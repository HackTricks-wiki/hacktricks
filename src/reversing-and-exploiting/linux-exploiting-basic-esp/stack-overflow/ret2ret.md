# Ret2ret & Reo2pop

{{#include ../../../banners/hacktricks-training.md}}

## Ret2ret

이 기술의 주요 목표는 **스택에 있는 기존 포인터를 악용하여 ASLR을 우회하려고 시도하는 것입니다**.

기본적으로, 스택 오버플로우는 일반적으로 문자열로 인해 발생하며, **문자열은 메모리의 끝에 널 바이트로 끝납니다**. 이는 스택에 이미 존재하는 포인터가 가리키는 위치를 줄이려고 시도할 수 있게 합니다. 따라서 스택에 `0xbfffffdd`가 포함되어 있다면, 이 오버플로우는 이를 `0xbfffff00`으로 변환할 수 있습니다(마지막 제로 바이트에 주목).

그 주소가 스택의 셸코드를 가리킨다면, **`ret` 명령어에 주소를 추가하여** 그 주소에 도달할 수 있습니다.

따라서 공격은 다음과 같이 진행됩니다:

- NOP 슬레드
- 셸코드
- **`ret`에 대한 주소로 EIP에서 스택을 덮어쓰기** (RET 슬레드)
- 문자열에 의해 추가된 0x00이 스택의 주소를 수정하여 NOP 슬레드를 가리키게 만듭니다.

[**이 링크**](https://github.com/florianhofhammer/stack-buffer-overflow-internship/blob/master/ASLR%20Smack%20and%20Laugh%20reference%20-%20Tilo%20Mueller/ret2ret.c)를 따라가면 취약한 바이너리의 예를 볼 수 있고, [**이 링크**](https://github.com/florianhofhammer/stack-buffer-overflow-internship/blob/master/ASLR%20Smack%20and%20Laugh%20reference%20-%20Tilo%20Mueller/ret2retexploit.c)에서는 익스플로잇을 볼 수 있습니다.

## Ret2pop

수정하고 싶지 않은 **완벽한 포인터를 스택에서 찾을 수 있는 경우** (ret2ret에서는 최종 최하위 바이트를 `0x00`으로 변경합니다), 동일한 `ret2ret` 공격을 수행할 수 있지만, **RET 슬레드의 길이는 1만큼 줄여야 합니다** (그래서 최종 `0x00`이 완벽한 포인터 바로 앞의 데이터를 덮어씁니다), 그리고 **RET 슬레드의 마지막** 주소는 **`pop <reg>; ret`**를 가리켜야 합니다.\
이렇게 하면 **완벽한 포인터 앞의 데이터가** 스택에서 제거됩니다 (이 데이터는 `0x00`의 영향을 받습니다) 그리고 **최종 `ret`는 스택의 완벽한 주소를 가리키게 됩니다**.

[**이 링크**](https://github.com/florianhofhammer/stack-buffer-overflow-internship/blob/master/ASLR%20Smack%20and%20Laugh%20reference%20-%20Tilo%20Mueller/ret2pop.c)를 따라가면 취약한 바이너리의 예를 볼 수 있고, [**이 링크**](https://github.com/florianhofhammer/stack-buffer-overflow-internship/blob/master/ASLR%20Smack%20and%20Laugh%20reference%20-%20Tilo%20Mueller/ret2popexploit.c)에서는 익스플로잇을 볼 수 있습니다.

## References

- [https://github.com/florianhofhammer/stack-buffer-overflow-internship/blob/master/NOTES.md](https://github.com/florianhofhammer/stack-buffer-overflow-internship/blob/master/NOTES.md)

{{#include ../../../banners/hacktricks-training.md}}
