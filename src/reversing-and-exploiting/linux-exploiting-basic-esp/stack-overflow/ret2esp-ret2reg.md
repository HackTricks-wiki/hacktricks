# Ret2esp / Ret2reg

{{#include ../../../banners/hacktricks-training.md}}

## **Ret2esp**

**Оскільки ESP (вказівник стеку) завжди вказує на верхню частину стеку**, ця техніка полягає в заміні EIP (вказівник інструкцій) адресою інструкції **`jmp esp`** або **`call esp`**. Таким чином, shellcode розміщується безпосередньо після переписаного EIP. Коли виконується інструкція `ret`, ESP вказує на наступну адресу, точно там, де зберігається shellcode.

Якщо **випадкове розташування адресного простору (ASLR)** не увімкнено в Windows або Linux, можна використовувати інструкції `jmp esp` або `call esp`, знайдені в спільних бібліотеках. Однак, з активним [**ASLR**](../common-binary-protections-and-bypasses/aslr/), можливо, доведеться шукати ці інструкції безпосередньо в уразливій програмі (і вам, можливо, потрібно буде подолати [**PIE**](../common-binary-protections-and-bypasses/pie/)).

Більше того, можливість розмістити shellcode **після корупції EIP**, а не посередині стеку, забезпечує, що будь-які інструкції `push` або `pop`, виконувані під час роботи функції, не заважатимуть shellcode. Це завада може статися, якщо shellcode буде розміщено посередині стеку функції.

### Брак місця

Якщо у вас недостатньо місця для запису після переписування RIP (можливо, лише кілька байтів), напишіть початковий shellcode `jmp`, наприклад:
```armasm
sub rsp, 0x30
jmp rsp
```
І напишіть shellcode на початку стеку.

### Приклад

Ви можете знайти приклад цієї техніки в [https://ir0nstone.gitbook.io/notes/types/stack/reliable-shellcode/using-rsp](https://ir0nstone.gitbook.io/notes/types/stack/reliable-shellcode/using-rsp) з фінальним експлойтом, як:
```python
from pwn import *

elf = context.binary = ELF('./vuln')
p = process()

jmp_rsp = next(elf.search(asm('jmp rsp')))

payload = b'A' * 120
payload += p64(jmp_rsp)
payload += asm('''
sub rsp, 10;
jmp rsp;
''')

pause()
p.sendlineafter('RSP!\n', payload)
p.interactive()
```
## Ret2reg

Аналогічно, якщо ми знаємо, що функція повертає адресу, де зберігається shellcode, ми можемо використовувати інструкції **`call eax`** або **`jmp eax`** (відомі як техніка **ret2eax**), що пропонує ще один спосіб виконати наш shellcode. Так само, як eax, **будь-який інший регістр**, що містить цікаву адресу, може бути використаний (**ret2reg**).

### Приклад

Ви можете знайти приклад тут: [https://ir0nstone.gitbook.io/notes/types/stack/reliable-shellcode/ret2reg/using-ret2reg](https://ir0nstone.gitbook.io/notes/types/stack/reliable-shellcode/ret2reg/using-ret2reg)

## Захист

- [**NX**](../common-binary-protections-and-bypasses/no-exec-nx.md): Якщо стек не є виконуваним, це не допоможе, оскільки нам потрібно помістити shellcode в стек і стрибнути для його виконання.
- [**ASLR**](../common-binary-protections-and-bypasses/aslr/) & [**PIE**](../common-binary-protections-and-bypasses/pie/): Це може ускладнити пошук інструкції для стрибка до esp або будь-якого іншого регістра.

## Посилання

- [https://ir0nstone.gitbook.io/notes/types/stack/reliable-shellcode](https://ir0nstone.gitbook.io/notes/types/stack/reliable-shellcode)
- [https://ir0nstone.gitbook.io/notes/types/stack/reliable-shellcode/using-rsp](https://ir0nstone.gitbook.io/notes/types/stack/reliable-shellcode/using-rsp)

{{#include ../../../banners/hacktricks-training.md}}
