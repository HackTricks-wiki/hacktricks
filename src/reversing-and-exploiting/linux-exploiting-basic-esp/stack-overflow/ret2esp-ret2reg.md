# Ret2esp / Ret2reg

{{#include ../../../banners/hacktricks-training.md}}

## **Ret2esp**

**Da der ESP (Stack Pointer) immer auf die Spitze des Stacks zeigt**, besteht diese Technik darin, den EIP (Instruction Pointer) mit der Adresse einer **`jmp esp`** oder **`call esp`** Anweisung zu ersetzen. Dadurch wird der Shellcode direkt nach dem überschriebenen EIP platziert. Wenn die `ret` Anweisung ausgeführt wird, zeigt ESP auf die nächste Adresse, genau dort, wo der Shellcode gespeichert ist.

Wenn **Address Space Layout Randomization (ASLR)** in Windows oder Linux nicht aktiviert ist, ist es möglich, `jmp esp` oder `call esp` Anweisungen in gemeinsam genutzten Bibliotheken zu verwenden. Mit aktivem [**ASLR**](../common-binary-protections-and-bypasses/aslr/) muss man jedoch möglicherweise innerhalb des anfälligen Programms nach diesen Anweisungen suchen (und man könnte [**PIE**](../common-binary-protections-and-bypasses/pie/) überwinden müssen).

Darüber hinaus stellt die Fähigkeit, den Shellcode **nach der EIP-Korruption** zu platzieren, anstatt in der Mitte des Stacks, sicher, dass keine `push` oder `pop` Anweisungen, die während des Betriebs der Funktion ausgeführt werden, mit dem Shellcode interferieren. Diese Interferenz könnte auftreten, wenn der Shellcode in der Mitte des Funktionsstacks platziert wird.

### Fehlender Platz

Wenn Ihnen der Platz fehlt, um nach dem Überschreiben von RIP zu schreiben (vielleicht nur ein paar Bytes), schreiben Sie einen anfänglichen `jmp` Shellcode wie:
```armasm
sub rsp, 0x30
jmp rsp
```
Und schreibe den Shellcode früh im Stack.

### Beispiel

Du kannst ein Beispiel für diese Technik in [https://ir0nstone.gitbook.io/notes/types/stack/reliable-shellcode/using-rsp](https://ir0nstone.gitbook.io/notes/types/stack/reliable-shellcode/using-rsp) mit einem finalen Exploit wie: finden.
```python
from pwn import *

elf = context.binary = ELF('./vuln')
p = process()

jmp_rsp = next(elf.search(asm('jmp rsp')))

payload = b'A' * 120
payload += p64(jmp_rsp)
payload += asm('''
sub rsp, 10;
jmp rsp;
''')

pause()
p.sendlineafter('RSP!\n', payload)
p.interactive()
```
## Ret2reg

Ähnlich, wenn wir wissen, dass eine Funktion die Adresse zurückgibt, an der der Shellcode gespeichert ist, können wir **`call eax`** oder **`jmp eax`** Anweisungen nutzen (bekannt als **ret2eax** Technik), was eine weitere Methode bietet, um unseren Shellcode auszuführen. Genau wie eax könnte **jedes andere Register**, das eine interessante Adresse enthält, verwendet werden (**ret2reg**).

### Beispiel

Sie können ein Beispiel hier finden: [https://ir0nstone.gitbook.io/notes/types/stack/reliable-shellcode/ret2reg/using-ret2reg](https://ir0nstone.gitbook.io/notes/types/stack/reliable-shellcode/ret2reg/using-ret2reg)

## Schutzmaßnahmen

- [**NX**](../common-binary-protections-and-bypasses/no-exec-nx.md): Wenn der Stack nicht ausführbar ist, hilft das nicht, da wir den Shellcode im Stack platzieren und springen müssen, um ihn auszuführen.
- [**ASLR**](../common-binary-protections-and-bypasses/aslr/) & [**PIE**](../common-binary-protections-and-bypasses/pie/): Diese können es erschweren, eine Anweisung zu finden, um zu esp oder einem anderen Register zu springen.

## Referenzen

- [https://ir0nstone.gitbook.io/notes/types/stack/reliable-shellcode](https://ir0nstone.gitbook.io/notes/types/stack/reliable-shellcode)
- [https://ir0nstone.gitbook.io/notes/types/stack/reliable-shellcode/using-rsp](https://ir0nstone.gitbook.io/notes/types/stack/reliable-shellcode/using-rsp)

{{#include ../../../banners/hacktricks-training.md}}
