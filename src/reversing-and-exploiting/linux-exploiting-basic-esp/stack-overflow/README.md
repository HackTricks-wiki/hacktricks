# Stack Overflow

{{#include ../../../banners/hacktricks-training.md}}

## Τι είναι το Stack Overflow

Ένα **stack overflow** είναι μια ευπάθεια που συμβαίνει όταν ένα πρόγραμμα γράφει περισσότερα δεδομένα στο stack από όσα έχει εκχωρηθεί να κρατήσει. Αυτά τα επιπλέον δεδομένα θα **επικαλύψουν γειτονικό χώρο μνήμης**, οδηγώντας σε διαφθορά έγκυρων δεδομένων, διαταραχή ροής ελέγχου και ενδεχομένως την εκτέλεση κακόβουλου κώδικα. Αυτό το ζήτημα προκύπτει συχνά λόγω της χρήσης μη ασφαλών συναρτήσεων που δεν εκτελούν έλεγχο ορίων στην είσοδο.

Το κύριο πρόβλημα αυτής της επικαλύψης είναι ότι ο **αποθηκευμένος δείκτης εντολών (EIP/RIP)** και ο **αποθηκευμένος δείκτης βάσης (EBP/RBP)** για να επιστρέψουν στην προηγούμενη συνάρτηση είναι **αποθηκευμένα στο stack**. Επομένως, ένας επιτιθέμενος θα είναι σε θέση να τα επικαλύψει και να **ελέγξει τη ροή εκτέλεσης του προγράμματος**.

Η ευπάθεια συνήθως προκύπτει επειδή μια συνάρτηση **αντιγράφει στο stack περισσότερα bytes από την ποσότητα που έχει εκχωρηθεί γι' αυτήν**, επομένως μπορεί να επικαλύψει άλλα μέρη του stack.\
Ορισμένες κοινές συναρτήσεις που είναι ευάλωτες σε αυτό είναι: `strcpy`, `strcat`, `sprintf`, `gets`... Επίσης, συναρτήσεις όπως `fgets` ή `read`, που δέχονται ένα όρισμα μήκους, μπορεί να χρησιμοποιηθούν με ευάλωτο τρόπο αν το καθορισμένο μήκος είναι μεγαλύτερο από το εκχωρημένο.

Για παράδειγμα, οι παρακάτω συναρτήσεις θα μπορούσαν να είναι ευάλωτες:
```c
void vulnerable() {
char buffer[128];
printf("Enter some text: ");
gets(buffer); // This is where the vulnerability lies
printf("You entered: %s\n", buffer);
}
```
### Εύρεση Σφαλμάτων Στοίβας

Ο πιο κοινός τρόπος για να βρείτε σφάλματα στοίβας είναι να δώσετε μια πολύ μεγάλη είσοδο από `A`s (π.χ. `python3 -c 'print("A"*1000)'`) και να περιμένετε ένα `Segmentation Fault` που υποδεικνύει ότι η **διεύθυνση `0x41414141` προσπαθήθηκε να προσπελαστεί**.

Επιπλέον, μόλις βρείτε ότι υπάρχει ευπάθεια Σφάλματος Στοίβας, θα χρειαστεί να βρείτε την απόσταση μέχρι να είναι δυνατό να **επικαλύψετε τη διεύθυνση επιστροφής**, για αυτό συνήθως χρησιμοποιείται μια **ακολουθία De Bruijn.** Η οποία για μια δεδομένη αλφάβητο μεγέθους _k_ και υποακολουθίες μήκους _n_ είναι μια **κυκλική ακολουθία στην οποία κάθε δυνατή υποακολουθία μήκους **_**n**_** εμφανίζεται ακριβώς μία φορά** ως συνεχής υποακολουθία.

Με αυτόν τον τρόπο, αντί να χρειάζεται να καταλάβετε ποια απόσταση είναι απαραίτητη για να ελέγξετε το EIP με το χέρι, είναι δυνατό να χρησιμοποιήσετε ως padding μία από αυτές τις ακολουθίες και στη συνέχεια να βρείτε την απόσταση των byte που τελείωσαν επικαλύπτοντάς το.

Είναι δυνατό να χρησιμοποιήσετε **pwntools** για αυτό:
```python
from pwn import *

# Generate a De Bruijn sequence of length 1000 with an alphabet size of 256 (byte values)
pattern = cyclic(1000)

# This is an example value that you'd have found in the EIP/IP register upon crash
eip_value = p32(0x6161616c)
offset = cyclic_find(eip_value)  # Finds the offset of the sequence in the De Bruijn pattern
print(f"The offset is: {offset}")
```
ή **GEF**:
```bash
#Patterns
pattern create 200 #Generate length 200 pattern
pattern search "avaaawaa" #Search for the offset of that substring
pattern search $rsp #Search the offset given the content of $rsp
```
## Εκμετάλλευση Στοίβας Υπερχείλισης

Κατά τη διάρκεια μιας υπερχείλισης (υποθέτοντας ότι το μέγεθος της υπερχείλισης είναι αρκετά μεγάλο) θα είστε σε θέση να επαναγράψετε τις τιμές των τοπικών μεταβλητών μέσα στη στοίβα μέχρι να φτάσετε στο αποθηκευμένο EBP/RBP και EIP/RIP (ή ακόμα περισσότερο).\
Ο πιο κοινός τρόπος για να εκμεταλλευτείτε αυτόν τον τύπο ευπάθειας είναι με το **να τροποποιήσετε τη διεύθυνση επιστροφής** έτσι ώστε όταν η συνάρτηση τελειώσει, η **ροή ελέγχου να ανακατευθυνθεί όπου έχει καθορίσει ο χρήστης** σε αυτόν τον δείκτη.

Ωστόσο, σε άλλα σενάρια, ίσως απλά **η επαναγραφή κάποιων τιμών μεταβλητών στη στοίβα** να είναι αρκετή για την εκμετάλλευση (όπως σε εύκολες προκλήσεις CTF).

### Ret2win

Σε αυτούς τους τύπους προκλήσεων CTF, υπάρχει μια **συνάρτηση** **μέσα** στο δυαδικό αρχείο που **ποτέ δεν καλείται** και που **πρέπει να καλέσετε για να κερδίσετε**. Για αυτές τις προκλήσεις, χρειάζεται απλώς να βρείτε την **απόσταση για να επαναγράψετε τη διεύθυνση επιστροφής** και **να βρείτε τη διεύθυνση της συνάρτησης** που θα καλέσετε (συνήθως [**ASLR**](../common-binary-protections-and-bypasses/aslr/index.html) θα είναι απενεργοποιημένο) έτσι ώστε όταν η ευάλωτη συνάρτηση επιστρέψει, η κρυφή συνάρτηση θα κληθεί:

{{#ref}}
ret2win.md
{{#endref}}

### Stack Shellcode

Σε αυτό το σενάριο, ο επιτιθέμενος θα μπορούσε να τοποθετήσει ένα shellcode στη στοίβα και να εκμεταλλευτεί το ελεγχόμενο EIP/RIP για να μεταπηδήσει στο shellcode και να εκτελέσει αυθαίρετο κώδικα:

{{#ref}}
stack-shellcode.md
{{#endref}}

## ROP

Αυτή η τεχνική είναι το θεμελιώδες πλαίσιο για να παρακαμφθεί η κύρια προστασία της προηγούμενης τεχνικής: **Μη εκτελέσιμη στοίβα** (NX). Και επιτρέπει την εκτέλεση αρκετών άλλων τεχνικών (ret2lib, ret2syscall...) που θα καταλήξουν να εκτελούν αυθαίρετες εντολές εκμεταλλευόμενοι υπάρχουσες εντολές στο δυαδικό αρχείο:

{{#ref}}
rop-return-oriented-programing.md
{{#endref}}

## Τύποι προστασιών

Υπάρχουν πολλές προστασίες που προσπαθούν να αποτρέψουν την εκμετάλλευση ευπαθειών, ελέγξτε τις στο:

{{#ref}}
../common-binary-protections-and-bypasses/
{{#endref}}

{{#include ../../../banners/hacktricks-training.md}}
