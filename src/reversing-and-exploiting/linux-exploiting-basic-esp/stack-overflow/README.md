# スタックオーバーフロー

{{#include ../../../banners/hacktricks-training.md}}

## スタックオーバーフローとは

**スタックオーバーフロー**は、プログラムがスタックに割り当てられたよりも多くのデータを書き込むときに発生する脆弱性です。この余分なデータは**隣接するメモリ空間を上書き**し、有効なデータの破損、制御フローの混乱、そして潜在的には悪意のあるコードの実行を引き起こします。この問題は、入力に対して境界チェックを行わない安全でない関数の使用によってしばしば発生します。

この上書きの主な問題は、**保存された命令ポインタ (EIP/RIP)** と**保存されたベースポインタ (EBP/RBP)** が前の関数に戻るために**スタックに保存されている**ことです。したがって、攻撃者はそれらを上書きし、**プログラムの実行フローを制御**できるようになります。

この脆弱性は通常、関数が**スタックに割り当てられたバイト数よりも多くのバイトをコピーする**ために発生し、他のスタックの部分を上書きできるようになります。\
このような脆弱性を持つ一般的な関数には、`strcpy`、`strcat`、`sprintf`、`gets`などがあります。また、長さ引数を取る`fgets`や`read`のような関数も、指定された長さが割り当てられたものより大きい場合に脆弱な方法で使用される可能性があります。

例えば、以下の関数が脆弱である可能性があります：
```c
void vulnerable() {
char buffer[128];
printf("Enter some text: ");
gets(buffer); // This is where the vulnerability lies
printf("You entered: %s\n", buffer);
}
```
### スタックオーバーフローの発見

スタックオーバーフローを見つける最も一般的な方法は、非常に大きな入力の`A`（例：`python3 -c 'print("A"*1000)'`）を与え、**アドレス`0x41414141`にアクセスしようとしたことを示す`Segmentation Fault`を期待することです**。

さらに、スタックオーバーフローの脆弱性があることがわかったら、**リターンアドレスを上書きするためのオフセットを見つける必要があります**。これには通常、**De Bruijn列**が使用されます。これは、サイズが_k_のアルファベットと長さ_n_の部分列に対して、**長さ**_**n**_**のすべての可能な部分列がちょうど1回ずつ連続した部分列として現れる**サイクリックシーケンスです。

この方法により、手動でEIPを制御するために必要なオフセットを特定する代わりに、これらのシーケンスの1つをパディングとして使用し、上書きされたバイトのオフセットを見つけることができます。

これには**pwntools**を使用することができます：
```python
from pwn import *

# Generate a De Bruijn sequence of length 1000 with an alphabet size of 256 (byte values)
pattern = cyclic(1000)

# This is an example value that you'd have found in the EIP/IP register upon crash
eip_value = p32(0x6161616c)
offset = cyclic_find(eip_value)  # Finds the offset of the sequence in the De Bruijn pattern
print(f"The offset is: {offset}")
```
または **GEF**:
```bash
#Patterns
pattern create 200 #Generate length 200 pattern
pattern search "avaaawaa" #Search for the offset of that substring
pattern search $rsp #Search the offset given the content of $rsp
```
## スタックオーバーフローの悪用

オーバーフロー中（オーバーフローサイズが十分大きいと仮定すると）、スタック内のローカル変数の値を上書きして、保存された EBP/RBP および EIP/RIP に到達することができます（さらにはそれ以上）。\
この種の脆弱性を悪用する最も一般的な方法は、**戻りアドレスを変更する**ことで、関数が終了するときに、**制御フローがこのポインタでユーザーが指定した場所にリダイレクトされる**ことです。

しかし、他のシナリオでは、スタック内の**いくつかの変数の値を上書きする**だけで、悪用が可能な場合もあります（簡単な CTF チャレンジのように）。

### Ret2win

この種の CTF チャレンジでは、**バイナリ内に** **決して呼び出されない** **関数**があり、**勝つために呼び出す必要があります**。これらのチャレンジでは、**戻りアドレスを上書きするオフセットを見つけ**、**呼び出す関数のアドレスを見つける**だけで済みます（通常、[**ASLR**](../common-binary-protections-and-bypasses/aslr/) は無効になります）ので、脆弱な関数が戻ると、隠れた関数が呼び出されます：

{{#ref}}
ret2win.md
{{#endref}}

### スタックシェルコード

このシナリオでは、攻撃者はスタックにシェルコードを配置し、制御された EIP/RIP を悪用してシェルコードにジャンプし、任意のコードを実行することができます：

{{#ref}}
stack-shellcode.md
{{#endref}}

## ROP

この技術は、前の技術の主要な保護を回避するための基本的なフレームワークです：**実行可能なスタックなし**（NX）。そして、既存の命令を悪用して任意のコマンドを実行する他のいくつかの技術（ret2lib、ret2syscall...）を実行することを可能にします：

{{#ref}}
rop-return-oriented-programing.md
{{#endref}}

## 保護の種類

脆弱性の悪用を防ぐためのいくつかの保護があります。詳細は以下を確認してください：

{{#ref}}
../common-binary-protections-and-bypasses/
{{#endref}}

{{#include ../../../banners/hacktricks-training.md}}
