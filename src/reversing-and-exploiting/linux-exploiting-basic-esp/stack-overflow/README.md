# Stack Overflow

{{#include ../../../banners/hacktricks-training.md}}

## What is a Stack Overflow

A **stack overflow** ni udhaifu unaotokea wakati programu inapoandika data zaidi kwenye stack kuliko ilivyopewa kushikilia. Data hii ya ziada it **andika nafasi ya kumbukumbu iliyo karibu**, ikisababisha uharibifu wa data halali, kuingiliwa kwa mtiririko wa udhibiti, na kwa uwezekano wa kutekeleza msimbo mbaya. Tatizo hili mara nyingi linatokea kutokana na matumizi ya kazi zisizo salama ambazo hazifanyi ukaguzi wa mipaka kwenye ingizo.

Tatizo kuu la kuandika tena ni kwamba **pointer ya maagizo iliyohifadhiwa (EIP/RIP)** na **pointer ya msingi iliyohifadhiwa (EBP/RBP)** za kurudi kwenye kazi ya awali zime **hifadhiwa kwenye stack**. Hivyo, mshambuliaji ataweza kuandika tena hizo na **kudhibiti mtiririko wa utekelezaji wa programu**.

Udhaifu huu kawaida hutokea kwa sababu kazi **inakopi ndani ya stack bytes zaidi kuliko kiasi kilichotengwa kwa ajili yake**, hivyo kuwa na uwezo wa kuandika tena sehemu nyingine za stack.\
Baadhi ya kazi za kawaida zinazoweza kuwa na udhaifu huu ni: `strcpy`, `strcat`, `sprintf`, `gets`... Pia, kazi kama `fgets` au `read`, ambazo zinachukua hoja ya urefu, zinaweza kutumika kwa njia hatarishi ikiwa urefu ulioelezwa ni mkubwa kuliko ule uliotengwa.

Kwa mfano, kazi zifuatazo zinaweza kuwa na udhaifu:
```c
void vulnerable() {
char buffer[128];
printf("Enter some text: ");
gets(buffer); // This is where the vulnerability lies
printf("You entered: %s\n", buffer);
}
```
### Kutafuta Stack Overflows

Njia ya kawaida zaidi ya kutafuta stack overflows ni kutoa ingizo kubwa la `A`s (kwa mfano `python3 -c 'print("A"*1000)'`) na kutarajia `Segmentation Fault` ikionyesha kwamba **anwani `0x41414141` ilijaribu kufikiwa**.

Zaidi ya hayo, mara tu unapogundua kwamba kuna udhaifu wa Stack Overflow utahitaji kutafuta offset hadi iwezekane **kufuta anwani ya kurudi**, kwa hili mara nyingi hutumiwa **De Bruijn sequence.** Ambayo kwa alfabeti iliyotolewa ya ukubwa _k_ na subsequences za urefu _n_ ni **mfuatano wa mzunguko ambapo kila subsequence inayowezekana ya urefu **_**n**_** inaonekana mara moja tu** kama subsequence iliyo karibu.

Kwa njia hii, badala ya kuhitaji kubaini ni offset ipi inahitajika kudhibiti EIP kwa mkono, inawezekana kutumia kama padding moja ya hizi sequences na kisha kutafuta offset ya bytes ambazo zilimaliza kufuta hiyo.

Inawezekana kutumia **pwntools** kwa hili:
```python
from pwn import *

# Generate a De Bruijn sequence of length 1000 with an alphabet size of 256 (byte values)
pattern = cyclic(1000)

# This is an example value that you'd have found in the EIP/IP register upon crash
eip_value = p32(0x6161616c)
offset = cyclic_find(eip_value)  # Finds the offset of the sequence in the De Bruijn pattern
print(f"The offset is: {offset}")
```
au **GEF**:
```bash
#Patterns
pattern create 200 #Generate length 200 pattern
pattern search "avaaawaa" #Search for the offset of that substring
pattern search $rsp #Search the offset given the content of $rsp
```
## Kutumia Stack Overflows

Wakati wa overflow (ikiwa saizi ya overflow ni kubwa vya kutosha) utaweza kubadilisha thamani za mabadiliko ya ndani ya stack hadi kufikia EBP/RBP na EIP/RIP zilizohifadhiwa (au hata zaidi).\
Njia ya kawaida zaidi ya kutumia aina hii ya udhaifu ni kwa **kubadilisha anwani ya kurudi** ili wakati kazi inamalizika **mchakato wa udhibiti utaelekezwa popote mtumiaji alivyobaini** katika kiashiria hiki.

Hata hivyo, katika hali nyingine labda tu **kubadilisha baadhi ya thamani za mabadiliko katika stack** inaweza kuwa ya kutosha kwa matumizi (kama katika changamoto rahisi za CTF).

### Ret2win

Katika aina hii ya changamoto za CTF, kuna **kazi** **ndani** ya binary ambayo **haitaitwa kamwe** na ambayo **unahitaji kuitwa ili kushinda**. Kwa ajili ya changamoto hizi unahitaji tu kupata **offset ya kubadilisha anwani ya kurudi** na **kupata anwani ya kazi** ya kuitwa (kawaida [**ASLR**](../common-binary-protections-and-bypasses/aslr/) itakuwa imezimwa) ili wakati kazi iliyo hatarini inarudi, kazi iliyofichwa itaitwa:

{{#ref}}
ret2win.md
{{#endref}}

### Stack Shellcode

Katika hali hii mshambuliaji anaweza kuweka shellcode katika stack na kutumia EIP/RIP iliyo na udhibiti kuruka kwenye shellcode na kutekeleza msimbo wa kiholela:

{{#ref}}
stack-shellcode.md
{{#endref}}

## ROP

Teknolojia hii ni mfumo wa msingi wa kupita ulinzi mkuu wa teknolojia iliyopita: **Stack isiyo na executable** (NX). Na inaruhusu kutekeleza mbinu kadhaa nyingine (ret2lib, ret2syscall...) ambazo zitamaliza kwa kutekeleza amri za kiholela kwa kutumia maagizo yaliyopo katika binary:

{{#ref}}
rop-return-oriented-programing.md
{{#endref}}

## Aina za ulinzi

Kuna ulinzi kadhaa zinazojaribu kuzuia matumizi ya udhaifu, angalia katika:

{{#ref}}
../common-binary-protections-and-bypasses/
{{#endref}}

{{#include ../../../banners/hacktricks-training.md}}
