# Stack Overflow

{{#include ../../../banners/hacktricks-training.md}}

## What is a Stack Overflow

A **stack overflow** एक सुरक्षा कमी है जो तब होती है जब एक प्रोग्राम स्टैक में उस डेटा से अधिक डेटा लिखता है जितना कि उसे रखने के लिए आवंटित किया गया है। यह अतिरिक्त डेटा **सन्निहित मेमोरी स्थान को ओवरराइट** करेगा, जिससे वैध डेटा का भ्रष्टाचार, नियंत्रण प्रवाह में विघटन, और संभावित रूप से दुर्भावनापूर्ण कोड का निष्पादन हो सकता है। यह समस्या अक्सर उन असुरक्षित कार्यों के उपयोग के कारण उत्पन्न होती है जो इनपुट पर सीमा जांच नहीं करते हैं।

इस ओवरराइट का मुख्य समस्या यह है कि **सहेजा गया निर्देश सूचक (EIP/RIP)** और **सहेजा गया बेस सूचक (EBP/RBP)** जो पिछले कार्य में लौटने के लिए होते हैं, **स्टैक पर संग्रहीत** होते हैं। इसलिए, एक हमलावर उन्हें ओवरराइट करने में सक्षम होगा और **प्रोग्राम के निष्पादन प्रवाह को नियंत्रित** कर सकेगा।

यह सुरक्षा कमी आमतौर पर इसलिए उत्पन्न होती है क्योंकि एक कार्य **स्टैक में आवंटित मात्रा से अधिक बाइट्स की कॉपी करता है**, जिससे अन्य स्टैक के हिस्सों को ओवरराइट करने में सक्षम होता है।\
इससे प्रभावित कुछ सामान्य कार्य हैं: `strcpy`, `strcat`, `sprintf`, `gets`... इसके अलावा, `fgets` या `read` जैसे कार्य, जो लंबाई तर्क लेते हैं, यदि निर्दिष्ट लंबाई आवंटित लंबाई से अधिक है तो एक संवेदनशील तरीके से उपयोग किए जा सकते हैं।

उदाहरण के लिए, निम्नलिखित कार्य संवेदनशील हो सकते हैं:
```c
void vulnerable() {
char buffer[128];
printf("Enter some text: ");
gets(buffer); // This is where the vulnerability lies
printf("You entered: %s\n", buffer);
}
```
### Stack Overflows ढूंढना

Stack overflows ढूंढने का सबसे सामान्य तरीका `A`s का बहुत बड़ा इनपुट देना है (जैसे `python3 -c 'print("A"*1000)'`) और एक `Segmentation Fault` की उम्मीद करना जो यह संकेत करता है कि **पता `0x41414141` को एक्सेस करने की कोशिश की गई थी**।

इसके अलावा, एक बार जब आप यह पता लगा लेते हैं कि Stack Overflow की कमजोरी है, तो आपको यह पता लगाने की आवश्यकता होगी कि **रिटर्न एड्रेस को ओवरराइट करने के लिए कितना ऑफसेट चाहिए**, इसके लिए आमतौर पर एक **De Bruijn अनुक्रम** का उपयोग किया जाता है। जो एक दिए गए वर्णमाला के आकार _k_ और लंबाई _n_ के उप अनुक्रमों के लिए एक **चक्रीय अनुक्रम है जिसमें लंबाई **_**n**_** के हर संभव उप अनुक्रम एक बार ही दिखाई देता है** एक सन्निकटन उप अनुक्रम के रूप में।

इस तरह, EIP को नियंत्रित करने के लिए आवश्यक ऑफसेट को हाथ से पता लगाने के बजाय, इन अनुक्रमों में से एक को पैडिंग के रूप में उपयोग करना संभव है और फिर उन बाइट्स का ऑफसेट ढूंढना जो इसे ओवरराइट करने के बाद समाप्त हो गए।

इसके लिए **pwntools** का उपयोग करना संभव है:
```python
from pwn import *

# Generate a De Bruijn sequence of length 1000 with an alphabet size of 256 (byte values)
pattern = cyclic(1000)

# This is an example value that you'd have found in the EIP/IP register upon crash
eip_value = p32(0x6161616c)
offset = cyclic_find(eip_value)  # Finds the offset of the sequence in the De Bruijn pattern
print(f"The offset is: {offset}")
```
या **GEF**:
```bash
#Patterns
pattern create 200 #Generate length 200 pattern
pattern search "avaaawaa" #Search for the offset of that substring
pattern search $rsp #Search the offset given the content of $rsp
```
## स्टैक ओवरफ्लोज़ का शोषण

एक ओवरफ्लो के दौरान (मान लेते हैं कि ओवरफ्लो का आकार पर्याप्त बड़ा है) आप स्टैक के अंदर स्थानीय चर के मानों को ओवरराइट करने में सक्षम होंगे जब तक कि सहेजे गए EBP/RBP और EIP/RIP तक नहीं पहुँचते (या इससे भी अधिक)।\
इस प्रकार की भेद्यता का दुरुपयोग करने का सबसे सामान्य तरीका है **रिटर्न पते को संशोधित करना** ताकि जब फ़ंक्शन समाप्त हो, तो **नियंत्रण प्रवाह उस पते पर पुनर्निर्देशित हो जाए जो उपयोगकर्ता ने निर्दिष्ट किया है**।

हालांकि, अन्य परिदृश्यों में केवल **स्टैक में कुछ चर के मानों को ओवरराइट करना** शोषण के लिए पर्याप्त हो सकता है (जैसे आसान CTF चुनौतियों में)।

### Ret2win

इस प्रकार की CTF चुनौतियों में, बाइनरी के अंदर एक **फंक्शन** है जो **कभी नहीं बुलाया जाता** और जिसे **आपको जीतने के लिए बुलाना होगा**। इन चुनौतियों के लिए आपको केवल **रिटर्न पते को ओवरराइट करने के लिए ऑफसेट** ढूंढना है और **बुलाने के लिए फंक्शन का पता** लगाना है (आमतौर पर [**ASLR**](../common-binary-protections-and-bypasses/aslr/index.html) अक्षम होगा) ताकि जब संवेदनशील फ़ंक्शन लौटे, तो छिपा हुआ फ़ंक्शन बुलाया जाए:

{{#ref}}
ret2win.md
{{#endref}}

### स्टैक शेलकोड

इस परिदृश्य में हमलावर स्टैक में एक शेलकोड रख सकता है और नियंत्रित EIP/RIP का दुरुपयोग करके शेलकोड पर कूद सकता है और मनमाने कोड को निष्पादित कर सकता है:

{{#ref}}
stack-shellcode.md
{{#endref}}

## ROP

यह तकनीक मुख्य सुरक्षा को बायपास करने के लिए मौलिक ढांचा है: **कोई निष्पादन योग्य स्टैक नहीं** (NX)। और यह कई अन्य तकनीकों (ret2lib, ret2syscall...) को निष्पादित करने की अनुमति देता है जो बाइनरी में मौजूदा निर्देशों का दुरुपयोग करके मनमाने आदेशों को निष्पादित करेंगे:

{{#ref}}
rop-return-oriented-programing.md
{{#endref}}

## सुरक्षा के प्रकार

भेद्यताओं के शोषण को रोकने के लिए कई सुरक्षा उपाय हैं, उन्हें देखें:

{{#ref}}
../common-binary-protections-and-bypasses/
{{#endref}}

{{#include ../../../banners/hacktricks-training.md}}
