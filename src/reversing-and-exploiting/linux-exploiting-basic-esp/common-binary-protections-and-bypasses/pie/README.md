# PIE

{{#include ../../../../banners/hacktricks-training.md}}

## 기본 정보

PIE로 컴파일된 바이너리는 **위치 독립 실행 파일**을 의미하며, **프로그램이 실행될 때마다 다른 메모리 위치에 로드될 수 있습니다**, 하드코딩된 주소를 방지합니다.

이러한 바이너리를 악용하는 요령은 **상대 주소**를 이용하는 것입니다. 프로그램의 부분 간의 오프셋은 절대 위치가 변경되더라도 동일하게 유지됩니다. **PIE를 우회하려면 하나의 주소를 유출하기만 하면 됩니다**, 일반적으로 포맷 문자열 공격과 같은 취약점을 사용하여 **스택**에서 유출합니다. 주소를 하나 확보하면 **고정 오프셋**을 통해 다른 주소를 계산할 수 있습니다.

PIE 바이너리를 악용하는 데 유용한 힌트는 그들의 **기본 주소가 일반적으로 000으로 끝난다는 것입니다**, 이는 메모리 페이지가 무작위화의 단위로 0x1000 바이트 크기이기 때문입니다. 이 정렬은 **익스플로잇이 예상대로 작동하지 않을 경우** 중요한 **확인 사항**이 될 수 있으며, 올바른 기본 주소가 식별되었는지를 나타냅니다.\
또는 익스플로잇에 사용할 수 있습니다. 주소가 **`0x649e1024`**에 위치해 있다고 유출되면, **기본 주소는 `0x649e1000`**이라는 것을 알 수 있으며, 거기서 함수와 위치의 **오프셋을 계산**할 수 있습니다.

## 우회 방법

PIE를 우회하려면 **로드된** 바이너리의 주소를 **유출해야** 합니다. 이를 위한 몇 가지 옵션이 있습니다:

- **ASLR 비활성화**: ASLR이 비활성화되면 PIE로 컴파일된 바이너리는 항상 **같은 주소에 로드됩니다**, 따라서 **PIE는 쓸모가 없게 됩니다**. 객체의 주소는 항상 같은 위치에 있게 됩니다.
- 유출을 **제공받기** (쉬운 CTF 챌린지에서 일반적, [**이 예시를 확인하세요**](https://ir0nstone.gitbook.io/notes/types/stack/pie/pie-exploit))
- **스택에서 EBP와 EIP 값을 무작위로 시도**하여 올바른 값을 유출할 때까지:

{{#ref}}
bypassing-canary-and-pie.md
{{#endref}}

- [**포맷 문자열**](../../format-strings/)과 같은 임의 읽기 취약점을 사용하여 바이너리의 주소를 유출합니다 (예: 이전 기술처럼 스택에서) 바이너리의 기본 주소를 얻고 거기서 오프셋을 사용합니다. [**여기에서 예시를 찾으세요**](https://ir0nstone.gitbook.io/notes/types/stack/pie/pie-bypass).

## 참고 자료

- [https://ir0nstone.gitbook.io/notes/types/stack/pie](https://ir0nstone.gitbook.io/notes/types/stack/pie)

{{#include ../../../../banners/hacktricks-training.md}}
