# Stap Canaries

{{#include ../../../../banners/hacktricks-training.md}}

## **StackGuard en StackShield**

**StackGuard** voeg 'n spesiale waarde bekend as 'n **canary** voor die **EIP (Extended Instruction Pointer)** in, spesifiek `0x000aff0d` (wat null, newline, EOF, carriage return verteenwoordig) om teen buffer oorgroeis te beskerm. Tog bly funksies soos `recv()`, `memcpy()`, `read()`, en `bcopy()` kwesbaar, en dit beskerm nie die **EBP (Base Pointer)** nie.

**StackShield** neem 'n meer gesofistikeerde benadering as StackGuard deur 'n **Global Return Stack** te handhaaf, wat alle terugkeer adresse (**EIPs**) stoor. Hierdie opstelling verseker dat enige oorgroei nie skade aanrig nie, aangesien dit 'n vergelyking tussen gestoor en werklike terugkeer adresse toelaat om oorgroei voorvalle te ontdek. Boonop kan StackShield die terugkeer adres teen 'n grenswaarde nagaan om te bepaal of die **EIP** buite die verwagte dataruimte wys. Tog kan hierdie beskerming omseil word deur tegnieke soos Return-to-libc, ROP (Return-Oriented Programming), of ret2ret, wat aandui dat StackShield ook nie plaaslike veranderlikes beskerm nie.

## **Stack Smash Protector (ProPolice) `-fstack-protector`:**

Hierdie meganisme plaas 'n **canary** voor die **EBP**, en reorganiseer plaaslike veranderlikes om buffers op hoër geheue adresse te posisioneer, wat voorkom dat hulle ander veranderlikes oorskry. Dit kopieer ook veilig argumente wat op die stap bo plaaslike veranderlikes oorgedra word en gebruik hierdie kopieë as argumente. Tog beskerm dit nie arrays met minder as 8 elemente of buffers binne 'n gebruiker se struktuur nie.

Die **canary** is 'n ewekansige getal wat afgelei is van `/dev/urandom` of 'n standaardwaarde van `0xff0a0000`. Dit word gestoor in **TLS (Thread Local Storage)**, wat gedeelde geheue ruimtes oor threads toelaat om thread-spesifieke globale of statiese veranderlikes te hê. Hierdie veranderlikes word aanvanklik van die ouer proses gekopieer, en kind proses kan hul data verander sonder om die ouer of broers en susters te beïnvloed. Nietemin, as 'n **`fork()` gebruik word sonder om 'n nuwe canary te skep, deel alle prosesse (ouer en kinders) dieselfde canary**, wat dit kwesbaar maak. Op die **i386** argitektuur, word die canary gestoor by `gs:0x14`, en op **x86_64**, by `fs:0x28`.

Hierdie plaaslike beskerming identifiseer funksies met buffers wat kwesbaar is vir aanvalle en spuit kode aan die begin van hierdie funksies om die canary te plaas, en aan die einde om sy integriteit te verifieer.

Wanneer 'n webbediener `fork()` gebruik, stel dit 'n brute-force aanval in staat om die canary byte vir byte te raai. Tog, die gebruik van `execve()` na `fork()` oorskry die geheue ruimte, wat die aanval ontken. `vfork()` laat die kind proses toe om uit te voer sonder duplisering totdat dit probeer om te skryf, op watter punt 'n duplikaat geskep word, wat 'n ander benadering tot proses skepping en geheue hantering bied.

### Lengtes

In `x64` binaries, is die canary koekie 'n **`0x8`** byte qword. Die **eerste sewe bytes is ewekansig** en die laaste byte is 'n **null byte.**

In `x86` binaries, is die canary koekie 'n **`0x4`** byte dword. Die **eerste drie bytes is ewekansig** en die laaste byte is 'n **null byte.**

> [!CAUTION]
> Die minste betekenisvolle byte van beide canaries is 'n null byte omdat dit die eerste in die stap sal wees wat van laer adresse kom en daarom **sal funksies wat strings lees stop voordat hulle dit lees**.

## Omseilings

**Lek die canary** en oorskry dit dan (bv. buffer overflow) met sy eie waarde.

- As die **canary in kind prosesse gefork is** kan dit moontlik wees om dit **brute-force** een byte op 'n slag:

{{#ref}}
bf-forked-stack-canaries.md
{{#endref}}

- As daar 'n interessante **lek of arbitrêre lees kwesbaarheid** in die binêre is, kan dit moontlik wees om dit te lek:

{{#ref}}
print-stack-canary.md
{{#endref}}

- **Oorskry stack gestoor pointers**

Die stap wat kwesbaar is vir 'n stap oorgroei mag **adresse na strings of funksies bevat wat oorgeskryf kan word** om die kwesbaarheid te benut sonder om die stap canary te bereik. Kontroleer:

{{#ref}}
../../stack-overflow/pointer-redirecting.md
{{#endref}}

- **Wysig beide meester en thread canary**

'n Buffer oorgroei in 'n gedrade funksie wat met canary beskerm word, kan gebruik word om die meester canary van die thread te wysig. As gevolg hiervan is die versagting nutteloos omdat die kontrole met twee canaries wat dieselfde is (alhoewel gewysig) gebruik word.

- **Wysig die GOT inskrywing van `__stack_chk_fail`**

As die binêre Partial RELRO het, kan jy 'n arbitrêre skrywe gebruik om die GOT inskrywing van `__stack_chk_fail` te wysig om 'n dummy funksie te wees wat nie die program blokkeer as die canary gewysig word nie.

## Verwysings

- [https://guyinatuxedo.github.io/7.1-mitigation_canary/index.html](https://guyinatuxedo.github.io/7.1-mitigation_canary/index.html)
- [http://7rocky.github.io/en/ctf/htb-challenges/pwn/robot-factory/#canaries-and-threads](http://7rocky.github.io/en/ctf/htb-challenges/pwn/robot-factory/#canaries-and-threads)
- 64 bits, geen PIE, nx, wysig thread en meester canary.
- [https://7rocky.github.io/en/ctf/other/securinets-ctf/scrambler/](https://7rocky.github.io/en/ctf/other/securinets-ctf/scrambler/)
- 64 bits, geen PIE, nx, write-what-where primitive. Wysig GOT inskrywing van `__stack_chk_fail`.

{{#include ../../../../banners/hacktricks-training.md}}
