# Stack Canaries

{{#include ../../../../banners/hacktricks-training.md}}

## **StackGuard ve StackShield**

**StackGuard**, **EIP (Genişletilmiş Talimat İşaretçisi)**'nden önce, özellikle `0x000aff0d` (null, yeni satır, EOF, taşıma dönüşü temsil eder) olarak bilinen özel bir değeri **canary** olarak ekler ve bu, tampon taşmalarına karşı koruma sağlar. Ancak, `recv()`, `memcpy()`, `read()` ve `bcopy()` gibi fonksiyonlar hala savunmasızdır ve **EBP (Temel İşaretçi)**'yi korumaz.

**StackShield**, tüm dönüş adreslerini (**EIP'ler**) saklayan bir **Küresel Dönüş Yığını** tutarak StackGuard'dan daha sofistike bir yaklaşım benimser. Bu yapı, herhangi bir taşmanın zarar vermemesini sağlar, çünkü saklanan ve gerçek dönüş adresleri arasında bir karşılaştırma yapılmasına olanak tanır ve taşma durumlarını tespit eder. Ayrıca, StackShield, dönüş adresini bir sınır değeri ile kontrol ederek **EIP**'nin beklenen veri alanının dışına işaret edip etmediğini tespit edebilir. Ancak, bu koruma, Return-to-libc, ROP (Dönüş-İlişkili Programlama) veya ret2ret gibi tekniklerle aşılabilir, bu da StackShield'in yerel değişkenleri de korumadığı anlamına gelir.

## **Stack Smash Protector (ProPolice) `-fstack-protector`:**

Bu mekanizma, **EBP**'den önce bir **canary** yerleştirir ve yerel değişkenleri daha yüksek bellek adreslerinde konumlandıracak şekilde yeniden düzenler, böylece diğer değişkenleri yazmalarını engeller. Ayrıca, yerel değişkenlerin üzerinde yığılan argümanları güvenli bir şekilde kopyalar ve bu kopyaları argüman olarak kullanır. Ancak, 8'den az eleman içeren dizileri veya bir kullanıcının yapısı içindeki tamponları korumaz.

**Canary**, `/dev/urandom`'dan türetilen rastgele bir sayıdır veya varsayılan değeri `0xff0a0000`'dir. **TLS (İş Parçacığı Yerel Depolama)**'da saklanır, bu da iş parçacıkları arasında paylaşılan bellek alanlarının iş parçacığına özgü küresel veya statik değişkenlere sahip olmasını sağlar. Bu değişkenler başlangıçta ana süreçten kopyalanır ve çocuk süreçler, ana veya kardeşleri etkilemeden verilerini değiştirebilir. Ancak, eğer bir **`fork()` yeni bir canary oluşturmadan kullanılırsa, tüm süreçler (ana ve çocuklar) aynı canary'yi paylaşır**, bu da onu savunmasız hale getirir. **i386** mimarisinde, canary `gs:0x14`'te, **x86_64**'de ise `fs:0x28`'de saklanır.

Bu yerel koruma, saldırılara karşı savunmasız tamponlara sahip fonksiyonları tanımlar ve bu fonksiyonların başına canary yerleştirmek için kod enjekte eder ve sonunda bütünlüğünü doğrulamak için kod ekler.

Bir web sunucusu `fork()` kullandığında, canary'yi byte byte tahmin etmek için bir kaba kuvvet saldırısını etkinleştirir. Ancak, `fork()`'tan sonra `execve()` kullanmak bellek alanını yazdığı için saldırıyı geçersiz kılar. `vfork()`, çocuk sürecin yazma girişiminde bulunana kadar kopyalamadan çalışmasına izin verir; bu noktada bir kopya oluşturulur ve süreç oluşturma ve bellek yönetimi için farklı bir yaklaşım sunar.

### Uzunluklar

`x64` ikili dosyalarında, canary çerezi bir **`0x8`** byte qword'dur. **İlk yedi byte rastgeledir** ve son byte bir **null byte**'dır.

`x86` ikili dosyalarında, canary çerezi bir **`0x4`** byte dword'dur. **İlk üç byte rastgeledir** ve son byte bir **null byte**'dır.

> [!CAUTION]
> Her iki canary'nin en az anlamlı byte'ı bir null byte'dır çünkü bu, daha düşük adreslerden gelen yığında ilk olacak ve bu nedenle **string okuyan fonksiyonlar onu okumadan önce duracaktır**.

## Bypass'ler

**Canary'yi sızdırmak** ve ardından kendi değeriyle (örneğin, tampon taşması) üzerine yazmak.

- Eğer **canary çocuk süreçlerde fork edilirse**, bir byte bir seferde **brute-force** yapmak mümkün olabilir:

{{#ref}}
bf-forked-stack-canaries.md
{{#endref}}

- İkili dosyada ilginç bir **sızıntı veya keyfi okuma açığı** varsa, onu sızdırmak mümkün olabilir:

{{#ref}}
print-stack-canary.md
{{#endref}}

- **Yığın üzerinde saklanan işaretçileri üzerine yazma**

Yığın, bir yığın taşmasına karşı savunmasızsa, **aşılabilecek string veya fonksiyon adreslerini içerebilir**. Kontrol et:

{{#ref}}
../../stack-overflow/pointer-redirecting.md
{{#endref}}

- **Hem ana hem de iş parçacığı canary'sini değiştirme**

Canary ile korunan bir iş parçacıklı fonksiyondaki bir tampon taşması, iş parçacığının ana canary'sini değiştirmek için kullanılabilir. Sonuç olarak, bu önlem işe yaramaz çünkü kontrol, aynı (değiştirilmiş) iki canary ile kullanılır.

- **`__stack_chk_fail` GOT girişini değiştirme**

Eğer ikili dosya Kısmi RELRO'ya sahipse, o zaman canary değiştiğinde programı engellemeyen sahte bir fonksiyon olacak şekilde `__stack_chk_fail`'in GOT girişini değiştirmek için keyfi bir yazma kullanabilirsiniz.

## Referanslar

- [https://guyinatuxedo.github.io/7.1-mitigation_canary/index.html](https://guyinatuxedo.github.io/7.1-mitigation_canary/index.html)
- [http://7rocky.github.io/en/ctf/htb-challenges/pwn/robot-factory/#canaries-and-threads](http://7rocky.github.io/en/ctf/htb-challenges/pwn/robot-factory/#canaries-and-threads)
- 64 bit, PIE yok, nx, iş parçacığı ve ana canary'yi değiştir.
- [https://7rocky.github.io/en/ctf/other/securinets-ctf/scrambler/](https://7rocky.github.io/en/ctf/other/securinets-ctf/scrambler/)
- 64 bit, PIE yok, nx, write-what-where primitive. `__stack_chk_fail`'in GOT girişini değiştir.

{{#include ../../../../banners/hacktricks-training.md}}
