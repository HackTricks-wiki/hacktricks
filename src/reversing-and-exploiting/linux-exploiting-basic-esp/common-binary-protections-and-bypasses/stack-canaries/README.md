# Stack Canaries

{{#include ../../../../banners/hacktricks-training.md}}

## **StackGuard et StackShield**

**StackGuard** insère une valeur spéciale connue sous le nom de **canary** avant le **EIP (Extended Instruction Pointer)**, spécifiquement `0x000aff0d` (représentant null, newline, EOF, carriage return) pour se protéger contre les débordements de tampon. Cependant, des fonctions comme `recv()`, `memcpy()`, `read()`, et `bcopy()` restent vulnérables, et cela ne protège pas le **EBP (Base Pointer)**.

**StackShield** adopte une approche plus sophistiquée que StackGuard en maintenant une **Global Return Stack**, qui stocke toutes les adresses de retour (**EIPs**). Cette configuration garantit qu'un débordement ne cause pas de dommages, car elle permet une comparaison entre les adresses de retour stockées et réelles pour détecter les occurrences de débordement. De plus, StackShield peut vérifier l'adresse de retour par rapport à une valeur limite pour détecter si le **EIP** pointe en dehors de l'espace de données attendu. Cependant, cette protection peut être contournée par des techniques comme Return-to-libc, ROP (Return-Oriented Programming), ou ret2ret, indiquant que StackShield ne protège également pas les variables locales.

## **Stack Smash Protector (ProPolice) `-fstack-protector`:**

Ce mécanisme place un **canary** avant le **EBP**, et réorganise les variables locales pour positionner les tampons à des adresses mémoire plus élevées, les empêchant d'écraser d'autres variables. Il copie également en toute sécurité les arguments passés sur la pile au-dessus des variables locales et utilise ces copies comme arguments. Cependant, il ne protège pas les tableaux de moins de 8 éléments ou les tampons dans une structure utilisateur.

Le **canary** est un nombre aléatoire dérivé de `/dev/urandom` ou d'une valeur par défaut de `0xff0a0000`. Il est stocké dans **TLS (Thread Local Storage)**, permettant aux espaces mémoire partagés entre les threads d'avoir des variables globales ou statiques spécifiques au thread. Ces variables sont initialement copiées à partir du processus parent, et les processus enfants peuvent modifier leurs données sans affecter le parent ou les frères et sœurs. Néanmoins, si un **`fork()` est utilisé sans créer un nouveau canary, tous les processus (parent et enfants) partagent le même canary**, le rendant vulnérable. Sur l'architecture **i386**, le canary est stocké à `gs:0x14`, et sur **x86_64**, à `fs:0x28`.

Cette protection locale identifie les fonctions avec des tampons vulnérables aux attaques et injecte du code au début de ces fonctions pour placer le canary, et à la fin pour vérifier son intégrité.

Lorsqu'un serveur web utilise `fork()`, il permet une attaque par force brute pour deviner le canary octet par octet. Cependant, l'utilisation de `execve()` après `fork()` écrase l'espace mémoire, annulant l'attaque. `vfork()` permet au processus enfant de s'exécuter sans duplication jusqu'à ce qu'il tente d'écrire, moment auquel un duplicata est créé, offrant une approche différente pour la création de processus et la gestion de la mémoire.

### Longueurs

Dans les binaires `x64`, le cookie canary est un **`0x8`** byte qword. Les **sept premiers octets sont aléatoires** et le dernier octet est un **octet nul.**

Dans les binaires `x86`, le cookie canary est un **`0x4`** byte dword. Les **trois premiers octets sont aléatoires** et le dernier octet est un **octet nul.**

> [!CAUTION]
> L'octet de poids faible des deux canaries est un octet nul car il sera le premier dans la pile venant d'adresses inférieures et donc **les fonctions qui lisent des chaînes s'arrêteront avant de le lire**.

## Contournements

**Fuir le canary** puis l'écraser (par exemple, débordement de tampon) avec sa propre valeur.

- Si le **canary est forké dans des processus enfants**, il pourrait être possible de **brute-forcer** un octet à la fois :

{{#ref}}
bf-forked-stack-canaries.md
{{#endref}}

- S'il y a une **fuite intéressante ou une vulnérabilité de lecture arbitraire** dans le binaire, il pourrait être possible de le fuir :

{{#ref}}
print-stack-canary.md
{{#endref}}

- **Écraser les pointeurs stockés sur la pile**

La pile vulnérable à un débordement de pile pourrait **contenir des adresses de chaînes ou de fonctions qui peuvent être écrasées** afin d'exploiter la vulnérabilité sans avoir besoin d'atteindre le canary de la pile. Vérifiez :

{{#ref}}
../../stack-overflow/pointer-redirecting.md
{{#endref}}

- **Modifier à la fois le canary maître et le canary de thread**

Un débordement de tampon dans une fonction threadée protégée par un canary peut être utilisé pour modifier le canary maître du thread. En conséquence, l'atténuation est inutile car la vérification est effectuée avec deux canaries qui sont les mêmes (bien que modifiés).

- **Modifier l'entrée GOT de `__stack_chk_fail`**

Si le binaire a un RELRO partiel, alors vous pouvez utiliser une écriture arbitraire pour modifier l'entrée GOT de `__stack_chk_fail` pour être une fonction factice qui ne bloque pas le programme si le canary est modifié.

## Références

- [https://guyinatuxedo.github.io/7.1-mitigation_canary/index.html](https://guyinatuxedo.github.io/7.1-mitigation_canary/index.html)
- [http://7rocky.github.io/en/ctf/htb-challenges/pwn/robot-factory/#canaries-and-threads](http://7rocky.github.io/en/ctf/htb-challenges/pwn/robot-factory/#canaries-and-threads)
- 64 bits, pas de PIE, nx, modifier le canary de thread et maître.
- [https://7rocky.github.io/en/ctf/other/securinets-ctf/scrambler/](https://7rocky.github.io/en/ctf/other/securinets-ctf/scrambler/)
- 64 bits, pas de PIE, nx, primitive write-what-where. Modifier l'entrée GOT de `__stack_chk_fail`.

{{#include ../../../../banners/hacktricks-training.md}}
