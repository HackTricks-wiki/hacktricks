# Stack Canaries

{{#include ../../../../banners/hacktricks-training.md}}

## **StackGuard 和 StackShield**

**StackGuard** 在 **EIP (扩展指令指针)** 之前插入一个特殊值，称为 **canary**，具体为 `0x000aff0d`（表示空值、换行符、EOF、回车）以防止缓冲区溢出。然而，像 `recv()`、`memcpy()`、`read()` 和 `bcopy()` 这样的函数仍然存在漏洞，并且它不保护 **EBP (基指针)**。

**StackShield** 采用比 StackGuard 更复杂的方法，通过维护一个 **全局返回栈**，存储所有返回地址 (**EIPs**)。这种设置确保任何溢出不会造成伤害，因为它允许比较存储的和实际的返回地址以检测溢出发生。此外，StackShield 可以检查返回地址与边界值的关系，以检测 **EIP** 是否指向预期数据空间之外。然而，这种保护可以通过 Return-to-libc、ROP（面向返回的编程）或 ret2ret 等技术绕过，这表明 StackShield 也不保护局部变量。

## **Stack Smash Protector (ProPolice) `-fstack-protector`:**

该机制在 **EBP** 之前放置一个 **canary**，并重新组织局部变量以将缓冲区放置在更高的内存地址，从而防止它们覆盖其他变量。它还安全地复制传递到栈上的参数，并使用这些副本作为参数。然而，它不保护少于 8 个元素的数组或用户结构中的缓冲区。

**canary** 是从 `/dev/urandom` 派生的随机数或默认值 `0xff0a0000`。它存储在 **TLS (线程局部存储)** 中，允许跨线程共享内存空间具有线程特定的全局或静态变量。这些变量最初从父进程复制，子进程可以在不影响父进程或兄弟进程的情况下更改其数据。然而，如果 **`fork()` 在不创建新 canary 的情况下使用，所有进程（父进程和子进程）共享相同的 canary**，使其变得脆弱。在 **i386** 架构中，canary 存储在 `gs:0x14`，在 **x86_64** 中，存储在 `fs:0x28`。

这种本地保护识别具有缓冲区的函数，这些缓冲区易受攻击，并在这些函数的开头注入代码以放置 canary，在结尾验证其完整性。

当 Web 服务器使用 `fork()` 时，它允许通过逐字节猜测 canary 字节进行暴力攻击。然而，在 `fork()` 之后使用 `execve()` 会覆盖内存空间，从而消除攻击。`vfork()` 允许子进程在尝试写入之前执行而不进行复制，此时会创建一个副本，提供了一种不同的进程创建和内存处理方法。

### 长度

在 `x64` 二进制文件中，canary cookie 是一个 **`0x8`** 字节的 qword。**前七个字节是随机的**，最后一个字节是 **空字节**。

在 `x86` 二进制文件中，canary cookie 是一个 **`0x4`** 字节的 dword。**前三个字节是随机的**，最后一个字节是 **空字节**。

> [!CAUTION]
> 两个 canary 的最低有效字节是空字节，因为它将是来自较低地址的栈中的第一个，因此 **读取字符串的函数将在读取之前停止**。

## 绕过

**泄露 canary** 然后用其自身的值覆盖它（例如，缓冲区溢出）。

- 如果 **canary 在子进程中被 fork**，可能可以 **逐字节暴力破解** 它：

{{#ref}}
bf-forked-stack-canaries.md
{{#endref}}

- 如果二进制文件中存在一些有趣的 **泄露或任意读取漏洞**，可能可以泄露它：

{{#ref}}
print-stack-canary.md
{{#endref}}

- **覆盖栈存储的指针**

易受栈溢出影响的栈可能 **包含可以被覆盖的字符串或函数的地址**，以利用该漏洞而无需到达栈 canary。检查：

{{#ref}}
../../stack-overflow/pointer-redirecting.md
{{#endref}}

- **修改主 canary 和线程 canary**

在受 canary 保护的线程函数中的缓冲区溢出可以用来修改线程的主 canary。因此，缓解措施是无效的，因为检查是使用两个相同的（尽管已修改）canary。

- **修改 `__stack_chk_fail` 的 GOT 条目**

如果二进制文件具有部分 RELRO，则可以使用任意写入修改 `__stack_chk_fail` 的 GOT 条目，使其成为一个不会阻止程序的虚拟函数，如果 canary 被修改。

## 参考

- [https://guyinatuxedo.github.io/7.1-mitigation_canary/index.html](https://guyinatuxedo.github.io/7.1-mitigation_canary/index.html)
- [http://7rocky.github.io/en/ctf/htb-challenges/pwn/robot-factory/#canaries-and-threads](http://7rocky.github.io/en/ctf/htb-challenges/pwn/robot-factory/#canaries-and-threads)
- 64 位，无 PIE，nx，修改线程和主 canary。
- [https://7rocky.github.io/en/ctf/other/securinets-ctf/scrambler/](https://7rocky.github.io/en/ctf/other/securinets-ctf/scrambler/)
- 64 位，无 PIE，nx，write-what-where 原语。修改 `__stack_chk_fail` 的 GOT 条目。

{{#include ../../../../banners/hacktricks-training.md}}
