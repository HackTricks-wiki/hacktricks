# Stack Canaries

{{#include ../../../../banners/hacktricks-training.md}}

## **StackGuard と StackShield**

**StackGuard** は、**EIP (Extended Instruction Pointer)** の前に **canary** として知られる特別な値 `0x000aff0d`（ヌル、改行、EOF、キャリッジリターンを表す）を挿入して、バッファオーバーフローから保護します。しかし、`recv()`、`memcpy()`、`read()`、および `bcopy()` のような関数は依然として脆弱であり、**EBP (Base Pointer)** を保護しません。

**StackShield** は、**Global Return Stack** を維持することで StackGuard よりも洗練されたアプローチを取ります。これにより、すべての戻りアドレス (**EIPs**) が保存され、オーバーフローが発生しても被害を及ぼさないようにします。保存された戻りアドレスと実際の戻りアドレスを比較することで、オーバーフローの発生を検出できます。さらに、StackShield は戻りアドレスを境界値と照合して、**EIP** が期待されるデータ空間の外を指しているかどうかを検出できます。しかし、この保護は Return-to-libc、ROP (Return-Oriented Programming)、または ret2ret のような技術によって回避可能であり、StackShield もローカル変数を保護しないことを示しています。

## **Stack Smash Protector (ProPolice) `-fstack-protector`:**

このメカニズムは、**EBP** の前に **canary** を配置し、ローカル変数を再配置してバッファをより高いメモリアドレスに配置し、他の変数を上書きできないようにします。また、ローカル変数の上にスタックで渡された引数を安全にコピーし、これらのコピーを引数として使用します。しかし、8 要素未満の配列やユーザーの構造体内のバッファは保護されません。

**canary** は `/dev/urandom` から派生したランダムな数またはデフォルト値 `0xff0a0000` です。これは **TLS (Thread Local Storage)** に保存され、スレッド間で共有メモリ空間がスレッド固有のグローバルまたは静的変数を持つことを可能にします。これらの変数は最初に親プロセスからコピーされ、子プロセスは親や兄弟に影響を与えずにデータを変更できます。しかし、**`fork()` を使用して新しい canary を作成しない場合、すべてのプロセス（親と子）は同じ canary を共有し、脆弱になります**。**i386** アーキテクチャでは、canary は `gs:0x14` に保存され、**x86_64** では `fs:0x28` に保存されます。

このローカル保護は、攻撃に脆弱なバッファを持つ関数を特定し、これらの関数の先頭にコードを注入して canary を配置し、末尾でその整合性を確認します。

ウェブサーバーが `fork()` を使用すると、canary バイトをバイト単位で推測するブルートフォース攻撃が可能になります。しかし、`fork()` の後に `execve()` を使用するとメモリ空間が上書きされ、攻撃が無効になります。`vfork()` は、子プロセスが書き込みを試みるまで複製なしで実行できるため、プロセス作成とメモリ処理に対する異なるアプローチを提供します。

### 長さ

`x64` バイナリでは、canary クッキーは **`0x8`** バイトの qword です。**最初の 7 バイトはランダム**で、最後のバイトは **ヌルバイト** です。

`x86` バイナリでは、canary クッキーは **`0x4`** バイトの dword です。**最初の 3 バイトはランダム**で、最後のバイトは **ヌルバイト** です。

> [!CAUTION]
> 両方の canary の最下位バイトはヌルバイトであり、これはスタックの最初に低いアドレスから来るため、**文字列を読み取る関数はそれを読む前に停止します**。

## バイパス

**canary を漏洩させて**、その後自分の値で上書きする（例：バッファオーバーフロー）。

- **子プロセスで canary がフォークされる場合**、1 バイトずつ **ブルートフォース** することが可能かもしれません：

{{#ref}}
bf-forked-stack-canaries.md
{{#endref}}

- バイナリに興味深い **漏洩または任意の読み取り脆弱性** がある場合、漏洩させることができるかもしれません：

{{#ref}}
print-stack-canary.md
{{#endref}}

- **スタックに保存されたポインタの上書き**

スタックがスタックオーバーフローに脆弱な場合、**上書き可能な文字列や関数へのアドレスを含む可能性があります**。これにより、スタック canary に到達することなく脆弱性を悪用できます。確認してください：

{{#ref}}
../../stack-overflow/pointer-redirecting.md
{{#endref}}

- **マスターとスレッドの canary の両方を変更**

canary で保護されたスレッド関数のバッファオーバーフローを使用して、スレッドのマスター canary を変更できます。その結果、チェックが同じ（ただし変更された）2 つの canary で使用されるため、緩和策は無意味になります。

- **`__stack_chk_fail` の GOT エントリを変更**

バイナリが Partial RELRO を持っている場合、任意の書き込みを使用して `__stack_chk_fail` の GOT エントリをダミー関数に変更し、canary が変更されてもプログラムがブロックされないようにできます。

## 参考文献

- [https://guyinatuxedo.github.io/7.1-mitigation_canary/index.html](https://guyinatuxedo.github.io/7.1-mitigation_canary/index.html)
- [http://7rocky.github.io/en/ctf/htb-challenges/pwn/robot-factory/#canaries-and-threads](http://7rocky.github.io/en/ctf/htb-challenges/pwn/robot-factory/#canaries-and-threads)
- 64 ビット、PIE なし、nx、スレッドとマスター canary を変更。
- [https://7rocky.github.io/en/ctf/other/securinets-ctf/scrambler/](https://7rocky.github.io/en/ctf/other/securinets-ctf/scrambler/)
- 64 ビット、PIE なし、nx、write-what-where プリミティブ。`__stack_chk_fail` の GOT エントリを変更。

{{#include ../../../../banners/hacktricks-training.md}}
