# Stack Canaries

{{#include ../../../../banners/hacktricks-training.md}}

## **StackGuard та StackShield**

**StackGuard** вставляє спеціальне значення, відоме як **canary**, перед **EIP (Розширений вказівник інструкцій)**, зокрема `0x000aff0d` (що представляє null, новий рядок, EOF, повернення каретки) для захисту від переповнень буфера. Однак функції, такі як `recv()`, `memcpy()`, `read()`, і `bcopy()`, залишаються вразливими, і це не захищає **EBP (Базовий вказівник)**.

**StackShield** використовує більш складний підхід, ніж StackGuard, підтримуючи **Глобальний стек повернень**, який зберігає всі адреси повернень (**EIPs**). Ця конфігурація забезпечує, що будь-яке переповнення не завдає шкоди, оскільки дозволяє порівняти збережені та фактичні адреси повернень для виявлення випадків переповнення. Крім того, StackShield може перевіряти адресу повернення на предмет відповідності граничному значенню, щоб виявити, чи **EIP** вказує за межі очікуваного простору даних. Однак цей захист можна обійти за допомогою технік, таких як Return-to-libc, ROP (Програмування, орієнтоване на повернення) або ret2ret, що вказує на те, що StackShield також не захищає локальні змінні.

## **Stack Smash Protector (ProPolice) `-fstack-protector`:**

Цей механізм розміщує **canary** перед **EBP** і реорганізовує локальні змінні, щоб розмістити буфери на вищих адресах пам'яті, запобігаючи їх перезапису інших змінних. Він також безпечно копіює аргументи, передані на стеку вище локальних змінних, і використовує ці копії як аргументи. Однак він не захищає масиви з менш ніж 8 елементами або буфери в структурі користувача.

**Canary** є випадковим числом, отриманим з `/dev/urandom` або значенням за замовчуванням `0xff0a0000`. Він зберігається в **TLS (Локальне зберігання потоків)**, що дозволяє спільним просторам пам'яті між потоками мати глобальні або статичні змінні, специфічні для потоку. Ці змінні спочатку копіюються з батьківського процесу, а дочірні процеси можуть змінювати свої дані, не впливаючи на батьківський або братні процеси. Проте, якщо **`fork()` використовується без створення нового canary, всі процеси (батьківський і дочірні) ділять один і той же canary**, що робить його вразливим. На архітектурі **i386** canary зберігається за адресою `gs:0x14`, а на **x86_64** - за адресою `fs:0x28`.

Цей локальний захист ідентифікує функції з буферами, вразливими до атак, і впроваджує код на початку цих функцій для розміщення canary, а в кінці для перевірки його цілісності.

Коли веб-сервер використовує `fork()`, це дозволяє провести грубу атаку для вгадування байта canary по одному. Однак використання `execve()` після `fork()` перезаписує простір пам'яті, нейтралізуючи атаку. `vfork()` дозволяє дочірньому процесу виконуватися без дублювання, поки він не спробує записати, в цей момент створюється дублікат, пропонуючи інший підхід до створення процесів і обробки пам'яті.

### Довжини

У бінарних файлах `x64` cookie canary є **`0x8`** байтовим qword. **Перші сім байтів випадкові**, а останній байт є **нулевим байтом.**

У бінарних файлах `x86` cookie canary є **`0x4`** байтовим dword. **Перші три байти випадкові**, а останній байт є **нулевим байтом.**

> [!CAUTION]
> Найменший значущий байт обох canary є нульовим байтом, оскільки він буде першим у стеку, що походить з нижчих адрес, і тому **функції, які читають рядки, зупиняться перед його читанням**.

## Обходи

**Витік canary** і потім перезапис його (наприклад, переповнення буфера) своїм значенням.

- Якщо **canary розгалужується в дочірніх процесах**, може бути можливим **грубо вгадати** його по одному байту:

{{#ref}}
bf-forked-stack-canaries.md
{{#endref}}

- Якщо в бінарному файлі є якийсь цікавий **витік або вразливість довільного читання**, може бути можливим витік його:

{{#ref}}
print-stack-canary.md
{{#endref}}

- **Перезапис вказівників, що зберігаються в стеку**

Стек, вразливий до переповнення стека, може **містити адреси рядків або функцій, які можуть бути перезаписані** для експлуатації вразливості без необхідності досягати canary. Перевірте:

{{#ref}}
../../stack-overflow/pointer-redirecting.md
{{#endref}}

- **Модифікація як майстерного, так і потокового canary**

Переповнення буфера в багатопотоковій функції, захищеній canary, може бути використано для модифікації майстерного canary потоку. В результаті, пом'якшення є марним, оскільки перевірка використовується з двома canary, які є однаковими (хоча модифікованими).

- **Модифікація запису GOT `__stack_chk_fail`**

Якщо бінарний файл має частковий RELRO, то ви можете використовувати довільний запис для модифікації запису GOT `__stack_chk_fail`, щоб він був фіктивною функцією, яка не блокує програму, якщо canary буде модифіковано.

## Посилання

- [https://guyinatuxedo.github.io/7.1-mitigation_canary/index.html](https://guyinatuxedo.github.io/7.1-mitigation_canary/index.html)
- [http://7rocky.github.io/en/ctf/htb-challenges/pwn/robot-factory/#canaries-and-threads](http://7rocky.github.io/en/ctf/htb-challenges/pwn/robot-factory/#canaries-and-threads)
- 64 біти, без PIE, nx, модифікація поточного та майстерного canary.
- [https://7rocky.github.io/en/ctf/other/securinets-ctf/scrambler/](https://7rocky.github.io/en/ctf/other/securinets-ctf/scrambler/)
- 64 біти, без PIE, nx, запис-що-де. Модифікуйте запис GOT `__stack_chk_fail`.

{{#include ../../../../banners/hacktricks-training.md}}
