# Stack Canaries

{{#include ../../../../banners/hacktricks-training.md}}

## **StackGuard और StackShield**

**StackGuard** एक विशेष मान जिसे **canary** कहा जाता है, को **EIP (Extended Instruction Pointer)** से पहले डालता है, विशेष रूप से `0x000aff0d` (जो null, newline, EOF, carriage return का प्रतिनिधित्व करता है) बफर ओवरफ्लो से बचाने के लिए। हालाँकि, `recv()`, `memcpy()`, `read()`, और `bcopy()` जैसी फ़ंक्शन कमजोर रहती हैं, और यह **EBP (Base Pointer)** की सुरक्षा नहीं करता है।

**StackShield** StackGuard की तुलना में एक अधिक परिष्कृत दृष्टिकोण अपनाता है, जो एक **Global Return Stack** बनाए रखता है, जो सभी रिटर्न पते (**EIPs**) को संग्रहीत करता है। यह सेटअप सुनिश्चित करता है कि कोई भी ओवरफ्लो नुकसान नहीं पहुँचाता है, क्योंकि यह संग्रहीत और वास्तविक रिटर्न पते के बीच तुलना की अनुमति देता है ताकि ओवरफ्लो की घटनाओं का पता लगाया जा सके। इसके अतिरिक्त, StackShield रिटर्न पते की तुलना एक सीमा मान से कर सकता है ताकि यह पता लगाया जा सके कि क्या **EIP** अपेक्षित डेटा स्थान के बाहर इंगित करता है। हालाँकि, इस सुरक्षा को Return-to-libc, ROP (Return-Oriented Programming), या ret2ret जैसी तकनीकों के माध्यम से दरकिनार किया जा सकता है, यह संकेत करता है कि StackShield स्थानीय चर की भी सुरक्षा नहीं करता है।

## **Stack Smash Protector (ProPolice) `-fstack-protector`:**

यह तंत्र **EBP** से पहले एक **canary** रखता है, और स्थानीय चर को पुनर्गठित करता है ताकि बफर को उच्च मेमोरी पते पर रखा जा सके, जिससे वे अन्य चर को ओवरराइट नहीं कर सकें। यह स्थानीय चर के ऊपर स्टैक पर पास किए गए तर्कों को सुरक्षित रूप से कॉपी करता है और इन कॉपियों का उपयोग तर्कों के रूप में करता है। हालाँकि, यह 8 तत्वों से कम वाले ऐरे या उपयोगकर्ता की संरचना के भीतर बफर की सुरक्षा नहीं करता है।

**canary** एक यादृच्छिक संख्या है जो `/dev/urandom` से प्राप्त होती है या इसका डिफ़ॉल्ट मान `0xff0a0000` होता है। इसे **TLS (Thread Local Storage)** में संग्रहीत किया जाता है, जिससे थ्रेड्स के बीच साझा मेमोरी स्थानों में थ्रेड-विशिष्ट वैश्विक या स्थिर चर हो सकते हैं। ये चर प्रारंभ में माता-पिता प्रक्रिया से कॉपी किए जाते हैं, और बच्चे की प्रक्रियाएँ अपने डेटा को माता-पिता या भाई-बहनों को प्रभावित किए बिना बदल सकती हैं। फिर भी, यदि **`fork()` का उपयोग बिना नए canary बनाए किया जाता है, तो सभी प्रक्रियाएँ (माता-पिता और बच्चे) एक ही canary साझा करती हैं**, जिससे यह कमजोर हो जाता है। **i386** आर्किटेक्चर पर, canary `gs:0x14` पर संग्रहीत होता है, और **x86_64** पर, `fs:0x28` पर।

यह स्थानीय सुरक्षा उन फ़ंक्शनों की पहचान करती है जिनमें बफर हमलों के प्रति संवेदनशील होते हैं और इन फ़ंक्शनों की शुरुआत में कोड इंजेक्ट करती है ताकि canary को रखा जा सके, और अंत में इसकी अखंडता की पुष्टि करने के लिए।

जब एक वेब सर्वर `fork()` का उपयोग करता है, तो यह canary बाइट को बाइट द्वारा अनुमान लगाने के लिए एक ब्रूट-फोर्स हमले की अनुमति देता है। हालाँकि, `fork()` के बाद `execve()` का उपयोग मेमोरी स्थान को ओवरराइट करता है, जिससे हमले को नकारा जाता है। `vfork()` बच्चे की प्रक्रिया को डुप्लिकेट किए बिना निष्पादित करने की अनुमति देता है जब तक कि यह लिखने का प्रयास नहीं करता, जिस बिंदु पर एक डुप्लिकेट बनाया जाता है, जो प्रक्रिया निर्माण और मेमोरी प्रबंधन के लिए एक अलग दृष्टिकोण प्रदान करता है।

### लंबाई

`x64` बाइनरी में, canary कुकी एक **`0x8`** बाइट qword है। **पहले सात बाइट यादृच्छिक** हैं और अंतिम बाइट एक **null byte** है।

`x86` बाइनरी में, canary कुकी एक **`0x4`** बाइट dword है। **पहले तीन बाइट यादृच्छिक** हैं और अंतिम बाइट एक **null byte** है।

> [!CAUTION]
> दोनों canaries का सबसे कम महत्वपूर्ण बाइट एक null byte है क्योंकि यह स्टैक में सबसे पहले होगा जो निम्न पते से आ रहा है और इसलिए **जो फ़ंक्शन स्ट्रिंग पढ़ते हैं वे इसे पढ़ने से पहले रुक जाएंगे**।

## बायपास

**canary को लीक करना** और फिर इसे अपने मान से ओवरराइट करना (जैसे बफर ओवरफ्लो)।

- यदि **canary को बच्चे की प्रक्रियाओं में fork किया जाता है** तो इसे एक बाइट में **brute-force** करना संभव हो सकता है:

{{#ref}}
bf-forked-stack-canaries.md
{{#endref}}

- यदि बाइनरी में कुछ दिलचस्प **लीक या मनमाना पढ़ने की कमजोरी** है तो इसे लीक करना संभव हो सकता है:

{{#ref}}
print-stack-canary.md
{{#endref}}

- **स्टैक में संग्रहीत प्वाइंटर्स को ओवरराइट करना**

स्टैक जो स्टैक ओवरफ्लो के प्रति संवेदनशील हो सकता है **स्ट्रिंग्स या फ़ंक्शंस के पते को शामिल कर सकता है जिन्हें ओवरराइट किया जा सकता है** ताकि कमजोरी का लाभ उठाया जा सके बिना स्टैक canary तक पहुँचने की आवश्यकता के। जाँच करें:

{{#ref}}
../../stack-overflow/pointer-redirecting.md
{{#endref}}

- **मास्टर और थ्रेड canary दोनों को संशोधित करना**

एक थ्रेडेड फ़ंक्शन में बफर ओवरफ्लो जो canary से सुरक्षित है, का उपयोग थ्रेड के मास्टर canary को संशोधित करने के लिए किया जा सकता है। परिणामस्वरूप, यह शमन बेकार हो जाता है क्योंकि जाँच दो समान (हालाँकि संशोधित) canaries के साथ की जाती है।

- **`__stack_chk_fail` के GOT प्रविष्टि को संशोधित करना**

यदि बाइनरी में Partial RELRO है, तो आप `__stack_chk_fail` के GOT प्रविष्टि को एक डमी फ़ंक्शन में संशोधित करने के लिए एक मनमाना लिखने का उपयोग कर सकते हैं जो प्रोग्राम को अवरुद्ध नहीं करता है यदि canary संशोधित हो जाता है।

## संदर्भ

- [https://guyinatuxedo.github.io/7.1-mitigation_canary/index.html](https://guyinatuxedo.github.io/7.1-mitigation_canary/index.html)
- [http://7rocky.github.io/en/ctf/htb-challenges/pwn/robot-factory/#canaries-and-threads](http://7rocky.github.io/en/ctf/htb-challenges/pwn/robot-factory/#canaries-and-threads)
- 64 बिट, कोई PIE, nx, थ्रेड और मास्टर canary को संशोधित करें।
- [https://7rocky.github.io/en/ctf/other/securinets-ctf/scrambler/](https://7rocky.github.io/en/ctf/other/securinets-ctf/scrambler/)
- 64 बिट, कोई PIE, nx, write-what-where primitive। `__stack_chk_fail` के GOT प्रविष्टि को संशोधित करें।

{{#include ../../../../banners/hacktricks-training.md}}
