# Stack Canaries

{{#include ../../../../banners/hacktricks-training.md}}

## **StackGuard na StackShield**

**StackGuard** inaingiza thamani maalum inayojulikana kama **canary** kabla ya **EIP (Extended Instruction Pointer)**, haswa `0x000aff0d` (inawakilisha null, newline, EOF, carriage return) ili kulinda dhidi ya buffer overflows. Hata hivyo, kazi kama `recv()`, `memcpy()`, `read()`, na `bcopy()` bado zina hatari, na haiwezi kulinda **EBP (Base Pointer)**.

**StackShield** inachukua mbinu ya hali ya juu zaidi kuliko StackGuard kwa kudumisha **Global Return Stack**, ambayo inahifadhi anwani zote za kurudi (**EIPs**). Mpangilio huu unahakikisha kwamba overflow yoyote haiwezi kusababisha madhara, kwani inaruhusu kulinganisha kati ya anwani zilizohifadhiwa na zile halisi za kurudi ili kugundua matukio ya overflow. Zaidi ya hayo, StackShield inaweza kuangalia anwani ya kurudi dhidi ya thamani ya mpaka ili kugundua ikiwa **EIP** inaelekeza nje ya nafasi ya data inayotarajiwa. Hata hivyo, ulinzi huu unaweza kupuuziliwa mbali kupitia mbinu kama Return-to-libc, ROP (Return-Oriented Programming), au ret2ret, ikionyesha kwamba StackShield pia haiwezi kulinda mabadiliko ya ndani.

## **Stack Smash Protector (ProPolice) `-fstack-protector`:**

Mekanism hii inaweka **canary** kabla ya **EBP**, na kuandaa mabadiliko ya ndani ili kuweka buffers katika anwani za juu za kumbukumbu, kuzuia kuandika tena mabadiliko mengine. Pia inakopi kwa usalama hoja zilizopitishwa kwenye stack juu ya mabadiliko ya ndani na inatumia nakala hizi kama hoja. Hata hivyo, haiwezi kulinda arrays zenye vipengele chini ya 8 au buffers ndani ya muundo wa mtumiaji.

**Canary** ni nambari ya nasibu inayotokana na `/dev/urandom` au thamani ya msingi ya `0xff0a0000`. Inahifadhiwa katika **TLS (Thread Local Storage)**, ikiruhusu nafasi za kumbukumbu zinazoshirikiwa kati ya nyuzi kuwa na mabadiliko ya kimataifa au ya kudumu maalum kwa nyuzi. Mabadiliko haya awali yanakopiwa kutoka kwa mchakato wa mzazi, na michakato ya watoto inaweza kubadilisha data zao bila kuathiri mzazi au ndugu. Hata hivyo, ikiwa **`fork()` inatumika bila kuunda canary mpya, michakato yote (mzazi na watoto) inashiriki canary ile ile**, ikifanya iwe hatari. Katika usanifu **i386**, canary inahifadhiwa katika `gs:0x14`, na katika **x86_64**, katika `fs:0x28`.

Ulinzi huu wa ndani unagundua kazi zenye buffers zinazoweza kushambuliwa na kuingiza msimbo mwanzoni mwa kazi hizi ili kuweka canary, na mwishoni kuthibitisha uaminifu wake.

Wakati seva ya wavuti inatumia `fork()`, inaruhusu shambulio la brute-force kutabiri byte ya canary moja kwa moja. Hata hivyo, kutumia `execve()` baada ya `fork()` inafuta nafasi ya kumbukumbu, ikiondoa shambulio hilo. `vfork()` inaruhusu mchakato wa mtoto kutekeleza bila kuiga hadi inajaribu kuandika, wakati ambapo nakala inaundwa, ikitoa mbinu tofauti ya kuunda michakato na kushughulikia kumbukumbu.

### Urefu

Katika binaries za `x64`, keki ya canary ni **`0x8`** byte qword. **Bytes saba za kwanza ni za nasibu** na byte ya mwisho ni **byte ya null.**

Katika binaries za `x86`, keki ya canary ni **`0x4`** byte dword. **Bytes tatu za kwanza ni za nasibu** na byte ya mwisho ni **byte ya null.**

> [!CAUTION]
> Byte ya chini ya umuhimu ya canaries zote ni byte ya null kwa sababu itakuwa ya kwanza katika stack ikitoka kwenye anwani za chini na hivyo **kazi zinazosomea nyuzi zitasimama kabla ya kuisoma**.

## Bypasses

**Kuvuja kwa canary** na kisha kuandika tena (mfano: buffer overflow) kwa thamani yake mwenyewe.

- Ikiwa **canary imeforked katika michakato ya watoto** inaweza kuwa inawezekana **kujaribu kwa nguvu** moja kwa moja:

{{#ref}}
bf-forked-stack-canaries.md
{{#endref}}

- Ikiwa kuna **kuvuja au udhaifu wa kusoma bila mpangilio** katika binary inaweza kuwa inawezekana kuvuja:

{{#ref}}
print-stack-canary.md
{{#endref}}

- **Kuandika tena viashiria vilivyohifadhiwa kwenye stack**

Stack inayoweza kuathiriwa na overflow ya stack inaweza **kuhifadhi anwani za nyuzi au kazi ambazo zinaweza kuandikwa tena** ili kutumia udhaifu bila kuhitaji kufikia canary ya stack. Angalia:

{{#ref}}
../../stack-overflow/pointer-redirecting.md
{{#endref}}

- **Kubadilisha canary ya bwana na nyuzi**

Overflow ya buffer katika kazi ya nyuzi iliyolindwa na canary inaweza kutumika kubadilisha canary ya bwana wa nyuzi. Kama matokeo, ulinzi ni wa bure kwa sababu ukaguzi unatumika na canaries mbili ambazo ni sawa (ingawa zimebadilishwa).

- **Badilisha kipengee cha GOT cha `__stack_chk_fail`**

Ikiwa binary ina Partial RELRO, basi unaweza kutumia kuandika bila mpangilio kubadilisha kipengee cha GOT cha `__stack_chk_fail` kuwa kazi ya dummy ambayo haiwezi kuzuia programu ikiwa canary itabadilishwa.

## Marejeleo

- [https://guyinatuxedo.github.io/7.1-mitigation_canary/index.html](https://guyinatuxedo.github.io/7.1-mitigation_canary/index.html)
- [http://7rocky.github.io/en/ctf/htb-challenges/pwn/robot-factory/#canaries-and-threads](http://7rocky.github.io/en/ctf/htb-challenges/pwn/robot-factory/#canaries-and-threads)
- 64 bits, hakuna PIE, nx, badilisha canary ya nyuzi na bwana.
- [https://7rocky.github.io/en/ctf/other/securinets-ctf/scrambler/](https://7rocky.github.io/en/ctf/other/securinets-ctf/scrambler/)
- 64 bits, hakuna PIE, nx, andika-nini-wapi primitive. Badilisha kipengee cha GOT cha `__stack_chk_fail`.

{{#include ../../../../banners/hacktricks-training.md}}
