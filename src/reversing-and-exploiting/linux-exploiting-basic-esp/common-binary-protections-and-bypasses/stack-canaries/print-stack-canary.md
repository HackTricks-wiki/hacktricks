# Print Stack Canary

{{#include ../../../../banners/hacktricks-training.md}}

## Enlarge printed stack

एक ऐसी स्थिति की कल्पना करें जहाँ एक **प्रोग्राम जो स्टैक ओवरफ्लो के लिए संवेदनशील है** एक **puts** फ़ंक्शन को **पॉइंट** कर सकता है जो **स्टैक ओवरफ्लो** के **भाग** की ओर इशारा करता है। हमलावर जानता है कि **कनारी का पहला बाइट एक नल बाइट है** (`\x00`) और बाकी कनारी **यादृच्छिक** बाइट्स हैं। फिर, हमलावर एक ओवरफ्लो बना सकता है जो **स्टैक को ओवरराइट करता है जब तक कि कनारी का पहला बाइट** न हो।

फिर, हमलावर **पेलोड के मध्य में puts फ़ंक्शन को कॉल करता है** जो **सभी कनारी को प्रिंट करेगा** (पहले नल बाइट को छोड़कर)।

इस जानकारी के साथ हमलावर **एक नया हमला तैयार और भेज सकता है** कनारी को जानकर (उसी प्रोग्राम सत्र में)।

स्पष्ट रूप से, यह रणनीति बहुत **सीमित** है क्योंकि हमलावर को अपने **पेलोड** की **सामग्री** को **प्रिंट** करने में सक्षम होना चाहिए ताकि वह **कनारी** को **एक्सफिल्ट्रेट** कर सके और फिर एक नया पेलोड बनाने में सक्षम हो (उसी **प्रोग्राम सत्र** में) और **वास्तविक बफर ओवरफ्लो** को **भेज** सके।

**CTF उदाहरण:**&#x20;

- [**https://guyinatuxedo.github.io/08-bof_dynamic/csawquals17_svc/index.html**](https://guyinatuxedo.github.io/08-bof_dynamic/csawquals17_svc/index.html)
- 64 बिट, ASLR सक्षम लेकिन कोई PIE नहीं, पहला कदम ओवरफ्लो को भरना है जब तक कि कनारी का बाइट 0x00 न हो ताकि फिर puts को कॉल किया जा सके और इसे लीक किया जा सके। कनारी के साथ एक ROP गैजेट बनाया जाता है जो puts को कॉल करता है ताकि GOT से puts का पता लीक किया जा सके और फिर एक ROP गैजेट जो `system('/bin/sh')` को कॉल करता है।

## Arbitrary Read

फॉर्मेट **स्ट्रिंग्स** द्वारा प्रदान किए गए एक मनमाने पढ़ने के साथ कनारी को लीक करना संभव हो सकता है। इस उदाहरण को देखें: [**https://ir0nstone.gitbook.io/notes/types/stack/canaries**](https://ir0nstone.gitbook.io/notes/types/stack/canaries) और आप पढ़ सकते हैं कि कैसे फॉर्मेट स्ट्रिंग्स का दुरुपयोग करके मनमाने मेमोरी पते को पढ़ा जा सकता है:

{{#ref}}
../../format-strings/
{{#endref}}

{{#include ../../../../banners/hacktricks-training.md}}
