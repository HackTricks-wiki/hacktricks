# 打印栈金丝雀

{{#include ../../../../banners/hacktricks-training.md}}

## 扩大打印的栈

想象一个情况，其中一个 **易受攻击的程序** 可以执行一个 **puts** 函数 **指向** **栈溢出** 的 **部分**。攻击者知道 **金丝雀的第一个字节是一个空字节** (`\x00`)，其余的金丝雀是 **随机** 字节。然后，攻击者可以创建一个溢出，**覆盖栈直到金丝雀的第一个字节**。

然后，攻击者在有效负载的中间 **调用 puts 功能**，这将 **打印所有金丝雀**（除了第一个空字节）。

有了这些信息，攻击者可以 **制作并发送一个新攻击**，知道金丝雀（在同一程序会话中）。

显然，这种策略是非常 **受限** 的，因为攻击者需要能够 **打印** 他的 **有效负载** 的 **内容** 来 **提取** **金丝雀**，然后能够创建一个新的有效负载（在 **同一程序会话** 中）并 **发送** **真实的缓冲区溢出**。

**CTF 示例：**&#x20;

- [**https://guyinatuxedo.github.io/08-bof_dynamic/csawquals17_svc/index.html**](https://guyinatuxedo.github.io/08-bof_dynamic/csawquals17_svc/index.html)
- 64 位，启用 ASLR 但没有 PIE，第一步是填充溢出直到金丝雀的字节 0x00，然后调用 puts 并泄露它。利用金丝雀创建一个 ROP gadget 来调用 puts 以泄露 GOT 中 puts 的地址，然后再创建一个 ROP gadget 来调用 `system('/bin/sh')`

## 任意读取

通过像格式 **字符串** 提供的任意读取，可能会泄露金丝雀。查看这个例子：[**https://ir0nstone.gitbook.io/notes/types/stack/canaries**](https://ir0nstone.gitbook.io/notes/types/stack/canaries)，你可以阅读关于滥用格式字符串以读取任意内存地址的内容：

{{#ref}}
../../format-strings/
{{#endref}}

{{#include ../../../../banners/hacktricks-training.md}}
