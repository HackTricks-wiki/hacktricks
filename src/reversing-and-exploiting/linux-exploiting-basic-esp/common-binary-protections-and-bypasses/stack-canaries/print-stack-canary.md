# スタックカナリの印刷

{{#include ../../../../banners/hacktricks-training.md}}

## 印刷されたスタックの拡大

スタックオーバーフローに**脆弱なプログラム**が**スタックオーバーフロー**の**一部**を指す**puts**関数を実行できる状況を想像してください。攻撃者は**カナリの最初のバイトがヌルバイト**（`\x00`）であり、残りのカナリは**ランダム**なバイトであることを知っています。次に、攻撃者は**カナリの最初のバイト**までスタックを**上書きする**オーバーフローを作成することができます。

その後、攻撃者はペイロードの中間で**puts機能**を呼び出し、**カナリ全体**を**印刷**します（最初のヌルバイトを除く）。

この情報を使って、攻撃者は**カナリを知っている**（同じプログラムセッション内で）新しい攻撃を**作成して送信**することができます。

明らかに、この戦術は非常に**制限されており**、攻撃者は**カナリ**を**抽出**するために自分の**ペイロードの内容**を**印刷**できる必要があり、その後**新しいペイロード**を作成し（**同じプログラムセッション内で**）、**実際のバッファオーバーフロー**を**送信**できる必要があります。

**CTFの例:**&#x20;

- [**https://guyinatuxedo.github.io/08-bof_dynamic/csawquals17_svc/index.html**](https://guyinatuxedo.github.io/08-bof_dynamic/csawquals17_svc/index.html)
- 64ビット、ASLRが有効ですがPIEはなし、最初のステップはカナリのバイト0x00までオーバーフローを埋めてからputsを呼び出して漏洩させることです。カナリを使ってROPガジェットを作成し、putsを呼び出してGOTからputsのアドレスを漏洩させ、次に`system('/bin/sh')`を呼び出すROPガジェットを作成します。

## 任意の読み取り

フォーマット**文字列**によって提供される任意の読み取りを使用すると、カナリを漏洩させることができるかもしれません。この例を確認してください: [**https://ir0nstone.gitbook.io/notes/types/stack/canaries**](https://ir0nstone.gitbook.io/notes/types/stack/canaries) そして、任意のメモリアドレスを読み取るためにフォーマット文字列を悪用することについては:

{{#ref}}
../../format-strings/
{{#endref}}

{{#include ../../../../banners/hacktricks-training.md}}
