# Evil Twin EAP-TLS

{{#include ../../banners/hacktricks-training.md}}

EAP-TLS est le choix « sécurisé » courant pour WPA2/3-Enterprise, mais deux faiblesses pratiques apparaissent régulièrement lors des évaluations :

- **Divulgation d'identité non authentifiée** : l'EAP-Response/Identity externe est envoyé en clair avant la mise en place d'un tunnel TLS, si bien que les vrais noms d'utilisateur de domaine sont souvent exposés par ondes radio.
- **Validation client-serveur défaillante** : si le supplicant ne vérifie pas strictement le certificat du serveur RADIUS (ou permet aux utilisateurs de valider malgré les avertissements), un rogue AP avec un self-signed cert peut quand même permettre à des victimes de s'authentifier — transformant le mutual TLS en one-way TLS.

## Divulgation d'identité EAP non authentifiée / énumération de noms d'utilisateur

EAP initie un échange d'identité *avant* le démarrage de TLS. Si le client utilise le vrai nom d'utilisateur de domaine comme identité externe, n'importe qui dans la portée RF peut le collecter sans s'authentifier.

**Flux de collecte passive**
```bash
# 1) Park on the right channel/BSSID
airodump-ng -i $IFACE -c $CHAN --bssid $BSSID

# 2) Decode EAP frames and extract identities
# Trigger a client connection (e.g., your phone) to see the leak
tshark -i "$IFACE" -Y eap -V | grep "Identity: *[a-z]\|*[A-Z]\|*[0-9]"
```
Impact : collecte rapide de usernames sans authentification → alimente password spraying, phishing et account correlation. Pire quand les usernames correspondent à des adresses e‑mail.

## TLS 1.3 : confidentialité vs attaques de downgrade

TLS 1.3 chiffre les client certs et la plupart des handshake metadata, donc quand un supplicant négocie effectivement TLS 1.3, un Evil Twin ne peut pas apprendre passivement le client certificate/identity. De nombreuses stacks d'entreprise autorisent encore TLS 1.2 pour des raisons de compatibilité ; RFC 9190 prévient qu'un rogue AP peut n'offrir que des suites static-RSA TLS 1.2 pour forcer un fallback et ré-exposer l'outer identity (ou même le client cert) en clair dans EAP-TLS.

**Playbook offensif (downgrade to leak ID) :**
- Compiler hostapd-wpe avec uniquement les ciphers static RSA TLS 1.2 activés et TLS 1.3 désactivé dans `openssl_ciphersuite` / `ssl_ctx_flags`.
- Diffuser le SSID corporate ; quand la victime initie TLS 1.3, répondre avec une TLS alert et relancer le handshake pour que le peer réessaie en TLS 1.2, révélant sa vraie identité avant que la validation du cert ne réussisse.
- Associer cela avec `force_authorized=1` dans hostapd-wpe pour que le 4-way handshake se complète même si client-auth échoue, vous donnant du traffic DHCP/DNS-level à phish ou pour un portal.

**Basculage défensif (à rechercher lors d'une évaluation) :**
- hostapd/wpa_supplicant 2.10 a ajouté le support EAP-TLS côté server *et* peer pour TLS 1.3 mais l'expédie **désactivé par défaut** ; l'activer sur les clients avec `phase1="tls_disable_tlsv1_3=0"` supprime la fenêtre de downgrade.

## Evil Twin via validation serveur défaillante ("mTLS?")

Les rogue APs diffusant le SSID corporate peuvent présenter n'importe quel certificate. Si le client :
- **ne valide pas** le server cert, ou
- **invite l'utilisateur** et permet l'override d'untrusted CAs/self-signed certs,
alors EAP-TLS cesse d'être mutual. Un **hostapd/hostapd-wpe** modifié qui ignore la validation du client-cert (p.ex., `SSL_set_verify(..., 0)`) suffit pour monter l'Evil Twin.

### Note rapide sur l'infra rogue

Sur un Kali récent, compiler `hostapd-wpe` en utilisant hostapd-2.6 (from https://w1.fi/releases/) et installer d'abord les en‑têtes legacy OpenSSL :
```bash
apt-get install libssl1.0-dev
# patch hostapd-wpe to set verify_peer=0 in SSL_set_verify to accept any client cert
```
### Pièges de mauvaise configuration du supplicant Windows (GUI/GPO)

Principaux paramètres du profil Windows EAP-TLS :
- **Verify the server's identity by validating the certificate**
- Cochée → la chaîne doit être approuvée ; décochée → tout certificat auto-signé est accepté.
- **Connect to these servers**
- Vide → tout certificat d'une CA de confiance est accepté ; définir la liste CN/SAN pour épingler les noms RADIUS attendus.
- **Don't prompt user to authorise new servers or trusted certification authorities**
- Cochée → les utilisateurs ne peuvent pas continuer en cliquant ; décochée → l'utilisateur peut faire confiance à une CA/cert non approuvée et rejoindre le rogue AP.

Résultats observés :
- **Strict validation + no prompts** → le rogue cert est rejeté ; Windows enregistre un événement et TLS échoue (bon signal de détection).
- **Validation + user prompt** → acceptation par l'utilisateur = association Evil Twin réussie.
- **No validation** → association silencieuse Evil Twin avec n'importe quel cert.

## Références

- [EAP-TLS: The most secure option? (NCC Group)](https://www.nccgroup.com/research-blog/eap-tls-the-most-secure-option/)
- [EAP-TLS wireless infrastructure (Versprite hostapd bypass)](https://versprite.com/blog/eap-tls-wireless-infrastructure/)
- [RFC 4282 - Network Access Identifier](https://datatracker.ietf.org/doc/html/rfc4282)
- [Microsoft ServerValidationParameters (WLAN profile)](https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-gpwl/0765966e-a16a-4e75-aec6-0f5f7bfbf31c)
- [RFC 9190 – EAP-TLS 1.3](https://datatracker.ietf.org/doc/rfc9190/)
- [hostapd/wpa_supplicant 2.10 release notes (TLS 1.3 EAP-TLS support)](https://lists.infradead.org/pipermail/hostap/2022-February/040204.html)

{{#include ../../banners/hacktricks-training.md}}
