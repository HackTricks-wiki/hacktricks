# Cryptographic Key Exchange Attacks (DH/KEM) and Hybrid KEM Combiners

{{#include ../../banners/hacktricks-training.md}}

## Overview

This page covers practical pitfalls and secure constructions when combining classical and post‑quantum key encapsulation mechanisms (KEMs) into a single hybrid key exchange. It also shows a concrete Diffie–Hellman (DH) ciphertext second pre‑image that breaks naïve concatenate‑then‑hash hybrids under an IND‑CCA adversary.

Threat model refresher:
- IND‑CPA: adversary sees a challenge (capsule, real secret vs random) and can call Encaps on chosen public keys.
- IND‑CCA: adversary additionally obtains a Decaps oracle under the challenge private key for any ciphertext except the challenge.

## KEM refresher and mapping DH→KEM

KEM API:
- KeyGen() → (sk, pk)
- Encaps(pk) → (ss, ct)
- Decaps(sk, ct) → ss

Mapping DH to a KEM (safe prime p=2q+1, g of order q):
- KeyGen(): pick a; sk=a, pk=A=g^a mod p
- Encaps(A): pick b; ct=B=g^b mod p; ss=A^b mod p
- Decaps(sk=a, ct=B): ss=B^a mod p

## Goal of hybridization

Run two or more KEMs in parallel (e.g., ECDH and ML‑KEM/Kyber) and derive one session key that remains secure if at least one constituent KEM remains secure. A generic combiner derives the final key as a KDF over the combined inputs with domain separation.

## Naïve combiners and why they fail under IND‑CCA

1) Concatenate shared secrets: ss = ss_X || ss_Y
- Problems: variable output length and partial leakage. If one KEM breaks, part of ss is known without bit diffusion.

2) Concatenate then hash: ss = KDF(ss_X || ss_Y)
- Still insufficient in general for IND‑CCA. If any ingredient KEM admits ciphertext second pre‑images under the challenge key (two different ciphertexts that Decaps to the same ss), an attacker with a Decaps oracle can distinguish the hybrid’s output from random while the other KEM remains IND‑CCA.

High‑level IND‑CCA attack on concatenate‑then‑hash hybrids:
- Given challenge (ct_X, ct_Y) and access to Decaps on any ct' ≠ ct, forge ct'_X ≠ ct_X such that Decaps_X(sk_X, ct'_X)=Decaps_X(sk_X, ct_X).
- Query the Decaps oracle on (ct'_X, ct_Y) to recover the real ss_X (and ss_Y if ct_Y unchanged), then compare KDF(ss_X||ss_Y) with the challenge to win the IND‑CCA game.

## PoC: DH ciphertext second pre‑image via order‑2 tweak

In a safe‑prime DH group p=2q+1 with generator g of order q, let v be the unique element of order 2 (v≡−1 mod p). If the private key a is even, then v^a=1 and for any capsule B one has (B·v)^a = B^a. Thus B and B·v decapsulate to the same shared secret under that key (a practical ciphertext second pre‑image without solving discrete log).

<details>
<summary>PoC: DH order‑2 capsule‑collision in safe‑prime group</summary>

```python
# === DH parameters (toy values; do NOT use in production)
p=1277723  # p = 2*q + 1, with q=638861 also prime
g=3        # order(g) = q

# === KeyGen() (Alice)
a = 130376              # even private exponent
A = pow(g, a, p)

# === Encaps(A) (Bob)
b = 644734
B = pow(g, b, p)
ss, ct = pow(A, b, p), B

# === Decaps(ct, a)
assert pow(ct, a, p) == ss

# === Collision: tweak by the order‑2 element v
v = p-1        # order(v) = 2 in Z_p^*
ct_coll = (ct * v) % p
assert ct != ct_coll and pow(ct_coll, a, p) == ss
```

</details>

Impact on hybrids: Given a challenge capsule, an attacker forges ct'≠ct with the same ss, queries Decaps on ct' to learn ss, and distinguishes KDF(ss_X||ss_Y) from random. This breaks IND‑CCA for the concatenation‑then‑hash combiner even if the other KEM is IND‑CCA secure.

Practical DH hardening to prevent such collisions:
- Subgroup validation on received DH public keys/capsules: reject inputs not in the order‑q subgroup (e.g., check X^q ≡ 1 mod p and X≠1).
- Use generators of the correct subgroup and clear cofactors when applicable (ECDH).
- Enforce key validation: reject low‑order points/elements and perform cofactor clearing on ECDH.

## When concatenate‑then‑hash can be safe

If each ingredient KEM provides ciphertext second pre‑image resistance (for the challenge key), then the concatenate‑then‑hash combiner can be proven IND‑CCA secure. Classical DH without subgroup validation violates this property via the order‑2 tweak above.

## Secure combiners: bind the derived key to the full transcript

To defend generically against ciphertext collisions, bind the final key derivation to the entire transcript of each KEM:
- Include for each KEM i: its shared secret ss_i, ciphertext/capsule ct_i, and public key pk_i.
- Use domain separation to identify the exact algorithm suite.

Example construction:

```
SS = KDF( ss_1 || ct_1 || pk_1 || ss_2 || ct_2 || pk_2 || ... || Domain )
# Output length typically 256 bits
```

This ensures any change in a ciphertext or public key alters the derived key, so second pre‑images on a component KEM do not help the attacker.

## IETF Composite ML‑KEM combiner (optimized)

For ML‑KEM (Kyber), proofs show ciphertext second pre‑image resistance. The IETF LAMPS composite KEM draft leverages this to omit the large ML‑KEM ciphertext/public‑key from the KDF input while preserving IND‑CCA, reducing overhead. The traditional (e.g., ECDH) component still binds its transcript.

Reference KDF inputs (256‑bit output):

```text
KemCombiner<KDF>(mlkemSS, tradSS, tradCT, tradPK, Domain) -> ss

if KDF == "SHA3-256":
    ss = SHA3-256( mlkemSS || tradSS || tradCT || tradPK || Domain )
else if KDF == "HMAC-{Hash}":
    ss = HMAC-{Hash}( key=0x00..00, text=mlkemSS || tradSS || tradCT || tradPK || Domain )
    ss = truncate_256_bits(ss)
return ss
```

Notes:
- Domain must unambiguously identify the exact algorithm pair and parameters (domain separation).
- Keep output length fixed (e.g., 256 bits) and use a KDF/HKDF as needed for key schedule expansion.

## Actionable guidance for attackers and defenders

Attacker techniques (against naïve hybrids):
- Search for component KEMs allowing ciphertext second pre‑images. In DH settings without subgroup validation, try order‑2 capsule tweaks B→B·v and probe a Decaps oracle to recover the true ss.

Defensive practices:
- Do not invent your own hybrid combiner; use vetted constructions (e.g., IETF Composite ML‑KEM for ML‑KEM+ECDH).
- For general hybrids, bind the KDF to: each ss_i, ct_i, and pk_i, with domain separation.
- Ensure each component KEM resists ciphertext second pre‑images; add input validation (subgroup/point validation, cofactor clearing) for DH/ECDH.

## References

- [Synacktiv – Quantum readiness: Hybridizing key exchanges](https://www.synacktiv.com/en/publications/quantum-readiness-hybridizing-key-exchanges.html)
- [IETF LAMPS – Post‑Quantum Composite KEM](https://datatracker.ietf.org/doc/draft-ietf-lamps-pq-composite-kem/)

{{#include ../../banners/hacktricks-training.md}}