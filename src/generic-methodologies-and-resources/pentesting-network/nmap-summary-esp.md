# Nmap Zusammenfassung (ESP)

{{#include ../../banners/hacktricks-training.md}}
```
nmap -sV -sC -O -n -oA nmapscan 192.168.0.1/24
```
## Parameter

### IPs zu scannen

- **`<ip>,<net/mask>`:** IPs direkt angeben
- **`-iL <ips_file>`:** list_IPs
- **`-iR <number>`**: Anzahl zufälliger IPs, mögliche IPs können mit `--exclude <Ips>` oder `--excludefile <file>` ausgeschlossen werden.

### Geräteerkennung

Standardmäßig startet Nmap eine Erkennungsphase, die aus besteht: `-PA80 -PS443 -PE -PP`

- **`-sL`**: Nicht invasiv, listet die Ziele und macht **DNS**-Anfragen zur Namensauflösung. Nützlich, um z. B. bei www.prueba.es/24 zu wissen, ob alle IPs unsere Ziele sind.
- **`-Pn`**: **Kein Ping**. Nützlich, wenn bekannt ist, dass alle aktiv sind (ansonsten kann viel Zeit verloren gehen, zudem kann diese Option False-Negatives erzeugen, die behaupten, sie seien inaktiv). Verhindert die Erkennungsphase.
- **`-sn`** : **Kein Portscan**. Nach Abschluss der Recon-Phase werden keine Ports gescannt. Relativ stealthy und ermöglicht schnelles Scannen kleiner Netze. Mit Rechten sendet es ACK (-PA) an 80, SYN (-PS) an 443 und ein Echo- sowie Timestamp-Request; ohne Rechte werden Verbindungen immer komplett durchgeführt. Ist das Ziel ein Netzwerk, verwendet es nur ARP (-PR). Wenn mit einer anderen Option kombiniert, werden nur die Pakete der anderen Option ausgelassen.
- **`-PR`**: **ARP-Ping**. Wird standardmäßig beim Analysieren von Rechnern im eigenen Netzwerk verwendet, ist schneller als ICMP-Pings. Wenn keine ARP-Pakete verwendet werden sollen, nutze `--send-ip`.
- **`-PS <ports>`**: Sendet SYN-Pakete; antwortet der Host mit SYN/ACK ist der Port offen (man antwortet mit RST, um die Verbindung nicht zu beenden), antwortet er mit RST ist er geschlossen, keine Antwort = unreachable. Ohne Privilegien wird automatisch eine vollständige Verbindung verwendet. Wenn keine Ports angegeben sind, wird Port 80 verwendet.
- **`-PA <ports>`**: Wie oben, aber mit ACK; die Kombination beider liefert bessere Ergebnisse.
- **`-PU <ports>`**: Ziel ist das Gegenteil: gesendet werden Pakete an Ports, die erwartungsgemäß geschlossen sind. Manche Firewalls prüfen nur TCP-Verbindungen. Bei geschlossenem Port kommt ein "port unreachable", andere ICMP-Antworten oder keine Antwort werden als destination unreachable gewertet.
- **`-PE, -PP, -PM`** : ICMP-PINGS: echo reply, timestamp und addresmask. Werden genutzt, um zu prüfen, ob das Ziel aktiv ist.
- **`-PY<ports>`**: Sendet SCTP INIT-Probes standardmäßig an 80; INIT-ACK (open) oder ABORT (closed) oder nichts bzw. ICMP unreachable (inactive) können zurückkommen.
- **`-PO <protocols>`**: Ein Protokoll wird in den Headern angegeben, standardmäßig 1(ICMP), 2(IGMP) und 4(Encap IP). Für ICMP, IGMP, TCP (6) und UDP (17) werden Protokoll-Header gesendet, für den Rest nur der IP-Header. Ziel ist, durch Header-Malformation Protocol unreachable oder Antworten selben Protokolls zu provozieren, um Up/Down zu erkennen.
- **`-n`**: Kein DNS
- **`-R`**: DNS immer

### Port-Scanning-Techniken

- **`-sS`**: Vollzieht die Verbindung nicht komplett, hinterlässt daher kaum Spuren — sehr nützlich wenn möglich (Privilegien nötig). Standardmäßig verwendet.
- **`-sT`**: Schließt die Verbindung komplett ab, hinterlässt Spuren, funktioniert aber sicher. Standardmäßig ohne Privilegien.
- **`-sU`**: Langsamer, für UDP. Hauptsächlich: DNS(53), SNMP(161,162), DHCP(67,68). (-sU53,161,162,67,68): open(reply), closed(port unreachable), filtered (anderes ICMP), open/filtered (keine Antwort). Bei open/filtered sendet -sV zahlreiche Anfragen zur Erkennung unterstützter Versionen. Erhöht die Laufzeit deutlich.
- **`-sY`**: SCTP-Scan, schlägt fehl, eine Verbindung aufzubauen, daher keine Logs; funktioniert wie -PY.
- **`-sN, -sX, -sF`:** Null, Fin, Xmas — können manche Firewalls umgehen und Informationen extrahieren. Basieren auf der Erwartung, dass standardkonforme Systeme auf Anfragen ohne gesetzte SYN/RST/ACK mit RST antworten: open/filtered (keine Antwort), closed (RST), filtered (ICMP unreachable). Unzuverlässig auf Windows, Cisco, BSDI und OS/400. Auf Unix funktionieren sie meist.
- **`-sM`**: Maimon scan: Sendet FIN und ACK Flags, ursprünglich für BSD; aktuell gibt es häufig Rückmeldungen als closed.
- **`-sA, -sW`**: ACK und Window-Scans, werden verwendet, um Firewalls zu erkennen und festzustellen, ob Ports gefiltert sind. -sW unterscheidet open/closed anhand unterschiedlicher Window-Werte: open (RST mit Window ≠ 0), closed (RST Window = 0), filtered (ICMP unreachable oder keine Antwort). Nicht alle Hosts verhalten sich so; daher: wenn alle als closed erscheinen, funktioniert die Methode nicht; wenn wenige open, funktioniert sie; wenn viele open und wenige closed, läuft es umgekehrt.
- **`-sI`:** Idle scan. Wenn eine aktive Firewall existiert, wir aber wissen, dass sie zu einer bestimmten IP nicht filtert (oder wenn wir Anonymität wollen), kann der Zombie-Scanner verwendet werden (funktioniert für alle Ports). Um mögliche Zombies zu finden, kann das Script ipidseq oder exploit auxiliary/scanner/ip/ipidseq genutzt werden. Dieser Scanner basiert auf der IPID-Nummer der IP-Pakete.
- **`--badsum`:** Sendet eine falsche Prüfsumme; Hosts würden die Pakete verwerfen, Firewalls könnten jedoch antworten — nützlich zur Erkennung von Firewalls.
- **`-sZ`**: "Weird" SCTP scanner; beim Senden von Probes mit cookie echo fragments sollten diese bei offenem Port verworfen oder bei geschlossenem Port mit ABORT beantwortet werden. Kann Firewalls passieren, die beim INIT blockieren; Nachteil: unterscheidet nicht zwischen filtered und open.
- **`-sO`**: IP-Protokoll-Scan. Sendet falsche/leckende Header, bei denen manchmal nicht einmal das Protokoll zu erkennen ist. Kommt ICMP protocol unreachable, ist es closed; kommt unreachable port, ist es open; andere Fehler = filtered; keine Antwort = open|filtered.
- **`-b <server>`:** FTPhost --> Dient dazu, einen Host über einen anderen zu scannen: Man verbindet sich mit dem FTP eines anderen Rechners und bittet ihn, Dateien an die zu testenden Ports zu senden; anhand der Antworten lässt sich erkennen, ob offen ist. Syntax: [\<user>:\<password>@]\<server>\[:\<port>]. Praktisch wenig nützlich, da die meisten FTP-Server das nicht mehr erlauben.

### Fokus-Analyse

**-p:** Zum Angeben der zu scannenden Ports. Alle 65.535 Ports auswählen: **-p-** oder **-p all**. Nmap hat eine interne Popularitätsklassifikation. Standardmäßig werden die Top-1000 Ports gescannt. Mit **-F** (Fast scan) werden die Top-100 analysiert. Mit **--top-ports <number>** kann eine bestimmte Anzahl der Top-Ports (von 1 bis 65.535) ausgewählt werden. Nmap prüft Ports in zufälliger Reihenfolge; um dies zu verhindern, nutze **-r**. Es lassen sich spezifische Ports angeben: 20-30,80,443,1024- (letzteres bedeutet ab 1024 aufwärts). Ports können auch nach Protokoll gruppiert werden: U:53,T:21-25,80,139,S:9. Ebenso kann ein Bereich innerhalb von Nmap's beliebten Ports gewählt werden: -p [-1024] analysiert bis Port 1024 aus den in nmap-services enthaltenen. **--port-ratio <ratio>** Analysiert die häufigsten Ports basierend auf einem Verhältnis zwischen 0 und 1.

**-sV** Versionserkennung; Intensität lässt sich von 0 bis 9 regeln, Standard ist 7.

**--version-intensity <number>** Regelt die Intensität; je niedriger, desto weniger und wahrscheinlicher die ausgeführten Probes. Damit lässt sich besonders die UDP-Scan-Dauer erheblich verkürzen.

**-O** OS-Erkennung

**--osscan-limit** Für verlässliche OS-Erkennung werden mindestens ein offener und ein geschlossener Port benötigt. Wenn diese Bedingung fehlt und diese Option gesetzt ist, wird keine OS-Vorhersage versucht (spart Zeit).

**--osscan-guess** Wenn die OS-Erkennung nicht perfekt ist, versucht diese Option aggressivere Vermutungen.

**Scripts**

--script _<filename>_|_<category>_|_<directory>_|_<expression>_[,...]

Um die default-Skripte zu verwenden, nutze -sC oder --script=default

Verfügbare Typen sind: auth, broadcast, default, discovery, dos, exploit, external, fuzzer, intrusive, malware, safe, version, und vuln

- **Auth:** Führt alle verfügbaren Authentication-Skripte aus
- **Default:** Führt grundlegende Default-Tool-Skripte aus
- **Discovery:** Holt Informationen vom Ziel oder Opfer
- **External:** Skripte zur Nutzung externer Ressourcen
- **Intrusive:** Nutzt Skripte, die als intrusive gegenüber dem Ziel gelten
- **Malware:** Prüft auf Verbindungen, die von Malware oder Backdoors geöffnet wurden
- **Safe:** Führt nicht-intrusive Skripte aus
- **Vuln:** Findet bekannte Schwachstellen
- **All:** Führt absolut alle verfügbaren NSE-Skripte aus

Zum Suchen von Skripten:

**nmap --script-help="http-\*" ->** Die mit http- beginnenden

**nmap --script-help="not intrusive" ->** Alle außer den intrusive

**nmap --script-help="default or safe" ->** Die in default oder safe oder beiden

**nmap --script-help="default and safe" ->** Die in beiden

**nmap --script-help="(default or safe or intrusive) and not http-\*"**

--script-args _<n1>_=_<v1>_,_<n2>_={_<n3>_=_<v3>_},_<n4>_={_<v4>_,_<v5>_}

--script-args-file _<filename>_

--script-help _<filename>_|_<category>_|_<directory>_|_<expression>_|all[,...]

--script-trace ---> Liefert Informationen darüber, wie das Skript abläuft

--script-updatedb

**Um ein Skript zu verwenden, einfach eingeben: nmap --script Script_Name target** --> Beim Ausführen laufen sowohl das Script als auch der Scanner, daher können Scanner-Optionen hinzugefügt werden. Wir können **"safe=1"** hinzufügen, um nur sichere Skripte auszuführen.

**Zeitsteuerung**

**Nmap kann Zeitangaben in Sekunden, Minuten, ms verändern:** --host-timeout Argumente 900000ms, 900, 900s, und 15m sind äquivalent.

Nmap teilt die Gesamtanzahl der zu scannenden Hosts in Gruppen und analysiert diese in Blöcken; es wechselt nicht zum nächsten Block, bis alle Hosts des aktuellen Blocks bearbeitet sind (und der Nutzer erhält keine Updates, bis der Block fertig ist). Daher ist es für Nmap optimal, große Gruppen zu verwenden. Standardmäßig in Klasse C verwendet es 256.

Dies lässt sich mit **--min-hostgroup** _**<numhosts>**_**;** **--max-hostgroup** _**<numhosts>**_ ändern (passt parallele Scan-Gruppengrößen an).

Die Anzahl paralleler Scanner lässt sich steuern, aber meist besser nicht (Nmap hat automatische Kontrolle anhand des Netzwerkstatus): **--min-parallelism** _**<numprobes>**_**;** **--max-parallelism** _**<numprobes>**_

Wir können das RTT-Timeout ändern, ist aber meist nicht nötig: **--min-rtt-timeout** _**<time>**_**,** **--max-rtt-timeout** _**<time>**_**,** **--initial-rtt-timeout** _**<time>**_

Wir können die Anzahl der Versuche ändern: **--max-retries** _**<numtries>**_

Wir können die Scan-Zeit eines Hosts ändern: **--host-timeout** _**<time>**_

Wir können die Wartezeit zwischen Tests erhöhen, um langsamer zu scannen: **--scan-delay** _**<time>**_**;** **--max-scan-delay** _**<time>**_

Wir können die Anzahl der Pakete pro Sekunde anpassen: **--min-rate** _**<number>**_**;** **--max-rate** _**<number>**_

Viele Ports brauchen lange bei gefiltertem oder geschlossenem Zustand. Wenn nur offene Ports interessieren, kann man schneller vorgehen mit: **--defeat-rst-ratelimit**

Zur Definition der Aggressivität von Nmap: -T paranoid|sneaky|polite|normal|aggressive|insane

-T (0-1)

-T0 --> Scannt nur 1 Port gleichzeitig und wartet 5 min bis zum nächsten

-T1 und T2 --> Sehr ähnlich; warten jeweils 15s bzw. 0.4s zwischen Tests

-T3 --> Standardbetrieb, beinhaltet paralleles Scannen

-T4 --> --max-rtt-timeout 1250ms --min-rtt-timeout 100ms --initial-rtt-timeout 500ms --max-retries 6 --max-scan-delay 10ms

-T5 --> --max-rtt-timeout 300ms --min-rtt-timeout 50ms --initial-rtt-timeout 250ms --max-retries 2 --host-timeout 15m --max-scan-delay 5ms

Firewall/IDS

Sie verhindern Zugriff auf Ports und analysieren Pakete.

**-f** Fragmentiert Pakete; standardmäßig in 8-Byte-Blöcke nach dem Header. Um die Größe anzugeben, nutzt man ..mtu (in dem Fall -f nicht verwenden). Der Offset muss Vielfaches von 8 sein. **Version-Scanner und Skripte unterstützen Fragmentation nicht.**

**-D decoy1,decoy2,ME** Nmap sendet Scans scheinbar von anderen IPs, um den Ursprung zu verschleiern. Wenn ME in der Liste steht, platziert Nmap dich dort — besser sind 5–6 Decoys vor dir, um komplett zu maskieren. Zufällige IPs können mit RND:<number> erzeugt werden. Funktioniert nicht mit TCP-Version-Detektoren ohne Verbindung. Im internen Netzwerk sind aktive IPs sinnvoll, sonst ist leicht ersichtlich, dass nur du aktiv bist.

Um zufällige IPs zu verwenden: nmap -D RND:10 Target_IP

**-S IP** Wenn Nmap deine IP nicht korrekt erkennt, kann sie hier gesetzt werden. Dient auch, um vorzutäuschen, ein anderer Host scanne.

**-e <interface>** Interface auswählen

Viele Administratoren lassen bestimmte Quell-Ports offen, damit Dienste funktionieren (z. B. DNS, FTP...). Um diese Situation auszunutzen, bietet Nmap: **--source-port** _**<portnumber>**_ ; **-g** _**<portnumber>**_ (sind äquivalent)

**--data** _**<hex string>**_ Sendet hexadezimale Daten: --data 0xdeadbeef und --data \xCA\xFE\x09

**--data-string** _**<string>**_ Sendet normalen Text: --data-string "Scan conducted by Security Ops, extension 7192"

**--data-length** _**<number>**_ Nmap sendet nur Header; mit dieser Option werden zusätzliche zufällige Bytes angehängt

Zur vollständigen Konfiguration des IP-Pakets nutze **--ip-options**

Wenn du die Optionen in gesendeten/empfangenen Paketen sehen willst, gib --packet-trace an. Für mehr Infos und Beispiele zur Nutzung von IP-Optionen mit Nmap siehe [http://seclists.org/nmap-dev/2006/q3/52](http://seclists.org/nmap-dev/2006/q3/52).

**--ttl** _**<value>**_

**--randomize-hosts** Macht den Angriff weniger offensichtlich

**--spoof-mac** _**<MAC address, prefix, or vendor name>**_ MAC ändern, Beispiele: Apple, 0, 01:02:03:04:05:06, deadbeefcafe, 0020F2, und Cisco

**--proxies** _**<Comma-separated list of proxy URLs>**_ Proxies verwenden; manche Proxies halten nicht so viele parallele Verbindungen wie Nmap erwartet — dann sollte die Parallelität mit --max-parallelism angepasst werden.

**-sP** Hosts im eigenen Netzwerk via ARP entdecken

Manche Admins erlauben alle Pakete, die von einem bestimmten Quellport kommen (z. B. 20, 53, 67). Man kann Nmap dazu bringen, Pakete von diesen Ports zu senden: **nmap --source-port 53 IP**

**Outputs**

**-oN file** Normale Ausgabe

**-oX file** XML-Ausgabe

**-oS file** Script kiddies output

**-oG file** Greppable output

**-oA file** Alle (außer -oS)

**-v level** Verbosity

**-d level** Debugging

**--reason** Grund für Host- und Statusangaben

**--stats-every time** Gibt alle diese Zeitintervalle Statusupdates

**--packet-trace** Zeigt ausgehende Pakete; Filter möglich wie: --version-trace oder --script-trace

**--open** Zeigt open, open|filtered und unfiltered

**--resume file** Setzt einen Scan fort / Ausgabetabelle

**Verschiedenes**

**-6** Aktiviert IPv6

**-A** entspricht -O -sV -sC --traceroute

**Laufzeitinteraktion**

Während Nmap läuft, können Optionen geändert werden:

v / V Erhöhe / verringere Verbosity-Level

d / D Erhöhe / verringere Debug-Level

p / P Schalte Packet Tracing ein / aus

? Zeigt eine Hilfe-Screen für Laufzeit-Interaktion

**Vulscan**

Nmap-Skript, das die ermittelten Service-Versionen gegen eine Offline-Datenbank (aus verschiedenen Quellen) prüft und mögliche Vulnerabilities zurückliefert

Die verwendeten DBs sind:

1. Scipvuldb.csv | [http://www.scip.ch/en/?vuldb](http://www.scip.ch/en/?vuldb)
2. Cve.csv | [http://cve.mitre.org](http://cve.mitre.org/)
3. Osvdb.csv | [http://www.osvdb.org](http://www.osvdb.org/)
4. Securityfocus.csv | [http://www.securityfocus.com/bid/](http://www.securityfocus.com/bid/)
5. Securitytracker.csv | [http://www.securitytracker.com](http://www.securitytracker.com/)
6. Xforce.csv | [http://xforce.iss.net](http://xforce.iss.net/)
7. Exploitdb.csv | [http://www.exploit-db.com](http://www.exploit-db.com/)
8. Openvas.csv | [http://www.openvas.org](http://www.openvas.org/)

Zum Download und Installieren in den Nmap-Ordner:

wget http://www.computec.ch/projekte/vulscan/download/nmap_nse_vulscan-2.0.tar.gz && tar -czvf nmap_nse_vulscan-2.0.tar.gz vulscan/ && sudo cp -r vulscan/ /usr/share/nmap/scripts/

Zusätzlich müssen die DB-Pakete heruntergeladen und nach /usr/share/nmap/scripts/vulscan/ gelegt werden.

Verwendung:

Um alle DBs zu nutzen: sudo nmap -sV --script=vulscan HOST_TO_SCAN

Um eine spezifische DB zu nutzen: sudo nmap -sV --script=vulscan --script-args vulscandb=cve.csv HOST_TO_SCAN

## Nmap Service-Scan x16 beschleunigen

Laut [**diesem Beitrag**](https://joshua.hu/nmap-speedup-service-scanning-16x) kann die Service-Analyse von nmap beschleunigt werden, indem alle **`totalwaitms`**-Werte in **`/usr/share/nmap/nmap-service-probes`** auf **300** und **`tcpwrappedms`** auf **200** gesetzt werden.

Außerdem verwenden Probes, die keinen spezifischen **`servicewaitms`**-Wert haben, einen Default-Wert von **`5000`**. Daher kann man entweder explizit Werte zu jedem Probe-Eintrag hinzufügen oder nmap selbst kompilieren und den Default-Wert in [**service_scan.h**](https://github.com/nmap/nmap/blob/master/service_scan.h#L79) ändern.

Wenn du die Werte **`totalwaitms`** und **`tcpwrappedms`** im `/usr/share/nmap/nmap-service-probes`-File überhaupt nicht ändern möchtest, kannst du den [Parsing-Code](https://github.com/nmap/nmap/blob/master/service_scan.cc#L1358) so anpassen, dass diese Werte in der `nmap-service-probes`-Datei komplett ignoriert werden.

## Statisches Nmap für restriktive Umgebungen bauen

In gehärteten oder minimalen Linux-Umgebungen (Container, Appliances) schlagen dynamisch gelinkte Nmap-Binaries oft fehl, weil Laufzeit-Loader oder Shared Libraries fehlen (z. B. /lib64/ld-linux-x86-64.so.2, libc.so). Ein statisch gelinktes Nmap zu bauen und NSE-Daten mitzuliefern ermöglicht die Ausführung ohne Systempakete zu installieren.

High-level Vorgehen
- Einen sauberen amd64 Ubuntu-Builder via Docker verwenden.
- OpenSSL und PCRE2 als statische Libraries bauen.
- Nmap statisch linkend bauen und die eingebundenen libpcap/libdnet verwenden, um dynamische Abhängigkeiten zu vermeiden.
- NSE-Skripte und Datenverzeichnisse mit dem Binary bündeln.

Zielarchitektur ermitteln (Beispiel)
```bash
uname -a
# If building from macOS/ARM/etc., pin the builder arch:
docker run --rm --platform=linux/amd64 -v "$(pwd)":/out -w /tmp ubuntu:22.04 bash -lc 'echo ok'
```
Schritt 1 — Toolchain vorbereiten
```bash
set -euo pipefail
export DEBIAN_FRONTEND=noninteractive
apt-get update && apt-get install -y --no-install-recommends \
build-essential ca-certificates curl bzip2 xz-utils pkg-config perl python3 file git \
automake autoconf libtool m4 zlib1g-dev
```
Schritt 2 — Statisches OpenSSL kompilieren (1.1.1w)
```bash
OSSL="1.1.1w"
curl -fsSLO "https://www.openssl.org/source/openssl-$OSSL.tar.gz"
tar xzf "openssl-$OSSL.tar.gz" && cd "openssl-$OSSL"
./Configure no-shared no-zlib linux-x86_64 -static --prefix=/opt/ossl
make -j"$(nproc)" && make install_sw
cd /tmp
```
Schritt 3 — PCRE2 (10.43) statisch bauen
```bash
PCRE2=10.43
curl -fsSLO "https://github.com/PCRE2Project/pcre2/releases/download/pcre2-$PCRE2/pcre2-$PCRE2.tar.bz2"
tar xjf "pcre2-$PCRE2.tar.bz2" && cd "pcre2-$PCRE2"
./configure --disable-shared --enable-static --prefix=/opt/pcre2
make -j"$(nproc)" && make install
cd /tmp
```
Schritt 4 — Nmap (7.98) statisch kompilieren
```bash
NMAP=7.98
curl -fsSLO "https://nmap.org/dist/nmap-$NMAP.tar.bz2"
tar xjf "nmap-$NMAP.tar.bz2" && cd "nmap-$NMAP"
export CPPFLAGS="-I/opt/ossl/include -I/opt/pcre2/include"
export LDFLAGS="-L/opt/ossl/lib -L/opt/pcre2/lib -static -static-libstdc++ -static-libgcc"
export LIBS="-lpcre2-8 -ldl -lpthread -lz"
./configure \
--with-openssl=/opt/ossl \
--with-libpcre=/opt/pcre2 \
--with-libpcap=included \
--with-libdnet=included \
--without-zenmap --without-ndiff --without-nmap-update
# Avoid building shared libpcap by accident
sed -i -e "s/^shared: /shared: #/" libpcap/Makefile || true
make -j1 V=1 nmap
strip nmap
```
Wichtige Punkte
- -static, -static-libstdc++, -static-libgcc erzwingen statische Verlinkung.
- Die Verwendung von --with-libpcap=included/--with-libdnet=included vermeidet systemweit geteilte Bibliotheken.
- sed-Anpassung neutralisiert ein shared libpcap-Ziel, falls vorhanden.

Schritt 5 — Binärdatei und NSE-Daten bündeln
```bash
mkdir -p /out/nmap-bundle/nmap-data
cp nmap /out/nmap-bundle/nmap-linux-amd64-static
cp -r scripts nselib /out/nmap-bundle/nmap-data/
cp nse_main.lua nmap-services nmap-protocols nmap-service-probes \
nmap-mac-prefixes nmap-os-db nmap-payloads nmap-rpc \
/out/nmap-bundle/nmap-data/ 2>/dev/null || true

tar -C /out -czf /out/nmap-linux-amd64-static-bundle.tar.gz nmap-bundle
```
Verifikation und Ops-Hinweise
- Benutze file auf dem Artefakt, um zu bestätigen, dass es statisch gelinkt ist.
- Bewahre NSE-Daten zusammen mit der Binärdatei auf, um Skript-Parität auf Hosts ohne installiertes Nmap sicherzustellen.
- Selbst bei einer statischen Binärdatei kann die Ausführung durch AppArmor/seccomp/SELinux blockiert werden; DNS/egress muss weiterhin funktionieren.
- Deterministische Builds verringern das Risiko in der Lieferkette gegenüber dem Herunterladen undurchsichtiger „statischer“ Binärdateien.

One-liner (Dockerized)
<details>
<summary>Erstellen, bündeln und Artefaktinformationen ausgeben</summary>
```bash
docker run --rm --platform=linux/amd64 -v "$(pwd)":/out -w /tmp ubuntu:22.04 bash -lc '
set -euo pipefail
export DEBIAN_FRONTEND=noninteractive
apt-get update && apt-get install -y --no-install-recommends \
build-essential ca-certificates curl bzip2 xz-utils pkg-config perl python3 file git \
automake autoconf libtool m4 zlib1g-dev

OSSL="1.1.1w"; curl -fsSLO "https://www.openssl.org/source/openssl-$OSSL.tar.gz" \
&& tar xzf "openssl-$OSSL.tar.gz" && cd "openssl-$OSSL" \
&& ./Configure no-shared no-zlib linux-x86_64 -static --prefix=/opt/ossl \
&& make -j"$(nproc)" && make install_sw && cd /tmp

PCRE2=10.43; curl -fsSLO "https://github.com/PCRE2Project/pcre2/releases/download/pcre2-$PCRE2/pcre2-$PCRE2.tar.bz2" \
&& tar xjf "pcre2-$PCRE2.tar.bz2" && cd "pcre2-$PCRE2" \
&& ./configure --disable-shared --enable-static --prefix=/opt/pcre2 \
&& make -j"$(nproc)" && make install && cd /tmp

NMAP=7.98; curl -fsSLO "https://nmap.org/dist/nmap-$NMAP.tar.bz2" \
&& tar xjf "nmap-$NMAP.tar.bz2" && cd "nmap-$NMAP" \
&& export CPPFLAGS="-I/opt/ossl/include -I/opt/pcre2/include" \
&& export LDFLAGS="-L/opt/ossl/lib -L/opt/pcre2/lib -static -static-libstdc++ -static-libgcc" \
&& export LIBS="-lpcre2-8 -ldl -lpthread -lz" \
&& ./configure --with-openssl=/opt/ossl --with-libpcre=/opt/pcre2 --with-libpcap=included --with-libdnet=included --without-zenmap --without-ndiff --without-nmap-update \
&& sed -i -e "s/^shared: /shared: #/" libpcap/Makefile || true \
&& make -j1 V=1 nmap && strip nmap

mkdir -p /out/nmap-bundle/nmap-data \
&& cp nmap /out/nmap-bundle/nmap-linux-amd64-static \
&& cp -r scripts nselib /out/nmap-bundle/nmap-data/ \
&& cp nse_main.lua nmap-services nmap-protocols nmap-service-probes nmap-mac-prefixes nmap-os-db nmap-payloads nmap-rpc /out/nmap-bundle/nmap-data/ 2>/dev/null || true \
&& tar -C /out -czf /out/nmap-linux-amd64-static-bundle.tar.gz nmap-bundle \
&& echo "===== OUTPUT ====="; ls -lah /out; echo "===== FILE TYPE ====="; file /out/nmap-bundle/nmap-linux-amd64-static || true
'
```
</details>

## Referenzen

- [Compiling static Nmap binary for jobs in restricted environments](https://www.pentestpartners.com/security-blog/compiling-static-nmap-binary-for-jobs-in-restricted-environments/)
- [Static Nmap Binary Generator (helper tool)](https://github.com/0x5ubt13/static_nmap_binary_generator)
- [OpenSSL sources](https://www.openssl.org/source/)
- [PCRE2 releases](https://github.com/PCRE2Project/pcre2/releases)
- [Nmap source tarballs](https://nmap.org/dist/)


{{#include ../../banners/hacktricks-training.md}}
