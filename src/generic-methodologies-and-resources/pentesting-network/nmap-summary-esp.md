# Nmap Resumen (ESP)

{{#include ../../banners/hacktricks-training.md}}
```
nmap -sV -sC -O -n -oA nmapscan 192.168.0.1/24
```
## Parámetros

### IPs a escanear

- **`<ip>,<net/mask>`:** Indica las IPs directamente
- **`-iL <ips_file>`:** list_IPs
- **`-iR <number>`**: Número de IPs aleatorias, puedes excluir IPs posibles con `--exclude <Ips>` o `--excludefile <file>`.

### Descubrimiento de equipos

Por defecto Nmap lanza una fase de descubrimiento consistente en: `-PA80 -PS443 -PE -PP`

- **`-sL`**: No es invasivo, lista los objetivos realizando peticiones **DNS** para resolver nombres. Es útil para saber si por ejemplo www.prueba.es/24 todas las IPs son nuestros objetivos.
- **`-Pn`**: **No ping**. Útil si sabes que todos están activos (si no, podrías perder mucho tiempo, pero esta opción también produce falsos negativos indicando que no están activos), evita la fase de descubrimiento.
- **`-sn`** : **Sin escaneo de puertos**. Tras completar la fase de reconocimiento, no escanea puertos. Es relativamente sigiloso y permite un escaneo de red pequeño. Con privilegios envía un ACK (-PA) a 80, un SYN(-PS) a 443 y un echo request y un Timestamp request, sin privilegios siempre completa conexiones. Si el objetivo es la red, solo usa ARP(-PR). Si se usa con otra opción, solo se descartan los paquetes de la otra opción.
- **`-PR`**: **Ping ARP**. Se usa por defecto al analizar equipos en nuestra red, es más rápido que usar pings. Si no quieres usar paquetes ARP usa `--send-ip`.
- **`-PS <ports>`**: Envía paquetes SYN a los cuales si responden SYN/ACK está abierto (a los que responden con RST para no finalizar la conexión), si responde RST está cerrado y si no responde está inalcanzable. En caso de no tener privilegios, se usa automáticamente una conexión completa. Si no se indican puertos, lo lanza al 80.
- **`-PA <ports>`**: Como el anterior pero con ACK; combinarlos da mejores resultados.
- **`-PU <ports>`**: El objetivo es el opuesto, se envían a puertos que se esperan cerrados. Algunos firewalls solo comprueban conexiones TCP. Si está cerrado responde con port unreachable; si responde con otro ICMP o no responde se deja como destination unreachable.
- **`-PE, -PP, -PM`** : PINGS ICMP: echo reply, timestamp y addresmask. Se lanzan para averiguar si el objetivo está activo.
- **`-PY<ports>`**: Envía sondas SCTP INIT a 80 por defecto, puede responder INIT-ACK (open) o ABORT (closed) o nada o ICMP unreachable (inactive).
- **`-PO <protocols>`**: Se indica un protocolo en los headers, por defecto 1(ICMP), 2(IGMP) y 4(Encap IP). Para ICMP, IGMP, TCP (6) y UDP (17) se envían los headers de protocolo; para el resto solo se envía el header IP. El propósito es que debido a la malformación de los headers, lleguen respuestas Protocol unreachable o respuestas del mismo protocolo para saber si está arriba.
- **`-n`**: Sin DNS
- **`-R`**: DNS siempre

### Técnicas de escaneo de puertos

- **`-sS`**: No completa la conexión por lo que no deja rastro, muy buena si puede usarse (privilegios). Es la usada por defecto.
- **`-sT`**: Completa la conexión, por lo que deja rastro, pero se puede usar seguro. Por defecto sin privilegios.
- **`-sU`**: Más lento, para UDP. Principalmente: DNS(53), SNMP(161,162), DHCP(67 y 68), (`-sU53,161,162,67,68`): open(reply), closed(port unreachable), filtered (otro ICMP), open/filtered (nada). En caso de open/filtered, `-sV` envía numerosas peticiones para detectar cualquiera de las versiones que nmap soporta y puede detectar el estado real. Incrementa mucho el tiempo.
- **`-sY`**: Protocolo SCTP que no llega a establecer la conexión, por lo que no hay logs, funciona como `-PY`.
- **`-sN,-sX,-sF`:** Null, Fin, Xmas, pueden penetrar algunos firewalls y extraer información. Se basan en que máquinas conformes al estándar deberían responder con RST todas las peticiones que no tienen SYN, RST o ACK activados: open/filtered(nada), closed(RST), filtered (ICMP unreachable). Poco fiables en Windows, Cisco, BSDI y OS/400. En Unix sí.
- **`-sM`**: Maimon scan: Envía flags FIN y ACK, usado para BSD, actualmente devolverá todo como closed.
- **`-sA, sW`**: ACK y Window, se usa para detectar firewalls, para saber si los puertos están filtrados o no. `-sW` distingue entre open/closed ya que los abiertos responden con un valor de window distinto: open (RST con window distinto de 0), closed (RST window = 0), filtered (ICMP unreachable o nada). No todos los equipos funcionan así, por lo que si todo sale closed, no está funcionando; si salen algunos open, funciona bien; y si salen muchos open y pocos closed, funciona a la inversa.
- **`-sI`:** Idle scan. Para casos en los que hay un firewall activo pero sabemos que no filtra hacia cierta IP (o cuando simplemente queremos anonimato) podemos usar el scanner zombie (funciona para todos los puertos). Para buscar posibles zombies podemos usar el script ipidseq o el exploit auxiliary/scanner/ip/ipidseq. Este scanner se basa en el número IPID de los paquetes IP.
- **`--badsum`:** Envía la suma errónea; los equipos descartarían los paquetes, pero los firewalls podrían contestar algo; se usa para detectar firewalls.
- **`-sZ`:** Escáner SCTP "Weird", al enviar probes con cookie echo fragments deberían ser descartados si están open o respondidos con ABORT si están closed. Puede pasar por firewalls por donde init no pasa, lo malo es que no distingue entre filtered y open.
- **`-sO`:** Escaneo de protocolos IP. Envía headers malos y vacíos en los que a veces ni siquiera se puede distinguir el protocolo. Si llega ICMP unreachable protocol está cerrado, si llega unreachable port está abierto, si llega otro error, filtered, si no llega nada, open|filtered.
- **`-b <server>`:** FTPhost --> Se usa para escanear un host desde otro, esto se hace conectando al ftp de otra máquina y pidiéndole que envíe archivos a los puertos que quieres escanear desde otra máquina; según las respuestas sabremos si están open o no. [\<user>:\<password>@]\<server>\[:\<port>] Casi todos los servidores ftp ya no permiten esto, por lo que tiene poco uso práctico.

### Análisis Enfocado

**-p:** Usado para especificar puertos a escanear. Para seleccionar los 65.535 puertos: **-p-** o **-p all**. Nmap tiene una clasificación interna basada en popularidad. Por defecto usa los 1000 puertos principales. Con **-F** (fast scan) analiza los 100 principales. Con **--top-ports <number>** analiza ese número de puertos principales (de 1 a 65.335). Revisa los puertos en orden aleatorio; para evitar esto, usa **-r**. También podemos seleccionar puertos específicos: 20-30,80,443,1024- (esto último significa mirar desde 1024 en adelante). También podemos agrupar puertos por protocolos: U:53,T:21-25,80,139,S:9. También podemos elegir un rango dentro de los puertos populares de Nmap: `-p [-1024]` analiza hasta el puerto 1024 de los incluidos en nmap-services. **--port-ratio <ratio>** Analiza los puertos más comunes dentro de una razón entre 0 y 1

**-sV** Escaneo de versiones; la intensidad se puede regular de 0 a 9, por defecto es 7.

**--version-intensity <number>** Regulamos la intensidad, de modo que cuanto menor sea, solo lanzará las probes más probables, pero no todas. Con esto podemos acortar considerablemente el tiempo de escaneo UDP

**-O** Detección de SO

**--osscan-limit** Para una detección de SO adecuada se necesita al menos un puerto abierto y uno cerrado. Si no se cumple esta condición y hemos activado esto, no intentará predecir el SO (ahorra tiempo)

**--osscan-guess** Cuando la detección de SO no es perfecta, esto hace que lo intente con más ahínco

**Scripts**

--script _<filename>_|_<category>_|_<directory>_|_<expression>_[,...]

Para usar los scripts por defecto, usa `-sC` o `--script=default`

Tipos disponibles: auth, broadcast, default, discovery, dos, exploit, external, fuzzer, intrusive, malware, safe, version, y vuln

- **Auth:** ejecuta todos los scripts de autenticación disponibles
- **Default:** ejecuta los scripts básicos por defecto
- **Discovery:** recupera información del target o víctima
- **External:** script para usar recursos externos
- **Intrusive:** usa scripts considerados intrusivos para la víctima o target
- **Malware:** comprueba conexiones abiertas por código malicioso o backdoors
- **Safe:** ejecuta scripts no intrusivos
- **Vuln:** descubre las vulnerabilidades más conocidas
- **All:** ejecuta absolutamente todos los scripts NSE disponibles

Para buscar scripts:

**nmap --script-help="http-*" -> Aquellos que comienzan con http-**

**nmap --script-help="not intrusive" -> Todos excepto esos**

**nmap --script-help="default or safe" -> Los que estén en uno u otro**

**nmap --script-help="default and safe" --> Los que estén en ambos**

**nmap --script-help="(default or safe or intrusive) and not http-*"**

--script-args _<n1>_=_<v1>_,_<n2>_={_<n3>_=_<v3>_},_<n4>_={_<v4>_,_<v5>_}

--script-args-file _<filename>_

--script-help _<filename>_|_<category>_|_<directory>_|_<expression>_|all[,...]

--script-trace ---> Proporciona info sobre cómo progresa el script

--script-updatedb

**Para usar un script, simplemente escribe: `nmap --script Script_Name target`** --> Al usar el script, tanto el script como el scanner se ejecutarán, por lo que también se pueden añadir opciones del scanner. Podemos añadir **"safe=1"** para ejecutar solo los seguros.

**Control de tiempo**

**Nmap puede modificar tiempos en segundos, minutos, ms:** `--host-timeout` argumentos `900000ms`, `900`, `900s`, y `15m` todos hacen lo mismo.

Nmap divide el número total de hosts a escanear en grupos y analiza estos grupos en bloques, por lo que no pasa al siguiente bloque hasta que todos han sido analizados (y el usuario no recibe actualizaciones hasta que el bloque se ha analizado). De este modo, es más óptimo para Nmap usar grupos grandes. Por defecto en clase C usa 256.

Esto se puede cambiar con **--min-hostgroup** _**<numhosts>**_; **--max-hostgroup** _**<numhosts>**_ (Ajusta tamaños de grupos de escaneo paralelo)

Puedes controlar el número de scanners en paralelo pero es mejor no hacerlo (Nmap ya incorpora control automático basado en el estado de la red): **--min-parallelism** _**<numprobes>**_; **--max-parallelism** _**<numprobes>**_

Podemos modificar el timeout RTT, pero normalmente no es necesario: **--min-rtt-timeout** _**<time>**_, **--max-rtt-timeout** _**<time>**_, **--initial-rtt-timeout** _**<time>**_

Podemos modificar el número de intentos: **--max-retries** _**<numtries>**_

Podemos modificar el tiempo de escaneo de un host: **--host-timeout** _**<time>**_

Podemos modificar el tiempo entre cada prueba para ralentizarlo: **--scan-delay** _**<time>**_; **--max-scan-delay** _**<time>**_

Podemos modificar el número de paquetes por segundo: **--min-rate** _**<number>**_; **--max-rate** _**<number>**_

Muchos puertos tardan mucho en responder cuando están filtrados o cerrados. Si solo nos interesan los abiertos, podemos ir más deprisa con: **--defeat-rst-ratelimit**

Para definir cuán agresivo queremos que sea Nmap: `-T paranoid|sneaky|polite|normal|aggressive|insane`

-T (0-1)

-T0 --> Solo escanea 1 puerto a la vez y espera 5min hasta el siguiente

-T1 y T2 --> Muy similares pero solo esperan 15 y 0.4s respectivamente entre cada prueba

-T3 --> Operación por defecto, incluye escaneo paralelo

-T4 --> `--max-rtt-timeout 1250ms --min-rtt-timeout 100ms --initial-rtt-timeout 500ms --max-retries 6 --max-scan-delay 10ms`

-T5 --> `--max-rtt-timeout 300ms --min-rtt-timeout 50ms --initial-rtt-timeout 250ms --max-retries 2 --host-timeout 15m --max-scan-delay 5ms`

**Firewall/IDS**

No permiten acceso a puertos y analizan paquetes.

**-f** Para fragmentar paquetes; por defecto los fragmenta en 8bytes después del header, para especificar ese tamaño usamos ..mtu (con esto, no usar `-f`), el offset debe ser múltiplo de 8. **Los version scanners y scripts no soportan fragmentación**

**-D decoy1,decoy2,ME** Nmap envía escaneos pero con otras direcciones IP como origen, así te oculta. Si pones ME en la lista, Nmap te colocará ahí; es mejor poner 5 o 6 antes que tú para enmascararte completamente. IPs aleatorias pueden generarse con `RND:<number>` para generar <number> de IPs aleatorias. No funcionan con version detectors TCP sin conexión. Si estás dentro de una red, interesa usar IPs activas, ya que de lo contrario será muy fácil deducir que eres el único activo.

Para usar IPs aleatorias: `nmap -D RND:10 Target_IP`

**-S IP** Para cuando Nmap no detecta tu IP debes dársela con esto. También sirve para hacerles pensar que otro objetivo les está escaneando.

**-e <interface>** Para elegir la interfaz

Muchos administradores dejan puertos de entrada abiertos para que todo funcione correctamente y les sea más fácil que buscar otra solución. Estos pueden ser puertos DNS o FTP... para encontrar esta vulnerabilidad Nmap incorpora: **--source-port** _**<portnumber>**_ ; `-g` _**<portnumber>**_ _Son equivalentes_

**--data** _**<hex string>**_ Para enviar texto hexadecimal: `--data 0xdeadbeef` y `--data \xCA\xFE\x09`

**--data-string** _**<string>**_ Para enviar texto normal: `--data-string "Scan conducted by Security Ops, extension 7192"`

**--data-length** _**<number>**_ Nmap solo envía headers; con esto añadimos un número de bytes más (que serán generados aleatoriamente)

Para configurar el paquete IP completamente usa **--ip-options**

Si deseas ver las opciones en los paquetes enviados y recibidos, especifica `--packet-trace`. Para más información y ejemplos de uso de IP options con Nmap, ver [http://seclists.org/nmap-dev/2006/q3/52](http://seclists.org/nmap-dev/2006/q3/52).

**--ttl** _**<value>**_

**--randomize-hosts** Para hacer el ataque menos obvio

**--spoof-mac** _**<MAC address, prefix, or vendor name>**_ Para cambiar la MAC ejemplos: Apple, 0, 01:02:03:04:05:06, deadbeefcafe, 0020F2, y Cisco

**--proxies** _**<Comma-separated list of proxy URLs>**_ Para usar proxies; a veces un proxy no mantiene tantas conexiones abiertas como Nmap quiere, por lo que habría que modificar el paralelismo: `--max-parallelism`

**-sP** Para descubrir hosts en nuestra red por ARP

Muchos administradores crean una regla de firewall que permite pasar todos los paquetes provenientes de un puerto particular (como 20,53 y 67); podemos decirle a Nmap que envíe nuestros paquetes desde esos puertos: `nmap --source-port 53 IP`

**Salidas**

**-oN file** Salida normal

**-oX file** Salida XML

**-oS file** Script kiddies output

**-oG file** Salida Greppable

**-oA file** Todo excepto `-oS`

**-v level** verbosidad

**-d level** depuración

**--reason** Motivo del estado del host

**--stats-every time** Cada ese tiempo nos dice cómo va

**--packet-trace** Para ver qué paquetes salen; se pueden especificar filtros como: `--version-trace` o `--script-trace`

**--open** muestra open, open|filtered y unfiltered

**--resume file** Resume una salida

**Miscelánea**

**-6** Permite IPv6

**-A** es lo mismo que `-O -sV -sC --traceroute`

**Tiempo de ejecución**

Mientras Nmap está corriendo podemos cambiar opciones:

v / V Aumentar / disminuir el nivel de verbosidad

d / D Aumentar / disminuir el nivel de depuración

p / P Activar / desactivar el trazado de paquetes

? Imprime una pantalla de ayuda de interacción en tiempo de ejecución

**Vulscan**

Script de Nmap que mira las versiones de servicios obtenidas en una base de datos offline (descargada de otras muy importantes) y devuelve posibles vulnerabilidades

Las DBs que usa son:

1. Scipvuldb.csv | [http://www.scip.ch/en/?vuldb](http://www.scip.ch/en/?vuldb)
2. Cve.csv | [http://cve.mitre.org](http://cve.mitre.org/)
3. Osvdb.csv | [http://www.osvdb.org](http://www.osvdb.org/)
4. Securityfocus.csv | [http://www.securityfocus.com/bid/](http://www.securityfocus.com/bid/)
5. Securitytracker.csv | [http://www.securitytracker.com](http://www.securitytracker.com/)
6. Xforce.csv | [http://xforce.iss.net](http://xforce.iss.net/)
7. Exploitdb.csv | [http://www.exploit-db.com](http://www.exploit-db.com/)
8. Openvas.csv | [http://www.openvas.org](http://www.openvas.org/)

Para descargar e instalar en la carpeta de Nmap:

wget http://www.computec.ch/projekte/vulscan/download/nmap_nse_vulscan-2.0.tar.gz && tar -czvf nmap_nse_vulscan-2.0.tar.gz vulscan/ && sudo cp -r vulscan/ /usr/share/nmap/scripts/

También necesitarás descargar los paquetes DB y añadirlos a `/usr/share/nmap/scripts/vulscan/`

Uso:

Para usar todo: `sudo nmap -sV --script=vulscan HOST_TO_SCAN`

Para usar una DB específica: `sudo nmap -sV --script=vulscan --script-args vulscandb=cve.csv HOST_TO_SCAN`

## Acelerar Nmap Service scan x16

Según [**this post**](https://joshua.hu/nmap-speedup-service-scanning-16x) puedes acelerar el análisis de servicios de nmap modificando todos los valores de **`totalwaitms`** en **`/usr/share/nmap/nmap-service-probes`** a **300** y **`tcpwrappedms`** a **200**.

Además, las probes que no tienen un **`servicewaitms`** específicamente definido usan un valor por defecto de **`5000`**. Por lo tanto, podemos añadir valores a cada una de las probes, o podemos **compilar nmap** nosotros mismos y cambiar el valor por defecto en [**service_scan.h**](https://github.com/nmap/nmap/blob/master/service_scan.h#L79).

Si no quieres cambiar los valores de **`totalwaitms`** y **`tcpwrappedms`** en el archivo `/usr/share/nmap/nmap-service-probes`, puedes editar el [parsing code](https://github.com/nmap/nmap/blob/master/service_scan.cc#L1358) de modo que estos valores en el archivo `nmap-service-probes` sean completamente ignorados.

## Compilar un Nmap estático para entornos restringidos

En entornos Linux endurecidos o mínimos (containers, appliances), los binarios Nmap enlazados dinámicamente a menudo fallan debido a cargadores de tiempo de ejecución o librerías compartidas faltantes (p. ej., /lib64/ld-linux-x86-64.so.2, libc.so). Construir tu propio Nmap ligado estáticamente y empaquetar los datos NSE permite la ejecución sin instalar paquetes del sistema.

Enfoque de alto nivel
- Usa un builder Ubuntu amd64 limpio vía Docker.
- Compila OpenSSL y PCRE2 como librerías estáticas.
- Compila Nmap vinculando estáticamente y usando libpcap/libdnet incluidos para evitar dependencias dinámicas.
- Empaqueta los scripts NSE y directorios de datos con el binario.

Descubrir la arquitectura objetivo (ejemplo)
```bash
uname -a
# If building from macOS/ARM/etc., pin the builder arch:
docker run --rm --platform=linux/amd64 -v "$(pwd)":/out -w /tmp ubuntu:22.04 bash -lc 'echo ok'
```
Paso 1 — Preparar el conjunto de herramientas
```bash
set -euo pipefail
export DEBIAN_FRONTEND=noninteractive
apt-get update && apt-get install -y --no-install-recommends \
build-essential ca-certificates curl bzip2 xz-utils pkg-config perl python3 file git \
automake autoconf libtool m4 zlib1g-dev
```
Paso 2 — Compilar OpenSSL estático (1.1.1w)
```bash
OSSL="1.1.1w"
curl -fsSLO "https://www.openssl.org/source/openssl-$OSSL.tar.gz"
tar xzf "openssl-$OSSL.tar.gz" && cd "openssl-$OSSL"
./Configure no-shared no-zlib linux-x86_64 -static --prefix=/opt/ossl
make -j"$(nproc)" && make install_sw
cd /tmp
```
Paso 3 — Compilar PCRE2 estático (10.43)
```bash
PCRE2=10.43
curl -fsSLO "https://github.com/PCRE2Project/pcre2/releases/download/pcre2-$PCRE2/pcre2-$PCRE2.tar.bz2"
tar xjf "pcre2-$PCRE2.tar.bz2" && cd "pcre2-$PCRE2"
./configure --disable-shared --enable-static --prefix=/opt/pcre2
make -j"$(nproc)" && make install
cd /tmp
```
Paso 4 — Compilar Nmap estático (7.98)
```bash
NMAP=7.98
curl -fsSLO "https://nmap.org/dist/nmap-$NMAP.tar.bz2"
tar xjf "nmap-$NMAP.tar.bz2" && cd "nmap-$NMAP"
export CPPFLAGS="-I/opt/ossl/include -I/opt/pcre2/include"
export LDFLAGS="-L/opt/ossl/lib -L/opt/pcre2/lib -static -static-libstdc++ -static-libgcc"
export LIBS="-lpcre2-8 -ldl -lpthread -lz"
./configure \
--with-openssl=/opt/ossl \
--with-libpcre=/opt/pcre2 \
--with-libpcap=included \
--with-libdnet=included \
--without-zenmap --without-ndiff --without-nmap-update
# Avoid building shared libpcap by accident
sed -i -e "s/^shared: /shared: #/" libpcap/Makefile || true
make -j1 V=1 nmap
strip nmap
```
Puntos clave
- -static, -static-libstdc++, -static-libgcc forzan el enlace estático.
- Usar --with-libpcap=included/--with-libdnet=included evita las bibliotecas compartidas del sistema.
- El ajuste con sed neutraliza un objetivo libpcap compartido si está presente.

Paso 5 — Empaquetar el binario y los datos NSE
```bash
mkdir -p /out/nmap-bundle/nmap-data
cp nmap /out/nmap-bundle/nmap-linux-amd64-static
cp -r scripts nselib /out/nmap-bundle/nmap-data/
cp nse_main.lua nmap-services nmap-protocols nmap-service-probes \
nmap-mac-prefixes nmap-os-db nmap-payloads nmap-rpc \
/out/nmap-bundle/nmap-data/ 2>/dev/null || true

tar -C /out -czf /out/nmap-linux-amd64-static-bundle.tar.gz nmap-bundle
```
Notas de verificación y operaciones
- Usar el archivo del artefacto para confirmar que está enlazado estáticamente.
- Mantener los datos NSE con el binario para asegurar la paridad de scripts en hosts sin Nmap instalado.
- Incluso con un binario estático, la ejecución puede ser bloqueada por AppArmor/seccomp/SELinux; DNS/egress debe seguir funcionando.
- Las compilaciones determinísticas reducen el riesgo de la cadena de suministro frente a descargar binarios opacos “static”.

One-liner (Dockerized)
<details>
<summary>Construir, empaquetar e imprimir información del artefacto</summary>
```bash
docker run --rm --platform=linux/amd64 -v "$(pwd)":/out -w /tmp ubuntu:22.04 bash -lc '
set -euo pipefail
export DEBIAN_FRONTEND=noninteractive
apt-get update && apt-get install -y --no-install-recommends \
build-essential ca-certificates curl bzip2 xz-utils pkg-config perl python3 file git \
automake autoconf libtool m4 zlib1g-dev

OSSL="1.1.1w"; curl -fsSLO "https://www.openssl.org/source/openssl-$OSSL.tar.gz" \
&& tar xzf "openssl-$OSSL.tar.gz" && cd "openssl-$OSSL" \
&& ./Configure no-shared no-zlib linux-x86_64 -static --prefix=/opt/ossl \
&& make -j"$(nproc)" && make install_sw && cd /tmp

PCRE2=10.43; curl -fsSLO "https://github.com/PCRE2Project/pcre2/releases/download/pcre2-$PCRE2/pcre2-$PCRE2.tar.bz2" \
&& tar xjf "pcre2-$PCRE2.tar.bz2" && cd "pcre2-$PCRE2" \
&& ./configure --disable-shared --enable-static --prefix=/opt/pcre2 \
&& make -j"$(nproc)" && make install && cd /tmp

NMAP=7.98; curl -fsSLO "https://nmap.org/dist/nmap-$NMAP.tar.bz2" \
&& tar xjf "nmap-$NMAP.tar.bz2" && cd "nmap-$NMAP" \
&& export CPPFLAGS="-I/opt/ossl/include -I/opt/pcre2/include" \
&& export LDFLAGS="-L/opt/ossl/lib -L/opt/pcre2/lib -static -static-libstdc++ -static-libgcc" \
&& export LIBS="-lpcre2-8 -ldl -lpthread -lz" \
&& ./configure --with-openssl=/opt/ossl --with-libpcre=/opt/pcre2 --with-libpcap=included --with-libdnet=included --without-zenmap --without-ndiff --without-nmap-update \
&& sed -i -e "s/^shared: /shared: #/" libpcap/Makefile || true \
&& make -j1 V=1 nmap && strip nmap

mkdir -p /out/nmap-bundle/nmap-data \
&& cp nmap /out/nmap-bundle/nmap-linux-amd64-static \
&& cp -r scripts nselib /out/nmap-bundle/nmap-data/ \
&& cp nse_main.lua nmap-services nmap-protocols nmap-service-probes nmap-mac-prefixes nmap-os-db nmap-payloads nmap-rpc /out/nmap-bundle/nmap-data/ 2>/dev/null || true \
&& tar -C /out -czf /out/nmap-linux-amd64-static-bundle.tar.gz nmap-bundle \
&& echo "===== OUTPUT ====="; ls -lah /out; echo "===== FILE TYPE ====="; file /out/nmap-bundle/nmap-linux-amd64-static || true
'
```
</details>

## Referencias

- [Compilar un binario estático de Nmap para trabajos en entornos restringidos](https://www.pentestpartners.com/security-blog/compiling-static-nmap-binary-for-jobs-in-restricted-environments/)
- [Static Nmap Binary Generator (herramienta auxiliar)](https://github.com/0x5ubt13/static_nmap_binary_generator)
- [Fuentes de OpenSSL](https://www.openssl.org/source/)
- [Lanzamientos de PCRE2](https://github.com/PCRE2Project/pcre2/releases)
- [Tarballs de código fuente de Nmap](https://nmap.org/dist/)


{{#include ../../banners/hacktricks-training.md}}
