# Nmap Podsumowanie (ESP)

{{#include ../../banners/hacktricks-training.md}}
```
nmap -sV -sC -O -n -oA nmapscan 192.168.0.1/24
```
## Parametry

### Adresy IP do skanowania

- **`<ip>,<net/mask>`:** Wskazuje adresy IP bezpośrednio
- **`-iL <ips_file>`:** list_IPs
- **`-iR <number>`**: Liczba losowych IP, możesz wykluczyć możliwe IP za pomocą `--exclude <Ips>` lub `--excludefile <file>`.

### Wykrywanie urządzeń

Domyślnie Nmap uruchamia fazę wykrywania składającą się z: `-PA80 -PS443 -PE -PP`

- **`-sL`**: Nieinwazyjny, listuje cele wykonując zapytania **DNS** w celu rozwiązania nazw. Przydatny, żeby wiedzieć np. czy www.prueba.es/24 wszystkie IP są naszymi celami.
- **`-Pn`**: **Brak pingowania**. Przydatne, jeśli wiesz, że wszystkie są aktywne (jeśli nie, możesz stracić dużo czasu, ale ta opcja też może dawać fałszywe negatywy twierdząc, że nie są aktywne), zapobiega fazie wykrywania.
- **`-sn`** : **Brak skanowania portów**. Po zakończeniu fazy rozpoznania nie skanuje portów. Stosunkowo skryte i pozwala na małe skanowanie sieci. Z uprawnieniami wysyła ACK (-PA) na 80, SYN(-PS) na 443 oraz echo request i timestamp request, bez uprawnień zawsze kończy połączenia. Jeśli celem jest sieć, używa tylko ARP(-PR). Jeśli użyte z inną opcją, tylko pakiety tej innej opcji są wysyłane.
- **`-PR`**: **Ping ARP**. Używane domyślnie przy analizie komputerów w naszej sieci, szybsze niż używanie pingów. Jeśli nie chcesz używać pakietów ARP użyj `--send-ip`.
- **`-PS <ports>`**: Wysyła pakiety SYN; jeśli odpowiedzią jest SYN/ACK to jest open (odpowiada się RST, aby nie zakończyć połączenia), jeśli odpowiedzią jest RST to jest closed, a jeśli brak odpowiedzi to unreachable. Jeśli brak uprawnień, automatycznie używana jest pełna konekcja. Jeśli nie podano portów, wysyła na 80.
- **`-PA <ports>`**: Jak poprzedni, ale z ACK; łączenie obu daje lepsze wyniki.
- **`-PU <ports>`**: Cel jest odwrotny, wysyłane są pakiety do portów, które powinny być zamknięte. Niektóre firewalle sprawdzają tylko połączenia TCP. Jeśli jest closed, odpowiada port unreachable, jeśli odpowiedzią jest inny ICMP lub brak odpowiedzi traktowane jako destination unreachable.
- **`-PE, -PP, -PM`** : ICMP PINGS: echo reply, timestamp i addresmask. Uruchamiane, aby sprawdzić czy cel jest aktywny.
- **`-PY<ports>`**: Wysyła SCTP INIT probe na 80 domyślnie; odpowiedź INIT-ACK (open) lub ABORT (closed) albo brak odpowiedzi lub ICMP unreachable (inactive).
- **`-PO <protocols>`**: W nagłówkach wskazywany jest protokół, domyślnie 1(ICMP), 2(IGMP) i 4(Encap IP). Dla ICMP, IGMP, TCP (6) i UDP (17) wysyłane są nagłówki protokołów, dla pozostałych tylko nagłówek IP. Cel jest taki, że z powodu sfałszowania nagłówków można otrzymać Protocol unreachable lub odpowiedzi tym samym protokołem, by dowiedzieć się, czy jest up.
- **`-n`**: Brak DNS
- **`-R`**: Zawsze DNS

### Techniki skanowania portów

- **`-sS`**: Nie kończy połączenia, więc zostawia mniej śladów, bardzo dobre jeśli można użyć (wymaga uprawnień). Używane domyślnie.
- **`-sT`**: Kończy połączenie, więc zostawia ślad, ale działa bez problemu. Domyślnie bez uprawnień.
- **`-sU`**: Wolniejsze, dla UDP. Głównie: DNS(53), SNMP(161,162), DHCP(67 i 68), (-sU53,161,162,67,68): open(reply), closed(port unreachable), filtered (inny ICMP), open/filtered (brak). W przypadku open/filtered, -sV wysyła liczne zapytania dla wykrycia wersji, co może wykryć prawdziwy stan. Zwiększa znacznie czas.
- **`-sY`**: SCTP — nie kończy połączenia, więc brak logów, działa jak -PY
- **`-sN,-sX,-sF`:** Null, Fin, Xmas, potrafią przeniknąć przez niektóre firewalle i wydobyć informacje. Bazują na tym, że zgodne maszyny powinny odpowiadać RST na wszystkie żądania bez ustawionych SYN, RST lub ACK: open/filtered(nic), closed(RST), filtered (ICMP unreachable). Niezawodne na Windows, Cisco, BSDI i OS/400 — tam zawodne. Na unix tak.
- **`-sM`**: Maimon scan: Wysyła FIN i ACK, używane dla BSD, obecnie zwróci wszystkie jako closed.
- **`-sA, sW`**: ACK i Window, służy do wykrywania firewalli, by poznać czy porty są filtrowane. -sW rozróżnia open/closed ponieważ otwarte odpowiadają różną wartością window: open (RST z window ≠ 0), closed (RST window = 0), filtered (ICMP unreachable lub brak). Nie wszystkie hosty tak działają, więc jeśli wszystko jest closed, to nie działa; jeśli kilka open, działa dobrze; jeśli wiele open i kilka closed, działa odwrotnie.
- **`-sI`:** Idle scan. Gdy istnieje aktywny firewall, ale wiemy, że nie filtruje do pewnego IP (lub gdy chcemy anonimowości) możemy użyć zombie scanner (działa dla wszystkich portów). Aby znaleźć możliwe zombie można użyć skryptu ipidseq lub exploit auxiliary/scanner/ip/ipidseq. Skaner opiera się na numerze IPID pakietów IP.
- **`--badsum`:** Wysyła błędną sumę kontrolną, komputery odrzuciłyby pakiety, ale firewalle mogą odpowiadać — używane do wykrywania firewalli.
- **`-sZ`:** "Weird" SCTP scanner, przy wysyłaniu probe z cookie echo fragments powinny być odrzucone jeśli open lub odpowiedziane ABORT jeśli closed. Może przejść przez firewalle, których INIT nie przechodzi; wadą jest, że nie rozróżnia filtered i open.
- **`-sO`:** Skan protokołów IP. Wysyła złe i puste nagłówki, w których czasem nawet protokołu nie da się rozpoznać. Jeśli przychodzi ICMP unreachable protocol to closed, jeśli przychodzi unreachable port to open, jeśli inny błąd to filtered, jeśli brak odpowiedzi to open|filtered.
- **`-b <server>`:** FTPhost --> Używane do skanowania hosta z innego hosta, polega na połączeniu się z FTP innej maszyny i poproszeniu jej o wysłanie plików do portów, które chcemy zeskanować z tej innej maszyny; w zależności od odpowiedzi wiemy, czy są otwarte. [\<user>:\<password>@]\<server>\[:\<port>] Prawie wszystkie serwery FTP już nie pozwalają na to, więc ma małe praktyczne zastosowanie.

### Analiza skupienia (Focus Analysis)

**-p:** Używane do określenia portów do skanowania. Aby wybrać wszystkie 65,335 porty: **-p-** lub **-p all**. Nmap ma wewnętrzną klasyfikację opartą na popularności. Domyślnie używa top 1000 portów. Z **-F** (fast scan) analizuje top 100. Z **--top-ports <number>** analizuje tę liczbę top portów (od 1 do 65,335). Sprawdza porty w losowej kolejności; aby temu zapobiec użyj **-r**. Możemy także wybrać konkretne porty: 20-30,80,443,1024- (to ostatnie oznacza od 1024 w górę). Możemy grupować porty według protokołów: U:53,T:21-25,80,139,S:9. Możemy też wybrać zakres w obrębie popularnych portów Nmap: -p [-1024] analizuje do portu 1024 z tych zawartych w nmap-services. **--port-ratio <ratio>** Analizuje najczęściej występujące porty w proporcji między 0 a 1

**-sV** Skanowanie wersji, intensywność można regulować od 0 do 9, domyślnie 7.

**--version-intensity <number>** Regulujemy intensywność, im niższa tym wysyła tylko najbardziej prawdopodobne probe, ale nie wszystkie. Dzięki temu można znacznie skrócić czas skanowania UDP.

**-O** Wykrywanie OS

**--osscan-limit** Do poprawnego skanowania hosta potrzebny jest co najmniej jeden open i jeden closed port. Jeśli ten warunek nie jest spełniony i ustawiliśmy tę opcję, nie będzie próbował przewidywać OS (oszczędza czas)

**--osscan-guess** Gdy wykrywanie OS nie jest perfekcyjne, powoduje, że próbuje mocniej

**Skrypty**

--script _<filename>_|_<category>_|_<directory>_|_<expression>_[,...]

Aby użyć domyślnych skryptów, użyj -sC lub --script=default

Dostępne typy: auth, broadcast, default, discovery, dos, exploit, external, fuzzer, intrusive, malware, safe, version, oraz vuln

- **Auth:** wykonuje wszystkie dostępne skrypty uwierzytelniające
- **Default:** wykonuje podstawowe domyślne skrypty narzędzia
- **Discovery:** pobiera informacje z celu lub ofiary
- **External:** skrypt korzystający z zasobów zewnętrznych
- **Intrusive:** używa skryptów uznanych za inwazyjne względem celu
- **Malware:** sprawdza połączenia otwarte przez złośliwy kod lub backdoory
- **Safe:** wykonuje nieinwazyjne skrypty
- **Vuln:** odkrywa najbardziej znane podatności
- **All:** wykonuje absolutnie wszystkie dostępne skrypty NSE

Aby wyszukać skrypty:

**nmap --script-help="http-\*" -> Te zaczynające się od http-**

**nmap --script-help="not intrusive" -> Wszystkie poza inwazyjnymi**

**nmap --script-help="default or safe" -> Te które są w jednym lub obu**

**nmap --script-help="default and safe" --> Te które są w obu**

**nmap --script-help="(default or safe or intrusive) and not http-\*"**

--script-args _<n1>_=_<v1>_,_<n2>_={_<n3>_=_<v3>_},_<n4>_={_<v4>_,_<v5>_}

--script-args-file _<filename>_

--script-help _<filename>_|_<category>_|_<directory>_|_<expression>_|all[,...]

--script-trace ---> Dostarcza informacji, jak skrypt postępuje

--script-updatedb

**Aby użyć skryptu, po prostu wpisz: nmap --script Script_Name target** --> Przy użyciu skryptu zarówno skrypt, jak i skaner zostaną uruchomione, więc można też dodać opcje skanera. Możemy dodać **"safe=1"** aby wykonać tylko bezpieczne.

**Kontrola czasu**

**Nmap może modyfikować czas w sekundach, minutach, ms:** --host-timeout argumenty 900000ms, 900, 900s, i 15m robią to samo.

Nmap dzieli łączną liczbę hostów do przeskanowania na grupy i analizuje te grupy w blokach, więc nie przechodzi do następnego bloku, dopóki wszystkie nie zostaną przeanalizowane (i użytkownik nie otrzymuje żadnych aktualizacji dopóki blok nie zostanie przeanalizowany). Dzięki temu Nmap optymalnie używa dużych grup. Domyślnie w klasie C używa 256.

Można to zmienić przy pomocy **--min-hostgroup** _**<numhosts>**_**;** **--max-hostgroup** _**<numhosts>**_ (Dopasowuje rozmiary równoległych grup skanowania)

Możesz kontrolować liczbę równoległych skanerów, ale lepiej tego nie robić (Nmap ma automatyczne sterowanie oparte na stanie sieci): **--min-parallelism** _**<numprobes>**_**;** **--max-parallelism** _**<numprobes>**_

Możemy zmodyfikować timeout RTT, ale zwykle nie jest to konieczne: **--min-rtt-timeout** _**<time>**_**,** **--max-rtt-timeout** _**<time>**_**,** **--initial-rtt-timeout** _**<time>**_

Możemy zmienić liczbę prób: **--max-retries** _**<numtries>**_

Możemy zmienić czas skanowania hosta: **--host-timeout** _**<time>**_

Możemy zmienić czas między każdym testem, aby spowolnić: **--scan-delay** _**<time>**_**;** **--max-scan-delay** _**<time>**_

Możemy zmienić liczbę pakietów na sekundę: **--min-rate** _**<number>**_**;** **--max-rate** _**<number>**_

Wiele portów długo odpowiada, gdy są filtrowane lub zamknięte. Jeśli interesują nas tylko otwarte, możemy przyspieszyć z: **--defeat-rst-ratelimit**

Aby zdefiniować jak agresywny ma być Nmap: -T paranoid|sneaky|polite|normal|aggressive|insane

-T (0-1)

-T0 --> Skanuje tylko 1 port naraz i czeka 5min przed następnym

-T1 i T2 --> Bardzo podobne, ale czekają odpowiednio 15s i 0.4s między testami

-T3 --> Domyślne działanie, zawiera skanowanie równoległe

-T4 --> --max-rtt-timeout 1250ms --min-rtt-timeout 100ms --initial-rtt-timeout 500ms --max-retries 6 --max-scan-delay 10ms

-T5 --> --max-rtt-timeout 300ms --min-rtt-timeout 50ms --initial-rtt-timeout 250ms --max-retries 2 --host-timeout 15m --max-scan-delay 5ms

**Firewall/IDS**

Blokują dostęp do portów i analizują pakiety.

**-f** Fragmentuje pakiety, domyślnie dzieli je na 8 bytes po nagłówku; aby określić rozmiar używamy ..mtu (z tym nie używaj -f), offset musi być wielokrotnością 8. **Version scanners i skrypty nie wspierają fragmentacji**

**-D decoy1,decoy2,ME** Nmap wysyła skany z innymi adresami IP jako źródło, w ten sposób się ukrywasz. Jeśli umieścisz ME na liście, Nmap umieści twój adres tam; lepiej dać 5 lub 6 przed sobą, aby całkowicie się zamaskować. Losowe IP można generować z RND:<number> aby stworzyć <number> losowych IP. Nie działają z detektorami wersji TCP bez połączenia. Jeśli jesteś w sieci lokalnej, interesuje Cię użycie aktywnych IP, bo inaczej łatwo będzie stwierdzić, że jesteś jedynym aktywnym.

Aby użyć losowych IP: nmap -D RND:10 Target_IP

**-S IP** Gdy Nmap nie wychwytuje twojego IP, musisz go podać. Służy też do tego, by myśleli, że inny host ich skanuje.

**-e <interface>** Aby wybrać interfejs

Wielu administratorów zostawia porty wejściowe otwarte, żeby wszystko działało poprawnie i to dla nich łatwiejsze niż znalezienie innego rozwiązania. Mogą to być porty DNS lub FTP... aby znaleźć tę podatność Nmap ma: **--source-port** _**<portnumber>**_**;-g** _**<portnumber>**_ _Są równoważne_

**--data** _**<hex string>**_ Aby wysłać tekst szesnastkowy: --data 0xdeadbeef i --data \xCA\xFE\x09

**--data-string** _**<string>**_ Aby wysłać zwykły tekst: --data-string "Scan conducted by Security Ops, extension 7192"

**--data-length** _**<number>**_ Nmap wysyła tylko nagłówki; dzięki temu dodamy określoną liczbę dodatkowych bajtów (wygenerowanych losowo)

Aby skonfigurować pakiet IP w całości użyj **--ip-options**

Jeśli chcesz zobaczyć opcje w wysyłanych i odbieranych pakietach, określ --packet-trace. Po więcej informacji i przykładów użycia opcji IP z Nmap zobacz [http://seclists.org/nmap-dev/2006/q3/52](http://seclists.org/nmap-dev/2006/q3/52).

**--ttl** _**<value>**_

**--randomize-hosts** Aby uczynić atak mniej oczywistym

**--spoof-mac** _**<MAC address, prefix, or vendor name>**_ Aby zmienić MAC, przykłady: Apple, 0, 01:02:03:04:05:06, deadbeefcafe, 0020F2, oraz Cisco

**--proxies** _**<Comma-separated list of proxy URLs>**_ Aby użyć proxy; czasami proxy nie utrzymuje tylu otwartych połączeń ile Nmap chce, więc trzeba zmienić równoległość: --max-parallelism

**-sP** Do odkrywania hostów w naszej sieci przez ARP

Wielu administratorów tworzy regułę firewalla, która pozwala przechodzić wszystkim pakietom pochodzącym z określonego portu (jak 20,53 i 67); możemy powiedzieć Nmap, żeby wysyłał nasze pakiety z tych portów: **nmap --source-port 53 IP**

**Wyjścia**

**-oN file** Normalne wyjście

**-oX file** Wyjście XML

**-oS file** Script kiddies output

**-oG file** Greppable output

**-oA file** Wszystko poza -oS

**-v level** poziom szczegółowości (verbosity)

**-d level** debugowanie

**--reason** Powód hosta i stanu

**--stats-every time** Co ten czas podaje status

**--packet-trace** Aby zobaczyć jakie pakiety wychodzą; można określić filtry jak: --version-trace lub --script-trace

**--open** pokazuje open, open|filtered i unfiltered

**--resume file** Wznawia/wyświetla podsumowanie

**Różne**

**-6** Pozwala IPv6

**-A** to to samo co -O -sV -sC --traceroute

**Czas działania**

Podczas działania Nmap można zmieniać opcje w locie:

v / V Zwiększ / zmniejsz poziom verbosity

d / D Zwiększ / zmniejsz poziom debugowania

p / P Włącz / wyłącz śledzenie pakietów

? Wyświetl ekran pomocy interakcji w czasie działania

**Vulscan**

Skrypt Nmap, który patrzy na wersje usług uzyskane w offline'owej bazie danych (pobranej z innych ważnych źródeł) i zwraca możliwe podatności

Bazy, których używa:

1. Scipvuldb.csv | [http://www.scip.ch/en/?vuldb](http://www.scip.ch/en/?vuldb)
2. Cve.csv | [http://cve.mitre.org](http://cve.mitre.org/)
3. Osvdb.csv | [http://www.osvdb.org](http://www.osvdb.org/)
4. Securityfocus.csv | [http://www.securityfocus.com/bid/](http://www.securityfocus.com/bid/)
5. Securitytracker.csv | [http://www.securitytracker.com](http://www.securitytracker.com/)
6. Xforce.csv | [http://xforce.iss.net](http://xforce.iss.net/)
7. Exploitdb.csv | [http://www.exploit-db.com](http://www.exploit-db.com/)
8. Openvas.csv | [http://www.openvas.org](http://www.openvas.org/)

Aby pobrać i zainstalować w folderze Nmap:

wget http://www.computec.ch/projekte/vulscan/download/nmap_nse_vulscan-2.0.tar.gz && tar -czvf nmap_nse_vulscan-2.0.tar.gz vulscan/ && sudo cp -r vulscan/ /usr/share/nmap/scripts/

Potrzebne będzie również pobranie pakietów DB i dodanie ich do /usr/share/nmap/scripts/vulscan/

Użycie:

Aby użyć wszystkich: sudo nmap -sV --script=vulscan HOST_TO_SCAN

Aby użyć konkretnej bazy: sudo nmap -sV --script=vulscan --script-args vulscandb=cve.csv HOST_TO_SCAN

## Przyspieszenie skanowania usług Nmap x16

According [**to this post**](https://joshua.hu/nmap-speedup-service-scanning-16x) możesz przyspieszyć analizę usług nmap modyfikując wszystkie wartości **`totalwaitms`** w **`/usr/share/nmap/nmap-service-probes`** na **300** oraz **`tcpwrappedms`** na **200**.

Ponadto, probe które nie mają określonego **`servicewaitms`** używają domyślnej wartości **`5000`**. Dlatego możemy albo dodać wartości do każdego z probe, albo **skompilować nmap** samodzielnie i zmienić wartość domyślną w [**service_scan.h**](https://github.com/nmap/nmap/blob/master/service_scan.h#L79).

Jeśli nie chcesz zmieniać wartości **`totalwaitms`** i **`tcpwrappedms`** w pliku `/usr/share/nmap/nmap-service-probes`, możesz edytować [parsing code](https://github.com/nmap/nmap/blob/master/service_scan.cc#L1358) tak, aby te wartości w pliku `nmap-service-probes` były całkowicie ignorowane.


## Zbudowanie statycznego Nmap dla ograniczonych środowisk

W utwardzonych lub minimalnych środowiskach Linux (kontenery, appliance), dynamicznie linkowane binaria Nmap często zawodzą z powodu brakujących loaderów czasu wykonywania lub bibliotek współdzielonych (np. /lib64/ld-linux-x86-64.so.2, libc.so). Zbudowanie własnego statycznie linkowanego Nmap i dołączenie danych NSE pozwala na uruchomienie bez instalowania pakietów systemowych.

Podejście wysokiego poziomu
- Użyj czystego amd64 Ubuntu buildera przez Docker.
- Zbuduj OpenSSL i PCRE2 jako statyczne biblioteki.
- Zbuduj Nmap linkując statycznie i używając wbudowanego libpcap/libdnet, aby uniknąć zależności dynamicznych.
- Dołącz katalogi skryptów NSE i danych wraz z binarnym plikiem.

Wykryj architekturę celu (przykład)
```bash
uname -a
# If building from macOS/ARM/etc., pin the builder arch:
docker run --rm --platform=linux/amd64 -v "$(pwd)":/out -w /tmp ubuntu:22.04 bash -lc 'echo ok'
```
Krok 1 — Przygotuj toolchain
```bash
set -euo pipefail
export DEBIAN_FRONTEND=noninteractive
apt-get update && apt-get install -y --no-install-recommends \
build-essential ca-certificates curl bzip2 xz-utils pkg-config perl python3 file git \
automake autoconf libtool m4 zlib1g-dev
```
Krok 2 — Zbuduj statyczny OpenSSL (1.1.1w)
```bash
OSSL="1.1.1w"
curl -fsSLO "https://www.openssl.org/source/openssl-$OSSL.tar.gz"
tar xzf "openssl-$OSSL.tar.gz" && cd "openssl-$OSSL"
./Configure no-shared no-zlib linux-x86_64 -static --prefix=/opt/ossl
make -j"$(nproc)" && make install_sw
cd /tmp
```
Krok 3 — Zbuduj statyczną wersję PCRE2 (10.43)
```bash
PCRE2=10.43
curl -fsSLO "https://github.com/PCRE2Project/pcre2/releases/download/pcre2-$PCRE2/pcre2-$PCRE2.tar.bz2"
tar xjf "pcre2-$PCRE2.tar.bz2" && cd "pcre2-$PCRE2"
./configure --disable-shared --enable-static --prefix=/opt/pcre2
make -j"$(nproc)" && make install
cd /tmp
```
Krok 4 — Zbuduj statyczny Nmap (7.98)
```bash
NMAP=7.98
curl -fsSLO "https://nmap.org/dist/nmap-$NMAP.tar.bz2"
tar xjf "nmap-$NMAP.tar.bz2" && cd "nmap-$NMAP"
export CPPFLAGS="-I/opt/ossl/include -I/opt/pcre2/include"
export LDFLAGS="-L/opt/ossl/lib -L/opt/pcre2/lib -static -static-libstdc++ -static-libgcc"
export LIBS="-lpcre2-8 -ldl -lpthread -lz"
./configure \
--with-openssl=/opt/ossl \
--with-libpcre=/opt/pcre2 \
--with-libpcap=included \
--with-libdnet=included \
--without-zenmap --without-ndiff --without-nmap-update
# Avoid building shared libpcap by accident
sed -i -e "s/^shared: /shared: #/" libpcap/Makefile || true
make -j1 V=1 nmap
strip nmap
```
Kluczowe punkty
- -static, -static-libstdc++, -static-libgcc wymuszają statyczne linkowanie.
- Użycie --with-libpcap=included/--with-libdnet=included zapobiega użyciu systemowych bibliotek współdzielonych.
- Modyfikacja za pomocą sed unieszkodliwia docelową współdzieloną bibliotekę libpcap, jeśli występuje.

Krok 5 — Spakuj binarkę i dane NSE
```bash
mkdir -p /out/nmap-bundle/nmap-data
cp nmap /out/nmap-bundle/nmap-linux-amd64-static
cp -r scripts nselib /out/nmap-bundle/nmap-data/
cp nse_main.lua nmap-services nmap-protocols nmap-service-probes \
nmap-mac-prefixes nmap-os-db nmap-payloads nmap-rpc \
/out/nmap-bundle/nmap-data/ 2>/dev/null || true

tar -C /out -czf /out/nmap-linux-amd64-static-bundle.tar.gz nmap-bundle
```
Verification and ops notes
- Użyj file na artefakcie, aby potwierdzić, że jest statycznie linkowany.
- Zachowaj dane NSE razem z binarką, aby zapewnić zgodność skryptów na hostach bez zainstalowanego Nmap.
- Nawet przy statycznej binarce wykonanie może być zablokowane przez AppArmor/seccomp/SELinux; DNS/egress musi nadal działać.
- Deterministyczne kompilacje zmniejszają ryzyko łańcucha dostaw w porównaniu z pobieraniem nieprzejrzystych „statycznych” binarek.

One-liner (Dockerized)
<details>
<summary>Zbuduj, spakuj i wypisz informacje o artefakcie</summary>
```bash
docker run --rm --platform=linux/amd64 -v "$(pwd)":/out -w /tmp ubuntu:22.04 bash -lc '
set -euo pipefail
export DEBIAN_FRONTEND=noninteractive
apt-get update && apt-get install -y --no-install-recommends \
build-essential ca-certificates curl bzip2 xz-utils pkg-config perl python3 file git \
automake autoconf libtool m4 zlib1g-dev

OSSL="1.1.1w"; curl -fsSLO "https://www.openssl.org/source/openssl-$OSSL.tar.gz" \
&& tar xzf "openssl-$OSSL.tar.gz" && cd "openssl-$OSSL" \
&& ./Configure no-shared no-zlib linux-x86_64 -static --prefix=/opt/ossl \
&& make -j"$(nproc)" && make install_sw && cd /tmp

PCRE2=10.43; curl -fsSLO "https://github.com/PCRE2Project/pcre2/releases/download/pcre2-$PCRE2/pcre2-$PCRE2.tar.bz2" \
&& tar xjf "pcre2-$PCRE2.tar.bz2" && cd "pcre2-$PCRE2" \
&& ./configure --disable-shared --enable-static --prefix=/opt/pcre2 \
&& make -j"$(nproc)" && make install && cd /tmp

NMAP=7.98; curl -fsSLO "https://nmap.org/dist/nmap-$NMAP.tar.bz2" \
&& tar xjf "nmap-$NMAP.tar.bz2" && cd "nmap-$NMAP" \
&& export CPPFLAGS="-I/opt/ossl/include -I/opt/pcre2/include" \
&& export LDFLAGS="-L/opt/ossl/lib -L/opt/pcre2/lib -static -static-libstdc++ -static-libgcc" \
&& export LIBS="-lpcre2-8 -ldl -lpthread -lz" \
&& ./configure --with-openssl=/opt/ossl --with-libpcre=/opt/pcre2 --with-libpcap=included --with-libdnet=included --without-zenmap --without-ndiff --without-nmap-update \
&& sed -i -e "s/^shared: /shared: #/" libpcap/Makefile || true \
&& make -j1 V=1 nmap && strip nmap

mkdir -p /out/nmap-bundle/nmap-data \
&& cp nmap /out/nmap-bundle/nmap-linux-amd64-static \
&& cp -r scripts nselib /out/nmap-bundle/nmap-data/ \
&& cp nse_main.lua nmap-services nmap-protocols nmap-service-probes nmap-mac-prefixes nmap-os-db nmap-payloads nmap-rpc /out/nmap-bundle/nmap-data/ 2>/dev/null || true \
&& tar -C /out -czf /out/nmap-linux-amd64-static-bundle.tar.gz nmap-bundle \
&& echo "===== OUTPUT ====="; ls -lah /out; echo "===== FILE TYPE ====="; file /out/nmap-bundle/nmap-linux-amd64-static || true
'
```
</details>

## Źródła

- [Kompilowanie statycznego binarnego Nmap dla zadań w środowiskach o ograniczonym dostępie](https://www.pentestpartners.com/security-blog/compiling-static-nmap-binary-for-jobs-in-restricted-environments/)
- [Static Nmap Binary Generator (narzędzie pomocnicze)](https://github.com/0x5ubt13/static_nmap_binary_generator)
- [Źródła OpenSSL](https://www.openssl.org/source/)
- [Wydania PCRE2](https://github.com/PCRE2Project/pcre2/releases)
- [Archiwa źródłowe Nmap](https://nmap.org/dist/)


{{#include ../../banners/hacktricks-training.md}}
