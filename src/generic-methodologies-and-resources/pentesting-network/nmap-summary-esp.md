# Nmap सारांश (ESP)

{{#include ../../banners/hacktricks-training.md}}
```
nmap -sV -sC -O -n -oA nmapscan 192.168.0.1/24
```
## पैरामीटर

### स्कैन करने के लिए IPs

- **`<ip>,<net/mask>`:** सीधे ips बताएँ
- **`-iL <ips_file>`:** list_IPs
- **`-iR <number>`**: रैंडम Ips की संख्या, आप संभावित Ips को `--exclude <Ips>` या `--excludefile <file>` से बाहर कर सकते हैं।

### उपकरण खोज

डिफ़ॉल्ट रूप से Nmap एक खोज चरण चलाता है, जो निम्नलिखित से मिलकर बनता है: `-PA80 -PS443 -PE -PP`

- **`-sL`**: यह invasive नहीं है, यह नाम resolve करने के लिए **DNS** अनुरोध कर के लक्ष्यों को सूचीबद्ध करता है। यह उपयोगी है यह जानने के लिए कि उदाहरण के लिए www.prueba.es/24 के सभी Ips हमारे लक्ष्य हैं या नहीं।
- **`-Pn`**: **No ping**. यह उपयोगी है जब आप जानते हैं कि सभी सक्रिय हैं (यदि नहीं, तो आप बहुत समय खो सकते हैं, पर यह विकल्प false negatives भी दे सकता है जो कहता है कि वे सक्रिय नहीं हैं), यह discovery चरण को रोकता है।
- **`-sn`** : **No port scan**. reconnaissance चरण पूरा करने के बाद, यह ports स्कैन नहीं करता। यह अपेक्षाकृत stealthy है, और छोटे नेटवर्क स्कैन की अनुमति देता है। privileges के साथ यह 80 पर ACK (-PA), 443 पर SYN(-PS) और echo request तथा Timestamp request भेजता है, बिना privileges के यह हमेशा कनेक्शंस पूरा करता है। यदि target नेटवर्क है, तो यह केवल ARP(-PR) का उपयोग करता है। यदि इसे किसी अन्य विकल्प के साथ इस्तेमाल किया जाता है, तो केवल अन्य विकल्प के पैकेट ड्रॉप होते हैं।
- **`-PR`**: **Ping ARP**. यह हमारे नेटवर्क में कंप्यूटरों का विश्लेषण करते समय डिफ़ॉल्ट रूप से उपयोग किया जाता है, यह pings के उपयोग से तेज़ है। यदि आप ARP पैकेट उपयोग नहीं करना चाहते तो `--send-ip` का उपयोग करें।
- **`-PS <ports>`**: यह SYN पैकेट भेजता है; यदि यह SYN/ACK से जवाब देता है तो open है (जिसे कनेक्शन खत्म न करने के लिए RST से जवाब देता है), यदि यह RST से जवाब देता है तो closed है और यदि जवाब नहीं देता तो unreachable है। privileges न होने पर, पूरा कनेक्शन स्वतः उपयोग किया जाता है। यदि कोई पोर्ट नहीं दिया गया तो यह डिफ़ॉल्ट रूप से 80 पर भेजता है।
- **`-PA <ports>`**: पिछले जैसा ही पर ACK के साथ, दोनों को मिलाकर बेहतर नतीजे मिलते हैं।
- **`-PU <ports>`**: उद्देश्य इसका उल्टा है, इन्हें उन ports पर भेजा जाता है जिन्हें closed होने की उम्मीद है। कुछ firewalls केवल TCP कनेक्शनों की जांच करते हैं। यदि closed है तो port unreachable से उत्तर मिलता है, यदि अन्य icmp से या कोई उत्तर नहीं मिलता है तो destination unreachable माना जाता है।
- **`-PE, -PP, -PM`** : ICMP PINGS: echo reply, timestamp और addresmask। इन्हें target सक्रिय है या नहीं जानने के लिए भेजा जाता है।
- **`-PY<ports>`**: SCTP INIT probes भेजता है, डिफ़ॉल्ट 80 पर, INIT-ACK(open) या ABORT(closed) या कुछ नहीं या ICMP unreachable(inactive) का जवाब आ सकता है।
- **`-PO <protocols>`**: हेडर्स में एक protocol संकेतित किया जाता है, डिफ़ॉल्ट 1(ICMP), 2(IGMP) और 4(Encap IP)। ICMP, IGMP, TCP (6) और UDP (17) के लिए protocol headers भेजे जाते हैं, बाकी के लिए केवल IP header भेजा जाता है। मकसद यह है कि header की malformed स्थिति में Protocol unreachable या उसी प्रोटोकॉल के responses से पता चले कि यह up है।
- **`-n`**: No DNS
- **`-R`**: DNS हमेशा

### पोर्ट स्कैन तकनीकें

- **`-sS`**: कनेक्शन पूरा नहीं करता इसलिए किसी निशान को नहीं छोड़ता, यदि उपयोग किया जा सके तो बहुत अच्छा।(privileges) यह डिफ़ॉल्ट रूप से उपयोग किया जाता है।
- **`-sT`**: कनेक्शन पूरा करता है, इसलिए यह ट्रेस छोड़ता है, पर यह निश्चित रूप से उपयोग किया जा सकता है। डिफ़ॉल्ट रूप से बिना privileges के।
- **`-sU`**: धीमा, UDP के लिए। मुख्यतः: DNS(53), SNMP(161,162), DHCP(67 और 68), (-sU53,161,162,67,68): open(reply), closed(port unreachable), filtered (another ICMP), open/filtered (कुछ नहीं)। open/filtered के मामले में, -sV कई अनुरोध भेजता है ताकि nmap द्वारा समर्थित किसी भी version का पता लगाया जा सके और सच्ची स्थिति का पता लग सके। यह बहुत समय बढ़ा देता है।
- **`-sY`**: SCTP प्रोटोकॉल कनेक्शन स्थापित करने में विफल होता है, इसलिए कोई लॉग नहीं होते, -PY की तरह काम करता है
- **`-sN,-sX,-sF`:** Null, Fin, Xmas, ये कुछ firewalls में प्रवेश कर सकते हैं और जानकारी निकाल सकते हैं। ये इस आधार पर काम करते हैं कि standard compliant मशीनें उन अनुरोधों पर RST से जवाब देनी चाहिए जिनमें SYN, RST या ACK flags नहीं उठे होते: open/filtered(कुछ नहीं), closed(RST), filtered (ICMP unreachable)। Windows, CIsco, BSDI और OS/400 पर unreliable। Unix पर हाँ।
- **`-sM`**: Maimon scan: FIN और ACK flags भेजता है, BSD के लिए उपयोग होता है, वर्तमान में यह सभी को closed लौटाएगा।
- **`-sA, sW`**: ACK और Window, यह firewalls का पता लगाने के लिए उपयोग होता है, यह जानने के लिए कि ports filtered हैं या नहीं। -sW open/closed में अंतर करता है क्योंकि open ones अलग window value के साथ RST के साथ जवाब देते हैं: open (RST with window other than 0), closed (RST window = 0), filtered (ICMP unreachable या कुछ नहीं)। सभी कंप्यूटर्स इस तरीके से व्यवहार नहीं करते, इसलिए यदि सब closed दिखते हैं तो यह काम नहीं कर रहा है, अगर कुछ open हैं तो यह ठीक काम कर रहा है, और यदि कई open और कुछ closed हैं तो यह उल्टा व्यवहार कर रहा है।
- **`-sI`:** Idle scan. उन मामलों के लिए जहाँ कोई active firewall है पर हमें पता है कि वह किसी विशेष Ip तक filter नहीं करता (या जब हम बस anonymity चाहते हैं) हम zombie scanner का उपयोग कर सकते हैं (यह सभी ports के लिए काम करता है), संभावित zombies खोजने के लिए हम scrpit ipidseq या exploit auxiliary/scanner/ip/ipidseq का उपयोग कर सकते हैं। यह scanner IP packets के IPID नंबर पर आधारित है।
- **`--badsum`:** यह checksum गलत भेजता है, कंप्यूटर पैकेट्स को discard कर देंगे, पर firewalls कुछ उत्तर दे सकते हैं, इसे firewall का पता लगाने के लिए उपयोग किया जाता है।
- **`-sZ`:** "Weird" SCTP scanner, जब probes cookie echo fragments के साथ भेजे जाते हैं तो उन्हें open होने पर drop कर देना चाहिए या closed होने पर ABORT से जवाब देना चाहिए। यह उन firewalls को पार कर सकता है जिन्हें init पार नहीं कर पाता, खराब बात यह है कि यह filtered और open के बीच अंतर नहीं करता।
- **`-sO`:** Protocol Ip scan. खराब और खाली हेडर्स भेजता है जिनमें कभी-कभी protocol की पहचान भी नहीं हो पाती। यदि ICMP unreachable protocol आता है तो यह closed है, यदि unreachable port आता है तो open है, यदि कोई अन्य त्रुटि आती है तो filtered, यदि कुछ नहीं आता तो open|filtered।
- **`-b <server>`:** FTPhost--> यह एक host को दूसरे से स्कैन करने के लिए उपयोग किया जाता है, यह दूसरे मशीन के ftp से connect करके और उसे उन ports पर फाइलें भेजने के लिए कहकर किया जाता है जिन्हें आप दूसरे मशीन से स्कैन करना चाहते हैं, उत्तरों के अनुसार हम जानेंगे कि वे open हैं या नहीं। [\<user>:\<password>@]\<server>\[:\<port>] लगभग सभी ftp servers अब यह अनुमति नहीं देते और इसलिए इसका व्यावहारिक उपयोग कम है।

### **फोकस विश्लेषण**

**-p:** स्कैन करने के लिए ports निर्दिष्ट करने के लिए उपयोग होता है। सभी 65,335 पोर्ट्स चुनने के लिए: **-p-** या **-p all**। Nmap के पास लोकप्रियता पर आधारित आंतरिक वर्गीकरण है। डिफ़ॉल्ट रूप से, यह top 1000 ports का उपयोग करता है। **-F** (fast scan) के साथ यह top 100 का विश्लेषण करता है। **--top-ports <number>** के साथ वह उस संख्या के top ports (1 से 65,335 तक) का विश्लेषण करता है। यह पोर्ट्स को रैंडम क्रम में चेक करता है; इसे रोकने के लिए **-r** का उपयोग करें। हम विशिष्ट पोर्ट्स भी चुन सकते हैं: 20-30,80,443,1024- (अर्थात् 1024 से आगे देखें)। हम प्रोटोकॉल्स द्वारा पोर्ट्स को भी समूहित कर सकते हैं: U:53,T:21-25,80,139,S:9। हम Nmap के लोकप्रिय ports में एक सीमा भी चुन सकते हैं: -p [-1024] nmap-services में शामिल पोर्ट्स में से 1024 तक का विश्लेषण करता है। **--port-ratio <ratio>** 0 और 1 के बीच के ratio के भीतर सबसे सामान्य ports का विश्लेषण करता है

**-sV** Version scanning, intensity 0 से 9 तक नियंत्रित की जा सकती है, डिफ़ॉल्ट 7 है।

**--version-intensity <number>** हम intensity नियंत्रित करते हैं, जितना कम होगा, वह केवल सबसे संभाव्य probes ही चलाएगा, पर सभी नहीं। इससे हम UDP scanning समय को काफी कम कर सकते हैं

**-O** OS detection

**--osscan-limit** उचित host scanning के लिए कम से कम एक open port और एक closed port आवश्यक होते हैं। यदि यह शर्त पूरी नहीं होती और हमने यह सेट किया है, तो यह OS prediction का प्रयास नहीं करेगा (समय बचता है)

**--osscan-guess** जब OS detection परफेक्ट नहीं होता, यह अधिक प्रयास करने देता है

**Scripts**

--script _<filename>_|_<category>_|_<directory>_|_<expression>_[,...]

Default scripts का उपयोग करने के लिए -sC या --script=default का उपयोग करें

Available types are: auth, broadcast, default, discovery, dos, exploit, external, fuzzer, intrusive, malware, safe, version, and vuln

- **Auth:** executes all available authentication scripts
- **Default:** executes basic default tool scripts
- **Discovery:** retrieves information from the target or victim
- **External:** script for using external resources
- **Intrusive:** uses scripts considered intrusive to the victim or target
- **Malware:** checks for connections opened by malicious code or backdoors
- **Safe:** executes non-intrusive scripts
- **Vuln:** discovers the most known vulnerabilities
- **All:** executes absolutely all available NSE extension scripts

To search for scripts:

**nmap --script-help="http-\*" -> Those starting with http-**

**nmap --script-help="not intrusive" -> All except those**

**nmap --script-help="default or safe" -> Those in either or both**

**nmap --script-help="default and safe" --> Those in both**

**nmap --script-help="(default or safe or intrusive) and not http-\*"**

--script-args _<n1>_=_<v1>_,_<n2>_={_<n3>_=_<v3>_},_<n4>_={_<v4>_,_<v5>_}

--script-args-file _<filename>_

--script-help _<filename>_|_<category>_|_<directory>_|_<expression>_|all[,...]

--script-trace ---> स्क्रिप्ट के प्रगति पर जानकारी प्रदान करता है

--script-updatedb

**To use a script, just type: nmap --script Script_Name target** --> स्क्रिप्ट का उपयोग करते समय, स्क्रिप्ट और scanner दोनों चलेंगे, इसलिए scanner विकल्प भी जोड़े जा सकते हैं। हम केवल safe ones को चलाने के लिए **"safe=1"** जोड़ सकते हैं।

**Time Control**

**Nmap सेकंड, मिनट, ms में समय बदल सकता है:** --host-timeout arguments 900000ms, 900, 900s, और 15m सभी एक ही काम करते हैं।

Nmap स्कैन करने वाले hosts की कुल संख्या को समूहों में विभाजित करता है और इन समूहों का ब्लॉक्स में विश्लेषण करता है, इसलिए यह अगले ब्लॉक पर तब तक नहीं जाता जब तक सभी का विश्लेषण नहीं हो जाता (और उपयोगकर्ता को किसी भी अपडेट तक तब तक सूचना नहीं मिलती)। इस तरह, बड़े समूहों का उपयोग Nmap के लिए अधिक optimal है। डिफ़ॉल्ट रूप से class C में, यह 256 का उपयोग करता है।

इसे बदला जा सकता है **--min-hostgroup** _**<numhosts>**_**;** **--max-hostgroup** _**<numhosts>**_ (parallel scan group sizes समायोजित करें)

आप parallel scanners की संख्या नियंत्रित कर सकते हैं पर बेहतर है न करें (Nmap पहले से नेटवर्क स्थिति के आधार पर स्वचालित नियंत्रण शामिल करता है): **--min-parallelism** _**<numprobes>**_**;** **--max-parallelism** _**<numprobes>**_

हम RTT timeout संशोधित कर सकते हैं, पर आम तौर पर इसकी आवश्यकता नहीं होती: **--min-rtt-timeout** _**<time>**_**,** **--max-rtt-timeout** _**<time>**_**,** **--initial-rtt-timeout** _**<time>**_

हम प्रयासों की संख्या बदल सकते हैं: **--max-retries** _**<numtries>**_

हम किसी host के स्कैन करने का समय बदल सकते हैं: **--host-timeout** _**<time>**_

हम प्रत्येक परीक्षण के बीच का समय बदल सकते हैं ताकि इसे धीमा किया जा सके: **--scan-delay** _**<time>**_**;** **--max-scan-delay** _**<time>**_

हम प्रति सेकंड पैकेट्स की संख्या बदल सकते हैं: **--min-rate** _**<number>**_**;** **--max-rate** _**<number>**_

कई ports filtered या closed होने पर उत्तर देने में अधिक समय लेते हैं। यदि हम केवल open ones में रुचि रखते हैं, तो हम तेज़ी से जा सकते हैं: **--defeat-rst-ratelimit**

यह परिभाषित करने के लिए कि हम Nmap को कितना aggressive चाहते हैं: -T paranoid|sneaky|polite|normal|aggressive|insane

-T (0-1)

-T0 --> केवल एक समय में 1 पोर्ट स्कैन करता है और अगले परीक्षण तक 5min तक प्रतीक्षा करता है

-T1 और T2 --> बहुत समान पर केवल 15 और 0.4sec क्रमशः प्रतीक्षा करते हैं प्रत्येक परीक्षण के बीच

-T3 --> डिफ़ॉल्ट संचालन, parallel scanning शामिल है

-T4 --> --max-rtt-timeout 1250ms --min-rtt-timeout 100ms --initial-rtt-timeout 500ms --max-retries 6 --max-scan-delay 10ms

-T5 --> --max-rtt-timeout 300ms --min-rtt-timeout 50ms --initial-rtt-timeout 250ms --max-retries 2 --host-timeout 15m --max-scan-delay 5ms

**Firewall/IDS**

वे ports तक पहुँचने की अनुमति नहीं देते और पैकेट्स का विश्लेषण करते हैं।

**-f** पैकेट्स को fragment करने के लिए, डिफ़ॉल्ट रूप से header के बाद 8bytes में fragment करता है, उस size को निर्दिष्ट करने के लिए ..mtu का उपयोग करते हैं (इसके साथ, -f का उपयोग न करें), offset 8 का multiple होना चाहिए। **Version scanners और scripts fragmentation का समर्थन नहीं करते**

**-D decoy1,decoy2,ME** Nmap scanners भेजता है पर अन्य IP addresses को origin के रूप में दिखाता है, इस तरह वे आपको छुपाते हैं। यदि आप सूची में ME रखते हैं, तो Nmap आपको वहाँ रखेगा, बेहतर है कि आप अपने पहले 5 या 6 डालें ताकि आपको पूरी तरह mask किया जा सके। Random IPs RND:<number> के साथ जेनरेट किए जा सकते हैं। ये TCP version detectors के साथ बिना कनेक्शन काम नहीं करते। यदि आप अंदर नेटवर्क में हैं, तो आप सक्रिय IPs का उपयोग करना चाहेंगे, अन्यथा यह पता लगाना बहुत आसान होगा कि आप ही एकमात्र सक्रिय हैं।

Random IPs उपयोग करने के लिए: nmap -D RND:10 Target_IP

**-S IP** जब Nmap आपका IP पता नहीं कर पाता तब आपको इसे देना होगा। यह यह सोचने के लिए भी उपयोगी है कि कोई और target उन्हें स्कैन कर रहा है।

**-e <interface>** इंटरफेस चुनने के लिए

कई administrators entry ports को सब कुछ काम करने के लिए खोलकर छोड़ देते हैं क्योंकि उनके लिए यह दूसरों की तुलना में आसान होता है। ये DNS ports या FTP ports हो सकते हैं... इस vulnerability को खोजने के लिए Nmap में शामिल है: **--source-port** _**<portnumber>**_**;-g** _**<portnumber>**_ _ये समतुल्य हैं_

**--data** _**<hex string>**_ hexadecimal टेक्स्ट भेजने के लिए: --data 0xdeadbeef and --data \xCA\xFE\x09

**--data-string** _**<string>**_ सामान्य टेक्स्ट भेजने के लिए: --data-string "Scan conducted by Security Ops, extension 7192"

**--data-length** _**<number>**_ Nmap केवल headers भेजता है, इसके साथ हम कुछ और बाइट्स जोड़ते हैं (जो यादृच्छिक रूप से जनरेट होंगे)

IP packet को पूरी तरह से कॉन्फ़िगर करने के लिए **--ip-options** का उपयोग करें

यदि आप भेजे और प्राप्त पैकेट्स में विकल्प देखना चाहते हैं, तो --packet-trace निर्दिष्ट करें। IP options के साथ Nmap के उपयोग के और उदाहरणों के लिए देखें [http://seclists.org/nmap-dev/2006/q3/52](http://seclists.org/nmap-dev/2006/q3/52).

**--ttl** _**<value>**_

**--randomize-hosts** हमले को कम स्पष्ट बनाने के लिए

**--spoof-mac** _**<MAC address, prefix, or vendor name>**_ MAC बदलने के लिए उदाहरण: Apple, 0, 01:02:03:04:05:06, deadbeefcafe, 0020F2, and Cisco

**--proxies** _**<Comma-separated list of proxy URLs>**_ proxies का उपयोग करने के लिए, कभी-कभी proxy उतने open connections प्रदान नहीं करता जितने Nmap चाहता है इसलिए parallelism को समायोजित करना पड़ेगा: --max-parallelism

**-sP** ARP द्वारा हमारे नेटवर्क में hosts खोजने के लिए

कई administrators एक firewall नियम बनाते हैं जो किसी विशेष port से आने वाले सभी पैकेट्स को पास होने की अनुमति देता है (जैसे 20,53 और 67), हम Nmap को बता सकते हैं कि हमारे पैकेट्स इन ports से भेजें: **nmap --source-port 53 IP**

**Outputs**

**-oN file** Normal output

**-oX file** XML output

**-oS file** Script kiddies output

**-oG file** Greppable output

**-oA file** All except -oS

**-v level** verbosity

**-d level** debugging

**--reason** host और state का कारण

**--stats-every time** हर उस समय यह हमें बताता है कि कैसे चल रहा है

**--packet-trace** कौन से पैकेट्स बाहर जा रहे हैं देखने के लिए, filters निर्दिष्ट किए जा सकते हैं जैसे: --version-trace या --script-trace

**--open** open, open|filtered और unfiltered दिखाता है

**--resume file** सारांश आउटपुट करता है

**Miscellaneous**

**-6** IPv6 की अनुमति देता है

**-A** यह -O -sV -sC --traceroute के समान है

**Run time**

जब Nmap चल रहा होता है हम विकल्प बदल सकते हैं:

v / V verbosity स्तर बढ़ाएँ / घटाएँ

d / D debugging स्तर बढ़ाएँ / घटाएँ

p / P packet tracing चालू / बंद करें

? runtime interaction help स्क्रीन प्रिंट करें

**Vulscan**

Nmap स्क्रिप्ट जो services के versions को एक offline database (अन्य प्रमुख स्रोतों से डाउनलोड किया हुआ) में देखती है और संभाव्य vulnerabilities लौटाती है

यह DBs उपयोग करती है:

1. Scipvuldb.csv | [http://www.scip.ch/en/?vuldb](http://www.scip.ch/en/?vuldb)
2. Cve.csv | [http://cve.mitre.org](http://cve.mitre.org/)
3. Osvdb.csv | [http://www.osvdb.org](http://www.osvdb.org/)
4. Securityfocus.csv | [http://www.securityfocus.com/bid/](http://www.securityfocus.com/bid/)
5. Securitytracker.csv | [http://www.securitytracker.com](http://www.securitytracker.com/)
6. Xforce.csv | [http://xforce.iss.net](http://xforce.iss.net/)
7. Exploitdb.csv | [http://www.exploit-db.com](http://www.exploit-db.com/)
8. Openvas.csv | [http://www.openvas.org](http://www.openvas.org/)

डाउनलोड और Nmap फ़ोल्डर में इंस्टॉल करने के लिए:

wget http://www.computec.ch/projekte/vulscan/download/nmap_nse_vulscan-2.0.tar.gz && tar -czvf nmap_nse_vulscan-2.0.tar.gz vulscan/ && sudo cp -r vulscan/ /usr/share/nmap/scripts/

आपको DB packages भी डाउनलोड करके /usr/share/nmap/scripts/vulscan/ में जोड़ने होंगे

उपयोग:

सभी का उपयोग करने के लिए: sudo nmap -sV --script=vulscan HOST_TO_SCAN

विशिष्ट DB का उपयोग करने के लिए: sudo nmap -sV --script=vulscan --script-args vulscandb=cve.csv HOST_TO_SCAN

## Nmap Service scan x16 तेज़ करें

According [**to this post**](https://joshua.hu/nmap-speedup-service-scanning-16x) आप nmap service analysis को तेज़ कर सकते हैं सभी **`totalwaitms`** मानों को **`/usr/share/nmap/nmap-service-probes`** में **300** और **`tcpwrappedms`** को **200** में बदल कर।

इसके अलावा, जिन probes में खास तौर पर **`servicewaitms`** परिभाषित नहीं है वे एक डिफ़ॉल्ट मान **`5000`** का उपयोग करते हैं। इसलिए, हम या तो प्रत्येक probe में मान जोड़ सकते हैं, या हम **nmap को खुद compile** कर सकते हैं और डिफ़ॉल्ट मान को [**service_scan.h**](https://github.com/nmap/nmap/blob/master/service_scan.h#L79) में बदल सकते हैं।

यदि आप `/usr/share/nmap/nmap-service-probes` फ़ाइल में **`totalwaitms`** और **`tcpwrappedms`** के मान बिल्कुल भी नहीं बदलना चाहते, तो आप parsing code को संपादित कर सकते हैं ताकि इन मानों को `nmap-service-probes` फ़ाइल में पूरी तरह नजरअंदाज किया जा सके। (देखें [https://github.com/nmap/nmap/blob/master/service_scan.cc#L1358](https://github.com/nmap/nmap/blob/master/service_scan.cc#L1358))


## restricted environments के लिए static Nmap बनाना

Hardened या minimal Linux environments (containers, appliances) में dynamically linked Nmap binaries अक्सर runtime loaders या shared libraries के गायब होने के कारण fail करते हैं (उदा., /lib64/ld-linux-x86-64.so.2, libc.so)। अपना खुद का statically linked Nmap बनाकर और NSE data bundle करके आप बिना system packages install किए execution कर सकते हैं।

High-level approach
- Docker के माध्यम से एक clean amd64 Ubuntu builder का उपयोग करें।
- OpenSSL और PCRE2 को static libraries के रूप में build करें।
- Nmap को statically link करके और included libpcap/libdnet का उपयोग करके build करें ताकि dynamic deps से बचा जा सके।
- binary के साथ NSE scripts और data directories bundle करें।

Discover target architecture (example)
```bash
uname -a
# If building from macOS/ARM/etc., pin the builder arch:
docker run --rm --platform=linux/amd64 -v "$(pwd)":/out -w /tmp ubuntu:22.04 bash -lc 'echo ok'
```
चरण 1 — toolchain तैयार करें
```bash
set -euo pipefail
export DEBIAN_FRONTEND=noninteractive
apt-get update && apt-get install -y --no-install-recommends \
build-essential ca-certificates curl bzip2 xz-utils pkg-config perl python3 file git \
automake autoconf libtool m4 zlib1g-dev
```
चरण 2 — स्थैतिक OpenSSL बनाएं (1.1.1w)
```bash
OSSL="1.1.1w"
curl -fsSLO "https://www.openssl.org/source/openssl-$OSSL.tar.gz"
tar xzf "openssl-$OSSL.tar.gz" && cd "openssl-$OSSL"
./Configure no-shared no-zlib linux-x86_64 -static --prefix=/opt/ossl
make -j"$(nproc)" && make install_sw
cd /tmp
```
चरण 3 — स्थैतिक PCRE2 बनाना (10.43)
```bash
PCRE2=10.43
curl -fsSLO "https://github.com/PCRE2Project/pcre2/releases/download/pcre2-$PCRE2/pcre2-$PCRE2.tar.bz2"
tar xjf "pcre2-$PCRE2.tar.bz2" && cd "pcre2-$PCRE2"
./configure --disable-shared --enable-static --prefix=/opt/pcre2
make -j"$(nproc)" && make install
cd /tmp
```
चरण 4 — स्थैतिक Nmap (7.98) बनाना
```bash
NMAP=7.98
curl -fsSLO "https://nmap.org/dist/nmap-$NMAP.tar.bz2"
tar xjf "nmap-$NMAP.tar.bz2" && cd "nmap-$NMAP"
export CPPFLAGS="-I/opt/ossl/include -I/opt/pcre2/include"
export LDFLAGS="-L/opt/ossl/lib -L/opt/pcre2/lib -static -static-libstdc++ -static-libgcc"
export LIBS="-lpcre2-8 -ldl -lpthread -lz"
./configure \
--with-openssl=/opt/ossl \
--with-libpcre=/opt/pcre2 \
--with-libpcap=included \
--with-libdnet=included \
--without-zenmap --without-ndiff --without-nmap-update
# Avoid building shared libpcap by accident
sed -i -e "s/^shared: /shared: #/" libpcap/Makefile || true
make -j1 V=1 nmap
strip nmap
```
मुख्य बिंदु
- -static, -static-libstdc++, -static-libgcc स्थैतिक लिंकिंग मजबूर करते हैं।
- --with-libpcap=included/--with-libdnet=included का उपयोग सिस्टम-शेयर्ड लाइब्रेरीज़ से बचाता है।
- sed के समायोजन से, यदि मौजूद हो तो shared libpcap target निष्क्रिय हो जाता है।

चरण 5 — बाइनरी और NSE डेटा बंडल करें
```bash
mkdir -p /out/nmap-bundle/nmap-data
cp nmap /out/nmap-bundle/nmap-linux-amd64-static
cp -r scripts nselib /out/nmap-bundle/nmap-data/
cp nse_main.lua nmap-services nmap-protocols nmap-service-probes \
nmap-mac-prefixes nmap-os-db nmap-payloads nmap-rpc \
/out/nmap-bundle/nmap-data/ 2>/dev/null || true

tar -C /out -czf /out/nmap-linux-amd64-static-bundle.tar.gz nmap-bundle
```
सत्यापन और ऑप्स नोट्स
- artifact पर file कमांड चलाकर पुष्टि करें कि यह statically linked है।
- Nmap इंस्टॉल न होने वाले hosts पर स्क्रिप्ट समानता सुनिश्चित करने के लिए NSE data को binary के साथ रखें।
- भले ही यह static binary हो, इसका execution AppArmor/seccomp/SELinux द्वारा ब्लॉक किया जा सकता है; DNS/egress अभी भी काम करना चाहिए।
- Deterministic builds डाउनलोड किए गए अस्पष्ट “static” binaries की तुलना में सप्लाई-चेन जोखिम कम करते हैं।

One-liner (Dockerized)
<details>
<summary>Build, bundle, और artifact जानकारी प्रिंट करें</summary>
```bash
docker run --rm --platform=linux/amd64 -v "$(pwd)":/out -w /tmp ubuntu:22.04 bash -lc '
set -euo pipefail
export DEBIAN_FRONTEND=noninteractive
apt-get update && apt-get install -y --no-install-recommends \
build-essential ca-certificates curl bzip2 xz-utils pkg-config perl python3 file git \
automake autoconf libtool m4 zlib1g-dev

OSSL="1.1.1w"; curl -fsSLO "https://www.openssl.org/source/openssl-$OSSL.tar.gz" \
&& tar xzf "openssl-$OSSL.tar.gz" && cd "openssl-$OSSL" \
&& ./Configure no-shared no-zlib linux-x86_64 -static --prefix=/opt/ossl \
&& make -j"$(nproc)" && make install_sw && cd /tmp

PCRE2=10.43; curl -fsSLO "https://github.com/PCRE2Project/pcre2/releases/download/pcre2-$PCRE2/pcre2-$PCRE2.tar.bz2" \
&& tar xjf "pcre2-$PCRE2.tar.bz2" && cd "pcre2-$PCRE2" \
&& ./configure --disable-shared --enable-static --prefix=/opt/pcre2 \
&& make -j"$(nproc)" && make install && cd /tmp

NMAP=7.98; curl -fsSLO "https://nmap.org/dist/nmap-$NMAP.tar.bz2" \
&& tar xjf "nmap-$NMAP.tar.bz2" && cd "nmap-$NMAP" \
&& export CPPFLAGS="-I/opt/ossl/include -I/opt/pcre2/include" \
&& export LDFLAGS="-L/opt/ossl/lib -L/opt/pcre2/lib -static -static-libstdc++ -static-libgcc" \
&& export LIBS="-lpcre2-8 -ldl -lpthread -lz" \
&& ./configure --with-openssl=/opt/ossl --with-libpcre=/opt/pcre2 --with-libpcap=included --with-libdnet=included --without-zenmap --without-ndiff --without-nmap-update \
&& sed -i -e "s/^shared: /shared: #/" libpcap/Makefile || true \
&& make -j1 V=1 nmap && strip nmap

mkdir -p /out/nmap-bundle/nmap-data \
&& cp nmap /out/nmap-bundle/nmap-linux-amd64-static \
&& cp -r scripts nselib /out/nmap-bundle/nmap-data/ \
&& cp nse_main.lua nmap-services nmap-protocols nmap-service-probes nmap-mac-prefixes nmap-os-db nmap-payloads nmap-rpc /out/nmap-bundle/nmap-data/ 2>/dev/null || true \
&& tar -C /out -czf /out/nmap-linux-amd64-static-bundle.tar.gz nmap-bundle \
&& echo "===== OUTPUT ====="; ls -lah /out; echo "===== FILE TYPE ====="; file /out/nmap-bundle/nmap-linux-amd64-static || true
'
```
</details>

## संदर्भ

- [प्रतिबंधित वातावरण में नौकरियों के लिए static Nmap binary का कंपाइल करना](https://www.pentestpartners.com/security-blog/compiling-static-nmap-binary-for-jobs-in-restricted-environments/)
- [Static Nmap Binary Generator (सहायक उपकरण)](https://github.com/0x5ubt13/static_nmap_binary_generator)
- [OpenSSL स्रोत](https://www.openssl.org/source/)
- [PCRE2 रिलीज़](https://github.com/PCRE2Project/pcre2/releases)
- [Nmap स्रोत tarballs](https://nmap.org/dist/)


{{#include ../../banners/hacktricks-training.md}}
