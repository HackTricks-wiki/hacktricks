# Riepilogo di Nmap (ESP)

{{#include ../../banners/hacktricks-training.md}}
```
nmap -sV -sC -O -n -oA nmapscan 192.168.0.1/24
```
## Parametri

### IP da scansionare

- **`<ip>,<net/mask>`:** Indica gli ip direttamente
- **`-iL <ips_file>`:** list_IPs
- **`-iR <number>`**: Numero di IP casuali, puoi escludere IP possibili con `--exclude <Ips>` o `--excludefile <file>`.

### Scoperta dei dispositivi

Per default Nmap lancia una fase di scoperta composta da: `-PA80 -PS443 -PE -PP`

- **`-sL`**: Non è invasivo, elenca i target effettuando richieste **DNS** per risolvere i nomi. È utile per sapere se ad esempio www.prueba.es/24 tutti gli IP sono i nostri target.
- **`-Pn`**: **No ping**. Utile se sai che sono tutti attivi (altrimenti potresti perdere molto tempo, ma questa opzione può anche produrre falsi negativi affermando che non sono attivi), impedisce la fase di discovery.
- **`-sn`** : **No port scan**. Dopo aver completato la fase di ricognizione, non scansiona le porte. È relativamente stealth e permette una scansione veloce di una rete. Con privilegi invia un ACK (-PA) a 80, un SYN (-PS) a 443 e una echo request e una timestamp request; senza privilegi completa sempre le connessioni. Se il target è la rete, usa solo ARP (-PR). Se usato con un'altra opzione, vengono inviati solo i pacchetti dell'altra opzione.
- **`-PR`**: **Ping ARP**. Usato di default quando si analizzano macchine nella nostra rete, è più veloce dell'uso di ping. Se non vuoi usare pacchetti ARP usa `--send-ip`.
- **`-PS <ports>`**: Invia pacchetti SYN ai quali, se rispondono SYN/ACK è open (rispondono con RST per non terminare la connessione), se rispondono RST è closed e se non rispondono è unreachable. In assenza di privilegi viene usata automaticamente una connessione completa. Se non vengono specificate porte, viene usata la 80.
- **`-PA <ports>`**: Come la precedente ma con ACK; combinandole si ottengono risultati migliori.
- **`-PU <ports>`**: L'obiettivo è l'opposto, vengono inviati a porte che si prevedono chiuse. Alcuni firewall controllano solo le connessioni TCP. Se è closed risponde con port unreachable, se arriva altro ICMP o nessuna risposta viene lasciato come destination unreachable.
- **`-PE, -PP, -PM`** : ICMP PINGS: echo reply, timestamp e addresmask. Vengono lanciati per scoprire se il target è attivo.
- **`-PY<ports>`**: Invia probe SCTP INIT su 80 di default; possono rispondere INIT-ACK (open), ABORT (closed), nulla o ICMP unreachable (inactive).
- **`-PO <protocols>`**: Si indica un protocollo negli header, di default 1(ICMP), 2(IGMP) e 4(Encap IP). Per ICMP, IGMP, TCP (6) e UDP (17) si inviano gli header di protocollo, per gli altri solo l'header IP. Lo scopo è che, a causa della malformazione degli header, arrivino risposte Protocol unreachable o risposte dello stesso protocollo per sapere se è up.
- **`-n`**: No DNS
- **`-R`**: DNS sempre

### Tecniche di scansione porte

- **`-sS`**: Non completa la connessione quindi non lascia tracce, molto buona se utilizzabile (privilegi). È quella usata di default.
- **`-sT`**: Completa la connessione, quindi lascia tracce, ma può essere usata senz'altro. Di default senza privilegi.
- **`-sU`**: Più lenta, per UDP. Principali: DNS(53), SNMP(161,162), DHCP(67 e 68), (`-sU53,161,162,67,68`): open(reply), closed(port unreachable), filtered (altro ICMP), open/filtered (nessuna risposta). In caso di open/filtered, `-sV` invia numerose richieste per tentare di rilevare le versioni supportate da nmap e può determinare lo stato reale. Aumenta molto i tempi.
- **`-sY`**: SCTP, fallisce nell'instaurare la connessione quindi non ci sono log, funziona come -PY
- **`-sN,-sX,-sF`:** Null, Fin, Xmas, possono bypassare alcuni firewall ed estrarre informazioni. Si basano sul fatto che macchine compliant standard dovrebbero rispondere con RST a tutte le richieste che non hanno SYN, RST o ACK impostati: open/filtered (nessuna risposta), closed (RST), filtered (ICMP unreachable). Inaffidabili su Windows, Cisco, BSDI e OS/400. Su unix sì.
- **`-sM`**: Maimon scan: invia FIN e ACK, usato per BSD, attualmente restituirà tutto come closed.
- **`-sA, sW`**: ACK e Window, usato per rilevare firewall, per sapere se le porte sono filtrate o no. `-sW` distingue tra open/closed poiché le open rispondono con un valore di window diverso: open (RST con window diversa da 0), closed (RST window = 0), filtered (ICMP unreachable o nessuna risposta). Non tutte le macchine si comportano così, quindi se è tutto closed non sta funzionando, se è qualche open funziona bene, e se sono molte open e poche closed allora si comporta all'opposto.
- **`-sI`:** Idle scan. Per i casi in cui c'è un firewall attivo ma sappiamo che non filtra verso un certo IP (o quando vogliamo anonimato) possiamo usare lo zombie scan (funziona per tutte le porte); per cercare possibili zombie possiamo usare lo script ipidseq o l'exploit auxiliary/scanner/ip/ipidseq. Questo scanner si basa sul numero IPID dei pacchetti IP.
- **`--badsum`:** Invia il checksum sbagliato; le macchine dovrebbero scartare i pacchetti, ma i firewall potrebbero rispondere, viene usato per rilevare firewall.
- **`-sZ`:** SCTP "Weird" scanner, inviando probe con cookie echo fragments dovrebbero essere scartati se open o rispondere con ABORT se closed. Può passare firewall che INIT non attraversa, il problema è che non distingue tra filtered e open.
- **`-sO`:** Scan dei protocolli IP. Invia header malformati o vuoti in cui a volte nemmeno il protocollo è distinguibile. Se arriva ICMP unreachable protocol è closed, se arriva unreachable port è open, se arriva altro errore è filtered, se non arriva nulla è open|filtered.
- **`-b <server>`:** FTPhost --> Usato per scansionare un host da un altro: si connette all'ftp di un'altra macchina e le chiede di inviare file alle porte che vuoi scansionare da quella macchina; dalle risposte sapremo se sono open o no. [\<user>:\<password>@]\<server>\[:\<port>] Quasi tutti gli ftp oggi non permettono più questo e quindi ha poco uso pratico.

### Analisi focalizzata

**-p:** Usato per specificare le porte da scansionare. Per selezionare tutte le 65.535 porte: **-p-** o **-p all**. Nmap ha una classificazione interna basata sulla popolarità. Di default usa le top 1000 ports. Con **-F** (fast scan) analizza le top 100. Con **--top-ports <number>** analizza quel numero di top ports (da 1 a 65.535). Controlla le porte in ordine casuale; per evitare questo usa **-r**. Possiamo anche selezionare porte specifiche: 20-30,80,443,1024- (quest'ultimo significa da 1024 in poi). Possiamo anche raggruppare le porte per protocollo: U:53,T:21-25,80,139,S:9. Possiamo anche scegliere un intervallo all'interno delle porte popolari di Nmap: `-p [-1024]` analizza fino alla porta 1024 tra quelle incluse in nmap-services. **--port-ratio <ratio>** Analizza le porte più comuni in base a un rapporto tra 0 e 1.

**-sV** Scansione versione, l'intensità può essere regolata da 0 a 9, default 7.

**--version-intensity <number>** Regola l'intensità: più è basso, lancerà solo le probe più probabili, non tutte. Con questo si può ridurre considerevolmente il tempo di scansione UDP.

**-O** Rilevamento OS

**--osscan-limit** Per una corretta scansione OS servono almeno una porta open e una closed. Se questa condizione non è soddisfatta e abbiamo impostato questa opzione, non tenterà la predizione dell'OS (risparmia tempo).

**--osscan-guess** Quando il rilevamento OS non è perfetto, fa un tentativo più approfondito.

Script

--script _<filename>_|_<category>_|_<directory>_|_<expression>_[,...]

Per usare gli script di default, usa -sC o --script=default

I tipi disponibili sono: auth, broadcast, default, discovery, dos, exploit, external, fuzzer, intrusive, malware, safe, version, e vuln

- **Auth:** esegue tutti gli script di autenticazione disponibili
- **Default:** esegue gli script di base di default
- **Discovery:** recupera informazioni dal target o vittima
- **External:** script per usare risorse esterne
- **Intrusive:** usa script considerati intrusive verso la vittima o il target
- **Malware:** verifica connessioni aperte da codice malevolo o backdoor
- **Safe:** esegue script non-invasivi
- **Vuln:** scopre le vulnerabilità più note
- **All:** esegue assolutamente tutti gli script di estensione NSE disponibili

Per cercare script:

**nmap --script-help="http-\*" -> Quelli che iniziano con http-**

**nmap --script-help="not intrusive" -> Tutti tranne quelli intrusive**

**nmap --script-help="default or safe" -> Quelli in uno dei due o in entrambi**

**nmap --script-help="default and safe" --> Quelli presenti in entrambi**

**nmap --script-help="(default or safe or intrusive) and not http-\*"**

--script-args _<n1>_=_<v1>_,_<n2>_={_<n3>_=_<v3>_},_<n4>_={_<v4>_,_<v5>_}

--script-args-file _<filename>_

--script-help _<filename>_|_<category>_|_<directory>_|_<expression>_|all[,...]

--script-trace ---> Fornisce info su come procede lo script

--script-updatedb

**Per usare uno script, basta digitare: nmap --script Script_Name target** --> Quando si usa lo script, sia lo script che lo scanner verranno eseguiti, quindi si possono aggiungere anche opzioni dello scanner. Possiamo aggiungere **"safe=1"** per eseguire solo quelli safe.

Controllo del tempo

Nmap può modificare il tempo in seconds, minutes, ms: --host-timeout argomenti 900000ms, 900, 900s, e 15m fanno la stessa cosa.

Nmap divide il numero totale di host da scansionare in gruppi e analizza questi gruppi a blocchi, quindi non passa al blocco successivo finché tutti non sono stati analizzati (e l'utente non riceve aggiornamenti fino al completamento del blocco). In questo modo è più efficiente per Nmap usare gruppi grandi. Di default in class C usa 256.

Questo può essere cambiato con **--min-hostgroup** _**<numhosts>**_**;** **--max-hostgroup** _**<numhosts>**_ (Regola la dimensione dei gruppi di scansione paralleli)

Puoi controllare il numero di scanner paralleli ma è meglio non farlo (Nmap incorpora già un controllo automatico basato sullo stato della rete): **--min-parallelism** _**<numprobes>**_**;** **--max-parallelism** _**<numprobes>**_

Possiamo modificare il timeout RTT, ma di solito non è necessario: **--min-rtt-timeout** _**<time>**_**,** **--max-rtt-timeout** _**<time>**_**,** **--initial-rtt-timeout** _**<time>**_

Possiamo modificare il numero di tentativi: **--max-retries** _**<numtries>**_

Possiamo modificare il tempo di scansione di un host: **--host-timeout** _**<time>**_

Possiamo modificare il tempo tra ogni test per rallentarlo: **--scan-delay** _**<time>**_**;** **--max-scan-delay** _**<time>**_

Possiamo modificare il numero di pacchetti al secondo: **--min-rate** _**<number>**_**;** **--max-rate** _**<number>**_

Molte porte impiegano molto tempo a rispondere quando sono filtered o closed. Se ci interessano solo le open, possiamo accelerare con: **--defeat-rst-ratelimit**

Per definire quanto aggressivo vogliamo che sia Nmap: -T paranoid|sneaky|polite|normal|aggressive|insane

-T (0-1)

-T0 --> Scansiona solo 1 porta alla volta e aspetta 5min prima della successiva

-T1 e T2 --> Molto simili ma aspettano rispettivamente 15s e 0.4s tra ogni test

-T3 --> Operazione di default, include scansione parallela

-T4 --> --max-rtt-timeout 1250ms --min-rtt-timeout 100ms --initial-rtt-timeout 500ms --max-retries 6 --max-scan-delay 10ms

-T5 --> --max-rtt-timeout 300ms --min-rtt-timeout 50ms --initial-rtt-timeout 250ms --max-retries 2 --host-timeout 15m --max-scan-delay 5ms

Firewall/IDS

Non permettono accesso alle porte e analizzano i pacchetti.

**-f** Per frammentare i pacchetti, di default li frammenta in 8 bytes dopo l'header; per specificare quella dimensione si usa ..mtu (con questo non usare -f), l'offset deve essere multiplo di 8. **I version scanners e gli script non supportano la frammentazione**

**-D decoy1,decoy2,ME** Nmap invia gli scanner ma con altri indirizzi IP come origine, così ti nasconde. Se metti ME nella lista, Nmap ti collocherà lì; è meglio mettere 5 o 6 prima di te per mascherarti completamente. IP casuali possono essere generati con RND:<number> per generare <number> di IP casuali. Non funzionano con i TCP version detectors senza connessione. Se sei dentro una rete, conviene usare IP attivi, altrimenti sarà facile scoprire che sei l'unico attivo.

Per usare IP casuali: nmap -D RND:10 Target_IP

**-S IP** Quando Nmap non rileva il tuo IP devi fornirlo. Serve anche per far credere che un altro target stia scansionando.

**-e <interface>** Per scegliere l'interfaccia

Molti amministratori lasciano porte di ingresso aperte affinché tutto funzioni correttamente ed è più semplice per loro che cercare un'altra soluzione. Possono essere porte DNS o FTP... per trovare questa vulnerabilità Nmap incorpora: **--source-port** _**<portnumber>**_**;-g** _**<portnumber>**_ _Sono equivalenti_

**--data** _**<hex string>**_ Per inviare testo esadecimale: --data 0xdeadbeef e --data \xCA\xFE\x09

**--data-string** _**<string>**_ Per inviare testo normale: --data-string "Scan conducted by Security Ops, extension 7192"

**--data-length** _**<number>**_ Nmap invia solo gli header, con questo aggiungiamo un numero di byte in più (generati randomicamente)

Per configurare completamente il pacchetto IP usa **--ip-options**

Se desideri vedere le opzioni nei pacchetti inviati e ricevuti, specifica --packet-trace. Per maggiori informazioni ed esempi sull'uso delle IP options con Nmap vedi [http://seclists.org/nmap-dev/2006/q3/52](http://seclists.org/nmap-dev/2006/q3/52).

**--ttl** _**<value>**_

**--randomize-hosts** Per rendere l'attacco meno evidente

**--spoof-mac** _**<MAC address, prefix, or vendor name>**_ Per cambiare il MAC esempi: Apple, 0, 01:02:03:04:05:06, deadbeefcafe, 0020F2, e Cisco

**--proxies** _**<Comma-separated list of proxy URLs>**_ Per usare proxy; a volte un proxy non mantiene tante connessioni aperte quante ne vuole Nmap quindi potrebbe essere necessario modificare il parallelism: --max-parallelism

**-sP** Per scoprire host nella nostra rete tramite ARP

Molti amministratori creano una regola firewall che permette il passaggio di tutti i pacchetti provenienti da una particolare porta (come 20,53 e 67); possiamo dire a Nmap di inviare i nostri pacchetti da queste porte: **nmap --source-port 53 IP**

Output

**-oN file** Output normale

**-oX file** Output XML

**-oS file** Script kiddies output

**-oG file** Output greppable

**-oA file** Tutti tranne -oS

**-v level** verbosità

**-d level** debugging

**--reason** Motivo di host e stato

**--stats-every time** Ogni quanto tempo ci dice come procede

**--packet-trace** Per vedere quali pacchetti escono, possono essere specificati filtri come: --version-trace o --script-trace

**--open** mostra open, open|filtered e unfiltered

**--resume file** Riprende da un file di output

Varie

**-6** Abilita IPv6

**-A** è equivalente a -O -sV -sC --traceroute

Tempo di esecuzione

Mentre Nmap è in esecuzione possiamo cambiare le opzioni:

v / V Aumenta / diminuisce il livello di verbosità

d / D Aumenta / diminuisce il livello di debugging

p / P Attiva / disattiva il packet tracing

? Stampa una schermata di aiuto per l'interazione a runtime

Vulscan

Script di Nmap che analizza le versioni dei servizi ottenute in un DB offline (scaricato da altre fonti) e restituisce possibili vulnerabilità.

I DB che usa sono:

1. Scipvuldb.csv | [http://www.scip.ch/en/?vuldb](http://www.scip.ch/en/?vuldb)
2. Cve.csv | [http://cve.mitre.org](http://cve.mitre.org/)
3. Osvdb.csv | [http://www.osvdb.org](http://www.osvdb.org/)
4. Securityfocus.csv | [http://www.securityfocus.com/bid/](http://www.securityfocus.com/bid/)
5. Securitytracker.csv | [http://www.securitytracker.com](http://www.securitytracker.com/)
6. Xforce.csv | [http://xforce.iss.net](http://xforce.iss.net/)
7. Exploitdb.csv | [http://www.exploit-db.com](http://www.exploit-db.com/)
8. Openvas.csv | [http://www.openvas.org](http://www.openvas.org/)

Per scaricare e installare nella cartella di Nmap:

wget http://www.computec.ch/projekte/vulscan/download/nmap_nse_vulscan-2.0.tar.gz && tar -czvf nmap_nse_vulscan-2.0.tar.gz vulscan/ && sudo cp -r vulscan/ /usr/share/nmap/scripts/

Sarà anche necessario scaricare i pacchetti DB e aggiungerli in /usr/share/nmap/scripts/vulscan/

Uso:

Per usare tutti: sudo nmap -sV --script=vulscan HOST_TO_SCAN

Per usare un DB specifico: sudo nmap -sV --script=vulscan --script-args vulscandb=cve.csv HOST_TO_SCAN

## Velocizzare la scansione dei service di Nmap x16

Secondo [**questo post**](https://joshua.hu/nmap-speedup-service-scanning-16x) puoi velocizzare l'analisi dei service di nmap modificando tutti i valori **`totalwaitms`** in **`/usr/share/nmap/nmap-service-probes`** a **300** e **`tcpwrappedms`** a **200**.

Inoltre, le probe che non hanno un `servicewaitms` specificamente definito usano un valore di default di **`5000`**. Pertanto, possiamo aggiungere valori a ciascuna probe, o possiamo **compilare nmap** noi stessi e cambiare il valore di default in [**service_scan.h**](https://github.com/nmap/nmap/blob/master/service_scan.h#L79).

Se non vuoi cambiare i valori di **`totalwaitms`** e **`tcpwrappedms`** nel file `/usr/share/nmap/nmap-service-probes`, puoi modificare il [parsing code](https://github.com/nmap/nmap/blob/master/service_scan.cc#L1358) in modo che questi valori nel file `nmap-service-probes` vengano completamente ignorati.

## Costruire un Nmap statico per ambienti ristretti

In ambienti Linux hardened o minimali (containers, appliances), i binari Nmap dinamici spesso falliscono a causa di loader runtime o librerie condivise mancanti (es., /lib64/ld-linux-x86-64.so.2, libc.so). Costruire un Nmap staticamente linkato e includere i dati NSE permette l'esecuzione senza installare pacchetti di sistema.

Approccio ad alto livello
- Usa un builder Ubuntu amd64 pulito tramite Docker.
- Compila OpenSSL e PCRE2 come librerie statiche.
- Compila Nmap collegandolo staticamente e usando le librerie incluse libpcap/libdnet per evitare dipendenze dinamiche.
- Pacchetta gli script NSE e le directory di dati insieme al binario.

Scoprire l'architettura target (esempio)
```bash
uname -a
# If building from macOS/ARM/etc., pin the builder arch:
docker run --rm --platform=linux/amd64 -v "$(pwd)":/out -w /tmp ubuntu:22.04 bash -lc 'echo ok'
```
Passo 1 — Preparare la toolchain
```bash
set -euo pipefail
export DEBIAN_FRONTEND=noninteractive
apt-get update && apt-get install -y --no-install-recommends \
build-essential ca-certificates curl bzip2 xz-utils pkg-config perl python3 file git \
automake autoconf libtool m4 zlib1g-dev
```
Passo 2 — Compilare OpenSSL statico (1.1.1w)
```bash
OSSL="1.1.1w"
curl -fsSLO "https://www.openssl.org/source/openssl-$OSSL.tar.gz"
tar xzf "openssl-$OSSL.tar.gz" && cd "openssl-$OSSL"
./Configure no-shared no-zlib linux-x86_64 -static --prefix=/opt/ossl
make -j"$(nproc)" && make install_sw
cd /tmp
```
Passo 3 — Compilare PCRE2 statico (10.43)
```bash
PCRE2=10.43
curl -fsSLO "https://github.com/PCRE2Project/pcre2/releases/download/pcre2-$PCRE2/pcre2-$PCRE2.tar.bz2"
tar xjf "pcre2-$PCRE2.tar.bz2" && cd "pcre2-$PCRE2"
./configure --disable-shared --enable-static --prefix=/opt/pcre2
make -j"$(nproc)" && make install
cd /tmp
```
Passo 4 — Compilare Nmap statico (7.98)
```bash
NMAP=7.98
curl -fsSLO "https://nmap.org/dist/nmap-$NMAP.tar.bz2"
tar xjf "nmap-$NMAP.tar.bz2" && cd "nmap-$NMAP"
export CPPFLAGS="-I/opt/ossl/include -I/opt/pcre2/include"
export LDFLAGS="-L/opt/ossl/lib -L/opt/pcre2/lib -static -static-libstdc++ -static-libgcc"
export LIBS="-lpcre2-8 -ldl -lpthread -lz"
./configure \
--with-openssl=/opt/ossl \
--with-libpcre=/opt/pcre2 \
--with-libpcap=included \
--with-libdnet=included \
--without-zenmap --without-ndiff --without-nmap-update
# Avoid building shared libpcap by accident
sed -i -e "s/^shared: /shared: #/" libpcap/Makefile || true
make -j1 V=1 nmap
strip nmap
```
Punti chiave
- -static, -static-libstdc++, -static-libgcc forzano il linking statico.
- Usando --with-libpcap=included/--with-libdnet=included si evitano le system-shared libs.
- Un tweak con sed neutralizza un target shared libpcap, se presente.

Passo 5 — Raggruppare il binario e i dati NSE
```bash
mkdir -p /out/nmap-bundle/nmap-data
cp nmap /out/nmap-bundle/nmap-linux-amd64-static
cp -r scripts nselib /out/nmap-bundle/nmap-data/
cp nse_main.lua nmap-services nmap-protocols nmap-service-probes \
nmap-mac-prefixes nmap-os-db nmap-payloads nmap-rpc \
/out/nmap-bundle/nmap-data/ 2>/dev/null || true

tar -C /out -czf /out/nmap-linux-amd64-static-bundle.tar.gz nmap-bundle
```
Note di verifica e operazioni
- Usa il comando file sull'artifact per confermare che sia collegato staticamente.
- Conserva i dati NSE con il binario per garantire la parità degli script su host senza Nmap installato.
- Anche con un binario statico, l'esecuzione può essere bloccata da AppArmor/seccomp/SELinux; DNS/egress deve comunque funzionare.
- Le build deterministiche riducono il rischio della catena di fornitura rispetto al download di binari “static” opachi.

One-liner (Dockerized)
<details>
<summary>Compila, crea il bundle e stampa le informazioni dell'artifact</summary>
```bash
docker run --rm --platform=linux/amd64 -v "$(pwd)":/out -w /tmp ubuntu:22.04 bash -lc '
set -euo pipefail
export DEBIAN_FRONTEND=noninteractive
apt-get update && apt-get install -y --no-install-recommends \
build-essential ca-certificates curl bzip2 xz-utils pkg-config perl python3 file git \
automake autoconf libtool m4 zlib1g-dev

OSSL="1.1.1w"; curl -fsSLO "https://www.openssl.org/source/openssl-$OSSL.tar.gz" \
&& tar xzf "openssl-$OSSL.tar.gz" && cd "openssl-$OSSL" \
&& ./Configure no-shared no-zlib linux-x86_64 -static --prefix=/opt/ossl \
&& make -j"$(nproc)" && make install_sw && cd /tmp

PCRE2=10.43; curl -fsSLO "https://github.com/PCRE2Project/pcre2/releases/download/pcre2-$PCRE2/pcre2-$PCRE2.tar.bz2" \
&& tar xjf "pcre2-$PCRE2.tar.bz2" && cd "pcre2-$PCRE2" \
&& ./configure --disable-shared --enable-static --prefix=/opt/pcre2 \
&& make -j"$(nproc)" && make install && cd /tmp

NMAP=7.98; curl -fsSLO "https://nmap.org/dist/nmap-$NMAP.tar.bz2" \
&& tar xjf "nmap-$NMAP.tar.bz2" && cd "nmap-$NMAP" \
&& export CPPFLAGS="-I/opt/ossl/include -I/opt/pcre2/include" \
&& export LDFLAGS="-L/opt/ossl/lib -L/opt/pcre2/lib -static -static-libstdc++ -static-libgcc" \
&& export LIBS="-lpcre2-8 -ldl -lpthread -lz" \
&& ./configure --with-openssl=/opt/ossl --with-libpcre=/opt/pcre2 --with-libpcap=included --with-libdnet=included --without-zenmap --without-ndiff --without-nmap-update \
&& sed -i -e "s/^shared: /shared: #/" libpcap/Makefile || true \
&& make -j1 V=1 nmap && strip nmap

mkdir -p /out/nmap-bundle/nmap-data \
&& cp nmap /out/nmap-bundle/nmap-linux-amd64-static \
&& cp -r scripts nselib /out/nmap-bundle/nmap-data/ \
&& cp nse_main.lua nmap-services nmap-protocols nmap-service-probes nmap-mac-prefixes nmap-os-db nmap-payloads nmap-rpc /out/nmap-bundle/nmap-data/ 2>/dev/null || true \
&& tar -C /out -czf /out/nmap-linux-amd64-static-bundle.tar.gz nmap-bundle \
&& echo "===== OUTPUT ====="; ls -lah /out; echo "===== FILE TYPE ====="; file /out/nmap-bundle/nmap-linux-amd64-static || true
'
```
</details>

## Riferimenti

- [Compilazione di un binario Nmap statico per attività in ambienti con restrizioni](https://www.pentestpartners.com/security-blog/compiling-static-nmap-binary-for-jobs-in-restricted-environments/)
- [Static Nmap Binary Generator (strumento di supporto)](https://github.com/0x5ubt13/static_nmap_binary_generator)
- [Sorgenti OpenSSL](https://www.openssl.org/source/)
- [Rilasci di PCRE2](https://github.com/PCRE2Project/pcre2/releases)
- [Tarball dei sorgenti di Nmap](https://nmap.org/dist/)


{{#include ../../banners/hacktricks-training.md}}
