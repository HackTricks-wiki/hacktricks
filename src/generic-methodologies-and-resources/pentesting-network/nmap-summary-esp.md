# Nmap Resumo (ESP)

{{#include ../../banners/hacktricks-training.md}}
```
nmap -sV -sC -O -n -oA nmapscan 192.168.0.1/24
```
## Parameters

### IPs to scan

- **`<ip>,<net/mask>`:** Indica os ips diretamente
- **`-iL <ips_file>`:** list_IPs
- **`-iR <number>`**: Número de Ips aleatórios, você pode excluir Ips possíveis com `--exclude <Ips>` ou `--excludefile <file>`.

### Equipment discovery

Por padrão Nmap lança uma fase de discovery consistindo em: `-PA80 -PS443 -PE -PP`

- **`-sL`**: Não é invasivo, lista os alvos fazendo requisições **DNS** para resolver nomes. Útil para saber se por exemplo www.prueba.es/24 todos os Ips são nossos alvos.
- **`-Pn`**: **No ping**. Útil se souber que todos estão ativos (caso contrário, pode perder muito tempo, mas esta opção também produz falsos negativos dizendo que não estão ativos), evita a fase de discovery.
- **`-sn`** : **No port scan**. Após completar a fase de reconnaissance, não faz scan de portas. É relativamente stealthy, e permite um scan pequeno de rede. Com privilégios envia um ACK (-PA) para 80, um SYN(-PS) para 443 e um echo request e um Timestamp request, sem privilégios ele sempre completa conexões. Se o alvo for a rede, usa apenas ARP(-PR). Se usado com outra opção, apenas os pacotes da outra opção são descartados.
- **`-PR`**: **Ping ARP**. Usado por padrão quando analisamos computadores na nossa rede, é mais rápido que usar pings. Se não quiser usar pacotes ARP use `--send-ip`.
- **`-PS <ports>`**: Envia pacotes SYN; se responder SYN/ACK está open (responde com RST para não finalizar a conexão), se responder RST está closed e se não responder está unreachable. Sem privilégios, uma conexão total é usada automaticamente. Se não forem dados ports, usa 80 por padrão.
- **`-PA <ports>`**: Semelhante ao anterior mas com ACK; combinar ambos dá melhores resultados.
- **`-PU <ports>`**: O objetivo é o oposto, são enviados a portas que se espera que estejam closed. Alguns firewalls só checam conexões TCP. Se estiver closed responde com port unreachable, se responder com outro icmp ou não responder fica como destination unreachable.
- **`-PE, -PP, -PM`** : ICMP PINGS: echo reply, timestamp e addresmask. São lançados para descobrir se o alvo está ativo.
- **`-PY<ports>`**: Envia probes SCTP INIT para 80 por padrão, pode responder INIT-ACK(open) ou ABORT(closed) ou nada ou ICMP unreachable(inactive).
- **`-PO <protocols>`**: Indica um protocolo nos headers, por padrão 1(ICMP), 2(IGMP) e 4(Encap IP). Para ICMP, IGMP, TCP (6) e UDP (17) os headers de protocolo são enviados, para o resto só o header IP é enviado. O propósito é que, devido à malformação dos headers, checar respostas Protocol unreachable ou respostas do mesmo protocolo para saber se está up.
- **`-n`**: No DNS
- **`-R`**: DNS always

### Port scanning techniques

- **`-sS`**: Não completa a conexão então não deixa rastro, muito bom se puder ser usado.(privileges) É o utilizado por padrão.
- **`-sT`**: Completa a conexão, portanto deixa rastro, mas pode ser usado com certeza. Por padrão sem privilégios.
- **`-sU`**: Mais lento, para UDP. Principalmente: DNS(53), SNMP(161,162), DHCP(67 e 68), (-sU53,161,162,67,68): open(reply), closed(port unreachable), filtered (outro ICMP), open/filtered (nada). Em caso de open/filtered, -sV envia numerosas requisições para detectar qualquer das versões que nmap suporta e pode detectar o estado real. Aumenta muito o tempo.
- **`-sY`**: SCTP protocolo que não estabelece a conexão, então não há logs, funciona como -PY
- **`-sN,-sX,-sF`:** Null, Fin, Xmas, podem penetrar alguns firewalls e extrair informação. Baseiam-se no fato de que máquinas que seguem o padrão devem responder com RST a todas as requests que não tenham SYN, RST ou ACK setados: open/filtered(nada), closed(RST), filtered (ICMP unreachable). Não confiável em WIndows, CIsco, BSDI e OS/400. Em unix sim.
- **`-sM`**: Maimon scan: Envia FIN e ACK flags, usado para BSD, atualmente retornará todos como closed.
- **`-sA, sW`**: ACK e Window, usado para detectar firewalls, para saber se as portas estão filtered ou não. O -sW distingue entre open/closed já que as open respondem com um valor de window diferente: open (RST com window != 0), closed (RST window = 0), filtered (ICMP unreachable ou nada). Nem todos os computadores funcionam assim, então se tudo aparecer closed, não está funcionando; se aparecerem alguns open, funciona bem; se aparecerem muitos open e poucos closed, funciona ao contrário.
- **`-sI`:** Idle scan. Para casos em que há um firewall ativo mas sabemos que ele não filtra para certo Ip (ou quando simplesmente queremos anonimato) podemos usar o zombie scanner (funciona para todas as portas); para procurar possíveis zombies podemos usar o script ipidseq ou o exploit auxiliary/scanner/ip/ipidseq. Este scanner baseia-se no número IPID dos pacotes IP.
- **`--badsum`:** Envia checksum errado, os computadores descartariam os pacotes, mas os firewalls podem responder algo; usado para detectar firewalls.
- **`-sZ`:** "Weird" SCTP scanner, ao enviar probes com cookie echo fragments eles deveriam ser descartados se open ou respondidos com ABORT se closed. Pode passar por firewalls que init não passa; ruim é que não distingue entre filtered e open.
- **`-sO`:** Protocol Ip scan. Envia headers malformados e vazios em que às vezes nem mesmo o protocolo pode ser distinguido. Se chegar ICMP unreachable protocol está closed, se chegar unreachable port está open, se chegar outro erro, filtered, se nada chega, open|filtered.
- **`-b <server>`:** FTPhost--> Usado para scanear um host a partir de outro, feito conectando ao ftp de outra máquina e pedindo que envie arquivos para as portas que queres scanear a partir da outra máquina; de acordo com as respostas saberemos se estão open ou não. [\<user>:\<password>@]\<server>\[:\<port>] Quase todos os ftps servers já não permitem isso, sendo de pouco uso prático.

### **Focus Analysis**

**-p:** Usado para especificar portas a scanear. Para selecionar todas as 65.335 portas: **-p-** ou **-p all**. Nmap tem uma classificação interna baseada em popularidade. Por padrão usa as top 1000 ports. Com **-F** (fast scan) analisa as top 100. Com **--top-ports <number>** analisa esse número de top ports (de 1 a 65,335). Checa portas em ordem aleatória; para evitar isso, use **-r**. Também podemos selecionar portas específicas: 20-30,80,443,1024- (este último significa procurar a partir de 1024). Podemos agrupar portas por protocolos: U:53,T:21-25,80,139,S:9. Podemos também escolher um intervalo dentro das portas populares do Nmap: -p [-1024] analisa até a porta 1024 dentre as incluídas em nmap-services. **--port-ratio <ratio>** Analisa as portas mais comuns dentro de uma razão entre 0 e 1

**-sV** Version scanning, intensidade pode ser regulada de 0 a 9, default é 7.

**--version-intensity <number>** Regulamos a intensidade; quanto menor, apenas lançará as probes mais prováveis, não todas. Com isso podemos reduzir consideravelmente o tempo de scan UDP

**-O** OS detection

**--osscan-limit** Para uma correta detecção de host, ao menos uma porta open e uma closed são necessárias. Se essa condição não for satisfeita e tivermos setado isto, não tentará predizer o OS (economiza tempo)

**--osscan-guess** Quando a detecção de OS não é perfeita, faz tentar mais

**Scripts**

--script _<filename>_|_<category>_|_<directory>_|_<expression>_[,...]

Para usar scripts default, use -sC ou --script=default

Tipos disponíveis: auth, broadcast, default, discovery, dos, exploit, external, fuzzer, intrusive, malware, safe, version, e vuln

- **Auth:** executa todos os scripts de autenticação disponíveis
- **Default:** executa scripts básicos default da ferramenta
- **Discovery:** obtém informação do target ou vítima
- **External:** script para usar recursos externos
- **Intrusive:** usa scripts considerados intrusivos para a vítima ou target
- **Malware:** checa por conexões abertas por código malicioso ou backdoors
- **Safe:** executa scripts não-intrusivos
- **Vuln:** descobre as vulnerabilidades mais conhecidas
- **All:** executa absolutamente todos os scripts de extensão NSE disponíveis

Para buscar scripts:

**nmap --script-help="http-\*" -> Those starting with http-**

**nmap --script-help="not intrusive" -> All except those**

**nmap --script-help="default or safe" -> Those in either or both**

**nmap --script-help="default and safe" --> Those in both**

**nmap --script-help="(default or safe or intrusive) and not http-\*"**

--script-args _<n1>_=_<v1>_,_<n2>_={_<n3>_=_<v3>_},_<n4>_={_<v4>_,_<v5>_}

--script-args-file _<filename>_

--script-help _<filename>_|_<category>_|_<directory>_|_<expression>_|all[,...]

--script-trace ---> Fornece info de como o script está progredindo

--script-updatedb

**To use a script, just type: nmap --script Script_Name target** --> Ao usar o script, tanto o script quanto o scanner serão executados, portanto opções do scanner também podem ser adicionadas. Podemos adicionar **"safe=1"** para executar apenas os safe.

**Time Control**

**Nmap pode modificar tempos em segundos, minutos, ms:** --host-timeout argumentos 900000ms, 900, 900s, e 15m fazem a mesma coisa.

Nmap divide o número total de hosts a scanear em grupos e analisa esses grupos em blocos, então não passa para o próximo bloco até que todos tenham sido analisados (e o usuário não recebe atualizações até o bloco ser analisado). Assim, é mais ótimo para Nmap usar grupos grandes. Por padrão em class C, usa 256.

Isso pode ser alterado com **--min-hostgroup** _**<numhosts>**_**;** **--max-hostgroup** _**<numhosts>**_ (Ajusta tamanhos dos grupos de scan paralelos)

Você pode controlar o número de scanners paralelos, mas é melhor não fazê-lo (Nmap já incorpora controle automático baseado no status da rede): **--min-parallelism** _**<numprobes>**_**;** **--max-parallelism** _**<numprobes>**_

Podemos modificar o RTT timeout, mas normalmente não é necessário: **--min-rtt-timeout** _**<time>**_**,** **--max-rtt-timeout** _**<time>**_**,** **--initial-rtt-timeout** _**<time>**_

Podemos modificar o número de tentativas: **--max-retries** _**<numtries>**_

Podemos modificar o tempo de scan de um host: **--host-timeout** _**<time>**_

Podemos modificar o tempo entre cada teste para desacelerar: **--scan-delay** _**<time>**_**;** **--max-scan-delay** _**<time>**_

Podemos modificar o número de pacotes por segundo: **--min-rate** _**<number>**_**;** **--max-rate** _**<number>**_

Muitas portas demoram muito para responder quando filtradas ou closed. Se estamos interessados apenas nas open, podemos acelerar com: **--defeat-rst-ratelimit**

Para definir quão agressivo queremos que o Nmap seja: -T paranoid|sneaky|polite|normal|aggressive|insane

-T (0-1)

-T0 --> Só escaneia 1 porta por vez e espera 5min até a próxima

-T1 e T2 --> Muito similares mas esperam apenas 15 e 0.4sec respectivamente entre cada teste

-T3 --> Operação padrão, inclui scanning paralelo

-T4 --> --max-rtt-timeout 1250ms --min-rtt-timeout 100ms --initial-rtt-timeout 500ms --max-retries 6 --max-scan-delay 10ms

-T5 --> --max-rtt-timeout 300ms --min-rtt-timeout 50ms --initial-rtt-timeout 250ms --max-retries 2 --host-timeout 15m --max-scan-delay 5ms

**Firewall/IDS**

Eles bloqueiam acesso a portas e analisam pacotes.

**-f** Para fragmentar pacotes, por padrão fragmenta em 8bytes após o header, para especificar esse tamanho usamos ..mtu (com isso, não use -f), o offset deve ser múltiplo de 8. **Version scanners e scripts não suportam fragmentação**

**-D decoy1,decoy2,ME** Nmap envia scans mas com outros IPs como origem, assim escondem você. Se colocar ME na lista, Nmap te colocará lá; é melhor colocar 5 ou 6 antes para mascarar completamente. IPs aleatórios podem ser gerados com RND:<number> para gerar <number> de IPs aleatórios. Não funcionam com TCP version detectors sem conexão. Se você está dentro de uma rede, interessa usar IPs ativos, caso contrário será fácil identificar que você é o único ativo.

Para usar IPs aleatórios: nmap -D RND:10 Target_IP

**-S IP** Para quando o Nmap não detecta seu IP você tem que fornecê-lo. Também serve para fazê-los pensar que outro target está escaneando-os.

**-e <interface>** Para escolher a interface

Muitos administradores deixam portas de entrada abertas para tudo funcionar corretamente e é mais fácil para eles do que achar outra solução. Podem ser portas DNS ou FTP... para encontrar essa vulnerabilidade Nmap incorpora: **--source-port** _**<portnumber>**_**;-g** _**<portnumber>**_ _They are equivalent_

**--data** _**<hex string>**_ Para enviar texto hexadecimal: --data 0xdeadbeef and --data \xCA\xFE\x09

**--data-string** _**<string>**_ Para enviar texto normal: --data-string "Scan conducted by Security Ops, extension 7192"

**--data-length** _**<number>**_ Nmap só envia headers; com isto adicionamos um número extra de bytes (que serão gerados aleatoriamente)

Para configurar completamente o pacote IP use **--ip-options**

Se quiser ver as opções nos pacotes enviados e recebidos, especifique --packet-trace. Para mais informação e exemplos de uso de IP options com Nmap, veja [http://seclists.org/nmap-dev/2006/q3/52](http://seclists.org/nmap-dev/2006/q3/52).

**--ttl** _**<value>**_

**--randomize-hosts** Para tornar o ataque menos óbvio

**--spoof-mac** _**<MAC address, prefix, or vendor name>**_ Para alterar o MAC exemplos: Apple, 0, 01:02:03:04:05:06, deadbeefcafe, 0020F2, e Cisco

**--proxies** _**<Comma-separated list of proxy URLs>**_ Para usar proxies; às vezes um proxy não mantém tantas conexões abertas quanto o Nmap quer, então o parallelism teria que ser modificado: --max-parallelism

**-sP** Para descobrir hosts na nossa rede via ARP

Muitos administradores criam uma regra de firewall que permite todos os pacotes vindos de uma porta particular (como 20,53 e 67), podemos dizer ao Nmap para enviar nossos pacotes a partir dessas portas: **nmap --source-port 53 IP**

**Outputs**

**-oN file** Saída normal

**-oX file** Saída XML

**-oS file** Script kiddies output

**-oG file** Saída greppable

**-oA file** All except -oS

**-v level** verbosidade

**-d level** debugging

**--reason** Motivo do estado do host

**--stats-every time** A cada esse tempo informa andamento

**--packet-trace** Para ver quais pacotes saem, filtros podem ser especificados tipo: --version-trace ou --script-trace

**--open** mostra open, open|filtered e unfiltered

**--resume file** Retoma um summary

**Miscellaneous**

**-6** Permite IPv6

**-A** equivale a -O -sV -sC --traceroute

**Run time**

Enquanto Nmap está rodando podemos mudar opções:

v / V Aumenta / diminui o nível de verbosidade

d / D Aumenta / diminui o nível de debugging

p / P Liga / desliga packet tracing

? Imprime uma tela de help interativo em runtime

**Vulscan**

Nmap script que olha versões de serviços obtidos numa database offline (baixada de outras muito importantes) e retorna possíveis vulnerabilidades

Os DBs que usa são:

1. Scipvuldb.csv | [http://www.scip.ch/en/?vuldb](http://www.scip.ch/en/?vuldb)
2. Cve.csv | [http://cve.mitre.org](http://cve.mitre.org/)
3. Osvdb.csv | [http://www.osvdb.org](http://www.osvdb.org/)
4. Securityfocus.csv | [http://www.securityfocus.com/bid/](http://www.securityfocus.com/bid/)
5. Securitytracker.csv | [http://www.securitytracker.com](http://www.securitytracker.com/)
6. Xforce.csv | [http://xforce.iss.net](http://xforce.iss.net/)
7. Exploitdb.csv | [http://www.exploit-db.com](http://www.exploit-db.com/)
8. Openvas.csv | [http://www.openvas.org](http://www.openvas.org/)

Para baixar e instalar na pasta do Nmap:

wget http://www.computec.ch/projekte/vulscan/download/nmap_nse_vulscan-2.0.tar.gz && tar -czvf nmap_nse_vulscan-2.0.tar.gz vulscan/ && sudo cp -r vulscan/ /usr/share/nmap/scripts/

Também será necessário baixar os pacotes DB e adicioná-los em /usr/share/nmap/scripts/vulscan/

Uso:

Para usar todos: sudo nmap -sV --script=vulscan HOST_TO_SCAN

Para usar um DB específico: sudo nmap -sV --script=vulscan --script-args vulscandb=cve.csv HOST_TO_SCAN

## Speed Up Nmap Service scan x16

Segundo [**to this post**](https://joshua.hu/nmap-speedup-service-scanning-16x) você pode acelerar a análise de serviços do nmap modificando todos os valores **`totalwaitms`** em **`/usr/share/nmap/nmap-service-probes`** para **300** e **`tcpwrappedms`** para **200**.

Além disso, probes que não têm um **`servicewaitms`** especificamente definido usam um valor default de **`5000`**. Portanto, podemos ou adicionar valores a cada probe, ou **compilar o nmap** nós mesmos e mudar o valor default em [**service_scan.h**](https://github.com/nmap/nmap/blob/master/service_scan.h#L79).

Se você não quiser mudar os valores de **`totalwaitms`** e **`tcpwrappedms`** no arquivo `/usr/share/nmap/nmap-service-probes`, pode editar o [parsing code](https://github.com/nmap/nmap/blob/master/service_scan.cc#L1358) de forma que esses valores no arquivo `nmap-service-probes` sejam completamente ignorados.


## Build a static Nmap for restricted environments

Em ambientes Linux hardenizados ou mínimos (containers, appliances), binários Nmap dinamicamente linkados frequentemente falham devido a loaders de runtime ou bibliotecas compartilhadas ausentes (ex.: /lib64/ld-linux-x86-64.so.2, libc.so). Construir seu próprio Nmap static linked e empacotar dados NSE permite execução sem instalar pacotes do sistema.

High-level approach
- Use um builder Ubuntu amd64 limpo via Docker.
- Build OpenSSL e PCRE2 como static libraries.
- Build Nmap linkando estaticamente e usando o libpcap/libdnet incluídos para evitar deps dinâmicos.
- Bundle NSE scripts e diretórios de dados com o binário.

Discover target architecture (example)
```bash
uname -a
# If building from macOS/ARM/etc., pin the builder arch:
docker run --rm --platform=linux/amd64 -v "$(pwd)":/out -w /tmp ubuntu:22.04 bash -lc 'echo ok'
```
Passo 1 — Preparar toolchain
```bash
set -euo pipefail
export DEBIAN_FRONTEND=noninteractive
apt-get update && apt-get install -y --no-install-recommends \
build-essential ca-certificates curl bzip2 xz-utils pkg-config perl python3 file git \
automake autoconf libtool m4 zlib1g-dev
```
Etapa 2 — Compilar OpenSSL estático (1.1.1w)
```bash
OSSL="1.1.1w"
curl -fsSLO "https://www.openssl.org/source/openssl-$OSSL.tar.gz"
tar xzf "openssl-$OSSL.tar.gz" && cd "openssl-$OSSL"
./Configure no-shared no-zlib linux-x86_64 -static --prefix=/opt/ossl
make -j"$(nproc)" && make install_sw
cd /tmp
```
Passo 3 — Compilar PCRE2 estático (10.43)
```bash
PCRE2=10.43
curl -fsSLO "https://github.com/PCRE2Project/pcre2/releases/download/pcre2-$PCRE2/pcre2-$PCRE2.tar.bz2"
tar xjf "pcre2-$PCRE2.tar.bz2" && cd "pcre2-$PCRE2"
./configure --disable-shared --enable-static --prefix=/opt/pcre2
make -j"$(nproc)" && make install
cd /tmp
```
Passo 4 — Compilar Nmap estático (7.98)
```bash
NMAP=7.98
curl -fsSLO "https://nmap.org/dist/nmap-$NMAP.tar.bz2"
tar xjf "nmap-$NMAP.tar.bz2" && cd "nmap-$NMAP"
export CPPFLAGS="-I/opt/ossl/include -I/opt/pcre2/include"
export LDFLAGS="-L/opt/ossl/lib -L/opt/pcre2/lib -static -static-libstdc++ -static-libgcc"
export LIBS="-lpcre2-8 -ldl -lpthread -lz"
./configure \
--with-openssl=/opt/ossl \
--with-libpcre=/opt/pcre2 \
--with-libpcap=included \
--with-libdnet=included \
--without-zenmap --without-ndiff --without-nmap-update
# Avoid building shared libpcap by accident
sed -i -e "s/^shared: /shared: #/" libpcap/Makefile || true
make -j1 V=1 nmap
strip nmap
```
Pontos principais
- -static, -static-libstdc++, -static-libgcc forçam ligação estática.
- Usar --with-libpcap=included/--with-libdnet=included evita system-shared libs.
- Um ajuste com sed neutraliza um target shared libpcap se estiver presente.

Passo 5 — Empacotar binary e dados NSE
```bash
mkdir -p /out/nmap-bundle/nmap-data
cp nmap /out/nmap-bundle/nmap-linux-amd64-static
cp -r scripts nselib /out/nmap-bundle/nmap-data/
cp nse_main.lua nmap-services nmap-protocols nmap-service-probes \
nmap-mac-prefixes nmap-os-db nmap-payloads nmap-rpc \
/out/nmap-bundle/nmap-data/ 2>/dev/null || true

tar -C /out -czf /out/nmap-linux-amd64-static-bundle.tar.gz nmap-bundle
```
Notas de verificação e operações
- Use file no artifact para confirmar que ele é estaticamente vinculado.
- Mantenha os dados NSE junto ao binário para garantir paridade de scripts em hosts sem Nmap instalado.
- Mesmo com um binário estático, a execução pode ser bloqueada por AppArmor/seccomp/SELinux; DNS/egress ainda precisam funcionar.
- Compilações determinísticas reduzem o risco na cadeia de suprimentos em comparação com baixar binários opacos “static”.

Comando de uma linha (Dockerized)
<details>
<summary>Compilar, empacotar e imprimir informações do artefato</summary>
```bash
docker run --rm --platform=linux/amd64 -v "$(pwd)":/out -w /tmp ubuntu:22.04 bash -lc '
set -euo pipefail
export DEBIAN_FRONTEND=noninteractive
apt-get update && apt-get install -y --no-install-recommends \
build-essential ca-certificates curl bzip2 xz-utils pkg-config perl python3 file git \
automake autoconf libtool m4 zlib1g-dev

OSSL="1.1.1w"; curl -fsSLO "https://www.openssl.org/source/openssl-$OSSL.tar.gz" \
&& tar xzf "openssl-$OSSL.tar.gz" && cd "openssl-$OSSL" \
&& ./Configure no-shared no-zlib linux-x86_64 -static --prefix=/opt/ossl \
&& make -j"$(nproc)" && make install_sw && cd /tmp

PCRE2=10.43; curl -fsSLO "https://github.com/PCRE2Project/pcre2/releases/download/pcre2-$PCRE2/pcre2-$PCRE2.tar.bz2" \
&& tar xjf "pcre2-$PCRE2.tar.bz2" && cd "pcre2-$PCRE2" \
&& ./configure --disable-shared --enable-static --prefix=/opt/pcre2 \
&& make -j"$(nproc)" && make install && cd /tmp

NMAP=7.98; curl -fsSLO "https://nmap.org/dist/nmap-$NMAP.tar.bz2" \
&& tar xjf "nmap-$NMAP.tar.bz2" && cd "nmap-$NMAP" \
&& export CPPFLAGS="-I/opt/ossl/include -I/opt/pcre2/include" \
&& export LDFLAGS="-L/opt/ossl/lib -L/opt/pcre2/lib -static -static-libstdc++ -static-libgcc" \
&& export LIBS="-lpcre2-8 -ldl -lpthread -lz" \
&& ./configure --with-openssl=/opt/ossl --with-libpcre=/opt/pcre2 --with-libpcap=included --with-libdnet=included --without-zenmap --without-ndiff --without-nmap-update \
&& sed -i -e "s/^shared: /shared: #/" libpcap/Makefile || true \
&& make -j1 V=1 nmap && strip nmap

mkdir -p /out/nmap-bundle/nmap-data \
&& cp nmap /out/nmap-bundle/nmap-linux-amd64-static \
&& cp -r scripts nselib /out/nmap-bundle/nmap-data/ \
&& cp nse_main.lua nmap-services nmap-protocols nmap-service-probes nmap-mac-prefixes nmap-os-db nmap-payloads nmap-rpc /out/nmap-bundle/nmap-data/ 2>/dev/null || true \
&& tar -C /out -czf /out/nmap-linux-amd64-static-bundle.tar.gz nmap-bundle \
&& echo "===== OUTPUT ====="; ls -lah /out; echo "===== FILE TYPE ====="; file /out/nmap-bundle/nmap-linux-amd64-static || true
'
```
</details>

## Referências

- [Compiling static Nmap binary for jobs in restricted environments](https://www.pentestpartners.com/security-blog/compiling-static-nmap-binary-for-jobs-in-restricted-environments/)
- [Static Nmap Binary Generator (helper tool)](https://github.com/0x5ubt13/static_nmap_binary_generator)
- [OpenSSL sources](https://www.openssl.org/source/)
- [PCRE2 releases](https://github.com/PCRE2Project/pcre2/releases)
- [Nmap source tarballs](https://nmap.org/dist/)


{{#include ../../banners/hacktricks-training.md}}
