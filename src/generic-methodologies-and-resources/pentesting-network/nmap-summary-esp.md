# Nmap Résumé (ESP)

{{#include ../../banners/hacktricks-training.md}}
```
nmap -sV -sC -O -n -oA nmapscan 192.168.0.1/24
```
## Paramètres

### IPs à scanner

- **`<ip>,<net/mask>`:** Indiquer les ips directement
- **`-iL <ips_file>`:** list_IPs
- **`-iR <number>`**: Nombre d'IPs aléatoires, vous pouvez exclure des Ips possibles avec `--exclude <Ips>` ou `--excludefile <file>`.

### Découverte d'équipements

Par défaut Nmap lance une phase de découverte composée de : `-PA80 -PS443 -PE -PP`

- **`-sL`**: Non invasif, liste les cibles en effectuant des requêtes **DNS** pour résoudre les noms. Utile pour savoir si par exemple www.prueba.es/24 toutes les Ips sont nos cibles.
- **`-Pn`**: **Pas de ping**. Utile si vous savez qu'elles sont toutes actives (sinon vous pourriez perdre beaucoup de temps, mais cette option produit aussi des faux négatifs en disant qu'elles ne sont pas actives), elle empêche la phase de découverte.
- **`-sn`** : **Pas de scan de ports**. Après la phase de reconnaissance, il ne scanne pas les ports. Relativement discret, et permet un scan réseau léger. Avec privilèges il envoie un ACK (-PA) vers 80, un SYN(-PS) vers 443 et une requête echo et une requête Timestamp, sans privilèges il complète toujours les connexions. Si la cible est le réseau, il n'utilise que ARP(-PR). Si utilisé avec une autre option, seuls les paquets de l'autre option sont abandonnés.
- **`-PR`**: **Ping ARP**. Utilisé par défaut lors de l'analyse d'ordinateurs sur notre réseau, plus rapide que les pings. Si vous ne voulez pas utiliser de paquets ARP utilisez `--send-ip`.
- **`-PS <ports>`**: Envoie des paquets SYN ; si la cible répond SYN/ACK c'est open (on répond RST pour ne pas terminer la connexion), si elle répond RST c'est closed et si elle ne répond pas c'est unreachable. En cas de manque de privilèges, une connexion totale est automatiquement utilisée. Si aucun port n'est fourni, il l'envoie sur 80.
- **`-PA <ports>`**: Comme le précédent mais avec ACK, la combinaison des deux donne de meilleurs résultats.
- **`-PU <ports>`**: L'objectif est l'inverse, ils sont envoyés à des ports qui sont censés être fermés. Certains firewalls ne vérifient que les connexions TCP. Si c'est closed il répond avec port unreachable, si c'est répondu avec un autre icmp ou pas répondu c'est laissé comme destination unreachable.
- **`-PE, -PP, -PM`** : PINGS ICMP : echo reply, timestamp et addresmask. Ils sont lancés pour savoir si la cible est active.
- **`-PY<ports>`**: Envoie des sondes SCTP INIT vers 80 par défaut, INIT-ACK(open) ou ABORT(closed) ou rien ou ICMP unreachable(inactive) peuvent être reçus.
- **`-PO <protocols>`**: Un protocole est indiqué dans les en-têtes, par défaut 1(ICMP), 2(IGMP) et 4(Encap IP). Pour ICMP, IGMP, TCP (6) et UDP (17) les en-têtes de protocole sont envoyés, pour le reste seul l'en-tête IP est envoyé. Le but est qu'après malformation des en-têtes, Protocol unreachable ou des réponses du même protocole soient renvoyées pour savoir si c'est up.
- **`-n`**: Pas de DNS
- **`-R`**: DNS toujours

### Techniques de scan de ports

- **`-sS`**: Ne complète pas la connexion donc ne laisse pas de trace, très bien si utilisable.(privilèges) C'est celui utilisé par défaut.
- **`-sT`**: Complète la connexion, donc laisse une trace, mais peut être utilisé sans problème. Par défaut sans privilèges.
- **`-sU`**: Plus lent, pour UDP. Principalement : DNS(53), SNMP(161,162), DHCP(67 et 68), (-sU53,161,162,67,68): open(reply), closed(port unreachable), filtered (autre ICMP), open/filtered (rien). En cas d'open/filtered, -sV envoie de nombreuses requêtes pour détecter les versions supportées par nmap et peut détecter le véritable état. Augmente beaucoup le temps.
- **`-sY`**: SCTP, échoue à établir la connexion donc pas de logs, fonctionne comme -PY
- **`-sN,-sX,-sF`:** Null, Fin, Xmas, ils peuvent passer certains firewalls et extraire des informations. Basés sur le fait que les machines conformes devraient répondre RST à toute requête sans SYN, RST ou ACK : open/filtered(rien), closed(RST), filtered (ICMP unreachable). Peu fiables sur Windows, Cisco, BSDI et OS/400. Sur unix oui.
- **`-sM`**: Maimon scan : Envoie flags FIN et ACK, utilisé pour BSD, actuellement retournera tout comme closed.
- **`-sA, sW`**: ACK et Window, utilisé pour détecter des firewalls, pour savoir si les ports sont filtrés ou non. Le -sW distingue open/closed car les open répondent avec une valeur de window différente : open (RST avec window ≠ 0), closed (RST window = 0), filtered (ICMP unreachable ou rien). Toutes les machines ne se comportent pas ainsi, donc si tout est closed, ce n'est pas fiable, si quelques-uns sont open, ça marche bien, et si beaucoup sont open et peu sont closed, ça fonctionne à l'inverse.
- **`-sI`:** Idle scan. Pour les cas avec un firewall actif mais où l'on sait qu'il ne filtre pas vers une certaine IP (ou quand on veut simplement anonymat) on peut utiliser le zombie scanner (fonctionne pour tous les ports), pour chercher des zombies possibles on peut utiliser le script ipidseq ou l'exploit auxiliary/scanner/ip/ipidseq. Ce scanner se base sur le numéro IPID des paquets IP.
- **`--badsum`:** Envoie une somme incorrecte, les machines rejetteraient les paquets, mais les firewalls pourraient répondre quelque chose, utilisé pour détecter des firewalls.
- **`-sZ`:** Scanner SCTP "Weird", en envoyant des probes avec cookie echo fragments ils devraient être abandonnés si open ou répondre ABORT si closed. Peut passer des firewalls que init n'arrive pas à traverser, le défaut est qu'il ne distingue pas filtered et open.
- **`-sO`:** Scan de protocoles IP. Envoie des en-têtes malformés et vides où parfois on ne peut même pas distinguer le protocole. Si ICMP unreachable protocol arrive c'est closed, si unreachable port arrive c'est open, si une autre erreur arrive, filtered, si rien arrive, open|filtered.
- **`-b <server>`:** FTPhost --> Utilisé pour scanner un hôte depuis un autre : on se connecte au ftp d'une autre machine et on lui demande d'envoyer des fichiers vers les ports qu'on veut scanner depuis cette autre machine ; selon les réponses on saura si c'est open ou non. [\<user>:\<password>@]\<server>\[:\<port>] Presque tous les serveurs ftp ne permettent plus cela et c'est donc peu utile en pratique.

### Analyse ciblée

**-p:** Utilisé pour spécifier les ports à scanner. Pour sélectionner les 65 335 ports : **-p-** ou **-p all**. Nmap a une classification interne basée sur la popularité. Par défaut, il utilise les 1000 ports les plus courants. Avec **-F** (fast scan) il analyse les 100 premiers. Avec **--top-ports <number>** il analyse ce nombre de ports les plus courants (de 1 à 65 335). Il vérifie les ports dans un ordre aléatoire ; pour empêcher cela, utilisez **-r**. On peut aussi sélectionner des ports spécifiques : 20-30,80,443,1024- (ce dernier signifie à partir de 1024). On peut aussi grouper les ports par protocole : U:53,T:21-25,80,139,S:9. On peut aussi choisir une plage dans les ports populaires de Nmap : -p [-1024] analyse jusqu'au port 1024 parmi ceux inclus dans nmap-services. **--port-ratio <ratio>** Analyse les ports les plus communs selon un ratio entre 0 et 1

**-sV** Scan de version, l'intensité peut être réglée de 0 à 9, par défaut 7.

**--version-intensity <number>** On règle l'intensité, plus bas = n'enverra que les probes les plus probables, pas toutes. Avec cela, on peut réduire considérablement le temps des scans UDP

**-O** Détection d'OS

**--osscan-limit** Pour une bonne détection d'hôte, au moins un port open et un port closed sont nécessaires. Si cette condition n'est pas satisfaite et qu'on a activé cette option, il n'essaiera pas de prédire l'OS (gain de temps)

**--osscan-guess** Quand la détection d'OS n'est pas parfaite, force à essayer plus fort

**Scripts**

--script _<filename>_|_<category>_|_<directory>_|_<expression>_[,...]

Pour utiliser les scripts par défaut, utiliser -sC ou --script=default

Types disponibles : auth, broadcast, default, discovery, dos, exploit, external, fuzzer, intrusive, malware, safe, version, et vuln

- **Auth:** exécute tous les scripts d'authentification disponibles
- **Default:** exécute les scripts de base par défaut
- **Discovery:** récupère des informations depuis la cible ou la victime
- **External:** script pour utiliser des ressources externes
- **Intrusive:** utilise des scripts considérés intrusifs pour la victime ou la cible
- **Malware:** vérifie des connexions ouvertes par du code malveillant ou backdoors
- **Safe:** exécute des scripts non-intrusifs
- **Vuln:** découvre les vulnérabilités les plus connues
- **All:** exécute absolument tous les scripts d'extension NSE disponibles

Pour rechercher des scripts :

**nmap --script-help="http-\*" -> Ceux commençant par http-**

**nmap --script-help="not intrusive" -> Tous sauf ceux intrusifs**

**nmap --script-help="default or safe" -> Ceux dans l'un ou l'autre**

**nmap --script-help="default and safe" --> Ceux dans les deux**

**nmap --script-help="(default or safe or intrusive) and not http-\*"**

--script-args _<n1>_=_<v1>_,_<n2>_={_<n3>_=_<v3>_},_<n4>_={_<v4>_,_<v5>_}

--script-args-file _<filename>_

--script-help _<filename>_|_<category>_|_<directory>_|_<expression>_|all[,...]

--script-trace ---> Fournit des infos sur la progression du script

--script-updatedb

**Pour utiliser un script, tapez simplement : nmap --script Script_Name target** --> Lors de l'utilisation du script, le script et le scanner s'exécuteront, donc des options de scanner peuvent aussi être ajoutées. On peut ajouter **"safe=1"** pour n'exécuter que ceux sûrs.

**Contrôle du temps**

**Nmap accepte des durées en secondes, minutes, ms :** --host-timeout arguments 900000ms, 900, 900s, et 15m équivalent.

Nmap divise le nombre total d'hôtes à scanner en groupes et analyse ces groupes par blocs, il ne passe pas au bloc suivant tant que tous n'ont pas été analysés (et l'utilisateur ne reçoit aucune mise à jour tant que le bloc n'a pas été terminé). Ainsi, il est plus optimal pour Nmap d'utiliser de grands groupes. Par défaut en classe C, il utilise 256.

Cela peut être changé avec **--min-hostgroup** _**<numhosts>**_**;** **--max-hostgroup** _**<numhosts>**_ (Ajuste la taille des groupes de scan parallèles)

Vous pouvez contrôler le nombre de scanners parallèles mais mieux vaut ne pas le faire (Nmap incorpore déjà un contrôle automatique basé sur l'état du réseau) : **--min-parallelism** _**<numprobes>**_**;** **--max-parallelism** _**<numprobes>**_

On peut modifier le timeout RTT, mais ce n'est généralement pas nécessaire : **--min-rtt-timeout** _**<time>**_**,** **--max-rtt-timeout** _**<time>**_**,** **--initial-rtt-timeout** _**<time>**_

On peut modifier le nombre de tentatives : **--max-retries** _**<numtries>**_

On peut modifier le temps de scan d'un hôte : **--host-timeout** _**<time>**_

On peut modifier le délai entre chaque test pour ralentir : **--scan-delay** _**<time>**_**;** **--max-scan-delay** _**<time>**_

On peut modifier le nombre de paquets par seconde : **--min-rate** _**<number>**_**;** **--max-rate** _**<number>**_

Beaucoup de ports mettent beaucoup de temps à répondre lorsqu'ils sont filtered ou closed. Si on s'intéresse uniquement aux open, on peut accélérer avec : **--defeat-rst-ratelimit**

Pour définir l'agressivité de Nmap : -T paranoid|sneaky|polite|normal|aggressive|insane

-T (0-1)

-T0 --> Scanne 1 port à la fois et attend 5min avant le suivant

-T1 et T2 --> Très similaires mais attendent seulement 15s et 0.4s respectivement entre chaque test

-T3 --> Comportement par défaut, inclut le scanning parallèle

-T4 --> --max-rtt-timeout 1250ms --min-rtt-timeout 100ms --initial-rtt-timeout 500ms --max-retries 6 --max-scan-delay 10ms

-T5 --> --max-rtt-timeout 300ms --min-rtt-timeout 50ms --initial-rtt-timeout 250ms --max-retries 2 --host-timeout 15m --max-scan-delay 5ms

**Firewall/IDS**

Ils bloquent l'accès aux ports et analysent les paquets.

**-f** Pour fragmenter les paquets, par défaut les fragmente en 8bytes après l'en-tête, pour spécifier cette taille on utilise ..mtu (avec cela, ne pas utiliser -f), l'offset doit être multiple de 8. **Les version scanners et scripts ne supportent pas la fragmentation**

**-D decoy1,decoy2,ME** Nmap envoie les scans mais avec d'autres adresses IP comme origine, cela permet de vous masquer. Si vous mettez ME dans la liste, Nmap vous placera là, mieux vaut mettre 5 ou 6 IPs avant vous pour être totalement masqué. Des IPs aléatoires peuvent être générées avec RND:<number> pour générer <number> d'IPs aléatoires. Ils ne fonctionnent pas avec les détecteurs de version TCP sans connexion. Si vous êtes à l'intérieur d'un réseau, préférez utiliser des IPs actives, sinon il sera très facile de déterminer que vous êtes le seul actif.

Pour utiliser des IPs aléatoires : nmap -D RND:10 Target_IP

**-S IP** Pour quand Nmap ne capte pas votre IP, vous devez la fournir. Sert aussi à faire croire qu'une autre cible vous scanne.

**-e <interface>** Pour choisir l'interface

Beaucoup d'administrateurs laissent des ports d'entrée ouverts pour que tout fonctionne correctement et c'est plus simple que de trouver une autre solution. Ce peuvent être des ports DNS ou FTP... pour trouver cette vulnérabilité Nmap intègre : **--source-port** _**<portnumber>**_**;-g** _**<portnumber>**_ _Ils sont équivalents_

**--data** _**<hex string>**_ Pour envoyer du texte hexadécimal : --data 0xdeadbeef et --data \xCA\xFE\x09

**--data-string** _**<string>**_ Pour envoyer du texte normal : --data-string "Scan conducted by Security Ops, extension 7192"

**--data-length** _**<number>**_ Nmap n'envoie que les en-têtes, avec ceci on ajoute un nombre d'octets supplémentaires (générés aléatoirement)

Pour configurer complètement le paquet IP utilisez **--ip-options**

Si vous souhaitez voir les options dans les paquets envoyés et reçus, spécifiez --packet-trace. Pour plus d'infos et d'exemples d'utilisation des options IP avec Nmap, voir [http://seclists.org/nmap-dev/2006/q3/52](http://seclists.org/nmap-dev/2006/q3/52).

**--ttl** _**<value>**_

**--randomize-hosts** Pour rendre l'attaque moins évidente

**--spoof-mac** _**<MAC address, prefix, or vendor name>**_ Pour changer le MAC exemples : Apple, 0, 01:02:03:04:05:06, deadbeefcafe, 0020F2, et Cisco

**--proxies** _**<Comma-separated list of proxy URLs>**_ Pour utiliser des proxies, parfois un proxy ne maintient pas autant de connexions ouvertes que Nmap le souhaite donc il faudra modifier le parallélisme : --max-parallelism

**-sP** Pour découvrir des hôtes sur notre réseau via ARP

Beaucoup d'administrateurs créent une règle de firewall qui permet à tous les paquets venant d'un port particulier de passer (comme 20,53 et 67), on peut dire à Nmap d'envoyer nos paquets depuis ces ports : **nmap --source-port 53 IP**

**Sorties**

**-oN file** Sortie normale

**-oX file** Sortie XML

**-oS file** Script kiddies output

**-oG file** Sortie greppable

**-oA file** Tout sauf -oS

**-v level** verbosité

**-d level** débogage

**--reason** Raison de l'état de l'hôte

**--stats-every time** Toutes les x indique comment ça se passe

**--packet-trace** Pour voir quels paquets sortent, des filtres peuvent être spécifiés comme : --version-trace ou --script-trace

**--open** affiche open, open|filtered et unfiltered

**--resume file** Reprend un résumé

**Divers**

**-6** Active IPv6

**-A** équivaut à -O -sV -sC --traceroute

**Temps d'exécution**

Pendant que Nmap tourne on peut changer des options :

v / V Augmente / diminue le niveau de verbosité

d / D Augmente / diminue le niveau de débogage

p / P Active / désactive le packet tracing

? Affiche l'écran d'aide d'interaction runtime

**Vulscan**

Script Nmap qui examine les versions des services obtenues dans une base de données offline (téléchargée depuis d'autres sources importantes) et renvoie des vulnérabilités possibles

Les DBs utilisées :

1. Scipvuldb.csv | [http://www.scip.ch/en/?vuldb](http://www.scip.ch/en/?vuldb)
2. Cve.csv | [http://cve.mitre.org](http://cve.mitre.org/)
3. Osvdb.csv | [http://www.osvdb.org](http://www.osvdb.org/)
4. Securityfocus.csv | [http://www.securityfocus.com/bid/](http://www.securityfocus.com/bid/)
5. Securitytracker.csv | [http://www.securitytracker.com](http://www.securitytracker.com/)
6. Xforce.csv | [http://xforce.iss.net](http://xforce.iss.net/)
7. Exploitdb.csv | [http://www.exploit-db.com](http://www.exploit-db.com/)
8. Openvas.csv | [http://www.openvas.org](http://www.openvas.org/)

Pour télécharger et installer dans le dossier Nmap :

wget http://www.computec.ch/projekte/vulscan/download/nmap_nse_vulscan-2.0.tar.gz && tar -czvf nmap_nse_vulscan-2.0.tar.gz vulscan/ && sudo cp -r vulscan/ /usr/share/nmap/scripts/

Il faudra aussi télécharger les paquets DB et les ajouter dans /usr/share/nmap/scripts/vulscan/

Utilisation :

Pour tout utiliser : sudo nmap -sV --script=vulscan HOST_TO_SCAN

Pour utiliser une DB spécifique : sudo nmap -sV --script=vulscan --script-args vulscandb=cve.csv HOST_TO_SCAN

## Accélérer le service scan de Nmap x16

Selon [**this post**](https://joshua.hu/nmap-speedup-service-scanning-16x) vous pouvez accélérer l'analyse de service de nmap en modifiant toutes les valeurs **`totalwaitms`** dans **`/usr/share/nmap/nmap-service-probes`** à **300** et **`tcpwrappedms`** à **200**.

De plus, les probes qui n'ont pas de **`servicewaitms`** spécifiquement définis utilisent une valeur par défaut de **`5000`**. Par conséquent, on peut soit ajouter des valeurs à chaque probe, soit **compiler nmap** soi-même et changer la valeur par défaut dans [**service_scan.h**](https://github.com/nmap/nmap/blob/master/service_scan.h#L79).

Si vous ne voulez pas changer les valeurs de **`totalwaitms`** et **`tcpwrappedms`** dans le fichier `/usr/share/nmap/nmap-service-probes`, vous pouvez modifier le [parsing code](https://github.com/nmap/nmap/blob/master/service_scan.cc#L1358) de sorte que ces valeurs dans le fichier `nmap-service-probes` soient complètement ignorées.

## Construire un Nmap statique pour environnements restreints

Dans des environnements Linux durcis ou minimaux (containers, appliances), les binaires Nmap dynamiquement liés échouent souvent à cause de loaders runtime ou bibliothèques partagées manquants (ex : /lib64/ld-linux-x86-64.so.2, libc.so). Construire votre propre Nmap statique et empaqueter les données NSE permet d'exécuter sans installer de paquets système.

Approche globale
- Utiliser un builder Ubuntu amd64 propre via Docker.
- Construire OpenSSL et PCRE2 en bibliothèques statiques.
- Compiler Nmap en liant statiquement et en utilisant les libpcap/libdnet incluses pour éviter les dépendances dynamiques.
- Regrouper les scripts NSE et les répertoires de données avec le binaire.

Découvrir l'architecture cible (exemple)
```bash
uname -a
# If building from macOS/ARM/etc., pin the builder arch:
docker run --rm --platform=linux/amd64 -v "$(pwd)":/out -w /tmp ubuntu:22.04 bash -lc 'echo ok'
```
Étape 1 — Préparer la chaîne d'outils
```bash
set -euo pipefail
export DEBIAN_FRONTEND=noninteractive
apt-get update && apt-get install -y --no-install-recommends \
build-essential ca-certificates curl bzip2 xz-utils pkg-config perl python3 file git \
automake autoconf libtool m4 zlib1g-dev
```
Étape 2 — Construire OpenSSL statique (1.1.1w)
```bash
OSSL="1.1.1w"
curl -fsSLO "https://www.openssl.org/source/openssl-$OSSL.tar.gz"
tar xzf "openssl-$OSSL.tar.gz" && cd "openssl-$OSSL"
./Configure no-shared no-zlib linux-x86_64 -static --prefix=/opt/ossl
make -j"$(nproc)" && make install_sw
cd /tmp
```
Étape 3 — Construire PCRE2 statique (10.43)
```bash
PCRE2=10.43
curl -fsSLO "https://github.com/PCRE2Project/pcre2/releases/download/pcre2-$PCRE2/pcre2-$PCRE2.tar.bz2"
tar xjf "pcre2-$PCRE2.tar.bz2" && cd "pcre2-$PCRE2"
./configure --disable-shared --enable-static --prefix=/opt/pcre2
make -j"$(nproc)" && make install
cd /tmp
```
Étape 4 — Compiler Nmap statique (7.98)
```bash
NMAP=7.98
curl -fsSLO "https://nmap.org/dist/nmap-$NMAP.tar.bz2"
tar xjf "nmap-$NMAP.tar.bz2" && cd "nmap-$NMAP"
export CPPFLAGS="-I/opt/ossl/include -I/opt/pcre2/include"
export LDFLAGS="-L/opt/ossl/lib -L/opt/pcre2/lib -static -static-libstdc++ -static-libgcc"
export LIBS="-lpcre2-8 -ldl -lpthread -lz"
./configure \
--with-openssl=/opt/ossl \
--with-libpcre=/opt/pcre2 \
--with-libpcap=included \
--with-libdnet=included \
--without-zenmap --without-ndiff --without-nmap-update
# Avoid building shared libpcap by accident
sed -i -e "s/^shared: /shared: #/" libpcap/Makefile || true
make -j1 V=1 nmap
strip nmap
```
Points clés
- -static, -static-libstdc++, -static-libgcc forcent la liaison statique.
- L'utilisation de --with-libpcap=included/--with-libdnet=included évite les bibliothèques partagées du système.
- sed tweak désactive une cible libpcap partagée si elle est présente.

Étape 5 — Regrouper le binaire et les données NSE
```bash
mkdir -p /out/nmap-bundle/nmap-data
cp nmap /out/nmap-bundle/nmap-linux-amd64-static
cp -r scripts nselib /out/nmap-bundle/nmap-data/
cp nse_main.lua nmap-services nmap-protocols nmap-service-probes \
nmap-mac-prefixes nmap-os-db nmap-payloads nmap-rpc \
/out/nmap-bundle/nmap-data/ 2>/dev/null || true

tar -C /out -czf /out/nmap-linux-amd64-static-bundle.tar.gz nmap-bundle
```
Notes de vérification et d'opérations
- Utilisez file sur l'artefact pour confirmer qu'il est lié statiquement.
- Conservez les données NSE avec le binaire pour garantir la parité des scripts sur les hôtes sans Nmap installé.
- Même avec un binaire statique, l'exécution peut être bloquée par AppArmor/seccomp/SELinux ; DNS/egress doivent toujours fonctionner.
- Les builds déterministes réduisent le risque de la chaîne d'approvisionnement par rapport au téléchargement de binaires « statiques » opaques.

One-liner (Dockerized)
<details>
<summary>Construire, empaqueter et afficher les infos de l'artefact</summary>
```bash
docker run --rm --platform=linux/amd64 -v "$(pwd)":/out -w /tmp ubuntu:22.04 bash -lc '
set -euo pipefail
export DEBIAN_FRONTEND=noninteractive
apt-get update && apt-get install -y --no-install-recommends \
build-essential ca-certificates curl bzip2 xz-utils pkg-config perl python3 file git \
automake autoconf libtool m4 zlib1g-dev

OSSL="1.1.1w"; curl -fsSLO "https://www.openssl.org/source/openssl-$OSSL.tar.gz" \
&& tar xzf "openssl-$OSSL.tar.gz" && cd "openssl-$OSSL" \
&& ./Configure no-shared no-zlib linux-x86_64 -static --prefix=/opt/ossl \
&& make -j"$(nproc)" && make install_sw && cd /tmp

PCRE2=10.43; curl -fsSLO "https://github.com/PCRE2Project/pcre2/releases/download/pcre2-$PCRE2/pcre2-$PCRE2.tar.bz2" \
&& tar xjf "pcre2-$PCRE2.tar.bz2" && cd "pcre2-$PCRE2" \
&& ./configure --disable-shared --enable-static --prefix=/opt/pcre2 \
&& make -j"$(nproc)" && make install && cd /tmp

NMAP=7.98; curl -fsSLO "https://nmap.org/dist/nmap-$NMAP.tar.bz2" \
&& tar xjf "nmap-$NMAP.tar.bz2" && cd "nmap-$NMAP" \
&& export CPPFLAGS="-I/opt/ossl/include -I/opt/pcre2/include" \
&& export LDFLAGS="-L/opt/ossl/lib -L/opt/pcre2/lib -static -static-libstdc++ -static-libgcc" \
&& export LIBS="-lpcre2-8 -ldl -lpthread -lz" \
&& ./configure --with-openssl=/opt/ossl --with-libpcre=/opt/pcre2 --with-libpcap=included --with-libdnet=included --without-zenmap --without-ndiff --without-nmap-update \
&& sed -i -e "s/^shared: /shared: #/" libpcap/Makefile || true \
&& make -j1 V=1 nmap && strip nmap

mkdir -p /out/nmap-bundle/nmap-data \
&& cp nmap /out/nmap-bundle/nmap-linux-amd64-static \
&& cp -r scripts nselib /out/nmap-bundle/nmap-data/ \
&& cp nse_main.lua nmap-services nmap-protocols nmap-service-probes nmap-mac-prefixes nmap-os-db nmap-payloads nmap-rpc /out/nmap-bundle/nmap-data/ 2>/dev/null || true \
&& tar -C /out -czf /out/nmap-linux-amd64-static-bundle.tar.gz nmap-bundle \
&& echo "===== OUTPUT ====="; ls -lah /out; echo "===== FILE TYPE ====="; file /out/nmap-bundle/nmap-linux-amd64-static || true
'
```
</details>

## Références

- [Compiling static Nmap binary for jobs in restricted environments](https://www.pentestpartners.com/security-blog/compiling-static-nmap-binary-for-jobs-in-restricted-environments/)
- [Static Nmap Binary Generator (helper tool)](https://github.com/0x5ubt13/static_nmap_binary_generator)
- [OpenSSL sources](https://www.openssl.org/source/)
- [PCRE2 releases](https://github.com/PCRE2Project/pcre2/releases)
- [Nmap source tarballs](https://nmap.org/dist/)


{{#include ../../banners/hacktricks-training.md}}
