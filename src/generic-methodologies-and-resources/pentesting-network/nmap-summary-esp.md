# Nmap Zusammenfassung (ESP)

{{#include ../../banners/hacktricks-training.md}}
```
nmap -sV -sC -O -n -oA nmapscan 192.168.0.1/24
```
## Parameter

### IPs zum Scannen

- **`<ip>,<net/mask>`:** Gib die IPs direkt an
- **`-iL <ips_file>`:** list_IPs
- **`-iR <number>`**: Anzahl zufälliger IPs, du kannst mögliche IPs mit `--exclude <Ips>` oder `--excludefile <file>` ausschließen.

### Geräteerkennung

Standardmäßig startet Nmap eine discovery phase bestehend aus: `-PA80 -PS443 -PE -PP`

- **`-sL`**: Nicht invasiv, listet die Ziele und macht **DNS**-Anfragen, um Namen aufzulösen. Nützlich, um z.B. zu wissen, ob bei www.prueba.es/24 alle IPs unsere Ziele sind.
- **`-Pn`**: **No ping**. Nützlich, wenn du weißt, dass alle aktiv sind (ansonsten kann viel Zeit verloren gehen; diese Option erzeugt aber auch False Negatives und sagt, dass sie nicht aktiv sind). Verhindert die discovery phase.
- **`-sn`** : **No port scan**. Nach Abschluss der reconnaissance phase werden keine Ports gescannt. Relativ stealthy und erlaubt einen kleinen Netzwerkscan. Mit Privilegien sendet es einen ACK (-PA) an 80, einen SYN (-PS) an 443 und ein Echo-Request sowie ein Timestamp-Request; ohne Privilegien werden immer Verbindungen komplett aufgebaut. Wenn das Ziel das Netzwerk ist, verwendet es nur ARP (-PR). Wird es mit einer anderen Option kombiniert, werden nur die Pakete der anderen Option verworfen.
- **`-PR`**: **Ping ARP**. Wird standardmäßig beim Analysieren von Rechnern im eigenen Netzwerk verwendet; ist schneller als pings. Wenn du keine ARP-Pakete nutzen willst, verwende `--send-ip`.
- **`-PS <ports>`**: Sendet SYN-Pakete; antwortet das Ziel mit SYN/ACK ist der Port open (es antwortet mit RST, um die Verbindung nicht zu beenden), antwortet es mit RST ist er closed, antwortet es nicht ist er unreachable. Ohne Privilegien wird automatisch eine vollständige Verbindung verwendet. Wenn keine Ports angegeben sind, wird 80 verwendet.
- **`-PA <ports>`**: Wie oben, aber mit ACK; die Kombination beider Optionen liefert bessere Ergebnisse.
- **`-PU <ports>`**: Ziel ist das Gegenteil — diese werden an Ports geschickt, die voraussichtlich closed sind. Manche Firewalls prüfen nur TCP-Verbindungen. Bei closed kommt eine port unreachable, bei anderen ICMP-Antworten oder keiner Antwort bleibt es als destination unreachable.
- **`-PE, -PP, -PM`** : ICMP PINGS: echo reply, timestamp und addressmask. Werden verwendet, um zu überprüfen, ob das Ziel aktiv ist.
- **`-PY<ports>`**: Sendet SCTP INIT-Probes standardmäßig an 80; INIT-ACK (open) oder ABORT (closed) oder nichts bzw. ICMP unreachable (inactive) können geantwortet werden.
- **`-PO <protocols>`**: Ein Protokoll wird in den Headern angegeben, standardmäßig 1(ICMP), 2(IGMP) und 4(Encap IP). Für ICMP, IGMP, TCP (6) und UDP (17) werden die Protokoll-Header gesendet, für den Rest nur der IP-Header. Ziel ist, dass aufgrund von fehlerhaften Headern Protocol unreachable oder Antworten desselben Protokolls zurückkommen, um zu erkennen, ob es up ist.
- **`-n`**: No DNS
- **`-R`**: DNS always

### Port-Scanning-Techniken

- **`-sS`**: Vervollständigt die Verbindung nicht, hinterlässt daher keine Spuren — sehr gut, wenn verwendbar (Privilegien). Standardmäßig verwendet.
- **`-sT`**: Vervollständigt die Verbindung, hinterlässt Spuren, kann aber sicher genutzt werden. Standardmäßig ohne Privilegien.
- **`-sU`**: Langsamer, für UDP. Häufig: DNS(53), SNMP(161,162), DHCP(67 und 68), (-sU53,161,162,67,68): open(reply), closed(port unreachable), filtered (anderes ICMP), open/filtered (keine Antwort). Bei open/filtered sendet -sV zahlreiche Anfragen, um eine der von nmap unterstützten Versionen zu erkennen; erhöht deutlich die Laufzeit.
- **`-sY`**: SCTP-Scan, scheitert bei Verbindungsaufbau, daher keine Logs; funktioniert ähnlich wie -PY
- **`-sN,-sX,-sF`**: Null, Fin, Xmas — können manche Firewalls umgehen und Informationen extrahieren. Basieren auf dem Verhalten, dass standardkonforme Maschinen auf alle Anfragen ohne SYN, RST oder ACK mit RST antworten sollten: open/filtered (keine Antwort), closed (RST), filtered (ICMP unreachable). Unzuverlässig auf Windows, Cisco, BSDI und OS/400. Auf Unix ja.
- **`-sM`**: Maimon-Scan: Sendet FIN und ACK Flags, ursprünglich für BSD; aktuell meldet es oft alle Ports als closed.
- **`-sA, sW`**: ACK und Window — wird verwendet, um Firewalls zu erkennen, um zu wissen, ob Ports gefiltert sind. -sW unterscheidet open/closed anhand unterschiedlicher window-Werte: open (RST mit window != 0), closed (RST window = 0), filtered (ICMP unreachable oder keine Antwort). Nicht alle Hosts verhalten sich so; wenn alles closed angezeigt wird, funktioniert die Methode nicht; bei wenigen open funktioniert sie gut; bei vielen open und wenigen closed läuft sie umgekehrt.
- **`-sI`**: Idle scan. Wenn eine aktive Firewall existiert, aber wir wissen, dass sie zu einer bestimmten IP nicht filtert (oder wenn wir Anonymität wollen), kann der zombie scanner verwendet werden (funktioniert für alle Ports). Um mögliche Zombies zu finden, kann das scrpit ipidseq oder das exploit auxiliary/scanner/ip/ipidseq genutzt werden. Dieser Scanner basiert auf der IPID-Nummer der IP-Pakete.
- **`--badsum`:** Sendet eine falsche Prüfsumme; Hosts würden die Pakete verwerfen, aber Firewalls könnten etwas antworten — wird genutzt, um Firewalls zu detektieren.
- **`-sZ`:** "Weird" SCTP-Scanner: Beim Senden von Probes mit cookie echo fragments sollten diese bei open verworfen werden oder bei closed mit ABORT beantwortet werden. Kann Firewalls passieren, die INIT nicht passieren lassen; Nachteil: unterscheidet nicht zwischen filtered und open.
- **`-sO`:** Protocol IP-Scan. Sendet fehlerhafte bzw. leere Header, in denen manchmal nicht einmal das Protokoll unterschieden werden kann. Kommt ICMP protocol unreachable an, ist es closed; kommt unreachable port an, ist es open; kommt ein anderer Fehler, ist es filtered; kommt nichts an, ist es open|filtered.
- **`-b <server>`:** FTPhost --> Wird verwendet, um einen Host von einem anderen aus zu scannen: Man verbindet sich mit dem FTP eines anderen Rechners und bittet ihn, Dateien an die Ports zu senden, die man von dort aus scannen möchte; anhand der Antworten weiß man, ob sie open sind. [\<user>:\<password>@]\<server>\[:\<port>] Fast alle FTP-Server erlauben das heute nicht mehr, daher nur begrenzter praktischer Nutzen.

### Fokus-Analyse

**-p:** Wird benutzt, um Ports zum Scannen anzugeben. Um alle 65.535 Ports auszuwählen: **-p-** oder **-p all**. Nmap hat eine interne Klassifikation basierend auf Popularität. Standardmäßig werden die Top 1000 Ports verwendet. Mit **-F** (fast scan) werden die Top 100 analysiert. Mit **--top-ports <number>** werden die angegebenen Top-Ports (von 1 bis 65.535) analysiert. Ports werden in zufälliger Reihenfolge geprüft; um das zu verhindern, nutze **-r**. Du kannst auch spezifische Ports wählen: 20-30,80,443,1024- (letzteres bedeutet ab 1024). Ports können nach Protokollen gruppiert werden: U:53,T:21-25,80,139,S:9. Auch ein Bereich innerhalb der nmap-popular-Ports ist möglich: -p [-1024] analysiert bis Port 1024 aus denen in nmap-services. **--port-ratio <ratio>** Analysiert die gebräuchlichsten Ports innerhalb eines Verhältnisses zwischen 0 und 1

**-sV** Version scanning; Intensität kann von 0 bis 9 geregelt werden, Standard ist 7.

**--version-intensity <number>** Regelt die Intensität; je niedriger der Wert, desto weniger (nur die wahrscheinlichsten) Probes werden gesendet. Damit lässt sich besonders bei UDP-Scans die Laufzeit deutlich verkürzen.

**-O** OS detection

**--osscan-limit** Für ein sinnvolles Host-Scanning werden mindestens ein open Port und ein closed Port benötigt. Wenn diese Bedingung nicht erfüllt ist und diese Option gesetzt wurde, wird keine OS-Vorhersage versucht (spart Zeit).

**--osscan-guess** Wenn OS detection nicht perfekt ist, versucht diese Option stärker zu raten.

Scripts

--script _<filename>_|_<category>_|_<directory>_|_<expression>_[,...]

Um default scripts zu verwenden, nutze -sC oder --script=default

Verfügbare Typen sind: auth, broadcast, default, discovery, dos, exploit, external, fuzzer, intrusive, malware, safe, version, und vuln

- **Auth:** führt alle verfügbaren authentication scripts aus
- **Default:** führt grundlegende default tool scripts aus
- **Discovery:** ruft Informationen vom Ziel oder Opfer ab
- **External:** Script zur Nutzung externer Ressourcen
- **Intrusive:** verwendet Scripts, die als intrusive gegenüber dem Opfer/Ziel gelten
- **Malware:** prüft auf Verbindungen, die von Malware oder Backdoors geöffnet wurden
- **Safe:** führt nicht-intrusive Scripts aus
- **Vuln:** entdeckt die bekanntesten vulnerabilities
- **All:** führt absolut alle verfügbaren NSE extension scripts aus

Um nach Scripts zu suchen:

**nmap --script-help="http-\*" -> Those starting with http-**

**nmap --script-help="not intrusive" -> All except those**

**nmap --script-help="default or safe" -> Those in either or both**

**nmap --script-help="default and safe" --> Those in both**

**nmap --script-help="(default or safe or intrusive) and not http-\*"**

--script-args _<n1>_=_<v1>_,_<n2>_={_<n3>_=_<v3>_},_<n4>_={_<v4>_,_<v5>_}

--script-args-file _<filename>_

--script-help _<filename>_|_<category>_|_<directory>_|_<expression>_|all[,...]

--script-trace ---> Liefert Infos darüber, wie das Script voranschreitet

--script-updatedb

**Um ein Script zu verwenden, einfach eingeben: nmap --script Script_Name target** --> Beim Ausführen eines Scripts laufen sowohl das Script als auch der Scanner, daher können auch Scanner-Optionen hinzugefügt werden. Wir können **"safe=1"** ergänzen, um nur sichere Scripts auszuführen.

Time Control

**Nmap kann Zeiten in Sekunden, Minuten, ms ändern:** --host-timeout Argumente 900000ms, 900, 900s und 15m sind äquivalent.

Nmap teilt die Gesamtanzahl der zu scannenden Hosts in Gruppen auf und analysiert diese Gruppen in Blöcken; es wechselt nicht zum nächsten Block, bis alle Hosts des aktuellen Blocks analysiert sind (und der Nutzer bis dahin keine Updates erhält). So ist es für Nmap optimal, große Gruppen zu verwenden. Standardmäßig in einem Class-C werden 256 Hosts verwendet.

Dies kann mit **--min-hostgroup** _**<numhosts>**_**;** **--max-hostgroup** _**<numhosts>**_ verändert werden (passt die Größe paralleler Scan-Gruppen an)

Du kannst die Anzahl paralleler Scanner steuern, es ist aber oft besser, dies Nmap zu überlassen (Nmap regelt automatisch basierend auf Netzwerkstatus): **--min-parallelism** _**<numprobes>**_**;** **--max-parallelism** _**<numprobes>**_

Man kann das RTT-Timeout verändern, ist meist aber nicht nötig: **--min-rtt-timeout** _**<time>**_**,** **--max-rtt-timeout** _**<time>**_**,** **--initial-rtt-timeout** _**<time>**_

Anzahl der Versuche anpassen: **--max-retries** _**<numtries>**_

Scanzeit eines Hosts anpassen: **--host-timeout** _**<time>**_

Zeit zwischen Tests vergrößern, um langsamer zu scannen: **--scan-delay** _**<time>**_**;** **--max-scan-delay** _**<time>**_

Pakete pro Sekunde anpassen: **--min-rate** _**<number>**_**;** **--max-rate** _**<number>**_

Viele Ports brauchen lange, wenn sie gefiltert oder geschlossen sind. Wenn nur open interessiert, kann man schneller sein mit: **--defeat-rst-ratelimit**

Um die Aggressivität von Nmap zu definieren: -T paranoid|sneaky|polite|normal|aggressive|insane

-T (0-1)

-T0 --> Scannt jeweils nur 1 Port und wartet 5min bis zum nächsten

-T1 und T2 --> Sehr ähnlich, warten nur 15 bzw. 0.4s zwischen Tests

-T3 --> Standardbetrieb, inklusive parallelem Scannen

-T4 --> --max-rtt-timeout 1250ms --min-rtt-timeout 100ms --initial-rtt-timeout 500ms --max-retries 6 --max-scan-delay 10ms

-T5 --> --max-rtt-timeout 300ms --min-rtt-timeout 50ms --initial-rtt-timeout 250ms --max-retries 2 --host-timeout 15m --max-scan-delay 5ms

Firewall/IDS

Sie erlauben keine Zugriffe auf Ports und analysieren Pakete.

**-f** Fragmentiert Pakete; standardmäßig in 8-Byte-Fragmente nach dem Header. Um diese Größe zu spezifizieren, nutzen wir ..mtu (bei diesem Verfahren nicht -f verwenden); der Offset muss ein Vielfaches von 8 sein. **Version scanners und scripts unterstützen Fragmentation nicht**

**-D decoy1,decoy2,ME** Nmap sendet Scans, nutzt aber andere IP-Adressen als Ursprung, um dich zu verschleiern. Wenn du ME in die Liste aufnimmst, platziert dich Nmap dort — besser sind 5 oder 6 Einträge vor dir, um dich komplett zu maskieren. Zufällige IPs können mit RND:<number> erzeugt werden. Sie funktionieren nicht mit TCP version detectors ohne Verbindung. Wenn du im internen Netzwerk bist, interessieren dich aktive IPs; sonst ist leicht zu erkennen, dass nur du aktiv bist.

Um zufällige IPs zu nutzen: nmap -D RND:10 Target_IP

**-S IP** Für Fälle, in denen Nmap deine IP nicht korrekt erkennt; du kannst sie angeben. Nützlich, um den Eindruck zu erwecken, ein anderer Host scanne.

**-e <interface>** Um das Interface auszuwählen

Viele Administratoren lassen Ein- oder Ausgangsports offen, damit Dienste funktionieren; das ist für sie oft einfacher als komplexe Regeln. Das können z.B. DNS- oder FTP-Ports sein. Um diese Schwachstelle zu finden, bietet Nmap: **--source-port** _**<portnumber>**_**;-g** _**<portnumber>**_ _Sie sind äquivalent_

**--data** _**<hex string>**_ Um hexadezimale Daten zu senden: --data 0xdeadbeef und --data \xCA\xFE\x09

**--data-string** _**<string>**_ Um normalen Text zu senden: --data-string "Scan conducted by Security Ops, extension 7192"

**--data-length** _**<number>**_ Nmap sendet standardmäßig nur Header; mit dieser Option werden zusätzliche Bytes (zufällig generiert) angehängt.

Um das IP-Paket komplett zu konfigurieren, nutze **--ip-options**

Wenn du die Optionen in gesendeten und empfangenen Paketen sehen willst, gib --packet-trace an. Für mehr Infos und Beispiele zur Nutzung von IP-Options mit Nmap siehe [http://seclists.org/nmap-dev/2006/q3/52](http://seclists.org/nmap-dev/2006/q3/52).

**--ttl** _**<value>**_

**--randomize-hosts** Macht den Angriff weniger offensichtlich

**--spoof-mac** _**<MAC address, prefix, or vendor name>**_ Beispielwerte: Apple, 0, 01:02:03:04:05:06, deadbeefcafe, 0020F2, Cisco

**--proxies** _**<Comma-separated list of proxy URLs>**_ Um Proxies zu verwenden; manche Proxies halten nicht so viele offene Verbindungen wie Nmap benötigt, daher müsste ggf. --max-parallelism angepasst werden

**-sP** Um Hosts im eigenen Netzwerk per ARP zu entdecken

Viele Admins erstellen Firewall-Regeln, die alle Pakete von einem bestimmten Source-Port passieren lassen (z.B. 20,53,67). Wir können Nmap anweisen, Pakete von diesen Ports zu senden: **nmap --source-port 53 IP**

Outputs

**-oN file** Normal output

**-oX file** XML output

**-oS file** Script kiddies output

**-oG file** Greppable output

**-oA file** All except -oS

**-v level** verbosity

**-d level** debugging

**--reason** Grund für Host- und State-Angaben

**--stats-every time** Gibt alle x Zeit eine Statusmeldung

**--packet-trace** Zeigt welche Pakete rausgehen; Filter sind möglich, z.B.: --version-trace oder --script-trace

**--open** zeigt open, open|filtered und unfiltered

**--resume file** Gibt eine Zusammenfassung aus

Verschiedenes

**-6** Erlaubt IPv6

**-A** entspricht -O -sV -sC --traceroute

Laufzeit-Interaktion

Während Nmap läuft, können Optionen angepasst werden:

v / V Erhöhe / verringere Verbosity-Level

d / D Erhöhe / verringere Debug-Level

p / P Schalte Packet Tracing an / aus

? Zeigt eine Laufzeit-Hilfe an

Vulscan

Nmap-Script, das Versionsinformationen von Services gegen eine Offline-Datenbank (aus anderen Quellen) prüft und mögliche Vulnerabilities zurückmeldet

Die verwendeten DBs sind:

1. Scipvuldb.csv | [http://www.scip.ch/en/?vuldb](http://www.scip.ch/en/?vuldb)
2. Cve.csv | [http://cve.mitre.org](http://cve.mitre.org/)
3. Osvdb.csv | [http://www.osvdb.org](http://www.osvdb.org/)
4. Securityfocus.csv | [http://www.securityfocus.com/bid/](http://www.securityfocus.com/bid/)
5. Securitytracker.csv | [http://www.securitytracker.com](http://www.securitytracker.com/)
6. Xforce.csv | [http://xforce.iss.net](http://xforce.iss.net/)
7. Exploitdb.csv | [http://www.exploit-db.com](http://www.exploit-db.com/)
8. Openvas.csv | [http://www.openvas.org](http://www.openvas.org/)

Um in den Nmap-Ordner herunterzuladen und zu installieren:

wget http://www.computec.ch/projekte/vulscan/download/nmap_nse_vulscan-2.0.tar.gz && tar -czvf nmap_nse_vulscan-2.0.tar.gz vulscan/ && sudo cp -r vulscan/ /usr/share/nmap/scripts/

Du musst außerdem die DB-Pakete herunterladen und nach /usr/share/nmap/scripts/vulscan/ hinzufügen.

Usage:

To use all: sudo nmap -sV --script=vulscan HOST_TO_SCAN

To use a specific DB: sudo nmap -sV --script=vulscan --script-args vulscandb=cve.csv HOST_TO_SCAN

## Nmap Service scan x16 beschleunigen

Laut [**diesem Post**](https://joshua.hu/nmap-speedup-service-scanning-16x) kannst du die nmap service analysis beschleunigen, indem du alle **`totalwaitms`**-Werte in **`/usr/share/nmap/nmap-service-probes`** auf **300** und **`tcpwrappedms`** auf **200** setzt.

Außerdem verwenden Probes, die keinen spezifischen **`servicewaitms`** definiert haben, einen Default-Wert von **`5000`**. Daher kannst du entweder für jeden Probe einen Wert hinzufügen oder **nmap selbst kompilieren** und den Default-Wert in [**service_scan.h**](https://github.com/nmap/nmap/blob/master/service_scan.h#L79) ändern.

Wenn du die Werte **`totalwaitms`** und **`tcpwrappedms`** in der Datei `/usr/share/nmap/nmap-service-probes` gar nicht ändern möchtest, kannst du den [parsing code](https://github.com/nmap/nmap/blob/master/service_scan.cc#L1358) so editieren, dass diese Werte in der `nmap-service-probes`-Datei komplett ignoriert werden.

## Statisches Nmap für eingeschränkte Umgebungen bauen

In gehärteten oder minimalen Linux-Umgebungen (Container, Appliances) schlagen dynamisch gelinkte Nmap-Binaries oft fehl, weil runtime loader oder shared libraries fehlen (z.B. /lib64/ld-linux-x86-64.so.2, libc.so). Ein statisch gelinktes Nmap selbst zu bauen und NSE-Daten mitzuliefern erlaubt die Ausführung ohne Systempakete zu installieren.

High-level Vorgehen
- Verwende einen sauberen amd64 Ubuntu-Builder via Docker.
- Baue OpenSSL und PCRE2 als statische Libraries.
- Baue Nmap statisch gelinkt und nutze das mitgelieferte libpcap/libdnet, um dynamische Abhängigkeiten zu vermeiden.
- Bündle NSE-Scripts und Data-Directories mit dem Binary.

Ziel-Architektur herausfinden (Beispiel)
```bash
uname -a
# If building from macOS/ARM/etc., pin the builder arch:
docker run --rm --platform=linux/amd64 -v "$(pwd)":/out -w /tmp ubuntu:22.04 bash -lc 'echo ok'
```
Schritt 1 — Toolchain vorbereiten
```bash
set -euo pipefail
export DEBIAN_FRONTEND=noninteractive
apt-get update && apt-get install -y --no-install-recommends \
build-essential ca-certificates curl bzip2 xz-utils pkg-config perl python3 file git \
automake autoconf libtool m4 zlib1g-dev
```
Schritt 2 — Statisches OpenSSL (1.1.1w) bauen
```bash
OSSL="1.1.1w"
curl -fsSLO "https://www.openssl.org/source/openssl-$OSSL.tar.gz"
tar xzf "openssl-$OSSL.tar.gz" && cd "openssl-$OSSL"
./Configure no-shared no-zlib linux-x86_64 -static --prefix=/opt/ossl
make -j"$(nproc)" && make install_sw
cd /tmp
```
Schritt 3 — PCRE2 (10.43) statisch bauen
```bash
PCRE2=10.43
curl -fsSLO "https://github.com/PCRE2Project/pcre2/releases/download/pcre2-$PCRE2/pcre2-$PCRE2.tar.bz2"
tar xjf "pcre2-$PCRE2.tar.bz2" && cd "pcre2-$PCRE2"
./configure --disable-shared --enable-static --prefix=/opt/pcre2
make -j"$(nproc)" && make install
cd /tmp
```
Schritt 4 — Statisches Nmap kompilieren (7.98)
```bash
NMAP=7.98
curl -fsSLO "https://nmap.org/dist/nmap-$NMAP.tar.bz2"
tar xjf "nmap-$NMAP.tar.bz2" && cd "nmap-$NMAP"
export CPPFLAGS="-I/opt/ossl/include -I/opt/pcre2/include"
export LDFLAGS="-L/opt/ossl/lib -L/opt/pcre2/lib -static -static-libstdc++ -static-libgcc"
export LIBS="-lpcre2-8 -ldl -lpthread -lz"
./configure \
--with-openssl=/opt/ossl \
--with-libpcre=/opt/pcre2 \
--with-libpcap=included \
--with-libdnet=included \
--without-zenmap --without-ndiff --without-nmap-update
# Avoid building shared libpcap by accident
sed -i -e "s/^shared: /shared: #/" libpcap/Makefile || true
make -j1 V=1 nmap
strip nmap
```
Wichtige Punkte
- -static, -static-libstdc++, -static-libgcc erzwingen statisches Linken.
- Die Verwendung von --with-libpcap=included/--with-libdnet=included vermeidet systemweite Shared-Libs.
- sed-Anpassung deaktiviert ein vorhandenes shared libpcap-Ziel.

Schritt 5 — Binärdatei und NSE-Daten bündeln
```bash
mkdir -p /out/nmap-bundle/nmap-data
cp nmap /out/nmap-bundle/nmap-linux-amd64-static
cp -r scripts nselib /out/nmap-bundle/nmap-data/
cp nse_main.lua nmap-services nmap-protocols nmap-service-probes \
nmap-mac-prefixes nmap-os-db nmap-payloads nmap-rpc \
/out/nmap-bundle/nmap-data/ 2>/dev/null || true

tar -C /out -czf /out/nmap-linux-amd64-static-bundle.tar.gz nmap-bundle
```
Verifikation und Ops-Notizen
- Verwende file auf dem Artefakt, um zu bestätigen, dass es statically linked ist.
- Bewahre NSE-Daten zusammen mit dem binary auf, um Script-Parität auf Hosts ohne Nmap sicherzustellen.
- Selbst mit einem static binary kann die Ausführung durch AppArmor/seccomp/SELinux blockiert werden; DNS/egress muss weiterhin funktionieren.
- Deterministic builds reduzieren das Supply-Chain-Risiko gegenüber dem Herunterladen undurchsichtiger “static” binaries.

One-liner (Dockerized)
<details>
<summary>Build, bundle und Artefakt-Informationen ausgeben</summary>
```bash
docker run --rm --platform=linux/amd64 -v "$(pwd)":/out -w /tmp ubuntu:22.04 bash -lc '
set -euo pipefail
export DEBIAN_FRONTEND=noninteractive
apt-get update && apt-get install -y --no-install-recommends \
build-essential ca-certificates curl bzip2 xz-utils pkg-config perl python3 file git \
automake autoconf libtool m4 zlib1g-dev

OSSL="1.1.1w"; curl -fsSLO "https://www.openssl.org/source/openssl-$OSSL.tar.gz" \
&& tar xzf "openssl-$OSSL.tar.gz" && cd "openssl-$OSSL" \
&& ./Configure no-shared no-zlib linux-x86_64 -static --prefix=/opt/ossl \
&& make -j"$(nproc)" && make install_sw && cd /tmp

PCRE2=10.43; curl -fsSLO "https://github.com/PCRE2Project/pcre2/releases/download/pcre2-$PCRE2/pcre2-$PCRE2.tar.bz2" \
&& tar xjf "pcre2-$PCRE2.tar.bz2" && cd "pcre2-$PCRE2" \
&& ./configure --disable-shared --enable-static --prefix=/opt/pcre2 \
&& make -j"$(nproc)" && make install && cd /tmp

NMAP=7.98; curl -fsSLO "https://nmap.org/dist/nmap-$NMAP.tar.bz2" \
&& tar xjf "nmap-$NMAP.tar.bz2" && cd "nmap-$NMAP" \
&& export CPPFLAGS="-I/opt/ossl/include -I/opt/pcre2/include" \
&& export LDFLAGS="-L/opt/ossl/lib -L/opt/pcre2/lib -static -static-libstdc++ -static-libgcc" \
&& export LIBS="-lpcre2-8 -ldl -lpthread -lz" \
&& ./configure --with-openssl=/opt/ossl --with-libpcre=/opt/pcre2 --with-libpcap=included --with-libdnet=included --without-zenmap --without-ndiff --without-nmap-update \
&& sed -i -e "s/^shared: /shared: #/" libpcap/Makefile || true \
&& make -j1 V=1 nmap && strip nmap

mkdir -p /out/nmap-bundle/nmap-data \
&& cp nmap /out/nmap-bundle/nmap-linux-amd64-static \
&& cp -r scripts nselib /out/nmap-bundle/nmap-data/ \
&& cp nse_main.lua nmap-services nmap-protocols nmap-service-probes nmap-mac-prefixes nmap-os-db nmap-payloads nmap-rpc /out/nmap-bundle/nmap-data/ 2>/dev/null || true \
&& tar -C /out -czf /out/nmap-linux-amd64-static-bundle.tar.gz nmap-bundle \
&& echo "===== OUTPUT ====="; ls -lah /out; echo "===== FILE TYPE ====="; file /out/nmap-bundle/nmap-linux-amd64-static || true
'
```
</details>

## Quellen

- [Compiling static Nmap binary for jobs in restricted environments](https://www.pentestpartners.com/security-blog/compiling-static-nmap-binary-for-jobs-in-restricted-environments/)
- [Static Nmap Binary Generator (helper tool)](https://github.com/0x5ubt13/static_nmap_binary_generator)
- [OpenSSL sources](https://www.openssl.org/source/)
- [PCRE2 releases](https://github.com/PCRE2Project/pcre2/releases)
- [Nmap source tarballs](https://nmap.org/dist/)


{{#include ../../banners/hacktricks-training.md}}
