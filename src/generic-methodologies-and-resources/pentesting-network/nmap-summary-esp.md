# Nmap 요약 (ESP)

{{#include ../../banners/hacktricks-training.md}}
```
nmap -sV -sC -O -n -oA nmapscan 192.168.0.1/24
```
## Parameters

### IPs to scan

- **`<ip>,<net/mask>`:** IP를 직접 지정
- **`-iL <ips_file>`:** list_IPs
- **`-iR <number>`**: 무작위 IP 수, `--exclude <Ips>` 또는 `--excludefile <file>`로 제외 가능.

### Equipment discovery

기본적으로 Nmap은 다음으로 구성된 discovery 단계를 실행합니다: `-PA80 -PS443 -PE -PP`

- **`-sL`**: 비침해적이며 대상 목록을 작성하기 위해 **DNS** 요청으로 이름을 해석합니다. 예를 들어 www.prueba.es/24의 모든 Ips가 우리의 대상인지 확인할 때 유용합니다.
- **`-Pn`**: **No ping**. 모든 호스트가 활성화되어 있음을 확신할 때 유용합니다(그렇지 않으면 많은 시간을 낭비할 수 있고, 이 옵션은 비활성이라고 잘못 판단하는 false negatives를 낼 수 있음). discovery 단계를 건너뜁니다.
- **`-sn`** : **No port scan**. reconnaissance 단계 완료 후 포트를 스캔하지 않습니다. 상대적으로 stealthy하며 작은 네트워크 스캔에 적합합니다. 권한이 있으면 80에 ACK(-PA), 443에 SYN(-PS)과 echo 요청 및 Timestamp 요청을 전송하고, 권한이 없으면 항상 연결을 완료합니다. 대상이 네트워크인 경우 ARP(-PR)만 사용합니다. 다른 옵션과 함께 사용하면 다른 옵션의 패킷만 전송됩니다.
- **`-PR`**: **Ping ARP**. 우리 네트워크의 컴퓨터를 분석할 때 기본으로 사용되며 ping을 사용하는 것보다 빠릅니다. ARP 패킷을 사용하고 싶지 않으면 `--send-ip`를 사용하세요.
- **`-PS <ports>`**: SYN 패킷을 전송합니다. SYN/ACK로 응답하면 open(연결을 끝내지 않기 위해 RST로 응답), RST로 응답하면 closed, 응답이 없으면 unreachable로 간주합니다. 권한이 없으면 전체 연결이 자동으로 사용됩니다. 포트가 주어지지 않으면 기본적으로 80에 던집니다.
- **`-PA <ports>`**: 이전과 유사하지만 ACK를 사용합니다. 둘을 조합하면 더 나은 결과를 얻습니다.
- **`-PU <ports>`**: 반대로 닫혀있을 것으로 예상되는 포트로 전송합니다. 일부 방화벽은 TCP 연결만 검사합니다. 닫혀 있으면 port unreachable로 응답하고, 다른 ICMP로 응답하거나 응답이 없으면 destination unreachable로 남깁니다.
- **`-PE, -PP, -PM`** : ICMP PINGS: echo replay, timestamp 및 addresmask. 대상이 활성인지 확인하기 위해 사용됩니다.
- **`-PY<ports>`**: 기본적으로 80에 SCTP INIT probes를 전송합니다. INIT-ACK(open), ABORT(closed), 아무 응답 없음 또는 ICMP unreachable(inactive) 등이 응답될 수 있습니다.
- **`-PO <protocols>`**: 헤더에 프로토콜 번호를 지정합니다. 기본적으로 1(ICMP), 2(IGMP), 4(Encap IP)을 사용합니다. ICMP, IGMP, TCP(6), UDP(17) 프로토콜의 경우 프로토콜 헤더를 전송하고, 나머지는 IP 헤더만 전송합니다. 헤더의 비정상성으로 인해 Protocol unreachable 또는 같은 프로토콜의 응답을 받아 호스트가 올라있는지 확인합니다.
- **`-n`**: No DNS
- **`-R`**: DNS always

### Port scanning techniques

- **`-sS`**: 연결을 완료하지 않아 흔적을 남기지 않아 가능하면 매우 유용합니다(권한 필요). 기본적으로 사용되는 스캔입니다.
- **`-sT`**: 연결을 완료하므로 흔적을 남기지만 확실히 사용할 수 있습니다. 기본적으로 권한 없이 사용됩니다.
- **`-sU`**: 느리며 UDP용입니다. 주로: DNS(53), SNMP(161,162), DHCP(67 및 68). (`-sU53,161,162,67,68`): open(reply), closed(port unreachable), filtered(다른 ICMP), open/filtered(응답 없음). open/filtered인 경우 -sV가 여러 요청을 보내 nmap이 지원하는 버전을 탐지하여 실제 상태를 확인하려 시도합니다. 시간이 크게 늘어납니다.
- **`-sY`**: SCTP 프로토콜 연결이 실패하여 로그가 남지 않으며 -PY와 유사하게 작동합니다.
- **`-sN,-sX,-sF`:** Null, Fin, Xmas는 일부 방화벽을 통과하거나 정보를 추출할 수 있습니다. 표준 준수 시스템은 SYN, RST 또는 ACK 플래그가 아닌 요청에 대해 RST로 응답해야 한다는 사실에 기반합니다: open/filtered(응답 없음), closed(RST), filtered(ICMP unreachable). Windows, Cisco, BSDI 및 OS/400에서는 신뢰성이 낮고 Unix에서는 작동합니다.
- **`-sM`**: Maimon scan: FIN과 ACK 플래그를 전송하며 BSD에서 사용되었으나 현재는 모두 closed로 반환될 수 있습니다.
- **`-sA, sW`**: ACK와 Window 스캔은 방화벽을 탐지하고 포트가 필터링되었는지 확인하는 데 사용됩니다. -sW는 open/closed를 구분하는데 open은 다른 window 값으로 RST 응답: open (RST with window other than 0), closed (RST window = 0), filtered (ICMP unreachable or nothing). 모든 시스템이 이 방식으로 동작하지 않으므로 모든 포트가 closed로 보이면 작동하지 않는 것이고, 일부만 open이면 정상 작동, 많은 포트가 open이면 반대 방식으로 동작할 수 있습니다.
- **`-sI`:** Idle scan. 특정 IP로는 필터링하지 않는 활성 방화벽이 있거나 단순히 익명성이 필요할 때 zombie scanner를 사용할 수 있습니다(모든 포트에 대해 작동). 가능한 좀비를 찾기 위해 scrpit ipidseq 또는 exploit auxiliary/scanner/ip/ipidseq를 사용할 수 있습니다. 이 스캐너는 IP 패킷의 IPID 번호에 기반합니다.
- **`--badsum`:** 체크섬을 잘못 보내면 대상 컴퓨터는 패킷을 버리지만 방화벽은 무언가 응답할 수 있어 방화벽 탐지에 사용됩니다.
- **`-sZ`:** "Weird" SCTP 스캐너로 cookie echo fragments를 포함한 probes를 보낼 때 open이면 드롭되고 closed이면 ABORT로 응답해야 합니다. init가 통과하지 못하는 방화벽을 통과할 수 있지만 filtered와 open을 구분하지 못합니다.
- **`-sO`:** Protocol IP 스캔. 때때로 프로토콜도 구분할 수 없는 잘못되거나 비어있는 헤더를 보냅니다. ICMP unreachable protocol이 도착하면 closed, unreachable port가 도착하면 open, 다른 오류가 오면 filtered, 아무 응답이 없으면 open|filtered로 처리합니다.
- **`-b <server>`:** FTPhost--> 다른 호스트에서 스캔할 때 사용합니다. 다른 머신의 FTP에 연결해 해당 머신이 스캔하려는 포트로 파일을 전송하도록 요청하고 응답으로 open 여부를 판단합니다. 형식: [\<user>:\<password>@]\<server>\[:\<port>]. 거의 모든 FTP 서버가 더 이상 이를 허용하지 않아 실무적 활용도는 낮습니다.

### **Focus Analysis**

**-p:** 스캔할 포트를 지정합니다. 모든 65,335 포트를 선택하려면: **-p-** 또는 **-p all**. Nmap은 내부적으로 인기순 분류를 사용합니다. 기본값은 상위 1000 포트입니다. **-F**(fast scan)로는 상위 100개를 분석합니다. **--top-ports <number>**로 1에서 65,335 사이의 해당 수만큼 상위 포트를 분석합니다. 포트는 무작위 순서로 검사되며, 이를 방지하려면 **-r**을 사용하세요. 특정 포트를 선택할 수도 있습니다: 20-30,80,443,1024- (후자는 1024부터 이후를 의미). 프로토콜별로 그룹화할 수도 있습니다: U:53,T:21-25,80,139,S:9. Nmap의 인기 포트 범위 내에서 범위를 선택할 수도 있습니다: -p [-1024]는 nmap-services에 포함된 포트 중 1024까지 분석합니다. **--port-ratio <ratio>**는 0과 1 사이의 비율로 가장 흔한 포트들을 분석합니다.

**-sV** Version scanning, intensity는 0에서 9까지 조절 가능, 기본은 7입니다.

**--version-intensity <number>** 낮게 설정하면 가장 가능성이 높은 프로브만 실행하므로 모든 프로브를 보내지 않습니다. 이를 통해 UDP 스캔 시간을 크게 단축할 수 있습니다.

**-O** OS detection

**--osscan-limit** 올바른 호스트 스캔을 위해 최소 하나의 open 포트와 하나의 closed 포트가 필요합니다. 이 조건이 충족되지 않고 이 옵션을 설정하면 OS 예측을 시도하지 않습니다(시간 절약).

**--osscan-guess** OS 탐지가 완벽하지 않을 때 더 열심히 시도하게 합니다.

**Scripts**

--script _<filename>_|_<category>_|_<directory>_|_<expression>_[,...]

기본 스크립트를 사용하려면 -sC 또는 --script=default

사용 가능한 타입: auth, broadcast, default, discovery, dos, exploit, external, fuzzer, intrusive, malware, safe, version, vuln

- **Auth:** 사용 가능한 모든 authentication scripts 실행
- **Default:** 기본 도구 스크립트 실행
- **Discovery:** 대상에서 정보 수집
- **External:** 외부 리소스 사용을 위한 스크립트
- **Intrusive:** 대상에 대해 침투적(intrusive)으로 간주되는 스크립트 사용
- **Malware:** 악성 코드나 백도어가 연 연결을 확인
- **Safe:** 비침해적 스크립트 실행
- **Vuln:** 알려진 취약점 발견
- **All:** 사용 가능한 모든 NSE 확장 스크립트 전체 실행

스크립트 검색 방법:

**nmap --script-help="http-\*" -> http-로 시작하는 것들**

**nmap --script-help="not intrusive" -> Intrusive를 제외한 모두**

**nmap --script-help="default or safe" -> 둘 중 하나에 속한 것들**

**nmap --script-help="default and safe" --> 둘 다에 속한 것들**

**nmap --script-help="(default or safe or intrusive) and not http-\*"**

--script-args _<n1>_=_<v1>_,_<n2>_={_<n3>_=_<v3>_},_<n4>_={_<v4>_,_<v5>_}

--script-args-file _<filename>_

--script-help _<filename>_|_<category>_|_<directory>_|_<expression>_|all[,...]

--script-trace ---> 스크립트 진행 정보를 제공합니다

--script-updatedb

**스크립트를 사용하려면 단순히 입력: nmap --script Script_Name target** --> 스크립트를 사용할 때 스크립트와 스캐너가 모두 실행되므로 스캐너 옵션을 추가할 수 있습니다. 안전한 것만 실행하려면 **"safe=1"**을 추가하세요.

**Time Control**

**Nmap은 초, 분, ms 단위로 시간을 설정할 수 있습니다:** --host-timeout 인수 900000ms, 900, 900s, 및 15m은 동일합니다.

Nmap은 스캔할 전체 호스트 수를 그룹으로 나누고 이 그룹들을 블록 단위로 분석하므로 한 블록이 모두 분석될 때까지 다음 블록으로 넘어가지 않습니다(사용자는 블록이 분석될 때까지 업데이트를 받지 못함). 이 방식은 Nmap이 큰 그룹을 사용하는 것이 더 최적화됨을 의미합니다. Class C에서 기본값은 256입니다.

이는 **--min-hostgroup** _**<numhosts>**_ 및 **--max-hostgroup** _**<numhosts>**_ 로 변경할 수 있습니다 (병렬 스캔 그룹 크기 조정).

병렬 스캐너 수를 제어할 수 있으나 Nmap은 이미 네트워크 상태에 따라 자동 제어를 하므로 보통 변경하지 않는 것이 좋습니다: **--min-parallelism** _**<numprobes>**_ ; **--max-parallelism** _**<numprobes>**_

RTT 타임아웃을 수정할 수 있지만 보통 필요하지 않습니다: **--min-rtt-timeout** _**<time>**_ , **--max-rtt-timeout** _**<time>**_ , **--initial-rtt-timeout** _**<time>**_

시도 횟수를 수정할 수 있습니다: **--max-retries** _**<numtries>**_

호스트 스캔 시간을 수정할 수 있습니다: **--host-timeout** _**<time>**_

각 테스트 간 시간을 늘려 느리게 만들 수 있습니다: **--scan-delay** _**<time>**_ ; **--max-scan-delay** _**<time>**_

초당 패킷 수를 수정할 수 있습니다: **--min-rate** _**<number>**_ ; **--max-rate** _**<number>**_

많은 포트는 filtered 또는 closed일 때 응답이 오래 걸립니다. 열린 포트만 관심이 있다면 더 빠르게 하려면: **--defeat-rst-ratelimit**

Nmap의 공격적 수준을 정의하려면: -T paranoid|sneaky|polite|normal|aggressive|insane

-T (0-1)

-T0 --> 한 번에 1개 포트만 스캔하고 다음 스캔까지 5분 대기

-T1 및 T2 --> 매우 유사하나 각각 테스트 간 15초 및 0.4초 대기

-T3 --> 기본 동작, 병렬 스캔 포함

-T4 --> --max-rtt-timeout 1250ms --min-rtt-timeout 100ms --initial-rtt-timeout 500ms --max-retries 6 --max-scan-delay 10ms

-T5 --> --max-rtt-timeout 300ms --min-rtt-timeout 50ms --initial-rtt-timeout 250ms --max-retries 2 --host-timeout 15m --max-scan-delay 5ms

**Firewall/IDS**

이들은 포트 접근을 허용하지 않거나 패킷을 분석합니다.

**-f** 패킷을 분할(fragment)합니다. 기본적으로 헤더 이후 8바이트 단위로 분할되며 크기를 지정하려면 ..mtu를 사용하세요(이 경우 -f를 사용하지 마십시오). 오프셋은 8의 배수여야 합니다. **Version scanners and scripts don't support fragmentation**

**-D decoy1,decoy2,ME** Nmap은 스캐닝을 다른 IP 주소 출처인 것처럼 보이게 전송하여 당신을 숨깁니다. 목록에 ME를 넣으면 Nmap이 당신을 그 위치에 배치합니다. 완전히 숨기려면 ME 앞에 5~6개의 엔트리를 넣는 것이 좋습니다. 무작위 IP는 RND:<number>로 생성할 수 있습니다. TCP version detectors without connection에서는 작동하지 않습니다. 내부 네트워크에 있으면 무작위가 아닌 활성 IP를 사용하는 것이 좋습니다. 그렇지 않으면 유일하게 활성인 호스트가 당신임을 쉽게 알아낼 수 있습니다.

무작위 IP 사용 예: nmap -D RND:10 Target_IP

**-S IP** Nmap이 당신의 IP를 잡지 못할 때 직접 지정합니다. 다른 호스트가 스캔하는 것처럼 보이게 할 때도 사용됩니다.

**-e <interface>** 인터페이스 선택

많은 관리자가 모든 것이 정상 작동하도록 특정 출발 포트에서 온 모든 패킷을 허용하는 방화벽 규칙을 만듭니다(예: 20,53,67). 이를 찾기 위해 Nmap은 **--source-port** _**<portnumber>**_ ; -g _**<portnumber>**_ 를 제공합니다 (동등).

**--data** _**<hex string>**_ 16진수 텍스트 전송: --data 0xdeadbeef 또는 --data \xCA\xFE\x09

**--data-string** _**<string>**_ 일반 텍스트 전송: --data-string "Scan conducted by Security Ops, extension 7192"

**--data-length** _**<number>**_ Nmap은 기본적으로 헤더만 보내며, 이로써 추가 바이트 수를 랜덤하게 생성하여 첨부할 수 있습니다.

IP 패킷을 완전히 구성하려면 **--ip-options** 사용

전송 및 수신된 패킷의 옵션을 보려면 --packet-trace를 지정하세요. IP 옵션으로 Nmap 사용에 대한 추가 정보와 예시는 [http://seclists.org/nmap-dev/2006/q3/52](http://seclists.org/nmap-dev/2006/q3/52)를 참조하세요.

**--ttl** _**<value>**_

**--randomize-hosts** 공격을 덜 눈에 띄게 만듭니다

**--spoof-mac** _**<MAC address, prefix, or vendor name>**_ MAC 변경 예: Apple, 0, 01:02:03:04:05:06, deadbeefcafe, 0020F2, Cisco

**--proxies** _**<Comma-separated list of proxy URLs>**_ 프록시 사용. 때로 프록시는 Nmap이 원하는 만큼 많은 연결을 유지하지 못하므로 병렬성 조정(--max-parallelism)이 필요할 수 있습니다.

**-sP** ARP로 우리 네트워크의 호스트 발견

많은 관리자가 특정 포트에서 온 모든 패킷을 허용하는 방화벽 규칙을 만듭니다(예: 20,53,67). Nmap에 해당 포트에서 패킷을 보내도록 지시할 수 있습니다: **nmap --source-port 53 IP**

**Outputs**

**-oN file** Normal output

**-oX file** XML output

**-oS file** Script kiddies output

**-oG file** Greppable output

**-oA file** All except -oS

**-v level** verbosity

**-d level** debugging

**--reason** 호스트와 상태의 이유

**--stats-every time** 지정한 시간마다 진행 상황 보고

**--packet-trace** 나가는 패킷을 확인, --version-trace 또는 --script-trace 같은 필터 지정 가능

**--open** open, open|filtered 및 unfiltered만 표시

**--resume file** 요약 출력 재개

**Miscellaneous**

**-6** IPv6 허용

**-A** 는 -O -sV -sC --traceroute와 동일

**Run time**

Nmap 실행 중 옵션을 변경할 수 있습니다:

v / V verbosity 레벨 증가 / 감소

d / D debugging 레벨 증가 / 감소

p / P 패킷 트레이싱 켜기 / 끄기

? 런타임 상호작용 도움말 화면 출력

**Vulscan**

Nmap 스크립트로, 얻어진 서비스 버전을 오프라인 DB(다른 출처에서 다운로드한)와 대조해 가능한 취약점을 반환합니다.

사용하는 DB들은:

1. Scipvuldb.csv | [http://www.scip.ch/en/?vuldb](http://www.scip.ch/en/?vuldb)
2. Cve.csv | [http://cve.mitre.org](http://cve.mitre.org/)
3. Osvdb.csv | [http://www.osvdb.org](http://www.osvdb.org/)
4. Securityfocus.csv | [http://www.securityfocus.com/bid/](http://www.securityfocus.com/bid/)
5. Securitytracker.csv | [http://www.securitytracker.com](http://www.securitytracker.com/)
6. Xforce.csv | [http://xforce.iss.net](http://xforce.iss.net/)
7. Exploitdb.csv | [http://www.exploit-db.com](http://www.exploit-db.com/)
8. Openvas.csv | [http://www.openvas.org](http://www.openvas.org/)

Nmap 폴더에 다운로드 및 설치:

wget http://www.computec.ch/projekte/vulscan/download/nmap_nse_vulscan-2.0.tar.gz && tar -czvf nmap_nse_vulscan-2.0.tar.gz vulscan/ && sudo cp -r vulscan/ /usr/share/nmap/scripts/

또한 DB 패키지를 다운로드하여 /usr/share/nmap/scripts/vulscan/에 추가해야 합니다.

사용법:

모두 사용하려면: sudo nmap -sV --script=vulscan HOST_TO_SCAN

특정 DB만 사용하려면: sudo nmap -sV --script=vulscan --script-args vulscandb=cve.csv HOST_TO_SCAN

## Speed Up Nmap Service scan x16

According [**to this post**](https://joshua.hu/nmap-speedup-service-scanning-16x) you can speed up the nmap service analysis by modifying all the **`totalwaitms`** values in **`/usr/share/nmap/nmap-service-probes`** to **300** and **`tcpwrappedms`** to **200**.

Moreover, probes which do not have a specifically defined **`servicewaitms`** use a default value of **`5000`**. Therefore, we can either add values to each of the probes, or we can **compile nmap** ourselves and change the default value in [**service_scan.h**](https://github.com/nmap/nmap/blob/master/service_scan.h#L79).

If you don't want to change the values of **`totalwaitms`** and **`tcpwrappedms`** at all in the `/usr/share/nmap/nmap-service-probes` file, you can edit the [parsing code](https://github.com/nmap/nmap/blob/master/service_scan.cc#L1358) such that these values in the `nmap-service-probes` file are completely ignored.


## Build a static Nmap for restricted environments

Hardened 또는 minimal Linux 환경(컨테이너, appliance 등)에서는 동적 링크된 Nmap 바이너리가 런타임 로더나 공유 라이브러리(예: /lib64/ld-linux-x86-64.so.2, libc.so) 누락으로 실패하는 경우가 많습니다. 정적으로 링크된 Nmap을 직접 빌드하고 NSE 데이터를 번들링하면 시스템 패키지를 설치하지 않고도 실행할 수 있습니다.

High-level approach
- Docker를 이용해 깨끗한 amd64 Ubuntu 빌더 사용
- OpenSSL과 PCRE2를 static 라이브러리로 빌드
- 포함된 libpcap/libdnet을 사용하여 동적 의존성을 피하고 Nmap을 static으로 링크하여 빌드
- 바이너리와 함께 NSE 스크립트 및 데이터 디렉토리 번들링

Discover target architecture (example)
```bash
uname -a
# If building from macOS/ARM/etc., pin the builder arch:
docker run --rm --platform=linux/amd64 -v "$(pwd)":/out -w /tmp ubuntu:22.04 bash -lc 'echo ok'
```
1단계 — 툴체인 준비
```bash
set -euo pipefail
export DEBIAN_FRONTEND=noninteractive
apt-get update && apt-get install -y --no-install-recommends \
build-essential ca-certificates curl bzip2 xz-utils pkg-config perl python3 file git \
automake autoconf libtool m4 zlib1g-dev
```
2단계 — 정적 OpenSSL 빌드 (1.1.1w)
```bash
OSSL="1.1.1w"
curl -fsSLO "https://www.openssl.org/source/openssl-$OSSL.tar.gz"
tar xzf "openssl-$OSSL.tar.gz" && cd "openssl-$OSSL"
./Configure no-shared no-zlib linux-x86_64 -static --prefix=/opt/ossl
make -j"$(nproc)" && make install_sw
cd /tmp
```
3단계 — PCRE2 (10.43) 정적 빌드
```bash
PCRE2=10.43
curl -fsSLO "https://github.com/PCRE2Project/pcre2/releases/download/pcre2-$PCRE2/pcre2-$PCRE2.tar.bz2"
tar xjf "pcre2-$PCRE2.tar.bz2" && cd "pcre2-$PCRE2"
./configure --disable-shared --enable-static --prefix=/opt/pcre2
make -j"$(nproc)" && make install
cd /tmp
```
단계 4 — 정적 Nmap 빌드 (7.98)
```bash
NMAP=7.98
curl -fsSLO "https://nmap.org/dist/nmap-$NMAP.tar.bz2"
tar xjf "nmap-$NMAP.tar.bz2" && cd "nmap-$NMAP"
export CPPFLAGS="-I/opt/ossl/include -I/opt/pcre2/include"
export LDFLAGS="-L/opt/ossl/lib -L/opt/pcre2/lib -static -static-libstdc++ -static-libgcc"
export LIBS="-lpcre2-8 -ldl -lpthread -lz"
./configure \
--with-openssl=/opt/ossl \
--with-libpcre=/opt/pcre2 \
--with-libpcap=included \
--with-libdnet=included \
--without-zenmap --without-ndiff --without-nmap-update
# Avoid building shared libpcap by accident
sed -i -e "s/^shared: /shared: #/" libpcap/Makefile || true
make -j1 V=1 nmap
strip nmap
```
핵심 포인트
- -static, -static-libstdc++, -static-libgcc는 정적 링크를 강제합니다.
- --with-libpcap=included/--with-libdnet=included를 사용하면 시스템 공유 라이브러리를 피할 수 있습니다.
- sed 조정은 존재하는 공유 libpcap 타깃을 비활성화합니다.

5단계 — binary와 NSE data 번들링
```bash
mkdir -p /out/nmap-bundle/nmap-data
cp nmap /out/nmap-bundle/nmap-linux-amd64-static
cp -r scripts nselib /out/nmap-bundle/nmap-data/
cp nse_main.lua nmap-services nmap-protocols nmap-service-probes \
nmap-mac-prefixes nmap-os-db nmap-payloads nmap-rpc \
/out/nmap-bundle/nmap-data/ 2>/dev/null || true

tar -C /out -czf /out/nmap-linux-amd64-static-bundle.tar.gz nmap-bundle
```
검증 및 운영 노트
- artifact에서 file을 사용해 그것이 statically linked인지 확인하세요.
- NSE data를 binary와 함께 보관하여 Nmap이 설치되지 않은 hosts에서 스크립트 동등성을 보장하세요.
- static binary라도 실행이 AppArmor/seccomp/SELinux에 의해 차단될 수 있습니다; DNS/egress는 여전히 동작해야 합니다.
- Deterministic builds는 불투명한 “static” 바이너리를 다운로드하는 것보다 공급망 리스크를 줄여줍니다.

One-liner (Dockerized)
<details>
<summary>아티팩트를 빌드하고 번들화해 정보 출력</summary>
```bash
docker run --rm --platform=linux/amd64 -v "$(pwd)":/out -w /tmp ubuntu:22.04 bash -lc '
set -euo pipefail
export DEBIAN_FRONTEND=noninteractive
apt-get update && apt-get install -y --no-install-recommends \
build-essential ca-certificates curl bzip2 xz-utils pkg-config perl python3 file git \
automake autoconf libtool m4 zlib1g-dev

OSSL="1.1.1w"; curl -fsSLO "https://www.openssl.org/source/openssl-$OSSL.tar.gz" \
&& tar xzf "openssl-$OSSL.tar.gz" && cd "openssl-$OSSL" \
&& ./Configure no-shared no-zlib linux-x86_64 -static --prefix=/opt/ossl \
&& make -j"$(nproc)" && make install_sw && cd /tmp

PCRE2=10.43; curl -fsSLO "https://github.com/PCRE2Project/pcre2/releases/download/pcre2-$PCRE2/pcre2-$PCRE2.tar.bz2" \
&& tar xjf "pcre2-$PCRE2.tar.bz2" && cd "pcre2-$PCRE2" \
&& ./configure --disable-shared --enable-static --prefix=/opt/pcre2 \
&& make -j"$(nproc)" && make install && cd /tmp

NMAP=7.98; curl -fsSLO "https://nmap.org/dist/nmap-$NMAP.tar.bz2" \
&& tar xjf "nmap-$NMAP.tar.bz2" && cd "nmap-$NMAP" \
&& export CPPFLAGS="-I/opt/ossl/include -I/opt/pcre2/include" \
&& export LDFLAGS="-L/opt/ossl/lib -L/opt/pcre2/lib -static -static-libstdc++ -static-libgcc" \
&& export LIBS="-lpcre2-8 -ldl -lpthread -lz" \
&& ./configure --with-openssl=/opt/ossl --with-libpcre=/opt/pcre2 --with-libpcap=included --with-libdnet=included --without-zenmap --without-ndiff --without-nmap-update \
&& sed -i -e "s/^shared: /shared: #/" libpcap/Makefile || true \
&& make -j1 V=1 nmap && strip nmap

mkdir -p /out/nmap-bundle/nmap-data \
&& cp nmap /out/nmap-bundle/nmap-linux-amd64-static \
&& cp -r scripts nselib /out/nmap-bundle/nmap-data/ \
&& cp nse_main.lua nmap-services nmap-protocols nmap-service-probes nmap-mac-prefixes nmap-os-db nmap-payloads nmap-rpc /out/nmap-bundle/nmap-data/ 2>/dev/null || true \
&& tar -C /out -czf /out/nmap-linux-amd64-static-bundle.tar.gz nmap-bundle \
&& echo "===== OUTPUT ====="; ls -lah /out; echo "===== FILE TYPE ====="; file /out/nmap-bundle/nmap-linux-amd64-static || true
'
```
</details>

## 참고자료

- [Compiling static Nmap binary for jobs in restricted environments](https://www.pentestpartners.com/security-blog/compiling-static-nmap-binary-for-jobs-in-restricted-environments/)
- [Static Nmap Binary Generator (helper tool)](https://github.com/0x5ubt13/static_nmap_binary_generator)
- [OpenSSL sources](https://www.openssl.org/source/)
- [PCRE2 releases](https://github.com/PCRE2Project/pcre2/releases)
- [Nmap source tarballs](https://nmap.org/dist/)


{{#include ../../banners/hacktricks-training.md}}
