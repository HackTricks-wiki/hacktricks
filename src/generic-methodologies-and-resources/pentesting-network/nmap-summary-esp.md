# Nmap 요약 (ESP)

{{#include ../../banners/hacktricks-training.md}}
```
nmap -sV -sC -O -n -oA nmapscan 192.168.0.1/24
```
## 매개변수

### 스캔할 IP

- **`<ip>,<net/mask>`:** IP를 직접 지정
- **`-iL <ips_file>`:** IP 목록 파일 사용
- **`-iR <number>`**: 랜덤 IP 개수. `--exclude <Ips>` 또는 `--excludefile <file>`로 제외 가능.

### 장비 탐지

기본적으로 Nmap은 다음으로 구성된 discovery 단계부터 시작합니다: `-PA80 -PS443 -PE -PP`

- **`-sL`**: 비침투적이며 대상 목록을 나열하기 위해 **DNS** 요청으로 이름을 해석합니다. 예를 들어 www.prueba.es/24의 모든 IP가 우리의 대상인지 확인할 때 유용합니다.
- **`-Pn`**: **ping 생략**. 모든 호스트가 활성화되어 있다고 확신할 때 유용합니다(그렇지 않다면 많은 시간이 소요될 수 있고, 이 옵션은 비활성이라고 잘못 판단하는 false negative를 발생시킬 수 있음). discovery 단계를 건너뜁니다.
- **`-sn`** : **포트 스캔 없음**. 정찰 단계는 수행하지만 포트 스캔을 하지 않습니다. 비교적 은밀하며 소규모 네트워크 탐지에 적합합니다. 권한이 있으면 80에 ACK(-PA), 443에 SYN(-PS), 그리고 echo 요청 및 Timestamp 요청을 보냅니다. 권한이 없으면 항상 연결을 완성합니다. 대상이 네트워크인 경우 ARP(-PR)만 사용합니다. 다른 옵션과 함께 사용하면 다른 옵션의 패킷만 전송됩니다.
- **`-PR`**: **ARP ping**. 로컬 네트워크의 호스트를 분석할 때 기본으로 사용되며 ping보다 빠릅니다. ARP 패킷을 사용하고 싶지 않다면 `--send-ip`를 사용하세요.
- **`-PS <ports>`**: SYN 패킷을 보냅니다. SYN/ACK 응답이면 open(연결을 끝내지 않기 위해 RST로 응답), RST 응답이면 closed, 응답이 없으면 unreachable. 권한이 없으면 전체 연결 방식이 자동으로 사용됩니다. 포트를 지정하지 않으면 기본적으로 80에 전송합니다.
- **`-PA <ports>`**: 이전과 유사하지만 ACK를 사용합니다. 둘을 조합하면 더 좋은 결과를 얻습니다.
- **`-PU <ports>`**: 목적은 반대입니다. 닫혀있을 것으로 예상되는 포트에 보냅니다. 일부 방화벽은 TCP 연결만 검사합니다. closed이면 port unreachable로 응답, 다른 ICMP로 응답하거나 응답이 없으면 destination unreachable로 남깁니다.
- **`-PE, -PP, -PM`** : ICMP PING: echo reply, timestamp, addressmask. 대상이 활성인지 확인하기 위해 보냅니다.
- **`-PY<ports>`**: 기본적으로 80에 SCTP INIT 프로브를 보냅니다. INIT-ACK(open), ABORT(closed), 또는 응답 없음/ICMP unreachable(inactive)가 올 수 있습니다.
- **`-PO <protocols>`**: 헤더에 프로토콜 번호를 지정합니다. 기본으로 1(ICMP), 2(IGMP), 4(Encap IP)를 사용합니다. ICMP, IGMP, TCP(6), UDP(17) 프로토콜에는 프로토콜 헤더를 보내고, 나머지에는 IP 헤더만 보냅니다. 헤더 변조로 인해 Protocol unreachable 또는 동일 프로토콜의 응답이 와서 up 여부를 판단합니다.
- **`-n`**: DNS 비사용
- **`-R`**: 항상 DNS 사용

### 포트 스캔 기법

- **`-sS`**: 연결을 완료하지 않아 흔적을 남기지 않습니다(권한 필요). 기본 사용 방식입니다.
- **`-sT`**: 연결을 완료하므로 흔적이 남지만 권한이 없어도 사용할 수 있습니다(기본).
- **`-sU`**: 느리며 UDP용. 주로 DNS(53), SNMP(161,162), DHCP(67,68)를 검사합니다 (`-sU53,161,162,67,68`): open(reply), closed(port unreachable), filtered(다른 ICMP), open/filtered(응답 없음). open/filtered 경우 `-sV`가 여러 요청을 보내어 버전을 탐지하려 시도하며 시간이 크게 늘어납니다.
- **`-sY`**: SCTP. 연결 수립 실패로 로그가 남지 않으며 -PY와 유사하게 동작합니다.
- **`-sN,-sX,-sF`:** Null, Fin, Xmas. 일부 방화벽을 통과해 정보를 얻을 수 있습니다. 표준 준수 호스트는 SYN, RST, ACK 플래그가 없는 요청에 RST로 응답해야 한다는 점에 기반합니다: open/filtered(응답 없음), closed(RST), filtered(ICMP unreachable). Windows, Cisco, BSDI 및 OS/400에서는 신뢰성이 떨어집니다. Unix에서는 동작합니다.
- **`-sM`**: Maimon 스캔: FIN과 ACK를 보냅니다. BSD 계열에서 사용되며 현재는 모두 closed로 반환될 가능성이 높습니다.
- **`-sA, sW`**: ACK와 Window 스캔. 방화벽을 탐지하고 포트가 필터링되는지 여부를 판단하는 데 사용됩니다. `-sW`는 open/closed를 윈도우 값으로 구분합니다: open (RST, window != 0), closed (RST, window = 0), filtered (ICMP unreachable 또는 응답 없음). 모든 시스템이 동일하게 동작하지 않으므로 모든 포트가 closed로 나오면 작동하지 않는 것입니다; 일부만 open이면 정상 동작입니다.
- **`-sI`:** Idle scan. 액티브 방화벽이 있지만 특정 IP로의 필터링이 없음을 알고 있거나 익명성이 필요할 때 zombie 스캐너를 사용합니다(모든 포트에 대해 동작). 가능한 좀비를 찾으려면 scrpit ipidseq 또는 exploit auxiliary/scanner/ip/ipidseq를 사용할 수 있습니다. 이 스캐너는 IP 패킷의 IPID 숫자에 기반합니다.
- **`--badsum`:** 체크섬을 틀리게 보내면 호스트는 패킷을 버리지만 방화벽은 응답할 수 있으므로 방화벽 탐지에 사용합니다.
- **`-sZ`:** "Weird" SCTP 스캐너. cookie echo fragments로 프로브를 보내면 open이면 드롭, closed이면 ABORT로 응답해야 합니다. INIT가 통과하지 못하는 방화벽을 통과할 수 있지만 filtered와 open을 구분하지 못합니다.
- **`-sO`:** IP 프로토콜 스캔. 때로는 프로토콜조차 구분되지 않는 잘못된/빈 헤더를 보냅니다. ICMP protocol unreachable이 오면 closed, unreachable port가 오면 open, 다른 오류가 오면 filtered, 응답이 없으면 open|filtered로 판단합니다.
- **`-b <server>`:** FTPhost --> 다른 호스트에서 대상 호스트를 스캔할 때 사용합니다. 다른 머신의 FTP에 연결해 해당 머신이 스캔하려는 포트로 파일을 보내도록 요청하고, 그 응답으로 포트 상태를 추정합니다. 형식: [\<user>:\<password>@]\<server>\[:\<port>]. 대부분의 FTP 서버는 이제 이를 허용하지 않아 실무에서는 거의 쓸모가 없습니다.

### **중점 분석**

**-p:** 스캔할 포트를 지정합니다. 전체 65,535 포트를 선택하려면: **-p-** 또는 **-p all**. Nmap은 인기도 기반의 내부 분류를 가지고 있으며 기본으로 상위 1000포트를 사용합니다. **-F**(빠른 스캔)는 상위 100포트를 분석합니다. **--top-ports <number>**로 1에서 65,335 사이의 상위 포트 수를 지정할 수 있습니다. 포트는 무작위 순서로 검사합니다; 이를 방지하려면 **-r**을 사용하세요. 특정 포트를 선택할 수도 있습니다: 20-30,80,443,1024- (마지막은 1024 이후 전부). 프로토콜별로 그룹화도 가능합니다: U:53,T:21-25,80,139,S:9. Nmap의 인기 포트 내에서 범위를 선택하려면: -p [-1024]는 nmap-services에 포함된 포트 중 포트 1024까지를 검사합니다. **--port-ratio <ratio>**는 0과 1 사이의 비율로 가장 흔한 포트를 분석합니다.

**-sV** 버전 스캔. 강도는 0에서 9까지 조절 가능, 기본 7.

**--version-intensity <number>** 강도를 조절합니다. 낮게 설정하면 가장 가능성 높은 프로브만 보내므로 UDP 스캔 시간을 크게 줄일 수 있습니다.

**-O** OS 탐지

**--osscan-limit** 적절한 OS 판정에는 최소 하나의 open 포트와 하나의 closed 포트가 필요합니다. 이 조건이 충족되지 않고 이 옵션을 설정하면 OS 예측을 시도하지 않습니다(시간 절약).

**--osscan-guess** OS 탐지가 완벽하지 않을 때 더 강하게 시도합니다.

**스크립트**

--script _<filename>_|_<category>_|_<directory>_|_<expression>_[,...]

기본 스크립트를 사용하려면 -sC 또는 --script=default

사용 가능한 타입: auth, broadcast, default, discovery, dos, exploit, external, fuzzer, intrusive, malware, safe, version, vuln

- **Auth:** 사용 가능한 인증 스크립트 전부 실행
- **Default:** 기본 도구 스크립트 실행
- **Discovery:** 대상에서 정보 수집
- **External:** 외부 리소스 사용용 스크립트
- **Intrusive:** 대상에 대해 침투적이라 분류되는 스크립트 사용
- **Malware:** 악성 코드나 백도어가 연 연결 검사
- **Safe:** 비침입적 스크립트만 실행
- **Vuln:** 알려진 취약점 탐지
- **All:** 사용 가능한 모든 NSE 확장 스크립트를 전부 실행

스크립트 검색 예:

**nmap --script-help="http-\*" -> http-로 시작하는 것들**

**nmap --script-help="not intrusive" -> 침투적이 아닌 모든 것**

**nmap --script-help="default or safe" -> 둘 중 하나 또는 둘 다에 속한 것들**

**nmap --script-help="default and safe" --> 둘 다에 속한 것들**

**nmap --script-help="(default or safe or intrusive) and not http-\*"**

--script-args _<n1>_=_<v1>_,_<n2>_={_<n3>_=_<v3>_},_<n4>_={_<v4>_,_<v5>_}

--script-args-file _<filename>_

--script-help _<filename>_|_<category>_|_<directory>_|_<expression>_|all[,...]

--script-trace ---> 스크립트 진행 상태 정보를 제공합니다

--script-updatedb

**스크립트 사용법:** nmap --script Script_Name target --> 스크립트를 사용할 때 스크립트와 스캐너가 함께 실행되므로 스캐너 옵션도 추가할 수 있습니다. 안전한 것만 실행하려면 **"safe=1"**을 추가할 수 있습니다.

**시간 제어**

**Nmap은 시간 단위를 초, 분, ms로 지정할 수 있습니다:** --host-timeout 인수로 900000ms, 900, 900s, 그리고 15m는 모두 동일하게 동작합니다.

Nmap은 스캔할 전체 호스트를 그룹으로 나누어 블록 단위로 분석하며, 한 블록의 분석이 끝날 때까지 다음 블록으로 넘어가지 않습니다(사용자는 블록이 완료될 때까지 업데이트를 받지 못함). 이 때문에 Nmap은 큰 그룹을 사용하는 것이 더 효율적입니다. 클래스 C 기본값은 256입니다.

이를 변경하려면 **--min-hostgroup** _**<numhosts>**_**;** **--max-hostgroup** _**<numhosts>**_ (병렬 스캔 그룹 크기 조정)

병렬 스캐너 수를 제어할 수 있지만(Nmap은 네트워크 상태에 따라 자동 제어를 이미 포함하므로 일반적으로 조정 권장 안 함): **--min-parallelism** _**<numprobes>**_**;** **--max-parallelism** _**<numprobes>**_

RTT 타임아웃을 수정할 수 있지만 보통 불필요합니다: **--min-rtt-timeout** _**<time>**_**,** **--max-rtt-timeout** _**<time>**_**,** **--initial-rtt-timeout** _**<time>**_

시도 횟수 수정: **--max-retries** _**<numtries>**_

호스트당 스캔 시간 수정: **--host-timeout** _**<time>**_

각 테스트 사이의 지연을 늘려 느리게 하려면: **--scan-delay** _**<time>**_**;** **--max-scan-delay** _**<time>**_

초당 패킷 수 수정: **--min-rate** _**<number>**_**;** **--max-rate** _**<number>**_

많은 포트는 filtered 또는 closed 상태에서 응답이 오래 걸립니다. open 포트만 관심 있다면 속도를 올리기 위해: **--defeat-rst-ratelimit**

Nmap의 공격성 수준 정의: -T paranoid|sneaky|polite|normal|aggressive|insane

-T (0-1)

-T0 --> 한 번에 1포트만 스캔하고 다음까지 5분 대기

-T1 및 T2 --> 매우 유사하지만 각각 테스트 간 15초와 0.4초 대기

-T3 --> 기본 동작, 병렬 스캔 포함

-T4 --> --max-rtt-timeout 1250ms --min-rtt-timeout 100ms --initial-rtt-timeout 500ms --max-retries 6 --max-scan-delay 10ms

-T5 --> --max-rtt-timeout 300ms --min-rtt-timeout 50ms --initial-rtt-timeout 250ms --max-retries 2 --host-timeout 15m --max-scan-delay 5ms

Firewall/IDS

방화벽/IDS는 포트 접근을 차단하고 패킷을 분석합니다.

**-f** 패킷을 분할(fragment)합니다. 기본적으로 헤더 이후 8바이트 단위로 분할하며 크기를 지정하려면 ..mtu를 사용(이 경우 -f를 사용하지 마세요). 오프셋은 8의 배수여야 합니다. **Version scanners와 스크립트는 fragmentation을 지원하지 않습니다**

**-D decoy1,decoy2,ME** Nmap은 origin을 다른 IP로 위장한 스캔을 보냅니다. ME를 리스트에 넣으면 Nmap이 해당 위치에 당신을 배치합니다. 완전히 숨기려면 당신 앞에 5~6개의 IP를 넣는 것이 좋습니다. RND:<number>로 랜덤 IP를 생성할 수 있습니다. TCP 버전 감지기(비연결형)에서는 동작하지 않습니다. 내부 네트워크에 있다면 비활성 IP보다 활성 IP를 사용하는 것이 좋습니다(아니면 유일한 활성 호스트가 당신인 것이 쉽게 드러납니다).

랜덤 IP 사용 예: nmap -D RND:10 Target_IP

**-S IP** Nmap이 당신의 IP를 잡아내지 못할 때 사용. 또한 다른 대상이 스캔하는 것처럼 보이게 할 때 사용됩니다.

**-e <interface>** 인터페이스 선택

많은 관리자들이 서비스 편의를 위해 특정 포트에서 오는 모든 패킷을 허용하는 규칙을 둡니다(예: 20,53,67). 이런 취약점을 찾기 위해 Nmap은 **--source-port** _**<portnumber>**_; **-g** _**<portnumber>**_ (동등)을 제공합니다.

**--data** _**<hex string>**_ 16진수 텍스트 전송: --data 0xdeadbeef 또는 --data \xCA\xFE\x09

**--data-string** _**<string>**_ 일반 텍스트 전송: --data-string "Scan conducted by Security Ops, extension 7192"

**--data-length** _**<number>**_ Nmap이 헤더만 보낼 때 추가 바이트 수를 랜덤하게 채워 전송

IP 패킷을 완전히 구성하려면 **--ip-options**

보내고 받는 패킷의 옵션을 보려면 --packet-trace 지정. IP 옵션 사용 예제 및 자세한 내용은 [http://seclists.org/nmap-dev/2006/q3/52](http://seclists.org/nmap-dev/2006/q3/52) 참조.

**--ttl** _**<value>**_

**--randomize-hosts** 공격을 덜 명백하게 만들기

**--spoof-mac** _**<MAC address, prefix, or vendor name>**_ MAC 변경 예: Apple, 0, 01:02:03:04:05:06, deadbeefcafe, 0020F2, Cisco

**--proxies** _**<Comma-separated list of proxy URLs>**_ 프록시 사용. 일부 프록시는 Nmap이 원하는 만큼 많은 연결을 유지하지 못하므로 병렬성 조정이 필요할 수 있음: --max-parallelism

**-sP** ARP로 로컬 네트워크에서 호스트 발견

많은 관리자들이 특정 포트에서 오는 모든 패킷을 허용하는 방화벽 규칙을 만듭니다(예: 20,53,67). Nmap에 이 포트들로 패킷을 보내도록 지시할 수 있습니다: **nmap --source-port 53 IP**

출력

**-oN file** 일반 출력

**-oX file** XML 출력

**-oS file** Script kiddies 출력

**-oG file** Greppable 출력

**-oA file** 모든 출력(-oS 제외 포함)

**-v level** verbosity

**-d level** debugging

**--reason** 호스트 상태의 이유 표시

**--stats-every time** 주기적으로 진행 상태 출력

**--packet-trace** 나가는 패킷 보기, 필터 지정 가능(예: --version-trace 또는 --script-trace)

**--open** open, open|filtered 및 unfiltered만 표시

**--resume file** 요약 출력으로 재개

기타

**-6** IPv6 허용

**-A** 는 -O -sV -sC --traceroute 와 동일

실행 중

Nmap 실행 중 옵션을 변경할 수 있습니다:

v / V verbosity 증가/감소

d / D debugging 증가/감소

p / P packet tracing 켜기/끄기

? 런타임 상호작용 도움말 화면 출력

Vulscan

Nmap 스크립트로, 얻은 서비스 버전을 오프라인 DB(다른 중요한 DB에서 수집)와 대조하여 가능한 취약점을 반환합니다.

사용하는 DB 목록:

1. Scipvuldb.csv | [http://www.scip.ch/en/?vuldb](http://www.scip.ch/en/?vuldb)
2. Cve.csv | [http://cve.mitre.org](http://cve.mitre.org/)
3. Osvdb.csv | [http://www.osvdb.org](http://www.osvdb.org/)
4. Securityfocus.csv | [http://www.securityfocus.com/bid/](http://www.securityfocus.com/bid/)
5. Securitytracker.csv | [http://www.securitytracker.com](http://www.securitytracker.com/)
6. Xforce.csv | [http://xforce.iss.net](http://xforce.iss.net/)
7. Exploitdb.csv | [http://www.exploit-db.com](http://www.exploit-db.com/)
8. Openvas.csv | [http://www.openvas.org](http://www.openvas.org/)

Nmap 폴더에 다운로드 및 설치:

wget http://www.computec.ch/projekte/vulscan/download/nmap_nse_vulscan-2.0.tar.gz && tar -czvf nmap_nse_vulscan-2.0.tar.gz vulscan/ && sudo cp -r vulscan/ /usr/share/nmap/scripts/

DB 패키지들도 다운로드하여 /usr/share/nmap/scripts/vulscan/에 추가해야 합니다.

사용법:

전체 DB 사용: sudo nmap -sV --script=vulscan HOST_TO_SCAN

특정 DB 사용: sudo nmap -sV --script=vulscan --script-args vulscandb=cve.csv HOST_TO_SCAN

## Nmap Service 스캔을 x16 빨리 하기

[**to this post**](https://joshua.hu/nmap-speedup-service-scanning-16x)에 따르면 `/usr/share/nmap/nmap-service-probes` 파일의 모든 **`totalwaitms`** 값을 **300**으로, **`tcpwrappedms`** 를 **200**으로 수정하면 service 분석 속도를 높일 수 있습니다.

또한, 명시적으로 정의된 **`servicewaitms`** 가 없는 프로브는 기본값 **`5000`** 을 사용합니다. 따라서 각 프로브에 값을 추가하거나 **nmap을 컴파일**하여 기본값을 [**service_scan.h**](https://github.com/nmap/nmap/blob/master/service_scan.h#L79)에서 변경할 수 있습니다.

`/usr/share/nmap/nmap-service-probes` 파일의 **`totalwaitms`** 및 **`tcpwrappedms`** 값을 전혀 변경하고 싶지 않다면, [parsing code](https://github.com/nmap/nmap/blob/master/service_scan.cc#L1358)를 편집하여 파일 내의 이 값들을 완전히 무시하도록 할 수 있습니다.

## 제한된 환경용 정적 Nmap 빌드

하드닝되거나 최소화된 Linux 환경(컨테이너, appliance)에서는 동적 링크된 Nmap 바이너리가 런타임 로더나 공유 라이브러리(예: /lib64/ld-linux-x86-64.so.2, libc.so) 부족으로 실패하는 경우가 많습니다. 정적으로 링크된 Nmap을 직접 빌드하고 NSE 데이터까지 번들하면 시스템 패키지 설치 없이 실행할 수 있습니다.

고수준 접근법
- Docker로 깨끗한 amd64 Ubuntu 빌더 사용
- OpenSSL 및 PCRE2를 정적 라이브러리로 빌드
- libpcap/libdnet 포함을 사용해 정적으로 링크된 Nmap 빌드(동적 의존성 회피)
- 바이너리와 함께 NSE 스크립트 및 데이터 디렉토리 번들링

타깃 아키텍처 식별 (예시)
```bash
uname -a
# If building from macOS/ARM/etc., pin the builder arch:
docker run --rm --platform=linux/amd64 -v "$(pwd)":/out -w /tmp ubuntu:22.04 bash -lc 'echo ok'
```
1단계 — 툴체인 준비
```bash
set -euo pipefail
export DEBIAN_FRONTEND=noninteractive
apt-get update && apt-get install -y --no-install-recommends \
build-essential ca-certificates curl bzip2 xz-utils pkg-config perl python3 file git \
automake autoconf libtool m4 zlib1g-dev
```
2단계 — 정적 OpenSSL (1.1.1w) 빌드
```bash
OSSL="1.1.1w"
curl -fsSLO "https://www.openssl.org/source/openssl-$OSSL.tar.gz"
tar xzf "openssl-$OSSL.tar.gz" && cd "openssl-$OSSL"
./Configure no-shared no-zlib linux-x86_64 -static --prefix=/opt/ossl
make -j"$(nproc)" && make install_sw
cd /tmp
```
3단계 — 정적 PCRE2 (10.43) 빌드
```bash
PCRE2=10.43
curl -fsSLO "https://github.com/PCRE2Project/pcre2/releases/download/pcre2-$PCRE2/pcre2-$PCRE2.tar.bz2"
tar xjf "pcre2-$PCRE2.tar.bz2" && cd "pcre2-$PCRE2"
./configure --disable-shared --enable-static --prefix=/opt/pcre2
make -j"$(nproc)" && make install
cd /tmp
```
4단계 — 정적 Nmap (7.98) 빌드
```bash
NMAP=7.98
curl -fsSLO "https://nmap.org/dist/nmap-$NMAP.tar.bz2"
tar xjf "nmap-$NMAP.tar.bz2" && cd "nmap-$NMAP"
export CPPFLAGS="-I/opt/ossl/include -I/opt/pcre2/include"
export LDFLAGS="-L/opt/ossl/lib -L/opt/pcre2/lib -static -static-libstdc++ -static-libgcc"
export LIBS="-lpcre2-8 -ldl -lpthread -lz"
./configure \
--with-openssl=/opt/ossl \
--with-libpcre=/opt/pcre2 \
--with-libpcap=included \
--with-libdnet=included \
--without-zenmap --without-ndiff --without-nmap-update
# Avoid building shared libpcap by accident
sed -i -e "s/^shared: /shared: #/" libpcap/Makefile || true
make -j1 V=1 nmap
strip nmap
```
요점
- -static, -static-libstdc++, -static-libgcc는 정적 링크를 강제합니다.
- --with-libpcap=included/--with-libdnet=included를 사용하면 시스템 공유 라이브러리를 피할 수 있습니다.
- sed 조정은 존재하는 경우 공유 libpcap 대상을 무력화합니다.

단계 5 — binary 및 NSE 데이터 번들링
```bash
mkdir -p /out/nmap-bundle/nmap-data
cp nmap /out/nmap-bundle/nmap-linux-amd64-static
cp -r scripts nselib /out/nmap-bundle/nmap-data/
cp nse_main.lua nmap-services nmap-protocols nmap-service-probes \
nmap-mac-prefixes nmap-os-db nmap-payloads nmap-rpc \
/out/nmap-bundle/nmap-data/ 2>/dev/null || true

tar -C /out -czf /out/nmap-linux-amd64-static-bundle.tar.gz nmap-bundle
```
검증 및 운영 노트
- 아티팩트에서 file을 사용하여 정적으로 링크되어 있는지 확인하세요.
- Nmap이 설치되지 않은 호스트에서 스크립트 동등성을 보장하려면 NSE 데이터를 바이너리와 함께 보관하세요.
- static binary가 있어도 실행은 AppArmor/seccomp/SELinux에 의해 차단될 수 있습니다; DNS/egress는 여전히 작동해야 합니다.
- 결정론적 빌드는 불투명한 "static" 바이너리를 다운로드하는 것보다 공급망 위험을 줄입니다.

원라이너 (Dockerized)
<details>
<summary>빌드, 번들화, 아티팩트 정보 출력</summary>
```bash
docker run --rm --platform=linux/amd64 -v "$(pwd)":/out -w /tmp ubuntu:22.04 bash -lc '
set -euo pipefail
export DEBIAN_FRONTEND=noninteractive
apt-get update && apt-get install -y --no-install-recommends \
build-essential ca-certificates curl bzip2 xz-utils pkg-config perl python3 file git \
automake autoconf libtool m4 zlib1g-dev

OSSL="1.1.1w"; curl -fsSLO "https://www.openssl.org/source/openssl-$OSSL.tar.gz" \
&& tar xzf "openssl-$OSSL.tar.gz" && cd "openssl-$OSSL" \
&& ./Configure no-shared no-zlib linux-x86_64 -static --prefix=/opt/ossl \
&& make -j"$(nproc)" && make install_sw && cd /tmp

PCRE2=10.43; curl -fsSLO "https://github.com/PCRE2Project/pcre2/releases/download/pcre2-$PCRE2/pcre2-$PCRE2.tar.bz2" \
&& tar xjf "pcre2-$PCRE2.tar.bz2" && cd "pcre2-$PCRE2" \
&& ./configure --disable-shared --enable-static --prefix=/opt/pcre2 \
&& make -j"$(nproc)" && make install && cd /tmp

NMAP=7.98; curl -fsSLO "https://nmap.org/dist/nmap-$NMAP.tar.bz2" \
&& tar xjf "nmap-$NMAP.tar.bz2" && cd "nmap-$NMAP" \
&& export CPPFLAGS="-I/opt/ossl/include -I/opt/pcre2/include" \
&& export LDFLAGS="-L/opt/ossl/lib -L/opt/pcre2/lib -static -static-libstdc++ -static-libgcc" \
&& export LIBS="-lpcre2-8 -ldl -lpthread -lz" \
&& ./configure --with-openssl=/opt/ossl --with-libpcre=/opt/pcre2 --with-libpcap=included --with-libdnet=included --without-zenmap --without-ndiff --without-nmap-update \
&& sed -i -e "s/^shared: /shared: #/" libpcap/Makefile || true \
&& make -j1 V=1 nmap && strip nmap

mkdir -p /out/nmap-bundle/nmap-data \
&& cp nmap /out/nmap-bundle/nmap-linux-amd64-static \
&& cp -r scripts nselib /out/nmap-bundle/nmap-data/ \
&& cp nse_main.lua nmap-services nmap-protocols nmap-service-probes nmap-mac-prefixes nmap-os-db nmap-payloads nmap-rpc /out/nmap-bundle/nmap-data/ 2>/dev/null || true \
&& tar -C /out -czf /out/nmap-linux-amd64-static-bundle.tar.gz nmap-bundle \
&& echo "===== OUTPUT ====="; ls -lah /out; echo "===== FILE TYPE ====="; file /out/nmap-bundle/nmap-linux-amd64-static || true
'
```
</details>

## 참고 자료

- [Compiling static Nmap binary for jobs in restricted environments](https://www.pentestpartners.com/security-blog/compiling-static-nmap-binary-for-jobs-in-restricted-environments/)
- [Static Nmap Binary Generator (helper tool)](https://github.com/0x5ubt13/static_nmap_binary_generator)
- [OpenSSL sources](https://www.openssl.org/source/)
- [PCRE2 releases](https://github.com/PCRE2Project/pcre2/releases)
- [Nmap source tarballs](https://nmap.org/dist/)


{{#include ../../banners/hacktricks-training.md}}
