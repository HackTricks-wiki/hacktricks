# Nmap सारांश (ESP)

{{#include ../../banners/hacktricks-training.md}}
```
nmap -sV -sC -O -n -oA nmapscan 192.168.0.1/24
```
## Parameters

### IPs to scan

- **`<ip>,<net/mask>`:** IPs सीधे बताने के लिए
- **`-iL <ips_file>`:** list_IPs
- **`-iR <number>`**: रैंडम Ips की संख्या, आप संभावित Ips को `--exclude <Ips>` या `--excludefile <file>` से बाहर रख सकते हैं।

### Equipment discovery

डिफ़ॉल्ट रूप से Nmap एक discovery चरण चलाता है जो शामिल है: `-PA80 -PS443 -PE -PP`

- **`-sL`**: यह invasive नहीं है, यह लक्ष्यों की सूची बनाता है और नाम resolve करने के लिए **DNS** अनुरोध करता है। यह उपयोगी है यह जानने के लिए कि उदाहरण के लिए www.prueba.es/24 के सभी Ips हमारे लक्ष्य हैं या नहीं।
- **`-Pn`**: **No ping**। यह उपयोगी है अगर आप जानते हैं कि सभी एक्टिव हैं (यदि नहीं, तो आप बहुत समय खो सकते हैं, लेकिन यह विकल्प false negatives भी पैदा कर सकता है जो कहेगा कि वे एक्टिव नहीं हैं), यह discovery चरण को रोकता है।
- **`-sn`** : **No port scan**। reconnaissance चरण पूरा करने के बाद यह पोर्ट्स स्कैन नहीं करता। यह तुलनात्मक रूप से stealthy है, और छोटे नेटवर्क स्कैन की अनुमति देता है। privileges होने पर यह 80 पर ACK (-PA), 443 पर SYN(-PS) और एक echo request और Timestamp request भेजता है, बिना privileges के यह हमेशा कनेक्शनों को पूरा करता है। यदि लक्ष्य नेटवर्क है, तो यह केवल ARP(-PR) का उपयोग करता है। यदि किसी अन्य विकल्प के साथ उपयोग किया जाता है, तो केवल अन्य विकल्प के पैकेट ड्रॉप किए जाते हैं।
- **`-PR`**: **Ping ARP**। हमारे नेटवर्क में कंप्यूटरों का विश्लेषण करते समय डिफ़ॉल्ट रूप से उपयोग किया जाता है, यह पिंग के मुकाबले तेज़ है। यदि आप ARP पैकेट का उपयोग नहीं करना चाहते हैं तो `--send-ip` का उपयोग करें।
- **`-PS <ports>`**: यह SYN पैकेट भेजता है जिनके लिए यदि SYN/ACK का उत्तर मिलता है तो वह open है (जिसका उत्तर RST के साथ दिया जाता है ताकि कनेक्शन समाप्त न हो), यदि RST आता है तो closed है और यदि कोई उत्तर नहीं आता तो unreachable। यदि privileges नहीं हैं, तो कुल कनेक्शन स्वचालित रूप से उपयोग किया जाता है। यदि पोर्ट्स नहीं दिए गए तो यह डिफ़ॉल्ट रूप से 80 पर भेजता है।
- **`-PA <ports>`**: पिछले जैसा ही परंतु ACK के साथ, दोनों को संयोजित करने से बेहतर परिणाम मिलते हैं।
- **`-PU <ports>`**: उद्देश्य इसका विपरीत है, इन्हें ऐसे पोर्ट्स पर भेजा जाता है जो बंद होने की उम्मीद होती है। कुछ firewalls केवल TCP कनेक्शनों की जाँच करते हैं। यदि बंद है तो port unreachable का उत्तर मिलता है, यदि किसी अन्य icmp से उत्तर मिलता है या कोई उत्तर नहीं मिलता है तो उसे destination unreachable छोड़ा जाता है।
- **`-PE, -PP, -PM`** : ICMP PINGS: echo reply, timestamp और addresmask। इन्हें लक्ष्य एक्टिव है या नहीं पता करने के लिए लॉन्च किया जाता है।
- **`-PY<ports>`**: SCTP INIT probes भेजता है, डिफ़ॉल्ट रूप से 80 पर, INIT-ACK(open) या ABORT(closed) या कुछ नहीं या ICMP unreachable(inactive) उत्तर मिल सकते हैं।
- **`-PO <protocols>`**: हेडर्स में एक प्रोटोकॉल संकेतित किया जाता है, डिफ़ॉल्ट 1(ICMP), 2(IGMP) और 4(Encap IP) है। ICMP, IGMP, TCP (6) और UDP (17) प्रोटोकॉल्स के लिए प्रोटोकॉल हेडर्स भेजे जाते हैं, बाकी के लिए केवल IP हेडर भेजा जाता है। इसका उद्देश्य यह है कि हेडर्स की malformed होने की वजह से Protocol unreachable या उसी प्रोटोकॉल के उत्तर मिलकर पता चले कि यह up है।
- **`-n`**: No DNS
- **`-R`**: हमेशा DNS

### Port scanning techniques

- **`-sS`**: कनेक्शन पूरा नहीं करता इसलिए कोई निशान नहीं छोड़ता, बहुत अच्छा यदि उपयोग किया जा सके।(privileges) यह डिफ़ॉल्ट रूप से प्रयोग किया जाता है।
- **`-sT`**: कनेक्शन पूरा करता है, इसलिए निशान छोड़ता है, पर यह निश्चित रूप से उपयोग किया जा सकता है। डिफ़ॉल्ट रूप से बिना privileges।
- **`-sU`**: धीमा, UDP के लिए। मुख्यतः: DNS(53), SNMP(161,162), DHCP(67 और 68), (-sU53,161,162,67,68): open(reply), closed(port unreachable), filtered (अलग ICMP), open/filtered (कुछ नहीं)। open/filtered के मामले में, -sV कई अनुरोध भेजता है ताकि nmap द्वारा समर्थित किसी भी संस्करण का पता लगा सके और वास्तविक स्थिति का पता कर सके। यह समय काफी बढ़ा देता है।
- **`-sY`**: SCTP प्रोटोकॉल कनेक्शन स्थापित करने में विफल रहता है, इसलिए कोई लॉग नहीं होते, यह -PY की तरह काम करता है
- **`-sN,-sX,-sF`:** Null, Fin, Xmas, ये कुछ firewalls में проник कर जानकारी निकाल सकते हैं। इनका आधार यह है कि standard compliant मशीनों को उन अनुरोधों का RST के साथ जवाब देना चाहिए जिनमें SYN, RST या ACK flags नहीं उठे होते: open/filtered(कुछ नहीं), closed(RST), filtered (ICMP unreachable). Windows, Cisco, BSDI और OS/400 पर अनविश्वसनीय। Unix पर हाँ।
- **`-sM`**: Maimon scan: FIN और ACK flags भेजता है, BSD के लिए उपयोग होता है, वर्तमान में सभी को closed के रूप में लौटाएगा।
- **`-sA, sW`**: ACK और Window, फायरवॉल का पता लगाने के लिए उपयोग किया जाता है, यह जानने के लिए कि पोर्ट्स filtered हैं या नहीं। -sW open/closed में अंतर बताता है क्योंकि open ones अलग window value के साथ RST के साथ जवाब देते हैं: open (RST window अन्य than 0), closed (RST window = 0), filtered (ICMP unreachable या कुछ नहीं)। सभी कंप्यूटर इस तरह काम नहीं करते, इसलिए यदि सब closed आ रहा है तो यह काम नहीं कर रहा है, अगर कुछ open आ रहे हैं तो यह ठीक काम कर रहा है, और यदि बहुत से open और कुछ closed हैं तो यह उल्टा काम कर रहा है।
- **`-sI`:** Idle scan. उन मामलों के लिए जिनमें एक सक्रिय firewall है पर हमें पता है कि वह किसी विशेष Ip के लिए फ़िल्टर नहीं करता (या जब हम बस anonymity चाहते हैं) हम zombie scanner का उपयोग कर सकते हैं (यह सभी पोर्ट्स के लिए काम करता है), संभावित zombies खोजने के लिए हम scrpit ipidseq या exploit auxiliary/scanner/ip/ipidseq का उपयोग कर सकते हैं। यह scanner IP पैकेट्स के IPID नंबर पर आधारित है।
- **`--badsum`:** यह checksum गलत भेजता है, कंप्यूटर पैकेट्स discard कर देंगे, पर firewalls कुछ उत्तर दे सकते हैं, इसे firewall का पता लगाने के लिए उपयोग किया जाता है।
- **`-sZ`:** "Weird" SCTP scanner, जब cookie echo fragments के साथ probes भेजे जाते हैं तो अगर open हैं तो उन्हें drop किया जाना चाहिए या closed होने पर ABORT के साथ जवाब देना चाहिए। यह उन firewalls को पार कर सकता है जिन्हें init पार नहीं कर पाता, खराब बात यह है कि यह filtered और open के बीच परभेद नहीं कर पाता।
- **`-sO`:** Protocol Ip scan। खराब और empty हेडर्स भेजता है जिनमें कभी-कभी प्रोटोकॉल भी अलग से पहचाना नहीं जा सकता। यदि ICMP unreachable protocol आता है तो closed है, यदि unreachable port आता है तो open है, यदि कोई अन्य error आता है तो filtered, यदि कुछ नहीं आता तो open|filtered।
- **`-b <server>`:** FTPhost--> यह किसी एक host से दूसरे host को स्कैन करने के लिए उपयोग किया जाता है, यह किसी अन्य मशीन के ftp से कनेक्ट करके और उसे उन पोर्ट्स पर फाइल भेजने के लिए कहकर किया जाता है जिन्हें आप दूसरे मशीन से स्कैन करना चाहते हैं, उत्तरों के अनुसार हम जानेंगे कि वे open हैं या नहीं। [\<user>:\<password>@]\<server>\[:\<port>] लगभग सभी ftp servers अब यह अनुमति नहीं देते और इसलिए इसका व्यावहारिक उपयोग कम है।

### **Focus Analysis**

**-p:** स्कैन करने के लिए पोर्ट्स निर्दिष्ट करने के लिए उपयोग किया जाता है। सभी 65,335 पोर्ट्स चुनने के लिए: **-p-** या **-p all**। Nmap के पास एक आंतरिक वर्गीकरण है जो लोकप्रियता पर आधारित है। डिफ़ॉल्ट रूप से, यह top 1000 पोर्ट्स का उपयोग करता है। **-F** (fast scan) के साथ यह top 100 का विश्लेषण करता है। **--top-ports <number>** के साथ यह उस संख्या के top पोर्ट्स का विश्लेषण करता है (1 से 65,335 तक)। यह पोर्ट्स को रैंडम क्रम में चेक करता है; इसे रोकने के लिए **-r** का उपयोग करें। हम विशिष्ट पोर्ट्स भी चुन सकते हैं: 20-30,80,443,1024- (अर्थात् 1024 से आगे देखना)। हम प्रोटोकॉल्स द्वारा पोर्ट्स को भी समूहित कर सकते हैं: U:53,T:21-25,80,139,S:9। हम Nmap के लोकप्रिय पोर्ट्स के भीतर एक रेंज भी चुन सकते हैं: -p [-1024] nmap-services में शामिल उन पोर्ट्स में 1024 तक का विश्लेषण करता है। **--port-ratio <ratio>** 0 और 1 के बीच एक अनुपात के भीतर सबसे सामान्य पोर्ट्स का विश्लेषण करता है

**-sV** Version scanning, intensity 0 से 9 तक नियंत्रित की जा सकती है, डिफ़ॉल्ट 7 है।

**--version-intensity <number>** हम intensity नियंत्रित करते हैं, ताकि जितना कम होगा यह केवल सबसे संभावित probes चलाएगा, लेकिन सभी नहीं। इससे हम UDP scanning समय को काफी कम कर सकते हैं

**-O** OS detection

**--osscan-limit** उचित host scanning के लिए कम से कम एक open पोर्ट और एक closed पोर्ट आवश्यक होते हैं। यदि यह शर्त पूरी नहीं होती और हमने यह सेट किया है, तो यह OS prediction का प्रयास नहीं करेगा (समय बचाता है)

**--osscan-guess** जब OS detection परफेक्ट नहीं होता, यह इसे और कोशिश करने के लिए प्रेरित करता है

**Scripts**

--script _<filename>_|_<category>_|_<directory>_|_<expression>_[,...]

डिफ़ॉल्ट scripts इस्तेमाल करने के लिए, -sC या --script=default का उपयोग करें

उपलब्ध प्रकार हैं: auth, broadcast, default, discovery, dos, exploit, external, fuzzer, intrusive, malware, safe, version, और vuln

- **Auth:** सभी उपलब्ध authentication scripts चलाता है
- **Default:** मूल default tool scripts चलाता है
- **Discovery:** लक्ष्य या विक्टिम से जानकारी पुनःप्राप्त करता है
- **External:** external resources का उपयोग करने के लिए script
- **Intrusive:** लक्ष्य/विक्टिम के लिए intrusive माने जाने वाले scripts का उपयोग करता है
- **Malware:** malicious code या backdoors द्वारा खोले गए कनेक्शनों की जाँच करता है
- **Safe:** non-intrusive scripts चलाता है
- **Vuln:** सबसे ज्ञात vulnerabilities को खोजता है
- **All:** उपलब्ध सभी NSE extension scripts को चलाता है

Scripts खोजने के लिए:

**nmap --script-help="http-\*" -> Those starting with http-**

**nmap --script-help="not intrusive" -> All except those**

**nmap --script-help="default or safe" -> Those in either or both**

**nmap --script-help="default and safe" --> Those in both**

**nmap --script-help="(default or safe or intrusive) and not http-\*"**

--script-args _<n1>_=_<v1>_,_<n2>_={_<n3>_=_<v3>_},_<n4>_={_<v4>_,_<v5>_}

--script-args-file _<filename>_

--script-help _<filename>_|_<category>_|_<directory>_|_<expression>_|all[,...]

--script-trace ---> स्क्रिप्ट कैसे प्रोग्रेस कर रही है इसकी जानकारी देता है

--script-updatedb

**To use a script, just type: nmap --script Script_Name target** --> स्क्रिप्ट उपयोग करते समय, स्क्रिप्ट और scanner दोनों execute होंगे, इसलिए scanner विकल्प भी जोड़े जा सकते हैं। हम **"safe=1"** जोड़ सकते हैं ताकि केवल safe स्क्रिप्ट्स चलें।

**Time Control**

**Nmap समय सेकंड, मिनट, ms में बदल सकता है:** --host-timeout arguments 900000ms, 900, 900s, और 15m सभी एक ही करते हैं।

Nmap स्कैन करने के कुल hosts की संख्या को समूहों में विभाजित करता है और इन समूहों का ब्लॉकों में विश्लेषण करता है, इसलिए यह अगले ब्लॉक पर तब तक नहीं जाता जब तक सभी का विश्लेषण न हो जाए (और यूज़र को तब तक कोई अपडेट नहीं मिलता)। इस तरह, Nmap के लिए बड़े समूहों का उपयोग करना अधिक optimal होता है। डिफ़ॉल्ट रूप से class C में, यह 256 का उपयोग करता है।

इसे बदला जा सकता है: **--min-hostgroup** _**<numhosts>**_**;** **--max-hostgroup** _**<numhosts>**_ (parallel scan group sizes समायोजित करें)

आप parallel scanners की संख्या नियंत्रित कर सकते हैं पर बेहतर है कि न करें (Nmap पहले से नेटवर्क की स्थिति के आधार पर automatic control शामिल करता है): **--min-parallelism** _**<numprobes>**_**;** **--max-parallelism** _**<numprobes>**_

हम RTT timeout बदल सकते हैं, पर सामान्यतः आवश्यक नहीं होता: **--min-rtt-timeout** _**<time>**_**,** **--max-rtt-timeout** _**<time>**_**,** **--initial-rtt-timeout** _**<time>**_

हम प्रयासों की संख्या बदल सकते हैं: **--max-retries** _**<numtries>**_

हम एक host के स्कैनिंग समय को बदल सकते हैं: **--host-timeout** _**<time>**_

हम हर टेस्ट के बीच का समय धीमा करने के लिए बदल सकते हैं: **--scan-delay** _**<time>**_**;** **--max-scan-delay** _**<time>**_

हम packets per second की संख्या बदल सकते हैं: **--min-rate** _**<number>**_**;** **--max-rate** _**<number>**_

कई पोर्ट्स जब filtered या closed होते हैं तो जवाब देने में अधिक समय लेते हैं। यदि हम केवल open ones में रुचि रखते हैं, तो हम तेज़ हो सकते हैं: **--defeat-rst-ratelimit**

Nmap की aggression को परिभाषित करने के लिए: -T paranoid|sneaky|polite|normal|aggressive|insane

-T (0-1)

-T0 --> केवल 1 पोर्ट एक बार स्कैन करता है और अगले के लिए 5min तक रुकता है

-T1 और T2 --> बहुत समान पर केवल 15 और 0.4sec क्रमशः इंतजार करते हैं हर टेस्ट के बीच

-T3 --> डिफ़ॉल्ट ऑपरेशन, इसमें parallel scanning शामिल है

-T4 --> --max-rtt-timeout 1250ms --min-rtt-timeout 100ms --initial-rtt-timeout 500ms --max-retries 6 --max-scan-delay 10ms

-T5 --> --max-rtt-timeout 300ms --min-rtt-timeout 50ms --initial-rtt-timeout 250ms --max-retries 2 --host-timeout 15m --max-scan-delay 5ms

**Firewall/IDS**

वे पोर्ट्स तक पहुंचने की अनुमति नहीं देते और पैकेट्स का विश्लेषण करते हैं।

**-f** पैकेट्स को fragment करने के लिए, डिफ़ॉल्ट रूप से header के बाद 8bytes में fragment करता है, उस आकार को निर्दिष्ट करने के लिए ..mtu का उपयोग करते हैं (इसके साथ, -f का उपयोग न करें), offset का multiple of 8 होना चाहिए। **Version scanners और scripts fragmentation का समर्थन नहीं करते**

**-D decoy1,decoy2,ME** Nmap scanners भेजता है पर origin के रूप में अन्य IP addresses दिखाता है, इस तरह वे आपको छिपाते हैं। यदि आप सूची में ME डालते हैं, तो Nmap आपको वहीं रखेगा, बेहतर है कि आपके से पहले 5 या 6 रखें ताकि आप पूरी तरह mask हों। रैंडम IPs RND:<number> से जनरेट किए जा सकते हैं। ये TCP version detectors के साथ काम नहीं करते जो बिना कनेक्शन होते हैं। यदि आप नेटवर्क के अंदर हैं, तो आप सक्रिय IPs का उपयोग करने में रुचि रखते हैं, वरना यह पता लगाना बहुत आसान होगा कि आप अकेले सक्रिय हैं।

Random IPs उपयोग करने के लिए: nmap -D RND:10 Target_IP

**-S IP** जब Nmap आपका IP पता नहीं पकड़ता तब आपको इसे देना होता है। यह उन्हें यह सोचने का भी काम देता है कि कोई अन्य लक्ष्य उन्हें स्कैन कर रहा है।

**-e <interface>** इंटरफ़ेस चुनने के लिए

कई administrators entry ports सबके लिए खुले छोड़ देते हैं ताकि सब कुछ सही ढंग से काम करे और यह उनके लिए आसान हो। ये DNS पोर्ट्स या FTP पोर्ट्स हो सकते हैं... इस कमजोरी को खोजने के लिए Nmap में शामिल है: **--source-port** _**<portnumber>**_**;-g** _**<portnumber>**_ _ये समानार्थी हैं_

**--data** _**<hex string>**_ हेक्साडेसिमल टेक्स्ट भेजने के लिए: --data 0xdeadbeef और --data \xCA\xFE\x09

**--data-string** _**<string>**_ सामान्य टेक्स्ट भेजने के लिए: --data-string "Scan conducted by Security Ops, extension 7192"

**--data-length** _**<number>**_ Nmap केवल headers भेजता है, इसके साथ हम कुछ और बाइट्स जोड़वा सकते हैं (जो रैन्डम रूप से जनरेट होंगे)

IP पैकेट को पूरी तरह से configure करने के लिए **--ip-options** उपयोग करें

यदि आप भेजे और रिसीव किए जाने वाले पैकेट्स में options देखना चाहते हैं, तो --packet-trace निर्दिष्ट करें। IP options के साथ Nmap के उपयोग के उदाहरणों और अधिक जानकारी के लिए देखें [http://seclists.org/nmap-dev/2006/q3/52](http://seclists.org/nmap-dev/2006/q3/52).

**--ttl** _**<value>**_

**--randomize-hosts** हमले को कम स्पष्ट बनाने के लिए

**--spoof-mac** _**<MAC address, prefix, or vendor name>**_ MAC बदलने के लिए उदाहरण: Apple, 0, 01:02:03:04:05:06, deadbeefcafe, 0020F2, और Cisco

**--proxies** _**<Comma-separated list of proxy URLs>**_ प्रॉक्सी उपयोग करने के लिए, कभी-कभी कोई प्रॉक्सी उतने खुले कनेक्शन्स बनाए नहीं रखता जितने Nmap चाहता है इसलिए parallelism को संशोधित करने की ज़रूरत पड़ेगी: --max-parallelism

**-sP** ARP द्वारा हमारे नेटवर्क में hosts खोजने के लिए

कई administrators एक firewall नियम बनाते हैं जो किसी विशेष पोर्ट से आने वाले सभी पैकेट्स को पास कर देता है (जैसे 20,53 और 67), हम Nmap को बता सकते हैं कि हमारे पैकेट्स इन पोर्ट्स से भेजे जाएं: **nmap --source-port 53 IP**

**Outputs**

**-oN file** Normal output

**-oX file** XML output

**-oS file** Script kiddies output

**-oG file** Greppable output

**-oA file** All except -oS

**-v level** verbosity

**-d level** debugging

**--reason** host और state का कारण

**--stats-every time** हर उस समय पर हमें बताता है कि कैसे चल रहा है

**--packet-trace** यह देखने के लिए कि कौन से पैकेट्स बाहर जा रहे हैं, filters निर्दिष्ट किए जा सकते हैं जैसे: --version-trace या --script-trace

**--open** open, open|filtered और unfiltered दिखाता है

**--resume file** सारांश आउटपुट करता है

**Miscellaneous**

**-6** IPv6 की अनुमति देता है

**-A** -O -sV -sC --traceroute के बराबर है

**Run time**

Nmap चलते समय हम विकल्प बदल सकते हैं:

v / V verbosity लेवल बढ़ाने / घटाने के लिए

d / D debugging Level बढ़ाने / घटाने के लिए

p / P packet tracing ऑन / ऑफ करने के लिए

? runtime interaction help screen प्रिंट करने के लिए

**Vulscan**

Nmap script जो सर्विसेज़ के versions को एक offline database में देखता है (जो अन्य स्रोतों से डाउनलोड किया गया है) और संभावित vulnerabilities लौटाता है

यह जो DBs उपयोग करता है वे हैं:

1. Scipvuldb.csv | [http://www.scip.ch/en/?vuldb](http://www.scip.ch/en/?vuldb)
2. Cve.csv | [http://cve.mitre.org](http://cve.mitre.org/)
3. Osvdb.csv | [http://www.osvdb.org](http://www.osvdb.org/)
4. Securityfocus.csv | [http://www.securityfocus.com/bid/](http://www.securityfocus.com/bid/)
5. Securitytracker.csv | [http://www.securitytracker.com](http://www.securitytracker.com/)
6. Xforce.csv | [http://xforce.iss.net](http://xforce.iss.net/)
7. Exploitdb.csv | [http://www.exploit-db.com](http://www.exploit-db.com/)
8. Openvas.csv | [http://www.openvas.org](http://www.openvas.org/)

इसे डाउनलोड और Nmap फ़ोल्डर में इंस्टॉल करने के लिए:

wget http://www.computec.ch/projekte/vulscan/download/nmap_nse_vulscan-2.0.tar.gz && tar -czvf nmap_nse_vulscan-2.0.tar.gz vulscan/ && sudo cp -r vulscan/ /usr/share/nmap/scripts/

आपको DB पैकेज भी डाउनलोड करने होंगे और उन्हें /usr/share/nmap/scripts/vulscan/ में जोड़ना होगा

उपयोग:

सभी का उपयोग करने के लिए: sudo nmap -sV --script=vulscan HOST_TO_SCAN

विशिष्ट DB का उपयोग करने के लिए: sudo nmap -sV --script=vulscan --script-args vulscandb=cve.csv HOST_TO_SCAN

## Speed Up Nmap Service scan x16

According [**to this post**](https://joshua.hu/nmap-speedup-service-scanning-16x) you can speed up the nmap service analysis by modifying all the **`totalwaitms`** values in **`/usr/share/nmap/nmap-service-probes`** to **300** and **`tcpwrappedms`** to **200**.

Moreover, probes which do not have a specifically defined **`servicewaitms`** use a default value of **`5000`**. Therefore, we can either add values to each of the probes, or we can **compile nmap** ourselves and change the default value in [**service_scan.h**](https://github.com/nmap/nmap/blob/master/service_scan.h#L79).

If you don't want to change the values of **`totalwaitms`** and **`tcpwrappedms`** at all in the `/usr/share/nmap/nmap-service-probes` file, you can edit the [parsing code](https://github.com/nmap/nmap/blob/master/service_scan.cc#L1358) such that these values in the `nmap-service-probes` file are completely ignored.


## Build a static Nmap for restricted environments

In hardened or minimal Linux environments (containers, appliances), dynamically linked Nmap binaries often fail due to missing runtime loaders or shared libraries (e.g., /lib64/ld-linux-x86-64.so.2, libc.so). Building your own statically linked Nmap and bundling NSE data allows execution without installing system packages.

High-level approach
- Use a clean amd64 Ubuntu builder via Docker.
- Build OpenSSL and PCRE2 as static libraries.
- Build Nmap linking statically and using the included libpcap/libdnet to avoid dynamic deps.
- Bundle NSE scripts and data directories with the binary.

Discover target architecture (example)
```bash
uname -a
# If building from macOS/ARM/etc., pin the builder arch:
docker run --rm --platform=linux/amd64 -v "$(pwd)":/out -w /tmp ubuntu:22.04 bash -lc 'echo ok'
```
चरण 1 — टूलचेन तैयार करें
```bash
set -euo pipefail
export DEBIAN_FRONTEND=noninteractive
apt-get update && apt-get install -y --no-install-recommends \
build-essential ca-certificates curl bzip2 xz-utils pkg-config perl python3 file git \
automake autoconf libtool m4 zlib1g-dev
```
चरण 2 — OpenSSL (1.1.1w) को स्थैतिक रूप में बनाएं
```bash
OSSL="1.1.1w"
curl -fsSLO "https://www.openssl.org/source/openssl-$OSSL.tar.gz"
tar xzf "openssl-$OSSL.tar.gz" && cd "openssl-$OSSL"
./Configure no-shared no-zlib linux-x86_64 -static --prefix=/opt/ossl
make -j"$(nproc)" && make install_sw
cd /tmp
```
चरण 3 — स्थैतिक PCRE2 (10.43) बनाएं
```bash
PCRE2=10.43
curl -fsSLO "https://github.com/PCRE2Project/pcre2/releases/download/pcre2-$PCRE2/pcre2-$PCRE2.tar.bz2"
tar xjf "pcre2-$PCRE2.tar.bz2" && cd "pcre2-$PCRE2"
./configure --disable-shared --enable-static --prefix=/opt/pcre2
make -j"$(nproc)" && make install
cd /tmp
```
चरण 4 — static Nmap बनाना (7.98)
```bash
NMAP=7.98
curl -fsSLO "https://nmap.org/dist/nmap-$NMAP.tar.bz2"
tar xjf "nmap-$NMAP.tar.bz2" && cd "nmap-$NMAP"
export CPPFLAGS="-I/opt/ossl/include -I/opt/pcre2/include"
export LDFLAGS="-L/opt/ossl/lib -L/opt/pcre2/lib -static -static-libstdc++ -static-libgcc"
export LIBS="-lpcre2-8 -ldl -lpthread -lz"
./configure \
--with-openssl=/opt/ossl \
--with-libpcre=/opt/pcre2 \
--with-libpcap=included \
--with-libdnet=included \
--without-zenmap --without-ndiff --without-nmap-update
# Avoid building shared libpcap by accident
sed -i -e "s/^shared: /shared: #/" libpcap/Makefile || true
make -j1 V=1 nmap
strip nmap
```
मुख्य बिंदु
- -static, -static-libstdc++, -static-libgcc स्थैतिक लिंकिंग को बाध्य करते हैं।
- --with-libpcap=included/--with-libdnet=included का उपयोग system-shared libs से बचाता है।
- sed tweak मौजूद होने पर किसी shared libpcap target को निष्क्रिय कर देता है।

Step 5 — बाइनरी और NSE डेटा को बंडल करें
```bash
mkdir -p /out/nmap-bundle/nmap-data
cp nmap /out/nmap-bundle/nmap-linux-amd64-static
cp -r scripts nselib /out/nmap-bundle/nmap-data/
cp nse_main.lua nmap-services nmap-protocols nmap-service-probes \
nmap-mac-prefixes nmap-os-db nmap-payloads nmap-rpc \
/out/nmap-bundle/nmap-data/ 2>/dev/null || true

tar -C /out -czf /out/nmap-linux-amd64-static-bundle.tar.gz nmap-bundle
```
सत्यापन और ऑप्स नोट्स
- artifact पर file का उपयोग करके पुष्टि करें कि यह statically linked है।
- binary के साथ NSE डेटा रखें ताकि उन होस्ट्स पर जिनमें Nmap इंस्टॉल नहीं है, स्क्रिप्ट समानता बनी रहे।
- एक static binary होने पर भी, निष्पादन AppArmor/seccomp/SELinux द्वारा रोका जा सकता है; DNS/egress अभी भी काम करना चाहिए।
- Deterministic builds अस्पष्ट “static” binaries को डाउनलोड करने की तुलना में सप्लाई-चेन जोखिम को कम करते हैं।

One-liner (Dockerized)
<details>
<summary>बिल्ड, बंडल, और आर्टिफैक्ट जानकारी प्रिंट करें</summary>
```bash
docker run --rm --platform=linux/amd64 -v "$(pwd)":/out -w /tmp ubuntu:22.04 bash -lc '
set -euo pipefail
export DEBIAN_FRONTEND=noninteractive
apt-get update && apt-get install -y --no-install-recommends \
build-essential ca-certificates curl bzip2 xz-utils pkg-config perl python3 file git \
automake autoconf libtool m4 zlib1g-dev

OSSL="1.1.1w"; curl -fsSLO "https://www.openssl.org/source/openssl-$OSSL.tar.gz" \
&& tar xzf "openssl-$OSSL.tar.gz" && cd "openssl-$OSSL" \
&& ./Configure no-shared no-zlib linux-x86_64 -static --prefix=/opt/ossl \
&& make -j"$(nproc)" && make install_sw && cd /tmp

PCRE2=10.43; curl -fsSLO "https://github.com/PCRE2Project/pcre2/releases/download/pcre2-$PCRE2/pcre2-$PCRE2.tar.bz2" \
&& tar xjf "pcre2-$PCRE2.tar.bz2" && cd "pcre2-$PCRE2" \
&& ./configure --disable-shared --enable-static --prefix=/opt/pcre2 \
&& make -j"$(nproc)" && make install && cd /tmp

NMAP=7.98; curl -fsSLO "https://nmap.org/dist/nmap-$NMAP.tar.bz2" \
&& tar xjf "nmap-$NMAP.tar.bz2" && cd "nmap-$NMAP" \
&& export CPPFLAGS="-I/opt/ossl/include -I/opt/pcre2/include" \
&& export LDFLAGS="-L/opt/ossl/lib -L/opt/pcre2/lib -static -static-libstdc++ -static-libgcc" \
&& export LIBS="-lpcre2-8 -ldl -lpthread -lz" \
&& ./configure --with-openssl=/opt/ossl --with-libpcre=/opt/pcre2 --with-libpcap=included --with-libdnet=included --without-zenmap --without-ndiff --without-nmap-update \
&& sed -i -e "s/^shared: /shared: #/" libpcap/Makefile || true \
&& make -j1 V=1 nmap && strip nmap

mkdir -p /out/nmap-bundle/nmap-data \
&& cp nmap /out/nmap-bundle/nmap-linux-amd64-static \
&& cp -r scripts nselib /out/nmap-bundle/nmap-data/ \
&& cp nse_main.lua nmap-services nmap-protocols nmap-service-probes nmap-mac-prefixes nmap-os-db nmap-payloads nmap-rpc /out/nmap-bundle/nmap-data/ 2>/dev/null || true \
&& tar -C /out -czf /out/nmap-linux-amd64-static-bundle.tar.gz nmap-bundle \
&& echo "===== OUTPUT ====="; ls -lah /out; echo "===== FILE TYPE ====="; file /out/nmap-bundle/nmap-linux-amd64-static || true
'
```
</details>

## संदर्भ

- [Compiling static Nmap binary for jobs in restricted environments](https://www.pentestpartners.com/security-blog/compiling-static-nmap-binary-for-jobs-in-restricted-environments/)
- [Static Nmap Binary Generator (helper tool)](https://github.com/0x5ubt13/static_nmap_binary_generator)
- [OpenSSL sources](https://www.openssl.org/source/)
- [PCRE2 releases](https://github.com/PCRE2Project/pcre2/releases)
- [Nmap source tarballs](https://nmap.org/dist/)


{{#include ../../banners/hacktricks-training.md}}
