# Structural File‑Format Exploit Detection (0‑Click Chains)

{{#include ../../../banners/hacktricks-training.md}}

Diese Seite fasst praktische Techniken zusammen, um 0‑click mobile Exploit‑Dateien zu erkennen, indem strukturelle Invarianten ihrer Formate validiert werden, anstatt sich auf Byte‑Signaturen zu verlassen. Der Ansatz verallgemeinert über Samples, polymorphe Varianten und zukünftige Exploits, die dieselbe Parser‑Logik missbrauchen.

Kernidee: strukturelle Unmöglichkeiten und feldübergreifende Inkonsistenzen zu kodieren, die nur auftreten, wenn ein verwundbarer Decoder-/Parser‑Zustand erreicht wird.

Siehe auch:

{{#ref}}
pdf-file-analysis.md
{{#endref}}


## Why structure, not signatures

Wenn weaponisierte Samples nicht verfügbar sind und Payload‑Bytes mutieren, versagen traditionelle IOC-/YARA‑Patterns. Strukturelle Erkennung prüft das deklarierte Layout des Containers gegenüber dem, was für die Format‑Implementierung mathematisch oder semantisch möglich ist.

Typische Prüfungen:
- Validiere Tabellengrößen und Grenzen, abgeleitet aus der Spezifikation und sicheren Implementierungen
- Markiere illegale/undokumentierte Opcodes oder Zustandsübergänge in eingebettetem Bytecode
- Kreuzprüfe Metadaten gegen tatsächlich kodierte Stream‑Komponenten
- Erkenne widersprüchliche Felder, die auf Parser‑Verwirrung oder Integer‑Overflow‑Setups hinweisen

Nachfolgend konkrete, feldgetestete Muster für mehrere hochwirksame Chains.

---

## PDF/JBIG2 – FORCEDENTRY (CVE‑2021‑30860)

Target: JBIG2‑Symbol‑Dictionaries, eingebettet in PDFs (häufig verwendet beim mobilen MMS‑Parsing).

Strukturelle Signale:
- Widersprüchlicher Dictionary‑Zustand, der in benignem Inhalt nicht auftreten kann, aber erforderlich ist, um den Overflow in der arithmetischen Dekodierung auszulösen.
- Verdächtige Nutzung globaler Segmente in Kombination mit abnormalen Symbolzahlen während der Refinement‑Codierung.

Pseudo‑Logik:
```pseudo
# Detecting impossible dictionary state used by FORCEDENTRY
if input_symbols_count == 0 and (ex_syms > 0 and ex_syms < 4):
mark_malicious("JBIG2 impossible symbol dictionary state")
```
Praktische Triage:
- Identifiziere und extrahiere JBIG2 streams aus dem PDF
- pdfid/pdf-parser/peepdf zum Auffinden und Dumpen der Streams
- Überprüfe arithmetic coding flags und symbol dictionary parameters anhand der JBIG2 spec

Notes:
- Funktioniert ohne embedded payload signatures
- Niedrige FP-Rate in der Praxis, da der markierte Zustand mathematisch inkonsistent ist

---

## WebP/VP8L – BLASTPASS (CVE‑2023‑4863)

Target: WebP lossless (VP8L) Huffman prefix‑code tables.

Strukturelle Signale:
- Die Gesamtgröße der konstruierten Huffman-Tabellen überschreitet die sichere Obergrenze, die von den Referenz-/gepatchten Implementierungen erwartet wird, was die Voraussetzung für einen Überlauf impliziert.

Pseudo‑logik:
```pseudo
# Detect malformed Huffman table construction triggering overflow
let total_size = sum(table_sizes)
if total_size > 2954:   # example bound: FIXED_TABLE_SIZE + MAX_TABLE_SIZE
mark_malicious("VP8L oversized Huffman tables")
```
Praktische Triage:
- Prüfe WebP-Container-Chunks: VP8X + VP8L
- Analysiere VP8L-Präfixcodes und berechne die tatsächlich zugewiesenen Tabellengrößen

Hinweise:
- Robust gegenüber byte‑level polymorphism der Payload
- Die Grenze wird aus upstream-Limits/Patch-Analysen abgeleitet

---

## TrueType – TRIANGULATION (CVE‑2023‑41990)

Ziel: TrueType-Bytecode innerhalb von fpgm/prep/glyf-Programmen.

Strukturelle Signale:
- Vorhandensein undokumentierter/verbotener opcodes im Apple-Interpreter, die von der Exploit-Kette genutzt werden.

Pseudo‑Logik:
```pseudo
# Flag undocumented TrueType opcodes leveraged by TRIANGULATION
switch opcode:
case 0x8F, 0x90:
mark_malicious("Undocumented TrueType bytecode")
default:
continue
```
Praktische Triage:
- Font-Tabellen ausgeben (z. B. mit fontTools/ttx) und fpgm/prep/glyf-Programme scannen
- Es ist nicht nötig, den Interpreter vollständig zu emulieren, um aus Präsenzprüfungen Nutzen zu ziehen

Anmerkungen:
- Kann seltene FPs erzeugen, wenn nichtstandardmäßige Fonts unbekannte Opcodes enthalten; mit sekundären Tools validieren

---

## DNG/TIFF – CVE‑2025‑43300

Target: DNG/TIFF image metadata VS actual component count in encoded stream (e.g., JPEG‑Lossless SOF3).

Strukturelle Signale:
- Inkonsistenz zwischen EXIF/IFD-Feldern (SamplesPerPixel, PhotometricInterpretation) und der aus dem Image-Stream-Header geparsten Komponentenanzahl, die die Pipeline verwendet.

Pseudo‑logic:
```pseudo
# Metadata claims 2 samples per pixel but stream header exposes only 1 component
if samples_per_pixel == 2 and sof3_components == 1:
mark_malicious("DNG/TIFF metadata vs. stream mismatch")
```
Praktische Triage:
- Primäre IFD- und EXIF-Tags parsen
- Eingebetteten JPEG‑Lossless-Header (SOF3) finden und parsen; Komponentenanzahl vergleichen

Hinweise:
- In freier Wildbahn als ausgenutzt gemeldet; ausgezeichneter Kandidat für strukturelle Konsistenzprüfungen

---

## DNG/TIFF – Samsung libimagecodec.quram.so (CVE‑2025‑21042) + Angehängte ZIP payload (LANDFALL)

Ziel: DNG (von TIFF abgeleitete) Bilder, die ein eingebettetes ZIP-Archiv enthalten, das am EOF angehängt ist, um native payloads nach Parser RCE zu stagen.

Strukturale Signale:
- Datei-Magic zeigt TIFF/DNG (`II*\x00` or `MM\x00*`) aber der Dateiname imitiert JPEG (z. B. `.jpg`/`.jpeg` WhatsApp-Namensgebung).
- Vorhandensein eines ZIP Local File Header oder EOCD-Magic nahe EOF (`PK\x03\x04` or `PK\x05\x06`), das von keinem TIFF IFD-Datenbereich (strips/tiles/`JPEGInterchangeFormat`) referenziert wird.
- Ungewöhnlich große nachlaufende Daten jenseits des zuletzt referenzierten IFD-Datenblocks (hundert KB bis MB), konsistent mit einem gebündelten Archiv von .so-Modulen.

Pseudo‑logic:
```pseudo
# Detect appended ZIP payload hidden after DNG/TIFF data (Samsung chain)
if is_tiff_dng(magic):
ext = file_extension()
if ext in {".jpg", ".jpeg"}: mark_suspicious("Extension/magic mismatch: DNG vs JPEG")

zip_off = rfind_any(["PK\x05\x06", "PK\x03\x04"], search_window_last_n_bytes=8*1024*1024)
if zip_off >= 0:
end_dng = approx_end_of_tiff_data()  # max(end of Strip/Tile/JPEGInterchangeFormat regions)
if zip_off > end_dng + 0x200:
mark_malicious("DNG with appended ZIP payload (LANDFALL‑style)")
```
Praktische Triage:
- Format vs. Name identifizieren:
- file sample; exiftool -s -FileType -MIMEType sample
- ZIP-Footer/-Header nahe EOF lokalisieren und carve:
- off=$(grep -aboa -E $'PK\x05\x06|PK\x03\x04' sample.dng | tail -n1 | cut -d: -f1)
- dd if=sample.dng of=payload.zip bs=1 skip="$off"
- zipdetails -v payload.zip; unzip -l payload.zip
- Sinnprüfung: TIFF-Datenbereiche dürfen sich nicht mit dem carved ZIP-Bereich überschneiden:
- tiffdump -D sample.dng | egrep 'StripOffsets|TileOffsets|JPEGInterchangeFormat|StripByteCounts|TileByteCounts|JPEGInterchangeFormatLength'
- Überprüfe `max(offset+length) << zip_off`
- One‑shot carving (coarse): binwalk -eM sample.dng

Hinweise:
- Wurde in freier Wildbahn gegen Samsung’s libimagecodec.quram.so (CVE‑2025‑21042) ausgenutzt. Das angehängte ZIP enthielt native Module (z. B. loader + SELinux policy editor), die nach der RCE extrahiert/ausgeführt wurden.

---

## Implementierungsmuster und Leistung

Ein praktischer Scanner sollte:
- Datei­typ automatisch erkennen und nur relevante Analyzer einsetzen (PDF/JBIG2, WebP/VP8L, TTF, DNG/TIFF)
- Streaming/teilweises Parsen verwenden, um Speicherallokationen zu minimieren und frühe Beendigung zu ermöglichen
- Analysen parallel ausführen (thread‑pool) für Bulk‑Triage

Beispiel‑Workflow mit ElegantBouncer (open‑source Rust‑Implementierung dieser Checks):
```bash
# Scan a path recursively with structural detectors
$ elegant-bouncer --scan /path/to/directory

# Optional TUI for parallel scanning and real‑time alerts
$ elegant-bouncer --tui --scan /path/to/samples
```
---

## DFIR Tipps und Randfälle

- Eingebettete Objekte: PDFs können Bilder (JBIG2) und Schriftarten (TrueType) einbetten; extrahieren und rekursiv scannen
- Sicherheit bei Dekompression: Bibliotheken verwenden, die Tabellen/Puffer vor der Allokation strikt begrenzen
- Fehlalarme: Regeln konservativ halten, Widersprüche bevorzugen, die laut Spezifikation unmöglich sind
- Versionsdrift: Grenzen neu bestimmen (z. B. VP8L-Tabellengrößen), wenn Upstream-Parser ihre Limits ändern

---

## Verwandte Tools

- ElegantBouncer – struktureller Scanner für die oben genannten Erkennungen
- pdfid/pdf-parser/peepdf – PDF-Objekt-Extraktion und statische Analyse
- pdfcpu – PDF-Linter/Sanitizer
- fontTools/ttx – TrueType-Tabellen und Bytecode ausgeben
- exiftool – TIFF/DNG/EXIF-Metadaten lesen
- dwebp/webpmux – WebP-Metadaten und Chunks parsen

---

## References

- [ELEGANTBOUNCER: When You Can't Get the Samples but Still Need to Catch the Threat](https://www.msuiche.com/posts/elegantbouncer-when-you-cant-get-the-samples-but-still-need-to-catch-the-threat/)
- [ElegantBouncer project (GitHub)](https://github.com/msuiche/elegant-bouncer)
- [Researching FORCEDENTRY: Detecting the exploit with no samples](https://www.msuiche.com/posts/researching-forcedentry-detecting-the-exploit-with-no-samples/)
- [Researching BLASTPASS – Detecting the exploit inside a WebP file (Part 1)](https://www.msuiche.com/posts/researching-blastpass-detecting-the-exploit-inside-a-webp-file-part-1/)
- [Researching BLASTPASS – Analysing the Apple & Google WebP PoC file (Part 2)](https://www.msuiche.com/posts/researching-blastpass-analysing-the-apple-google-webp-poc-file-part-2/)
- [Researching TRIANGULATION – Detecting CVE‑2023‑41990 with single‑byte signatures](https://www.msuiche.com/posts/researching-triangulation-detecting-cve-2023-41990-with-single-byte-signatures/)
- [CVE‑2025‑43300: Critical vulnerability found in Apple’s DNG image processing](https://www.msuiche.com/posts/cve-2025-43300-critical-vulnerability-found-in-apples-dng-image-processing/)
- [LANDFALL: New Commercial-Grade Android Spyware in Exploit Chain Targeting Samsung Devices](https://unit42.paloaltonetworks.com/landfall-is-new-commercial-grade-android-spyware/)

{{#include ../../../banners/hacktricks-training.md}}
