# Structural File‑Format Exploit Detection (0‑Click Chains)

{{#include ../../../banners/hacktricks-training.md}}

На цій сторінці узагальнено практичні методи виявлення 0‑click mobile exploit files шляхом перевірки структурних інваріант формату замість покладання на byte signatures. Підхід узагальнюється на різні зразки, поліморфні варіанти та майбутні експлойти, що зловживають тією самою parser логікою.

Ключова ідея: кодувати структурні неможливості та міжполе невідповідності, які з'являються лише коли досягається вразливий decoder/parser стан.

See also:

{{#ref}}
pdf-file-analysis.md
{{#endref}}


## Why structure, not signatures

Коли weaponized samples недоступні, а payload bytes мутують, традиційні IOC/YARA патерни зазнають поразки. Structural detection перевіряє заявлену розмітку контейнера проти того, що математично або семантично можливо для реалізації формату.

Типові перевірки:
- Валідувати розміри таблиць і межі, виведені зі spec та безпечних імплементацій
- Позначати illegal/undocumented opcodes або state transitions в embedded bytecode
- Перевіряти metadata VS фактичні компоненти закодованого stream
- Виявляти суперечливі поля, які вказують на parser confusion або integer overflow set‑ups

Нижче — конкретні, перевірені в полі шаблони для кількох високовпливових chains.

---

## PDF/JBIG2 – FORCEDENTRY (CVE‑2021‑30860)

Target: JBIG2 symbol dictionaries embedded inside PDFs (often used in mobile MMS parsing).

Structural signals:
- Contradictory dictionary state that cannot occur in benign content but is required to trigger the overflow in arithmetic decoding.
- Suspicious use of global segments combined with abnormal symbol counts during refinement coding.

Псевдо‑логіка:
```pseudo
# Detecting impossible dictionary state used by FORCEDENTRY
if input_symbols_count == 0 and (ex_syms > 0 and ex_syms < 4):
mark_malicious("JBIG2 impossible symbol dictionary state")
```
Практичний тріаж:
- Виявити та витягти JBIG2-потоки з PDF
- pdfid/pdf-parser/peepdf для знаходження та дампу потоків
- Перевірити прапори арифметичного кодування та параметри словника символів відповідно до JBIG2 spec

Notes:
- Works without embedded payload signatures
- Low FP in practice because the flagged state is mathematically inconsistent

---

## WebP/VP8L – BLASTPASS (CVE‑2023‑4863)

Target: префіксні таблиці кодів Huffman для WebP lossless (VP8L).

Структурні ознаки:
- Загальний розмір збудованих таблиць Huffman перевищує безпечну верхню межу, очікувану референсними/запатченими реалізаціями, що вказує на передумову переповнення.

Псевдо‑логіка:
```pseudo
# Detect malformed Huffman table construction triggering overflow
let total_size = sum(table_sizes)
if total_size > 2954:   # example bound: FIXED_TABLE_SIZE + MAX_TABLE_SIZE
mark_malicious("VP8L oversized Huffman tables")
```
Практична перевірка:
- Перевірити чанки контейнера WebP: VP8X + VP8L
- Розібрати VP8L prefix codes і обчислити фактичні розміри виділених таблиць

Примітки:
- Стійкий до байтового поліморфізму payload
- Межа виведена з аналізу upstream limits/patch

---

## TrueType – TRIANGULATION (CVE‑2023‑41990)

Target: TrueType bytecode inside fpgm/prep/glyf programs.

Структурні сигнали:
- Наявність undocumented/forbidden opcodes в Apple’s interpreter, які використовуються exploit chain.

Псевдо‑логіка:
```pseudo
# Flag undocumented TrueType opcodes leveraged by TRIANGULATION
switch opcode:
case 0x8F, 0x90:
mark_malicious("Undocumented TrueType bytecode")
default:
continue
```
Практичний тріаж:
- Вивантажити таблиці шрифтів (наприклад, за допомогою fontTools/ttx) та просканувати програми fpgm/prep/glyf
- Немає потреби повністю емулювати інтерпретатор, щоб отримати користь від перевірок на наявність

Примітки:
- Може давати рідкісні FPs, якщо нестандартні шрифти містять невідомі опкоди; перевірте за допомогою додаткових інструментів

---

## DNG/TIFF – CVE‑2025‑43300

Target: метадані зображення DNG/TIFF проти фактичної кількості компонентів у закодованому потоці (наприклад, JPEG‑Lossless SOF3).

Структурні ознаки:
- Невідповідність між полями EXIF/IFD (SamplesPerPixel, PhotometricInterpretation) та кількістю компонентів, розібраною з заголовка потоку зображення, що використовується в pipeline.

Псевдо‑логіка:
```pseudo
# Metadata claims 2 samples per pixel but stream header exposes only 1 component
if samples_per_pixel == 2 and sof3_components == 1:
mark_malicious("DNG/TIFF metadata vs. stream mismatch")
```
Practical triage:
- Розпарсити первинні IFD і EXIF теги
- Знайти та розпарсити вбудований заголовок JPEG‑Lossless (SOF3) і порівняти кількість компонентів

Notes:
- Повідомлялося про експлуатацію в реальних умовах; відмінний кандидат для перевірок структурної узгодженості

---

## Implementation patterns and performance

A practical scanner should:
- Автоматично визначати тип файлу та запускати тільки релевантні аналізатори (PDF/JBIG2, WebP/VP8L, TTF, DNG/TIFF)
- Парсити в потоковому/частковому режимі, щоб мінімізувати виділення пам'яті та дозволити раннє завершення
- Запускати аналізи паралельно (thread‑pool) для масового triage

Example workflow with ElegantBouncer (відкрита реалізація на Rust цих перевірок):
```bash
# Scan a path recursively with structural detectors
$ elegant-bouncer --scan /path/to/directory

# Optional TUI for parallel scanning and real‑time alerts
$ elegant-bouncer --tui --scan /path/to/samples
```
---

## DFIR поради та крайові випадки

- Embedded objects: PDFs may embed images (JBIG2) and fonts (TrueType); extract and recursively scan
- Безпека декомпресії: використовуйте бібліотеки, що жорстко обмежують таблиці/буфери перед виділенням пам'яті
- Хибні спрацьовування: тримайте правила консервативними, віддавайте перевагу протиріччям, які неможливі за специфікацією
- Version drift: re‑baseline bounds (e.g., VP8L table sizes) when upstream parsers change limits

---

## Пов'язані інструменти

- ElegantBouncer – структурний сканер для наведених вище виявлень
- pdfid/pdf-parser/peepdf – витяг об'єктів PDF та статичний аналіз
- pdfcpu – лінтер/санітизатор PDF
- fontTools/ttx – дамп таблиць TrueType та байткоду
- exiftool – читати метадані TIFF/DNG/EXIF
- dwebp/webpmux – parse WebP metadata and chunks

---

## References

- [ELEGANTBOUNCER: When You Can't Get the Samples but Still Need to Catch the Threat](https://www.msuiche.com/posts/elegantbouncer-when-you-cant-get-the-samples-but-still-need-to-catch-the-threat/)
- [ElegantBouncer project (GitHub)](https://github.com/msuiche/elegant-bouncer)
- [Researching FORCEDENTRY: Detecting the exploit with no samples](https://www.msuiche.com/posts/researching-forcedentry-detecting-the-exploit-with-no-samples/)
- [Researching BLASTPASS – Detecting the exploit inside a WebP file (Part 1)](https://www.msuiche.com/posts/researching-blastpass-detecting-the-exploit-inside-a-webp-file-part-1/)
- [Researching BLASTPASS – Analysing the Apple & Google WebP PoC file (Part 2)](https://www.msuiche.com/posts/researching-blastpass-analysing-the-apple-google-webp-poc-file-part-2/)
- [Researching TRIANGULATION – Detecting CVE‑2023‑41990 with single‑byte signatures](https://www.msuiche.com/posts/researching-triangulation-detecting-cve-2023-41990-with-single-byte-signatures/)
- [CVE‑2025‑43300: Critical vulnerability found in Apple’s DNG image processing](https://www.msuiche.com/posts/cve-2025-43300-critical-vulnerability-found-in-apples-dng-image-processing/)

{{#include ../../../banners/hacktricks-training.md}}
