# Detección de Exploits en Formatos Estructurales de Archivos (0‑Click Chains)

{{#include ../../../banners/hacktricks-training.md}}

Esta página resume técnicas prácticas para detectar archivos exploit móviles de 0‑click validando invariantes estructurales de sus formatos en lugar de depender de firmas de bytes. El enfoque se generaliza entre muestras, variantes polimórficas y futuros exploits que abusen de la misma lógica del parser.

Idea clave: codificar imposibilidades estructurales e inconsistencias entre campos que solo aparecen cuando se alcanza un estado vulnerable del decodificador/parser.

Ver también:

{{#ref}}
pdf-file-analysis.md
{{#endref}}


## Por qué la estructura, no las firmas

Cuando muestras weaponized no están disponibles y los bytes del payload mutan, los patrones tradicionales IOC/YARA fallan. La detección estructural inspecciona la disposición declarada del contenedor frente a lo que es matemática o semánticamente posible para la implementación del formato.

Comprobaciones típicas:
- Validar tamaños de tablas y límites derivados de la especificación y de implementaciones seguras
- Señalar opcodes ilegales/no documentados o transiciones de estado en bytecode embebido
- Contrastar metadata VS los componentes reales del stream codificado
- Detectar campos contradictorios que indican confusión del parser o preparaciones para integer overflow

Abajo hay patrones concretos, probados en campo, para varias cadenas de alto impacto.

---

## PDF/JBIG2 – FORCEDENTRY (CVE‑2021‑30860)

Target: JBIG2 symbol dictionaries embedded inside PDFs (often used in mobile MMS parsing).

Señales estructurales:
- Estado contradictorio del diccionario que no puede ocurrir en contenido benigno pero es necesario para disparar el desbordamiento en la decodificación aritmética.
- Uso sospechoso de segmentos globales combinado con conteos anormales de símbolos durante la codificación de refinamiento.

Pseudo‑lógica:
```pseudo
# Detecting impossible dictionary state used by FORCEDENTRY
if input_symbols_count == 0 and (ex_syms > 0 and ex_syms < 4):
mark_malicious("JBIG2 impossible symbol dictionary state")
```
Triaje práctico:
- Identificar y extraer streams JBIG2 del PDF
- pdfid/pdf-parser/peepdf para localizar y volcar streams
- Verificar flags de codificación aritmética y parámetros del diccionario de símbolos contra la especificación JBIG2

Notas:
- Funciona sin firmas de payload embebido
- Bajo FP en la práctica porque el estado marcado es matemáticamente inconsistente

---

## WebP/VP8L – BLASTPASS (CVE‑2023‑4863)

Objetivo: WebP lossless (VP8L) tablas de códigos prefijo Huffman.

Señales estructurales:
- El tamaño total de las tablas Huffman construidas excede el límite superior seguro esperado por las implementaciones de referencia/parchadas, lo que implica la precondición de desbordamiento.

Pseudo‑lógica:
```pseudo
# Detect malformed Huffman table construction triggering overflow
let total_size = sum(table_sizes)
if total_size > 2954:   # example bound: FIXED_TABLE_SIZE + MAX_TABLE_SIZE
mark_malicious("VP8L oversized Huffman tables")
```
Triaje práctico:
- Comprueba los chunks del contenedor WebP: VP8X + VP8L
- Analiza los códigos de prefijo de VP8L y calcula los tamaños reales de las tablas asignadas

Notas:
- Robusto frente al polimorfismo a nivel de bytes del payload
- El límite se deriva del análisis de límites/parches upstream

---

## TrueType – TRIANGULATION (CVE‑2023‑41990)

Objetivo: bytecode de TrueType dentro de los programas fpgm/prep/glyf.

Señales estructurales:
- Presencia de opcodes no documentados/prohibidos en el intérprete de Apple utilizado por la cadena de exploit.

Pseudo‑lógica:
```pseudo
# Flag undocumented TrueType opcodes leveraged by TRIANGULATION
switch opcode:
case 0x8F, 0x90:
mark_malicious("Undocumented TrueType bytecode")
default:
continue
```
Practical triage:
- Extraer tablas de fuentes (p. ej., usando fontTools/ttx) y escanear programas fpgm/prep/glyf
- No es necesario emular completamente el intérprete para obtener valor de las comprobaciones de presencia

Notes:
- Puede producir FPs raros si fuentes no estándar incluyen opcodes desconocidos; validar con herramientas secundarias

---

## DNG/TIFF – CVE‑2025‑43300

Target: DNG/TIFF image metadata VS actual component count in encoded stream (e.g., JPEG‑Lossless SOF3).

Structural signals:
- Inconsistency between EXIF/IFD fields (SamplesPerPixel, PhotometricInterpretation) and the component count parsed from the image stream header used by the pipeline.

Pseudo‑logic:
```pseudo
# Metadata claims 2 samples per pixel but stream header exposes only 1 component
if samples_per_pixel == 2 and sof3_components == 1:
mark_malicious("DNG/TIFF metadata vs. stream mismatch")
```
Triaje práctico:
- Analizar las etiquetas primarias IFD y EXIF
- Localizar y parsear el JPEG‑Lossless header (SOF3) embebido y comparar el conteo de componentes

Notas:
- Reportado explotado en entornos reales; excelente candidato para comprobaciones de consistencia estructural

---

## Patrones de implementación y rendimiento

Un escáner práctico debería:
- Detectar automáticamente el tipo de archivo y ejecutar solo los analizadores relevantes (PDF/JBIG2, WebP/VP8L, TTF, DNG/TIFF)
- Procesar en streaming/parsear parcialmente para minimizar asignaciones y permitir terminación temprana
- Ejecutar análisis en paralelo (thread‑pool) para triaje masivo

Ejemplo de flujo de trabajo con ElegantBouncer (implementación en Rust de código abierto de estas comprobaciones):
```bash
# Scan a path recursively with structural detectors
$ elegant-bouncer --scan /path/to/directory

# Optional TUI for parallel scanning and real‑time alerts
$ elegant-bouncer --tui --scan /path/to/samples
```
---

## Consejos DFIR y casos límite

- Objetos embebidos: los PDFs pueden incrustar imágenes (JBIG2) y fuentes (TrueType); extraer y escanear recursivamente
- Seguridad en la descompresión: usar bibliotecas que limiten de forma estricta tablas/buffers antes de la asignación
- Falsos positivos: mantener las reglas conservadoras, favorecer contradicciones que sean imposibles según la especificación
- Deriva de versiones: recalibrar los límites de referencia (p. ej., tamaños de tablas VP8L) cuando los parsers upstream cambien los límites

---

## Herramientas relacionadas

- ElegantBouncer – escáner estructural para las detecciones anteriores
- pdfid/pdf-parser/peepdf – extracción de objetos PDF y análisis estático
- pdfcpu – linter/sanitizador de PDF
- fontTools/ttx – volcar tablas TrueType y bytecode
- exiftool – leer metadatos TIFF/DNG/EXIF
- dwebp/webpmux – analizar metadatos y chunks de WebP

---

## Referencias

- [ELEGANTBOUNCER: When You Can't Get the Samples but Still Need to Catch the Threat](https://www.msuiche.com/posts/elegantbouncer-when-you-cant-get-the-samples-but-still-need-to-catch-the-threat/)
- [ElegantBouncer project (GitHub)](https://github.com/msuiche/elegant-bouncer)
- [Researching FORCEDENTRY: Detecting the exploit with no samples](https://www.msuiche.com/posts/researching-forcedentry-detecting-the-exploit-with-no-samples/)
- [Researching BLASTPASS – Detecting the exploit inside a WebP file (Part 1)](https://www.msuiche.com/posts/researching-blastpass-detecting-the-exploit-inside-a-webp-file-part-1/)
- [Researching BLASTPASS – Analysing the Apple & Google WebP PoC file (Part 2)](https://www.msuiche.com/posts/researching-blastpass-analysing-the-apple-google-webp-poc-file-part-2/)
- [Researching TRIANGULATION – Detecting CVE‑2023‑41990 with single‑byte signatures](https://www.msuiche.com/posts/researching-triangulation-detecting-cve-2023-41990-with-single-byte-signatures/)
- [CVE‑2025‑43300: Critical vulnerability found in Apple’s DNG image processing](https://www.msuiche.com/posts/cve-2025-43300-critical-vulnerability-found-in-apples-dng-image-processing/)

{{#include ../../../banners/hacktricks-training.md}}
