# Structural File‑Format Exploit Detection (0‑Click Chains)

{{#include ../../../banners/hacktricks-training.md}}

Esta página resume técnicas prácticas para detectar archivos exploit móviles 0‑click validando invariantes estructurales de sus formatos en lugar de depender de firmas de bytes. El enfoque se generaliza entre muestras, variantes polimórficas y futuros exploits que abusan de la misma lógica del parser.

Idea clave: codificar imposibilidades estructurales e inconsistencias entre campos que solo aparecen cuando se alcanza un estado vulnerable del parser.

Ver también:

{{#ref}}
pdf-file-analysis.md
{{#endref}}


## Why structure, not signatures

Cuando weaponized samples no están disponibles y los payload bytes mutan, los patrones tradicionales IOC/YARA fallan. La detección estructural inspecciona la disposición declarada del contenedor frente a lo que es matemática o semánticamente posible para la implementación del formato.

Comprobaciones típicas:
- Validar tamaños de tablas y límites derivados de la spec y de implementaciones seguras
- Señalar opcodes ilegales/no documentados o transiciones de estado en bytecode embebido
- Contrastar metadatos VS componentes reales del stream codificado
- Detectar campos contradictorios que indiquen confusión del parser o setups para integer overflow

A continuación hay patrones concretos, probados en campo, para múltiples cadenas de alto impacto.

---

## PDF/JBIG2 – FORCEDENTRY (CVE‑2021‑30860)

Objetivo: diccionarios de símbolos JBIG2 embebidos dentro de PDFs (a menudo usados en el parsing de MMS en mobile).

Señales estructurales:
- Estado contradictorio del diccionario que no puede ocurrir en contenido benigno pero que es requerido para disparar el overflow en arithmetic decoding.
- Uso sospechoso de segmentos globales combinado con conteos de símbolos anormales durante la refinement coding.

Pseudo‑lógica:
```pseudo
# Detecting impossible dictionary state used by FORCEDENTRY
if input_symbols_count == 0 and (ex_syms > 0 and ex_syms < 4):
mark_malicious("JBIG2 impossible symbol dictionary state")
```
Triaje práctico:
- Identificar y extraer flujos JBIG2 del PDF
- pdfid/pdf-parser/peepdf para localizar y volcar flujos
- Verificar las banderas de codificación aritmética y los parámetros del diccionario de símbolos según la especificación JBIG2

Notas:
- Funciona sin firmas de payload embebido
- Baja tasa de FP en la práctica porque el estado marcado es matemáticamente inconsistente

---

## WebP/VP8L – BLASTPASS (CVE‑2023‑4863)

Objetivo: tablas de código prefijo Huffman en WebP lossless (VP8L).

Señales estructurales:
- El tamaño total de las tablas Huffman construidas excede el límite superior seguro esperado por las implementaciones de referencia/parcheadas, lo que implica la precondición de overflow.

Pseudo-lógica:
```pseudo
# Detect malformed Huffman table construction triggering overflow
let total_size = sum(table_sizes)
if total_size > 2954:   # example bound: FIXED_TABLE_SIZE + MAX_TABLE_SIZE
mark_malicious("VP8L oversized Huffman tables")
```
Triaje práctico:
- Verificar los chunks del contenedor WebP: VP8X + VP8L
- Parsear los prefix codes de VP8L y calcular los tamaños de tabla realmente asignados

Notas:
- Robusto frente al polimorfismo a nivel de bytes del payload
- El límite se deriva de los límites y del análisis de parches upstream

---

## TrueType – TRIANGULATION (CVE‑2023‑41990)

Objetivo: bytecode de TrueType dentro de los programas fpgm/prep/glyf.

Señales estructurales:
- Presencia de opcodes no documentados/prohibidos en el intérprete de Apple usado por la cadena de explotación.

Pseudo‑lógica:
```pseudo
# Flag undocumented TrueType opcodes leveraged by TRIANGULATION
switch opcode:
case 0x8F, 0x90:
mark_malicious("Undocumented TrueType bytecode")
default:
continue
```
Triaje práctico:
- Volcar tablas de fuentes (p. ej., usando fontTools/ttx) y escanear los programas fpgm/prep/glyf
- No es necesario emular completamente el intérprete para obtener valor de comprobaciones de presencia

Notas:
- Puede producir FPs raros si fuentes no estándar incluyen opcodes desconocidos; validar con herramientas secundarias

---

## DNG/TIFF – CVE‑2025‑43300

Objetivo: metadatos de imagen DNG/TIFF vs el recuento real de componentes en el flujo codificado (p. ej., JPEG‑Lossless SOF3).

Señales estructurales:
- Inconsistencia entre los campos EXIF/IFD (SamplesPerPixel, PhotometricInterpretation) y el recuento de componentes analizado desde el encabezado del flujo de imagen usado por la pipeline.

Pseudo‑lógica:
```pseudo
# Metadata claims 2 samples per pixel but stream header exposes only 1 component
if samples_per_pixel == 2 and sof3_components == 1:
mark_malicious("DNG/TIFF metadata vs. stream mismatch")
```
Triaje práctico:
- Analizar las etiquetas IFD primarias y EXIF
- Localizar y analizar el encabezado JPEG‑Lossless embebido (SOF3) y comparar el número de componentes

Notas:
- Reportado explotado en entornos reales; excelente candidato para comprobaciones de consistencia estructural

---

## DNG/TIFF – Samsung libimagecodec.quram.so (CVE‑2025‑21042) + Appended ZIP payload (LANDFALL)

Objetivo: imágenes DNG (derivadas de TIFF) que contienen un archivo ZIP embebido añadido al EOF para desplegar payloads nativos tras una RCE en el parser.

Señales estructurales:
- El magic del archivo indica TIFF/DNG (`II*\x00` or `MM\x00*`) pero el nombre de archivo imita JPEG (p. ej., `.jpg`/`.jpeg` en nombres de WhatsApp).
- Presencia de un ZIP Local File Header o magic EOCD cerca del EOF (`PK\x03\x04` or `PK\x05\x06`) que no está referenciado por ninguna región de datos IFD de TIFF (strips/tiles/`JPEGInterchangeFormat`).
- Datos finales inusualmente grandes más allá del último bloque de datos IFD referenciado (cientos de KB a MB), consistente con un archivo empaquetado de módulos .so.

Pseudo‑lógica:
```pseudo
# Detect appended ZIP payload hidden after DNG/TIFF data (Samsung chain)
if is_tiff_dng(magic):
ext = file_extension()
if ext in {".jpg", ".jpeg"}: mark_suspicious("Extension/magic mismatch: DNG vs JPEG")

zip_off = rfind_any(["PK\x05\x06", "PK\x03\x04"], search_window_last_n_bytes=8*1024*1024)
if zip_off >= 0:
end_dng = approx_end_of_tiff_data()  # max(end of Strip/Tile/JPEGInterchangeFormat regions)
if zip_off > end_dng + 0x200:
mark_malicious("DNG with appended ZIP payload (LANDFALL‑style)")
```
Triaje práctico:
- Identificar formato vs nombre:
- file sample; exiftool -s -FileType -MIMEType sample
- Localizar footer/header ZIP cerca del EOF y carve:
- off=$(grep -aboa -E $'PK\x05\x06|PK\x03\x04' sample.dng | tail -n1 | cut -d: -f1)
- dd if=sample.dng of=payload.zip bs=1 skip="$off"
- zipdetails -v payload.zip; unzip -l payload.zip
- Sanity‑check TIFF data regions don’t overlap the carved ZIP region:
- tiffdump -D sample.dng | egrep 'StripOffsets|TileOffsets|JPEGInterchangeFormat|StripByteCounts|TileByteCounts|JPEGInterchangeFormatLength'
- Verify `max(offset+length) << zip_off`
- One‑shot carving (coarse): binwalk -eM sample.dng

Notes:
- Exploited in the wild against Samsung’s libimagecodec.quram.so (CVE‑2025‑21042). The appended ZIP contained native modules (e.g., loader + SELinux policy editor) extracted/executed post‑RCE.

---

## Implementation patterns and performance

Un escáner práctico debe:
- Detectar automáticamente el tipo de archivo y despachar solo los analizadores relevantes (PDF/JBIG2, WebP/VP8L, TTF, DNG/TIFF)
- Stream/partial‑parse para minimizar asignaciones y permitir terminación temprana
- Ejecutar análisis en paralelo (thread‑pool) para triaje masivo

Example workflow with ElegantBouncer (open‑source Rust implementation of these checks):
```bash
# Scan a path recursively with structural detectors
$ elegant-bouncer --scan /path/to/directory

# Optional TUI for parallel scanning and real‑time alerts
$ elegant-bouncer --tui --scan /path/to/samples
```
---

## DFIR consejos y casos límite

- Objetos embebidos: los PDFs pueden incrustar imágenes (JBIG2) y fuentes (TrueType); extraer y escanear recursivamente
- Seguridad en la descompresión: usar bibliotecas que limiten estrictamente tablas/buffers antes de la asignación
- Falsos positivos: mantener las reglas conservadoras, favorecer contradicciones que sean imposibles según la especificación
- Deriva de versiones: reestablecer los límites de referencia (p. ej., VP8L table sizes) cuando los analizadores upstream cambien los límites

---

## Herramientas relacionadas

- ElegantBouncer – escáner estructural para las detecciones anteriores
- pdfid/pdf-parser/peepdf – extracción de objetos PDF y análisis estático
- pdfcpu – linter/sanitizador de PDF
- fontTools/ttx – volcar tablas TrueType y bytecode
- exiftool – leer metadatos TIFF/DNG/EXIF
- dwebp/webpmux – analizar metadatos y chunks de WebP

---

## Referencias

- [ELEGANTBOUNCER: When You Can't Get the Samples but Still Need to Catch the Threat](https://www.msuiche.com/posts/elegantbouncer-when-you-cant-get-the-samples-but-still-need-to-catch-the-threat/)
- [ElegantBouncer project (GitHub)](https://github.com/msuiche/elegant-bouncer)
- [Researching FORCEDENTRY: Detecting the exploit with no samples](https://www.msuiche.com/posts/researching-forcedentry-detecting-the-exploit-with-no-samples/)
- [Researching BLASTPASS – Detecting the exploit inside a WebP file (Part 1)](https://www.msuiche.com/posts/researching-blastpass-detecting-the-exploit-inside-a-webp-file-part-1/)
- [Researching BLASTPASS – Analysing the Apple & Google WebP PoC file (Part 2)](https://www.msuiche.com/posts/researching-blastpass-analysing-the-apple-google-webp-poc-file-part-2/)
- [Researching TRIANGULATION – Detecting CVE‑2023‑41990 with single‑byte signatures](https://www.msuiche.com/posts/researching-triangulation-detecting-cve-2023-41990-with-single-byte-signatures/)
- [CVE‑2025‑43300: Critical vulnerability found in Apple’s DNG image processing](https://www.msuiche.com/posts/cve-2025-43300-critical-vulnerability-found-in-apples-dng-image-processing/)
- [LANDFALL: New Commercial-Grade Android Spyware in Exploit Chain Targeting Samsung Devices](https://unit42.paloaltonetworks.com/landfall-is-new-commercial-grade-android-spyware/)

{{#include ../../../banners/hacktricks-training.md}}
