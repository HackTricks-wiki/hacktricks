# Rilevamento di exploit basati sul formato file strutturale (0‑Click Chains)

{{#include ../../../banners/hacktricks-training.md}}

Questa pagina riassume tecniche pratiche per rilevare file exploit 0‑click su mobile validando invarianti strutturali dei loro formati invece di affidarsi a firme di byte. L'approccio si generalizza attraverso campioni, varianti polimorfiche e futuri exploit che abusano della stessa logica del parser.

Idea chiave: codificare impossibilità strutturali e incoerenze tra campi che appaiono solo quando viene raggiunto uno stato vulnerabile del decoder/parser.

Vedi anche:

{{#ref}}
pdf-file-analysis.md
{{#endref}}


## Perché la struttura, non le firme

Quando campioni weaponizzati non sono disponibili e i byte del payload mutano, pattern IOC/YARA tradizionali falliscono. Il rilevamento strutturale ispeziona il layout dichiarato del contenitore rispetto a ciò che è matematicamente o semanticamente possibile per l'implementazione del formato.

Controlli tipici:
- Validare dimensioni delle tabelle e bound derivati dalla spec e da implementazioni sicure
- Segnalare opcode illegali/non documentati o transizioni di stato in bytecode embedded
- Verificare incrociati i metadata VS componenti effettivamente codificati nello stream
- Rilevare campi contraddittori che indicano confusione del parser o set‑up per overflow interi

Di seguito pattern concreti, testati sul campo, per diverse catene ad alto impatto.

---

## PDF/JBIG2 – FORCEDENTRY (CVE‑2021‑30860)

Obiettivo: dizionari di simboli JBIG2 incorporati all'interno dei PDF (spesso usati nel parsing MMS su dispositivi mobili).

Segnali strutturali:
- Stato del dizionario contraddittorio che non può verificarsi in contenuti benigni ma è necessario per innescare l'overflow nella decodifica aritmetica.
- Uso sospetto di segmenti globali combinato con conteggi di simboli anomali durante la codifica di refinement.

Pseudo‑logica:
```pseudo
# Detecting impossible dictionary state used by FORCEDENTRY
if input_symbols_count == 0 and (ex_syms > 0 and ex_syms < 4):
mark_malicious("JBIG2 impossible symbol dictionary state")
```
Triage pratico:
- Identificare ed estrarre JBIG2 streams dal PDF
- pdfid/pdf-parser/peepdf per localizzare e dumpare gli streams
- Verificare arithmetic coding flags e symbol dictionary parameters rispetto alla JBIG2 spec

Notes:
- Funziona senza firme di payload incorporate
- Low FP nella pratica perché lo stato segnalato è matematicamente inconsistente

---

## WebP/VP8L – BLASTPASS (CVE‑2023‑4863)

Obiettivo: WebP lossless (VP8L) Huffman prefix‑code tables.

Segnali strutturali:
- Total size of constructed Huffman tables exceeds the safe upper bound expected by the reference/patched implementations, implying the overflow precondition.

Pseudo‑logic:
```pseudo
# Detect malformed Huffman table construction triggering overflow
let total_size = sum(table_sizes)
if total_size > 2954:   # example bound: FIXED_TABLE_SIZE + MAX_TABLE_SIZE
mark_malicious("VP8L oversized Huffman tables")
```
Triage pratico:
- Controllare i chunk del contenitore WebP: VP8X + VP8L
- Analizzare i prefix codes di VP8L e calcolare le dimensioni effettivamente allocate delle tabelle

Note:
- Robusto contro il polimorfismo a livello di byte del payload
- Il bound è derivato dall'analisi di upstream limits/patch

---

## TrueType – TRIANGULATION (CVE‑2023‑41990)

Target: TrueType bytecode all'interno dei programmi fpgm/prep/glyf.

Segnali strutturali:
- Presenza di opcode non documentati/proibiti nell'interprete di Apple’s utilizzato dalla exploit chain.

Pseudo‑logica:
```pseudo
# Flag undocumented TrueType bytecode leveraged by TRIANGULATION
switch opcode:
case 0x8F, 0x90:
mark_malicious("Undocumented TrueType bytecode")
default:
continue
```
Triage pratico:
- Estrarre le tabelle dei font (es., usando fontTools/ttx) e scansionare i programmi fpgm/prep/glyf
- Non è necessario emulare completamente l'interprete per ottenere valore dai presence checks

Note:
- Può produrre rari FPs se font non standard includono opcode sconosciuti; convalidare con tooling secondario

---

## DNG/TIFF – CVE‑2025‑43300

Target: DNG/TIFF image metadata VS actual component count in encoded stream (e.g., JPEG‑Lossless SOF3).

Segnali strutturali:
- Incoerenza tra i campi EXIF/IFD (SamplesPerPixel, PhotometricInterpretation) e il conteggio dei componenti parsati dall'header dello stream immagine usato dalla pipeline.

Pseudo‑logica:
```pseudo
# Metadata claims 2 samples per pixel but stream header exposes only 1 component
if samples_per_pixel == 2 and sof3_components == 1:
mark_malicious("DNG/TIFF metadata vs. stream mismatch")
```
Triage pratico:
- Analizzare i tag IFD primari e EXIF
- Individuare e analizzare l'header JPEG‑Lossless incorporato (SOF3) e confrontare il numero di componenti

Note:
- Segnalato essere sfruttato in ambienti reali; ottimo candidato per controlli di coerenza strutturale

---

## DNG/TIFF – Samsung libimagecodec.quram.so (CVE‑2025‑21042) + Appended ZIP payload (LANDFALL)

Target: immagini DNG (derivate da TIFF) che contengono un archivio ZIP incorporato aggiunto all'EOF per posizionare payload nativi dopo parser RCE.

Indicatori strutturali:
- La magic del file indica TIFF/DNG (`II*\x00` or `MM\x00*`) ma il nome file imita JPEG (es., `.jpg`/`.jpeg` naming WhatsApp).
- Presenza di un ZIP Local File Header o della signature EOCD vicino all'EOF (`PK\x03\x04` or `PK\x05\x06`) che non è referenziata da nessuna regione dati TIFF IFD (strips/tiles/`JPEGInterchangeFormat`).
- Dati terminali insolitamente grandi oltre l'ultimo blocco dati IFD referenziato (centinaia di KB fino a MB), coerenti con un archivio incluso di moduli .so.

Pseudo‑logica:
```pseudo
# Detect appended ZIP payload hidden after DNG/TIFF data (Samsung chain)
if is_tiff_dng(magic):
ext = file_extension()
if ext in {".jpg", ".jpeg"}: mark_suspicious("Extension/magic mismatch: DNG vs JPEG")

zip_off = rfind_any(["PK\x05\x06", "PK\x03\x04"], search_window_last_n_bytes=8*1024*1024)
if zip_off >= 0:
end_dng = approx_end_of_tiff_data()  # max(end of Strip/Tile/JPEGInterchangeFormat regions)
if zip_off > end_dng + 0x200:
mark_malicious("DNG with appended ZIP payload (LANDFALL‑style)")
```
Triage pratico:
- Identify format vs name:
- file sample; exiftool -s -FileType -MIMEType sample
- Locate ZIP footer/header near EOF and carve:
- off=$(grep -aboa -E $'PK\x05\x06|PK\x03\x04' sample.dng | tail -n1 | cut -d: -f1)
- dd if=sample.dng of=payload.zip bs=1 skip="$off"
- zipdetails -v payload.zip; unzip -l payload.zip
- Verifica di base: le regioni dati TIFF non devono sovrapporsi alla carved ZIP region:
- tiffdump -D sample.dng | egrep 'StripOffsets|TileOffsets|JPEGInterchangeFormat|StripByteCounts|TileByteCounts|JPEGInterchangeFormatLength'
- Verificare `max(offset+length) << zip_off`
- One‑shot carving (coarse): binwalk -eM sample.dng

Note:
- Sfruttato in the wild contro la libimagecodec.quram.so di Samsung (CVE‑2025‑21042). Lo ZIP aggiunto conteneva moduli nativi (es., loader + SELinux policy editor) estratti/eseguiti post‑RCE.

---

## HEIF/AVIF – libheif & libde265 (CVE‑2024‑41311, CVE‑2025‑29482, CVE‑2025‑65586)

Target: container HEIF/AVIF analizzati da libheif (e build di ImageIO/OpenImageIO che lo bundle).

Segnali strutturali:
- Overlay items (iloc/iref) i cui rettangoli di origine eccedono le dimensioni dell'immagine base o i cui offset sono negativi/overflowing → scatena ImageOverlay::parse per accesso out‑of‑bounds (CVE‑2024‑41311).
- Grid items che referenziano ID di item non‑esistenti (ImageItem_Grid::get_decoder NULL deref, CVE‑2025‑43967) – semplice controllo strutturale, nessuna decodifica richiesta.
- Parametri SAO/loop‑filter o conteggi di tile che forzano allocazioni di tabelle maggiori del massimo consentito da libde265 (CVE‑2025‑29482): conteggi di band troppo alti o dimensioni di slice eccessive.
- Lunghezze/estensioni di box che puntano oltre EOF (tipico nei PoC CVE‑2025‑65586 scoperti via fuzzing).

Pseudo‑logica:
```pseudo
# HEIF overlay bounds check
for overlay in heif_overlays:
if overlay.x < 0 or overlay.y < 0: mark_malicious("HEIF overlay negative offset")
if overlay.x + overlay.w > base.w or overlay.y + overlay.h > base.h:
mark_malicious("HEIF overlay exceeds base image (CVE‑2024‑41311 pattern)")

# Grid item reference validation
for grid in heif_grids:
if any(ref_id not in item_ids):
mark_malicious("HEIF grid references missing item (CVE‑2025‑43967 pattern)")

# SAO / slice allocation guard
if sao_band_count > 32 or (tile_cols * tile_rows) > MAX_TILES or sao_eo_class not in {0..3}:
mark_malicious("HEIF SAO/tiling exceeds safe bounds (CVE‑2025‑29482 pattern)")
```
Triage pratico:
- Controllo rapido dei metadati senza decodifica completa:
- heif-info sample.heic
- oiiotool --info --stats sample.heic
- Validare le estensioni rispetto alla dimensione del file:
- heif-convert --verbose sample.heic /dev/null | grep -i extent
- Estrapolare box sospette per ispezione manuale:
- dd if=sample.heic bs=1 skip=$((box_off)) count=$((box_len)) of=box.bin

Note:
- Questi controlli individuano strutture malformate prima di una decodifica pesante; utili per gateway mail/MMS che devono solo prendere decisioni allow/deny.
- I limiti di libheif cambiano tra le versioni; ristabilire i valori costanti quando upstream cambia (1.18.x → 1.21.x ha reso più rigorosa la validazione di overlay e grid).

---

## Pattern di implementazione e prestazioni

Uno scanner pratico dovrebbe:
- Rilevare automaticamente il tipo di file e avviare solo gli analizzatori rilevanti (PDF/JBIG2, WebP/VP8L, TTF, DNG/TIFF, HEIF/AVIF)
- Eseguire parsing in streaming/parziale per minimizzare le allocazioni e consentire l'interruzione anticipata
- Eseguire analisi in parallelo (thread‑pool) per triage di massa

Esempio di workflow con ElegantBouncer (implementazione open‑source in Rust di questi controlli):
```bash
# Scan a path recursively with structural detectors
$ elegant-bouncer --scan /path/to/directory

# Optional TUI for parallel scanning and real‑time alerts
$ elegant-bouncer --tui --scan /path/to/samples
```
---

## Consigli DFIR e casi limite

- Oggetti incorporati: i PDF possono incorporare immagini (JBIG2) e font (TrueType); estrarre e scansionare ricorsivamente
- Sicurezza nella decompressione: usare librerie che limitano rigidamente tabelle/buffer prima dell'allocazione
- Falsi positivi: mantenere regole conservative, favorire contraddizioni impossibili secondo la specifica
- Deriva delle versioni: ricalibrare i limiti (p.es., dimensioni delle tabelle VP8L) quando i parser upstream cambiano i limiti

---

## Strumenti correlati

- ElegantBouncer – scanner strutturale per le rilevazioni precedenti
- pdfid/pdf-parser/peepdf – estrazione di oggetti PDF e analisi statica
- pdfcpu – linter/sanitizzatore per PDF
- fontTools/ttx – dump delle tabelle TrueType e del bytecode
- exiftool – leggere i metadata TIFF/DNG/EXIF
- dwebp/webpmux – analizzare i metadata e i chunk WebP
- heif-info/heif-convert (libheif) – ispezione della struttura HEIF/AVIF
- oiiotool – validare HEIF/AVIF tramite OpenImageIO

---

## Riferimenti

- [ELEGANTBOUNCER: When You Can't Get the Samples but Still Need to Catch the Threat](https://www.msuiche.com/posts/elegantbouncer-when-you-cant-get-the-samples-but-still-need-to-catch-the-threat/)
- [ElegantBouncer project (GitHub)](https://github.com/msuiche/elegant-bouncer)
- [Researching FORCEDENTRY: Detecting the exploit with no samples](https://www.msuiche.com/posts/researching-forcedentry-detecting-the-exploit-with-no-samples/)
- [Researching BLASTPASS – Detecting the exploit inside a WebP file (Part 1)](https://www.msuiche.com/posts/researching-blastpass-detecting-the-exploit-inside-a-webp-file-part-1/)
- [Researching BLASTPASS – Analysing the Apple & Google WebP PoC file (Part 2)](https://www.msuiche.com/posts/researching-blastpass-analysing-the-apple-google-webp-poc-file-part-2/)
- [Researching TRIANGULATION – Detecting CVE‑2023‑41990 with single‑byte signatures](https://www.msuiche.com/posts/researching-triangulation-detecting-cve-2023-41990-with-single-byte-signatures/)
- [CVE‑2025‑43300: Critical vulnerability found in Apple’s DNG image processing](https://www.msuiche.com/posts/cve-2025-43300-critical-vulnerability-found-in-apples-dng-image-processing/)
- [LANDFALL: New Commercial-Grade Android Spyware in Exploit Chain Targeting Samsung Devices](https://unit42.paloaltonetworks.com/landfall-is-new-commercial-grade-android-spyware/)
- [CVE‑2024‑41311 analysis (libheif overlay OOB)](https://www.wiz.io/vulnerability-database/cve/cve-2024-41311)
- [CVE‑2025‑65586 libheif metadata iterator flaw](https://securityonline.info/cve-2025-65586-libheif-flaw-exposes-image-decoders-to-denial-of-service/)

{{#include ../../../banners/hacktricks-training.md}}
