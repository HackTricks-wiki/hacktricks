# Détection d'exploits des formats de fichiers structurels (chaînes 0‑clic)

{{#include ../../../banners/hacktricks-training.md}}

Cette page résume des techniques pratiques pour détecter des fichiers d'exploit mobile 0‑clic en validant des invariants structurels de leurs formats plutôt qu'en se basant sur des signatures d'octets. L'approche se généralise aux échantillons, variantes polymorphes et futurs exploits qui abusent de la même logique de parser.

Idée clé : encoder des impossibilités structurelles et des incohérences inter‑champs qui n'apparaissent que lorsque un état vulnérable du decoder/parser est atteint.

Voir aussi :

{{#ref}}
pdf-file-analysis.md
{{#endref}}


## Pourquoi la structure, pas les signatures

Lorsque des échantillons weaponisés ne sont pas disponibles et que les octets du payload mutent, les patterns IOC/YARA traditionnels échouent. La détection structurelle inspecte la disposition déclarée du conteneur par rapport à ce qui est mathématiquement ou sémantiquement possible pour l'implémentation du format.

Vérifications typiques :
- Valider les tailles de tables et les bornes dérivées de la spécification et des implémentations sûres
- Signaler des opcodes illégaux/non documentés ou des transitions d'état dans le bytecode embarqué
- Cross‑check des métadonnées VS les composants réels du flux encodé
- Détecter des champs contradictoires indiquant une confusion du parser ou des configurations menant à un débordement d'entier

Ci‑dessous des schémas concrets, testés sur le terrain, pour plusieurs chaînes à fort impact.

---

## PDF/JBIG2 – FORCEDENTRY (CVE‑2021‑30860)

Target: JBIG2 symbol dictionaries embedded inside PDFs (often used in mobile MMS parsing).

Signaux structurels :
- État contradictoire du dictionnaire qui ne peut pas se produire dans du contenu bénin mais qui est nécessaire pour déclencher le débordement dans le décodage arithmétique.
- Utilisation suspecte de segments globaux combinée à des comptes de symboles anormaux lors du codage de raffinage.

Pseudo‑logique:
```pseudo
# Detecting impossible dictionary state used by FORCEDENTRY
if input_symbols_count == 0 and (ex_syms > 0 and ex_syms < 4):
mark_malicious("JBIG2 impossible symbol dictionary state")
```
Practical triage:
- Identifier et extraire les flux JBIG2 du PDF
- pdfid/pdf-parser/peepdf pour localiser et dumper les flux
- Vérifier les drapeaux de codage arithmétique et les paramètres du dictionnaire de symboles par rapport à la spec JBIG2

Notes:
- Fonctionne sans signatures de payload intégrées
- Faible FP en pratique car l'état signalé est mathématiquement incohérent

---

## WebP/VP8L – BLASTPASS (CVE‑2023‑4863)

Target: WebP lossless (VP8L) Huffman prefix‑code tables.

Structural signals:
- La taille totale des tables Huffman construites dépasse la borne supérieure sûre attendue par les implémentations de référence/patchées, impliquant la condition préalable de débordement.

Pseudo‑logic:
```pseudo
# Detect malformed Huffman table construction triggering overflow
let total_size = sum(table_sizes)
if total_size > 2954:   # example bound: FIXED_TABLE_SIZE + MAX_TABLE_SIZE
mark_malicious("VP8L oversized Huffman tables")
```
Triage pratique :
- Vérifier les blocs du conteneur WebP : VP8X + VP8L
- Analyser les codes de préfixe VP8L et calculer les tailles réelles des tables allouées

Remarques :
- Robuste face au polymorphisme au niveau des octets du payload
- La borne est déduite des limites upstream et de l'analyse des patchs

---

## TrueType – TRIANGULATION (CVE‑2023‑41990)

Cible : TrueType bytecode à l'intérieur des programmes fpgm/prep/glyf.

Signaux structurels :
- Présence d'opcodes non documentés/interdits dans l'interpréteur d'Apple utilisés par l'exploit chain.

Pseudo‑logique :
```pseudo
# Flag undocumented TrueType bytecode leveraged by TRIANGULATION
switch opcode:
case 0x8F, 0x90:
mark_malicious("Undocumented TrueType bytecode")
default:
continue
```
Triage pratique :
- Dumper les tables de polices (p.ex., en utilisant fontTools/ttx) et analyser les programmes fpgm/prep/glyf
- Pas besoin d'émuler complètement l'interpréteur pour tirer parti des vérifications de présence

Remarques :
- Peut produire de rares FPs si des polices non standard incluent des opcodes inconnus ; valider avec des outils secondaires

---

## DNG/TIFF – CVE‑2025‑43300

Target: DNG/TIFF image metadata VS actual component count in encoded stream (e.g., JPEG‑Lossless SOF3).

Structural signals:
- Inconsistency between EXIF/IFD fields (SamplesPerPixel, PhotometricInterpretation) and the component count parsed from the image stream header used by the pipeline.

Pseudo‑logic:
```pseudo
# Metadata claims 2 samples per pixel but stream header exposes only 1 component
if samples_per_pixel == 2 and sof3_components == 1:
mark_malicious("DNG/TIFF metadata vs. stream mismatch")
```
Practical triage:
- Analyser les IFD primaires et les tags EXIF
- Localiser et analyser l'en-tête JPEG‑Lossless intégré (SOF3) et comparer le nombre de composants

Notes :
- Signalé comme exploité en conditions réelles ; excellent candidat pour des vérifications de cohérence structurelle

---

## DNG/TIFF – Samsung libimagecodec.quram.so (CVE‑2025‑21042) + Appended ZIP payload (LANDFALL)

Cible : images DNG (dérivées de TIFF) contenant une archive ZIP intégrée ajoutée à EOF pour staging de payloads natifs après RCE du parser.

Structural signals:
- File magic indicates TIFF/DNG (`II*\x00` or `MM\x00*`) but filename mimics JPEG (e.g., `.jpg`/`.jpeg` WhatsApp naming).
- Presence of a ZIP Local File Header or EOCD magic near EOF (`PK\x03\x04` or `PK\x05\x06`) that is not referenced by any TIFF IFD data region (strips/tiles/`JPEGInterchangeFormat`).
- Unusually large trailing data beyond the last referenced IFD data block (hundreds of KB to MB), consistent with a bundled archive of .so modules.

Pseudo‑logic:
```pseudo
# Detect appended ZIP payload hidden after DNG/TIFF data (Samsung chain)
if is_tiff_dng(magic):
ext = file_extension()
if ext in {".jpg", ".jpeg"}: mark_suspicious("Extension/magic mismatch: DNG vs JPEG")

zip_off = rfind_any(["PK\x05\x06", "PK\x03\x04"], search_window_last_n_bytes=8*1024*1024)
if zip_off >= 0:
end_dng = approx_end_of_tiff_data()  # max(end of Strip/Tile/JPEGInterchangeFormat regions)
if zip_off > end_dng + 0x200:
mark_malicious("DNG with appended ZIP payload (LANDFALL‑style)")
```
Triage pratique :
- Identify format vs name:
- file sample; exiftool -s -FileType -MIMEType sample
- Locate ZIP footer/header near EOF and carve:
- off=$(grep -aboa -E $'PK\x05\x06|PK\x03\x04' sample.dng | tail -n1 | cut -d: -f1)
- dd if=sample.dng of=payload.zip bs=1 skip="$off"
- zipdetails -v payload.zip; unzip -l payload.zip
- Sanity‑check TIFF data regions don’t overlap the carved ZIP region:
- tiffdump -D sample.dng | egrep 'StripOffsets|TileOffsets|JPEGInterchangeFormat|StripByteCounts|TileByteCounts|JPEGInterchangeFormatLength'
- Verify `max(offset+length) << zip_off`
- One‑shot carving (coarse): binwalk -eM sample.dng

Notes:
- Exploité sur le terrain contre libimagecodec.quram.so de Samsung (CVE‑2025‑21042). Le ZIP appendu contenait des modules natifs (par ex., loader + éditeur de policy SELinux) extraits/exécutés après RCE.

---

## HEIF/AVIF – libheif & libde265 (CVE‑2024‑41311, CVE‑2025‑29482, CVE‑2025‑65586)

Cible: conteneurs HEIF/AVIF analysés par libheif (et les builds ImageIO/OpenImageIO qui l’incluent).

Signaux structurels:
- Overlay items (iloc/iref) whose source rectangles exceed the base image dimensions or whose offsets are negative/overflowing → triggers ImageOverlay::parse out‑of‑bounds (CVE‑2024‑41311).
- Grid items referencing non‑existent item IDs (ImageItem_Grid::get_decoder NULL deref, CVE‑2025‑43967) – vérification structurelle simple, aucun décodage requis.
- SAO/loop‑filter parameters or tile counts that force table allocations larger than the max allowed by libde265 (CVE‑2025‑29482): overly large band counts or slice dimensions.
- Box length/extent sizes that point past EOF (typical in CVE‑2025‑65586 PoCs discovered via fuzzing).

Pseudo‑logique:
```pseudo
# HEIF overlay bounds check
for overlay in heif_overlays:
if overlay.x < 0 or overlay.y < 0: mark_malicious("HEIF overlay negative offset")
if overlay.x + overlay.w > base.w or overlay.y + overlay.h > base.h:
mark_malicious("HEIF overlay exceeds base image (CVE‑2024‑41311 pattern)")

# Grid item reference validation
for grid in heif_grids:
if any(ref_id not in item_ids):
mark_malicious("HEIF grid references missing item (CVE‑2025‑43967 pattern)")

# SAO / slice allocation guard
if sao_band_count > 32 or (tile_cols * tile_rows) > MAX_TILES or sao_eo_class not in {0..3}:
mark_malicious("HEIF SAO/tiling exceeds safe bounds (CVE‑2025‑29482 pattern)")
```
Practical triage:
- Vérification rapide des métadonnées sans décodage complet:
- heif-info sample.heic
- oiiotool --info --stats sample.heic
- Valider les extents par rapport à la taille du fichier:
- heif-convert --verbose sample.heic /dev/null | grep -i extent
- Carve suspicious boxes for manual inspection:
- dd if=sample.heic bs=1 skip=$((box_off)) count=$((box_len)) of=box.bin

Remarques:
- Ces vérifications détectent une structure malformée avant un décodage lourd ; utile pour les passerelles mail/MMS qui n'ont besoin que de décisions autoriser/refuser.
- Les limites de libheif évoluent selon les versions ; réajuster les constantes de référence lorsque l'upstream change (1.18.x → 1.21.x a renforcé la validation des superpositions et des grilles).

---

## Modèles d'implémentation et performance

Un scanner pratique devrait :
- Détecter automatiquement le type de fichier et lancer uniquement les analyseurs pertinents (PDF/JBIG2, WebP/VP8L, TTF, DNG/TIFF, HEIF/AVIF)
- Traiter en flux / analyser partiellement pour minimiser les allocations et permettre une terminaison anticipée
- Exécuter les analyses en parallèle (pool de threads) pour le triage en masse

Exemple de workflow avec ElegantBouncer (implémentation Rust open‑source de ces vérifications):
```bash
# Scan a path recursively with structural detectors
$ elegant-bouncer --scan /path/to/directory

# Optional TUI for parallel scanning and real‑time alerts
$ elegant-bouncer --tui --scan /path/to/samples
```
---

## DFIR conseils et cas limites

- Objets intégrés : les PDFs peuvent intégrer des images (JBIG2) et des polices (TrueType) ; extraire et analyser de manière récursive
- Sécurité de la décompression : utiliser des bibliothèques qui limitent strictement les tailles de tables/tampons avant allocation
- Faux positifs : garder les règles conservatrices, privilégier les contradictions qui sont impossibles selon la spécification
- Dérive des versions : redéfinir les bornes de référence (par ex., tailles des tables VP8L) quand les parsers en amont changent leurs limites

---

## Outils associés

- ElegantBouncer – scanner structurel pour les détections ci‑dessus
- pdfid/pdf-parser/peepdf – extraction d'objets PDF et analyse statique
- pdfcpu – linter/sanitiseur PDF
- fontTools/ttx – exporter les tables TrueType et le bytecode
- exiftool – lire les métadonnées TIFF/DNG/EXIF
- dwebp/webpmux – analyser les métadonnées et blocs WebP
- heif-info/heif-convert (libheif) – inspection de la structure HEIF/AVIF
- oiiotool – valider HEIF/AVIF via OpenImageIO

---

## Références

- [ELEGANTBOUNCER : Quand vous ne pouvez pas obtenir les échantillons mais devez quand même capturer la menace](https://www.msuiche.com/posts/elegantbouncer-when-you-cant-get-the-samples-but-still-need-to-catch-the-threat/)
- [Projet ElegantBouncer (GitHub)](https://github.com/msuiche/elegant-bouncer)
- [Recherche sur FORCEDENTRY : détecter l'exploit sans échantillons](https://www.msuiche.com/posts/researching-forcedentry-detecting-the-exploit-with-no-samples/)
- [Recherche BLASTPASS – Détecter l'exploit à l'intérieur d'un fichier WebP (Partie 1)](https://www.msuiche.com/posts/researching-blastpass-detecting-the-exploit-inside-a-webp-file-part-1/)
- [Recherche BLASTPASS – Analyse du fichier PoC WebP d'Apple & Google (Partie 2)](https://www.msuiche.com/posts/researching-blastpass-analysing-the-apple-google-webp-poc-file-part-2/)
- [Recherche TRIANGULATION – Détecter CVE‑2023‑41990 avec des signatures mono-octet](https://www.msuiche.com/posts/researching-triangulation-detecting-cve-2023-41990-with-single-byte-signatures/)
- [CVE‑2025‑43300 : Vulnérabilité critique trouvée dans le traitement d'images DNG d'Apple](https://www.msuiche.com/posts/cve-2025-43300-critical-vulnerability-found-in-apples-dng-image-processing/)
- [LANDFALL : New Commercial-Grade Android Spyware in Exploit Chain Targeting Samsung Devices](https://unit42.paloaltonetworks.com/landfall-is-new-commercial-grade-android-spyware/)
- [Analyse CVE‑2024‑41311 (libheif overlay OOB)](https://www.wiz.io/vulnerability-database/cve/cve-2024-41311)
- [CVE‑2025‑65586 libheif metadata iterator flaw](https://securityonline.info/cve-2025-65586-libheif-flaw-exposes-image-decoders-to-denial-of-service/)

{{#include ../../../banners/hacktricks-training.md}}
