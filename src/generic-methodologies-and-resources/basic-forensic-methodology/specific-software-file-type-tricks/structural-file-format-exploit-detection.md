# Rilevamento di exploit su formati di file strutturali (0‑Click Chains)

{{#include ../../../banners/hacktricks-training.md}}

Questa pagina riassume tecniche pratiche per rilevare file exploit mobili 0‑click validando invarianti strutturali dei loro formati invece di basarsi su firme di byte. L'approccio si generalizza attraverso campioni, varianti polimorfiche e futuri exploit che abusano della stessa logica del parser.

Idea chiave: codificare impossibilità strutturali e incongruenze tra campi che compaiono solo quando si raggiunge uno stato vulnerabile del decoder/parser.

Vedi anche:

{{#ref}}
pdf-file-analysis.md
{{#endref}}


## Perché la struttura, non le firme

Quando i campioni weaponizzati non sono disponibili e i byte del payload mutano, i tradizionali pattern IOC/YARA falliscono. La detection strutturale ispeziona il layout dichiarato del contenitore rispetto a ciò che è matematicamente o semanticamente possibile per l'implementazione del formato.

Controlli tipici:
- Validare le dimensioni delle tabelle e i limiti derivati dalla spec e dalle implementazioni sicure
- Segnalare opcode illegali/non documentati o transizioni di stato in embedded bytecode
- Confrontare metadata VS componenti effettivamente codificati dello stream
- Rilevare campi contraddittori che indicano confusione del parser o set‑up per integer overflow

Di seguito pattern concreti, testati sul campo, per più chain ad alto impatto.

---

## PDF/JBIG2 – FORCEDENTRY (CVE‑2021‑30860)

Target: dizionari di simboli JBIG2 incorporati nei PDF (spesso usati nel parsing di MMS su mobile).

Segnali strutturali:
- Stato del dizionario contraddittorio che non può verificarsi in contenuto benigno ma è necessario per scatenare l'overflow nella decodifica aritmetica.
- Uso sospetto di global segments combinato con conteggi di simboli anomali durante la refinement coding.

Pseudo‑logica:
```pseudo
# Detecting impossible dictionary state used by FORCEDENTRY
if input_symbols_count == 0 and (ex_syms > 0 and ex_syms < 4):
mark_malicious("JBIG2 impossible symbol dictionary state")
```
Practical triage:
- Identify and extract JBIG2 streams from the PDF
- pdfid/pdf-parser/peepdf to locate and dump streams
- Verify arithmetic coding flags and symbol dictionary parameters against the JBIG2 spec

Notes:
- Works without embedded payload signatures
- Low FP in practice because the flagged state is mathematically inconsistent

---

## WebP/VP8L – BLASTPASS (CVE‑2023‑4863)

Obiettivo: WebP lossless (VP8L) Huffman prefix‑code tables.

Segnali strutturali:
- Total size of constructed Huffman tables exceeds the safe upper bound expected by the reference/patched implementations, implying the overflow precondition.

Pseudo‑logic:
```pseudo
# Detect malformed Huffman table construction triggering overflow
let total_size = sum(table_sizes)
if total_size > 2954:   # example bound: FIXED_TABLE_SIZE + MAX_TABLE_SIZE
mark_malicious("VP8L oversized Huffman tables")
```
Triage pratico:
- Controllare i chunk del container WebP: VP8X + VP8L
- Analizzare i prefix codes VP8L e calcolare le dimensioni effettivamente allocate delle tabelle

Note:
- Robusto contro il polimorfismo a livello di byte del payload
- Il vincolo è ricavato dall'analisi dei limiti/patch upstream

---

## TrueType – TRIANGULATION (CVE‑2023‑41990)

Target: bytecode TrueType all'interno dei programmi fpgm/prep/glyf.

Segnali strutturali:
- Presenza di opcode non documentati/proibiti nell'interpreter di Apple usato dalla exploit chain.

Pseudo‑logica:
```pseudo
# Flag undocumented TrueType opcodes leveraged by TRIANGULATION
switch opcode:
case 0x8F, 0x90:
mark_malicious("Undocumented TrueType bytecode")
default:
continue
```
Triage pratico:
- Dump font tables (ad es., usando fontTools/ttx) e scansionare i programmi fpgm/prep/glyf
- Non è necessario emulare completamente l'interprete per ottenere valore dai controlli di presenza

Note:
- Può produrre rari FPs se font non standard includono opcodes sconosciuti; convalidare con tooling secondario

---

## DNG/TIFF – CVE‑2025‑43300

Obiettivo: metadati immagine DNG/TIFF vs il reale conteggio dei componenti nello stream codificato (ad es., JPEG‑Lossless SOF3).

Segnali strutturali:
- Incoerenza tra i campi EXIF/IFD (SamplesPerPixel, PhotometricInterpretation) e il conteggio dei componenti estratto dall'header dello stream immagine utilizzato dalla pipeline.

Pseudo‑logica:
```pseudo
# Metadata claims 2 samples per pixel but stream header exposes only 1 component
if samples_per_pixel == 2 and sof3_components == 1:
mark_malicious("DNG/TIFF metadata vs. stream mismatch")
```
Triage pratico:
- Eseguire il parsing dei tag IFD ed EXIF primari
- Individuare ed eseguire il parsing dell'header incorporato JPEG‑Lossless (SOF3) e confrontare il conteggio dei componenti

Note:
- Segnalato sfruttato in the wild; eccellente candidato per controlli di coerenza strutturale

---

## Pattern di implementazione e prestazioni

Un scanner pratico dovrebbe:
- Rilevare automaticamente il tipo di file ed eseguire solo gli analizzatori rilevanti (PDF/JBIG2, WebP/VP8L, TTF, DNG/TIFF)
- Parsing in streaming/parziale per minimizzare le allocazioni e consentire la terminazione anticipata
- Eseguire le analisi in parallelo (pool di thread) per il triage di massa

Esempio di flusso di lavoro con ElegantBouncer (implementazione open‑source in Rust di questi controlli):
```bash
# Scan a path recursively with structural detectors
$ elegant-bouncer --scan /path/to/directory

# Optional TUI for parallel scanning and real‑time alerts
$ elegant-bouncer --tui --scan /path/to/samples
```
---

## DFIR consigli e casi limite

- Embedded objects: i PDF possono incorporare immagini (JBIG2) e font (TrueType); estrarre e scansionare ricorsivamente
- Decompression safety: usare librerie che limitano rigidamente tabelle/buffer prima dell'allocazione
- False positives: mantenere le regole conservative, privilegiare contraddizioni che sono impossibili secondo la specifica
- Version drift: ricalibrare i limiti di base (es., VP8L table sizes) quando i parser upstream cambiano i limiti

---

## Strumenti correlati

- ElegantBouncer – scanner strutturale per le detections sopra
- pdfid/pdf-parser/peepdf – estrazione degli oggetti PDF e analisi statica
- pdfcpu – PDF linter/sanitizer
- fontTools/ttx – dump delle tabelle TrueType e del bytecode
- exiftool – leggere i metadati TIFF/DNG/EXIF
- dwebp/webpmux – analizzare i metadati e i chunk WebP

---

## Riferimenti

- [ELEGANTBOUNCER: When You Can't Get the Samples but Still Need to Catch the Threat](https://www.msuiche.com/posts/elegantbouncer-when-you-cant-get-the-samples-but-still-need-to-catch-the-threat/)
- [ElegantBouncer project (GitHub)](https://github.com/msuiche/elegant-bouncer)
- [Researching FORCEDENTRY: Detecting the exploit with no samples](https://www.msuiche.com/posts/researching-forcedentry-detecting-the-exploit-with-no-samples/)
- [Researching BLASTPASS – Detecting the exploit inside a WebP file (Part 1)](https://www.msuiche.com/posts/researching-blastpass-detecting-the-exploit-inside-a-webp-file-part-1/)
- [Researching BLASTPASS – Analysing the Apple & Google WebP PoC file (Part 2)](https://www.msuiche.com/posts/researching-blastpass-analysing-the-apple-google-webp-poc-file-part-2/)
- [Researching TRIANGULATION – Detecting CVE‑2023‑41990 with single‑byte signatures](https://www.msuiche.com/posts/researching-triangulation-detecting-cve-2023-41990-with-single-byte-signatures/)
- [CVE‑2025‑43300: Critical vulnerability found in Apple’s DNG image processing](https://www.msuiche.com/posts/cve-2025-43300-critical-vulnerability-found-in-apples-dng-image-processing/)

{{#include ../../../banners/hacktricks-training.md}}
