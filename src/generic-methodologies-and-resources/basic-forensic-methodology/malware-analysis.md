# Analiza Malware

{{#include ../../banners/hacktricks-training.md}}

## Ściągi Forensics

[https://www.jaiminton.com/cheatsheet/DFIR/#](https://www.jaiminton.com/cheatsheet/DFIR/)

## Usługi online

- [VirusTotal](https://www.virustotal.com/gui/home/upload)
- [HybridAnalysis](https://www.hybrid-analysis.com)
- [Koodous](https://koodous.com)
- [Intezer](https://analyze.intezer.com)
- [Any.Run](https://any.run/)

## Narzędzia antywirusowe i detekcyjne (offline)

### Yara

#### Instalacja
```bash
sudo apt-get install -y yara
```
#### Przygotuj reguły

Użyj tego skryptu, aby pobrać i scalić wszystkie yara malware rules z github: [https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9](https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9)\  
Utwórz katalog _**rules**_ i uruchom skrypt. Spowoduje to utworzenie pliku o nazwie _**malware_rules.yar**_, który zawiera wszystkie yara rules dla malware.
```bash
wget https://gist.githubusercontent.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9/raw/4ec711d37f1b428b63bed1f786b26a0654aa2f31/malware_yara_rules.py
mkdir rules
python malware_yara_rules.py
```
#### Skanowanie
```bash
yara -w malware_rules.yar image  #Scan 1 file
yara -w malware_rules.yar folder #Scan the whole folder
```
#### YaraGen: Sprawdź malware i utwórz reguły

Możesz użyć narzędzia [**YaraGen**](https://github.com/Neo23x0/yarGen), aby wygenerować yara rules z pliku binarnego. Zobacz te poradniki: [**Part 1**](https://www.nextron-systems.com/2015/02/16/write-simple-sound-yara-rules/), [**Part 2**](https://www.nextron-systems.com/2015/10/17/how-to-write-simple-but-sound-yara-rules-part-2/), [**Part 3**](https://www.nextron-systems.com/2016/04/15/how-to-write-simple-but-sound-yara-rules-part-3/)
```bash
python3 yarGen.py --update
python3.exe yarGen.py --excludegood -m  ../../mals/
```
### ClamAV

#### Instalacja
```
sudo apt-get install -y clamav
```
#### Skanowanie
```bash
sudo freshclam      #Update rules
clamscan filepath   #Scan 1 file
clamscan folderpath #Scan the whole folder
```
### [Capa](https://github.com/mandiant/capa)

**Capa** wykrywa potencjalnie złośliwe **możliwości** w plikach wykonywalnych: PE, ELF, .NET. Wykryje więc rzeczy takie jak Att\&ck tactics, lub podejrzane możliwości takie jak:

- check for OutputDebugString error
- run as a service
- create process

Pobierz go z [**Github repo**](https://github.com/mandiant/capa).

### IOCs

IOC oznacza Indicator Of Compromise. IOC to zbiór **warunków, które identyfikują** potencjalnie niechciane oprogramowanie lub potwierdzone **malware**.\
Blue Teams używają tego rodzaju definicji do **wyszukiwania tego typu złośliwych plików** w swoich **systemach** i **sieciach**.\
Udostępnianie tych definicji jest bardzo przydatne — gdy malware zostanie zidentyfikowane na komputerze i zostanie utworzony dla niego IOC, inne Blue Teams mogą go wykorzystać do szybszej identyfikacji.

Narzędziem do tworzenia lub modyfikowania IOC jest [**IOC Editor**](https://www.fireeye.com/services/freeware/ioc-editor.html)**.**\
Możesz użyć narzędzi takich jak [**Redline**](https://www.fireeye.com/services/freeware/redline.html) do **wyszukiwania zdefiniowanych IOC na urządzeniu**.

### Loki

[**Loki**](https://github.com/Neo23x0/Loki) to skaner prostych wskaźników kompromitacji.\
Wykrywanie opiera się na czterech metodach detekcji:
```
1. File Name IOC
Regex match on full file path/name

2. Yara Rule Check
Yara signature matches on file data and process memory

3. Hash Check
Compares known malicious hashes (MD5, SHA1, SHA256) with scanned files

4. C2 Back Connect Check
Compares process connection endpoints with C2 IOCs (new since version v.10)
```
### Linux Malware Detect

[**Linux Malware Detect (LMD)**](https://www.rfxn.com/projects/linux-malware-detect/) to skaner malware dla Linux wydany na licencji GNU GPLv2, zaprojektowany z myślą o zagrożeniach występujących w środowiskach współdzielonego hostingu. Wykorzystuje dane o zagrożeniach z network edge intrusion detection systems do wydobywania malware, które są aktywnie używane w atakach, i generuje sygnatury do wykrywania. Dodatkowo dane o zagrożeniach pochodzą również z user submissions za pomocą LMD checkout feature oraz z zasobów społeczności malware.

### rkhunter

Narzędzia takie jak [**rkhunter**](http://rkhunter.sourceforge.net) mogą być użyte do sprawdzenia systemu plików pod kątem możliwych **rootkits** i malware.
```bash
sudo ./rkhunter --check -r / -l /tmp/rkhunter.log [--report-warnings-only] [--skip-keypress]
```
### FLOSS

[**FLOSS**](https://github.com/mandiant/flare-floss) to narzędzie, które spróbuje znaleźć obfuscated strings w executables, używając różnych techniques.

### PEpper

[PEpper ](https://github.com/Th3Hurrican3/PEpper) sprawdza podstawowe rzeczy w executable (binary data, entropy, URLs and IPs, some yara rules).

### PEstudio

[PEstudio](https://www.winitor.com/download) to narzędzie pozwalające uzyskać informacje o Windows executables, takich jak imports, exports, headers, ale także sprawdzi virus total i znajdzie potencjalne Att\&ck techniques.

### Detect It Easy(DiE)

[**DiE**](https://github.com/horsicq/Detect-It-Easy/) to narzędzie do wykrywania, czy plik jest **encrypted** i także znajdowania **packers**.

### NeoPI

[**NeoPI** ](https://github.com/CiscoCXSecurity/NeoPI) to skrypt Python, który używa różnych **statistical methods** do wykrywania **obfuscated** i **encrypted** content w plikach tekstowych/skryptach. Celem NeoPI jest pomoc w **detection of hidden web shell code**.

### **php-malware-finder**

[**PHP-malware-finder**](https://github.com/nbs-system/php-malware-finder) robi co może, aby wykryć **obfuscated**/**dodgy code** oraz pliki wykorzystujące funkcje **PHP** często używane w **malwares**/webshells.

### Apple Binary Signatures

Sprawdzając próbkę **malware sample** powinieneś zawsze **check the signature** binarki, ponieważ **developer**, który ją podpisał, może być już **related** z **malware.**
```bash
#Get signer
codesign -vv -d /bin/ls 2>&1 | grep -E "Authority|TeamIdentifier"

#Check if the app’s contents have been modified
codesign --verify --verbose /Applications/Safari.app

#Check if the signature is valid
spctl --assess --verbose /Applications/Safari.app
```
## Techniki wykrywania

### File Stacking

Jeżeli wiesz, że jakiś folder zawierający **pliki** web servera był **ostatnio zaktualizowany w pewnym dniu**. **Sprawdź** **datę**, kiedy wszystkie **pliki** w **web serverze** zostały utworzone i zmodyfikowane — jeśli któraś data wygląda **podejrzanie**, sprawdź ten plik.

### Baselines

Jeżeli pliki w folderze **nie powinny być modyfikowane**, możesz obliczyć **hash** **oryginalnych plików** folderu i **porównać** je z **aktualnymi**. Wszystko zmodyfikowane będzie **podejrzane**.

### Statistical Analysis

Kiedy informacje są zapisywane w logach, możesz **sprawdzić statystyki**, np. ile razy każdy plik web servera był dostępny — web shell może być jednym z najczęściej.

---

### Android in-app native telemetry (no root)

Na Androidzie możesz instrumentować natywny kod wewnątrz procesu docelowej aplikacji przez wstępne załadowanie małej biblioteki loggera zanim inne JNI libs się zainicjalizują. To daje wczesną widoczność natywnego zachowania bez system-wide hooks ani roota. Popularne podejście to SoTap: wrzuć libsotap.so dla odpowiedniego ABI do APK i wstrzyknij wywołanie System.loadLibrary("sotap") wcześnie (np. static initializer lub Application.onCreate), następnie zbieraj logi z internal/external ścieżek lub użyj Logcat jako fallback.

See the Android native reversing page for setup details and log paths:

{{#ref}}
../../mobile-pentesting/android-app-pentesting/reversing-native-libraries.md
{{#endref}}

---

## Deobfuscating Dynamic Control-Flow (JMP/CALL RAX Dispatchers)

Współczesne rodziny malware intensywnie nadużywają Control-Flow Graph (CFG) obfuskacji: zamiast bezpośredniego skoku/wywołania obliczają cel w czasie wykonania i wykonują `jmp rax` lub `call rax`. Mały *dispatcher* (zazwyczaj dziewięć instrukcji) ustawia docelowy adres zależnie od flag CPU `ZF`/`CF`, całkowicie łamiąc statyczne odzyskiwanie CFG.

Technika – zaprezentowana przez loader SLOW#TEMPEST – może być pokonana trzema krokami wykorzystując wyłącznie IDAPython i emulator CPU Unicorn.

### 1. Zlokalizuj wszystkie pośrednie skoki / wywołania
```python
import idautils, idc

for ea in idautils.FunctionItems(idc.here()):
mnem = idc.print_insn_mnem(ea)
if mnem in ("jmp", "call") and idc.print_operand(ea, 0) == "rax":
print(f"[+] Dispatcher found @ {ea:X}")
```
### 2. Wyodrębnij kod bajtowy dispatchera
```python
import idc

def get_dispatcher_start(jmp_ea, count=9):
s = jmp_ea
for _ in range(count):
s = idc.prev_head(s, 0)
return s

start = get_dispatcher_start(jmp_ea)
size  = jmp_ea + idc.get_item_size(jmp_ea) - start
code  = idc.get_bytes(start, size)
open(f"{start:X}.bin", "wb").write(code)
```
### 3. Emuluj to dwukrotnie za pomocą Unicorn
```python
from unicorn import *
from unicorn.x86_const import *
import struct

def run(code, zf=0, cf=0):
BASE = 0x1000
mu = Uc(UC_ARCH_X86, UC_MODE_64)
mu.mem_map(BASE, 0x1000)
mu.mem_write(BASE, code)
mu.reg_write(UC_X86_REG_RFLAGS, (zf << 6) | cf)
mu.reg_write(UC_X86_REG_RAX, 0)
mu.emu_start(BASE, BASE+len(code))
return mu.reg_read(UC_X86_REG_RAX)
```
Uruchom `run(code,0,0)` i `run(code,1,1)`, aby uzyskać *false* i *true* cele gałęzi.

### 4. Przywróć bezpośredni skok / wywołanie
```python
import struct, ida_bytes

def patch_direct(ea, target, is_call=False):
op   = 0xE8 if is_call else 0xE9           # CALL rel32 or JMP rel32
disp = target - (ea + 5) & 0xFFFFFFFF
ida_bytes.patch_bytes(ea, bytes([op]) + struct.pack('<I', disp))
```
Po patchingu wymuś w IDA ponowną analizę funkcji, aby pełny CFG i wynik Hex-Rays zostały przywrócone:
```python
import ida_auto, idaapi
idaapi.reanalyze_function(idc.get_func_attr(ea, idc.FUNCATTR_START))
```
### 5. Oznacz pośrednie wywołania API

Gdy znane jest rzeczywiste miejsce docelowe każdego `call rax`, możesz powiedzieć IDA, co to jest, aby typy parametrów & nazwy zmiennych zostały odzyskane automatycznie:
```python
idc.set_callee_name(call_ea, resolved_addr, 0)  # IDA 8.3+
```
### Praktyczne korzyści

* Przywraca prawdziwe CFG → decompilation przechodzi z *10* linii do tysięcy.
* Umożliwia string-cross-reference i xrefs, dzięki czemu rekonstrukcja zachowania staje się trywialna.
* Scripts są wielokrotnego użytku: umieść je w dowolnym loaderze chronionym tym samym trikiem.

---

## Źródła

- [Unit42 – Evolving Tactics of SLOW#TEMPEST: A Deep Dive Into Advanced Malware Techniques](https://unit42.paloaltonetworks.com/slow-tempest-malware-obfuscation/)
- SoTap: Lightweight in-app JNI (.so) behavior logger – [github.com/RezaArbabBot/SoTap](https://github.com/RezaArbabBot/SoTap)

{{#include ../../banners/hacktricks-training.md}}
