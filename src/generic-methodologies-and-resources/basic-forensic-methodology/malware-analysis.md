# Analyse de Malware

{{#include ../../banners/hacktricks-training.md}}

## Fiches de Référence en Criminalistique

[https://www.jaiminton.com/cheatsheet/DFIR/#](https://www.jaiminton.com/cheatsheet/DFIR/)

## Services en Ligne

- [VirusTotal](https://www.virustotal.com/gui/home/upload)
- [HybridAnalysis](https://www.hybrid-analysis.com)
- [Koodous](https://koodous.com)
- [Intezer](https://analyze.intezer.com)
- [Any.Run](https://any.run/)

## Outils Antivirus et de Détection Hors Ligne

### Yara

#### Installer
```bash
sudo apt-get install -y yara
```
#### Préparer les règles

Utilisez ce script pour télécharger et fusionner toutes les règles yara de malware depuis github : [https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9](https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9)\
Créez le répertoire _**rules**_ et exécutez-le. Cela créera un fichier appelé _**malware_rules.yar**_ qui contient toutes les règles yara pour les malwares.
```bash
wget https://gist.githubusercontent.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9/raw/4ec711d37f1b428b63bed1f786b26a0654aa2f31/malware_yara_rules.py
mkdir rules
python malware_yara_rules.py
```
#### Scanner
```bash
yara -w malware_rules.yar image  #Scan 1 file
yara -w malware_rules.yar folder #Scan the whole folder
```
#### YaraGen : Vérifiez la présence de malware et créez des règles

Vous pouvez utiliser l'outil [**YaraGen**](https://github.com/Neo23x0/yarGen) pour générer des règles yara à partir d'un binaire. Consultez ces tutoriels : [**Partie 1**](https://www.nextron-systems.com/2015/02/16/write-simple-sound-yara-rules/), [**Partie 2**](https://www.nextron-systems.com/2015/10/17/how-to-write-simple-but-sound-yara-rules-part-2/), [**Partie 3**](https://www.nextron-systems.com/2016/04/15/how-to-write-simple-but-sound-yara-rules-part-3/)
```bash
python3 yarGen.py --update
python3.exe yarGen.py --excludegood -m  ../../mals/
```
### ClamAV

#### Installer
```
sudo apt-get install -y clamav
```
#### Scanner
```bash
sudo freshclam      #Update rules
clamscan filepath   #Scan 1 file
clamscan folderpath #Scan the whole folder
```
### [Capa](https://github.com/mandiant/capa)

**Capa** détecte des **capabilités** potentiellement malveillantes dans les exécutables : PE, ELF, .NET. Il trouvera donc des éléments tels que les tactiques Att\&ck, ou des capacités suspectes telles que :

- vérifier l'erreur OutputDebugString
- s'exécuter en tant que service
- créer un processus

Obtenez-le dans le [**Github repo**](https://github.com/mandiant/capa).

### IOCs

IOC signifie Indicateur de Compromission. Un IOC est un ensemble de **conditions qui identifient** un logiciel potentiellement indésirable ou un **malware** confirmé. Les Blue Teams utilisent ce type de définition pour **rechercher ce type de fichiers malveillants** dans leurs **systèmes** et **réseaux**.\
Partager ces définitions est très utile car lorsque le malware est identifié sur un ordinateur et qu'un IOC pour ce malware est créé, d'autres Blue Teams peuvent l'utiliser pour identifier le malware plus rapidement.

Un outil pour créer ou modifier des IOCs est [**IOC Editor**](https://www.fireeye.com/services/freeware/ioc-editor.html)**.**\
Vous pouvez utiliser des outils tels que [**Redline**](https://www.fireeye.com/services/freeware/redline.html) pour **rechercher des IOCs définis sur un appareil**.

### Loki

[**Loki**](https://github.com/Neo23x0/Loki) est un scanner pour des Indicateurs de Compromission Simples.\
La détection est basée sur quatre méthodes de détection :
```
1. File Name IOC
Regex match on full file path/name

2. Yara Rule Check
Yara signature matches on file data and process memory

3. Hash Check
Compares known malicious hashes (MD5, SHA1, SHA256) with scanned files

4. C2 Back Connect Check
Compares process connection endpoints with C2 IOCs (new since version v.10)
```
### Linux Malware Detect

[**Linux Malware Detect (LMD)**](https://www.rfxn.com/projects/linux-malware-detect/) est un scanner de malware pour Linux publié sous la licence GNU GPLv2, conçu autour des menaces rencontrées dans des environnements d'hébergement partagé. Il utilise des données de menaces provenant de systèmes de détection d'intrusion en bordure de réseau pour extraire les malwares qui sont activement utilisés dans des attaques et génère des signatures pour la détection. De plus, les données de menaces proviennent également des soumissions des utilisateurs avec la fonctionnalité de vérification LMD et des ressources de la communauté des malwares.

### rkhunter

Des outils comme [**rkhunter**](http://rkhunter.sourceforge.net) peuvent être utilisés pour vérifier le système de fichiers à la recherche de **rootkits** et de malwares.
```bash
sudo ./rkhunter --check -r / -l /tmp/rkhunter.log [--report-warnings-only] [--skip-keypress]
```
### FLOSS

[**FLOSS**](https://github.com/mandiant/flare-floss) est un outil qui essaiera de trouver des chaînes obfusquées à l'intérieur des exécutables en utilisant différentes techniques.

### PEpper

[PEpper ](https://github.com/Th3Hurrican3/PEpper) vérifie certaines informations de base à l'intérieur de l'exécutable (données binaires, entropie, URLs et IPs, certaines règles yara).

### PEstudio

[PEstudio](https://www.winitor.com/download) est un outil qui permet d'obtenir des informations sur les exécutables Windows tels que les imports, les exports, les en-têtes, mais vérifiera également virus total et trouvera des techniques potentielles Att\&ck.

### Detect It Easy(DiE)

[**DiE**](https://github.com/horsicq/Detect-It-Easy/) est un outil pour détecter si un fichier est **chiffré** et également trouver des **packers**.

### NeoPI

[**NeoPI** ](https://github.com/CiscoCXSecurity/NeoPI) est un script Python qui utilise une variété de **méthodes statistiques** pour détecter du contenu **obfusqué** et **chiffré** dans des fichiers texte/script. L'objectif de NeoPI est d'aider à la **détection de code de shell web caché**.

### **php-malware-finder**

[**PHP-malware-finder**](https://github.com/nbs-system/php-malware-finder) fait de son mieux pour détecter du **code obfusqué**/**suspect** ainsi que des fichiers utilisant des fonctions **PHP** souvent utilisées dans des **malwares**/webshells.

### Apple Binary Signatures

Lors de la vérification d'un **échantillon de malware**, vous devez toujours **vérifier la signature** du binaire car le **développeur** qui l'a signé peut déjà être **lié** à des **malwares.**
```bash
#Get signer
codesign -vv -d /bin/ls 2>&1 | grep -E "Authority|TeamIdentifier"

#Check if the app’s contents have been modified
codesign --verify --verbose /Applications/Safari.app

#Check if the signature is valid
spctl --assess --verbose /Applications/Safari.app
```
## Techniques de Détection

### Empilement de Fichiers

Si vous savez qu'un dossier contenant les **fichiers** d'un serveur web a été **dernièrement mis à jour à une certaine date**. **Vérifiez** la **date** à laquelle tous les **fichiers** du **serveur web ont été créés et modifiés** et si une date est **suspecte**, vérifiez ce fichier.

### Lignes de Base

Si les fichiers d'un dossier **n'auraient pas dû être modifiés**, vous pouvez calculer le **hash** des **fichiers originaux** du dossier et **les comparer** avec les **actuels**. Tout ce qui a été modifié sera **suspect**.

### Analyse Statistique

Lorsque l'information est enregistrée dans des journaux, vous pouvez **vérifier des statistiques comme combien de fois chaque fichier d'un serveur web a été accédé, car un shell web pourrait être l'un des plus**.

---

## Déobfuscation du Flux de Contrôle Dynamique (Dispatcheurs JMP/CALL RAX)

Les familles de malware modernes abusent fortement de l'obfuscation du Graphique de Flux de Contrôle (CFG) : au lieu d'un saut/appel direct, elles calculent la destination à l'exécution et exécutent un `jmp rax` ou `call rax`. Un petit *dispatcheur* (typiquement neuf instructions) définit la cible finale en fonction des drapeaux `ZF`/`CF` du CPU, brisant complètement la récupération statique du CFG.

La technique – mise en avant par le chargeur SLOW#TEMPEST – peut être vaincue avec un flux de travail en trois étapes qui repose uniquement sur IDAPython et l'émulateur de CPU Unicorn.

### 1. Localiser chaque saut / appel indirect
```python
import idautils, idc

for ea in idautils.FunctionItems(idc.here()):
mnem = idc.print_insn_mnem(ea)
if mnem in ("jmp", "call") and idc.print_operand(ea, 0) == "rax":
print(f"[+] Dispatcher found @ {ea:X}")
```
### 2. Extraire le byte-code du dispatcher
```python
import idc

def get_dispatcher_start(jmp_ea, count=9):
s = jmp_ea
for _ in range(count):
s = idc.prev_head(s, 0)
return s

start = get_dispatcher_start(jmp_ea)
size  = jmp_ea + idc.get_item_size(jmp_ea) - start
code  = idc.get_bytes(start, size)
open(f"{start:X}.bin", "wb").write(code)
```
### 3. Émulez-le deux fois avec Unicorn
```python
from unicorn import *
from unicorn.x86_const import *
import struct

def run(code, zf=0, cf=0):
BASE = 0x1000
mu = Uc(UC_ARCH_X86, UC_MODE_64)
mu.mem_map(BASE, 0x1000)
mu.mem_write(BASE, code)
mu.reg_write(UC_X86_REG_RFLAGS, (zf << 6) | cf)
mu.reg_write(UC_X86_REG_RAX, 0)
mu.emu_start(BASE, BASE+len(code))
return mu.reg_read(UC_X86_REG_RAX)
```
Exécutez `run(code,0,0)` et `run(code,1,1)` pour obtenir les cibles de branche *fausse* et *vraie*.

### 4. Rétablir un saut / appel direct
```python
import struct, ida_bytes

def patch_direct(ea, target, is_call=False):
op   = 0xE8 if is_call else 0xE9           # CALL rel32 or JMP rel32
disp = target - (ea + 5) & 0xFFFFFFFF
ida_bytes.patch_bytes(ea, bytes([op]) + struct.pack('<I', disp))
```
Après avoir appliqué le correctif, forcez IDA à réanalyser la fonction afin que le CFG complet et la sortie Hex-Rays soient restaurés :
```python
import ida_auto, idaapi
idaapi.reanalyze_function(idc.get_func_attr(ea, idc.FUNCATTR_START))
```
### 5. Étiqueter les appels API indirects

Une fois que la véritable destination de chaque `call rax` est connue, vous pouvez indiquer à IDA ce que c'est afin que les types de paramètres et les noms de variables soient récupérés automatiquement :
```python
idc.set_callee_name(call_ea, resolved_addr, 0)  # IDA 8.3+
```
### Avantages pratiques

* Restaure le vrai CFG → la décompilation passe de *10* lignes à des milliers.
* Permet la référence croisée de chaînes & xrefs, rendant la reconstruction du comportement triviale.
* Les scripts sont réutilisables : il suffit de les placer dans n'importe quel chargeur protégé par le même truc.

---

## Références

- [Unit42 – Evolving Tactics of SLOW#TEMPEST: A Deep Dive Into Advanced Malware Techniques](https://unit42.paloaltonetworks.com/slow-tempest-malware-obfuscation/)

{{#include ../../banners/hacktricks-training.md}}
