# 恶意软件分析

{{#include ../../banners/hacktricks-training.md}}

## 取证速查表

[https://www.jaiminton.com/cheatsheet/DFIR/#](https://www.jaiminton.com/cheatsheet/DFIR/)

## 在线服务

- [VirusTotal](https://www.virustotal.com/gui/home/upload)
- [HybridAnalysis](https://www.hybrid-analysis.com)
- [Koodous](https://koodous.com)
- [Intezer](https://analyze.intezer.com)
- [Any.Run](https://any.run/)

## 离线杀毒和检测工具

### Yara

#### 安装
```bash
sudo apt-get install -y yara
```
#### 准备规则

使用此脚本从 github 下载并合并所有 yara malware rules: [https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9](https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9)\
创建 _**rules**_ 目录并执行它。 这将创建一个名为 _**malware_rules.yar**_ 的文件，包含所有 yara malware rules。
```bash
wget https://gist.githubusercontent.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9/raw/4ec711d37f1b428b63bed1f786b26a0654aa2f31/malware_yara_rules.py
mkdir rules
python malware_yara_rules.py
```
#### 扫描
```bash
yara -w malware_rules.yar image  #Scan 1 file
yara -w malware_rules.yar folder #Scan the whole folder
```
#### YaraGen: 检查 malware 并创建 yara rules

你可以使用工具 [**YaraGen**](https://github.com/Neo23x0/yarGen) 从 binary 生成 yara rules。查看这些教程：[**Part 1**](https://www.nextron-systems.com/2015/02/16/write-simple-sound-yara-rules/), [**Part 2**](https://www.nextron-systems.com/2015/10/17/how-to-write-simple-but-sound-yara-rules-part-2/), [**Part 3**](https://www.nextron-systems.com/2016/04/15/how-to-write-simple-but-sound-yara-rules-part-3/)
```bash
python3 yarGen.py --update
python3.exe yarGen.py --excludegood -m  ../../mals/
```
### ClamAV

#### 安装
```
sudo apt-get install -y clamav
```
#### 扫描
```bash
sudo freshclam      #Update rules
clamscan filepath   #Scan 1 file
clamscan folderpath #Scan the whole folder
```
### [Capa](https://github.com/mandiant/capa)

**Capa** 在可执行文件：PE、ELF、.NET 中检测潜在恶意的 **能力**。因此它会发现诸如 Att\&ck tactics 的条目，或以下可疑能力：

- check for OutputDebugString error
- run as a service
- create process

可在 [**Github repo**](https://github.com/mandiant/capa) 获取。

### IOCs

IOC 表示入侵指标。IOC 是一组 **用于识别** 某些潜在不受欢迎软件或已确认 **malware** 的 **条件**。Blue Teams 使用这种定义在其 **系统** 和 **网络** 中 **搜索此类恶意文件**。\
共享这些定义非常有用，因为当在一台计算机中识别出 malware 并为其创建 IOC 后，其他 Blue Teams 可以使用该 IOC 更快地识别该 malware。

用于创建或修改 IOCs 的工具有 [**IOC Editor**](https://www.fireeye.com/services/freeware/ioc-editor.html)**.**\
你可以使用诸如 [**Redline**](https://www.fireeye.com/services/freeware/redline.html) 的工具来 **在设备中搜索已定义的 IOCs**。

### Loki

[**Loki**](https://github.com/Neo23x0/Loki) 是一个用于扫描简单入侵指标的扫描器。\
检测基于四种检测方法：
```
1. File Name IOC
Regex match on full file path/name

2. Yara Rule Check
Yara signature matches on file data and process memory

3. Hash Check
Compares known malicious hashes (MD5, SHA1, SHA256) with scanned files

4. C2 Back Connect Check
Compares process connection endpoints with C2 IOCs (new since version v.10)
```
### Linux Malware Detect

[**Linux Malware Detect (LMD)**](https://www.rfxn.com/projects/linux-malware-detect/) 是一个面向 Linux 的 malware 扫描器，基于 GNU GPLv2 许可发布，专为共享托管环境所面临的威胁而设计。它使用来自 network edge intrusion detection systems 的威胁数据来提取正在被用于攻击的 malware 并生成用于检测的签名。此外，威胁数据也来自用户通过 LMD checkout 功能提交的样本以及 malware community resources。

### rkhunter

像 [**rkhunter**](http://rkhunter.sourceforge.net) 这样的工具可用于检查文件系统以查找可能的 **rootkits** 和 malware。
```bash
sudo ./rkhunter --check -r / -l /tmp/rkhunter.log [--report-warnings-only] [--skip-keypress]
```
### FLOSS

[**FLOSS**](https://github.com/mandiant/flare-floss) 是一个工具，会尝试使用不同的技术在可执行文件中查找混淆的字符串。

### PEpper

[PEpper ](https://github.com/Th3Hurrican3/PEpper) 会检查可执行文件中的一些基本内容（二进制数据、熵、URLs 和 IPs、一些 yara 规则）。

### PEstudio

[PEstudio](https://www.winitor.com/download) 是一个可以获取 Windows 可执行文件信息的工具，例如 imports、exports、headers，同时也会检查 VirusTotal 并发现潜在的 Att\&ck 技术。

### Detect It Easy(DiE)

[**DiE**](https://github.com/horsicq/Detect-It-Easy/) 是一个用于检测文件是否 **encrypted** 并查找 **packers** 的工具。

### NeoPI

[**NeoPI** ](https://github.com/CiscoCXSecurity/NeoPI) 是一个 Python 脚本，使用多种 **statistical methods** 来检测文本/脚本文件中 **obfuscated** 和 **encrypted** 的内容。NeoPI 的目的是帮助 **detection of hidden web shell code**。

### **php-malware-finder**

[**PHP-malware-finder**](https://github.com/nbs-system/php-malware-finder) 尽其所能检测 **obfuscated**/**dodgy code**，以及使用常见于 **malwares**/webshells 的 **PHP** 函数的文件。

### Apple Binary Signatures

在检查某些 **malware sample** 时，你应始终 **check the signature** 二进制，因为签名的 **developer** 可能已经与 **malware** 有关联。
```bash
#Get signer
codesign -vv -d /bin/ls 2>&1 | grep -E "Authority|TeamIdentifier"

#Check if the app’s contents have been modified
codesign --verify --verbose /Applications/Safari.app

#Check if the signature is valid
spctl --assess --verbose /Applications/Safari.app
```
## 检测技术

### File Stacking

如果你知道某个包含 web 服务器 **文件** 的文件夹在某个 **日期被最后更新**。请**检查**该 web 服务器中所有 **文件** 的创建和修改 **日期**，如果有任何日期 **可疑**，就检查那个文件。

### Baselines

如果一个文件夹的文件 **不应该被修改**，你可以计算该文件夹原始文件的 **hash** 并将其与当前文件 **比较**。任何被修改的文件都应视为 **可疑**。

### Statistical Analysis

当信息记录在日志中时，你可以**检查统计信息**，例如每个 web 服务器文件被访问的次数，因为 web shell 可能是被访问次数最多的之一。

---

### Android in-app native telemetry (no root)

在 Android 上，你可以通过在其他 JNI 库初始化之前预加载一个小型 logger 库，在目标应用进程内对 native 代码进行 instrument。这样可以在不依赖系统范围 hook 或 root 的情况下，尽早观察 native 行为。一种常用方法是 SoTap：将 libsotap.so 放到 APK 的对应 ABI 路径下，并尽早注入一个 System.loadLibrary("sotap") 调用（例如静态初始化器或 Application.onCreate），然后从内部/外部路径收集日志，或使用 Logcat 作为回退。

查看 Android native reversing 页面以获取设置细节和日志路径：

{{#ref}}
../../mobile-pentesting/android-app-pentesting/reversing-native-libraries.md
{{#endref}}

---

## Deobfuscating Dynamic Control-Flow (JMP/CALL RAX Dispatchers)

现代恶意软件家族大量滥用 Control-Flow Graph (CFG) 混淆：它们不是直接跳转/调用，而是在运行时计算目标并执行 `jmp rax` 或 `call rax`。一个小的 *dispatcher*（通常九条指令）会根据 CPU 的 `ZF`/`CF` flags 设置最终目标，这会完全破坏静态 CFG 恢复。

该技术 —— 由 SLOW#TEMPEST loader 展示 —— 可以通过一个仅依赖 IDAPython 和 Unicorn CPU emulator 的三步工作流来破解。

### 1. Locate every indirect jump / call
```python
import idautils, idc

for ea in idautils.FunctionItems(idc.here()):
mnem = idc.print_insn_mnem(ea)
if mnem in ("jmp", "call") and idc.print_operand(ea, 0) == "rax":
print(f"[+] Dispatcher found @ {ea:X}")
```
### 2. 提取 dispatcher 字节码
```python
import idc

def get_dispatcher_start(jmp_ea, count=9):
s = jmp_ea
for _ in range(count):
s = idc.prev_head(s, 0)
return s

start = get_dispatcher_start(jmp_ea)
size  = jmp_ea + idc.get_item_size(jmp_ea) - start
code  = idc.get_bytes(start, size)
open(f"{start:X}.bin", "wb").write(code)
```
### 3. 使用 Unicorn 对其进行两次模拟
```python
from unicorn import *
from unicorn.x86_const import *
import struct

def run(code, zf=0, cf=0):
BASE = 0x1000
mu = Uc(UC_ARCH_X86, UC_MODE_64)
mu.mem_map(BASE, 0x1000)
mu.mem_write(BASE, code)
mu.reg_write(UC_X86_REG_RFLAGS, (zf << 6) | cf)
mu.reg_write(UC_X86_REG_RAX, 0)
mu.emu_start(BASE, BASE+len(code))
return mu.reg_read(UC_X86_REG_RAX)
```
运行 `run(code,0,0)` 和 `run(code,1,1)` 以获取 *false* 和 *true* 分支目标。

### 4. 将其修补回直接 jump / call
```python
import struct, ida_bytes

def patch_direct(ea, target, is_call=False):
op   = 0xE8 if is_call else 0xE9           # CALL rel32 or JMP rel32
disp = target - (ea + 5) & 0xFFFFFFFF
ida_bytes.patch_bytes(ea, bytes([op]) + struct.pack('<I', disp))
```
在打补丁之后，强制 IDA 重新分析该函数，以恢复完整的 CFG 和 Hex-Rays 输出：
```python
import ida_auto, idaapi
idaapi.reanalyze_function(idc.get_func_attr(ea, idc.FUNCATTR_START))
```
### 5. 标注间接 API 调用

一旦每个 `call rax` 的真实目标已知，你就可以告诉 IDA 那是什么，这样参数类型 & 变量名会被自动恢复：
```python
idc.set_callee_name(call_ea, resolved_addr, 0)  # IDA 8.3+
```
### 实际好处

* 恢复真实的 CFG → 反编译结果从 *10* 行变成数千行。
* 启用 string-cross-reference & xrefs，使行为重建变得轻而易举。
* 脚本可复用：将它们放入受相同技巧保护的任何 loader 中。

---

## 参考资料

- [Unit42 – Evolving Tactics of SLOW#TEMPEST: A Deep Dive Into Advanced Malware Techniques](https://unit42.paloaltonetworks.com/slow-tempest-malware-obfuscation/)
- SoTap: Lightweight in-app JNI (.so) behavior logger – [github.com/RezaArbabBot/SoTap](https://github.com/RezaArbabBot/SoTap)

{{#include ../../banners/hacktricks-training.md}}
