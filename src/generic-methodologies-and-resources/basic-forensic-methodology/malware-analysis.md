# Análise de Malware

{{#include ../../banners/hacktricks-training.md}}

## Cheatsheets de Forense

[https://www.jaiminton.com/cheatsheet/DFIR/#](https://www.jaiminton.com/cheatsheet/DFIR/)

## Serviços Online

- [VirusTotal](https://www.virustotal.com/gui/home/upload)
- [HybridAnalysis](https://www.hybrid-analysis.com)
- [Koodous](https://koodous.com)
- [Intezer](https://analyze.intezer.com)
- [Any.Run](https://any.run/)

## Ferramentas de Antivírus e Detecção Offline

### Yara

#### Instalar
```bash
sudo apt-get install -y yara
```
#### Prepare regras

Use este script para baixar e mesclar todas as regras yara de malware do github: [https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9](https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9)\
Crie o diretório _**rules**_ e execute-o. Isso criará um arquivo chamado _**malware_rules.yar**_ que contém todas as regras yara para malware.
```bash
wget https://gist.githubusercontent.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9/raw/4ec711d37f1b428b63bed1f786b26a0654aa2f31/malware_yara_rules.py
mkdir rules
python malware_yara_rules.py
```
#### Escanear
```bash
yara -w malware_rules.yar image  #Scan 1 file
yara -w malware_rules.yar folder #Scan the whole folder
```
#### YaraGen: Verifique se há malware e crie regras

Você pode usar a ferramenta [**YaraGen**](https://github.com/Neo23x0/yarGen) para gerar regras yara a partir de um binário. Confira estes tutoriais: [**Parte 1**](https://www.nextron-systems.com/2015/02/16/write-simple-sound-yara-rules/), [**Parte 2**](https://www.nextron-systems.com/2015/10/17/how-to-write-simple-but-sound-yara-rules-part-2/), [**Parte 3**](https://www.nextron-systems.com/2016/04/15/how-to-write-simple-but-sound-yara-rules-part-3/)
```bash
python3 yarGen.py --update
python3.exe yarGen.py --excludegood -m  ../../mals/
```
### ClamAV

#### Instalar
```
sudo apt-get install -y clamav
```
#### Escanear
```bash
sudo freshclam      #Update rules
clamscan filepath   #Scan 1 file
clamscan folderpath #Scan the whole folder
```
### [Capa](https://github.com/mandiant/capa)

**Capa** detecta **capacidades** potencialmente maliciosas em executáveis: PE, ELF, .NET. Assim, encontrará coisas como táticas do Att\&ck ou capacidades suspeitas, como:

- verificar erro de OutputDebugString
- executar como um serviço
- criar processo

Obtenha no [**repositório do Github**](https://github.com/mandiant/capa).

### IOCs

IOC significa Indicador de Compromisso. Um IOC é um conjunto de **condições que identificam** algum software potencialmente indesejado ou **malware** confirmado. As Blue Teams usam esse tipo de definição para **procurar por esse tipo de arquivos maliciosos** em seus **sistemas** e **redes**.\
Compartilhar essas definições é muito útil, pois quando o malware é identificado em um computador e um IOC para esse malware é criado, outras Blue Teams podem usá-lo para identificar o malware mais rapidamente.

Uma ferramenta para criar ou modificar IOCs é [**IOC Editor**](https://www.fireeye.com/services/freeware/ioc-editor.html)**.**\
Você pode usar ferramentas como [**Redline**](https://www.fireeye.com/services/freeware/redline.html) para **procurar por IOCs definidos em um dispositivo**.

### Loki

[**Loki**](https://github.com/Neo23x0/Loki) é um scanner para Indicadores Simples de Compromisso.\
A detecção é baseada em quatro métodos de detecção:
```
1. File Name IOC
Regex match on full file path/name

2. Yara Rule Check
Yara signature matches on file data and process memory

3. Hash Check
Compares known malicious hashes (MD5, SHA1, SHA256) with scanned files

4. C2 Back Connect Check
Compares process connection endpoints with C2 IOCs (new since version v.10)
```
### Linux Malware Detect

[**Linux Malware Detect (LMD)**](https://www.rfxn.com/projects/linux-malware-detect/) é um scanner de malware para Linux lançado sob a licença GNU GPLv2, que é projetado em torno das ameaças enfrentadas em ambientes de hospedagem compartilhada. Ele usa dados de ameaças de sistemas de detecção de intrusões na borda da rede para extrair malware que está sendo ativamente utilizado em ataques e gera assinaturas para detecção. Além disso, os dados de ameaças também são derivados de envios de usuários com o recurso de checkout do LMD e recursos da comunidade de malware.

### rkhunter

Ferramentas como [**rkhunter**](http://rkhunter.sourceforge.net) podem ser usadas para verificar o sistema de arquivos em busca de possíveis **rootkits** e malware.
```bash
sudo ./rkhunter --check -r / -l /tmp/rkhunter.log [--report-warnings-only] [--skip-keypress]
```
### FLOSS

[**FLOSS**](https://github.com/mandiant/flare-floss) é uma ferramenta que tentará encontrar strings ofuscadas dentro de executáveis usando diferentes técnicas.

### PEpper

[PEpper](https://github.com/Th3Hurrican3/PEpper) verifica algumas informações básicas dentro do executável (dados binários, entropia, URLs e IPs, algumas regras yara).

### PEstudio

[PEstudio](https://www.winitor.com/download) é uma ferramenta que permite obter informações de executáveis do Windows, como imports, exports, cabeçalhos, mas também verificará o virus total e encontrará técnicas potenciais do Att\&ck.

### Detect It Easy(DiE)

[**DiE**](https://github.com/horsicq/Detect-It-Easy/) é uma ferramenta para detectar se um arquivo está **criptografado** e também encontrar **empacotadores**.

### NeoPI

[**NeoPI**](https://github.com/CiscoCXSecurity/NeoPI) é um script em Python que utiliza uma variedade de **métodos estatísticos** para detectar conteúdo **ofuscado** e **criptografado** dentro de arquivos de texto/script. O objetivo pretendido do NeoPI é ajudar na **detecção de código de web shell oculto**.

### **php-malware-finder**

[**PHP-malware-finder**](https://github.com/nbs-system/php-malware-finder) faz o seu melhor para detectar **código ofuscado**/**suspeito**, bem como arquivos que utilizam funções **PHP** frequentemente usadas em **malwares**/webshells.

### Apple Binary Signatures

Ao verificar alguma **amostra de malware**, você deve sempre **verificar a assinatura** do binário, pois o **desenvolvedor** que a assinou pode já estar **relacionado** com **malware.**
```bash
#Get signer
codesign -vv -d /bin/ls 2>&1 | grep -E "Authority|TeamIdentifier"

#Check if the app’s contents have been modified
codesign --verify --verbose /Applications/Safari.app

#Check if the signature is valid
spctl --assess --verbose /Applications/Safari.app
```
## Técnicas de Detecção

### Empilhamento de Arquivos

Se você sabe que alguma pasta contendo os **arquivos** de um servidor web foi **atualizada pela última vez em uma data específica**. **Verifique** a **data** em que todos os **arquivos** no **servidor web foram criados e modificados** e se alguma data é **suspeita**, verifique esse arquivo.

### Linhas de Base

Se os arquivos de uma pasta **não deveriam ter sido modificados**, você pode calcular o **hash** dos **arquivos originais** da pasta e **compará-los** com os **atuais**. Qualquer modificação será **suspeita**.

### Análise Estatística

Quando as informações são salvas em logs, você pode **verificar estatísticas como quantas vezes cada arquivo de um servidor web foi acessado, pois um shell web pode ser um dos mais**.

---

## Deobfuscação de Fluxo de Controle Dinâmico (Despachantes JMP/CALL RAX)

Famílias modernas de malware abusam fortemente da ofuscação do Grafo de Fluxo de Controle (CFG): em vez de um salto/chamada direto, eles computam o destino em tempo de execução e executam um `jmp rax` ou `call rax`. Um pequeno *despachante* (tipicamente nove instruções) define o alvo final dependendo das flags `ZF`/`CF` da CPU, quebrando completamente a recuperação estática do CFG.

A técnica – demonstrada pelo carregador SLOW#TEMPEST – pode ser derrotada com um fluxo de trabalho em três etapas que depende apenas do IDAPython e do emulador de CPU Unicorn.

### 1. Localizar cada salto / chamada indireta
```python
import idautils, idc

for ea in idautils.FunctionItems(idc.here()):
mnem = idc.print_insn_mnem(ea)
if mnem in ("jmp", "call") and idc.print_operand(ea, 0) == "rax":
print(f"[+] Dispatcher found @ {ea:X}")
```
### 2. Extraia o byte-code do despachante
```python
import idc

def get_dispatcher_start(jmp_ea, count=9):
s = jmp_ea
for _ in range(count):
s = idc.prev_head(s, 0)
return s

start = get_dispatcher_start(jmp_ea)
size  = jmp_ea + idc.get_item_size(jmp_ea) - start
code  = idc.get_bytes(start, size)
open(f"{start:X}.bin", "wb").write(code)
```
### 3. Emule-o duas vezes com Unicorn
```python
from unicorn import *
from unicorn.x86_const import *
import struct

def run(code, zf=0, cf=0):
BASE = 0x1000
mu = Uc(UC_ARCH_X86, UC_MODE_64)
mu.mem_map(BASE, 0x1000)
mu.mem_write(BASE, code)
mu.reg_write(UC_X86_REG_RFLAGS, (zf << 6) | cf)
mu.reg_write(UC_X86_REG_RAX, 0)
mu.emu_start(BASE, BASE+len(code))
return mu.reg_read(UC_X86_REG_RAX)
```
Execute `run(code,0,0)` e `run(code,1,1)` para obter os alvos dos ramos *falso* e *verdadeiro*.

### 4. Repare um salto / chamada direta
```python
import struct, ida_bytes

def patch_direct(ea, target, is_call=False):
op   = 0xE8 if is_call else 0xE9           # CALL rel32 or JMP rel32
disp = target - (ea + 5) & 0xFFFFFFFF
ida_bytes.patch_bytes(ea, bytes([op]) + struct.pack('<I', disp))
```
Após aplicar o patch, force o IDA a reanalisar a função para que o CFG completo e a saída do Hex-Rays sejam restaurados:
```python
import ida_auto, idaapi
idaapi.reanalyze_function(idc.get_func_attr(ea, idc.FUNCATTR_START))
```
### 5. Rotule chamadas de API indiretas

Uma vez que o verdadeiro destino de cada `call rax` é conhecido, você pode informar ao IDA qual é, para que os tipos de parâmetros e nomes de variáveis sejam recuperados automaticamente:
```python
idc.set_callee_name(call_ea, resolved_addr, 0)  # IDA 8.3+
```
### Benefícios práticos

* Restaura o CFG real → a descompilação passa de *10* linhas para milhares.
* Permite referência cruzada de strings & xrefs, tornando a reconstrução de comportamento trivial.
* Scripts são reutilizáveis: basta colocá-los em qualquer loader protegido pelo mesmo truque.

---

## Referências

- [Unit42 – Evolving Tactics of SLOW#TEMPEST: A Deep Dive Into Advanced Malware Techniques](https://unit42.paloaltonetworks.com/slow-tempest-malware-obfuscation/)

{{#include ../../banners/hacktricks-training.md}}
