# Analyse de malware

{{#include ../../banners/hacktricks-training.md}}

## Fiches CheatSheets d'informatique légale

[https://www.jaiminton.com/cheatsheet/DFIR/#](https://www.jaiminton.com/cheatsheet/DFIR/)

## Services en ligne

- [VirusTotal](https://www.virustotal.com/gui/home/upload)
- [HybridAnalysis](https://www.hybrid-analysis.com)
- [Koodous](https://koodous.com)
- [Intezer](https://analyze.intezer.com)
- [Any.Run](https://any.run/)

## Outils antivirus et de détection hors ligne

### Yara

#### Installation
```bash
sudo apt-get install -y yara
```
#### Préparez les règles

Utilisez ce script pour télécharger et fusionner toutes les règles yara malware depuis github: [https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9](https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9)\
Créez le répertoire _**rules**_ puis exécutez le script. Cela créera un fichier appelé _**malware_rules.yar**_ qui contient toutes les règles yara pour malware.
```bash
wget https://gist.githubusercontent.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9/raw/4ec711d37f1b428b63bed1f786b26a0654aa2f31/malware_yara_rules.py
mkdir rules
python malware_yara_rules.py
```
#### Analyse
```bash
yara -w malware_rules.yar image  #Scan 1 file
yara -w malware_rules.yar folder #Scan the whole folder
```
#### YaraGen: Détecter le malware et créer des règles

Vous pouvez utiliser l'outil [**YaraGen**](https://github.com/Neo23x0/yarGen) pour générer des yara rules à partir d'un binaire. Consultez ces tutoriels : [**Part 1**](https://www.nextron-systems.com/2015/02/16/write-simple-sound-yara-rules/), [**Part 2**](https://www.nextron-systems.com/2015/10/17/how-to-write-simple-but-sound-yara-rules-part-2/), [**Part 3**](https://www.nextron-systems.com/2016/04/15/how-to-write-simple-but-sound-yara-rules-part-3/)
```bash
python3 yarGen.py --update
python3.exe yarGen.py --excludegood -m  ../../mals/
```
### ClamAV

#### Installer
```
sudo apt-get install -y clamav
```
#### Analyse
```bash
sudo freshclam      #Update rules
clamscan filepath   #Scan 1 file
clamscan folderpath #Scan the whole folder
```
### [Capa](https://github.com/mandiant/capa)

**Capa** détecte des **capacités** potentiellement malveillantes dans les exécutables : PE, ELF, .NET. Il trouvera donc des éléments tels que les tactiques Att\&ck, ou des capacités suspectes telles que :

- vérifier la présence d'une erreur OutputDebugString
- s'exécuter en tant que service
- créer un processus

Récupérez-le dans le [**Github repo**](https://github.com/mandiant/capa).

### IOCs

IOC signifie Indicateur de compromission. Un IOC est un ensemble de **conditions qui identifient** un logiciel potentiellement indésirable ou un **malware** confirmé. Les Blue Teams utilisent ce type de définition pour **rechercher ce type de fichiers malveillants** dans leurs **systèmes** et **réseaux**.\
Partager ces définitions est très utile : lorsqu'un **malware** est identifié sur un ordinateur et qu'un IOC pour ce malware est créé, d'autres Blue Teams peuvent l'utiliser pour identifier le malware plus rapidement.

Un outil pour créer ou modifier des IOC est [**IOC Editor**](https://www.fireeye.com/services/freeware/ioc-editor.html)**.**\
Vous pouvez utiliser des outils tels que [**Redline**](https://www.fireeye.com/services/freeware/redline.html) pour **rechercher des IOC définis sur un appareil**.

### Loki

[**Loki**](https://github.com/Neo23x0/Loki) est un scanner pour les Simple Indicators of Compromise.\
La détection est basée sur quatre méthodes de détection :
```
1. File Name IOC
Regex match on full file path/name

2. Yara Rule Check
Yara signature matches on file data and process memory

3. Hash Check
Compares known malicious hashes (MD5, SHA1, SHA256) with scanned files

4. C2 Back Connect Check
Compares process connection endpoints with C2 IOCs (new since version v.10)
```
### Linux Malware Detect

[**Linux Malware Detect (LMD)**](https://www.rfxn.com/projects/linux-malware-detect/) est un scanner de malware pour Linux, publié sous licence GNU GPLv2, conçu pour les menaces rencontrées dans les environnements d'hébergement mutualisé. Il utilise des données de menace provenant de systèmes de détection d'intrusion en périphérie réseau pour extraire les malware activement utilisés dans des attaques et génère des signatures pour leur détection. De plus, des données de menace sont également dérivées des soumissions d'utilisateurs via la fonctionnalité de checkout de LMD et des ressources communautaires sur les malware.

### rkhunter

Des outils comme [**rkhunter**](http://rkhunter.sourceforge.net) peuvent être utilisés pour vérifier le système de fichiers à la recherche de possibles **rootkits** et malware.
```bash
sudo ./rkhunter --check -r / -l /tmp/rkhunter.log [--report-warnings-only] [--skip-keypress]
```
### FLOSS

[**FLOSS**](https://github.com/mandiant/flare-floss) est un outil qui tente de trouver des chaînes obfusquées à l'intérieur des exécutables en utilisant différentes techniques.

### PEpper

[PEpper ](https://github.com/Th3Hurrican3/PEpper) vérifie quelques éléments basiques dans l'exécutable (données binaires, entropie, URLs et IPs, quelques règles yara).

### PEstudio

[PEstudio](https://www.winitor.com/download) est un outil qui permet d'obtenir des informations sur des exécutables Windows tels que imports, exports, headers, mais vérifie aussi virus total et identifie des techniques potentielles d'Att\&ck.

### Detect It Easy(DiE)

[**DiE**](https://github.com/horsicq/Detect-It-Easy/) est un outil pour détecter si un fichier est **chiffré** et aussi pour trouver des **packers**.

### NeoPI

[**NeoPI** ](https://github.com/CiscoCXSecurity/NeoPI) est un script Python qui utilise diverses **méthodes statistiques** pour détecter du contenu **obfusqué** et **chiffré** dans des fichiers texte/script. Le but de NeoPI est d'aider à la **détection de code web shell caché**.

### **php-malware-finder**

[**PHP-malware-finder**](https://github.com/nbs-system/php-malware-finder) fait de son mieux pour détecter du code **obfusqué**/**suspect** ainsi que des fichiers utilisant des fonctions **PHP** souvent utilisées dans des **malwares**/webshells.

### Apple Binary Signatures

Lorsque vous examinez un **malware sample**, vous devriez toujours **vérifier la signature** du binaire car le **developer** qui l'a signé peut déjà être **lié** au **malware.**
```bash
#Get signer
codesign -vv -d /bin/ls 2>&1 | grep -E "Authority|TeamIdentifier"

#Check if the app’s contents have been modified
codesign --verify --verbose /Applications/Safari.app

#Check if the signature is valid
spctl --assess --verbose /Applications/Safari.app
```
## Techniques de détection

### Empilement de fichiers

Si vous savez qu'un dossier contenant les **fichiers** d'un serveur web a été **mis à jour pour la dernière fois à une certaine date**, **vérifiez** la **date** de création et de modification de **tous les fichiers** du **serveur web** et si une date est **suspecte**, examinez ce fichier.

### Lignes de base

Si les fichiers d'un dossier **n'auraient pas dû être modifiés**, vous pouvez calculer le **hash** des **fichiers originaux** du dossier et les **comparer** avec ceux **actuels**. Tout élément modifié sera **suspect**.

### Analyse statistique

Lorsque l'information est enregistrée dans des logs, vous pouvez **vérifier des statistiques**, par exemple combien de fois chaque fichier d'un serveur web a été accédé — un web shell peut être parmi les plus accédés.

---

### Android in-app native telemetry (no root)

Sur Android, vous pouvez instrumenter du code natif à l'intérieur du processus de l'application cible en préchargeant une petite librairie de logging avant l'initialisation des autres libs JNI. Cela donne une visibilité précoce sur le comportement natif sans hooks système ni root. Une approche populaire est SoTap : placez libsotap.so pour l'ABI appropriée dans l'APK et injectez un appel System.loadLibrary("sotap") tôt (par ex. initialiseur statique ou Application.onCreate), puis collectez les logs à partir des chemins internes/externes ou en fallback via Logcat.

Voir la page Android native reversing pour les détails de configuration et les chemins des logs :

{{#ref}}
../../mobile-pentesting/android-app-pentesting/reversing-native-libraries.md
{{#endref}}

---

## Déobfuscation du contrôle de flux dynamique (JMP/CALL RAX Dispatchers)

Les familles de malware modernes abusent fortement de l'obfuscation du Control-Flow Graph (CFG) : au lieu d'un jump/call direct, elles calculent la destination à l'exécution et exécutent un `jmp rax` ou `call rax`. Un petit *dispatcher* (typiquement neuf instructions) définit la cible finale en fonction des drapeaux CPU `ZF`/`CF`, rompant complètement la récupération statique du CFG.

La technique — mise en évidence par le loader SLOW#TEMPEST — peut être contrecarrée par un workflow en trois étapes qui ne s'appuie que sur IDAPython et l'émulateur CPU Unicorn.

### 1. Localiser chaque jump / call indirect
```python
import idautils, idc

for ea in idautils.FunctionItems(idc.here()):
mnem = idc.print_insn_mnem(ea)
if mnem in ("jmp", "call") and idc.print_operand(ea, 0) == "rax":
print(f"[+] Dispatcher found @ {ea:X}")
```
### 2. Extraire le dispatcher byte-code
```python
import idc

def get_dispatcher_start(jmp_ea, count=9):
s = jmp_ea
for _ in range(count):
s = idc.prev_head(s, 0)
return s

start = get_dispatcher_start(jmp_ea)
size  = jmp_ea + idc.get_item_size(jmp_ea) - start
code  = idc.get_bytes(start, size)
open(f"{start:X}.bin", "wb").write(code)
```
### 3. Émulez-le deux fois avec Unicorn
```python
from unicorn import *
from unicorn.x86_const import *
import struct

def run(code, zf=0, cf=0):
BASE = 0x1000
mu = Uc(UC_ARCH_X86, UC_MODE_64)
mu.mem_map(BASE, 0x1000)
mu.mem_write(BASE, code)
mu.reg_write(UC_X86_REG_RFLAGS, (zf << 6) | cf)
mu.reg_write(UC_X86_REG_RAX, 0)
mu.emu_start(BASE, BASE+len(code))
return mu.reg_read(UC_X86_REG_RAX)
```
Exécutez `run(code,0,0)` et `run(code,1,1)` pour obtenir les cibles de branche *false* et *true*.

### 4. Patch back a direct jump / call
```python
import struct, ida_bytes

def patch_direct(ea, target, is_call=False):
op   = 0xE8 if is_call else 0xE9           # CALL rel32 or JMP rel32
disp = target - (ea + 5) & 0xFFFFFFFF
ida_bytes.patch_bytes(ea, bytes([op]) + struct.pack('<I', disp))
```
Après le patch, forcez IDA à ré-analyser la fonction afin que le CFG complet et la sortie Hex-Rays soient restaurés :
```python
import ida_auto, idaapi
idaapi.reanalyze_function(idc.get_func_attr(ea, idc.FUNCATTR_START))
```
### 5. Étiqueter les appels API indirects

Une fois que la destination réelle de chaque `call rax` est connue, vous pouvez indiquer à IDA de quoi il s'agit afin que les types de paramètres et les noms de variables soient récupérés automatiquement :
```python
idc.set_callee_name(call_ea, resolved_addr, 0)  # IDA 8.3+
```
### Avantages pratiques

* Restaure le vrai CFG → la decompilation passe de *10* lignes à des milliers.
* Permet string-cross-reference & xrefs, rendant la reconstruction du comportement triviale.
* Les Scripts sont réutilisables : déposez-les dans n'importe quel loader protégé par le même trick.

---

## Références

- [Unit42 – Evolving Tactics of SLOW#TEMPEST: A Deep Dive Into Advanced Malware Techniques](https://unit42.paloaltonetworks.com/slow-tempest-malware-obfuscation/)
- SoTap: Lightweight in-app JNI (.so) behavior logger – [github.com/RezaArbabBot/SoTap](https://github.com/RezaArbabBot/SoTap)

{{#include ../../banners/hacktricks-training.md}}
