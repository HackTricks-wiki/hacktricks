# Malware Analysis

{{#include ../../banners/hacktricks-training.md}}

## Forensics चीटशीट्स

[https://www.jaiminton.com/cheatsheet/DFIR/#](https://www.jaiminton.com/cheatsheet/DFIR/)

## ऑनलाइन सेवाएँ

- [VirusTotal](https://www.virustotal.com/gui/home/upload)
- [HybridAnalysis](https://www.hybrid-analysis.com)
- [Koodous](https://koodous.com)
- [Intezer](https://analyze.intezer.com)
- [Any.Run](https://any.run/)

## ऑफ़लाइन एंटीवायरस और डिटेक्शन टूल्स

### Yara

#### इंस्टॉल
```bash
sudo apt-get install -y yara
```
#### नियम तैयार करें

इस स्क्रिप्ट का उपयोग करके github से सभी yara malware rules डाउनलोड और मर्ज करें: [https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9](https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9)\
Create the _**rules**_ directory and execute it. This will create a file called _**malware_rules.yar**_ which contains all the yara rules for malware.
```bash
wget https://gist.githubusercontent.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9/raw/4ec711d37f1b428b63bed1f786b26a0654aa2f31/malware_yara_rules.py
mkdir rules
python malware_yara_rules.py
```
#### स्कैन
```bash
yara -w malware_rules.yar image  #Scan 1 file
yara -w malware_rules.yar folder #Scan the whole folder
```
#### YaraGen: malware की जाँच और नियम बनाएँ

आप बाइनरी से yara rules जनरेट करने के लिए टूल [**YaraGen**](https://github.com/Neo23x0/yarGen) का उपयोग कर सकते हैं। इन ट्यूटोरियल्स को देखें: [**Part 1**](https://www.nextron-systems.com/2015/02/16/write-simple-sound-yara-rules/), [**Part 2**](https://www.nextron-systems.com/2015/10/17/how-to-write-simple-but-sound-yara-rules-part-2/), [**Part 3**](https://www.nextron-systems.com/2016/04/15/how-to-write-simple-but-sound-yara-rules-part-3/)
```bash
python3 yarGen.py --update
python3.exe yarGen.py --excludegood -m  ../../mals/
```
### ClamAV

#### इंस्टॉल
```
sudo apt-get install -y clamav
```
#### Scan
```bash
sudo freshclam      #Update rules
clamscan filepath   #Scan 1 file
clamscan folderpath #Scan the whole folder
```
### [Capa](https://github.com/mandiant/capa)

**Capa** संभावित रूप से दुर्भावनापूर्ण **capabilities** को executables: PE, ELF, .NET में पहचानता है। इसलिए यह Att\&ck tactics जैसी चीज़ें या निम्नलिखित संदिग्ध क्षमताओं को ढूँढेगा:

- OutputDebugString error की जाँच
- सेवा के रूप में चलना
- process बनाना

Get it int he [**Github repo**](https://github.com/mandiant/capa).

### IOCs

IOC means Indicator Of Compromise. एक IOC उन **conditions that identify** की एक सेट होती है जो कुछ संभावित अनचाहे सॉफ़्टवेयर या पुष्ट **malware** की पहचान करती है। Blue Teams इस प्रकार की परिभाषा का उपयोग अपने **systems** और **networks** में इस प्रकार की दुर्भावनापूर्ण फ़ाइलों की **search for this kind of malicious files** के लिए करते हैं.\

इन परिभाषाओं को साझा करना बहुत उपयोगी होता है क्योंकि जब किसी कंप्यूटर में malware की पहचान होती है और उस malware के लिए IOC बनाया जाता है, तो अन्य Blue Teams इसका उपयोग करके malware को तेज़ी से पहचान सकती हैं।

IOC बनाने या संशोधित करने के लिए एक टूल [**IOC Editor**](https://www.fireeye.com/services/freeware/ioc-editor.html)**.**\
आप [**Redline**](https://www.fireeye.com/services/freeware/redline.html) जैसे टूल का उपयोग **परिभाषित IOCs को किसी डिवाइस में खोजने के लिए** कर सकते हैं।

### Loki

[**Loki**](https://github.com/Neo23x0/Loki) is a scanner for Simple Indicators of Compromise.\
Detection is based on four detection methods:
```
1. File Name IOC
Regex match on full file path/name

2. Yara Rule Check
Yara signature matches on file data and process memory

3. Hash Check
Compares known malicious hashes (MD5, SHA1, SHA256) with scanned files

4. C2 Back Connect Check
Compares process connection endpoints with C2 IOCs (new since version v.10)
```
### Linux Malware Detect

[**Linux Malware Detect (LMD)**](https://www.rfxn.com/projects/linux-malware-detect/) एक Linux के लिए malware स्कैनर है जो GNU GPLv2 license के तहत जारी किया गया है, और यह साझा होस्टेड वातावरणों में सामना किए जाने वाले खतरों को ध्यान में रखकर डिज़ाइन किया गया है। यह network edge intrusion detection systems से threat data का उपयोग करके सक्रिय रूप से हमलों में उपयोग हो रहे malware को extract करता है और detection के लिए signatures जनरेट करता है। इसके अतिरिक्त, threat data LMD checkout feature के माध्यम से user submissions और malware community resources से भी प्राप्त किया जाता है।

### rkhunter

Tools like [**rkhunter**](http://rkhunter.sourceforge.net) filesystem को संभावित **rootkits** और malware के लिए जांचने में उपयोग किए जा सकते हैं।
```bash
sudo ./rkhunter --check -r / -l /tmp/rkhunter.log [--report-warnings-only] [--skip-keypress]
```
### FLOSS

[**FLOSS**](https://github.com/mandiant/flare-floss) एक टूल है जो अलग‑अलग तकनीकों का उपयोग करके executables के अंदर obfuscated strings खोजने की कोशिश करेगा।

### PEpper

[PEpper ](https://github.com/Th3Hurrican3/PEpper) executable के अंदर कुछ बुनियादी चीज़ें चेक करता है (binary data, entropy, URLs and IPs, some yara rules)।

### PEstudio

[PEstudio](https://www.winitor.com/download) एक टूल है जो Windows executables की जानकारी प्राप्त करने की अनुमति देता है जैसे imports, exports, headers, और साथ ही virus total की जाँच करता है और संभावित Att\&ck techniques ढूँढता है।

### Detect It Easy(DiE)

[**DiE**](https://github.com/horsicq/Detect-It-Easy/) एक टूल है जो यह पता लगाने के लिए कि कोई फ़ाइल **encrypted** है या नहीं और साथ ही **packers** भी ढूँढता है।

### NeoPI

[**NeoPI** ](https://github.com/CiscoCXSecurity/NeoPI) एक Python script है जो text/script files के भीतर **statistical methods** की विविधता का उपयोग करके **obfuscated** और **encrypted** content का पता लगाती है। NeoPI का उद्देश्य **detection of hidden web shell code** में सहायता करना है।

### **php-malware-finder**

[**PHP-malware-finder**](https://github.com/nbs-system/php-malware-finder) अपनी पूरी कोशिश करता है ताकि **obfuscated**/**dodgy code** के साथ-साथ उन फ़ाइलों का भी पता चल सके जो अक्सर **PHP** functions का उपयोग करती हैं जो **malwares**/webshells में दिखाई देते हैं।

### Apple Binary Signatures

जब आप किसी **malware sample** की जाँच कर रहे हों तो हमेशा बाइनरी के **check the signature** को देखें क्योंकि जिसने इसे साइन किया है वह **developer** पहले से ही **related** with **malware** हो सकता है।
```bash
#Get signer
codesign -vv -d /bin/ls 2>&1 | grep -E "Authority|TeamIdentifier"

#Check if the app’s contents have been modified
codesign --verify --verbose /Applications/Safari.app

#Check if the signature is valid
spctl --assess --verbose /Applications/Safari.app
```
## डिटेक्शन तकनीकें

### File Stacking

यदि आप जानते हैं कि किसी फ़ोल्डर में web server के **files** थे जिन्हें **last updated on some date** किया गया था। **Check** करें कि web server के सभी **files** किस **date** पर created और modified हुए थे, और अगर कोई date **suspicious** लगे, तो उस file की जाँच करें।

### Baselines

यदि किसी फ़ोल्डर के **files** को **shouldn't have been modified** होना चाहिए था, तो आप फ़ोल्डर के **original files** का **hash** निकालकर उन्हें **current** वाले से **compare** कर सकते हैं। जो कुछ भी modified होगा वह **suspicious** माना जाएगा।

### Statistical Analysis

जब जानकारी logs में सेव होती है तो आप **check statistics like how many times each file of a web server was accessed as a web shell might be one of the most** कर सकते हैं — यानी यह देख सकते हैं कि web server के किस **file** तक कितनी बार access हुआ, क्योंकि एक web shell संभवतः सबसे ज़्यादा access किए जाने वाले में से एक हो सकता है।

---

### Android in-app native telemetry (no root)

Android पर आप target app process के अंदर native code को instrument कर सकते हैं एक छोटा logger library पहले preload करके, इससे पहले कि अन्य JNI libs initialize हों। इससे system-wide hooks या root के बिना native व्यवहार की early visibility मिलती है। एक लोकप्रिय तरीका SoTap है: सही ABI के लिए libsotap.so को APK में drop करें और early में System.loadLibrary("sotap") call inject करें (उदा., static initializer या Application.onCreate), फिर internal/external paths से logs collect करें या Logcat fallback का उपयोग करें।

See the Android native reversing page for setup details and log paths:

{{#ref}}
../../mobile-pentesting/android-app-pentesting/reversing-native-libraries.md
{{#endref}}

---

## Deobfuscating Dynamic Control-Flow (JMP/CALL RAX Dispatchers)

आधुनिक malware परिवार Control-Flow Graph (CFG) obfuscation का भारी उपयोग करते हैं: सीधे jump/call के बजाय वे destination को run-time पर compute करते हैं और `jmp rax` या `call rax` execute करते हैं। एक छोटा *dispatcher* (आम तौर पर नौ instructions) CPU के `ZF`/`CF` flags पर निर्भर करके final target सेट करता है, जिससे static CFG recovery पूरी तरह टूट जाती है।

यह technique — SLOW#TEMPEST loader द्वारा प्रदर्शित — IDAPython और Unicorn CPU emulator पर ही निर्भर तीन-स्टेप workflow से bypass की जा सकती है।

### 1. Locate every indirect jump / call
```python
import idautils, idc

for ea in idautils.FunctionItems(idc.here()):
mnem = idc.print_insn_mnem(ea)
if mnem in ("jmp", "call") and idc.print_operand(ea, 0) == "rax":
print(f"[+] Dispatcher found @ {ea:X}")
```
### 2. डिस्पैचर का बाइट-कोड निकालें
```python
import idc

def get_dispatcher_start(jmp_ea, count=9):
s = jmp_ea
for _ in range(count):
s = idc.prev_head(s, 0)
return s

start = get_dispatcher_start(jmp_ea)
size  = jmp_ea + idc.get_item_size(jmp_ea) - start
code  = idc.get_bytes(start, size)
open(f"{start:X}.bin", "wb").write(code)
```
### 3. इसे Unicorn के साथ दो बार अनुकरण करें
```python
from unicorn import *
from unicorn.x86_const import *
import struct

def run(code, zf=0, cf=0):
BASE = 0x1000
mu = Uc(UC_ARCH_X86, UC_MODE_64)
mu.mem_map(BASE, 0x1000)
mu.mem_write(BASE, code)
mu.reg_write(UC_X86_REG_RFLAGS, (zf << 6) | cf)
mu.reg_write(UC_X86_REG_RAX, 0)
mu.emu_start(BASE, BASE+len(code))
return mu.reg_read(UC_X86_REG_RAX)
```
`run(code,0,0)` और `run(code,1,1)` चलाएँ ताकि आप *false* और *true* ब्रांच टार्गेट प्राप्त कर सकें।

### 4. एक direct jump / call को वापस पैच करें
```python
import struct, ida_bytes

def patch_direct(ea, target, is_call=False):
op   = 0xE8 if is_call else 0xE9           # CALL rel32 or JMP rel32
disp = target - (ea + 5) & 0xFFFFFFFF
ida_bytes.patch_bytes(ea, bytes([op]) + struct.pack('<I', disp))
```
पैच करने के बाद, IDA को फ़ंक्शन का पुनः विश्लेषण करने के लिए मजबूर करें ताकि पूरा CFG और Hex-Rays आउटपुट बहाल हो:
```python
import ida_auto, idaapi
idaapi.reanalyze_function(idc.get_func_attr(ea, idc.FUNCATTR_START))
```
### 5. अप्रत्यक्ष API कॉल्स को लेबल करें

एक बार जब हर `call rax` का वास्तविक गंतव्य ज्ञात हो जाता है, तो आप IDA को बता सकते हैं कि वह क्या है ताकि पैरामीटर प्रकार और वेरिएबल नाम स्वचालित रूप से पुनर्प्राप्त हो जाएँ:
```python
idc.set_callee_name(call_ea, resolved_addr, 0)  # IDA 8.3+
```
### व्यावहारिक लाभ

* वास्तविक CFG को बहाल करता है → decompilation *10* लाइनों से हजारों तक पहुँच जाता है।
* string-cross-reference & xrefs सक्षम होते हैं, जिससे behaviour reconstruction सरल हो जाता है।
* Scripts पुनः उपयोग योग्य हैं: इन्हें उसी trick द्वारा सुरक्षित किसी भी loader में डालें।

---

## संदर्भ

- [Unit42 – Evolving Tactics of SLOW#TEMPEST: A Deep Dive Into Advanced Malware Techniques](https://unit42.paloaltonetworks.com/slow-tempest-malware-obfuscation/)
- SoTap: Lightweight in-app JNI (.so) behavior logger – [github.com/RezaArbabBot/SoTap](https://github.com/RezaArbabBot/SoTap)

{{#include ../../banners/hacktricks-training.md}}
