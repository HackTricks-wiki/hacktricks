# Analyse de Malware

{{#include ../../banners/hacktricks-training.md}}

## Fiches de Triche en Criminalistique

[https://www.jaiminton.com/cheatsheet/DFIR/#](https://www.jaiminton.com/cheatsheet/DFIR/)

## Services en Ligne

- [VirusTotal](https://www.virustotal.com/gui/home/upload)
- [HybridAnalysis](https://www.hybrid-analysis.com)
- [Koodous](https://koodous.com)
- [Intezer](https://analyze.intezer.com)
- [Any.Run](https://any.run/)

## Outils Antivirus et de Détection Hors Ligne

### Yara

#### Installer
```bash
sudo apt-get install -y yara
```
#### Préparer les règles

Utilisez ce script pour télécharger et fusionner toutes les règles yara de malware depuis github : [https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9](https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9)\
Créez le répertoire _**rules**_ et exécutez-le. Cela créera un fichier appelé _**malware_rules.yar**_ qui contient toutes les règles yara pour les malwares.
```bash
wget https://gist.githubusercontent.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9/raw/4ec711d37f1b428b63bed1f786b26a0654aa2f31/malware_yara_rules.py
mkdir rules
python malware_yara_rules.py
```
#### Scanner
```bash
yara -w malware_rules.yar image  #Scan 1 file
yara -w malware_rules.yar folder #Scan the whole folder
```
#### YaraGen : Vérifiez la présence de malware et créez des règles

Vous pouvez utiliser l'outil [**YaraGen**](https://github.com/Neo23x0/yarGen) pour générer des règles yara à partir d'un binaire. Consultez ces tutoriels : [**Partie 1**](https://www.nextron-systems.com/2015/02/16/write-simple-sound-yara-rules/), [**Partie 2**](https://www.nextron-systems.com/2015/10/17/how-to-write-simple-but-sound-yara-rules-part-2/), [**Partie 3**](https://www.nextron-systems.com/2016/04/15/how-to-write-simple-but-sound-yara-rules-part-3/)
```bash
python3 yarGen.py --update
python3.exe yarGen.py --excludegood -m  ../../mals/
```
### ClamAV

#### Installer
```
sudo apt-get install -y clamav
```
#### Analyse
```bash
sudo freshclam      #Update rules
clamscan filepath   #Scan 1 file
clamscan folderpath #Scan the whole folder
```
### [Capa](https://github.com/mandiant/capa)

**Capa** détecte des **capabilités** potentiellement malveillantes dans les exécutables : PE, ELF, .NET. Il trouvera donc des éléments tels que les tactiques Att\&ck, ou des capacités suspectes telles que :

- vérifier l'erreur OutputDebugString
- s'exécuter en tant que service
- créer un processus

Obtenez-le dans le [**Github repo**](https://github.com/mandiant/capa).

### IOCs

IOC signifie Indicateur de Compromission. Un IOC est un ensemble de **conditions qui identifient** un logiciel potentiellement indésirable ou un **malware** confirmé. Les Blue Teams utilisent ce type de définition pour **rechercher ce type de fichiers malveillants** dans leurs **systèmes** et **réseaux**.\
Partager ces définitions est très utile car lorsque le malware est identifié sur un ordinateur et qu'un IOC pour ce malware est créé, d'autres Blue Teams peuvent l'utiliser pour identifier le malware plus rapidement.

Un outil pour créer ou modifier des IOCs est [**IOC Editor**](https://www.fireeye.com/services/freeware/ioc-editor.html)**.**\
Vous pouvez utiliser des outils tels que [**Redline**](https://www.fireeye.com/services/freeware/redline.html) pour **rechercher des IOCs définis dans un appareil**.

### Loki

[**Loki**](https://github.com/Neo23x0/Loki) est un scanner pour des Indicateurs de Compromission Simples.\
La détection est basée sur quatre méthodes de détection :
```
1. File Name IOC
Regex match on full file path/name

2. Yara Rule Check
Yara signature matches on file data and process memory

3. Hash Check
Compares known malicious hashes (MD5, SHA1, SHA256) with scanned files

4. C2 Back Connect Check
Compares process connection endpoints with C2 IOCs (new since version v.10)
```
### Linux Malware Detect

[**Linux Malware Detect (LMD)**](https://www.rfxn.com/projects/linux-malware-detect/) est un scanner de malware pour Linux publié sous la licence GNU GPLv2, conçu autour des menaces rencontrées dans les environnements d'hébergement partagé. Il utilise des données de menaces provenant de systèmes de détection d'intrusion en bordure de réseau pour extraire les malwares qui sont activement utilisés dans des attaques et génère des signatures pour la détection. De plus, les données de menaces proviennent également des soumissions des utilisateurs avec la fonctionnalité de vérification LMD et des ressources de la communauté des malwares.

### rkhunter

Des outils comme [**rkhunter**](http://rkhunter.sourceforge.net) peuvent être utilisés pour vérifier le système de fichiers à la recherche de **rootkits** et de malwares.
```bash
sudo ./rkhunter --check -r / -l /tmp/rkhunter.log [--report-warnings-only] [--skip-keypress]
```
### FLOSS

[**FLOSS**](https://github.com/mandiant/flare-floss) est un outil qui essaiera de trouver des chaînes obfusquées à l'intérieur des exécutables en utilisant différentes techniques.

### PEpper

[PEpper ](https://github.com/Th3Hurrican3/PEpper) vérifie certaines informations de base à l'intérieur de l'exécutable (données binaires, entropie, URLs et IPs, certaines règles yara).

### PEstudio

[PEstudio](https://www.winitor.com/download) est un outil qui permet d'obtenir des informations sur les exécutables Windows tels que les imports, les exports, les en-têtes, mais vérifiera également virus total et trouvera des techniques Att\&ck potentielles.

### Detect It Easy(DiE)

[**DiE**](https://github.com/horsicq/Detect-It-Easy/) est un outil pour détecter si un fichier est **chiffré** et également trouver des **packers**.

### NeoPI

[**NeoPI** ](https://github.com/CiscoCXSecurity/NeoPI) est un script Python qui utilise une variété de **méthodes statistiques** pour détecter du contenu **obfusqué** et **chiffré** dans des fichiers texte/script. L'objectif de NeoPI est d'aider à la **détection de code de shell web caché**.

### **php-malware-finder**

[**PHP-malware-finder**](https://github.com/nbs-system/php-malware-finder) fait de son mieux pour détecter du **code obfusqué**/**suspect** ainsi que des fichiers utilisant des fonctions **PHP** souvent utilisées dans des **malwares**/webshells.

### Apple Binary Signatures

Lors de la vérification d'un **échantillon de malware**, vous devez toujours **vérifier la signature** du binaire car le **développeur** qui l'a signé peut déjà être **lié** à des **malwares.**
```bash
#Get signer
codesign -vv -d /bin/ls 2>&1 | grep -E "Authority|TeamIdentifier"

#Check if the app’s contents have been modified
codesign --verify --verbose /Applications/Safari.app

#Check if the signature is valid
spctl --assess --verbose /Applications/Safari.app
```
## Techniques de Détection

### Empilement de Fichiers

Si vous savez qu'un dossier contenant les **fichiers** d'un serveur web a été **dernièrement mis à jour à une certaine date**. **Vérifiez** la **date** à laquelle tous les **fichiers** du **serveur web ont été créés et modifiés** et si une date est **suspecte**, vérifiez ce fichier.

### Lignes de Base

Si les fichiers d'un dossier **n'auraient pas dû être modifiés**, vous pouvez calculer le **hash** des **fichiers originaux** du dossier et **les comparer** avec les **actuels**. Tout ce qui a été modifié sera **suspect**.

### Analyse Statistique

Lorsque l'information est enregistrée dans des journaux, vous pouvez **vérifier des statistiques comme le nombre de fois que chaque fichier d'un serveur web a été accédé, car un web shell pourrait être l'un des plus**.

{{#include ../../banners/hacktricks-training.md}}
