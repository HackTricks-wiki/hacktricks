# 맬웨어 분석

{{#include ../../banners/hacktricks-training.md}}

## 포렌식 치트시트

[https://www.jaiminton.com/cheatsheet/DFIR/#](https://www.jaiminton.com/cheatsheet/DFIR/)

## 온라인 서비스

- [VirusTotal](https://www.virustotal.com/gui/home/upload)
- [HybridAnalysis](https://www.hybrid-analysis.com)
- [Koodous](https://koodous.com)
- [Intezer](https://analyze.intezer.com)
- [Any.Run](https://any.run/)

## 오프라인 안티바이러스 및 탐지 도구

### Yara

#### 설치
```bash
sudo apt-get install -y yara
```
#### 규칙 준비

이 스크립트를 사용하여 GitHub에서 모든 yara malware rules를 다운로드하고 병합하세요: [https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9](https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9)\
_**rules**_ 디렉터리를 만들고 스크립트를 실행하세요. 그러면 malware용 모든 yara rules를 포함한 _**malware_rules.yar**_ 파일이 생성됩니다.
```bash
wget https://gist.githubusercontent.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9/raw/4ec711d37f1b428b63bed1f786b26a0654aa2f31/malware_yara_rules.py
mkdir rules
python malware_yara_rules.py
```
#### Scan
```bash
yara -w malware_rules.yar image  #Scan 1 file
yara -w malware_rules.yar folder #Scan the whole folder
```
#### YaraGen: malware 검사 및 규칙 생성

도구 [**YaraGen**](https://github.com/Neo23x0/yarGen)를 사용해 바이너리로부터 yara rules를 생성할 수 있습니다. 다음 튜토리얼을 확인하세요: [**Part 1**](https://www.nextron-systems.com/2015/02/16/write-simple-sound-yara-rules/), [**Part 2**](https://www.nextron-systems.com/2015/10/17/how-to-write-simple-but-sound-yara-rules-part-2/), [**Part 3**](https://www.nextron-systems.com/2016/04/15/how-to-write-simple-but-sound-yara-rules-part-3/)
```bash
python3 yarGen.py --update
python3.exe yarGen.py --excludegood -m  ../../mals/
```
### ClamAV

#### 설치
```
sudo apt-get install -y clamav
```
#### 스캔
```bash
sudo freshclam      #Update rules
clamscan filepath   #Scan 1 file
clamscan folderpath #Scan the whole folder
```
### [Capa](https://github.com/mandiant/capa)

**Capa**는 실행 파일(PE, ELF, .NET)에서 잠재적으로 악의적인 **기능**을 탐지합니다. 따라서 Att\&ck 전술이나 다음과 같은 의심스러운 기능들을 찾아냅니다:

- OutputDebugString 오류 확인
- 서비스로 실행
- 프로세스 생성

다운로드는 [**Github repo**](https://github.com/mandiant/capa)에서 가능합니다.

### IOCs

IOC는 Indicator Of Compromise의 약자입니다. IOC는 잠재적으로 원치 않는 소프트웨어나 확인된 **malware**를 식별하는 일련의 **조건**입니다. Blue Teams는 이러한 정의를 사용하여 자신들의 **시스템** 및 **네트워크**에서 이러한 악성 파일을 **검색**합니다.\
이 정의들을 공유하는 것은 매우 유용합니다. 한 컴퓨터에서 malware가 식별되어 해당 malware에 대한 IOC가 만들어지면, 다른 Blue Teams가 이를 사용해 malware를 더 빠르게 식별할 수 있기 때문입니다.

A tool to create or modify IOCs is [**IOC Editor**](https://www.fireeye.com/services/freeware/ioc-editor.html)**.**\
You can use tools such as [**Redline**](https://www.fireeye.com/services/freeware/redline.html) to **search for defined IOCs in a device**.

### Loki

[**Loki**](https://github.com/Neo23x0/Loki) is a scanner for Simple Indicators of Compromise.\
Detection is based on four detection methods:
```
1. File Name IOC
Regex match on full file path/name

2. Yara Rule Check
Yara signature matches on file data and process memory

3. Hash Check
Compares known malicious hashes (MD5, SHA1, SHA256) with scanned files

4. C2 Back Connect Check
Compares process connection endpoints with C2 IOCs (new since version v.10)
```
### Linux Malware Detect

[**Linux Malware Detect (LMD)**](https://www.rfxn.com/projects/linux-malware-detect/) 는 GNU GPLv2 라이선스 하에 배포되는 Linux용 malware scanner로, 공유 호스팅 환경에서 직면하는 위협을 중심으로 설계되었습니다. 네트워크 에지 침입 탐지 시스템으로부터 얻은 위협 데이터를 사용해 실제 공격에 사용 중인 malware를 추출하고 탐지용 시그니처를 생성합니다. 또한 LMD의 checkout 기능을 통한 사용자 제출과 malware 커뮤니티 자원으로부터 위협 데이터가 추가로 수집됩니다.

### rkhunter

Tools like [**rkhunter**](http://rkhunter.sourceforge.net) can be used to check the filesystem for possible **rootkits** and malware.
```bash
sudo ./rkhunter --check -r / -l /tmp/rkhunter.log [--report-warnings-only] [--skip-keypress]
```
### FLOSS

[**FLOSS**](https://github.com/mandiant/flare-floss) 는 다양한 기법을 사용해 executables 내부의 obfuscated strings를 찾아내는 도구입니다.

### PEpper

[PEpper ](https://github.com/Th3Hurrican3/PEpper)checks executable 내부의 기본 항목들(binary data, entropy, URLs and IPs, some yara rules)을 검사합니다.

### PEstudio

[PEstudio](https://www.winitor.com/download) 는 imports, exports, headers 등의 Windows executables 정보를 제공하며, virus total을 확인하고 잠재적 Att\&ck techniques를 찾아냅니다.

### Detect It Easy(DiE)

[**DiE**](https://github.com/horsicq/Detect-It-Easy/) 는 파일이 **encrypted**인지 감지하고 **packers**를 찾아내는 도구입니다.

### NeoPI

[**NeoPI** ](https://github.com/CiscoCXSecurity/NeoPI)는 다양한 **statistical methods**를 사용해 text/script 파일 내의 **obfuscated** 및 **encrypted** 콘텐츠를 탐지하는 Python 스크립트입니다. NeoPI의 목적은 hidden web shell code의 **detection**을 돕는 것입니다.

### **php-malware-finder**

[**PHP-malware-finder**](https://github.com/nbs-system/php-malware-finder) 는 **obfuscated**/**dodgy code**뿐만 아니라 종종 malwares/webshells에서 사용되는 PHP 함수들을 사용하는 파일들을 탐지하려 최선을 다합니다.

### Apple Binary Signatures

When checking some **malware sample** you should always **check the signature** of the binary as the **developer** that signed it may be already **related** with **malware.**
```bash
#Get signer
codesign -vv -d /bin/ls 2>&1 | grep -E "Authority|TeamIdentifier"

#Check if the app’s contents have been modified
codesign --verify --verbose /Applications/Safari.app

#Check if the signature is valid
spctl --assess --verbose /Applications/Safari.app
```
## 탐지 기법

### File Stacking

어떤 폴더가 웹 서버의 **파일**을 포함하고 있고 **마지막으로 업데이트된 날짜**가 알려져 있다면, 웹 서버의 모든 **파일**이 생성 및 수정된 **날짜**를 **확인**하고 어떤 날짜가 **수상한** 경우 해당 파일을 조사하세요.

### Baselines

폴더의 파일들이 **수정되지 않아야 하는 경우**, 해당 폴더의 **원본 파일**의 **hash**를 계산하여 **현재** 파일들과 **비교**하세요. 변경된 항목은 **수상합니다**.

### Statistical Analysis

정보가 로그에 저장되어 있으면, 웹 서버의 각 파일이 얼마나 자주 접근되었는지와 같은 **통계(예: web shell이 가장 많이 접근된 파일 중 하나일 수 있음)를 확인**할 수 있습니다.

---

### Android in-app native telemetry (no root)

Android에서는, 타깃 앱 프로세스 내부의 네이티브 코드를 다른 JNI 라이브러리들이 초기화되기 전에 작은 로거 라이브러리를 프리로드하여 계측할 수 있습니다. 이렇게 하면 시스템 전역 훅이나 루트 없이도 네이티브 동작을 조기에 관찰할 수 있습니다. 널리 사용되는 접근법은 SoTap입니다: 올바른 ABI용 libsotap.so를 APK에 넣고 초기 시점(예: static initializer 또는 Application.onCreate)에 System.loadLibrary("sotap") 호출을 주입한 뒤, 내부/외부 경로나 Logcat으로 로그를 수집합니다.

설정 방법 및 로그 경로는 Android native reversing 페이지를 참조하세요:

{{#ref}}
../../mobile-pentesting/android-app-pentesting/reversing-native-libraries.md
{{#endref}}

---

## Deobfuscating Dynamic Control-Flow (JMP/CALL RAX Dispatchers)

최근 악성코드 계열은 Control-Flow Graph (CFG) 난독화를 광범위하게 남용합니다: 직접적인 jump/call 대신 실행 시 목적지를 계산하여 `jmp rax` 또는 `call rax`를 실행합니다. 작은 *dispatcher*(보통 9개 명령어)가 CPU의 `ZF`/`CF` 플래그에 따라 최종 타깃을 설정하며, 이는 정적 CFG 복구를 완전히 무력화합니다.

이 기법은 SLOW#TEMPEST 로더에서 보여졌으며, IDAPython과 Unicorn CPU emulator만으로 수행하는 세 단계 워크플로로 대응할 수 있습니다.

### 1. 모든 간접 jump / call 위치 찾기
```python
import idautils, idc

for ea in idautils.FunctionItems(idc.here()):
mnem = idc.print_insn_mnem(ea)
if mnem in ("jmp", "call") and idc.print_operand(ea, 0) == "rax":
print(f"[+] Dispatcher found @ {ea:X}")
```
### 2. dispatcher byte-code 추출
```python
import idc

def get_dispatcher_start(jmp_ea, count=9):
s = jmp_ea
for _ in range(count):
s = idc.prev_head(s, 0)
return s

start = get_dispatcher_start(jmp_ea)
size  = jmp_ea + idc.get_item_size(jmp_ea) - start
code  = idc.get_bytes(start, size)
open(f"{start:X}.bin", "wb").write(code)
```
### 3. Unicorn으로 두 번 에뮬레이트하기
```python
from unicorn import *
from unicorn.x86_const import *
import struct

def run(code, zf=0, cf=0):
BASE = 0x1000
mu = Uc(UC_ARCH_X86, UC_MODE_64)
mu.mem_map(BASE, 0x1000)
mu.mem_write(BASE, code)
mu.reg_write(UC_X86_REG_RFLAGS, (zf << 6) | cf)
mu.reg_write(UC_X86_REG_RAX, 0)
mu.emu_start(BASE, BASE+len(code))
return mu.reg_read(UC_X86_REG_RAX)
```
`run(code,0,0)` 및 `run(code,1,1)`을 실행하여 *false* 및 *true* 브랜치 타깃을 얻으세요.

### 4. 직접적인 jump / call을 되돌려 패치하기
```python
import struct, ida_bytes

def patch_direct(ea, target, is_call=False):
op   = 0xE8 if is_call else 0xE9           # CALL rel32 or JMP rel32
disp = target - (ea + 5) & 0xFFFFFFFF
ida_bytes.patch_bytes(ea, bytes([op]) + struct.pack('<I', disp))
```
패치한 후 IDA에게 함수를 재분석하도록 강제하여 전체 CFG와 Hex-Rays 출력이 복원되도록 합니다:
```python
import ida_auto, idaapi
idaapi.reanalyze_function(idc.get_func_attr(ea, idc.FUNCATTR_START))
```
### 5. 간접 API 호출에 라벨 지정

모든 `call rax`의 실제 목적지가 확인되면 IDA에 이를 알려 파라미터 타입 및 변수 이름이 자동으로 복원되도록 할 수 있다:
```python
idc.set_callee_name(call_ea, resolved_addr, 0)  # IDA 8.3+
```
### 실용적 이점

* 실제 CFG를 복원 → decompilation이 *10* 줄에서 수천 줄로 늘어납니다.
* 문자열 교차 참조 및 xrefs를 가능하게 하여 동작 재구성이 매우 쉬워집니다.
* 스크립트는 재사용 가능: 동일한 트릭으로 보호된 어떤 loader에도 넣어 사용하세요.

---

## AdaptixC2: 구성 추출 및 TTPs

전용 페이지 보기:

{{#ref}}
adaptixc2-config-extraction-and-ttps.md
{{#endref}}

## 참고 자료

- [Unit42 – Evolving Tactics of SLOW#TEMPEST: A Deep Dive Into Advanced Malware Techniques](https://unit42.paloaltonetworks.com/slow-tempest-malware-obfuscation/)
- SoTap: 경량 인앱 JNI (.so) 동작 로거 – [github.com/RezaArbabBot/SoTap](https://github.com/RezaArbabBot/SoTap)
- [Unit42 – AdaptixC2: A New Open-Source Framework Leveraged in Real-World Attacks](https://unit42.paloaltonetworks.com/adaptixc2-post-exploitation-framework/)

{{#include ../../banners/hacktricks-training.md}}
