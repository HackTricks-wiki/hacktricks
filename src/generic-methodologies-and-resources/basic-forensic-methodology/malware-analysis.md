# Analiza Malware

{{#include ../../banners/hacktricks-training.md}}

## Ściągi Forensics

[https://www.jaiminton.com/cheatsheet/DFIR/#](https://www.jaiminton.com/cheatsheet/DFIR/)

## Usługi online

- [VirusTotal](https://www.virustotal.com/gui/home/upload)
- [HybridAnalysis](https://www.hybrid-analysis.com)
- [Koodous](https://koodous.com)
- [Intezer](https://analyze.intezer.com)
- [Any.Run](https://any.run/)

## Offline — antywirusy i narzędzia wykrywania

### Yara

#### Instalacja
```bash
sudo apt-get install -y yara
```
#### Przygotuj reguły

Użyj tego skryptu, aby pobrać i scalić wszystkie reguły yara dotyczące malware z github: [https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9](https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9)\
Utwórz katalog _**rules**_ i uruchom skrypt. Spowoduje to utworzenie pliku o nazwie _**malware_rules.yar**_, który zawiera wszystkie reguły yara dla malware.
```bash
wget https://gist.githubusercontent.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9/raw/4ec711d37f1b428b63bed1f786b26a0654aa2f31/malware_yara_rules.py
mkdir rules
python malware_yara_rules.py
```
#### Skanowanie
```bash
yara -w malware_rules.yar image  #Scan 1 file
yara -w malware_rules.yar folder #Scan the whole folder
```
#### YaraGen: Sprawdzanie malware i tworzenie reguł

Możesz użyć narzędzia [**YaraGen**](https://github.com/Neo23x0/yarGen) aby wygenerować yara rules z pliku binarnego. Zobacz te poradniki: [**Część 1**](https://www.nextron-systems.com/2015/02/16/write-simple-sound-yara-rules/), [**Część 2**](https://www.nextron-systems.com/2015/10/17/how-to-write-simple-but-sound-yara-rules-part-2/), [**Część 3**](https://www.nextron-systems.com/2016/04/15/how-to-write-simple-but-sound-yara-rules-part-3/)
```bash
python3 yarGen.py --update
python3.exe yarGen.py --excludegood -m  ../../mals/
```
### ClamAV

#### Instalacja
```
sudo apt-get install -y clamav
```
#### Skanowanie
```bash
sudo freshclam      #Update rules
clamscan filepath   #Scan 1 file
clamscan folderpath #Scan the whole folder
```
### [Capa](https://github.com/mandiant/capa)

**Capa** wykrywa potencjalnie złośliwe **capabilities** w plikach wykonywalnych: PE, ELF, .NET. Dzięki temu znajdzie takie elementy jak Att\&ck tactics, albo podejrzane możliwości, takie jak:

- sprawdzanie błędu OutputDebugString
- uruchamianie jako usługa
- tworzenie procesu

Pobierz go z [**Github repo**](https://github.com/mandiant/capa).

### IOCs

IOC oznacza Indicator Of Compromise. IOC to zestaw **warunków, które identyfikują** potencjalnie niechciane oprogramowanie lub potwierdzone **malware**. Blue Teams używają tego rodzaju definicji do **wyszukiwania tego typu złośliwych plików** w swoich **systemach** i **sieciach**.\
Dzielenie się tymi definicjami jest bardzo przydatne — gdy malware zostanie zidentyfikowane na komputerze i zostanie utworzony IOC dla tego malware, inne Blue Teams mogą go użyć, aby szybciej wykryć to malware.

Narzędzie do tworzenia lub modyfikowania IOCs jest [**IOC Editor**](https://www.fireeye.com/services/freeware/ioc-editor.html)**.**\
Możesz użyć narzędzi takich jak [**Redline**](https://www.fireeye.com/services/freeware/redline.html) do **wyszukiwania zdefiniowanych IOCs na urządzeniu**.

### Loki

[**Loki**](https://github.com/Neo23x0/Loki) to skaner dla Simple Indicators of Compromise.\
Wykrywanie opiera się na czterech metodach detekcji:
```
1. File Name IOC
Regex match on full file path/name

2. Yara Rule Check
Yara signature matches on file data and process memory

3. Hash Check
Compares known malicious hashes (MD5, SHA1, SHA256) with scanned files

4. C2 Back Connect Check
Compares process connection endpoints with C2 IOCs (new since version v.10)
```
### Linux Malware Detect

[**Linux Malware Detect (LMD)**](https://www.rfxn.com/projects/linux-malware-detect/) jest skanerem malware dla Linux wydanym na licencji GNU GPLv2, zaprojektowanym z myślą o zagrożeniach występujących w środowiskach współdzielonego hostingu. Wykorzystuje dane o zagrożeniach z systemów wykrywania włamań na krawędzi sieci do wyodrębniania malware, które jest aktywnie używane w atakach, oraz generuje sygnatury do wykrywania. Dodatkowo dane o zagrożeniach pochodzą także z zgłoszeń użytkowników za pomocą funkcji LMD checkout oraz z zasobów społeczności zajmującej się malware.

### rkhunter

Narzędzia takie jak [**rkhunter**](http://rkhunter.sourceforge.net) mogą być użyte do sprawdzenia systemu plików pod kątem możliwych **rootkits** i malware.
```bash
sudo ./rkhunter --check -r / -l /tmp/rkhunter.log [--report-warnings-only] [--skip-keypress]
```
### FLOSS

[**FLOSS**](https://github.com/mandiant/flare-floss) to narzędzie, które próbuje znaleźć obfuscated strings w plikach executable, używając różnych technik.

### PEpper

[PEpper ](https://github.com/Th3Hurrican3/PEpper) sprawdza podstawowe rzeczy wewnątrz pliku executable (binary data, entropy, URLs and IPs, some yara rules).

### PEstudio

[PEstudio](https://www.winitor.com/download) to narzędzie, które pozwala uzyskać informacje o Windows executables, takich jak imports, exports, headers, ale także sprawdzi virus total i znajdzie potencjalne Att\&ck techniques.

### Detect It Easy(DiE)

[**DiE**](https://github.com/horsicq/Detect-It-Easy/) to narzędzie do wykrywania, czy plik jest **encrypted**, oraz do znajdowania **packers**.

### NeoPI

[**NeoPI** ](https://github.com/CiscoCXSecurity/NeoPI) to skrypt w Pythonie, który wykorzystuje różnorodne **statistical methods** do wykrywania **obfuscated** i **encrypted** content w plikach tekstowych/skryptowych. Celem NeoPI jest pomoc w **detection of hidden web shell code**.

### **php-malware-finder**

[**PHP-malware-finder**](https://github.com/nbs-system/php-malware-finder) robi wszystko, by wykryć **obfuscated**/**dodgy code** oraz pliki używające funkcji **PHP** często stosowanych w **malwares**/webshells.

### Apple Binary Signatures

Podczas sprawdzania jakiegoś **malware sample** zawsze powinieneś **check the signature** binarki, ponieważ **developer** który ją podpisał, może być już **related** z **malware**.
```bash
#Get signer
codesign -vv -d /bin/ls 2>&1 | grep -E "Authority|TeamIdentifier"

#Check if the app’s contents have been modified
codesign --verify --verbose /Applications/Safari.app

#Check if the signature is valid
spctl --assess --verbose /Applications/Safari.app
```
## Techniki wykrywania

### File Stacking

Jeśli wiesz, że jakiś folder zawierający **pliki** serwera WWW był **ostatnio zaktualizowany w określonym dniu**, **sprawdź** **datę**, kiedy wszystkie **pliki** na **serwerze WWW** zostały utworzone i zmodyfikowane, a jeśli któraś data jest **podejrzana**, sprawdź ten plik.

### Baselines

Jeśli pliki w katalogu **nie powinny być zmieniane**, możesz obliczyć **hash** **oryginalnych plików** katalogu i **porównać** je z **aktualnymi**. Wszystko, co zostało zmodyfikowane, będzie **podejrzane**.

### Statistical Analysis

Gdy informacje są zapisywane w logach, możesz **sprawdzić statystyki, np. ile razy każdy plik serwera WWW był dostępny — web shell może być jednym z najczęściej wywoływanych**.

---

### Android natywna telemetryka w aplikacji (no root)

Na Androidzie możesz instrumentować natywny kod wewnątrz procesu docelowej aplikacji, preloadując małą bibliotekę loggera zanim zainicjują się inne biblioteki JNI. To daje wczesną widoczność zachowania natywnego bez systemowych hooków ani root. Popularnym podejściem jest SoTap: wrzuć libsotap.so dla odpowiedniego ABI do APK i wstrzyknięcie wywołania System.loadLibrary("sotap") wcześnie (np. static initializer lub Application.onCreate), a następnie zbieraj logi z wewnętrznych/zewnętrznych ścieżek lub z fallbacku Logcat.

See the Android native reversing page for setup details and log paths:

{{#ref}}
../../mobile-pentesting/android-app-pentesting/reversing-native-libraries.md
{{#endref}}

---

## Deobfuscating Dynamic Control-Flow (JMP/CALL RAX Dispatchers)

Nowoczesne rodziny malware nadużywają obfuskacji Control-Flow Graph (CFG): zamiast bezpośredniego skoku/wywołania obliczają cel w czasie wykonywania i wykonują `jmp rax` lub `call rax`. Mały *dispatcher* (zwykle dziewięć instrukcji) ustawia końcowy cel w zależności od flag CPU `ZF`/`CF`, całkowicie łamiąc odzyskiwanie statycznego CFG.

Technika – prezentowana przez loader SLOW#TEMPEST – może zostać sforsowana trzystopniowym workflowem opartym wyłącznie na IDAPython i Unicorn CPU emulator.

### 1. Zlokalizuj każdy skok/wywołanie pośrednie
```python
import idautils, idc

for ea in idautils.FunctionItems(idc.here()):
mnem = idc.print_insn_mnem(ea)
if mnem in ("jmp", "call") and idc.print_operand(ea, 0) == "rax":
print(f"[+] Dispatcher found @ {ea:X}")
```
### 2. Wyodrębnij dispatcher byte-code
```python
import idc

def get_dispatcher_start(jmp_ea, count=9):
s = jmp_ea
for _ in range(count):
s = idc.prev_head(s, 0)
return s

start = get_dispatcher_start(jmp_ea)
size  = jmp_ea + idc.get_item_size(jmp_ea) - start
code  = idc.get_bytes(start, size)
open(f"{start:X}.bin", "wb").write(code)
```
### 3. Emuluj to dwukrotnie przy użyciu Unicorn
```python
from unicorn import *
from unicorn.x86_const import *
import struct

def run(code, zf=0, cf=0):
BASE = 0x1000
mu = Uc(UC_ARCH_X86, UC_MODE_64)
mu.mem_map(BASE, 0x1000)
mu.mem_write(BASE, code)
mu.reg_write(UC_X86_REG_RFLAGS, (zf << 6) | cf)
mu.reg_write(UC_X86_REG_RAX, 0)
mu.emu_start(BASE, BASE+len(code))
return mu.reg_read(UC_X86_REG_RAX)
```
Uruchom `run(code,0,0)` i `run(code,1,1)`, aby uzyskać docelowe adresy gałęzi *false* i *true*.

### 4. Przywróć bezpośredni jump / call
```python
import struct, ida_bytes

def patch_direct(ea, target, is_call=False):
op   = 0xE8 if is_call else 0xE9           # CALL rel32 or JMP rel32
disp = target - (ea + 5) & 0xFFFFFFFF
ida_bytes.patch_bytes(ea, bytes([op]) + struct.pack('<I', disp))
```
After patching, wymuś ponowną analizę funkcji w IDA, aby pełny CFG i Hex-Rays output zostały przywrócone:
```python
import ida_auto, idaapi
idaapi.reanalyze_function(idc.get_func_attr(ea, idc.FUNCATTR_START))
```
### 5. Oznacz pośrednie wywołania API

Gdy znane jest rzeczywiste miejsce docelowe każdego `call rax`, możesz powiedzieć IDA, czym ono jest, dzięki czemu typy parametrów i nazwy zmiennych zostaną odzyskane automatycznie:
```python
idc.set_callee_name(call_ea, resolved_addr, 0)  # IDA 8.3+
```
### Praktyczne korzyści

* Przywraca rzeczywisty CFG → decompilation zmienia się z *10* linii do tysięcy.
* Umożliwia string-cross-reference & xrefs, co sprawia, że rekonstrukcja zachowania jest prosta.
* Skrypty są wielokrotnego użytku: wstaw je do dowolnego loadera chronionego tym samym trikiem.

---

## References

- [Unit42 – Evolving Tactics of SLOW#TEMPEST: A Deep Dive Into Advanced Malware Techniques](https://unit42.paloaltonetworks.com/slow-tempest-malware-obfuscation/)
- SoTap: Lightweight in-app JNI (.so) behavior logger – [github.com/RezaArbabBot/SoTap](https://github.com/RezaArbabBot/SoTap)

{{#include ../../banners/hacktricks-training.md}}
