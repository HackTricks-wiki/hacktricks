# Ανάλυση Κακόβουλου Λογισμικού

{{#include ../../banners/hacktricks-training.md}}

## Cheatsheets Ψηφιακής Εγκληματολογίας

[https://www.jaiminton.com/cheatsheet/DFIR/#](https://www.jaiminton.com/cheatsheet/DFIR/)

## Διαδικτυακές Υπηρεσίες

- [VirusTotal](https://www.virustotal.com/gui/home/upload)
- [HybridAnalysis](https://www.hybrid-analysis.com)
- [Koodous](https://koodous.com)
- [Intezer](https://analyze.intezer.com)
- [Any.Run](https://any.run/)

## Offline Antivirus και Εργαλεία Ανίχνευσης

### Yara

#### Εγκατάσταση
```bash
sudo apt-get install -y yara
```
#### Προετοιμασία κανόνων

Χρησιμοποιήστε αυτό το script για να κατεβάσετε και να συγχωνεύσετε όλους τους yara malware rules από github: [https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9](https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9)\
Δημιουργήστε τον φάκελο _**rules**_ και εκτελέστε το. Αυτό θα δημιουργήσει ένα αρχείο με όνομα _**malware_rules.yar**_ που περιέχει όλους τους yara rules για malware.
```bash
wget https://gist.githubusercontent.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9/raw/4ec711d37f1b428b63bed1f786b26a0654aa2f31/malware_yara_rules.py
mkdir rules
python malware_yara_rules.py
```
#### Σάρωση
```bash
yara -w malware_rules.yar image  #Scan 1 file
yara -w malware_rules.yar folder #Scan the whole folder
```
#### YaraGen: Ελέγξτε για malware και δημιουργήστε κανόνες

Μπορείτε να χρησιμοποιήσετε το εργαλείο [**YaraGen**](https://github.com/Neo23x0/yarGen) για να δημιουργήσετε yara rules από ένα δυαδικό αρχείο. Δείτε αυτούς τους οδηγούς: [**Part 1**](https://www.nextron-systems.com/2015/02/16/write-simple-sound-yara-rules/), [**Part 2**](https://www.nextron-systems.com/2015/10/17/how-to-write-simple-but-sound-yara-rules-part-2/), [**Part 3**](https://www.nextron-systems.com/2016/04/15/how-to-write-simple-but-sound-yara-rules-part-3/)
```bash
python3 yarGen.py --update
python3.exe yarGen.py --excludegood -m  ../../mals/
```
### ClamAV

#### Εγκατάσταση
```
sudo apt-get install -y clamav
```
#### Σάρωση
```bash
sudo freshclam      #Update rules
clamscan filepath   #Scan 1 file
clamscan folderpath #Scan the whole folder
```
### [Capa](https://github.com/mandiant/capa)

**Capa** εντοπίζει πιθανώς κακόβουλες **capabilities** σε executables: PE, ELF, .NET. Έτσι θα βρει πράγματα όπως Att\&ck tactics, ή ύποπτες **capabilities** όπως:

- check for OutputDebugString error
- run as a service
- create process

Κατέβασέ το από το [**Github repo**](https://github.com/mandiant/capa).

### IOCs

IOC σημαίνει Indicator Of Compromise. Ένα IOC είναι ένα σύνολο **κριτηρίων που προσδιορίζουν** κάποιο πιθανώς ανεπιθύμητο λογισμικό ή επιβεβαιωμένο **malware**. Οι Blue Teams χρησιμοποιούν αυτόν τον τύπο ορισμού για να **αναζητήσουν αυτό το είδος κακόβουλων αρχείων** στα **συστήματα** και τα **δίκτυά** τους.\
Η κοινοποίηση αυτών των ορισμών είναι πολύ χρήσιμη, αφού όταν ένα malware εντοπιστεί σε έναν υπολογιστή και δημιουργηθεί ένα IOC για αυτό, άλλες Blue Teams μπορούν να το χρησιμοποιήσουν για να αναγνωρίσουν το malware πιο γρήγορα.

Ένα εργαλείο για να δημιουργείς ή να τροποποιείς IOCs είναι [**IOC Editor**](https://www.fireeye.com/services/freeware/ioc-editor.html)**.**\
Μπορείς να χρησιμοποιήσεις εργαλεία όπως [**Redline**](https://www.fireeye.com/services/freeware/redline.html) για να **search for defined IOCs in a device**.

### Loki

[**Loki**](https://github.com/Neo23x0/Loki) είναι ένας scanner για Simple Indicators of Compromise.\
Η ανίχνευση βασίζεται σε τέσσερις μεθόδους ανίχνευσης:
```
1. File Name IOC
Regex match on full file path/name

2. Yara Rule Check
Yara signature matches on file data and process memory

3. Hash Check
Compares known malicious hashes (MD5, SHA1, SHA256) with scanned files

4. C2 Back Connect Check
Compares process connection endpoints with C2 IOCs (new since version v.10)
```
### Linux Malware Detect

[**Linux Malware Detect (LMD)**](https://www.rfxn.com/projects/linux-malware-detect/) είναι ένας malware scanner για Linux που κυκλοφορεί υπό την άδεια GNU GPLv2 και έχει σχεδιαστεί για τις απειλές που αντιμετωπίζονται σε κοινόχρηστα περιβάλλοντα φιλοξενίας. Χρησιμοποιεί δεδομένα απειλών από network edge intrusion detection systems για να εξάγει malware που χρησιμοποιείται ενεργά σε επιθέσεις και να δημιουργεί signatures για τον εντοπισμό. Επιπλέον, δεδομένα απειλών προέρχονται επίσης από υποβολές χρηστών μέσω του LMD checkout feature και από πόρους της malware κοινότητας.

### rkhunter

Εργαλεία όπως [**rkhunter**](http://rkhunter.sourceforge.net) μπορούν να χρησιμοποιηθούν για να ελέγξουν το σύστημα αρχείων για πιθανά **rootkits** και malware.
```bash
sudo ./rkhunter --check -r / -l /tmp/rkhunter.log [--report-warnings-only] [--skip-keypress]
```
### FLOSS

[**FLOSS**](https://github.com/mandiant/flare-floss) είναι ένα εργαλείο που θα προσπαθήσει να εντοπίσει obfuscated strings μέσα σε executables χρησιμοποιώντας διάφορες τεχνικές.

### PEpper

[PEpper ](https://github.com/Th3Hurrican3/PEpper) ελέγχει κάποια βασικά πράγματα μέσα στο executable (binary data, entropy, URLs and IPs, κάποια yara rules).

### PEstudio

[PEstudio](https://www.winitor.com/download) είναι ένα εργαλείο που επιτρέπει την άντληση πληροφοριών για Windows executables όπως imports, exports, headers, αλλά επίσης θα ελέγξει virus total και θα εντοπίσει πιθανές Att\&ck τεχνικές.

### Detect It Easy(DiE)

[**DiE**](https://github.com/horsicq/Detect-It-Easy/) είναι ένα εργαλείο για να ανιχνεύσει αν ένα αρχείο είναι **encrypted** και επίσης να βρει **packers**.

### NeoPI

[**NeoPI** ](https://github.com/CiscoCXSecurity/NeoPI) είναι ένα Python script που χρησιμοποιεί μια ποικιλία **statistical methods** για να ανιχνεύσει **obfuscated** και **encrypted** περιεχόμενο μέσα σε text/script αρχεία. Ο σκοπός του NeoPI είναι να βοηθήσει στην **detection of hidden web shell code**.

### **php-malware-finder**

[**PHP-malware-finder**](https://github.com/nbs-system/php-malware-finder) κάνει ό,τι καλύτερο μπορεί για να εντοπίσει **obfuscated**/**dodgy code** καθώς και αρχεία που χρησιμοποιούν **PHP** functions που συχνά χρησιμοποιούνται σε **malwares**/webshells.

### Apple Binary Signatures

Όταν ελέγχετε κάποιο **malware sample** θα πρέπει πάντα να **check the signature** του binary, καθώς ο **developer** που το υπέγραψε μπορεί ήδη να είναι **related** με **malware.**
```bash
#Get signer
codesign -vv -d /bin/ls 2>&1 | grep -E "Authority|TeamIdentifier"

#Check if the app’s contents have been modified
codesign --verify --verbose /Applications/Safari.app

#Check if the signature is valid
spctl --assess --verbose /Applications/Safari.app
```
## Τεχνικές Ανίχνευσης

### File Stacking

Αν ξέρετε ότι κάποιος φάκελος που περιέχει τα **files** ενός web server ενημερώθηκε **τελευταία φορά σε κάποια ημερομηνία**, **ελέγξτε** την **ημερομηνία** δημιουργίας και τροποποίησης όλων των **files** στον **web server** και αν κάποια ημερομηνία είναι **ύποπτη**, ελέγξτε εκείνο το αρχείο.

### Βάσεις Αναφοράς

Αν τα αρχεία ενός φακέλου **δεν έπρεπε να έχουν τροποποιηθεί**, μπορείτε να υπολογίσετε το **hash** των **αρχικών αρχείων** του φακέλου και να τα **συγκρίνετε** με τα **τρέχοντα**. Οτιδήποτε τροποποιημένο θα είναι **ύποπτο**.

### Στατιστική Ανάλυση

Όταν οι πληροφορίες αποθηκεύονται σε logs μπορείτε να **ελέγξετε στατιστικά** όπως πόσες φορές προσπελάστηκε κάθε αρχείο του web server, αφού ένα web shell μπορεί να είναι ένα από τα πιο προσπελασμένα.

---

### Android in-app native telemetry (no root)

Σε Android, μπορείτε να instrument το native code μέσα στη διαδικασία του target app προφορτώνοντας μια μικρή βιβλιοθήκη logger πριν αρχικοποιηθούν άλλες JNI libs. Αυτό δίνει πρώιμη ορατότητα στη native συμπεριφορά χωρίς system-wide hooks ή root. Μια δημοφιλής προσέγγιση είναι το SoTap: βάλτε libsotap.so για το σωστό ABI μέσα στο APK και εισάγετε μια κλήση System.loadLibrary("sotap") νωρίς (π.χ., static initializer ή Application.onCreate), στη συνέχεια συλλέξτε logs από εσωτερικές/εξωτερικές διαδρομές ή fallback σε Logcat.

See the Android native reversing page for setup details and log paths:

{{#ref}}
../../mobile-pentesting/android-app-pentesting/reversing-native-libraries.md
{{#endref}}

---

## Deobfuscating Dynamic Control-Flow (JMP/CALL RAX Dispatchers)

Modern malware families heavily abuse Control-Flow Graph (CFG) obfuscation: instead of a direct jump/call they compute the destination at run-time and execute a `jmp rax` or `call rax`.  A small *dispatcher* (typically nine instructions) sets the final target depending on the CPU `ZF`/`CF` flags, completely breaking static CFG recovery.

The technique – showcased by the SLOW#TEMPEST loader – can be defeated with a three-step workflow that only relies on IDAPython and the Unicorn CPU emulator.

### 1. Εντοπίστε κάθε έμμεσο jump / call
```python
import idautils, idc

for ea in idautils.FunctionItems(idc.here()):
mnem = idc.print_insn_mnem(ea)
if mnem in ("jmp", "call") and idc.print_operand(ea, 0) == "rax":
print(f"[+] Dispatcher found @ {ea:X}")
```
### 2. Εξαγάγετε το dispatcher byte-code
```python
import idc

def get_dispatcher_start(jmp_ea, count=9):
s = jmp_ea
for _ in range(count):
s = idc.prev_head(s, 0)
return s

start = get_dispatcher_start(jmp_ea)
size  = jmp_ea + idc.get_item_size(jmp_ea) - start
code  = idc.get_bytes(start, size)
open(f"{start:X}.bin", "wb").write(code)
```
### 3. Εξομοιώστε το δύο φορές με το Unicorn
```python
from unicorn import *
from unicorn.x86_const import *
import struct

def run(code, zf=0, cf=0):
BASE = 0x1000
mu = Uc(UC_ARCH_X86, UC_MODE_64)
mu.mem_map(BASE, 0x1000)
mu.mem_write(BASE, code)
mu.reg_write(UC_X86_REG_RFLAGS, (zf << 6) | cf)
mu.reg_write(UC_X86_REG_RAX, 0)
mu.emu_start(BASE, BASE+len(code))
return mu.reg_read(UC_X86_REG_RAX)
```
Εκτελέστε `run(code,0,0)` και `run(code,1,1)` για να αποκτήσετε τους στόχους των κλάδων *false* και *true*.

### 4. Επαναφορά με patch ενός άμεσου jump / call
```python
import struct, ida_bytes

def patch_direct(ea, target, is_call=False):
op   = 0xE8 if is_call else 0xE9           # CALL rel32 or JMP rel32
disp = target - (ea + 5) & 0xFFFFFFFF
ida_bytes.patch_bytes(ea, bytes([op]) + struct.pack('<I', disp))
```
Μετά το patching, αναγκάστε το IDA να αναλύσει ξανά τη συνάρτηση ώστε να αποκατασταθούν ο πλήρης CFG και η έξοδος του Hex-Rays:
```python
import ida_auto, idaapi
idaapi.reanalyze_function(idc.get_func_attr(ea, idc.FUNCATTR_START))
```
### 5. Επισήμανση έμμεσων κλήσεων API

Αφού γίνει γνωστός ο πραγματικός προορισμός κάθε `call rax`, μπορείτε να πείτε στην IDA τι είναι, ώστε οι τύποι παραμέτρων & τα ονόματα μεταβλητών να ανακτηθούν αυτόματα:
```python
idc.set_callee_name(call_ea, resolved_addr, 0)  # IDA 8.3+
```
### Πρακτικά οφέλη

* Επαναφέρει το πραγματικό CFG → η decompilation αυξάνεται από *10* γραμμές σε χιλιάδες.
* Ενεργοποιεί string-cross-reference & xrefs, καθιστώντας την ανακατασκευή της συμπεριφοράς πολύ απλή.
* Τα Scripts είναι επαναχρησιμοποιήσιμα: τοποθετήστε τα σε οποιονδήποτε loader που προστατεύεται από το ίδιο κόλπο.

---

## Αναφορές

- [Unit42 – Evolving Tactics of SLOW#TEMPEST: A Deep Dive Into Advanced Malware Techniques](https://unit42.paloaltonetworks.com/slow-tempest-malware-obfuscation/)
- SoTap: Lightweight in-app JNI (.so) behavior logger – [github.com/RezaArbabBot/SoTap](https://github.com/RezaArbabBot/SoTap)

{{#include ../../banners/hacktricks-training.md}}
