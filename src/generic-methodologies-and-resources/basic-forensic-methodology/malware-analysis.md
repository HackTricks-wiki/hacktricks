# Malware Analysis

{{#include ../../banners/hacktricks-training.md}}

## Forensics CheatSheets

[https://www.jaiminton.com/cheatsheet/DFIR/#](https://www.jaiminton.com/cheatsheet/DFIR/)

## Онлайн сервіси

- [VirusTotal](https://www.virustotal.com/gui/home/upload)
- [HybridAnalysis](https://www.hybrid-analysis.com)
- [Koodous](https://koodous.com)
- [Intezer](https://analyze.intezer.com)
- [Any.Run](https://any.run/)

## Офлайн антивірусні та інструменти виявлення

### Yara

#### Встановлення
```bash
sudo apt-get install -y yara
```
#### Підготуйте правила

Використайте цей скрипт, щоб завантажити та об'єднати всі yara malware rules з github: [https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9](https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9)\  
Створіть директорію _**rules**_ і виконайте скрипт. Це створить файл _**malware_rules.yar**_, який міститиме всі yara rules для malware.
```bash
wget https://gist.githubusercontent.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9/raw/4ec711d37f1b428b63bed1f786b26a0654aa2f31/malware_yara_rules.py
mkdir rules
python malware_yara_rules.py
```
#### Сканування
```bash
yara -w malware_rules.yar image  #Scan 1 file
yara -w malware_rules.yar folder #Scan the whole folder
```
#### YaraGen: Перевірка на malware та створення правил

Ви можете використовувати інструмент [**YaraGen**](https://github.com/Neo23x0/yarGen) для генерації yara rules із бінарного файлу. Перегляньте ці підручники: [**Part 1**](https://www.nextron-systems.com/2015/02/16/write-simple-sound-yara-rules/), [**Part 2**](https://www.nextron-systems.com/2015/10/17/how-to-write-simple-but-sound-yara-rules-part-2/), [**Part 3**](https://www.nextron-systems.com/2016/04/15/how-to-write-simple-but-sound-yara-rules-part-3/)
```bash
python3 yarGen.py --update
python3.exe yarGen.py --excludegood -m  ../../mals/
```
### ClamAV

#### Встановлення
```
sudo apt-get install -y clamav
```
#### Сканування
```bash
sudo freshclam      #Update rules
clamscan filepath   #Scan 1 file
clamscan folderpath #Scan the whole folder
```
### [Capa](https://github.com/mandiant/capa)

**Capa** виявляє потенційно шкідливі **можливості** в виконуваних файлах: PE, ELF, .NET. Тому він знайде такі речі, як Att\&ck tactics, або підозрілі можливості, наприклад:

- check for OutputDebugString error
- run as a service
- create process

Отримати його можна в [**Github repo**](https://github.com/mandiant/capa).

### IOCs

IOC означає Indicator Of Compromise. IOC — це набір **умов, що ідентифікують** деяке потенційно небажане програмне забезпечення або підтверджене **malware**. Blue Teams використовують такого роду визначення, щоб **шукати цього роду шкідливі файли** у своїх **системах** та **мережах**.\
Обмін цими визначеннями дуже корисний: якщо malware виявлено на комп'ютері і створено IOC для цього malware, інші Blue Teams можуть використати його, щоб швидше ідентифікувати загрозу.

Інструмент для створення або модифікації IOCs — [**IOC Editor**](https://www.fireeye.com/services/freeware/ioc-editor.html)**.**\
Ви можете використовувати інструменти, такі як [**Redline**](https://www.fireeye.com/services/freeware/redline.html), щоб **шукати визначені IOCs на пристрої**.

### Loki

[**Loki**](https://github.com/Neo23x0/Loki) є сканером для Simple Indicators of Compromise.\
Виявлення базується на чотирьох методах детекції:
```
1. File Name IOC
Regex match on full file path/name

2. Yara Rule Check
Yara signature matches on file data and process memory

3. Hash Check
Compares known malicious hashes (MD5, SHA1, SHA256) with scanned files

4. C2 Back Connect Check
Compares process connection endpoints with C2 IOCs (new since version v.10)
```
### Linux Malware Detect

[**Linux Malware Detect (LMD)**](https://www.rfxn.com/projects/linux-malware-detect/) — це сканер malware для Linux, випущений під ліцензією GNU GPLv2, розроблений з урахуванням загроз, які виникають у середовищах спільного хостингу. Він використовує дані про загрози із систем виявлення вторгнень на периферії мережі для вилучення malware, яке активно використовується в атаках, і генерує сигнатури для виявлення. Крім того, дані про загрози також отримуються з подань користувачів через функцію LMD checkout та ресурсів спільноти malware.

### rkhunter

Інструменти на кшталт [**rkhunter**](http://rkhunter.sourceforge.net) можна використовувати для перевірки файлової системи на наявність можливих rootkits і malware.
```bash
sudo ./rkhunter --check -r / -l /tmp/rkhunter.log [--report-warnings-only] [--skip-keypress]
```
### FLOSS

[**FLOSS**](https://github.com/mandiant/flare-floss) — інструмент, який намагається знайти obfuscated strings всередині виконуваних файлів, використовуючи різні техніки.

### PEpper

[PEpper ](https://github.com/Th3Hurrican3/PEpper) перевіряє базові речі у виконуваному файлі (binary data, entropy, URLs and IPs, some yara rules).

### PEstudio

[PEstudio](https://www.winitor.com/download) — інструмент, який дозволяє отримати інформацію про Windows executables, такі як imports, exports, headers, а також перевіряє virus total і знаходить потенційні Att\&ck techniques.

### Detect It Easy(DiE)

[**DiE**](https://github.com/horsicq/Detect-It-Easy/) — інструмент для визначення, чи файл є **encrypted**, а також для виявлення **packers**.

### NeoPI

[**NeoPI** ](https://github.com/CiscoCXSecurity/NeoPI) — Python script, який використовує різні **statistical methods** для виявлення **obfuscated** та **encrypted** даних у текстових/скриптових файлах. Основна мета NeoPI — допомогти у **detection of hidden web shell code**.

### **php-malware-finder**

[**PHP-malware-finder**](https://github.com/nbs-system/php-malware-finder) робить усе можливе, щоб виявити **obfuscated**/**dodgy code**, а також файли, що використовують **PHP** функції, часто вживані в **malwares**/webshells.

### Apple Binary Signatures

Під час перевірки деякого **malware sample** завжди слід **check the signature** бінарного файлу, оскільки **developer**, який його підписав, може вже бути **related** з **malware.**
```bash
#Get signer
codesign -vv -d /bin/ls 2>&1 | grep -E "Authority|TeamIdentifier"

#Check if the app’s contents have been modified
codesign --verify --verbose /Applications/Safari.app

#Check if the signature is valid
spctl --assess --verbose /Applications/Safari.app
```
## Техніки виявлення

### File Stacking

Якщо відома папка, що містить **files** веб-сервера була **останній раз оновлена в певну дату**, **перевірте** **дату**, коли всі **files** на **web server** були створені та змінені, і якщо якась дата здається **підозрілою**, перевірте цей файл.

### Baselines

Якщо **files** у папці **не мали бути змінені**, ви можете обчислити **hash** від **оригінальних files** папки і **порівняти** їх із **поточними**. Будь-які зміни будуть **підозрілі**.

### Statistical Analysis

Коли інформація зберігається в logs, можна **перевірити статистику**, наприклад, скільки разів кожен файл на **web server** був доступний — web shell може бути одним із найчастіше accessed.

---

### Android in-app native telemetry (no root)

На Android ви можете інструментувати native code всередині процесу цільового додатка, попередньо підвантаживши невелику бібліотеку логера перед ініціалізацією інших JNI libs. Це дає ранню видимість native поведінки без system-wide hooks або root. Популярний підхід — SoTap: помістіть libsotap.so для потрібного ABI в APK і інжектуйте виклик System.loadLibrary("sotap") на ранньому етапі (наприклад, static initializer або Application.onCreate), після чого збирайте логи з internal/external paths або через fallback в Logcat.

See the Android native reversing page for setup details and log paths:

{{#ref}}
../../mobile-pentesting/android-app-pentesting/reversing-native-libraries.md
{{#endref}}

---

## Deobfuscating Dynamic Control-Flow (JMP/CALL RAX Dispatchers)

Сучасні malware families широко зловживають Control-Flow Graph (CFG) obfuscation: замість прямого jump/call вони обчислюють ціль під час виконання і виконують `jmp rax` або `call rax`. Невеликий *dispatcher* (зазвичай дев'ять інструкцій) встановлює кінцеву мішень залежно від CPU `ZF`/`CF` флагів, повністю ламаючи статичне відновлення CFG.

Техніку — продемонстровану в SLOW#TEMPEST loader — можна подолати трикроковим workflow, який покладається лише на IDAPython та Unicorn CPU emulator.

### 1. Locate every indirect jump / call
```python
import idautils, idc

for ea in idautils.FunctionItems(idc.here()):
mnem = idc.print_insn_mnem(ea)
if mnem in ("jmp", "call") and idc.print_operand(ea, 0) == "rax":
print(f"[+] Dispatcher found @ {ea:X}")
```
### 2. Витягніть байткод диспетчера
```python
import idc

def get_dispatcher_start(jmp_ea, count=9):
s = jmp_ea
for _ in range(count):
s = idc.prev_head(s, 0)
return s

start = get_dispatcher_start(jmp_ea)
size  = jmp_ea + idc.get_item_size(jmp_ea) - start
code  = idc.get_bytes(start, size)
open(f"{start:X}.bin", "wb").write(code)
```
### 3. Емулюйте це двічі за допомогою Unicorn
```python
from unicorn import *
from unicorn.x86_const import *
import struct

def run(code, zf=0, cf=0):
BASE = 0x1000
mu = Uc(UC_ARCH_X86, UC_MODE_64)
mu.mem_map(BASE, 0x1000)
mu.mem_write(BASE, code)
mu.reg_write(UC_X86_REG_RFLAGS, (zf << 6) | cf)
mu.reg_write(UC_X86_REG_RAX, 0)
mu.emu_start(BASE, BASE+len(code))
return mu.reg_read(UC_X86_REG_RAX)
```
Запустіть `run(code,0,0)` та `run(code,1,1)`, щоб отримати *false* і *true* цільові адреси гілок.

### 4. Відновлення прямого jump / call
```python
import struct, ida_bytes

def patch_direct(ea, target, is_call=False):
op   = 0xE8 if is_call else 0xE9           # CALL rel32 or JMP rel32
disp = target - (ea + 5) & 0xFFFFFFFF
ida_bytes.patch_bytes(ea, bytes([op]) + struct.pack('<I', disp))
```
Після внесення патчу примусово змусьте IDA повторно проаналізувати функцію, щоб відновити повний CFG і вивід Hex-Rays:
```python
import ida_auto, idaapi
idaapi.reanalyze_function(idc.get_func_attr(ea, idc.FUNCATTR_START))
```
### 5. Позначте непрямі виклики API

Коли відоме реальне призначення кожного `call rax`, можна вказати IDA, що це за функція, і типи параметрів та імена змінних відновляться автоматично:
```python
idc.set_callee_name(call_ea, resolved_addr, 0)  # IDA 8.3+
```
### Практичні переваги

* Відновлює реальний CFG → decompilation переходить з *10* рядків до тисяч.
* Дозволяє string-cross-reference & xrefs, що робить відновлення поведінки тривіальним.
* Скрипти повторно використовуються: просто помістіть їх у будь-який loader, захищений тим самим трюком.

---

## Джерела

- [Unit42 – Evolving Tactics of SLOW#TEMPEST: A Deep Dive Into Advanced Malware Techniques](https://unit42.paloaltonetworks.com/slow-tempest-malware-obfuscation/)
- SoTap: Lightweight in-app JNI (.so) behavior logger – [github.com/RezaArbabBot/SoTap](https://github.com/RezaArbabBot/SoTap)

{{#include ../../banners/hacktricks-training.md}}
