# Malware Analizi

{{#include ../../banners/hacktricks-training.md}}

## Adli Bilişim CheatSheet'leri

[https://www.jaiminton.com/cheatsheet/DFIR/#](https://www.jaiminton.com/cheatsheet/DFIR/)

## Çevrimiçi Servisler

- [VirusTotal](https://www.virustotal.com/gui/home/upload)
- [HybridAnalysis](https://www.hybrid-analysis.com)
- [Koodous](https://koodous.com)
- [Intezer](https://analyze.intezer.com)
- [Any.Run](https://any.run/)

## Çevrimdışı Antivirüs ve Tespit Araçları

### Yara

#### Kurulum
```bash
sudo apt-get install -y yara
```
#### Kuralları hazırla

Bu scripti, github'dan tüm yara malware kurallarını indirmek ve birleştirmek için kullanın: [https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9](https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9)\
_**rules**_ dizinini oluşturun ve scripti çalıştırın. Bu, tüm yara malware kurallarını içeren _**malware_rules.yar**_ adlı bir dosya oluşturacaktır.
```bash
wget https://gist.githubusercontent.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9/raw/4ec711d37f1b428b63bed1f786b26a0654aa2f31/malware_yara_rules.py
mkdir rules
python malware_yara_rules.py
```
#### Tarama
```bash
yara -w malware_rules.yar image  #Scan 1 file
yara -w malware_rules.yar folder #Scan the whole folder
```
#### YaraGen: malware kontrolü ve kural oluşturma

Bir binary'den yara rules oluşturmak için [**YaraGen**](https://github.com/Neo23x0/yarGen) aracını kullanabilirsiniz. Bu öğreticilere göz atın: [**Part 1**](https://www.nextron-systems.com/2015/02/16/write-simple-sound-yara-rules/), [**Part 2**](https://www.nextron-systems.com/2015/10/17/how-to-write-simple-but-sound-yara-rules-part-2/), [**Part 3**](https://www.nextron-systems.com/2016/04/15/how-to-write-simple-but-sound-yara-rules-part-3/)
```bash
python3 yarGen.py --update
python3.exe yarGen.py --excludegood -m  ../../mals/
```
### ClamAV

#### Kurulum
```
sudo apt-get install -y clamav
```
#### Tarama
```bash
sudo freshclam      #Update rules
clamscan filepath   #Scan 1 file
clamscan folderpath #Scan the whole folder
```
### [Capa](https://github.com/mandiant/capa)

**Capa**, yürütülebilir dosyalarda: PE, ELF, .NET, potansiyel olarak kötü amaçlı **capabilities** tespit eder. Böylece Att\&ck tactics gibi şeyleri veya şu tür şüpheli capabilities'leri bulur:

- OutputDebugString hatası için kontrol etme
- servis olarak çalıştırma
- süreç oluşturma

Edinin: [**Github repo**](https://github.com/mandiant/capa).

### IOCs

IOC, Indicator Of Compromise anlamına gelir. Bir IOC, potansiyel olarak istenmeyen yazılımları veya teyit edilmiş **malware**'i tanımlayan bir dizi **koşuldur**. Blue Teams bu tür tanımları **bu tür kötü amaçlı dosyaları aramak** için kendi **sistemlerinde** ve **ağlarında** kullanır.\
Bu tanımları paylaşmak çok faydalıdır; çünkü bir bilgisayarda malware tespit edildiğinde ve o malware için bir IOC oluşturulduğunda, diğer Blue Teams bunu kullanarak malware'i daha hızlı tespit edebilir.

IOC oluşturmak veya değiştirmek için bir araç [**IOC Editor**](https://www.fireeye.com/services/freeware/ioc-editor.html)**.**\
Tanımlı IOC'leri bir cihazda aramak için [**Redline**](https://www.fireeye.com/services/freeware/redline.html) gibi araçları kullanabilirsiniz.

### Loki

[**Loki**](https://github.com/Neo23x0/Loki) Simple Indicators of Compromise için bir tarayıcıdır.\
Tespit dört farklı yönteme dayanır:
```
1. File Name IOC
Regex match on full file path/name

2. Yara Rule Check
Yara signature matches on file data and process memory

3. Hash Check
Compares known malicious hashes (MD5, SHA1, SHA256) with scanned files

4. C2 Back Connect Check
Compares process connection endpoints with C2 IOCs (new since version v.10)
```
### Linux Malware Detect

[**Linux Malware Detect (LMD)**](https://www.rfxn.com/projects/linux-malware-detect/) GNU GPLv2 lisansı altında yayımlanan ve paylaşılan hosting ortamlarında karşılaşılan tehditlere göre tasarlanmış bir Linux malware tarayıcısıdır. Saldırılarda aktif olarak kullanılan malware'leri çıkarmak ve tespit için imzalar üretmek amacıyla ağ kenarı saldırı tespit sistemlerinden gelen tehdit verilerini kullanır. Ayrıca tehdit verileri, LMD checkout özelliğiyle yapılan kullanıcı gönderimleri ve malware topluluk kaynaklarından da elde edilir.

### rkhunter

Tools like [**rkhunter**](http://rkhunter.sourceforge.net) can be used to check the filesystem for possible **rootkits** and malware.
```bash
sudo ./rkhunter --check -r / -l /tmp/rkhunter.log [--report-warnings-only] [--skip-keypress]
```
### FLOSS

[**FLOSS**](https://github.com/mandiant/flare-floss) farklı teknikler kullanarak executables içindeki obfuscated strings'i bulmaya çalışan bir araçtır.

### PEpper

[PEpper ](https://github.com/Th3Hurrican3/PEpper)executable içinde bazı temel şeyleri kontrol eder (binary data, entropy, URLs and IPs, some yara rules).

### PEstudio

[PEstudio](https://www.winitor.com/download) Windows executables hakkında imports, exports, headers gibi bilgiler almayı sağlar; ayrıca virus total'u kontrol eder ve potansiyel Att\&ck tekniklerini bulur.

### Detect It Easy(DiE)

[**DiE**](https://github.com/horsicq/Detect-It-Easy/) bir dosyanın **encrypted** olup olmadığını tespit etmek ve **packers**'ı bulmak için bir araçtır.

### NeoPI

[**NeoPI** ](https://github.com/CiscoCXSecurity/NeoPI)is bir Python scriptidir ve text/script dosyalar içindeki **obfuscated** ve **encrypted** content'i tespit etmek için çeşitli **statistical methods** kullanır. NeoPI'nin amaçlarından biri **detection of hidden web shell code**'a yardımcı olmaktır.

### **php-malware-finder**

[**PHP-malware-finder**](https://github.com/nbs-system/php-malware-finder) **obfuscated**/**dodgy code**'ları ve sıklıkla **malwares**/webshells içinde kullanılan **PHP** fonksiyonlarını kullanan dosyaları tespit etmek için elinden geleni yapar.

### Apple Binary Signatures

Bazı **malware sample**'larını incelerken, binary'nin **check the signature**'ını her zaman kontrol etmelisiniz çünkü imzalayan **developer** zaten **related** with **malware** olabilir.
```bash
#Get signer
codesign -vv -d /bin/ls 2>&1 | grep -E "Authority|TeamIdentifier"

#Check if the app’s contents have been modified
codesign --verify --verbose /Applications/Safari.app

#Check if the signature is valid
spctl --assess --verbose /Applications/Safari.app
```
## Detection Techniques

### File Stacking

Eğer bir klasörün, bir web sunucusunun **files**ını içerdiğini ve **last updated on some date** olduğunu biliyorsanız. Web sunucusundaki tüm **files**ın oluşturulma ve değiştirilme **date**lerini **Check** edin; eğer herhangi bir tarih **suspicious** ise o dosyayı inceleyin.

### Baselines

Eğer bir klasörün **files**ı **shouldn't have been modified** ise, klasörün **original files**ının **hash**ini hesaplayıp bunları **current** olanlarla **compare** edebilirsiniz. Değişmiş olan herhangi bir şey **suspicious** olacaktır.

### Statistical Analysis

Bilgiler loglarda saklandığında, bir web shell en çok erişilenlerden biri olabileceği için her bir web sunucusu dosyasının kaç kez erişildiği gibi istatistikleri **check** edebilirsiniz.

---

### Android in-app native telemetry (no root)

Android'de, hedef uygulama sürecinin içindeki native kodu diğer JNI kütüphaneleri initialize olmadan önce küçük bir logger kütüphanesini preload ederek instrument edebilirsiniz. Bu, sistem çapında hook'lara veya root'a ihtiyaç duymadan native davranışa erken görünürlük sağlar. Popüler bir yaklaşım SoTap'tır: doğru ABI için libsotap.so'yu APK'ye koyun ve erken bir noktada System.loadLibrary("sotap") çağrısı enjekte edin (örn. static initializer veya Application.onCreate), ardından logları internal/external yollarından veya Logcat fallback'ten toplayın.

See the Android native reversing page for setup details and log paths:

{{#ref}}
../../mobile-pentesting/android-app-pentesting/reversing-native-libraries.md
{{#endref}}

---

## Deobfuscating Dynamic Control-Flow (JMP/CALL RAX Dispatchers)

Modern malware families heavily abuse Control-Flow Graph (CFG) obfuscation: instead of a direct jump/call they compute the destination at run-time and execute a `jmp rax` or `call rax`.  A small *dispatcher* (typically nine instructions) sets the final target depending on the CPU `ZF`/`CF` flags, completely breaking static CFG recovery.

The technique – showcased by the SLOW#TEMPEST loader – can be defeated with a three-step workflow that only relies on IDAPython and the Unicorn CPU emulator.

### 1. Locate every indirect jump / call
```python
import idautils, idc

for ea in idautils.FunctionItems(idc.here()):
mnem = idc.print_insn_mnem(ea)
if mnem in ("jmp", "call") and idc.print_operand(ea, 0) == "rax":
print(f"[+] Dispatcher found @ {ea:X}")
```
### 2. dispatcher byte-code'u çıkarın
```python
import idc

def get_dispatcher_start(jmp_ea, count=9):
s = jmp_ea
for _ in range(count):
s = idc.prev_head(s, 0)
return s

start = get_dispatcher_start(jmp_ea)
size  = jmp_ea + idc.get_item_size(jmp_ea) - start
code  = idc.get_bytes(start, size)
open(f"{start:X}.bin", "wb").write(code)
```
### 3. Unicorn ile bunu iki kez emüle et
```python
from unicorn import *
from unicorn.x86_const import *
import struct

def run(code, zf=0, cf=0):
BASE = 0x1000
mu = Uc(UC_ARCH_X86, UC_MODE_64)
mu.mem_map(BASE, 0x1000)
mu.mem_write(BASE, code)
mu.reg_write(UC_X86_REG_RFLAGS, (zf << 6) | cf)
mu.reg_write(UC_X86_REG_RAX, 0)
mu.emu_start(BASE, BASE+len(code))
return mu.reg_read(UC_X86_REG_RAX)
```
`run(code,0,0)` ve `run(code,1,1)` komutlarını çalıştırarak *false* ve *true* branch hedeflerini elde edin.

### 4. Doğrudan jump / call'ı geri patch'layın
```python
import struct, ida_bytes

def patch_direct(ea, target, is_call=False):
op   = 0xE8 if is_call else 0xE9           # CALL rel32 or JMP rel32
disp = target - (ea + 5) & 0xFFFFFFFF
ida_bytes.patch_bytes(ea, bytes([op]) + struct.pack('<I', disp))
```
Patching yaptıktan sonra, IDA'yı fonksiyonu yeniden analiz etmeye zorlayın, böylece tam CFG ve Hex-Rays çıktısı geri yüklenir:
```python
import ida_auto, idaapi
idaapi.reanalyze_function(idc.get_func_attr(ea, idc.FUNCATTR_START))
```
### 5. Dolaylı API çağrılarını etiketleyin

Her `call rax`'in gerçek hedefi belirlendiğinde IDA'ya bunun ne olduğunu söyleyebilirsiniz, böylece parametre tipleri & değişken adları otomatik olarak geri kazanılır:
```python
idc.set_callee_name(call_ea, resolved_addr, 0)  # IDA 8.3+
```
### Pratik faydalar

* Gerçek CFG'yi geri yükler → dekompilasyon *10* satırdan binlerce satıra çıkar.
* string-cross-reference & xrefs'i etkinleştirir, davranışın yeniden yapılandırılmasını kolaylaştırır.
* Scripts yeniden kullanılabilir: aynı yöntemi kullanan herhangi bir loader'a yerleştirilebilir.

---

## Kaynaklar

- [Unit42 – Evolving Tactics of SLOW#TEMPEST: A Deep Dive Into Advanced Malware Techniques](https://unit42.paloaltonetworks.com/slow-tempest-malware-obfuscation/)
- SoTap: Hafif uygulama içi JNI (.so) davranış kaydedicisi – [github.com/RezaArbabBot/SoTap](https://github.com/RezaArbabBot/SoTap)

{{#include ../../banners/hacktricks-training.md}}
