# マルウェア解析

{{#include ../../banners/hacktricks-training.md}}

## フォレンジック チートシート

[https://www.jaiminton.com/cheatsheet/DFIR/#](https://www.jaiminton.com/cheatsheet/DFIR/)

## オンラインサービス

- [VirusTotal](https://www.virustotal.com/gui/home/upload)
- [HybridAnalysis](https://www.hybrid-analysis.com)
- [Koodous](https://koodous.com)
- [Intezer](https://analyze.intezer.com)
- [Any.Run](https://any.run/)

## オフラインのアンチウイルスおよび検出ツール

### Yara

#### インストール
```bash
sudo apt-get install -y yara
```
#### ルールの準備

このスクリプトを使って github からすべての yara malware rules をダウンロードしてマージしてください: [https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9](https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9)\
_**rules**_ ディレクトリを作成し、スクリプトを実行してください。これにより、すべての yara malware rules が含まれる _**malware_rules.yar**_ というファイルが作成されます。
```bash
wget https://gist.githubusercontent.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9/raw/4ec711d37f1b428b63bed1f786b26a0654aa2f31/malware_yara_rules.py
mkdir rules
python malware_yara_rules.py
```
#### Scan
```bash
yara -w malware_rules.yar image  #Scan 1 file
yara -w malware_rules.yar folder #Scan the whole folder
```
#### YaraGen: malwareの検出とルール作成

ツール [**YaraGen**](https://github.com/Neo23x0/yarGen) を使って、バイナリから yara rules を生成できます。以下のチュートリアルを参照してください: [**Part 1**](https://www.nextron-systems.com/2015/02/16/write-simple-sound-yara-rules/), [**Part 2**](https://www.nextron-systems.com/2015/10/17/how-to-write-simple-but-sound-yara-rules-part-2/), [**Part 3**](https://www.nextron-systems.com/2016/04/15/how-to-write-simple-but-sound-yara-rules-part-3/)
```bash
python3 yarGen.py --update
python3.exe yarGen.py --excludegood -m  ../../mals/
```
### ClamAV

#### インストール
```
sudo apt-get install -y clamav
```
#### Scan
```bash
sudo freshclam      #Update rules
clamscan filepath   #Scan 1 file
clamscan folderpath #Scan the whole folder
```
### [Capa](https://github.com/mandiant/capa)

**Capa** は実行ファイル（PE、ELF、.NET）内の潜在的に悪意のある **capabilities** を検出します。したがって、Att\&ck tactics のようなものや、次のような疑わしい **capabilities** を見つけます:

- OutputDebugString のエラーをチェックする
- サービスとして実行する
- プロセスを作成する

入手先は [**Github repo**](https://github.com/mandiant/capa)。

### IOCs

IOC は Indicator Of Compromise（侵害の指標）を意味します。IOC は、潜在的に望ましくないソフトウェアや確認された **malware** を特定するための **conditions that identify** の集合です。Blue Teams はこの種の定義を使って、自分たちの **systems** や **networks** 内でこの種の悪意あるファイルを **search for this kind of malicious files** します。\
これらの定義を共有することは非常に有益です。コンピュータで malware が特定され、その malware 用の IOC が作成されると、他の Blue Teams はそれを使って malware をより速く特定できます。

IOC を作成または修正するためのツールとして [**IOC Editor**](https://www.fireeye.com/services/freeware/ioc-editor.html)**.**\
[**Redline**](https://www.fireeye.com/services/freeware/redline.html) のようなツールを使用して、デバイス上で **search for defined IOCs in a device** を行うことができます。

### Loki

[**Loki**](https://github.com/Neo23x0/Loki) は Simple Indicators of Compromise のスキャナーです。\
検出は4つの検出方法に基づいています:
```
1. File Name IOC
Regex match on full file path/name

2. Yara Rule Check
Yara signature matches on file data and process memory

3. Hash Check
Compares known malicious hashes (MD5, SHA1, SHA256) with scanned files

4. C2 Back Connect Check
Compares process connection endpoints with C2 IOCs (new since version v.10)
```
### Linux Malware Detect

[**Linux Malware Detect (LMD)**](https://www.rfxn.com/projects/linux-malware-detect/) は GNU GPLv2 ライセンスで配布される Linux 向けの malware scanner で、共有ホスティング環境で直面する脅威を念頭に設計されています。network edge intrusion detection systems からの脅威データを使用して、攻撃で実際に使用されている malware を抽出し、検出用の signatures を生成します。さらに、脅威データは LMD の checkout feature を使った user submissions や malware community resources からも得られます。

### rkhunter

Tools like [**rkhunter**](http://rkhunter.sourceforge.net) can be used to check the filesystem for possible **rootkits** and malware.
```bash
sudo ./rkhunter --check -r / -l /tmp/rkhunter.log [--report-warnings-only] [--skip-keypress]
```
### FLOSS

[**FLOSS**](https://github.com/mandiant/flare-floss) は、様々な手法を用いて executables 内の obfuscated strings を検出しようとするツールです。

### PEpper

[PEpper ](https://github.com/Th3Hurrican3/PEpper) は executable 内の基本的な情報（binary data、entropy、URLs and IPs、some yara rules）をチェックします。

### PEstudio

[PEstudio](https://www.winitor.com/download) は、Windows executables の imports、exports、headers といった情報を取得できるツールで、virus total のチェックや潜在的な Att\&ck techniques の検出も行います。

### Detect It Easy(DiE)

[**DiE**](https://github.com/horsicq/Detect-It-Easy/) は、ファイルが **encrypted** かどうかを検出し、**packers** を見つけるツールです。

### NeoPI

[**NeoPI** ](https://github.com/CiscoCXSecurity/NeoPI) は、様々な **statistical methods** を用いて text/script files 内の **obfuscated** や **encrypted** コンテンツを検出する Python スクリプトです。NeoPI の目的は、**detection of hidden web shell code** を支援することです。

### **php-malware-finder**

[**PHP-malware-finder**](https://github.com/nbs-system/php-malware-finder) は、**obfuscated**/**dodgy code** の検出や、**PHP** 関数を使った **malwares**/webshells によく使われるファイルの検出に最善を尽くします。

### Apple Binary Signatures

いくつかの **malware sample** を調査する際は、署名されたバイナリの **signature** を常に確認してください。署名した **developer** が既に **malware** と関連している可能性があるためです。
```bash
#Get signer
codesign -vv -d /bin/ls 2>&1 | grep -E "Authority|TeamIdentifier"

#Check if the app’s contents have been modified
codesign --verify --verbose /Applications/Safari.app

#Check if the signature is valid
spctl --assess --verbose /Applications/Safari.app
```
## Detection Techniques

### File Stacking

もしあるフォルダに含まれる **files** が **last updated on some date** と分かっている場合は、web server の全ての **files** が作成・変更された **date** を確認し、いずれかの **date** が **suspicious** ならそのファイルを調べてください。

### Baselines

フォルダ内の files が **shouldn't have been modified** はずであれば、そのフォルダの **original files** の **hash** を計算して **current** なものと **compare** できます。変更されたものは **suspicious** です。

### Statistical Analysis

情報が logs に保存されている場合、web server の各ファイルが何回アクセスされたかのような統計を **check** できます。web shell が最も多くアクセスされたものの一つかもしれません。

---

### Android in-app native telemetry (no root)

On Android, you can instrument native code inside the target app process by preloading a tiny logger library before other JNI libs initialize. This gives early visibility into native behavior without system-wide hooks or root. A popular approach is SoTap: drop libsotap.so for the right ABI into the APK and inject a System.loadLibrary("sotap") call early (e.g., static initializer or Application.onCreate), then collect logs from internal/external paths or Logcat fallback.

See the Android native reversing page for setup details and log paths:

{{#ref}}
../../../mobile-pentesting/android-app-pentesting/reversing-native-libraries.md
{{#endref}}

---

## Deobfuscating Dynamic Control-Flow (JMP/CALL RAX Dispatchers)

Modern malware families heavily abuse Control-Flow Graph (CFG) obfuscation: instead of a direct jump/call they compute the destination at run-time and execute a `jmp rax` or `call rax`.  A small *dispatcher* (typically nine instructions) sets the final target depending on the CPU `ZF`/`CF` flags, completely breaking static CFG recovery.

The technique – showcased by the SLOW#TEMPEST loader – can be defeated with a three-step workflow that only relies on IDAPython and the Unicorn CPU emulator.

### 1. Locate every indirect jump / call
```python
import idautils, idc

for ea in idautils.FunctionItems(idc.here()):
mnem = idc.print_insn_mnem(ea)
if mnem in ("jmp", "call") and idc.print_operand(ea, 0) == "rax":
print(f"[+] Dispatcher found @ {ea:X}")
```
### 2. ディスパッチャーのバイトコードを抽出する
```python
import idc

def get_dispatcher_start(jmp_ea, count=9):
s = jmp_ea
for _ in range(count):
s = idc.prev_head(s, 0)
return s

start = get_dispatcher_start(jmp_ea)
size  = jmp_ea + idc.get_item_size(jmp_ea) - start
code  = idc.get_bytes(start, size)
open(f"{start:X}.bin", "wb").write(code)
```
### 3. Unicornで2回エミュレートする
```python
from unicorn import *
from unicorn.x86_const import *
import struct

def run(code, zf=0, cf=0):
BASE = 0x1000
mu = Uc(UC_ARCH_X86, UC_MODE_64)
mu.mem_map(BASE, 0x1000)
mu.mem_write(BASE, code)
mu.reg_write(UC_X86_REG_RFLAGS, (zf << 6) | cf)
mu.reg_write(UC_X86_REG_RAX, 0)
mu.emu_start(BASE, BASE+len(code))
return mu.reg_read(UC_X86_REG_RAX)
```
Run `run(code,0,0)` と `run(code,1,1)` を実行して、*false* および *true* のブランチターゲットを取得する。

### 4. パッチで直接 jump / call を元に戻す
```python
import struct, ida_bytes

def patch_direct(ea, target, is_call=False):
op   = 0xE8 if is_call else 0xE9           # CALL rel32 or JMP rel32
disp = target - (ea + 5) & 0xFFFFFFFF
ida_bytes.patch_bytes(ea, bytes([op]) + struct.pack('<I', disp))
```
パッチ適用後、IDA に関数の再解析を強制して、完全な CFG と Hex-Rays の出力が復元されるように:
```python
import ida_auto, idaapi
idaapi.reanalyze_function(idc.get_func_attr(ea, idc.FUNCATTR_START))
```
### 5. 間接APIコールにラベルを付ける

各 `call rax` の実際の宛先が判明したら、IDAにそれが何かを教えることで、パラメータ型や変数名が自動的に復元されます:
```python
idc.set_callee_name(call_ea, resolved_addr, 0)  # IDA 8.3+
```
### 実用的な利点

* 実際の CFG を復元 → decompilation が *10* 行から数千行に増える。
* string-cross-reference & xrefs を有効にし、behaviour reconstruction を容易にする。
* Scripts は再利用可能: 同じトリックで保護された任意の loader にドロップできる。

---

## 参考文献

- [Unit42 – Evolving Tactics of SLOW#TEMPEST: A Deep Dive Into Advanced Malware Techniques](https://unit42.paloaltonetworks.com/slow-tempest-malware-obfuscation/)
- SoTap: Lightweight in-app JNI (.so) behavior logger – [github.com/RezaArbabBot/SoTap](https://github.com/RezaArbabBot/SoTap)

{{#include ../../banners/hacktricks-training.md}}
