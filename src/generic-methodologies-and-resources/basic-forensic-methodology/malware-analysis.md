# Аналіз шкідливого ПЗ

{{#include ../../banners/hacktricks-training.md}}

## Шпаргалки з форензики

[https://www.jaiminton.com/cheatsheet/DFIR/#](https://www.jaiminton.com/cheatsheet/DFIR/)

## Онлайн-сервіси

- [VirusTotal](https://www.virustotal.com/gui/home/upload)
- [HybridAnalysis](https://www.hybrid-analysis.com)
- [Koodous](https://koodous.com)
- [Intezer](https://analyze.intezer.com)
- [Any.Run](https://any.run/)

## Офлайн антивірусні та інструменти виявлення

### Yara

#### Встановлення
```bash
sudo apt-get install -y yara
```
#### Підготуйте правила

Використайте цей скрипт, щоб завантажити та об'єднати всі yara malware rules з github: [https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9](https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9)\
Створіть директорію _**rules**_ і запустіть скрипт. Це створить файл під назвою _**malware_rules.yar**_, який містить усі yara rules для malware.
```bash
wget https://gist.githubusercontent.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9/raw/4ec711d37f1b428b63bed1f786b26a0654aa2f31/malware_yara_rules.py
mkdir rules
python malware_yara_rules.py
```
#### Сканування
```bash
yara -w malware_rules.yar image  #Scan 1 file
yara -w malware_rules.yar folder #Scan the whole folder
```
#### YaraGen: Перевірка на malware та створення правил

Ви можете використати інструмент [**YaraGen**](https://github.com/Neo23x0/yarGen) для генерації yara rules з бінарного файлу. Перегляньте ці підручники: [**Part 1**](https://www.nextron-systems.com/2015/02/16/write-simple-sound-yara-rules/), [**Part 2**](https://www.nextron-systems.com/2015/10/17/how-to-write-simple-but-sound-yara-rules-part-2/), [**Part 3**](https://www.nextron-systems.com/2016/04/15/how-to-write-simple-but-sound-yara-rules-part-3/)
```bash
python3 yarGen.py --update
python3.exe yarGen.py --excludegood -m  ../../mals/
```
### ClamAV

#### Встановлення
```
sudo apt-get install -y clamav
```
#### Сканування
```bash
sudo freshclam      #Update rules
clamscan filepath   #Scan 1 file
clamscan folderpath #Scan the whole folder
```
### [Capa](https://github.com/mandiant/capa)

**Capa** виявляє потенційно шкідливі **capabilities** у виконуваних файлах: PE, ELF, .NET. Тому воно знаходить такі речі, як Att\&ck tactics, або підозрілі можливості, наприклад:

- check for OutputDebugString error
- run as a service
- create process

Отримати його можна в [**Github repo**](https://github.com/mandiant/capa).

### IOCs

IOC означає Indicator Of Compromise. IOC — це набір **conditions that identify** деякого потенційно небажаного програмного забезпечення або підтвердженого **malware**. Blue Teams використовують такі визначення, щоб **пошукати подібні шкідливі файли** у своїх **systems** і **networks**.\
Обмін цими визначеннями дуже корисний: коли malware виявлено на комп'ютері і для нього створено IOC, інші Blue Teams можуть використати його, щоб швидше ідентифікувати malware.

Інструмент для створення або редагування IOCs — [**IOC Editor**](https://www.fireeye.com/services/freeware/ioc-editor.html)**.**\
Ви можете використовувати інструменти, такі як [**Redline**](https://www.fireeye.com/services/freeware/redline.html), щоб **search for defined IOCs in a device**.

### Loki

[**Loki**](https://github.com/Neo23x0/Loki) — сканер для Simple Indicators of Compromise.\
Виявлення базується на чотирьох методах виявлення:
```
1. File Name IOC
Regex match on full file path/name

2. Yara Rule Check
Yara signature matches on file data and process memory

3. Hash Check
Compares known malicious hashes (MD5, SHA1, SHA256) with scanned files

4. C2 Back Connect Check
Compares process connection endpoints with C2 IOCs (new since version v.10)
```
### Linux Malware Detect

[**Linux Malware Detect (LMD)**](https://www.rfxn.com/projects/linux-malware-detect/) — це сканер malware для Linux, випущений під ліцензією GNU GPLv2, який розроблений з урахуванням загроз, характерних для shared hosted environments. Він використовує дані про загрози з network edge intrusion detection systems для виявлення malware, що активно використовується в атаках, та генерує сигнатури для їхнього виявлення. Крім того, дані про загрози також надходять від користувацьких надсилань через LMD checkout feature та ресурсів спільноти malware.

### rkhunter

Інструменти на кшталт [**rkhunter**](http://rkhunter.sourceforge.net) можна використовувати для перевірки файлової системи на наявність можливих **rootkits** і malware.
```bash
sudo ./rkhunter --check -r / -l /tmp/rkhunter.log [--report-warnings-only] [--skip-keypress]
```
### FLOSS

[**FLOSS**](https://github.com/mandiant/flare-floss) — інструмент, який намагається знайти **obfuscated strings** всередині **executables**, використовуючи різні методи.

### PEpper

[PEpper ](https://github.com/Th3Hurrican3/PEpper) перевіряє деякі базові речі всередині **executable** (binary data, entropy, URLs and IPs, some yara rules).

### PEstudio

[PEstudio](https://www.winitor.com/download) — інструмент, який дозволяє отримати інформацію про **Windows executables**, такі як imports, exports, headers, а також перевіряє **virus total** і виявляє потенційні **Att\&ck techniques**.

### Detect It Easy(DiE)

[**DiE**](https://github.com/horsicq/Detect-It-Easy/) — інструмент для визначення, чи файл є **encrypted**, а також для пошуку **packers**.

### NeoPI

[**NeoPI** ](https://github.com/CiscoCXSecurity/NeoPI) — Python script, який використовує різні **statistical methods** для виявлення **obfuscated** та **encrypted** вмісту в текстових/скриптових файлах. Основна мета NeoPI — допомагати у **detection of hidden web shell code**.

### **php-malware-finder**

[**PHP-malware-finder**](https://github.com/nbs-system/php-malware-finder) робить усе можливе, щоб виявити **obfuscated**/**dodgy code**, а також файли, що використовують **PHP** functions, часто використовувані в **malwares**/webshells.

### Apple Binary Signatures

При перевірці зразка **malware sample** завжди слід **check the signature** бінарного файлу, оскільки **developer**, який його підписав, може бути вже **related** з **malware.**
```bash
#Get signer
codesign -vv -d /bin/ls 2>&1 | grep -E "Authority|TeamIdentifier"

#Check if the app’s contents have been modified
codesign --verify --verbose /Applications/Safari.app

#Check if the signature is valid
spctl --assess --verbose /Applications/Safari.app
```
## Detection Techniques

### File Stacking

If you know that some folder containing the **файли** of a web server was **last updated on some date**. **Check** the **date** all the **файли** in the **web server were created and modified** and if any date is **suspicious**, check that file.

### Baselines

If the files of a folder **shouldn't have been modified**, you can calculate the **hash** of the **original files** of the folder and **compare** them with the **current** ones. Anything modified will be **suspicious**.

### Statistical Analysis

When the information is saved in logs you can **check statistics like how many times each file of a web server was accessed as a web shell might be one of the most**.

---

### Android in-app native telemetry (no root)

On Android, you can instrument native code inside the target app process by preloading a tiny logger library before other JNI libs initialize. This gives early visibility into native behavior without system-wide hooks or root. A popular approach is SoTap: drop libsotap.so for the right ABI into the APK and inject a System.loadLibrary("sotap") call early (e.g., static initializer or Application.onCreate), then collect logs from internal/external paths or Logcat fallback.

See the Android native reversing page for setup details and log paths:

{{#ref}}
../../mobile-pentesting/android-app-pentesting/reversing-native-libraries.md
{{#endref}}

---

## Deobfuscating Dynamic Control-Flow (JMP/CALL RAX Dispatchers)

Modern malware families heavily abuse Control-Flow Graph (CFG) obfuscation: instead of a direct jump/call they compute the destination at run-time and execute a `jmp rax` or `call rax`.  A small *dispatcher* (typically nine instructions) sets the final target depending on the CPU `ZF`/`CF` flags, completely breaking static CFG recovery.

The technique – showcased by the SLOW#TEMPEST loader – can be defeated with a three-step workflow that only relies on IDAPython and the Unicorn CPU emulator.

### 1. Знайдіть кожний indirect jump / call
```python
import idautils, idc

for ea in idautils.FunctionItems(idc.here()):
mnem = idc.print_insn_mnem(ea)
if mnem in ("jmp", "call") and idc.print_operand(ea, 0) == "rax":
print(f"[+] Dispatcher found @ {ea:X}")
```
### 2. Витягти байт-код диспетчера
```python
import idc

def get_dispatcher_start(jmp_ea, count=9):
s = jmp_ea
for _ in range(count):
s = idc.prev_head(s, 0)
return s

start = get_dispatcher_start(jmp_ea)
size  = jmp_ea + idc.get_item_size(jmp_ea) - start
code  = idc.get_bytes(start, size)
open(f"{start:X}.bin", "wb").write(code)
```
### 3. Емулюйте це двічі за допомогою Unicorn
```python
from unicorn import *
from unicorn.x86_const import *
import struct

def run(code, zf=0, cf=0):
BASE = 0x1000
mu = Uc(UC_ARCH_X86, UC_MODE_64)
mu.mem_map(BASE, 0x1000)
mu.mem_write(BASE, code)
mu.reg_write(UC_X86_REG_RFLAGS, (zf << 6) | cf)
mu.reg_write(UC_X86_REG_RAX, 0)
mu.emu_start(BASE, BASE+len(code))
return mu.reg_read(UC_X86_REG_RAX)
```
Запустіть `run(code,0,0)` і `run(code,1,1)`, щоб отримати цілі гілок для *false* та *true*.

### 4. Patch back a direct jump / call
```python
import struct, ida_bytes

def patch_direct(ea, target, is_call=False):
op   = 0xE8 if is_call else 0xE9           # CALL rel32 or JMP rel32
disp = target - (ea + 5) & 0xFFFFFFFF
ida_bytes.patch_bytes(ea, bytes([op]) + struct.pack('<I', disp))
```
Після застосування патчу, змусьте IDA повторно проаналізувати функцію, щоб відновити повний CFG і вивід Hex-Rays:
```python
import ida_auto, idaapi
idaapi.reanalyze_function(idc.get_func_attr(ea, idc.FUNCATTR_START))
```
### 5. Позначте непрямі виклики API

Як тільки справжнє призначення кожного `call rax` буде відоме, ви можете повідомити IDA, що це за виклик, щоб типи параметрів та імена змінних були відновлені автоматично:
```python
idc.set_callee_name(call_ea, resolved_addr, 0)  # IDA 8.3+
```
### Практичні переваги

* Відновлює реальний CFG → декомпіляція переходить з *10* рядків до тисяч.
* Дозволяє string-cross-reference & xrefs, що робить реконструкцію поведінки тривіальною.
* Scripts повторно використовувані: помістіть їх у будь-який loader, захищений тим самим трюком.

---

## Посилання

- [Unit42 – Evolving Tactics of SLOW#TEMPEST: A Deep Dive Into Advanced Malware Techniques](https://unit42.paloaltonetworks.com/slow-tempest-malware-obfuscation/)
- SoTap: Легкий in-app JNI (.so) логер поведінки – [github.com/RezaArbabBot/SoTap](https://github.com/RezaArbabBot/SoTap)

{{#include ../../banners/hacktricks-training.md}}
