# Ανάλυση Malware

{{#include ../../banners/hacktricks-training.md}}

## CheatSheets Ψηφιακής Εγκληματολογίας

[https://www.jaiminton.com/cheatsheet/DFIR/#](https://www.jaiminton.com/cheatsheet/DFIR/)

## Διαδικτυακές Υπηρεσίες

- [VirusTotal](https://www.virustotal.com/gui/home/upload)
- [HybridAnalysis](https://www.hybrid-analysis.com)
- [Koodous](https://koodous.com)
- [Intezer](https://analyze.intezer.com)
- [Any.Run](https://any.run/)

## Εργαλεία Antivirus και Ανίχνευσης (Offline)

### Yara

#### Εγκατάσταση
```bash
sudo apt-get install -y yara
```
#### Προετοιμασία κανόνων

Χρησιμοποιήστε αυτό το script για να κατεβάσετε και να συγχωνεύσετε όλους τους yara malware κανόνες από github: [https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9](https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9)\
Δημιουργήστε τον φάκελο _**rules**_ και εκτελέστε το. Αυτό θα δημιουργήσει ένα αρχείο με όνομα _**malware_rules.yar**_ που περιέχει όλους τους yara κανόνες για malware.
```bash
wget https://gist.githubusercontent.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9/raw/4ec711d37f1b428b63bed1f786b26a0654aa2f31/malware_yara_rules.py
mkdir rules
python malware_yara_rules.py
```
#### Σάρωση
```bash
yara -w malware_rules.yar image  #Scan 1 file
yara -w malware_rules.yar folder #Scan the whole folder
```
#### YaraGen: Έλεγχος για malware και δημιουργία κανόνων

Μπορείτε να χρησιμοποιήσετε το εργαλείο [**YaraGen**](https://github.com/Neo23x0/yarGen) για να δημιουργήσετε yara rules από ένα binary. Δείτε αυτούς τους οδηγούς: [**Part 1**](https://www.nextron-systems.com/2015/02/16/write-simple-sound-yara-rules/), [**Part 2**](https://www.nextron-systems.com/2015/10/17/how-to-write-simple-but-sound-yara-rules-part-2/), [**Part 3**](https://www.nextron-systems.com/2016/04/15/how-to-write-simple-but-sound-yara-rules-part-3/)
```bash
python3 yarGen.py --update
python3.exe yarGen.py --excludegood -m  ../../mals/
```
### ClamAV

#### Εγκατάσταση
```
sudo apt-get install -y clamav
```
#### Σάρωση
```bash
sudo freshclam      #Update rules
clamscan filepath   #Scan 1 file
clamscan folderpath #Scan the whole folder
```
### [Capa](https://github.com/mandiant/capa)

**Capa** ανιχνεύει ενδεχομένως κακόβουλες **capabilities** σε εκτελέσιμα: PE, ELF, .NET. Έτσι θα βρει πράγματα όπως Att\&ck tactics, ή ύποπτες capabilities όπως:

- check for OutputDebugString error
- run as a service
- create process

Πάρε το από το [**Github repo**](https://github.com/mandiant/capa).

### IOCs

IOC σημαίνει Indicator Of Compromise. Ένας IOC είναι ένα σύνολο **συνθηκών που αναγνωρίζουν** κάποιο ενδεχομένως ανεπιθύμητο λογισμικό ή επιβεβαιωμένο **malware**. Οι Blue Teams χρησιμοποιούν αυτόν τον τύπο ορισμού για να **αναζητήσουν αυτό το είδος κακόβουλων αρχείων** στα **systems** και **networks** τους.\
Η κοινή χρήση αυτών των ορισμών είναι πολύ χρήσιμη, καθώς όταν εντοπιστεί malware σε έναν υπολογιστή και δημιουργηθεί ένας IOC για αυτό, άλλοι Blue Teams μπορούν να τον χρησιμοποιήσουν για να εντοπίσουν το malware πιο γρήγορα.

Ένα εργαλείο για να δημιουργήσετε ή να τροποποιήσετε IOCs είναι το [**IOC Editor**](https://www.fireeye.com/services/freeware/ioc-editor.html)**.**\
Μπορείτε να χρησιμοποιήσετε εργαλεία όπως το [**Redline**](https://www.fireeye.com/services/freeware/redline.html) για να **αναζητήσετε ορισμένους IOCs σε μια συσκευή**.

### Loki

[**Loki**](https://github.com/Neo23x0/Loki) είναι ένας scanner για Simple Indicators of Compromise.\
Η ανίχνευση βασίζεται σε τέσσερις μεθόδους ανίχνευσης:
```
1. File Name IOC
Regex match on full file path/name

2. Yara Rule Check
Yara signature matches on file data and process memory

3. Hash Check
Compares known malicious hashes (MD5, SHA1, SHA256) with scanned files

4. C2 Back Connect Check
Compares process connection endpoints with C2 IOCs (new since version v.10)
```
### Linux Malware Detect

[**Linux Malware Detect (LMD)**](https://www.rfxn.com/projects/linux-malware-detect/) είναι ένας σαρωτής malware για Linux που κυκλοφορεί υπό την άδεια GNU GPLv2 και έχει σχεδιαστεί για τις απειλές που αντιμετωπίζονται σε κοινόχρηστα φιλοξενούμενα περιβάλλοντα. Χρησιμοποιεί δεδομένα απειλών από network edge intrusion detection systems για να εξάγει malware που χρησιμοποιείται ενεργά σε επιθέσεις και να δημιουργεί υπογραφές για εντοπισμό. Επιπλέον, δεδομένα απειλών προέρχονται επίσης από υποβολές χρηστών μέσω του LMD checkout feature και από malware community resources.

### rkhunter

Εργαλεία όπως [**rkhunter**](http://rkhunter.sourceforge.net) μπορούν να χρησιμοποιηθούν για να ελέγξουν το σύστημα αρχείων για πιθανά **rootkits** και malware.
```bash
sudo ./rkhunter --check -r / -l /tmp/rkhunter.log [--report-warnings-only] [--skip-keypress]
```
### FLOSS

[**FLOSS**](https://github.com/mandiant/flare-floss) είναι ένα εργαλείο που θα προσπαθήσει να βρει obfuscated strings μέσα σε executables χρησιμοποιώντας διάφορες τεχνικές.

### PEpper

[PEpper ](https://github.com/Th3Hurrican3/PEpper)ελέγχει κάποια βασικά στοιχεία μέσα στο executable (binary data, entropy, URLs and IPs, μερικούς yara rules).

### PEstudio

[PEstudio](https://www.winitor.com/download) είναι ένα εργαλείο που επιτρέπει να λάβετε πληροφορίες για Windows executables όπως imports, exports, headers, αλλά επίσης θα ελέγξει το virus total και θα βρει πιθανές Att\&ck τεχνικές.

### Detect It Easy(DiE)

[**DiE**](https://github.com/horsicq/Detect-It-Easy/) είναι ένα εργαλείο για να εντοπίσει αν ένα αρχείο είναι **encrypted** και επίσης να βρει **packers**.

### NeoPI

[**NeoPI** ](https://github.com/CiscoCXSecurity/NeoPI)είναι ένα Python script που χρησιμοποιεί μια σειρά από **statistical methods** για να εντοπίσει **obfuscated** και **encrypted** περιεχόμενο μέσα σε αρχεία κειμένου/script. Ο σκοπός του NeoPI είναι να βοηθήσει στην **detection of hidden web shell code**.

### **php-malware-finder**

[**PHP-malware-finder**](https://github.com/nbs-system/php-malware-finder) κάνει το καλύτερο δυνατό για να εντοπίσει **obfuscated**/**dodgy code** καθώς και αρχεία που χρησιμοποιούν **PHP** functions που συχνά χρησιμοποιούνται σε **malwares**/webshells.

### Apple Binary Signatures

Όταν ελέγχετε κάποιο **malware sample**, θα πρέπει πάντα να **check the signature** του binary, καθώς ο **developer** που το υπέγραψε μπορεί να είναι ήδη **related** με **malware.**
```bash
#Get signer
codesign -vv -d /bin/ls 2>&1 | grep -E "Authority|TeamIdentifier"

#Check if the app’s contents have been modified
codesign --verify --verbose /Applications/Safari.app

#Check if the signature is valid
spctl --assess --verbose /Applications/Safari.app
```
## Τεχνικές Ανίχνευσης

### Στοίβα Αρχείων

Αν γνωρίζετε ότι κάποιος φάκελος που περιέχει τα **αρχεία** ενός web server ενημερώθηκε **τελευταία σε κάποια ημερομηνία**, **ελέγξτε** την **ημερομηνία δημιουργίας και τροποποίησης** όλων των **αρχείων** στον **web server** και αν κάποια ημερομηνία είναι **ύποπτη**, ελέγξτε εκείνο το αρχείο.

### Βασικές Γραμμές

Αν τα αρχεία ενός φακέλου **δεν θα έπρεπε να έχουν τροποποιηθεί**, μπορείτε να υπολογίσετε το **hash** των **αρχικών αρχείων** του φακέλου και να τα **συγκρίνετε** με τα **τρέχοντα**. Οτιδήποτε τροποποιημένο θα είναι **ύποπτο**.

### Στατιστική Ανάλυση

Όταν οι πληροφορίες αποθηκεύονται σε logs μπορείτε να **ελέγξετε στατιστικά όπως πόσες φορές κάθε αρχείο ενός web server προσπελάστηκε καθώς ένα web shell μπορεί να είναι ένα από τα πιο**.

---

### Android in-app native telemetry (no root)

On Android, you can instrument native code inside the target app process by preloading a tiny logger library before other JNI libs initialize. This gives early visibility into native behavior without system-wide hooks or root. A popular approach is SoTap: drop libsotap.so for the right ABI into the APK and inject a System.loadLibrary("sotap") call early (e.g., static initializer or Application.onCreate), then collect logs from internal/external paths or Logcat fallback.

See the Android native reversing page for setup details and log paths:

{{#ref}}
../../mobile-pentesting/android-app-pentesting/reversing-native-libraries.md
{{#endref}}

---

## Αποκρυπτογράφηση της δυναμικής ροής ελέγχου (JMP/CALL RAX Dispatchers)

Σύγχρονες οικογένειες malware καταχρώνται έντονα τη θόλωση του Control-Flow Graph (CFG): αντί για έναν άμεσο jump/call, υπολογίζουν τον προορισμό κατά το runtime και εκτελούν `jmp rax` ή `call rax`. Ένας μικρός *dispatcher* (συνήθως εννέα εντολές) ορίζει τον τελικό στόχο ανάλογα με τα CPU `ZF`/`CF` flags, καταστρέφοντας εντελώς τη στατική ανάκτηση του CFG.

Η τεχνική – showcased by the SLOW#TEMPEST loader – μπορεί να παρακαμφθεί με ένα τριών βημάτων workflow που βασίζεται μόνο σε IDAPython και τον Unicorn CPU emulator.

### 1. Εντοπίστε κάθε indirect jump / call
```python
import idautils, idc

for ea in idautils.FunctionItems(idc.here()):
mnem = idc.print_insn_mnem(ea)
if mnem in ("jmp", "call") and idc.print_operand(ea, 0) == "rax":
print(f"[+] Dispatcher found @ {ea:X}")
```
### 2. Εξαγωγή του byte-code του dispatcher
```python
import idc

def get_dispatcher_start(jmp_ea, count=9):
s = jmp_ea
for _ in range(count):
s = idc.prev_head(s, 0)
return s

start = get_dispatcher_start(jmp_ea)
size  = jmp_ea + idc.get_item_size(jmp_ea) - start
code  = idc.get_bytes(start, size)
open(f"{start:X}.bin", "wb").write(code)
```
### 3. Εξομοιώστε το δύο φορές με Unicorn
```python
from unicorn import *
from unicorn.x86_const import *
import struct

def run(code, zf=0, cf=0):
BASE = 0x1000
mu = Uc(UC_ARCH_X86, UC_MODE_64)
mu.mem_map(BASE, 0x1000)
mu.mem_write(BASE, code)
mu.reg_write(UC_X86_REG_RFLAGS, (zf << 6) | cf)
mu.reg_write(UC_X86_REG_RAX, 0)
mu.emu_start(BASE, BASE+len(code))
return mu.reg_read(UC_X86_REG_RAX)
```
Εκτελέστε `run(code,0,0)` και `run(code,1,1)` για να λάβετε τους *false* και *true* branch targets.

### 4. Επαναφορά (patch back) άμεσου jump / call
```python
import struct, ida_bytes

def patch_direct(ea, target, is_call=False):
op   = 0xE8 if is_call else 0xE9           # CALL rel32 or JMP rel32
disp = target - (ea + 5) & 0xFFFFFFFF
ida_bytes.patch_bytes(ea, bytes([op]) + struct.pack('<I', disp))
```
Μετά το patch, αναγκάστε το IDA να αναλύσει ξανά τη συνάρτηση ώστε να αποκατασταθούν το πλήρες CFG και η έξοδος του Hex-Rays:
```python
import ida_auto, idaapi
idaapi.reanalyze_function(idc.get_func_attr(ea, idc.FUNCATTR_START))
```
### 5. Επισημάνετε έμμεσες κλήσεις API

Μόλις γίνει γνωστός ο πραγματικός προορισμός κάθε `call rax`, μπορείτε να πείτε στο IDA τι είναι, ώστε οι τύποι παραμέτρων & τα ονόματα μεταβλητών να ανακτηθούν αυτόματα:
```python
idc.set_callee_name(call_ea, resolved_addr, 0)  # IDA 8.3+
```
### Πρακτικά οφέλη

* Επαναφέρει το πραγματικό CFG → decompilation πηγαίνει από *10* γραμμές σε χιλιάδες.
* Επιτρέπει string-cross-reference & xrefs, καθιστώντας την ανακατασκευή της συμπεριφοράς απλή.
* Scripts είναι επαναχρησιμοποιήσιμα: τοποθετήστε τα σε οποιονδήποτε loader που προστατεύεται με το ίδιο trick.

---

## AdaptixC2: Εξαγωγή ρυθμίσεων και TTPs

Δείτε την αφιερωμένη σελίδα:

{{#ref}}
adaptixc2-config-extraction-and-ttps.md
{{#endref}}

## Αναφορές

- [Unit42 – Evolving Tactics of SLOW#TEMPEST: A Deep Dive Into Advanced Malware Techniques](https://unit42.paloaltonetworks.com/slow-tempest-malware-obfuscation/)
- SoTap: Lightweight in-app JNI (.so) behavior logger – [github.com/RezaArbabBot/SoTap](https://github.com/RezaArbabBot/SoTap)
- [Unit42 – AdaptixC2: A New Open-Source Framework Leveraged in Real-World Attacks](https://unit42.paloaltonetworks.com/adaptixc2-post-exploitation-framework/)

{{#include ../../banners/hacktricks-training.md}}
