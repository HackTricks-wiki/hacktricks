# Analiza malvera

{{#include ../../banners/hacktricks-training.md}}

## Priručnici za forenziku

[https://www.jaiminton.com/cheatsheet/DFIR/#](https://www.jaiminton.com/cheatsheet/DFIR/)

## Online servisi

- [VirusTotal](https://www.virustotal.com/gui/home/upload)
- [HybridAnalysis](https://www.hybrid-analysis.com)
- [Koodous](https://koodous.com)
- [Intezer](https://analyze.intezer.com)
- [Any.Run](https://any.run/)

## Offline antivirus i alati za detekciju

### Yara

#### Instalacija
```bash
sudo apt-get install -y yara
```
#### Pripremite pravila

Upotrebite ovaj skript da preuzmete i spojite sve yara malware rules sa github-a: [https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9](https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9)\
Kreirajte direktorijum _**rules**_ i pokrenite skript. Ovo će kreirati fajl pod imenom _**malware_rules.yar**_ koji sadrži sve yara rules za malware.
```bash
wget https://gist.githubusercontent.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9/raw/4ec711d37f1b428b63bed1f786b26a0654aa2f31/malware_yara_rules.py
mkdir rules
python malware_yara_rules.py
```
#### Skeniranje
```bash
yara -w malware_rules.yar image  #Scan 1 file
yara -w malware_rules.yar folder #Scan the whole folder
```
#### YaraGen: Provera za malware i kreiranje pravila

Možete koristiti alat [**YaraGen**](https://github.com/Neo23x0/yarGen) za generisanje yara rules iz binarnog fajla. Pogledajte ove tutorijale: [**Part 1**](https://www.nextron-systems.com/2015/02/16/write-simple-sound-yara-rules/), [**Part 2**](https://www.nextron-systems.com/2015/10/17/how-to-write-simple-but-sound-yara-rules-part-2/), [**Part 3**](https://www.nextron-systems.com/2016/04/15/how-to-write-simple-but-sound-yara-rules-part-3/)
```bash
python3 yarGen.py --update
python3.exe yarGen.py --excludegood -m  ../../mals/
```
### ClamAV

#### Instalacija
```
sudo apt-get install -y clamav
```
#### Skeniranje
```bash
sudo freshclam      #Update rules
clamscan filepath   #Scan 1 file
clamscan folderpath #Scan the whole folder
```
### [Capa](https://github.com/mandiant/capa)

**Capa** otkriva potencijalno maliciozne **capabilities** u izvršnim fajlovima: PE, ELF, .NET. Dakle, pronaći će stvari kao što su Att\&ck tactics, ili sumnjive capabilities kao što su:

- proverava OutputDebugString grešku
- pokreće se kao servis
- kreira proces

Preuzmite ga na [**Github repo**](https://github.com/mandiant/capa).

### IOCs

IOC means Indicator Of Compromise. IOC je skup **uslova koji identifikuju** neki potencijalno neželjeni softver ili potvrđeni **malware**. Blue Teams koriste ovu vrstu definicije da **pretraže ovu vrstu malicioznih fajlova** u svojim **sistemima** i **mrežama**.\
Deljenje ovih definicija je veoma korisno: kada se malware identifikuje na računaru i kreira IOC za taj malware, druge Blue Teams mogu koristiti taj IOC da brže identifikuju malware.

Alat za kreiranje ili izmenu IOCs je [**IOC Editor**](https://www.fireeye.com/services/freeware/ioc-editor.html)**.**\
Možete koristiti alate kao što su [**Redline**](https://www.fireeye.com/services/freeware/redline.html) da **pretražite definisane IOCs na uređaju**.

### Loki

[**Loki**](https://github.com/Neo23x0/Loki) je skener za Simple Indicators of Compromise.\
Detekcija se zasniva na četiri detection methods:
```
1. File Name IOC
Regex match on full file path/name

2. Yara Rule Check
Yara signature matches on file data and process memory

3. Hash Check
Compares known malicious hashes (MD5, SHA1, SHA256) with scanned files

4. C2 Back Connect Check
Compares process connection endpoints with C2 IOCs (new since version v.10)
```
### Linux Malware Detect

[**Linux Malware Detect (LMD)**](https://www.rfxn.com/projects/linux-malware-detect/) je malware skener za Linux izdat pod GNU GPLv2 licencom, dizajniran za pretnje sa kojima se suočavaju okruženja sa deljenim hostingom. Koristi podatke o pretnjama iz sistema za detekciju upada na ivici mreže da bi izdvojio malware koji se aktivno koristi u napadima i generiše signatures za detekciju. Pored toga, podaci o pretnjama se takođe dobijaju iz korisničkih prijava preko LMD checkout feature i iz malware community resources.

### rkhunter

Alati poput [**rkhunter**](http://rkhunter.sourceforge.net) mogu se koristiti za proveru datotečnog sistema zbog mogućih **rootkits** i malware.
```bash
sudo ./rkhunter --check -r / -l /tmp/rkhunter.log [--report-warnings-only] [--skip-keypress]
```
### FLOSS

[**FLOSS**](https://github.com/mandiant/flare-floss) je alat koji pokušava da pronađe obfuskovane stringove unutar izvršnih datoteka koristeći različite tehnike.

### PEpper

[PEpper ](https://github.com/Th3Hurrican3/PEpper)checks neke osnovne informacije unutar izvršne datoteke (binarni podaci, entropija, URLs and IPs, some yara rules).

### PEstudio

[PEstudio](https://www.winitor.com/download) je alat koji omogućava dobijanje informacija o Windows izvršnim datotekama kao što su imports, exports, headers, ali takođe će proveriti virus total i pronaći potencijalne Att\&ck tehnike.

### Detect It Easy(DiE)

[**DiE**](https://github.com/horsicq/Detect-It-Easy/) je alat koji detektuje da li je fajl **šifrovan** i takođe pronalazi **packers**.

### NeoPI

[**NeoPI** ](https://github.com/CiscoCXSecurity/NeoPI)is Python skripta koja koristi razne **statističke metode** za detekciju **obfuskovanog** i **šifrovanog** sadržaja u tekstualnim/skript fajlovima. Namena NeoPI-ja je da pomogne u **detekciji skrivenog web shell koda**.

### **php-malware-finder**

[**PHP-malware-finder**](https://github.com/nbs-system/php-malware-finder) se trudi da detektuje **obfuskovan**/**sumnjiv kod** kao i fajlove koji koriste **PHP** funkcije često korišćene u **malwares**/webshells.

### Apple Binary Signatures

Kada proveravate neki **malware sample** uvek bi trebalo da **proverite potpis** binarija, jer autor koji ga je potpisao može već biti **povezan** sa **malware**.
```bash
#Get signer
codesign -vv -d /bin/ls 2>&1 | grep -E "Authority|TeamIdentifier"

#Check if the app’s contents have been modified
codesign --verify --verbose /Applications/Safari.app

#Check if the signature is valid
spctl --assess --verbose /Applications/Safari.app
```
## Tehnike detekcije

### File Stacking

Ako znate da je neki folder koji sadrži **fajlove** web servera bio **poslednji put ažuriran na neki datum**, **proverite** **datume** kada su svi **fajlovi** na **web serveru** kreirani i izmenjeni, i ako je neki datum **sumnjiv**, proverite taj fajl.

### Referentno stanje

Ako **fajlovi** u folderu **ne bi trebalo da budu izmenjeni**, možete izračunati **hash** **originalnih fajlova** foldera i **uporediti** ih sa **trenutnim**. Sve što je izmenjeno biće **sumnjivo**.

### Statistička analiza

Kada se informacije čuvaju u logovima možete **proveriti statistiku, npr. koliko puta je pristupljeno svakom fajlu web servera**, jer web shell može biti jedan od najčešće pristupanih.

---

### Android telemetrija native koda unutar aplikacije (bez root-a)

Na Androidu možete instrumentisati native kod unutar procesa ciljane aplikacije tako što ćete unapred učitati malu biblioteku za logovanje pre nego što se ostale JNI biblioteke inicijalizuju. Ovo daje ranu vidljivost native ponašanja bez sistemskih hookova ili root pristupa. Popularan pristup je SoTap: ubacite libsotap.so za odgovarajući ABI u APK i injektujte poziv System.loadLibrary("sotap") rano (npr. static initializer ili Application.onCreate), zatim prikupite logove iz internog/eksternog puta ili koristite Logcat kao fallback.

Pogledajte stranicu za Android native reversing za detalje podešavanja i putanje logova:

{{#ref}}
../../mobile-pentesting/android-app-pentesting/reversing-native-libraries.md
{{#endref}}

---

## Deobfuskacija dinamičkog Control-Flow (JMP/CALL RAX Dispatchers)

Moderne porodice malvera intenzivno zloupotrebljavaju Control-Flow Graph (CFG) obfuscation: umesto direktnog jump/call oni izračunavaju destinaciju u runtime-u i izvršavaju `jmp rax` ili `call rax`. Mali *dispatcher* (obično devet instrukcija) postavlja finalni cilj u zavisnosti od CPU `ZF`/`CF` zastavica, što potpuno razbija statički oporavak CFG-a.

Tehniku — prikazanu u SLOW#TEMPEST loaderu — moguće je razbiti trostepenim tokom rada koji se oslanja samo na IDAPython i Unicorn CPU emulator.

### 1. Pronađite svaki indirektni jump / call
```python
import idautils, idc

for ea in idautils.FunctionItems(idc.here()):
mnem = idc.print_insn_mnem(ea)
if mnem in ("jmp", "call") and idc.print_operand(ea, 0) == "rax":
print(f"[+] Dispatcher found @ {ea:X}")
```
### 2. Izvucite dispatcher byte-code
```python
import idc

def get_dispatcher_start(jmp_ea, count=9):
s = jmp_ea
for _ in range(count):
s = idc.prev_head(s, 0)
return s

start = get_dispatcher_start(jmp_ea)
size  = jmp_ea + idc.get_item_size(jmp_ea) - start
code  = idc.get_bytes(start, size)
open(f"{start:X}.bin", "wb").write(code)
```
### 3. Emuliraj to dvaput pomoću Unicorn
```python
from unicorn import *
from unicorn.x86_const import *
import struct

def run(code, zf=0, cf=0):
BASE = 0x1000
mu = Uc(UC_ARCH_X86, UC_MODE_64)
mu.mem_map(BASE, 0x1000)
mu.mem_write(BASE, code)
mu.reg_write(UC_X86_REG_RFLAGS, (zf << 6) | cf)
mu.reg_write(UC_X86_REG_RAX, 0)
mu.emu_start(BASE, BASE+len(code))
return mu.reg_read(UC_X86_REG_RAX)
```
Pokreni `run(code,0,0)` i `run(code,1,1)` da dobiješ ciljeve grana *false* i *true*.

### 4. Vraćanje direktnog jump / call-a
```python
import struct, ida_bytes

def patch_direct(ea, target, is_call=False):
op   = 0xE8 if is_call else 0xE9           # CALL rel32 or JMP rel32
disp = target - (ea + 5) & 0xFFFFFFFF
ida_bytes.patch_bytes(ea, bytes([op]) + struct.pack('<I', disp))
```
Nakon patching, naterajte IDA da ponovo analizira funkciju tako da se kompletan CFG i Hex-Rays izlaz vrate:
```python
import ida_auto, idaapi
idaapi.reanalyze_function(idc.get_func_attr(ea, idc.FUNCATTR_START))
```
### 5. Označavanje indirektnih API poziva

Kada je stvarna destinacija svakog `call rax` poznata, možete reći IDA-u šta je to, tako da se tipovi parametara & imena promenljivih automatski obnove:
```python
idc.set_callee_name(call_ea, resolved_addr, 0)  # IDA 8.3+
```
### Praktične prednosti

* Vraća stvarni CFG → decompilation prelazi sa *10* linija na hiljade.
* Omogućava string-cross-reference & xrefs, čineći rekonstrukciju ponašanja trivijalnom.
* Scripts su ponovo upotrebljivi: ubaci ih u bilo koji loader zaštićen istim trikom.

---

## AdaptixC2: Ekstrakcija konfiguracije i TTPs

Pogledajte posvećenu stranicu:

{{#ref}}
adaptixc2-config-extraction-and-ttps.md
{{#endref}}

## Referencije

- [Unit42 – Evolving Tactics of SLOW#TEMPEST: A Deep Dive Into Advanced Malware Techniques](https://unit42.paloaltonetworks.com/slow-tempest-malware-obfuscation/)
- SoTap: Lightweight in-app JNI (.so) behavior logger – [github.com/RezaArbabBot/SoTap](https://github.com/RezaArbabBot/SoTap)
- [Unit42 – AdaptixC2: A New Open-Source Framework Leveraged in Real-World Attacks](https://unit42.paloaltonetworks.com/adaptixc2-post-exploitation-framework/)

{{#include ../../banners/hacktricks-training.md}}
