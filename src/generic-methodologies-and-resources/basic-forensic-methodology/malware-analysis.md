# मैलवेयर विश्लेषण

{{#include ../../banners/hacktricks-training.md}}

## फॉरेंसिक्स चीटशीट

[https://www.jaiminton.com/cheatsheet/DFIR/#](https://www.jaiminton.com/cheatsheet/DFIR/)

## ऑनलाइन सेवाएं

- [VirusTotal](https://www.virustotal.com/gui/home/upload)
- [HybridAnalysis](https://www.hybrid-analysis.com)
- [Koodous](https://koodous.com)
- [Intezer](https://analyze.intezer.com)
- [Any.Run](https://any.run/)

## ऑफ़लाइन एंटीवायरस और डिटेक्शन टूल्स

### Yara

#### इंस्टॉल
```bash
sudo apt-get install -y yara
```
#### नियम तैयार करें

इस script का उपयोग github से सभी yara malware rules download और merge करने के लिए करें: [https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9](https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9)\  
Create the _**rules**_ directory and execute it. This will create a file called _**malware_rules.yar**_ which contains all the yara rules for malware.
```bash
wget https://gist.githubusercontent.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9/raw/4ec711d37f1b428b63bed1f786b26a0654aa2f31/malware_yara_rules.py
mkdir rules
python malware_yara_rules.py
```
#### स्कैन
```bash
yara -w malware_rules.yar image  #Scan 1 file
yara -w malware_rules.yar folder #Scan the whole folder
```
#### YaraGen: malware की जाँच और नियम बनाना

आप [**YaraGen**](https://github.com/Neo23x0/yarGen) टूल का उपयोग करके किसी binary से yara rules जेनरेट कर सकते हैं। इन ट्यूटोरियल्स को देखें: [**Part 1**](https://www.nextron-systems.com/2015/02/16/write-simple-sound-yara-rules/), [**Part 2**](https://www.nextron-systems.com/2015/10/17/how-to-write-simple-but-sound-yara-rules-part-2/), [**Part 3**](https://www.nextron-systems.com/2016/04/15/how-to-write-simple-but-sound-yara-rules-part-3/)
```bash
python3 yarGen.py --update
python3.exe yarGen.py --excludegood -m  ../../mals/
```
### ClamAV

#### इंस्टॉल
```
sudo apt-get install -y clamav
```
#### Scan
```bash
sudo freshclam      #Update rules
clamscan filepath   #Scan 1 file
clamscan folderpath #Scan the whole folder
```
### [Capa](https://github.com/mandiant/capa)

**Capa** executables में संभावित रूप से दुर्भावनापूर्ण **capabilities** का पता लगाती है: PE, ELF, .NET. यह Att\&ck tactics जैसी चीज़ें और निम्नलिखित तरह की संदिग्ध क्षमताओं को खोजेगा:

- OutputDebugString error के लिए जाँच
- सर्विस के रूप में चलना
- प्रोसेस बनाना

इसे [**Github repo**](https://github.com/mandiant/capa) में प्राप्त करें।

### IOCs

IOC का मतलब Indicator Of Compromise है। एक IOC उन **पहचानने वाली शर्तों** का समूह है जो कुछ संभावित रूप से अनचाहे सॉफ़्टवेयर या निश्चित रूप से मौजूद **malware** की पहचान करती हैं। Blue Teams इस तरह की परिभाषा का उपयोग अपने **सिस्टम्स** और **नेटवर्क्स** में इस प्रकार की **दुर्भावनापूर्ण फ़ाइलों की खोज** के लिए करते हैं.\
इन परिभाषाओं को साझा करना बहुत उपयोगी है क्योंकि जब किसी कंप्यूटर में malware पहचाना जाता है और उस malware के लिए एक IOC बनाया जाता है, तो अन्य Blue Teams इसका उपयोग करके उस malware की पहचान तेज़ी से कर सकते हैं।

IOCs बनाने या संशोधित करने के लिए एक टूल है [**IOC Editor**](https://www.fireeye.com/services/freeware/ioc-editor.html)**.**\
आप [**Redline**](https://www.fireeye.com/services/freeware/redline.html) जैसे टूल्स का उपयोग **डिवाइस में परिभाषित IOCs खोजने के लिए** कर सकते हैं।

### Loki

[**Loki**](https://github.com/Neo23x0/Loki) Simple Indicators of Compromise के लिए एक स्कैनर है.\
Detection चार पता लगाने के तरीकों पर आधारित है:
```
1. File Name IOC
Regex match on full file path/name

2. Yara Rule Check
Yara signature matches on file data and process memory

3. Hash Check
Compares known malicious hashes (MD5, SHA1, SHA256) with scanned files

4. C2 Back Connect Check
Compares process connection endpoints with C2 IOCs (new since version v.10)
```
### Linux Malware Detect

[**Linux Malware Detect (LMD)**](https://www.rfxn.com/projects/linux-malware-detect/) Linux के लिए एक malware scanner है जो GNU GPLv2 license के तहत जारी है, और इसे shared hosted environments में आने वाले threats को ध्यान में रखकर डिज़ाइन किया गया है। यह network edge intrusion detection systems से threat data का उपयोग करके उन malware को निकालता है जो सक्रिय रूप से attacks में उपयोग हो रहे हैं और detection के लिए signatures जनरेट करता है। इसके अलावा, threat data LMD checkout feature और malware community resources में उपयोगकर्ताओं द्वारा की गई submissions से भी प्राप्त होता है।

### rkhunter

rkhunter जैसे टूल्स का उपयोग filesystem की जाँच के लिए किया जा सकता है ताकि संभावित **rootkits** और malware का पता लगाया जा सके।
```bash
sudo ./rkhunter --check -r / -l /tmp/rkhunter.log [--report-warnings-only] [--skip-keypress]
```
### FLOSS

[**FLOSS**](https://github.com/mandiant/flare-floss) एक टूल है जो विभिन्न तकनीकों का उपयोग करके executables के अंदर obfuscated strings खोजने की कोशिश करता है।

### PEpper

[PEpper ](https://github.com/Th3Hurrican3/PEpper) executable के अंदर कुछ बेसिक चीज़ें चेक करता है (binary data, entropy, URLs and IPs, कुछ yara rules)।

### PEstudio

[PEstudio](https://www.winitor.com/download) एक टूल है जो Windows executables की जानकारी प्राप्त करने की अनुमति देता है जैसे imports, exports, headers, और साथ ही यह VirusTotal चेक करेगा और संभावित Att\&ck techniques ढूँढेगा।

### Detect It Easy(DiE)

[**DiE**](https://github.com/horsicq/Detect-It-Easy/) एक टूल है जो पता लगाता है कि कोई फ़ाइल **encrypted** है या नहीं और इसके साथ ही **packers** भी खोजता है।

### NeoPI

[**NeoPI** ](https://github.com/CiscoCXSecurity/NeoPI) एक Python script है जो text/script files के भीतर मौजूद **obfuscated** और **encrypted** content को detect करने के लिए विभिन्न **statistical methods** का उपयोग करती है। NeoPI का उद्देश्य **detection of hidden web shell code** में सहायता करना है।

### **php-malware-finder**

[**PHP-malware-finder**](https://github.com/nbs-system/php-malware-finder) अपना पूरा प्रयास करता है **obfuscated**/**dodgy code** का पता लगाने के लिए और उन फाइलों को भी ढूँढता है जो अक्सर **PHP** functions का इस्तेमाल करते हैं जो **malwares**/webshells में पाए जाते हैं।

### Apple Binary Signatures

जब आप किसी **malware sample** की जाँच कर रहे हों तो आपको हमेशा binary के **signature** की जाँच करनी चाहिए क्योंकि जिसने इसे sign किया है वह पहले से **malware** से **संबंधित** हो सकता है।
```bash
#Get signer
codesign -vv -d /bin/ls 2>&1 | grep -E "Authority|TeamIdentifier"

#Check if the app’s contents have been modified
codesign --verify --verbose /Applications/Safari.app

#Check if the signature is valid
spctl --assess --verbose /Applications/Safari.app
```
## डिटेक्शन तकनीकें

### File Stacking

यदि आपको पता है कि किसी फ़ोल्डर में वेब सर्वर के **files** थे जिन्हें **किसी तिथि को अंतिम बार अपडेट किया गया था**। उस फ़ोल्डर में मौजूद सभी **files** के बनाए जाने और संशोधित होने की **date** जाँचें, और अगर कोई **date** संदिग्ध हो तो उस file की जाँच करें।

### Baselines

यदि किसी फ़ोल्डर के files **shouldn't have been modified** होने चाहिए थे, तो आप उस फ़ोल्डर के मूल **files** का **hash** निकालकर उन्हें वर्तमान files से **compare** कर सकते हैं। जो भी चीज़ें बदली हुई हों वे **suspicious** होंगी।

### Statistical Analysis

जब जानकारी logs में सेव होती है, आप ऐसे आँकड़े देख सकते हैं — जैसे कि प्रत्येक web server के file तक कितनी बार पहुँच हुई; क्योंकि एक web shell अक्सर सबसे ज्यादा access किया गया file हो सकता है।

---

### Android in-app native telemetry (no root)

Android पर, आप target app process के अंदर native code में instrumentation कर सकते हैं, छोटे से logger library को अन्य JNI libs initialize होने से पहले preload करके। इससे system-wide hooks या root के बिना ही native व्यवहार की शुरुआती visibility मिलती है। एक लोकप्रिय तरीका SoTap है: सही ABI के लिए libsotap.so को APK में डालें और early में एक System.loadLibrary("sotap") कॉल inject करें (उदा. static initializer या Application.onCreate), फिर internal/external paths या Logcat fallback से logs इकट्ठा करें।

See the Android native reversing page for setup details and log paths:

{{#ref}}
../../mobile-pentesting/android-app-pentesting/reversing-native-libraries.md
{{#endref}}

---

## Deobfuscating Dynamic Control-Flow (JMP/CALL RAX Dispatchers)

आधुनिक malware families Control-Flow Graph (CFG) obfuscation का भारी दुरुपयोग करते हैं: सीधे jump/call के बजाय वे destination को run-time पर गणना करते हैं और `jmp rax` या `call rax` execute करते हैं। एक छोटा *dispatcher* (आमतौर पर नौ instructions) CPU के `ZF`/`CF` flags पर निर्भर करके final target सेट करता है, जिससे static CFG recovery पूरी तरह टूटी जाती है।

यह technique — जिसे SLOW#TEMPEST loader ने प्रदर्शित किया — केवल IDAPython और Unicorn CPU emulator पर निर्भर रहने वाले तीन-चरण के workflow से हराया जा सकता है।

### 1. हर indirect jump / call का पता लगाएँ
```python
import idautils, idc

for ea in idautils.FunctionItems(idc.here()):
mnem = idc.print_insn_mnem(ea)
if mnem in ("jmp", "call") and idc.print_operand(ea, 0) == "rax":
print(f"[+] Dispatcher found @ {ea:X}")
```
### 2. dispatcher byte-code निकालें
```python
import idc

def get_dispatcher_start(jmp_ea, count=9):
s = jmp_ea
for _ in range(count):
s = idc.prev_head(s, 0)
return s

start = get_dispatcher_start(jmp_ea)
size  = jmp_ea + idc.get_item_size(jmp_ea) - start
code  = idc.get_bytes(start, size)
open(f"{start:X}.bin", "wb").write(code)
```
### 3. Unicorn के साथ इसे दो बार Emulate करें
```python
from unicorn import *
from unicorn.x86_const import *
import struct

def run(code, zf=0, cf=0):
BASE = 0x1000
mu = Uc(UC_ARCH_X86, UC_MODE_64)
mu.mem_map(BASE, 0x1000)
mu.mem_write(BASE, code)
mu.reg_write(UC_X86_REG_RFLAGS, (zf << 6) | cf)
mu.reg_write(UC_X86_REG_RAX, 0)
mu.emu_start(BASE, BASE+len(code))
return mu.reg_read(UC_X86_REG_RAX)
```
*false* और *true* branch targets प्राप्त करने के लिए `run(code,0,0)` और `run(code,1,1)` चलाएँ।

### 4. Patch back a direct jump / call
```python
import struct, ida_bytes

def patch_direct(ea, target, is_call=False):
op   = 0xE8 if is_call else 0xE9           # CALL rel32 or JMP rel32
disp = target - (ea + 5) & 0xFFFFFFFF
ida_bytes.patch_bytes(ea, bytes([op]) + struct.pack('<I', disp))
```
पैच करने के बाद, फ़ंक्शन को पुनः विश्लेषित करने के लिए IDA को मजबूर करें ताकि पूरा CFG और Hex-Rays आउटपुट फिर से बहाल हो:
```python
import ida_auto, idaapi
idaapi.reanalyze_function(idc.get_func_attr(ea, idc.FUNCATTR_START))
```
### 5. अप्रत्यक्ष API कॉल्स को लेबल करें

एक बार जब हर `call rax` का वास्तविक गंतव्य ज्ञात हो जाता है, तो आप IDA को बता सकते हैं कि वह क्या है ताकि पैरामीटर प्रकार और वेरिएबल नाम स्वतः पुनर्प्राप्त हो जाएँ:
```python
idc.set_callee_name(call_ea, resolved_addr, 0)  # IDA 8.3+
```
### व्यावहारिक लाभ

* वास्तविक CFG को बहाल करता है → decompilation *10* लाइनों से हजारों तक पहुँच जाता है.
* string-cross-reference & xrefs सक्षम करता है, जिससे behaviour reconstruction बेहद सरल हो जाता है.
* Scripts पुन: उपयोग योग्य हैं: इन्हें उसी ट्रिक से सुरक्षित किसी भी loader में डाल दें.

---

## AdaptixC2: Configuration Extraction and TTPs

समर्पित पेज देखें:

{{#ref}}
adaptixc2-config-extraction-and-ttps.md
{{#endref}}

## संदर्भ

- [Unit42 – Evolving Tactics of SLOW#TEMPEST: A Deep Dive Into Advanced Malware Techniques](https://unit42.paloaltonetworks.com/slow-tempest-malware-obfuscation/)
- SoTap: Lightweight in-app JNI (.so) behavior logger – [github.com/RezaArbabBot/SoTap](https://github.com/RezaArbabBot/SoTap)
- [Unit42 – AdaptixC2: A New Open-Source Framework Leveraged in Real-World Attacks](https://unit42.paloaltonetworks.com/adaptixc2-post-exploitation-framework/)

{{#include ../../banners/hacktricks-training.md}}
