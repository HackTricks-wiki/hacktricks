# Análisis de Malware

{{#include ../../banners/hacktricks-training.md}}

## Hojas de referencia Forensics

[https://www.jaiminton.com/cheatsheet/DFIR/#](https://www.jaiminton.com/cheatsheet/DFIR/)

## Servicios en línea

- [VirusTotal](https://www.virustotal.com/gui/home/upload)
- [HybridAnalysis](https://www.hybrid-analysis.com)
- [Koodous](https://koodous.com)
- [Intezer](https://analyze.intezer.com)
- [Any.Run](https://any.run/)

## Herramientas Offline de Antivirus y Detección

### Yara

#### Instalación
```bash
sudo apt-get install -y yara
```
#### Preparar reglas

Usa este script para descargar y fusionar todas las reglas yara para malware desde github: [https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9]\  
Crea el directorio _**rules**_ y ejecútalo. Esto creará un archivo llamado _**malware_rules.yar**_ que contiene todas las reglas yara para malware.
```bash
wget https://gist.githubusercontent.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9/raw/4ec711d37f1b428b63bed1f786b26a0654aa2f31/malware_yara_rules.py
mkdir rules
python malware_yara_rules.py
```
#### Escaneo
```bash
yara -w malware_rules.yar image  #Scan 1 file
yara -w malware_rules.yar folder #Scan the whole folder
```
#### YaraGen: Comprobar malware y crear reglas

Puedes usar la herramienta [**YaraGen**](https://github.com/Neo23x0/yarGen) para generar yara rules a partir de un binario. Consulta estos tutoriales: [**Part 1**](https://www.nextron-systems.com/2015/02/16/write-simple-sound-yara-rules/), [**Part 2**](https://www.nextron-systems.com/2015/10/17/how-to-write-simple-but-sound-yara-rules-part-2/), [**Part 3**](https://www.nextron-systems.com/2016/04/15/how-to-write-simple-but-sound-yara-rules-part-3/)
```bash
python3 yarGen.py --update
python3.exe yarGen.py --excludegood -m  ../../mals/
```
### ClamAV

#### Instalación
```
sudo apt-get install -y clamav
```
#### Escaneo
```bash
sudo freshclam      #Update rules
clamscan filepath   #Scan 1 file
clamscan folderpath #Scan the whole folder
```
### [Capa](https://github.com/mandiant/capa)

**Capa** detecta **capabilities** potencialmente maliciosas en ejecutables: PE, ELF, .NET. Así encontrará cosas como Att\&ck tactics, o capacidades sospechosas como:

- comprobar error de OutputDebugString
- ejecutarse como servicio
- crear proceso

Consíguelo en el [**Github repo**](https://github.com/mandiant/capa).

### IOCs

IOC significa Indicator Of Compromise. Un IOC es un conjunto de **condiciones que identifican** algún software potencialmente no deseado o el **malware** confirmado. Los Blue Teams usan este tipo de definiciones para **buscar este tipo de archivos maliciosos** en sus **sistemas** y **redes**.\
Compartir estas definiciones es muy útil: cuando se identifica malware en un equipo y se crea un IOC para ese malware, otros Blue Teams pueden usarlo para identificar el malware más rápido.

Una herramienta para crear o modificar IOCs es [**IOC Editor**](https://www.fireeye.com/services/freeware/ioc-editor.html)**.**\
Puedes usar herramientas como [**Redline**](https://www.fireeye.com/services/freeware/redline.html) para **buscar IOCs definidos en un dispositivo**.

### Loki

[**Loki**](https://github.com/Neo23x0/Loki) es un scanner para Indicadores simples de compromiso.\
La detección se basa en cuatro métodos de detección:
```
1. File Name IOC
Regex match on full file path/name

2. Yara Rule Check
Yara signature matches on file data and process memory

3. Hash Check
Compares known malicious hashes (MD5, SHA1, SHA256) with scanned files

4. C2 Back Connect Check
Compares process connection endpoints with C2 IOCs (new since version v.10)
```
### Linux Malware Detect

[**Linux Malware Detect (LMD)**](https://www.rfxn.com/projects/linux-malware-detect/) es un escáner de malware para Linux publicado bajo la licencia GNU GPLv2, diseñado en torno a las amenazas que enfrentan los entornos de hosting compartido. Utiliza datos de amenazas de sistemas de detección de intrusiones en el borde de la red para extraer malware que se está usando activamente en ataques y genera firmas para su detección. Además, los datos de amenazas también se obtienen de envíos de usuarios mediante la LMD checkout feature y de recursos de la comunidad de malware.

### rkhunter

Herramientas como [**rkhunter**](http://rkhunter.sourceforge.net) pueden usarse para revisar el sistema de archivos en busca de posibles **rootkits** y malware.
```bash
sudo ./rkhunter --check -r / -l /tmp/rkhunter.log [--report-warnings-only] [--skip-keypress]
```
### FLOSS

[**FLOSS**](https://github.com/mandiant/flare-floss) es una herramienta que intentará encontrar obfuscated strings dentro de ejecutables usando diferentes técnicas.

### PEpper

[PEpper ](https://github.com/Th3Hurrican3/PEpper) comprueba algunas cosas básicas dentro del ejecutable (binary data, entropy, URLs and IPs, some yara rules).

### PEstudio

[PEstudio](https://www.winitor.com/download) es una herramienta que permite obtener información de ejecutables Windows tales como imports, exports, headers, pero también comprobará virus total y encontrará posibles técnicas Att\&ck.

### Detect It Easy(DiE)

[**DiE**](https://github.com/horsicq/Detect-It-Easy/) es una herramienta para detectar si un archivo está **encrypted** y también encontrar **packers**.

### NeoPI

[**NeoPI** ](https://github.com/CiscoCXSecurity/NeoPI) es un script Python que usa una variedad de **statistical methods** para detectar contenido **obfuscated** y **encrypted** dentro de archivos de texto/script. El propósito de NeoPI es ayudar en la **detection of hidden web shell code**.

### **php-malware-finder**

[**PHP-malware-finder**](https://github.com/nbs-system/php-malware-finder) hace su mejor esfuerzo para detectar **obfuscated**/**dodgy code** así como archivos que usan funciones **PHP** que a menudo son usadas en **malwares**/webshells.

### Apple Binary Signatures

Al revisar alguna **malware sample**, siempre debes **check the signature** del binario, ya que el **developer** que lo firmó podría ya estar **related** con **malware**.
```bash
#Get signer
codesign -vv -d /bin/ls 2>&1 | grep -E "Authority|TeamIdentifier"

#Check if the app’s contents have been modified
codesign --verify --verbose /Applications/Safari.app

#Check if the signature is valid
spctl --assess --verbose /Applications/Safari.app
```
## Técnicas de detección

### File Stacking

Si sabes que una carpeta que contiene los **archivos** de un servidor web fue **actualizada por última vez en cierta fecha**. **Comprueba** la **fecha** en que todos los **archivos** en el **servidor web fueron creados y modificados** y si alguna fecha es **sospechosa**, revisa ese archivo.

### Baselines

Si los archivos de una carpeta **no deberían haber sido modificados**, puedes calcular el **hash** de los **archivos originales** de la carpeta y **compararlos** con los **actuales**. Cualquier cosa modificada será **sospechosa**.

### Statistical Analysis

Cuando la información se guarda en logs, puedes **consultar estadísticas**, por ejemplo cuántas veces se accedió a cada archivo del servidor web, ya que un web shell podría ser uno de los más accedidos.

---

### Telemetría nativa in-app en Android (sin root)

En Android, puedes instrumentar código nativo dentro del proceso de la app objetivo precargando una pequeña librería logger antes de que otras libs JNI se inicialicen. Esto proporciona visibilidad temprana del comportamiento nativo sin hooks a nivel de sistema ni root. Un enfoque popular es SoTap: coloca libsotap.so para el ABI correcto dentro del APK e injerta una llamada System.loadLibrary("sotap") temprano (p. ej., inicializador estático o Application.onCreate), luego recoge los logs desde rutas internas/externas o, en su defecto, Logcat.

See the Android native reversing page for setup details and log paths:

{{#ref}}
../../mobile-pentesting/android-app-pentesting/reversing-native-libraries.md
{{#endref}}

---

## Deobfuscating Dynamic Control-Flow (JMP/CALL RAX Dispatchers)

Las familias de malware modernas abusan en gran medida de la obfuscación del Control-Flow Graph (CFG): en lugar de un salto/llamada directa calculan el destino en tiempo de ejecución y ejecutan un `jmp rax` o `call rax`. Un pequeño *dispatcher* (típicamente nueve instrucciones) establece el destino final dependiendo de las banderas de la CPU `ZF`/`CF`, rompiendo completamente la recuperación estática del CFG.

The technique – showcased by the SLOW#TEMPEST loader – can be defeated with a three-step workflow that only relies on IDAPython and the Unicorn CPU emulator.

### 1. Localiza cada salto/call indirecto
```python
import idautils, idc

for ea in idautils.FunctionItems(idc.here()):
mnem = idc.print_insn_mnem(ea)
if mnem in ("jmp", "call") and idc.print_operand(ea, 0) == "rax":
print(f"[+] Dispatcher found @ {ea:X}")
```
### 2. Extraer el byte-code del dispatcher
```python
import idc

def get_dispatcher_start(jmp_ea, count=9):
s = jmp_ea
for _ in range(count):
s = idc.prev_head(s, 0)
return s

start = get_dispatcher_start(jmp_ea)
size  = jmp_ea + idc.get_item_size(jmp_ea) - start
code  = idc.get_bytes(start, size)
open(f"{start:X}.bin", "wb").write(code)
```
### 3. Emularlo dos veces con Unicorn
```python
from unicorn import *
from unicorn.x86_const import *
import struct

def run(code, zf=0, cf=0):
BASE = 0x1000
mu = Uc(UC_ARCH_X86, UC_MODE_64)
mu.mem_map(BASE, 0x1000)
mu.mem_write(BASE, code)
mu.reg_write(UC_X86_REG_RFLAGS, (zf << 6) | cf)
mu.reg_write(UC_X86_REG_RAX, 0)
mu.emu_start(BASE, BASE+len(code))
return mu.reg_read(UC_X86_REG_RAX)
```
Ejecute `run(code,0,0)` y `run(code,1,1)` para obtener los destinos de las ramas *false* y *true*.

### 4. Parchear de nuevo un jump / call
```python
import struct, ida_bytes

def patch_direct(ea, target, is_call=False):
op   = 0xE8 if is_call else 0xE9           # CALL rel32 or JMP rel32
disp = target - (ea + 5) & 0xFFFFFFFF
ida_bytes.patch_bytes(ea, bytes([op]) + struct.pack('<I', disp))
```
Después del patching, fuerza a IDA a reanalizar la función para que se restablezcan el CFG completo y la salida de Hex-Rays:
```python
import ida_auto, idaapi
idaapi.reanalyze_function(idc.get_func_attr(ea, idc.FUNCATTR_START))
```
### 5. Etiquetar llamadas API indirectas

Una vez que se conoce el destino real de cada `call rax`, puedes indicarle a IDA cuál es para que los tipos de parámetros y los nombres de variables se recuperen automáticamente:
```python
idc.set_callee_name(call_ea, resolved_addr, 0)  # IDA 8.3+
```
### Beneficios prácticos

* Restaura el CFG real → la decompilación pasa de *10* líneas a miles.
* Permite string-cross-reference & xrefs, haciendo la reconstrucción del comportamiento trivial.
* Los scripts son reutilizables: insértalos en cualquier loader protegido por el mismo truco.

---

## AdaptixC2: Extracción de configuración y TTPs

Ver la página dedicada:

{{#ref}}
adaptixc2-config-extraction-and-ttps.md
{{#endref}}

## Referencias

- [Unit42 – Evolving Tactics of SLOW#TEMPEST: A Deep Dive Into Advanced Malware Techniques](https://unit42.paloaltonetworks.com/slow-tempest-malware-obfuscation/)
- SoTap: Registrador ligero de comportamiento in-app JNI (.so) – [github.com/RezaArbabBot/SoTap](https://github.com/RezaArbabBot/SoTap)
- [Unit42 – AdaptixC2: A New Open-Source Framework Leveraged in Real-World Attacks](https://unit42.paloaltonetworks.com/adaptixc2-post-exploitation-framework/)

{{#include ../../banners/hacktricks-training.md}}
