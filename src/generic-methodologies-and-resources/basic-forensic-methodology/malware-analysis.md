# Analiza Malvera

{{#include ../../banners/hacktricks-training.md}}

## Forenzičke CheatSheets

[https://www.jaiminton.com/cheatsheet/DFIR/#](https://www.jaiminton.com/cheatsheet/DFIR/)

## Online Usluge

- [VirusTotal](https://www.virustotal.com/gui/home/upload)
- [HybridAnalysis](https://www.hybrid-analysis.com)
- [Koodous](https://koodous.com)
- [Intezer](https://analyze.intezer.com)
- [Any.Run](https://any.run/)

## Offline Antivirus i Alati za Detekciju

### Yara

#### Instaliraj
```bash
sudo apt-get install -y yara
```
#### Pripremite pravila

Use this script to download and merge all the yara malware rules from github: [https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9](https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9)\
Create the _**rules**_ directory and execute it. This will create a file called _**malware_rules.yar**_ which contains all the yara rules for malware.
```bash
wget https://gist.githubusercontent.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9/raw/4ec711d37f1b428b63bed1f786b26a0654aa2f31/malware_yara_rules.py
mkdir rules
python malware_yara_rules.py
```
#### Skeneranje
```bash
yara -w malware_rules.yar image  #Scan 1 file
yara -w malware_rules.yar folder #Scan the whole folder
```
#### YaraGen: Proverite malver i kreirajte pravila

Možete koristiti alat [**YaraGen**](https://github.com/Neo23x0/yarGen) za generisanje yara pravila iz binarnog fajla. Pogledajte ove tutorijale: [**Deo 1**](https://www.nextron-systems.com/2015/02/16/write-simple-sound-yara-rules/), [**Deo 2**](https://www.nextron-systems.com/2015/10/17/how-to-write-simple-but-sound-yara-rules-part-2/), [**Deo 3**](https://www.nextron-systems.com/2016/04/15/how-to-write-simple-but-sound-yara-rules-part-3/)
```bash
python3 yarGen.py --update
python3.exe yarGen.py --excludegood -m  ../../mals/
```
### ClamAV

#### Instaliraj
```
sudo apt-get install -y clamav
```
#### Skeneranje
```bash
sudo freshclam      #Update rules
clamscan filepath   #Scan 1 file
clamscan folderpath #Scan the whole folder
```
### [Capa](https://github.com/mandiant/capa)

**Capa** detektuje potencijalno zlonamerne **kapacitete** u izvršnim datotekama: PE, ELF, .NET. Tako će pronaći stvari kao što su Att\&ck taktike, ili sumnjivi kapaciteti kao što su:

- provera za OutputDebugString grešku
- pokretanje kao servis
- kreiranje procesa

Preuzmite ga u [**Github repo**](https://github.com/mandiant/capa).

### IOCs

IOC znači Indikator Kompromitacije. IOC je skup **uslova koji identifikuju** neki potencijalno neželjeni softver ili potvrđeni **malver**. Plave ekipe koriste ovu vrstu definicije da **traže ovu vrstu zlonamernih datoteka** u svojim **sistemima** i **mrežama**.\
Deljenje ovih definicija je veoma korisno jer kada se malver identifikuje na računaru i kreira se IOC za taj malver, druge Plave ekipe mogu to koristiti da brže identifikuju malver.

Alat za kreiranje ili modifikovanje IOCs je [**IOC Editor**](https://www.fireeye.com/services/freeware/ioc-editor.html)**.**\
Možete koristiti alate kao što su [**Redline**](https://www.fireeye.com/services/freeware/redline.html) da **tražite definisane IOCs na uređaju**.

### Loki

[**Loki**](https://github.com/Neo23x0/Loki) je skener za Simple Indicators of Compromise.\
Detekcija se zasniva na četiri metode detekcije:
```
1. File Name IOC
Regex match on full file path/name

2. Yara Rule Check
Yara signature matches on file data and process memory

3. Hash Check
Compares known malicious hashes (MD5, SHA1, SHA256) with scanned files

4. C2 Back Connect Check
Compares process connection endpoints with C2 IOCs (new since version v.10)
```
### Linux Malware Detect

[**Linux Malware Detect (LMD)**](https://www.rfxn.com/projects/linux-malware-detect/) je skener malvera za Linux koji je objavljen pod GNU GPLv2 licencom, a dizajniran je oko pretnji sa kojima se suočavaju deljeni hostovani okruženja. Koristi podatke o pretnjama iz sistema za detekciju upada na mrežnom rubu kako bi izvukao malver koji se aktivno koristi u napadima i generiše potpise za detekciju. Pored toga, podaci o pretnjama se takođe dobijaju iz korisničkih prijava putem LMD checkout funkcije i resursa zajednice malvera.

### rkhunter

Alati poput [**rkhunter**](http://rkhunter.sourceforge.net) mogu se koristiti za proveru datotečnog sistema na moguće **rootkitove** i malver.
```bash
sudo ./rkhunter --check -r / -l /tmp/rkhunter.log [--report-warnings-only] [--skip-keypress]
```
### FLOSS

[**FLOSS**](https://github.com/mandiant/flare-floss) je alat koji pokušava da pronađe obfuskirane stringove unutar izvršnih datoteka koristeći različite tehnike.

### PEpper

[PEpper ](https://github.com/Th3Hurrican3/PEpper)proverava neke osnovne stvari unutar izvršne datoteke (binarni podaci, entropija, URL-ovi i IP adrese, neka yara pravila).

### PEstudio

[PEstudio](https://www.winitor.com/download) je alat koji omogućava dobijanje informacija o Windows izvršnim datotekama kao što su uvozi, izvozi, zaglavlja, ali će takođe proveriti virus total i pronaći potencijalne Att\&ck tehnike.

### Detect It Easy(DiE)

[**DiE**](https://github.com/horsicq/Detect-It-Easy/) je alat za detekciju da li je datoteka **kriptovana** i takođe pronalazi **pakere**.

### NeoPI

[**NeoPI** ](https://github.com/CiscoCXSecurity/NeoPI)je Python skripta koja koristi razne **statističke metode** za detekciju **obfuskovanog** i **kriptovanog** sadržaja unutar tekstualnih/skript datoteka. Namena NeoPI-a je da pomogne u **detekciji skrivenog web shell koda**.

### **php-malware-finder**

[**PHP-malware-finder**](https://github.com/nbs-system/php-malware-finder) se trudi da detektuje **obfuskovani**/**sumnjivi kod** kao i datoteke koje koriste **PHP** funkcije često korišćene u **malverima**/webshell-ima.

### Apple Binary Signatures

Kada proveravate neki **uzorak malvera**, uvek treba da **proverite potpis** binarne datoteke jer **razvijač** koji je potpisao može već biti **povezan** sa **malverom.**
```bash
#Get signer
codesign -vv -d /bin/ls 2>&1 | grep -E "Authority|TeamIdentifier"

#Check if the app’s contents have been modified
codesign --verify --verbose /Applications/Safari.app

#Check if the signature is valid
spctl --assess --verbose /Applications/Safari.app
```
## Tehnike Detekcije

### Stacking Fajlova

Ako znate da je neka fascikla koja sadrži **fajlove** web servera **poslednji put ažurirana na neki datum**. **Proverite** **datum** kada su svi **fajlovi** na **web serveru** kreirani i modifikovani i ako je neki datum **sumnjiv**, proverite taj fajl.

### Osnovne Linije

Ako fajlovi u fascikli **ne bi trebali biti modifikovani**, možete izračunati **hash** **originalnih fajlova** iz fascikle i **uporediti** ih sa **trenutnim**. Sve što je modifikovano će biti **sumnjivo**.

### Statistička Analiza

Kada su informacije sačuvane u logovima, možete **proveriti statistiku kao što je koliko puta je svaki fajl web servera bio pristupljen, jer bi web shell mogao biti jedan od naj**.

---

## Deobfuskacija Dinamičkog Kontrolnog Tok (JMP/CALL RAX Dispečeri)

Moderne porodice malvera snažno zloupotrebljavaju obfuskaciju Kontrolnog Toka (CFG): umesto direktnog skakanja/pozivanja, izračunavaju odredište u vreme izvođenja i izvršavaju `jmp rax` ili `call rax`. Mali *dispečer* (obično devet instrukcija) postavlja konačni cilj u zavisnosti od CPU `ZF`/`CF` flagova, potpuno razbijajući statičku CFG obnovu.

Tehnika – prikazana od strane SLOW#TEMPEST loader-a – može biti savladana trostepenim radnim tokom koji se oslanja samo na IDAPython i Unicorn CPU emulator.

### 1. Pronađite svaki indirektni skok / poziv
```python
import idautils, idc

for ea in idautils.FunctionItems(idc.here()):
mnem = idc.print_insn_mnem(ea)
if mnem in ("jmp", "call") and idc.print_operand(ea, 0) == "rax":
print(f"[+] Dispatcher found @ {ea:X}")
```
### 2. Izvucite dispatcher byte-code
```python
import idc

def get_dispatcher_start(jmp_ea, count=9):
s = jmp_ea
for _ in range(count):
s = idc.prev_head(s, 0)
return s

start = get_dispatcher_start(jmp_ea)
size  = jmp_ea + idc.get_item_size(jmp_ea) - start
code  = idc.get_bytes(start, size)
open(f"{start:X}.bin", "wb").write(code)
```
### 3. Emulirajte ga dva puta sa Unicorn
```python
from unicorn import *
from unicorn.x86_const import *
import struct

def run(code, zf=0, cf=0):
BASE = 0x1000
mu = Uc(UC_ARCH_X86, UC_MODE_64)
mu.mem_map(BASE, 0x1000)
mu.mem_write(BASE, code)
mu.reg_write(UC_X86_REG_RFLAGS, (zf << 6) | cf)
mu.reg_write(UC_X86_REG_RAX, 0)
mu.emu_start(BASE, BASE+len(code))
return mu.reg_read(UC_X86_REG_RAX)
```
Pokrenite `run(code,0,0)` i `run(code,1,1)` da dobijete ciljeve *false* i *true* grana.

### 4. Ponovo patch-ujte direktan skok / poziv
```python
import struct, ida_bytes

def patch_direct(ea, target, is_call=False):
op   = 0xE8 if is_call else 0xE9           # CALL rel32 or JMP rel32
disp = target - (ea + 5) & 0xFFFFFFFF
ida_bytes.patch_bytes(ea, bytes([op]) + struct.pack('<I', disp))
```
Након закрпљивања, натерајте IDA да поново анализира функцију како би се вратили комплетан CFG и Hex-Rays излаз:
```python
import ida_auto, idaapi
idaapi.reanalyze_function(idc.get_func_attr(ea, idc.FUNCATTR_START))
```
### 5. Obeležite indirektne API pozive

Kada je stvarna destinacija svakog `call rax` poznata, možete reći IDA šta je to kako bi se tipovi parametara i imena promenljivih automatski povratili:
```python
idc.set_callee_name(call_ea, resolved_addr, 0)  # IDA 8.3+
```
### Praktične koristi

* Obnavlja pravi CFG → dekompilacija ide od *10* linija do hiljada.
* Omogućava pretragu stringova i xrefs, čineći rekonstrukciju ponašanja trivijalnom.
* Skripte su ponovo upotrebljive: ubacite ih u bilo koji loader zaštićen istim trikovima.

---

## Reference

- [Unit42 – Evolving Tactics of SLOW#TEMPEST: A Deep Dive Into Advanced Malware Techniques](https://unit42.paloaltonetworks.com/slow-tempest-malware-obfuscation/)

{{#include ../../banners/hacktricks-training.md}}
