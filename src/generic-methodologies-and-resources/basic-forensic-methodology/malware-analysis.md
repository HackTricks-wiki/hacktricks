# Malware Analysis

{{#include ../../banners/hacktricks-training.md}}

## Forensics CheatSheets

[https://www.jaiminton.com/cheatsheet/DFIR/#](https://www.jaiminton.com/cheatsheet/DFIR/)

## Usługi online

- [VirusTotal](https://www.virustotal.com/gui/home/upload)
- [HybridAnalysis](https://www.hybrid-analysis.com)
- [Koodous](https://koodous.com)
- [Intezer](https://analyze.intezer.com)
- [Any.Run](https://any.run/)

## Offline — narzędzia antywirusowe i wykrywania

### Yara

#### Instalacja
```bash
sudo apt-get install -y yara
```
#### Przygotuj reguły

Użyj tego skryptu, aby pobrać i scalić wszystkie reguły yara dotyczące malware z GitHub: [https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9](https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9)\
Utwórz katalog _**rules**_ i uruchom go. Spowoduje to utworzenie pliku o nazwie _**malware_rules.yar**_, który zawiera wszystkie reguły yara dla malware.
```bash
wget https://gist.githubusercontent.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9/raw/4ec711d37f1b428b63bed1f786b26a0654aa2f31/malware_yara_rules.py
mkdir rules
python malware_yara_rules.py
```
#### Skanowanie
```bash
yara -w malware_rules.yar image  #Scan 1 file
yara -w malware_rules.yar folder #Scan the whole folder
```
#### YaraGen: Sprawdź malware i twórz yara rules

Możesz użyć narzędzia [**YaraGen**](https://github.com/Neo23x0/yarGen) aby wygenerować yara rules z pliku binarnego. Zobacz te samouczki: [**Part 1**](https://www.nextron-systems.com/2015/02/16/write-simple-sound-yara-rules/), [**Part 2**](https://www.nextron-systems.com/2015/10/17/how-to-write-simple-but-sound-yara-rules-part-2/), [**Part 3**](https://www.nextron-systems.com/2016/04/15/how-to-write-simple-but-sound-yara-rules-part-3/)
```bash
python3 yarGen.py --update
python3.exe yarGen.py --excludegood -m  ../../mals/
```
### ClamAV

#### Instalacja
```
sudo apt-get install -y clamav
```
#### Skanowanie
```bash
sudo freshclam      #Update rules
clamscan filepath   #Scan 1 file
clamscan folderpath #Scan the whole folder
```
### [Capa](https://github.com/mandiant/capa)

**Capa** wykrywa potencjalnie złośliwe **możliwości** w plikach wykonywalnych: PE, ELF, .NET. Dzięki temu znajdzie rzeczy takie jak Att\&ck tactics, albo podejrzane możliwości takie jak:

- sprawdzenie błędu OutputDebugString
- run as a service
- create process

Pobierz go w [**Github repo**](https://github.com/mandiant/capa).

### IOCs

IOC oznacza Indicator Of Compromise. IOC to zestaw **warunków, które identyfikują** potencjalnie niechciane oprogramowanie lub potwierdzone **malware**. Blue Teams używają tego rodzaju definicji, aby **wyszukiwać tego typu złośliwe pliki** w swoich **systemach** i **sieciach**.\
Współdzielenie tych definicji jest bardzo przydatne — gdy malware zostanie zidentyfikowane na komputerze i utworzony zostanie IOC dla tego malware, inne Blue Teams mogą użyć go do szybszej identyfikacji zagrożenia.

Narzędziem do tworzenia lub modyfikowania IOCs jest [**IOC Editor**](https://www.fireeye.com/services/freeware/ioc-editor.html)**.**\
Możesz użyć narzędzi takich jak [**Redline**](https://www.fireeye.com/services/freeware/redline.html) aby **wyszukać zdefiniowane IOC na urządzeniu**.

### Loki

[**Loki**](https://github.com/Neo23x0/Loki) to skaner dla Simple Indicators of Compromise.\
Wykrywanie opiera się na czterech metodach detekcji:
```
1. File Name IOC
Regex match on full file path/name

2. Yara Rule Check
Yara signature matches on file data and process memory

3. Hash Check
Compares known malicious hashes (MD5, SHA1, SHA256) with scanned files

4. C2 Back Connect Check
Compares process connection endpoints with C2 IOCs (new since version v.10)
```
### Linux Malware Detect

[**Linux Malware Detect (LMD)**](https://www.rfxn.com/projects/linux-malware-detect/) to skaner malware dla Linuxa wydany na licencji GNU GPLv2, zaprojektowany z myślą o zagrożeniach występujących w środowiskach hostingu współdzielonego. Wykorzystuje dane o zagrożeniach z systemów IDS na krawędzi sieci do ekstrakcji malware, które są aktywnie wykorzystywane w atakach, i generuje sygnatury do wykrywania. Dodatkowo dane o zagrożeniach pochodzą także ze zgłoszeń użytkowników za pomocą LMD checkout feature oraz z malware community resources.

### rkhunter

Narzędzia takie jak [**rkhunter**](http://rkhunter.sourceforge.net) można użyć do sprawdzenia systemu plików w poszukiwaniu możliwych **rootkits** i malware.
```bash
sudo ./rkhunter --check -r / -l /tmp/rkhunter.log [--report-warnings-only] [--skip-keypress]
```
### FLOSS

[**FLOSS**](https://github.com/mandiant/flare-floss) jest narzędziem, które spróbuje znaleźć **obfuscated strings** wewnątrz **executables** używając różnych technik.

### PEpper

[PEpper ](https://github.com/Th3Hurrican3/PEpper)sprawdza podstawowe rzeczy w **executable** (binary data, entropy, URLs and IPs, some yara rules).

### PEstudio

[PEstudio](https://www.winitor.com/download) to narzędzie pozwalające uzyskać informacje o Windows **executables** takich jak imports, exports, headers, ale także sprawdzi virus total i znajdzie potencjalne Att\&ck techniques.

### Detect It Easy(DiE)

[**DiE**](https://github.com/horsicq/Detect-It-Easy/) to narzędzie do wykrywania, czy plik jest **encrypted** oraz do znajdowania **packers**.

### NeoPI

[**NeoPI** ](https://github.com/CiscoCXSecurity/NeoPI)is skrypt w Pythonie, który używa różnych **statistical methods** do wykrywania **obfuscated** i **encrypted** treści w plikach tekstowych/skryptach. Celem NeoPI jest pomoc w **detection of hidden web shell code**.

### **php-malware-finder**

[**PHP-malware-finder**](https://github.com/nbs-system/php-malware-finder) stara się jak najlepiej wykryć **obfuscated**/**dodgy code**, a także pliki używające funkcji **PHP** często stosowanych w **malwares**/webshells.

### Apple Binary Signatures

Przy sprawdzaniu jakiegoś **malware sample** zawsze powinieneś **check the signature** binarnego pliku, ponieważ **developer**, który go podpisał, może być już **related** z **malware.**
```bash
#Get signer
codesign -vv -d /bin/ls 2>&1 | grep -E "Authority|TeamIdentifier"

#Check if the app’s contents have been modified
codesign --verify --verbose /Applications/Safari.app

#Check if the signature is valid
spctl --assess --verbose /Applications/Safari.app
```
## Techniki wykrywania

### File Stacking

Jeśli wiesz, że jakiś folder zawierający **pliki** serwera WWW został **ostatnio zaktualizowany w określonym terminie**. **Sprawdź** **daty** utworzenia i modyfikacji wszystkich **plików** na **serwerze WWW** i jeśli jakaś data jest **podejrzana**, sprawdź ten plik.

### Linia bazowa

Jeśli pliki w folderze **nie powinny były być modyfikowane**, możesz policzyć **hash** **oryginalnych plików** folderu i **porównać** je z **aktualnymi**. Wszystko, co zostało zmodyfikowane, będzie **podejrzane**.

### Analiza statystyczna

Gdy informacje są zapisywane w logach, możesz **sprawdzić statystyki**, np. ile razy każdy plik serwera WWW był dostępny — web shell może być jednym z najczęściej występujących.

---

### Natywna telemetryka in-app na Androidzie (no root)

Na Androidzie możesz instrumentować kod natywny wewnątrz procesu docelowej aplikacji, preloadując małą bibliotekę loggera przed zainicjalizowaniem innych bibliotek JNI. Daje to wczesną widoczność zachowania natywnego bez hooków systemowych czy roota. Popularne podejście to SoTap: wrzuć libsotap.so dla właściwego ABI do APK i wstrzyknij wywołanie System.loadLibrary("sotap") wcześnie (np. static initializer lub Application.onCreate), następnie zbieraj logi ze ścieżek wewnętrznych/zewnętrznych lub jako fallback Logcat.

Zobacz stronę Android native reversing po szczegóły konfiguracji i ścieżki logów:

{{#ref}}
../../mobile-pentesting/android-app-pentesting/reversing-native-libraries.md
{{#endref}}

---

## Deobfuskacja dynamicznego przepływu sterowania (JMP/CALL RAX Dispatchers)

Nowoczesne rodziny malware intensywnie nadużywają obfuskacji Control-Flow Graph (CFG): zamiast bezpośredniego jump/call obliczają cel w czasie wykonania i wykonują `jmp rax` lub `call rax`. Mały *dispatcher* (zwykle dziewięć instrukcji) ustawia końcowy target w zależności od flag CPU `ZF`/`CF`, całkowicie łamiąc statyczne odzyskiwanie CFG.

Technika — pokazana przez loader SLOW#TEMPEST — może zostać pokonana za pomocą trzyetapowego procesu, który opiera się wyłącznie na IDAPython i emulatorze CPU Unicorn.

### 1. Zlokalizuj każdy pośredni jump / call
```python
import idautils, idc

for ea in idautils.FunctionItems(idc.here()):
mnem = idc.print_insn_mnem(ea)
if mnem in ("jmp", "call") and idc.print_operand(ea, 0) == "rax":
print(f"[+] Dispatcher found @ {ea:X}")
```
### 2. Wyodrębnij dispatcher byte-code
```python
import idc

def get_dispatcher_start(jmp_ea, count=9):
s = jmp_ea
for _ in range(count):
s = idc.prev_head(s, 0)
return s

start = get_dispatcher_start(jmp_ea)
size  = jmp_ea + idc.get_item_size(jmp_ea) - start
code  = idc.get_bytes(start, size)
open(f"{start:X}.bin", "wb").write(code)
```
### 3. Emuluj to dwukrotnie przy użyciu Unicorn
```python
from unicorn import *
from unicorn.x86_const import *
import struct

def run(code, zf=0, cf=0):
BASE = 0x1000
mu = Uc(UC_ARCH_X86, UC_MODE_64)
mu.mem_map(BASE, 0x1000)
mu.mem_write(BASE, code)
mu.reg_write(UC_X86_REG_RFLAGS, (zf << 6) | cf)
mu.reg_write(UC_X86_REG_RAX, 0)
mu.emu_start(BASE, BASE+len(code))
return mu.reg_read(UC_X86_REG_RAX)
```
Uruchom `run(code,0,0)` i `run(code,1,1)`, aby uzyskać cele gałęzi *false* i *true*.

### 4. Przywrócenie bezpośredniego skoku / wywołania
```python
import struct, ida_bytes

def patch_direct(ea, target, is_call=False):
op   = 0xE8 if is_call else 0xE9           # CALL rel32 or JMP rel32
disp = target - (ea + 5) & 0xFFFFFFFF
ida_bytes.patch_bytes(ea, bytes([op]) + struct.pack('<I', disp))
```
Po patching, wymuś w IDA ponowną analizę funkcji, aby przywrócić pełny CFG i Hex-Rays output:
```python
import ida_auto, idaapi
idaapi.reanalyze_function(idc.get_func_attr(ea, idc.FUNCATTR_START))
```
### 5. Oznacz pośrednie wywołania API

Gdy znane jest rzeczywiste przeznaczenie każdego `call rax`, możesz powiedzieć IDA, czym ono jest, aby typy parametrów & nazwy zmiennych zostały odzyskane automatycznie:
```python
idc.set_callee_name(call_ea, resolved_addr, 0)  # IDA 8.3+
```
### Praktyczne korzyści

* Przywraca prawdziwy CFG → dekompilacja zmienia się z *10* linii do tysięcy.
* Umożliwia string-cross-reference & xrefs, co czyni rekonstrukcję zachowania trywialną.
* Skrypty są wielokrotnego użytku: umieść je w dowolnym loaderze chronionym tą samą sztuczką.

---

## AdaptixC2: Ekstrakcja konfiguracji i TTPs

Zobacz dedykowaną stronę:

{{#ref}}
adaptixc2-config-extraction-and-ttps.md
{{#endref}}

## Źródła

- [Unit42 – Evolving Tactics of SLOW#TEMPEST: A Deep Dive Into Advanced Malware Techniques](https://unit42.paloaltonetworks.com/slow-tempest-malware-obfuscation/)
- SoTap: Lightweight in-app JNI (.so) behavior logger – [github.com/RezaArbabBot/SoTap](https://github.com/RezaArbabBot/SoTap)
- [Unit42 – AdaptixC2: A New Open-Source Framework Leveraged in Real-World Attacks](https://unit42.paloaltonetworks.com/adaptixc2-post-exploitation-framework/)

{{#include ../../banners/hacktricks-training.md}}
