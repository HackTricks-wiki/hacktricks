# Malware Analizi

{{#include ../../banners/hacktricks-training.md}}

## Adli Bilişim CheatSheet'leri

[https://www.jaiminton.com/cheatsheet/DFIR/#](https://www.jaiminton.com/cheatsheet/DFIR/)

## Çevrimiçi Servisler

- [VirusTotal](https://www.virustotal.com/gui/home/upload)
- [HybridAnalysis](https://www.hybrid-analysis.com)
- [Koodous](https://koodous.com)
- [Intezer](https://analyze.intezer.com)
- [Any.Run](https://any.run/)

## Çevrimdışı Antivirus ve Tespit Araçları

### Yara

#### Kurulum
```bash
sudo apt-get install -y yara
```
#### Kuralları hazırla

Bu script'i kullanarak github'dan tüm yara malware kurallarını indirip birleştirin: [https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9](https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9)\
Create the _**rules**_ directory and execute it. This will create a file called _**malware_rules.yar**_ which contains all the yara rules for malware.
```bash
wget https://gist.githubusercontent.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9/raw/4ec711d37f1b428b63bed1f786b26a0654aa2f31/malware_yara_rules.py
mkdir rules
python malware_yara_rules.py
```
#### Tarama
```bash
yara -w malware_rules.yar image  #Scan 1 file
yara -w malware_rules.yar folder #Scan the whole folder
```
#### YaraGen: malware kontrolü ve kurallar oluşturma

Bir binary'den yara rules oluşturmak için [**YaraGen**](https://github.com/Neo23x0/yarGen) aracını kullanabilirsiniz. Bu eğitimlere göz atın: [**Part 1**](https://www.nextron-systems.com/2015/02/16/write-simple-sound-yara-rules/), [**Part 2**](https://www.nextron-systems.com/2015/10/17/how-to-write-simple-but-sound-yara-rules-part-2/), [**Part 3**](https://www.nextron-systems.com/2016/04/15/how-to-write-simple-but-sound-yara-rules-part-3/)
```bash
python3 yarGen.py --update
python3.exe yarGen.py --excludegood -m  ../../mals/
```
### ClamAV

#### Kurulum
```
sudo apt-get install -y clamav
```
#### Tarama
```bash
sudo freshclam      #Update rules
clamscan filepath   #Scan 1 file
clamscan folderpath #Scan the whole folder
```
### [Capa](https://github.com/mandiant/capa)

**Capa** PE, ELF, .NET gibi çalıştırılabilirlerde potansiyel olarak kötü amaçlı **capabilities** tespit eder. Bu nedenle Att\&ck taktikleri veya şu tür şüpheli yetenekleri bulur:

- OutputDebugString hatasını kontrol etme
- servis olarak çalıştırma
- process oluşturma

Edinin: [**Github repo**](https://github.com/mandiant/capa).

### IOCs

IOC, Indicator Of Compromise anlamına gelir. IOC, potansiyel olarak istenmeyen yazılımları veya doğrulanmış **malware**'i **tanımlayan koşulların** bir kümesidir. Blue Teams bu tür tanımları kendi **sistemlerinde** ve **ağlarında** bu tür kötü amaçlı dosyaları **aramak** için kullanır.\
Bu tanımları paylaşmak çok faydalıdır; çünkü bir bilgisayarda malware tespit edildiğinde ve o malware için bir IOC oluşturulduğunda, diğer Blue Teams bunu kullanarak malware'i daha hızlı tespit edebilir.

IOC oluşturmak veya değiştirmek için bir araç [**IOC Editor**](https://www.fireeye.com/services/freeware/ioc-editor.html).\
[**Redline**](https://www.fireeye.com/services/freeware/redline.html) gibi araçları kullanarak **bir cihazda tanımlanmış IOC'leri arayabilirsiniz**.

### Loki

[**Loki**](https://github.com/Neo23x0/Loki) Simple Indicators of Compromise için bir tarayıcıdır.\
Tespit, dört algılama yöntemine dayanır:
```
1. File Name IOC
Regex match on full file path/name

2. Yara Rule Check
Yara signature matches on file data and process memory

3. Hash Check
Compares known malicious hashes (MD5, SHA1, SHA256) with scanned files

4. C2 Back Connect Check
Compares process connection endpoints with C2 IOCs (new since version v.10)
```
### Linux Malware Detect

[**Linux Malware Detect (LMD)**](https://www.rfxn.com/projects/linux-malware-detect/) Linux için GNU GPLv2 lisansı altında yayımlanmış bir malware tarayıcısıdır; paylaşılan barındırma ortamlarında karşılaşılan tehditler göz önünde bulundurularak tasarlanmıştır. Ağ kenarında bulunan intrusion detection systems'ten gelen tehdit verilerini kullanarak saldırılarda aktif olarak kullanılan malware'leri tespit eder ve tespit için imzalar oluşturur. Ayrıca tehdit verileri, LMD'nin checkout özelliğiyle yapılan kullanıcı gönderimlerinden ve malware topluluk kaynaklarından da elde edilir.

### rkhunter

[**rkhunter**](http://rkhunter.sourceforge.net) gibi araçlar, olası **rootkits** ve malware için dosya sistemini kontrol etmek amacıyla kullanılabilir.
```bash
sudo ./rkhunter --check -r / -l /tmp/rkhunter.log [--report-warnings-only] [--skip-keypress]
```
### FLOSS

[**FLOSS**](https://github.com/mandiant/flare-floss) farklı teknikler kullanarak yürütülebilir dosyaların içinde obfuscated strings bulmaya çalışacak bir araçtır.

### PEpper

[PEpper ](https://github.com/Th3Hurrican3/PEpper) yürütülebilir dosya içinde bazı temel şeyleri kontrol eder (binary data, entropy, URLs and IPs, some yara rules).

### PEstudio

[PEstudio](https://www.winitor.com/download) imports, exports, headers gibi Windows yürütülebilirleriyle ilgili bilgiler almayı sağlayan bir araçtır; ayrıca virus total'u kontrol eder ve potansiyel Att\&ck tekniklerini bulur.

### Detect It Easy(DiE)

[**DiE**](https://github.com/horsicq/Detect-It-Easy/) bir dosyanın **encrypted** olup olmadığını tespit etmek ve ayrıca **packers** bulmak için bir araçtır.

### NeoPI

[**NeoPI** ](https://github.com/CiscoCXSecurity/NeoPI) metin/script dosyaları içinde **obfuscated** ve **encrypted** içeriği tespit etmek için çeşitli **statistical methods** kullanan bir Python scriptidir. NeoPI'nin amacı, **gizli web shell kodunun tespitine** yardımcı olmaktır.

### **php-malware-finder**

[**PHP-malware-finder**](https://github.com/nbs-system/php-malware-finder) **obfuscated**/**dodgy code** ve **malwares**/webshell'lerde sık kullanılan **PHP** fonksiyonlarını kullanan dosyaları tespit etmek için elinden geleni yapar.

### Apple Binary Signatures

Bir **malware sample** incelerken, ikili dosyanın **check the signature**'ını her zaman yapmalısınız; imzalayan **developer** zaten **related** with **malware** olabilir.
```bash
#Get signer
codesign -vv -d /bin/ls 2>&1 | grep -E "Authority|TeamIdentifier"

#Check if the app’s contents have been modified
codesign --verify --verbose /Applications/Safari.app

#Check if the signature is valid
spctl --assess --verbose /Applications/Safari.app
```
## Tespit Teknikleri

### File Stacking

Eğer bir klasörün, web server'ın **dosyalarını** içerdiğini ve **son olarak belirli bir tarihte** güncellendiğini biliyorsanız, web server'daki tüm **dosyaların** oluşturulma ve değiştirilme **tarihlerini** **kontrol edin**; eğer herhangi bir tarih **şüpheli** ise o dosyayı inceleyin.

### Baselines

Bir klasörün dosyaları **değiştirilmemiş olması gerekiyorsa**, klasörün **orijinal dosyalarının** **hash**'ini hesaplayıp bunları **şimdiki** dosyalarla **karşılaştırabilirsiniz**. Değiştirilmiş olan her şey **şüpheli** olacaktır.

### Statistical Analysis

Bilgiler log'larda saklanıyorsa, örneğin her bir web server dosyasının kaç kez erişildiği gibi istatistikleri **kontrol edebilirsiniz**, çünkü bir web shell en çok erişilenlerden biri olabilir.

---

### Android in-app native telemetry (no root)

Android üzerinde, hedef uygulama süreci içinde diğer JNI kütüphaneleri initialize olmadan önce küçük bir logger kütüphanesini önceden yükleyerek native kodu enstrümante edebilirsiniz. Bu, sistem çapı hook veya root gerektirmeden native davranış hakkında erken görünürlük sağlar. Yaygın bir yaklaşım SoTap: uygun ABI için libsotap.so'yu APK'ya bırakıp erken bir noktaya System.loadLibrary("sotap") çağrısı enjekte etmek (ör. static initializer veya Application.onCreate), ardından logları internal/external yollarından veya Logcat fallback ile toplamak.

See the Android native reversing page for setup details and log paths:

{{#ref}}
../../mobile-pentesting/android-app-pentesting/reversing-native-libraries.md
{{#endref}}

---

## Deobfuscating Dynamic Control-Flow (JMP/CALL RAX Dispatchers)

Modern malware aileleri Control-Flow Graph (CFG) obfuscation'ı yoğun şekilde kötüye kullanıyor: doğrudan bir jump/call yerine hedefi çalışma zamanında hesaplayıp `jmp rax` veya `call rax` yürütüyorlar. Küçük bir *dispatcher* (genellikle dokuz talimat) CPU `ZF`/`CF` flag'lerine bağlı olarak nihai hedefi ayarlar ve bu, statik CFG kurtarmayı tamamen bozar.

The technique – showcased by the SLOW#TEMPEST loader – can be defeated with a three-step workflow that only relies on IDAPython and the Unicorn CPU emulator.

### 1. Locate every indirect jump / call
```python
import idautils, idc

for ea in idautils.FunctionItems(idc.here()):
mnem = idc.print_insn_mnem(ea)
if mnem in ("jmp", "call") and idc.print_operand(ea, 0) == "rax":
print(f"[+] Dispatcher found @ {ea:X}")
```
### 2. dispatcher byte-code'u çıkarın
```python
import idc

def get_dispatcher_start(jmp_ea, count=9):
s = jmp_ea
for _ in range(count):
s = idc.prev_head(s, 0)
return s

start = get_dispatcher_start(jmp_ea)
size  = jmp_ea + idc.get_item_size(jmp_ea) - start
code  = idc.get_bytes(start, size)
open(f"{start:X}.bin", "wb").write(code)
```
### 3. Unicorn ile iki kez emüle et
```python
from unicorn import *
from unicorn.x86_const import *
import struct

def run(code, zf=0, cf=0):
BASE = 0x1000
mu = Uc(UC_ARCH_X86, UC_MODE_64)
mu.mem_map(BASE, 0x1000)
mu.mem_write(BASE, code)
mu.reg_write(UC_X86_REG_RFLAGS, (zf << 6) | cf)
mu.reg_write(UC_X86_REG_RAX, 0)
mu.emu_start(BASE, BASE+len(code))
return mu.reg_read(UC_X86_REG_RAX)
```
`run(code,0,0)` ve `run(code,1,1)` komutlarını çalıştırarak *false* ve *true* dallanma hedeflerini elde edin.

### 4. Doğrudan jump / call'ı geri yama
```python
import struct, ida_bytes

def patch_direct(ea, target, is_call=False):
op   = 0xE8 if is_call else 0xE9           # CALL rel32 or JMP rel32
disp = target - (ea + 5) & 0xFFFFFFFF
ida_bytes.patch_bytes(ea, bytes([op]) + struct.pack('<I', disp))
```
After patching, IDA'nın fonksiyonu yeniden analiz etmesini zorlayın, böylece tam CFG ve Hex-Rays çıktıları geri yüklenir:
```python
import ida_auto, idaapi
idaapi.reanalyze_function(idc.get_func_attr(ea, idc.FUNCATTR_START))
```
### 5. Dolaylı API çağrılarını etiketleyin

Her `call rax` için gerçek hedef belirlendiğinde, IDA'ya bunun ne olduğunu söyleyebilirsiniz; böylece parametre türleri & değişken adları otomatik olarak belirlenir:
```python
idc.set_callee_name(call_ea, resolved_addr, 0)  # IDA 8.3+
```
### Pratik faydalar

* Gerçek CFG'yi geri yükler → decompilation *10* satırdan binlerce satıra çıkar.
* string-cross-reference & xrefs'i etkinleştirir, bu da davranışın yeniden oluşturulmasını çok kolay hale getirir.
* Scripts yeniden kullanılabilir: aynı yöntemle korunmuş herhangi bir loader'ın içine koyun.

---

## AdaptixC2: Configuration Extraction and TTPs

Ayrı sayfaya bakın:

{{#ref}}
adaptixc2-config-extraction-and-ttps.md
{{#endref}}

## Kaynaklar

- [Unit42 – Evolving Tactics of SLOW#TEMPEST: A Deep Dive Into Advanced Malware Techniques](https://unit42.paloaltonetworks.com/slow-tempest-malware-obfuscation/)
- SoTap: Lightweight in-app JNI (.so) behavior logger – [github.com/RezaArbabBot/SoTap](https://github.com/RezaArbabBot/SoTap)
- [Unit42 – AdaptixC2: A New Open-Source Framework Leveraged in Real-World Attacks](https://unit42.paloaltonetworks.com/adaptixc2-post-exploitation-framework/)

{{#include ../../banners/hacktricks-training.md}}
