# Malware Analysis

{{#include ../../banners/hacktricks-training.md}}

## Forensiek CheatSheets

[https://www.jaiminton.com/cheatsheet/DFIR/#](https://www.jaiminton.com/cheatsheet/DFIR/)

## Aanlyn Dienste

- [VirusTotal](https://www.virustotal.com/gui/home/upload)
- [HybridAnalysis](https://www.hybrid-analysis.com)
- [Koodous](https://koodous.com)
- [Intezer](https://analyze.intezer.com)
- [Any.Run](https://any.run/)

## Offline Antivirus en Opsporingstools

### Yara

#### Installeer
```bash
sudo apt-get install -y yara
```
#### Berei reëls voor

Gebruik hierdie skrip om al die yara malware-reëls van github af te laai en saam te voeg: [https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9](https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9)\
Skep die _**rules**_ gids en voer dit uit. Dit sal 'n lêer genaamd _**malware_rules.yar**_ skep wat al die yara-reëls vir malware bevat.
```bash
wget https://gist.githubusercontent.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9/raw/4ec711d37f1b428b63bed1f786b26a0654aa2f31/malware_yara_rules.py
mkdir rules
python malware_yara_rules.py
```
#### Skandering
```bash
yara -w malware_rules.yar image  #Scan 1 file
yara -w malware_rules.yar folder #Scan the whole folder
```
#### YaraGen: Kontroleer vir malware en Skep reëls

Jy kan die hulpmiddel [**YaraGen**](https://github.com/Neo23x0/yarGen) gebruik om yara rules van 'n binary te genereer. Kyk na hierdie handleidings: [**Part 1**](https://www.nextron-systems.com/2015/02/16/write-simple-sound-yara-rules/), [**Part 2**](https://www.nextron-systems.com/2015/10/17/how-to-write-simple-but-sound-yara-rules-part-2/), [**Part 3**](https://www.nextron-systems.com/2016/04/15/how-to-write-simple-but-sound-yara-rules-part-3/)
```bash
python3 yarGen.py --update
python3.exe yarGen.py --excludegood -m  ../../mals/
```
### ClamAV

#### Installeer
```
sudo apt-get install -y clamav
```
#### Skandering
```bash
sudo freshclam      #Update rules
clamscan filepath   #Scan 1 file
clamscan folderpath #Scan the whole folder
```
### [Capa](https://github.com/mandiant/capa)

**Capa** identifiseer potensieel kwaadwillige **capabilities** in uitvoerbare lêers: PE, ELF, .NET. Dit sal dus dinge vind soos Att\&ck tactics, of verdagte capabilities soos:

- check for OutputDebugString error
- run as a service
- create process

Kry dit in die [**Github repo**](https://github.com/mandiant/capa).

### IOCs

IOC beteken Aanwyser van Kompromittering. 'n IOC is 'n stel **voorwaardes wat identifiseer** sommige moontlik ongewenste sagteware of bevestigde **malware**. Blue Teams gebruik hierdie soort definisie om **na hierdie soort kwaadwillige lêers te soek** in hul **stelsels** en **netwerke**.\
Om hierdie definisies te deel is baie nuttig, want as malware in 'n rekenaar geïdentifiseer word en 'n IOC vir daardie malware geskep word, kan ander Blue Teams dit gebruik om die malware vinniger te identifiseer.

'n hulpmiddel om IOCs te skep of te wysig is [**IOC Editor**](https://www.fireeye.com/services/freeware/ioc-editor.html)**.**\
Jy kan gereedskap soos [**Redline**](https://www.fireeye.com/services/freeware/redline.html) gebruik om **vir gedefinieerde IOCs in 'n toestel te soek**.

### Loki

[**Loki**](https://github.com/Neo23x0/Loki) is 'n skandeerder vir eenvoudige Aanwysers van Kompromittering.\
Opsporing is gebaseer op vier opsporingsmetodes:
```
1. File Name IOC
Regex match on full file path/name

2. Yara Rule Check
Yara signature matches on file data and process memory

3. Hash Check
Compares known malicious hashes (MD5, SHA1, SHA256) with scanned files

4. C2 Back Connect Check
Compares process connection endpoints with C2 IOCs (new since version v.10)
```
### Linux Malware Detect

[**Linux Malware Detect (LMD)**](https://www.rfxn.com/projects/linux-malware-detect/) is 'n malware-skandeerder vir Linux wat vrygestel is onder die GNU GPLv2-lisensie, en ontwerp is rondom die bedreigings wat in gedeelde gehoste omgewings voorkom. Dit gebruik bedreigingsdata van netwerkrand intrusion detection systems om malware wat aktief in aanvalle gebruik word uit te trek en signatures te genereer vir opsporing. Daarbenewens word bedreigingsdata ook verkry uit gebruikersinskrywings met die LMD checkout-funksie en malware-gemeenskapsbronne.

### rkhunter

Gereedskap soos [**rkhunter**](http://rkhunter.sourceforge.net) kan gebruik word om die lêerstelsel na moontlike **rootkits** en malware na te gaan.
```bash
sudo ./rkhunter --check -r / -l /tmp/rkhunter.log [--report-warnings-only] [--skip-keypress]
```
### FLOSS

[**FLOSS**](https://github.com/mandiant/flare-floss) is 'n hulpmiddel wat probeer om obfuscated strings binne uitvoerbare lêers te vind deur verskeie tegnieke te gebruik.

### PEpper

[PEpper ](https://github.com/Th3Hurrican3/PEpper) kontroleer 'n paar basiese dinge in die uitvoerbare lêer (binary data, entropy, URLs and IPs, some yara rules).

### PEstudio

[PEstudio](https://www.winitor.com/download) is 'n hulpmiddel wat inligting oor Windows-uitvoerbare lêers verskaf soos imports, exports, headers, maar sal ook virus total kontroleer en moontlike Att\&ck techniques vind.

### Detect It Easy(DiE)

[**DiE**](https://github.com/horsicq/Detect-It-Easy/) is 'n hulpmiddel om te bepaal of 'n lêer encrypted is en ook packers te vind.

### NeoPI

[**NeoPI** ](https://github.com/CiscoCXSecurity/NeoPI) is 'n Python-skrip wat 'n verskeidenheid statistical methods gebruik om obfuscated en encrypted inhoud binne teks-/scriptlêers te detecteer. Die beoogde doel van NeoPI is om te help met die detection of hidden web shell code.

### **php-malware-finder**

[**PHP-malware-finder**](https://github.com/nbs-system/php-malware-finder) doen sy uiterste bes om obfuscated/dodgy code op te spoor, sowel as lêers wat PHP-funksies gebruik wat dikwels in malwares/webshells gebruik word.

### Apple Binary Signatures

Wanneer jy 'n malware sample nagaan, moet jy altyd die signature van die binary nagaan, aangesien die developer wat dit geteken het dalk reeds met malware in verband staan.
```bash
#Get signer
codesign -vv -d /bin/ls 2>&1 | grep -E "Authority|TeamIdentifier"

#Check if the app’s contents have been modified
codesign --verify --verbose /Applications/Safari.app

#Check if the signature is valid
spctl --assess --verbose /Applications/Safari.app
```
## Opsporingstegnieke

### File Stacking

Indien jy weet dat 'n gids wat die **files** van 'n **web server** bevat op 'n bepaalde **datum** laas bygewerk is, **kontroleer** die **datum** waarop al die **files** in die **web server** geskep en gewysig is; as enige datum **verdag** is, ondersoek daardie file.

### Baselines

As die **files** van 'n gids **nie moes verander het nie**, kan jy die **hash** van die **original files** van die gids bereken en dit met die **current** vergelyk. Alles wat gewysig is sal **verdag** wees.

### Statistical Analysis

Wanneer die inligting in **logs** gestoor word, kan jy **statistieke** nagaan soos hoe dikwels elke **file** van 'n **web server** geraadpleeg is, aangesien 'n **web shell** moontlik een van die mees.

---

### Android in-app native telemetry (no root)

On Android, you can instrument native code inside the target app process by preloading a tiny logger library before other JNI libs initialize. This gives early visibility into native behavior without system-wide hooks or root. A popular approach is SoTap: drop libsotap.so for the right ABI into the APK and inject a System.loadLibrary("sotap") call early (e.g., static initializer or Application.onCreate), then collect logs from internal/external paths or Logcat fallback.

See the Android native reversing page for setup details and log paths:

{{#ref}}
../../mobile-pentesting/android-app-pentesting/reversing-native-libraries.md
{{#endref}}

---

## Deobfuscating Dynamic Control-Flow (JMP/CALL RAX Dispatchers)

Moderne malware families maak swaar gebruik van Control-Flow Graph (CFG) obfuscation: in plaas van 'n direkte jump/call bereken hulle die bestemming tydens run-time en voer `jmp rax` of `call rax` uit. 'n Klein *dispatcher* (gewoonlik nege instruksies) stel die finale teiken afhangende van die CPU `ZF`/`CF` vlagte, wat statiese CFG-herwinning heeltemal breek.

Die tegniek – gedemonstreer deur die SLOW#TEMPEST loader – kan gekeer word met 'n drie-stap workflow wat slegs op IDAPython en die Unicorn CPU emulator staatmaak.

### 1. Vind elke indirekte jump / call
```python
import idautils, idc

for ea in idautils.FunctionItems(idc.here()):
mnem = idc.print_insn_mnem(ea)
if mnem in ("jmp", "call") and idc.print_operand(ea, 0) == "rax":
print(f"[+] Dispatcher found @ {ea:X}")
```
### 2. Haal die dispatcher byte-code uit
```python
import idc

def get_dispatcher_start(jmp_ea, count=9):
s = jmp_ea
for _ in range(count):
s = idc.prev_head(s, 0)
return s

start = get_dispatcher_start(jmp_ea)
size  = jmp_ea + idc.get_item_size(jmp_ea) - start
code  = idc.get_bytes(start, size)
open(f"{start:X}.bin", "wb").write(code)
```
### 3. Emuleer dit twee keer met Unicorn
```python
from unicorn import *
from unicorn.x86_const import *
import struct

def run(code, zf=0, cf=0):
BASE = 0x1000
mu = Uc(UC_ARCH_X86, UC_MODE_64)
mu.mem_map(BASE, 0x1000)
mu.mem_write(BASE, code)
mu.reg_write(UC_X86_REG_RFLAGS, (zf << 6) | cf)
mu.reg_write(UC_X86_REG_RAX, 0)
mu.emu_start(BASE, BASE+len(code))
return mu.reg_read(UC_X86_REG_RAX)
```
Voer `run(code,0,0)` en `run(code,1,1)` uit om die *false* en *true* branch targets te verkry.

### 4. Patch 'n direkte jump / call terug
```python
import struct, ida_bytes

def patch_direct(ea, target, is_call=False):
op   = 0xE8 if is_call else 0xE9           # CALL rel32 or JMP rel32
disp = target - (ea + 5) & 0xFFFFFFFF
ida_bytes.patch_bytes(ea, bytes([op]) + struct.pack('<I', disp))
```
Na patching, dwing IDA om die funksie weer te heranaliseer sodat die volledige CFG en Hex-Rays output herstel word:
```python
import ida_auto, idaapi
idaapi.reanalyze_function(idc.get_func_attr(ea, idc.FUNCATTR_START))
```
### 5. Merk indirekte API-aanroepe

Sodra die werklike bestemming van elke `call rax` bekend is, kan jy IDA vertel wat dit is sodat parametertipes & veranderlike name outomaties herstel word:
```python
idc.set_callee_name(call_ea, resolved_addr, 0)  # IDA 8.3+
```
### Praktiese voordele

* Herstel die werklike CFG → decompilation gaan van *10* lyne na duisende.
* Maak string-cross-reference & xrefs moontlik, wat gedragsherbou triviaal maak.
* Skripte is herbruikbaar: plaas dit in enige loader wat deur dieselfde truuk beskerm word.

---

## AdaptixC2: Konfigurasie-onttrekking en TTPs

Sien die toegewyde bladsy:

{{#ref}}
adaptixc2-config-extraction-and-ttps.md
{{#endref}}

## Verwysings

- [Unit42 – Evolving Tactics of SLOW#TEMPEST: A Deep Dive Into Advanced Malware Techniques](https://unit42.paloaltonetworks.com/slow-tempest-malware-obfuscation/)
- SoTap: Lightweight in-app JNI (.so) behavior logger – [github.com/RezaArbabBot/SoTap](https://github.com/RezaArbabBot/SoTap)
- [Unit42 – AdaptixC2: A New Open-Source Framework Leveraged in Real-World Attacks](https://unit42.paloaltonetworks.com/adaptixc2-post-exploitation-framework/)

{{#include ../../banners/hacktricks-training.md}}
