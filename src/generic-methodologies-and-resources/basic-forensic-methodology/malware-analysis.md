# Аналіз шкідливого ПЗ

{{#include ../../banners/hacktricks-training.md}}

## Шпаргалки з форензики

[https://www.jaiminton.com/cheatsheet/DFIR/#](https://www.jaiminton.com/cheatsheet/DFIR/)

## Онлайн сервіси

- [VirusTotal](https://www.virustotal.com/gui/home/upload)
- [HybridAnalysis](https://www.hybrid-analysis.com)
- [Koodous](https://koodous.com)
- [Intezer](https://analyze.intezer.com)
- [Any.Run](https://any.run/)

## Офлайн антивірусні та засоби виявлення

### Yara

#### Встановлення
```bash
sudo apt-get install -y yara
```
#### Підготовка правил

Використайте цей скрипт, щоб завантажити та об'єднати всі yara malware rules з github: [https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9](https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9)\
Створіть директорію _**rules**_ та виконайте скрипт. Це створить файл _**malware_rules.yar**_, який містить усі yara rules для malware.
```bash
wget https://gist.githubusercontent.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9/raw/4ec711d37f1b428b63bed1f786b26a0654aa2f31/malware_yara_rules.py
mkdir rules
python malware_yara_rules.py
```
#### Сканування
```bash
yara -w malware_rules.yar image  #Scan 1 file
yara -w malware_rules.yar folder #Scan the whole folder
```
#### YaraGen: Перевірка на malware та створення rules

Ви можете використати інструмент [**YaraGen**](https://github.com/Neo23x0/yarGen) для генерації yara rules з бінарного файлу. Перегляньте ці підручники: [**Part 1**](https://www.nextron-systems.com/2015/02/16/write-simple-sound-yara-rules/), [**Part 2**](https://www.nextron-systems.com/2015/10/17/how-to-write-simple-but-sound-yara-rules-part-2/), [**Part 3**](https://www.nextron-systems.com/2016/04/15/how-to-write-simple-but-sound-yara-rules-part-3/)
```bash
python3 yarGen.py --update
python3.exe yarGen.py --excludegood -m  ../../mals/
```
### ClamAV

#### Встановлення
```
sudo apt-get install -y clamav
```
#### Сканування
```bash
sudo freshclam      #Update rules
clamscan filepath   #Scan 1 file
clamscan folderpath #Scan the whole folder
```
### [Capa](https://github.com/mandiant/capa)

**Capa** виявляє потенційно шкідливі **можливості** в виконуваних файлах: PE, ELF, .NET. Тому воно знайде такі речі, як Att\&ck tactics, або підозрілі можливості, наприклад:

- check for OutputDebugString error
- run as a service
- create process

Отримати його можна в [**Github repo**](https://github.com/mandiant/capa).

### IOCs

IOC означає Indicator Of Compromise. IOC — це набір **умов, які ідентифікують** деяке потенційно небажане програмне забезпечення або підтверджене **malware**. Blue Teams використовують такі визначення, щоб **шукати цього роду шкідливі файли** у своїх **системах** та **мережах**.\
Обмін цими визначеннями дуже корисний: коли malware виявлено на комп'ютері і створено IOC для цього malware, інші Blue Teams можуть швидше його ідентифікувати.

Інструмент для створення або редагування IOC — [**IOC Editor**](https://www.fireeye.com/services/freeware/ioc-editor.html)**.**\
Ви можете використовувати інструменти, такі як [**Redline**](https://www.fireeye.com/services/freeware/redline.html), щоб **шукати визначені IOC на пристрої**.

### Loki

[**Loki**](https://github.com/Neo23x0/Loki) — сканер для Simple Indicators of Compromise.\
Виявлення базується на чотирьох методах виявлення:
```
1. File Name IOC
Regex match on full file path/name

2. Yara Rule Check
Yara signature matches on file data and process memory

3. Hash Check
Compares known malicious hashes (MD5, SHA1, SHA256) with scanned files

4. C2 Back Connect Check
Compares process connection endpoints with C2 IOCs (new since version v.10)
```
### Linux Malware Detect

[**Linux Malware Detect (LMD)**](https://www.rfxn.com/projects/linux-malware-detect/) — це сканер malware для Linux, випущений під ліцензією GNU GPLv2, розроблений з урахуванням загроз, характерних для середовищ зі спільним хостингом. Він використовує дані про загрози з периферійних мережевих систем виявлення вторгнень для вилучення malware, яке активно використовується в атаках, та генерує сигнатури для виявлення. Крім того, дані про загрози також надходять від відправлень користувачів за допомогою LMD checkout feature та ресурсів спільноти malware.

### rkhunter

Інструменти на кшталт [**rkhunter**](http://rkhunter.sourceforge.net) можна використовувати для перевірки файлової системи на наявність можливих **rootkits** та malware.
```bash
sudo ./rkhunter --check -r / -l /tmp/rkhunter.log [--report-warnings-only] [--skip-keypress]
```
### FLOSS

[**FLOSS**](https://github.com/mandiant/flare-floss) — інструмент, який намагається знайти обфусковані рядки всередині виконуваних файлів, використовуючи різні техніки.

### PEpper

[PEpper ](https://github.com/Th3Hurrican3/PEpper)перевіряє деякі базові речі всередині виконуваного файлу (бінарні дані, ентропія, URLs та IP-адреси, деякі yara правила).

### PEstudio

[PEstudio](https://www.winitor.com/download) — інструмент, який дозволяє отримати інформацію про Windows виконувані файли, такі як імпорти, експорти, заголовки, а також перевіряє VirusTotal і знаходить потенційні Att\&ck techniques.

### Detect It Easy(DiE)

[**DiE**](https://github.com/horsicq/Detect-It-Easy/) — інструмент для визначення, чи файл **зашифрований**, а також для знаходження **packers**.

### NeoPI

[**NeoPI** ](https://github.com/CiscoCXSecurity/NeoPI) — Python-скрипт, який використовує різні **статистичні методи** для виявлення **обфускованого** та **зашифрованого** вмісту в текстових/скриптових файлах. Метою NeoPI є допомога у **виявленні прихованого web shell коду**.

### **php-malware-finder**

[**PHP-malware-finder**](https://github.com/nbs-system/php-malware-finder) робить усе можливе, щоб виявити **обфускований**/**підозрілий код**, а також файли, що використовують **PHP** функції, які часто застосовуються в **malwares**/webshells.

### Apple Binary Signatures

When checking some **malware sample** you should always **check the signature** of the binary as the **developer** that signed it may be already **related** with **malware.**
```bash
#Get signer
codesign -vv -d /bin/ls 2>&1 | grep -E "Authority|TeamIdentifier"

#Check if the app’s contents have been modified
codesign --verify --verbose /Applications/Safari.app

#Check if the signature is valid
spctl --assess --verbose /Applications/Safari.app
```
## Detection Techniques

### File Stacking

Якщо ви знаєте, що якась папка, яка містить **files** веб-сервера, була **last updated on some date**. **Check** **date** створення та модифікації всіх **files** у **web server**, і якщо якась дата виглядає **suspicious**, перевірте відповідний файл.

### Baselines

Якщо **files** у папці **shouldn't have been modified**, ви можете обчислити **hash** від **original files** папки і **compare** їх із **current**. Усе, що змінено, буде **suspicious**.

### Statistical Analysis

Якщо інформація збережена в logs, ви можете **check statistics** — наприклад, скільки разів кожен **file** веб-сервера був доступний; web shell може бути одним із найчастіше accessed.

---

### Android in-app native telemetry (no root)

На Android ви можете інструментувати native code всередині процесу цільового додатка, підвантаживши невелику бібліотеку-логер перед ініціалізацією інших JNI libs. Це дає ранню видимість native behavior без system-wide hooks або root. Популярний підхід — SoTap: покладіть libsotap.so для потрібного ABI у APK і інжектуйте виклик System.loadLibrary("sotap") на ранньому етапі (наприклад, static initializer або Application.onCreate), потім збирайте логи з internal/external шляхів або використовуйте Logcat як fallback.

See the Android native reversing page for setup details and log paths:

{{#ref}}
../../mobile-pentesting/android-app-pentesting/reversing-native-libraries.md
{{#endref}}

---

## Deobfuscating Dynamic Control-Flow (JMP/CALL RAX Dispatchers)

Сучасні malware родини інтенсивно зловживають Control-Flow Graph (CFG) obfuscation: замість прямого jump/call вони обчислюють адресу призначення під час виконання і виконують `jmp rax` або `call rax`. Малий *dispatcher* (звичайно дев'ять інструкцій) встановлює фінальну ціль залежно від CPU `ZF`/`CF` flags, що повністю руйнує статичне відновлення CFG.

Техніку — продемонстровану SLOW#TEMPEST loader — можна обійти трьома кроками, які покладаються лише на IDAPython і Unicorn CPU emulator.

### 1. Locate every indirect jump / call
```python
import idautils, idc

for ea in idautils.FunctionItems(idc.here()):
mnem = idc.print_insn_mnem(ea)
if mnem in ("jmp", "call") and idc.print_operand(ea, 0) == "rax":
print(f"[+] Dispatcher found @ {ea:X}")
```
### 2. Витягти байт-код диспетчера
```python
import idc

def get_dispatcher_start(jmp_ea, count=9):
s = jmp_ea
for _ in range(count):
s = idc.prev_head(s, 0)
return s

start = get_dispatcher_start(jmp_ea)
size  = jmp_ea + idc.get_item_size(jmp_ea) - start
code  = idc.get_bytes(start, size)
open(f"{start:X}.bin", "wb").write(code)
```
### 3. Емулюйте це двічі за допомогою Unicorn
```python
from unicorn import *
from unicorn.x86_const import *
import struct

def run(code, zf=0, cf=0):
BASE = 0x1000
mu = Uc(UC_ARCH_X86, UC_MODE_64)
mu.mem_map(BASE, 0x1000)
mu.mem_write(BASE, code)
mu.reg_write(UC_X86_REG_RFLAGS, (zf << 6) | cf)
mu.reg_write(UC_X86_REG_RAX, 0)
mu.emu_start(BASE, BASE+len(code))
return mu.reg_read(UC_X86_REG_RAX)
```
Запустіть `run(code,0,0)` та `run(code,1,1)`, щоб отримати *false* та *true* цілі гілок.

### 4. Відновити direct jump / call
```python
import struct, ida_bytes

def patch_direct(ea, target, is_call=False):
op   = 0xE8 if is_call else 0xE9           # CALL rel32 or JMP rel32
disp = target - (ea + 5) & 0xFFFFFFFF
ida_bytes.patch_bytes(ea, bytes([op]) + struct.pack('<I', disp))
```
Після patching, змусьте IDA повторно проаналізувати функцію, щоб повний CFG і вивід Hex-Rays були відновлені:
```python
import ida_auto, idaapi
idaapi.reanalyze_function(idc.get_func_attr(ea, idc.FUNCATTR_START))
```
### 5. Позначення непрямих API викликів

Після того, як відоме реальне місце призначення кожного `call rax`, ви можете вказати це в IDA, щоб типи параметрів та імена змінних відновлювалися автоматично:
```python
idc.set_callee_name(call_ea, resolved_addr, 0)  # IDA 8.3+
```
### Практичні переваги

* Відновлює реальний CFG → decompilation goes from *10* lines to thousands.
* Дозволяє string-cross-reference & xrefs, що робить реконструкцію поведінки тривіальною.
* Scripts are reusable: drop them into any loader protected by the same trick.

---

## AdaptixC2: Configuration Extraction and TTPs

Див. присвячену сторінку:

{{#ref}}
adaptixc2-config-extraction-and-ttps.md
{{#endref}}

## Джерела

- [Unit42 – Evolving Tactics of SLOW#TEMPEST: A Deep Dive Into Advanced Malware Techniques](https://unit42.paloaltonetworks.com/slow-tempest-malware-obfuscation/)
- SoTap: Lightweight in-app JNI (.so) behavior logger – [github.com/RezaArbabBot/SoTap](https://github.com/RezaArbabBot/SoTap)
- [Unit42 – AdaptixC2: A New Open-Source Framework Leveraged in Real-World Attacks](https://unit42.paloaltonetworks.com/adaptixc2-post-exploitation-framework/)

{{#include ../../banners/hacktricks-training.md}}
