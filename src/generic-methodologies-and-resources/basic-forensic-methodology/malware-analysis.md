# Analisi del Malware

{{#include ../../banners/hacktricks-training.md}}

## CheatSheets di Forense

[https://www.jaiminton.com/cheatsheet/DFIR/#](https://www.jaiminton.com/cheatsheet/DFIR/)

## Servizi Online

- [VirusTotal](https://www.virustotal.com/gui/home/upload)
- [HybridAnalysis](https://www.hybrid-analysis.com)
- [Koodous](https://koodous.com)
- [Intezer](https://analyze.intezer.com)
- [Any.Run](https://any.run/)

## Strumenti Antivirus e di Rilevamento Offline

### Yara

#### Installa
```bash
sudo apt-get install -y yara
```
#### Preparare le regole

Usa questo script per scaricare e unire tutte le regole yara per malware da github: [https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9](https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9)\
Crea la directory _**rules**_ ed eseguila. Questo creerà un file chiamato _**malware_rules.yar**_ che contiene tutte le regole yara per malware.
```bash
wget https://gist.githubusercontent.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9/raw/4ec711d37f1b428b63bed1f786b26a0654aa2f31/malware_yara_rules.py
mkdir rules
python malware_yara_rules.py
```
#### Scansione
```bash
yara -w malware_rules.yar image  #Scan 1 file
yara -w malware_rules.yar folder #Scan the whole folder
```
#### YaraGen: Controlla il malware e crea regole

Puoi utilizzare lo strumento [**YaraGen**](https://github.com/Neo23x0/yarGen) per generare regole yara da un binario. Dai un'occhiata a questi tutorial: [**Parte 1**](https://www.nextron-systems.com/2015/02/16/write-simple-sound-yara-rules/), [**Parte 2**](https://www.nextron-systems.com/2015/10/17/how-to-write-simple-but-sound-yara-rules-part-2/), [**Parte 3**](https://www.nextron-systems.com/2016/04/15/how-to-write-simple-but-sound-yara-rules-part-3/)
```bash
python3 yarGen.py --update
python3.exe yarGen.py --excludegood -m  ../../mals/
```
### ClamAV

#### Installa
```
sudo apt-get install -y clamav
```
#### Scansione
```bash
sudo freshclam      #Update rules
clamscan filepath   #Scan 1 file
clamscan folderpath #Scan the whole folder
```
### [Capa](https://github.com/mandiant/capa)

**Capa** rileva potenziali **capacità** malevole in eseguibili: PE, ELF, .NET. Quindi troverà cose come tattiche Att\&ck, o capacità sospette come:

- controlla per errori OutputDebugString
- esegui come servizio
- crea processo

Ottienilo nel [**Github repo**](https://github.com/mandiant/capa).

### IOCs

IOC significa Indicatore di Compromissione. Un IOC è un insieme di **condizioni che identificano** alcuni software potenzialmente indesiderati o **malware** confermato. I Blue Teams usano questo tipo di definizione per **cercare questo tipo di file malevoli** nei loro **sistemi** e **reti**.\
Condividere queste definizioni è molto utile poiché quando il malware viene identificato in un computer e viene creato un IOC per quel malware, altri Blue Teams possono usarlo per identificare il malware più rapidamente.

Uno strumento per creare o modificare IOCs è [**IOC Editor**](https://www.fireeye.com/services/freeware/ioc-editor.html)**.**\
Puoi usare strumenti come [**Redline**](https://www.fireeye.com/services/freeware/redline.html) per **cercare IOCs definiti in un dispositivo**.

### Loki

[**Loki**](https://github.com/Neo23x0/Loki) è uno scanner per Indicatori di Compromissione Semplici.\
La rilevazione si basa su quattro metodi di rilevazione:
```
1. File Name IOC
Regex match on full file path/name

2. Yara Rule Check
Yara signature matches on file data and process memory

3. Hash Check
Compares known malicious hashes (MD5, SHA1, SHA256) with scanned files

4. C2 Back Connect Check
Compares process connection endpoints with C2 IOCs (new since version v.10)
```
### Linux Malware Detect

[**Linux Malware Detect (LMD)**](https://www.rfxn.com/projects/linux-malware-detect/) è uno scanner di malware per Linux rilasciato sotto la licenza GNU GPLv2, progettato attorno alle minacce affrontate negli ambienti di hosting condivisi. Utilizza dati sulle minacce provenienti dai sistemi di rilevamento delle intrusioni ai margini della rete per estrarre malware che viene attivamente utilizzato negli attacchi e genera firme per la rilevazione. Inoltre, i dati sulle minacce sono anche derivati dalle segnalazioni degli utenti con la funzione di checkout di LMD e dalle risorse della comunità malware.

### rkhunter

Strumenti come [**rkhunter**](http://rkhunter.sourceforge.net) possono essere utilizzati per controllare il filesystem per possibili **rootkit** e malware.
```bash
sudo ./rkhunter --check -r / -l /tmp/rkhunter.log [--report-warnings-only] [--skip-keypress]
```
### FLOSS

[**FLOSS**](https://github.com/mandiant/flare-floss) è uno strumento che cerca di trovare stringhe offuscate all'interno di eseguibili utilizzando diverse tecniche.

### PEpper

[PEpper ](https://github.com/Th3Hurrican3/PEpper)controlla alcune informazioni di base all'interno dell'eseguibile (dati binari, entropia, URL e IP, alcune regole yara).

### PEstudio

[PEstudio](https://www.winitor.com/download) è uno strumento che consente di ottenere informazioni sugli eseguibili Windows come importazioni, esportazioni, intestazioni, ma controlla anche virus total e trova potenziali tecniche Att\&ck.

### Detect It Easy(DiE)

[**DiE**](https://github.com/horsicq/Detect-It-Easy/) è uno strumento per rilevare se un file è **crittografato** e trova anche **packers**.

### NeoPI

[**NeoPI** ](https://github.com/CiscoCXSecurity/NeoPI)è uno script Python che utilizza una varietà di **metodi statistici** per rilevare contenuti **offuscati** e **crittografati** all'interno di file di testo/script. Lo scopo di NeoPI è aiutare nella **rilevazione di codice web shell nascosto**.

### **php-malware-finder**

[**PHP-malware-finder**](https://github.com/nbs-system/php-malware-finder) fa del suo meglio per rilevare **codice offuscato**/**sospetto** così come file che utilizzano funzioni **PHP** spesso usate in **malware**/webshell.

### Apple Binary Signatures

Quando controlli un **campione di malware** dovresti sempre **controllare la firma** del binario poiché il **sviluppatore** che l'ha firmato potrebbe essere già **relato** a **malware.**
```bash
#Get signer
codesign -vv -d /bin/ls 2>&1 | grep -E "Authority|TeamIdentifier"

#Check if the app’s contents have been modified
codesign --verify --verbose /Applications/Safari.app

#Check if the signature is valid
spctl --assess --verbose /Applications/Safari.app
```
## Tecniche di Rilevamento

### File Stacking

Se sai che una cartella contenente i **file** di un server web è stata **aggiornata l'ultima volta in una certa data**. **Controlla** la **data** in cui tutti i **file** nel **server web sono stati creati e modificati** e se qualche data è **sospetta**, controlla quel file.

### Baselines

Se i file di una cartella **non avrebbero dovuto essere modificati**, puoi calcolare l'**hash** dei **file originali** della cartella e **confrontarli** con quelli **correnti**. Qualsiasi modifica sarà **sospetta**.

### Analisi Statistica

Quando le informazioni sono salvate nei log puoi **controllare statistiche come quante volte ogni file di un server web è stato accesso, poiché una shell web potrebbe essere una delle più**.

---

## Deobfuscating Dynamic Control-Flow (JMP/CALL RAX Dispatchers)

Le moderne famiglie di malware abusano pesantemente dell'oscuramento del Control-Flow Graph (CFG): invece di un salto/chiamata diretto, calcolano la destinazione a tempo di esecuzione ed eseguono un `jmp rax` o `call rax`. Un piccolo *dispatcher* (tipicamente nove istruzioni) imposta il target finale a seconda dei flag `ZF`/`CF` della CPU, rompendo completamente il recupero statico del CFG.

La tecnica – mostrata dal caricatore SLOW#TEMPEST – può essere sconfitta con un flusso di lavoro in tre fasi che si basa solo su IDAPython e l'emulatore CPU Unicorn.

### 1. Individua ogni salto / chiamata indiretta
```python
import idautils, idc

for ea in idautils.FunctionItems(idc.here()):
mnem = idc.print_insn_mnem(ea)
if mnem in ("jmp", "call") and idc.print_operand(ea, 0) == "rax":
print(f"[+] Dispatcher found @ {ea:X}")
```
### 2. Estrai il byte-code del dispatcher
```python
import idc

def get_dispatcher_start(jmp_ea, count=9):
s = jmp_ea
for _ in range(count):
s = idc.prev_head(s, 0)
return s

start = get_dispatcher_start(jmp_ea)
size  = jmp_ea + idc.get_item_size(jmp_ea) - start
code  = idc.get_bytes(start, size)
open(f"{start:X}.bin", "wb").write(code)
```
### 3. Esegui l'emulazione due volte con Unicorn
```python
from unicorn import *
from unicorn.x86_const import *
import struct

def run(code, zf=0, cf=0):
BASE = 0x1000
mu = Uc(UC_ARCH_X86, UC_MODE_64)
mu.mem_map(BASE, 0x1000)
mu.mem_write(BASE, code)
mu.reg_write(UC_X86_REG_RFLAGS, (zf << 6) | cf)
mu.reg_write(UC_X86_REG_RAX, 0)
mu.emu_start(BASE, BASE+len(code))
return mu.reg_read(UC_X86_REG_RAX)
```
Esegui `run(code,0,0)` e `run(code,1,1)` per ottenere i target dei rami *falsi* e *veri*.

### 4. Ripristina un salto / chiamata diretta
```python
import struct, ida_bytes

def patch_direct(ea, target, is_call=False):
op   = 0xE8 if is_call else 0xE9           # CALL rel32 or JMP rel32
disp = target - (ea + 5) & 0xFFFFFFFF
ida_bytes.patch_bytes(ea, bytes([op]) + struct.pack('<I', disp))
```
Dopo aver applicato la patch, costringi IDA a riesaminare la funzione in modo che il CFG completo e l'output di Hex-Rays vengano ripristinati:
```python
import ida_auto, idaapi
idaapi.reanalyze_function(idc.get_func_attr(ea, idc.FUNCATTR_START))
```
### 5. Etichetta le chiamate API indirette

Una volta che la vera destinazione di ogni `call rax` è nota, puoi dire a IDA quale sia, in modo che i tipi di parametro e i nomi delle variabili vengano recuperati automaticamente:
```python
idc.set_callee_name(call_ea, resolved_addr, 0)  # IDA 8.3+
```
### Vantaggi pratici

* Ripristina il vero CFG → la decompilazione passa da *10* righe a migliaia.
* Abilita il cross-reference delle stringhe & xrefs, rendendo la ricostruzione del comportamento banale.
* Gli script sono riutilizzabili: basta inserirli in qualsiasi loader protetto dallo stesso trucco.

---

## Riferimenti

- [Unit42 – Evolving Tactics of SLOW#TEMPEST: A Deep Dive Into Advanced Malware Techniques](https://unit42.paloaltonetworks.com/slow-tempest-malware-obfuscation/)

{{#include ../../banners/hacktricks-training.md}}
