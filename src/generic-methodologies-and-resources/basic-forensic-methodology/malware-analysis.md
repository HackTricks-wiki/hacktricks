# Malware Analysis

{{#include ../../banners/hacktricks-training.md}}

## Forensics CheatSheets

[https://www.jaiminton.com/cheatsheet/DFIR/#](https://www.jaiminton.com/cheatsheet/DFIR/)

## Online Services

- [VirusTotal](https://www.virustotal.com/gui/home/upload)
- [HybridAnalysis](https://www.hybrid-analysis.com)
- [Koodous](https://koodous.com)
- [Intezer](https://analyze.intezer.com)
- [Any.Run](https://any.run/)

## Offline Antivirus and Detection Tools

### Yara

#### Install
```bash
sudo apt-get install -y yara
```
#### Prepare rules

Use this script to download and merge all the yara malware rules from github: [https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9](https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9)\
_create the _**rules**_ directory and execute it. This will create a file called _**malware_rules.yar**_ which contains all the yara rules for malware._
```bash
wget https://gist.githubusercontent.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9/raw/4ec711d37f1b428b63bed1f786b26a0654aa2f31/malware_yara_rules.py
mkdir rules
python malware_yara_rules.py
```
#### स्कैन
```bash
yara -w malware_rules.yar image  #Scan 1 file
yara -w malware_rules.yar folder #Scan the whole folder
```
#### YaraGen: मैलवेयर की जांच करें और नियम बनाएं

आप बाइनरी से यारा नियम उत्पन्न करने के लिए टूल [**YaraGen**](https://github.com/Neo23x0/yarGen) का उपयोग कर सकते हैं। इन ट्यूटोरियल्स को देखें: [**भाग 1**](https://www.nextron-systems.com/2015/02/16/write-simple-sound-yara-rules/), [**भाग 2**](https://www.nextron-systems.com/2015/10/17/how-to-write-simple-but-sound-yara-rules-part-2/), [**भाग 3**](https://www.nextron-systems.com/2016/04/15/how-to-write-simple-but-sound-yara-rules-part-3/)
```bash
python3 yarGen.py --update
python3.exe yarGen.py --excludegood -m  ../../mals/
```
### ClamAV

#### स्थापित करें
```
sudo apt-get install -y clamav
```
#### स्कैन
```bash
sudo freshclam      #Update rules
clamscan filepath   #Scan 1 file
clamscan folderpath #Scan the whole folder
```
### [Capa](https://github.com/mandiant/capa)

**Capa** संभावित हानिकारक **क्षमताओं** का पता लगाता है जो executables में होती हैं: PE, ELF, .NET। इसलिए यह ऐसे चीजें खोजेगा जैसे Att\&ck tactics, या संदिग्ध क्षमताएँ जैसे:

- OutputDebugString त्रुटि की जांच करें
- सेवा के रूप में चलाएँ
- प्रक्रिया बनाएँ

इसे [**Github repo**](https://github.com/mandiant/capa) में प्राप्त करें।

### IOCs

IOC का अर्थ है Indicator Of Compromise। एक IOC कुछ संभावित अवांछित सॉफ़्टवेयर या पुष्टि किए गए **malware** की पहचान करने वाले **शर्तों का एक सेट** है। Blue Teams इस प्रकार की परिभाषा का उपयोग अपने **सिस्टम** और **नेटवर्क** में इस प्रकार की हानिकारक फ़ाइलों की **खोज** के लिए करते हैं।\
इन परिभाषाओं को साझा करना बहुत उपयोगी है क्योंकि जब किसी कंप्यूटर में malware की पहचान की जाती है और उस malware के लिए एक IOC बनाया जाता है, तो अन्य Blue Teams इसका उपयोग malware की पहचान तेजी से करने के लिए कर सकते हैं।

IOCs बनाने या संशोधित करने के लिए एक उपकरण है [**IOC Editor**](https://www.fireeye.com/services/freeware/ioc-editor.html)**.**\
आप [**Redline**](https://www.fireeye.com/services/freeware/redline.html) जैसे उपकरणों का उपयोग करके **एक डिवाइस में परिभाषित IOCs की खोज** कर सकते हैं।

### Loki

[**Loki**](https://github.com/Neo23x0/Loki) Simple Indicators of Compromise के लिए एक स्कैनर है।\
पता लगाने की प्रक्रिया चार पहचान विधियों पर आधारित है:
```
1. File Name IOC
Regex match on full file path/name

2. Yara Rule Check
Yara signature matches on file data and process memory

3. Hash Check
Compares known malicious hashes (MD5, SHA1, SHA256) with scanned files

4. C2 Back Connect Check
Compares process connection endpoints with C2 IOCs (new since version v.10)
```
### Linux Malware Detect

[**Linux Malware Detect (LMD)**](https://www.rfxn.com/projects/linux-malware-detect/) एक मैलवेयर स्कैनर है जो Linux के लिए GNU GPLv2 लाइसेंस के तहत जारी किया गया है, जिसे साझा होस्टेड वातावरण में सामना की जाने वाली खतरों के चारों ओर डिज़ाइन किया गया है। यह नेटवर्क एज इंट्रूज़न डिटेक्शन सिस्टम से खतरे के डेटा का उपयोग करता है ताकि उन मैलवेयर को निकाला जा सके जो हमलों में सक्रिय रूप से उपयोग किए जा रहे हैं और पहचान के लिए सिग्नेचर उत्पन्न करता है। इसके अतिरिक्त, खतरे का डेटा LMD चेकआउट फीचर और मैलवेयर समुदाय संसाधनों के साथ उपयोगकर्ता सबमिशन से भी प्राप्त किया जाता है।

### rkhunter

जैसे उपकरण [**rkhunter**](http://rkhunter.sourceforge.net) का उपयोग फ़ाइल सिस्टम की जांच करने के लिए किया जा सकता है कि क्या संभव **रूटकिट** और मैलवेयर हैं।
```bash
sudo ./rkhunter --check -r / -l /tmp/rkhunter.log [--report-warnings-only] [--skip-keypress]
```
### FLOSS

[**FLOSS**](https://github.com/mandiant/flare-floss) एक उपकरण है जो विभिन्न तकनीकों का उपयोग करके निष्पादन योग्य फ़ाइलों के अंदर छिपे हुए स्ट्रिंग्स को खोजने की कोशिश करेगा।

### PEpper

[PEpper ](https://github.com/Th3Hurrican3/PEpper) निष्पादन योग्य फ़ाइल के अंदर कुछ बुनियादी चीजों की जांच करता है (बाइनरी डेटा, एंट्रॉपी, URLs और IPs, कुछ यारा नियम)।

### PEstudio

[PEstudio](https://www.winitor.com/download) एक उपकरण है जो Windows निष्पादन योग्य फ़ाइलों की जानकारी प्राप्त करने की अनुमति देता है जैसे कि आयात, निर्यात, हेडर, लेकिन यह वायरस टोटल की भी जांच करेगा और संभावित Att\&ck तकनीकों को खोजेगा।

### Detect It Easy(DiE)

[**DiE**](https://github.com/horsicq/Detect-It-Easy/) एक उपकरण है जो यह पता लगाने के लिए है कि क्या एक फ़ाइल **एन्क्रिप्टेड** है और साथ ही **पैकर** भी खोजता है।

### NeoPI

[**NeoPI** ](https://github.com/CiscoCXSecurity/NeoPI) एक Python स्क्रिप्ट है जो **छिपे हुए** और **एन्क्रिप्टेड** सामग्री का पता लगाने के लिए विभिन्न **सांख्यिकीय विधियों** का उपयोग करती है। NeoPI का उद्देश्य **छिपे हुए वेब शेल कोड** का पता लगाने में मदद करना है।

### **php-malware-finder**

[**PHP-malware-finder**](https://github.com/nbs-system/php-malware-finder) **छिपे हुए**/**संदिग्ध कोड** के साथ-साथ **PHP** फ़ंक्शंस का उपयोग करने वाली फ़ाइलों का पता लगाने के लिए अपनी पूरी कोशिश करता है जो अक्सर **मैलवेयर**/वेबशेल में उपयोग किए जाते हैं।

### Apple Binary Signatures

जब आप कुछ **मैलवेयर नमूना** की जांच कर रहे हों, तो आपको हमेशा बाइनरी के **हस्ताक्षर** की जांच करनी चाहिए क्योंकि **डेवलपर** जिसने इसे हस्ताक्षरित किया है, वह पहले से ही **मैलवेयर** से **संबंधित** हो सकता है।
```bash
#Get signer
codesign -vv -d /bin/ls 2>&1 | grep -E "Authority|TeamIdentifier"

#Check if the app’s contents have been modified
codesign --verify --verbose /Applications/Safari.app

#Check if the signature is valid
spctl --assess --verbose /Applications/Safari.app
```
## Detection Techniques

### File Stacking

यदि आप जानते हैं कि किसी फ़ोल्डर में **फाइलें** एक वेब सर्वर की **अंतिम बार कुछ तारीख** को **अपडेट** की गई थीं। **जांचें** कि **वेब सर्वर में सभी फाइलों** की **तारीख** कब **बनाई और संशोधित** की गई थी और यदि कोई तारीख **संदिग्ध** है, तो उस फ़ाइल की जांच करें।

### Baselines

यदि किसी फ़ोल्डर की फाइलें **संशोधित नहीं होनी चाहिए थीं**, तो आप फ़ोल्डर की **मूल फाइलों** का **हैश** निकाल सकते हैं और उन्हें **वर्तमान** फाइलों के साथ **तुलना** कर सकते हैं। जो भी संशोधित होगा वह **संदिग्ध** होगा।

### Statistical Analysis

जब जानकारी लॉग में सहेजी जाती है, तो आप **सांख्यिकी की जांच कर सकते हैं जैसे कि एक वेब सर्वर की प्रत्येक फ़ाइल को कितनी बार एक्सेस किया गया, क्योंकि एक वेब शेल सबसे अधिक हो सकता है**।

---

## Deobfuscating Dynamic Control-Flow (JMP/CALL RAX Dispatchers)

आधुनिक मैलवेयर परिवार नियंत्रण-प्रवाह ग्राफ (CFG) की छिपाने का भारी दुरुपयोग करते हैं: सीधे कूदने/कॉल करने के बजाय, वे रन-टाइम पर गंतव्य की गणना करते हैं और `jmp rax` या `call rax` का निष्पादन करते हैं। एक छोटा *डिस्पैचर* (आमतौर पर नौ निर्देश) CPU के `ZF`/`CF` फ्लैग के आधार पर अंतिम लक्ष्य निर्धारित करता है, जो स्थिर CFG पुनर्प्राप्ति को पूरी तरह से तोड़ देता है।

यह तकनीक - SLOW#TEMPEST लोडर द्वारा प्रदर्शित - एक तीन-चरणीय कार्यप्रवाह के साथ पराजित की जा सकती है जो केवल IDAPython और यूनिकॉर्न CPU इम्यूलेटर पर निर्भर करती है।

### 1. Locate every indirect jump / call
```python
import idautils, idc

for ea in idautils.FunctionItems(idc.here()):
mnem = idc.print_insn_mnem(ea)
if mnem in ("jmp", "call") and idc.print_operand(ea, 0) == "rax":
print(f"[+] Dispatcher found @ {ea:X}")
```
### 2. डिस्पैचर बाइट-कोड निकालें
```python
import idc

def get_dispatcher_start(jmp_ea, count=9):
s = jmp_ea
for _ in range(count):
s = idc.prev_head(s, 0)
return s

start = get_dispatcher_start(jmp_ea)
size  = jmp_ea + idc.get_item_size(jmp_ea) - start
code  = idc.get_bytes(start, size)
open(f"{start:X}.bin", "wb").write(code)
```
### 3. इसे यूनिकॉर्न के साथ दो बार अनुकरण करें
```python
from unicorn import *
from unicorn.x86_const import *
import struct

def run(code, zf=0, cf=0):
BASE = 0x1000
mu = Uc(UC_ARCH_X86, UC_MODE_64)
mu.mem_map(BASE, 0x1000)
mu.mem_write(BASE, code)
mu.reg_write(UC_X86_REG_RFLAGS, (zf << 6) | cf)
mu.reg_write(UC_X86_REG_RAX, 0)
mu.emu_start(BASE, BASE+len(code))
return mu.reg_read(UC_X86_REG_RAX)
```
`run(code,0,0)` और `run(code,1,1)` चलाएँ ताकि *false* और *true* शाखा लक्ष्यों को प्राप्त किया जा सके।

### 4. एक प्रत्यक्ष कूद / कॉल को पैच करें
```python
import struct, ida_bytes

def patch_direct(ea, target, is_call=False):
op   = 0xE8 if is_call else 0xE9           # CALL rel32 or JMP rel32
disp = target - (ea + 5) & 0xFFFFFFFF
ida_bytes.patch_bytes(ea, bytes([op]) + struct.pack('<I', disp))
```
पैचिंग के बाद, IDA को फ़ंक्शन को फिर से विश्लेषण करने के लिए मजबूर करें ताकि पूरा CFG और Hex-Rays आउटपुट पुनर्स्थापित हो सके:
```python
import ida_auto, idaapi
idaapi.reanalyze_function(idc.get_func_attr(ea, idc.FUNCATTR_START))
```
### 5. अप्रत्यक्ष API कॉल को लेबल करें

एक बार जब हर `call rax` का असली गंतव्य ज्ञात हो जाता है, तो आप IDA को बता सकते हैं कि यह क्या है ताकि पैरामीटर प्रकार और चर नाम स्वचालित रूप से पुनर्प्राप्त हो सकें:
```python
idc.set_callee_name(call_ea, resolved_addr, 0)  # IDA 8.3+
```
### व्यावहारिक लाभ

* वास्तविक CFG को पुनर्स्थापित करता है → डिकंपाइलिंग *10* लाइनों से हजारों लाइनों में बदल जाती है।
* स्ट्रिंग-क्रॉस-रेफरेंस और xrefs सक्षम करता है, जिससे व्यवहार पुनर्निर्माण सरल हो जाता है।
* स्क्रिप्ट पुन: उपयोग योग्य हैं: उन्हें किसी भी लोडर में डालें जो उसी ट्रिक द्वारा सुरक्षित है।

---

## संदर्भ

- [Unit42 – SLOW#TEMPEST की विकसित होती रणनीतियाँ: उन्नत मैलवेयर तकनीकों में गहराई से गोताखोरी](https://unit42.paloaltonetworks.com/slow-tempest-malware-obfuscation/)

{{#include ../../banners/hacktricks-training.md}}
