# Malware विश्लेषण

{{#include ../../banners/hacktricks-training.md}}

## Forensics CheatSheets

[https://www.jaiminton.com/cheatsheet/DFIR/#](https://www.jaiminton.com/cheatsheet/DFIR/)

## ऑनलाइन सेवाएँ

- [VirusTotal](https://www.virustotal.com/gui/home/upload)
- [HybridAnalysis](https://www.hybrid-analysis.com)
- [Koodous](https://koodous.com)
- [Intezer](https://analyze.intezer.com)
- [Any.Run](https://any.run/)

## ऑफ़लाइन एंटीवायरस और डिटेक्शन टूल्स

### Yara

#### इंस्टॉल
```bash
sudo apt-get install -y yara
```
#### नियम तैयार करें

इस स्क्रिप्ट का उपयोग github से सभी yara malware rules को डाउनलोड और मर्ज करने के लिए करें: [https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9](https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9)\
Create the _**rules**_ directory and execute it. यह _**malware_rules.yar**_ नाम की एक फ़ाइल बनाएगा जिसमें malware के लिए सभी yara rules शामिल होंगे।
```bash
wget https://gist.githubusercontent.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9/raw/4ec711d37f1b428b63bed1f786b26a0654aa2f31/malware_yara_rules.py
mkdir rules
python malware_yara_rules.py
```
#### स्कैन
```bash
yara -w malware_rules.yar image  #Scan 1 file
yara -w malware_rules.yar folder #Scan the whole folder
```
#### YaraGen: malware के लिए जांच करें और नियम बनाएं

आप [**YaraGen**](https://github.com/Neo23x0/yarGen) टूल का उपयोग करके किसी binary से yara rules जनरेट कर सकते हैं। इन ट्यूटोरियल्स को देखें: [**Part 1**](https://www.nextron-systems.com/2015/02/16/write-simple-sound-yara-rules/), [**Part 2**](https://www.nextron-systems.com/2015/10/17/how-to-write-simple-but-sound-yara-rules-part-2/), [**Part 3**](https://www.nextron-systems.com/2016/04/15/how-to-write-simple-but-sound-yara-rules-part-3/)
```bash
python3 yarGen.py --update
python3.exe yarGen.py --excludegood -m  ../../mals/
```
### ClamAV

#### इंस्टॉल
```
sudo apt-get install -y clamav
```
#### स्कैन
```bash
sudo freshclam      #Update rules
clamscan filepath   #Scan 1 file
clamscan folderpath #Scan the whole folder
```
### [Capa](https://github.com/mandiant/capa)

**Capa** executables में संभावित malicious **capabilities** का पता लगाती है: PE, ELF, .NET. इसलिए यह Att\&ck tactics जैसी चीज़ें, या निम्नलिखित suspicious capabilities जैसी चीज़ें खोजेगी:

- check for OutputDebugString error
- run as a service
- create process

इसे [**Github repo**](https://github.com/mandiant/capa) में प्राप्त करें।

### IOCs

IOC का मतलब Indicator Of Compromise है। एक IOC उन शर्तों का सेट है जो किसी संभावित unwanted software या confirmed **malware** को पहचानती हैं। Blue Teams इस तरह की परिभाषा का उपयोग अपने **systems** और **networks** में इस तरह की malicious files को खोजने के लिए करते हैं।\
इन परिभाषाओं को share करना बहुत उपयोगी है क्योंकि जब किसी कंप्यूटर में malware पहचाना जाता है और उस malware के लिए एक IOC बनाया जाता है, तो अन्य Blue Teams उसे तेजी से पहचानने के लिए इसका उपयोग कर सकती हैं।

IOC बनाने या संशोधित करने के लिए एक tool है [**IOC Editor**](https://www.fireeye.com/services/freeware/ioc-editor.html)**.**\
आप ऐसे tools उपयोग कर सकते हैं जैसे [**Redline**](https://www.fireeye.com/services/freeware/redline.html) जो किसी device में defined IOCs को खोजने के लिए हैं।

### Loki

[**Loki**](https://github.com/Neo23x0/Loki) Simple Indicators of Compromise के लिए एक scanner है।\
Detection निम्न चार detection methods पर आधारित है:
```
1. File Name IOC
Regex match on full file path/name

2. Yara Rule Check
Yara signature matches on file data and process memory

3. Hash Check
Compares known malicious hashes (MD5, SHA1, SHA256) with scanned files

4. C2 Back Connect Check
Compares process connection endpoints with C2 IOCs (new since version v.10)
```
### Linux Malware Detect

[**Linux Malware Detect (LMD)**](https://www.rfxn.com/projects/linux-malware-detect/) एक Linux के लिए malware स्कैनर है जो GNU GPLv2 license के अंतर्गत जारी किया गया है, और इसे shared hosted environments में आने वाले threats के मद्देनज़र डिज़ाइन किया गया है। यह network edge intrusion detection systems से threat data का उपयोग करके उन malware को पहचानता और निकालता है जो सक्रिय रूप से हमलों में उपयोग हो रहे हैं और detection के लिए signatures बनाता है। इसके अलावा, threat data LMD checkout feature के जरिए user submissions और malware community resources से भी लिया जाता है।

### rkhunter

Tools like [**rkhunter**](http://rkhunter.sourceforge.net) का उपयोग फ़ाइल सिस्टम की जाँच करने के लिए किया जा सकता है ताकि संभावित **rootkits** और malware का पता लगाया जा सके।
```bash
sudo ./rkhunter --check -r / -l /tmp/rkhunter.log [--report-warnings-only] [--skip-keypress]
```
### FLOSS

[**FLOSS**](https://github.com/mandiant/flare-floss) एक टूल है जो विभिन्न तकनीकों का उपयोग करके executables के अंदर obfuscated strings खोजने की कोशिश करता है।

### PEpper

[PEpper ](https://github.com/Th3Hurrican3/PEpper) executable के अंदर कुछ बुनियादी चीज़ें चेक करता है (binary data, entropy, URLs and IPs, कुछ yara rules)।

### PEstudio

[PEstudio](https://www.winitor.com/download) एक टूल है जो Windows executables की जानकारी देता है जैसे imports, exports, headers; साथ ही यह virus total को भी चेक करेगा और संभावित Att\&ck techniques खोजेगा।

### Detect It Easy(DiE)

[**DiE**](https://github.com/horsicq/Detect-It-Easy/) एक टूल है जो पता लगाने के लिए कि कोई फ़ाइल **encrypted** है या नहीं और साथ ही **packers** भी खोजता है।

### NeoPI

[**NeoPI** ](https://github.com/CiscoCXSecurity/NeoPI) एक Python स्क्रिप्ट है जो text/script files के भीतर छिपे हुए **obfuscated** और **encrypted** कंटेंट का पता लगाने के लिए विभिन्न **statistical methods** का उपयोग करती है। NeoPI का उद्देश्य छिपे हुए web shell code के **detection** में मदद करना है।

### **php-malware-finder**

[**PHP-malware-finder**](https://github.com/nbs-system/php-malware-finder) obfuscated/**dodgy code** के साथ-साथ उन फाइलों का पता लगाने की पूरी कोशिश करता है जो **PHP** functions का उपयोग करती हैं जो अक्सर **malwares**/webshells में इस्तेमाल होते हैं।

### Apple Binary Signatures

जब आप किसी **malware sample** की जांच कर रहे हों तो हमेशा binary के **signature** की जांच करनी चाहिए क्योंकि जिस **developer** ने उसे sign किया है वह पहले से ही **related** हो सकता है **malware** से।
```bash
#Get signer
codesign -vv -d /bin/ls 2>&1 | grep -E "Authority|TeamIdentifier"

#Check if the app’s contents have been modified
codesign --verify --verbose /Applications/Safari.app

#Check if the signature is valid
spctl --assess --verbose /Applications/Safari.app
```
## डिटेक्शन तकनीकें

### File Stacking

यदि आप जानते हैं कि किसी फ़ोल्डर जिसमें **files** वाले web server को किसी विशेष तिथि पर **last updated on some date** किया गया था, तो उस स्थिति में आप वे सभी **files** की **date** जाँचें कि वे कब **created** और **modified** हुए थे; अगर कोई **date** **suspicious** दिखे तो उस file की जाँच करें।

### Baselines

यदि किसी फ़ोल्डर के **files** को **shouldn't have been modified** होना चाहिए था, तो आप उस फ़ोल्डर के **original files** का **hash** निकालकर उन्हें **current** वाले से **compare** कर सकते हैं। जो भी संशोधित होगा वह **suspicious** होगा।

### Statistical Analysis

जब जानकारी logs में सेव होती है, आप ऐसे **statistics** चेक कर सकते हैं जैसे कि web server के प्रत्येक file को कितनी बार एक्सेस किया गया — क्योंकि web shell संभवतः सबसे अधिक एक्सेस किए गए में से एक हो सकता है।

---

### Android in-app native telemetry (no root)

On Android, आप target app process के अंदर native code में instrumentation कर सकते हैं एक छोटे logger library को प्रीलोड करके, इससे पहले कि अन्य JNI libs initialize हों। इससे system-wide hooks या root के बिना ही native व्यवहार की शुरुआती visibility मिलती है। एक लोकप्रिय तरीका SoTap है: सही ABI के लिए libsotap.so को APK में डालें और शुरुआती चरण में System.loadLibrary("sotap") कॉल inject करें (उदाहरण के लिए, static initializer या Application.onCreate), फिर logs को internal/external paths या Logcat fallback से इकट्ठा करें।

See the Android native reversing page for setup details and log paths:

{{#ref}}
../../mobile-pentesting/android-app-pentesting/reversing-native-libraries.md
{{#endref}}

---

## डायनामिक Control-Flow का Deobfuscation (JMP/CALL RAX Dispatchers)

आधुनिक malware परिवार Control-Flow Graph (CFG) obfuscation का भारी दुरुपयोग करते हैं: सीधे jump/call की जगह वे destination को run-time पर compute करते हैं और `jmp rax` या `call rax` execute करते हैं। एक छोटा *dispatcher* (आम तौर पर नौ निर्देश) CPU के `ZF`/`CF` flags के आधार पर final target सेट करता है, जिससे static CFG recovery पूरी तरह टूट जाती है।

The technique – showcased by the SLOW#TEMPEST loader – can be defeated with a three-step workflow that only relies on IDAPython and the Unicorn CPU emulator.

### 1. Locate every indirect jump / call
```python
import idautils, idc

for ea in idautils.FunctionItems(idc.here()):
mnem = idc.print_insn_mnem(ea)
if mnem in ("jmp", "call") and idc.print_operand(ea, 0) == "rax":
print(f"[+] Dispatcher found @ {ea:X}")
```
### 2. डिस्पैचर बाइट-कोड निकालें
```python
import idc

def get_dispatcher_start(jmp_ea, count=9):
s = jmp_ea
for _ in range(count):
s = idc.prev_head(s, 0)
return s

start = get_dispatcher_start(jmp_ea)
size  = jmp_ea + idc.get_item_size(jmp_ea) - start
code  = idc.get_bytes(start, size)
open(f"{start:X}.bin", "wb").write(code)
```
### 3. Unicorn के साथ इसे दो बार Emulate करें
```python
from unicorn import *
from unicorn.x86_const import *
import struct

def run(code, zf=0, cf=0):
BASE = 0x1000
mu = Uc(UC_ARCH_X86, UC_MODE_64)
mu.mem_map(BASE, 0x1000)
mu.mem_write(BASE, code)
mu.reg_write(UC_X86_REG_RFLAGS, (zf << 6) | cf)
mu.reg_write(UC_X86_REG_RAX, 0)
mu.emu_start(BASE, BASE+len(code))
return mu.reg_read(UC_X86_REG_RAX)
```
`run(code,0,0)` और `run(code,1,1)` चलाएँ ताकि *false* और *true* branch targets प्राप्त किए जा सकें।

### 4. direct jump / call को वापस patch करें
```python
import struct, ida_bytes

def patch_direct(ea, target, is_call=False):
op   = 0xE8 if is_call else 0xE9           # CALL rel32 or JMP rel32
disp = target - (ea + 5) & 0xFFFFFFFF
ida_bytes.patch_bytes(ea, bytes([op]) + struct.pack('<I', disp))
```
पैच करने के बाद, पूरी CFG और Hex-Rays आउटपुट को बहाल करने के लिए IDA को function का पुनः विश्लेषण करने के लिए मजबूर करें:
```python
import ida_auto, idaapi
idaapi.reanalyze_function(idc.get_func_attr(ea, idc.FUNCATTR_START))
```
### 5. अप्रत्यक्ष API calls को लेबल करें

एक बार जब हर `call rax` का असली गंतव्य पता चल जाए, आप IDA को बता सकते हैं कि वह क्या है, ताकि parameter types & variable names अपने आप पुनर्प्राप्त हो जाएँ:
```python
idc.set_callee_name(call_ea, resolved_addr, 0)  # IDA 8.3+
```
### व्यावहारिक लाभ

* वास्तविक CFG को पुनर्स्थापित करता है → decompilation *10* लाइनों से हजारों तक चली जाती है।
* string-cross-reference & xrefs सक्षम करता है, जिससे behaviour reconstruction सरल हो जाती है।
* Scripts पुन:उपयोगी हैं: उन्हें किसी भी loader में डालें जो उसी trick से सुरक्षित हो।

---

## संदर्भ

- [Unit42 – Evolving Tactics of SLOW#TEMPEST: A Deep Dive Into Advanced Malware Techniques](https://unit42.paloaltonetworks.com/slow-tempest-malware-obfuscation/)
- SoTap: Lightweight in-app JNI (.so) behavior logger – [github.com/RezaArbabBot/SoTap](https://github.com/RezaArbabBot/SoTap)

{{#include ../../banners/hacktricks-training.md}}
