# Аналіз Шкідливого ПЗ

{{#include ../../banners/hacktricks-training.md}}

## Чит-листи для Судмедекспертів

[https://www.jaiminton.com/cheatsheet/DFIR/#](https://www.jaiminton.com/cheatsheet/DFIR/)

## Онлайн Сервіси

- [VirusTotal](https://www.virustotal.com/gui/home/upload)
- [HybridAnalysis](https://www.hybrid-analysis.com)
- [Koodous](https://koodous.com)
- [Intezer](https://analyze.intezer.com)
- [Any.Run](https://any.run/)

## Офлайн Антивірусні та Інструменти Виявлення

### Yara

#### Встановлення
```bash
sudo apt-get install -y yara
```
#### Підготовка правил

Використовуйте цей скрипт для завантаження та об'єднання всіх правил yara для шкідливого ПЗ з github: [https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9](https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9)\
Створіть директорію _**rules**_ і виконайте його. Це створить файл під назвою _**malware_rules.yar**_, який міститиме всі правила yara для шкідливого ПЗ.
```bash
wget https://gist.githubusercontent.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9/raw/4ec711d37f1b428b63bed1f786b26a0654aa2f31/malware_yara_rules.py
mkdir rules
python malware_yara_rules.py
```
#### Сканування
```bash
yara -w malware_rules.yar image  #Scan 1 file
yara -w malware_rules.yar folder #Scan the whole folder
```
#### YaraGen: Перевірка на наявність шкідливого ПЗ та створення правил

Ви можете використовувати інструмент [**YaraGen**](https://github.com/Neo23x0/yarGen) для генерації правил yara з бінарного файлу. Ознайомтеся з цими навчальними посібниками: [**Частина 1**](https://www.nextron-systems.com/2015/02/16/write-simple-sound-yara-rules/), [**Частина 2**](https://www.nextron-systems.com/2015/10/17/how-to-write-simple-but-sound-yara-rules-part-2/), [**Частина 3**](https://www.nextron-systems.com/2016/04/15/how-to-write-simple-but-sound-yara-rules-part-3/)
```bash
python3 yarGen.py --update
python3.exe yarGen.py --excludegood -m  ../../mals/
```
### ClamAV

#### Встановлення
```
sudo apt-get install -y clamav
```
#### Сканування
```bash
sudo freshclam      #Update rules
clamscan filepath   #Scan 1 file
clamscan folderpath #Scan the whole folder
```
### [Capa](https://github.com/mandiant/capa)

**Capa** виявляє потенційно шкідливі **можливості** в виконуваних файлах: PE, ELF, .NET. Тому він знайде такі речі, як тактики Att\&ck або підозрілі можливості, такі як:

- перевірка на помилку OutputDebugString
- запуск як служба
- створення процесу

Отримайте його в [**Github репозиторії**](https://github.com/mandiant/capa).

### IOCs

IOC означає Індикатор Компрометації. IOC - це набір **умов, які ідентифікують** деяке потенційно небажане програмне забезпечення або підтверджене **шкідливе ПЗ**. Команди Blue Teams використовують таке визначення, щоб **шукати такі шкідливі файли** у своїх **системах** та **мережах**.\
Д sharing these definitions is very useful as when malware is identified in a computer and an IOC for that malware is created, other Blue Teams can use it to identify the malware faster.

Інструмент для створення або модифікації IOCs - це [**IOC Editor**](https://www.fireeye.com/services/freeware/ioc-editor.html)**.**\
Ви можете використовувати такі інструменти, як [**Redline**](https://www.fireeye.com/services/freeware/redline.html), щоб **шукати визначені IOCs на пристрої**.

### Loki

[**Loki**](https://github.com/Neo23x0/Loki) - це сканер для Простих Індикаторів Компрометації.\
Виявлення базується на чотирьох методах виявлення:
```
1. File Name IOC
Regex match on full file path/name

2. Yara Rule Check
Yara signature matches on file data and process memory

3. Hash Check
Compares known malicious hashes (MD5, SHA1, SHA256) with scanned files

4. C2 Back Connect Check
Compares process connection endpoints with C2 IOCs (new since version v.10)
```
### Linux Malware Detect

[**Linux Malware Detect (LMD)**](https://www.rfxn.com/projects/linux-malware-detect/) - це сканер шкідливого ПЗ для Linux, випущений під ліцензією GNU GPLv2, який розроблений з урахуванням загроз, що виникають у середовищах спільного хостингу. Він використовує дані про загрози з систем виявлення вторгнень на краю мережі для виявлення шкідливого ПЗ, яке активно використовується в атаках, і генерує сигнатури для виявлення. Крім того, дані про загрози також отримуються з подань користувачів за допомогою функції перевірки LMD та ресурсів спільноти шкідливого ПЗ.

### rkhunter

Інструменти, такі як [**rkhunter**](http://rkhunter.sourceforge.net), можуть бути використані для перевірки файлової системи на можливі **rootkits** та шкідливе ПЗ.
```bash
sudo ./rkhunter --check -r / -l /tmp/rkhunter.log [--report-warnings-only] [--skip-keypress]
```
### FLOSS

[**FLOSS**](https://github.com/mandiant/flare-floss) - це інструмент, який намагатиметься знайти обфусцировані рядки всередині виконуваних файлів, використовуючи різні техніки.

### PEpper

[PEpper ](https://github.com/Th3Hurrican3/PEpper)перевіряє деякі базові речі всередині виконуваного файлу (бінарні дані, ентропія, URL-адреси та IP-адреси, деякі правила yara).

### PEstudio

[PEstudio](https://www.winitor.com/download) - це інструмент, який дозволяє отримувати інформацію про виконувані файли Windows, такі як імпорти, експорти, заголовки, але також перевірить virus total і знайде потенційні техніки Att\&ck.

### Detect It Easy(DiE)

[**DiE**](https://github.com/horsicq/Detect-It-Easy/) - це інструмент для виявлення, чи є файл **зашифрованим**, а також для знаходження **пакерів**.

### NeoPI

[**NeoPI** ](https://github.com/CiscoCXSecurity/NeoPI) - це скрипт на Python, який використовує різноманітні **статистичні методи** для виявлення **обфусцированого** та **зашифрованого** контенту в текстових/скриптових файлах. Заплановане призначення NeoPI - допомогти у **виявленні прихованого коду веб-оболонки**.

### **php-malware-finder**

[**PHP-malware-finder**](https://github.com/nbs-system/php-malware-finder) робить все можливе, щоб виявити **обфусцирований**/**підозрілий код**, а також файли, що використовують функції **PHP**, які часто використовуються в **шкідливих програмах**/веб-оболонках.

### Apple Binary Signatures

При перевірці деякого **зразка шкідливого ПЗ** ви завжди повинні **перевіряти підпис** бінарного файлу, оскільки **розробник**, який його підписав, може бути вже **пов'язаний** зі **шкідливим ПЗ.**
```bash
#Get signer
codesign -vv -d /bin/ls 2>&1 | grep -E "Authority|TeamIdentifier"

#Check if the app’s contents have been modified
codesign --verify --verbose /Applications/Safari.app

#Check if the signature is valid
spctl --assess --verbose /Applications/Safari.app
```
## Техніки виявлення

### Складання файлів

Якщо ви знаєте, що деяка папка, що містить **файли** веб-сервера, була **останніми оновленнями на певну дату**. **Перевірте** **дату** всіх **файлів**, які були створені та змінені на **веб-сервері**, і якщо якась дата є **підозрілою**, перевірте цей файл.

### Базові лінії

Якщо файли папки **не повинні були бути зміненими**, ви можете обчислити **хеш** **оригінальних файлів** папки та **порівняти** їх з **поточними**. Усе, що було змінено, буде **підозрілим**.

### Статистичний аналіз

Коли інформація зберігається в журналах, ви можете **перевірити статистику, наприклад, скільки разів кожен файл веб-сервера був доступний, оскільки веб-оболонка може бути одним з найбільш**.

---

## Деобфускація динамічного контролю потоку (JMP/CALL RAX диспетчери)

Сучасні сімейства шкідливих програм сильно зловживають обфускацією графа контролю потоку (CFG): замість прямого стрибка/виклику вони обчислюють призначення під час виконання та виконують `jmp rax` або `call rax`. Невеликий *диспетчер* (зазвичай дев'ять інструкцій) встановлює остаточну ціль залежно від флагів CPU `ZF`/`CF`, повністю порушуючи статичне відновлення CFG.

Цю техніку – продемонстровану завантажувачем SLOW#TEMPEST – можна подолати за допомогою трьохетапного робочого процесу, який покладається лише на IDAPython та емулятор CPU Unicorn.

### 1. Знайдіть кожен непрямий стрибок / виклик
```python
import idautils, idc

for ea in idautils.FunctionItems(idc.here()):
mnem = idc.print_insn_mnem(ea)
if mnem in ("jmp", "call") and idc.print_operand(ea, 0) == "rax":
print(f"[+] Dispatcher found @ {ea:X}")
```
### 2. Витягніть байт-код диспетчера
```python
import idc

def get_dispatcher_start(jmp_ea, count=9):
s = jmp_ea
for _ in range(count):
s = idc.prev_head(s, 0)
return s

start = get_dispatcher_start(jmp_ea)
size  = jmp_ea + idc.get_item_size(jmp_ea) - start
code  = idc.get_bytes(start, size)
open(f"{start:X}.bin", "wb").write(code)
```
### 3. Емулюйте його двічі з Unicorn
```python
from unicorn import *
from unicorn.x86_const import *
import struct

def run(code, zf=0, cf=0):
BASE = 0x1000
mu = Uc(UC_ARCH_X86, UC_MODE_64)
mu.mem_map(BASE, 0x1000)
mu.mem_write(BASE, code)
mu.reg_write(UC_X86_REG_RFLAGS, (zf << 6) | cf)
mu.reg_write(UC_X86_REG_RAX, 0)
mu.emu_start(BASE, BASE+len(code))
return mu.reg_read(UC_X86_REG_RAX)
```
Запустіть `run(code,0,0)` та `run(code,1,1)`, щоб отримати цілі *хибної* та *істинної* гілок.

### 4. Виправте прямий перехід / виклик
```python
import struct, ida_bytes

def patch_direct(ea, target, is_call=False):
op   = 0xE8 if is_call else 0xE9           # CALL rel32 or JMP rel32
disp = target - (ea + 5) & 0xFFFFFFFF
ida_bytes.patch_bytes(ea, bytes([op]) + struct.pack('<I', disp))
```
Після патчінгу, примусьте IDA повторно проаналізувати функцію, щоб відновити повну CFG та вихід Hex-Rays:
```python
import ida_auto, idaapi
idaapi.reanalyze_function(idc.get_func_attr(ea, idc.FUNCATTR_START))
```
### 5. Позначте непрямі виклики API

Якщо відомо справжнє призначення кожного `call rax`, ви можете повідомити IDA, що це так, щоб типи параметрів і імена змінних відновлювалися автоматично:
```python
idc.set_callee_name(call_ea, resolved_addr, 0)  # IDA 8.3+
```
### Практичні переваги

* Відновлює реальний CFG → декомпіляція переходить з *10* рядків до тисяч.
* Дозволяє перехресне посилання на рядки та xrefs, що робить реконструкцію поведінки тривіальною.
* Скрипти можна повторно використовувати: просто вставте їх у будь-який завантажувач, захищений тим самим трюком.

---

## Посилання

- [Unit42 – Evolving Tactics of SLOW#TEMPEST: A Deep Dive Into Advanced Malware Techniques](https://unit42.paloaltonetworks.com/slow-tempest-malware-obfuscation/)

{{#include ../../banners/hacktricks-training.md}}
