# マルウェア分析

{{#include ../../banners/hacktricks-training.md}}

## フォレンジック チートシート

[https://www.jaiminton.com/cheatsheet/DFIR/#](https://www.jaiminton.com/cheatsheet/DFIR/)

## オンラインサービス

- [VirusTotal](https://www.virustotal.com/gui/home/upload)
- [HybridAnalysis](https://www.hybrid-analysis.com)
- [Koodous](https://koodous.com)
- [Intezer](https://analyze.intezer.com)
- [Any.Run](https://any.run/)

## オフラインアンチウイルスおよび検出ツール

### Yara

#### インストール
```bash
sudo apt-get install -y yara
```
#### ルールの準備

このスクリプトを使用して、githubからすべてのyaraマルウェアルールをダウンロードしてマージします: [https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9](https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9)\
_**rules**_ ディレクトリを作成し、実行します。これにより、すべてのマルウェア用のyaraルールを含む _**malware_rules.yar**_ というファイルが作成されます。
```bash
wget https://gist.githubusercontent.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9/raw/4ec711d37f1b428b63bed1f786b26a0654aa2f31/malware_yara_rules.py
mkdir rules
python malware_yara_rules.py
```
#### スキャン
```bash
yara -w malware_rules.yar image  #Scan 1 file
yara -w malware_rules.yar folder #Scan the whole folder
```
#### YaraGen: マルウェアのチェックとルールの作成

バイナリから yara ルールを生成するために、ツール [**YaraGen**](https://github.com/Neo23x0/yarGen) を使用できます。これらのチュートリアルをチェックしてください: [**Part 1**](https://www.nextron-systems.com/2015/02/16/write-simple-sound-yara-rules/), [**Part 2**](https://www.nextron-systems.com/2015/10/17/how-to-write-simple-but-sound-yara-rules-part-2/), [**Part 3**](https://www.nextron-systems.com/2016/04/15/how-to-write-simple-but-sound-yara-rules-part-3/)
```bash
python3 yarGen.py --update
python3.exe yarGen.py --excludegood -m  ../../mals/
```
### ClamAV

#### インストール
```
sudo apt-get install -y clamav
```
#### スキャン
```bash
sudo freshclam      #Update rules
clamscan filepath   #Scan 1 file
clamscan folderpath #Scan the whole folder
```
### [Capa](https://github.com/mandiant/capa)

**Capa** は、実行可能ファイル（PE、ELF、.NET）内の潜在的に悪意のある **機能** を検出します。これにより、Att\&ck 戦術や、次のような疑わしい機能を見つけることができます：

- OutputDebugString エラーのチェック
- サービスとして実行
- プロセスの作成

[**Github リポジトリ**](https://github.com/mandiant/capa) から入手できます。

### IOCs

IOC は、妥協の指標（Indicator Of Compromise）を意味します。IOC は、潜在的に望ましくないソフトウェアや確認された **マルウェア** を特定するための **条件のセット** です。ブルーチームは、この種の定義を使用して、**システム** や **ネットワーク** 内のこの種の悪意のあるファイルを **検索** します。\
これらの定義を共有することは非常に有用で、コンピュータ内でマルウェアが特定され、そのマルウェアの IOC が作成されると、他のブルーチームはそれを使用してマルウェアをより迅速に特定できます。

IOC を作成または修正するためのツールは [**IOC Editor**](https://www.fireeye.com/services/freeware/ioc-editor.html)**.**\
[**Redline**](https://www.fireeye.com/services/freeware/redline.html) のようなツールを使用して、**デバイス内の定義された IOC を検索** できます。

### Loki

[**Loki**](https://github.com/Neo23x0/Loki) は、シンプルな妥協の指標のスキャナーです。\
検出は、4つの検出方法に基づいています：
```
1. File Name IOC
Regex match on full file path/name

2. Yara Rule Check
Yara signature matches on file data and process memory

3. Hash Check
Compares known malicious hashes (MD5, SHA1, SHA256) with scanned files

4. C2 Back Connect Check
Compares process connection endpoints with C2 IOCs (new since version v.10)
```
### Linux Malware Detect

[**Linux Malware Detect (LMD)**](https://www.rfxn.com/projects/linux-malware-detect/) は、GNU GPLv2 ライセンスの下でリリースされた Linux 用のマルウェアスキャナーで、共有ホスティング環境で直面する脅威に基づいて設計されています。ネットワークエッジ侵入検知システムからの脅威データを使用して、攻撃に積極的に使用されているマルウェアを抽出し、検出のためのシグネチャを生成します。さらに、脅威データは、LMD チェックアウト機能を使用したユーザーの提出やマルウェアコミュニティリソースからも得られます。

### rkhunter

[**rkhunter**](http://rkhunter.sourceforge.net) のようなツールを使用して、ファイルシステムに対して可能な **rootkits** やマルウェアをチェックすることができます。
```bash
sudo ./rkhunter --check -r / -l /tmp/rkhunter.log [--report-warnings-only] [--skip-keypress]
```
### FLOSS

[**FLOSS**](https://github.com/mandiant/flare-floss)は、異なる技術を使用して実行可能ファイル内の難読化された文字列を見つけようとするツールです。

### PEpper

[PEpper](https://github.com/Th3Hurrican3/PEpper)は、実行可能ファイル内の基本的な情報（バイナリデータ、エントロピー、URLおよびIP、いくつかのyaraルール）をチェックします。

### PEstudio

[PEstudio](https://www.winitor.com/download)は、インポート、エクスポート、ヘッダーなどのWindows実行可能ファイルの情報を取得するツールですが、ウイルス総合チェックも行い、潜在的なAtt\&ck技術を見つけます。

### Detect It Easy(DiE)

[**DiE**](https://github.com/horsicq/Detect-It-Easy/)は、ファイルが**暗号化**されているかどうかを検出し、**パッカー**を見つけるツールです。

### NeoPI

[**NeoPI**](https://github.com/CiscoCXSecurity/NeoPI)は、テキスト/スクリプトファイル内の**難読化**された**暗号化**されたコンテンツを検出するためにさまざまな**統計的手法**を使用するPythonスクリプトです。NeoPIの目的は、**隠れたウェブシェルコードの検出**を支援することです。

### **php-malware-finder**

[**PHP-malware-finder**](https://github.com/nbs-system/php-malware-finder)は、**難読化された**/**不正なコード**や、**マルウェア**/ウェブシェルでよく使用される**PHP**関数を使用しているファイルを検出するために最善を尽くします。

### Apple Binary Signatures

いくつかの**マルウェアサンプル**をチェックする際には、**バイナリの署名**を常に**確認**するべきです。署名した**開発者**がすでに**マルウェア**に関連している可能性があります。
```bash
#Get signer
codesign -vv -d /bin/ls 2>&1 | grep -E "Authority|TeamIdentifier"

#Check if the app’s contents have been modified
codesign --verify --verbose /Applications/Safari.app

#Check if the signature is valid
spctl --assess --verbose /Applications/Safari.app
```
## Detection Techniques

### File Stacking

もしウェブサーバーの**ファイル**を含むフォルダーが**最終更新日**を知っている場合、**ウェブサーバーのすべてのファイルが作成および変更された**日付を**確認**し、いずれかの日付が**疑わしい**場合は、そのファイルを確認してください。

### Baselines

フォルダーのファイルが**変更されるべきではなかった**場合、フォルダーの**元のファイル**の**ハッシュ**を計算し、**現在の**ものと**比較**できます。変更されたものは**疑わしい**です。

### Statistical Analysis

情報がログに保存されている場合、各ウェブサーバーのファイルがどれだけアクセスされたかなどの**統計**を**確認**できます。ウェブシェルがその中の一つかもしれません。

---

## Deobfuscating Dynamic Control-Flow (JMP/CALL RAX Dispatchers)

現代のマルウェアファミリーは、制御フローグラフ（CFG）難読化を大いに悪用しています：直接のジャンプ/コールの代わりに、実行時に宛先を計算し、`jmp rax`または`call rax`を実行します。小さな*ディスパッチャ*（通常は9命令）がCPUの`ZF`/`CF`フラグに応じて最終ターゲットを設定し、静的CFGの回復を完全に破壊します。

この技術は、SLOW#TEMPESTローダーによって示されており、IDAPythonとUnicorn CPUエミュレーターにのみ依存する3ステップのワークフローで打破できます。

### 1. Locate every indirect jump / call
```python
import idautils, idc

for ea in idautils.FunctionItems(idc.here()):
mnem = idc.print_insn_mnem(ea)
if mnem in ("jmp", "call") and idc.print_operand(ea, 0) == "rax":
print(f"[+] Dispatcher found @ {ea:X}")
```
### 2. ディスパッチャーバイトコードを抽出する
```python
import idc

def get_dispatcher_start(jmp_ea, count=9):
s = jmp_ea
for _ in range(count):
s = idc.prev_head(s, 0)
return s

start = get_dispatcher_start(jmp_ea)
size  = jmp_ea + idc.get_item_size(jmp_ea) - start
code  = idc.get_bytes(start, size)
open(f"{start:X}.bin", "wb").write(code)
```
### 3. Unicornで2回エミュレートする
```python
from unicorn import *
from unicorn.x86_const import *
import struct

def run(code, zf=0, cf=0):
BASE = 0x1000
mu = Uc(UC_ARCH_X86, UC_MODE_64)
mu.mem_map(BASE, 0x1000)
mu.mem_write(BASE, code)
mu.reg_write(UC_X86_REG_RFLAGS, (zf << 6) | cf)
mu.reg_write(UC_X86_REG_RAX, 0)
mu.emu_start(BASE, BASE+len(code))
return mu.reg_read(UC_X86_REG_RAX)
```
`run(code,0,0)` と `run(code,1,1)` を実行して *false* および *true* ブランチターゲットを取得します。

### 4. 直接ジャンプ / コールをパッチバックする
```python
import struct, ida_bytes

def patch_direct(ea, target, is_call=False):
op   = 0xE8 if is_call else 0xE9           # CALL rel32 or JMP rel32
disp = target - (ea + 5) & 0xFFFFFFFF
ida_bytes.patch_bytes(ea, bytes([op]) + struct.pack('<I', disp))
```
パッチを適用した後、IDAに関数を再分析させて、完全なCFGとHex-Raysの出力を復元させます:
```python
import ida_auto, idaapi
idaapi.reanalyze_function(idc.get_func_attr(ea, idc.FUNCATTR_START))
```
### 5. 間接API呼び出しにラベルを付ける

`call rax` の実際の宛先がわかると、IDAにそれを伝えることができるため、パラメータの型と変数名が自動的に回復されます:
```python
idc.set_callee_name(call_ea, resolved_addr, 0)  # IDA 8.3+
```
### 実用的な利点

* 実際のCFGを復元 → デコンパイルが*10*行から数千行に増加します。
* 文字列の交差参照とxrefsを可能にし、動作の再構築を簡単にします。
* スクリプトは再利用可能：同じトリックで保護された任意のローダーにドロップできます。

---

## 参考文献

- [Unit42 – Evolving Tactics of SLOW#TEMPEST: A Deep Dive Into Advanced Malware Techniques](https://unit42.paloaltonetworks.com/slow-tempest-malware-obfuscation/)

{{#include ../../banners/hacktricks-training.md}}
