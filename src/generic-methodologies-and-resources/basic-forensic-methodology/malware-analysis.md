# Malware Analysis

{{#include ../../banners/hacktricks-training.md}}

## Forensik-Cheat-Sheets

[https://www.jaiminton.com/cheatsheet/DFIR/#](https://www.jaiminton.com/cheatsheet/DFIR/)

## Online-Dienste

- [VirusTotal](https://www.virustotal.com/gui/home/upload)
- [HybridAnalysis](https://www.hybrid-analysis.com)
- [Koodous](https://koodous.com)
- [Intezer](https://analyze.intezer.com)
- [Any.Run](https://any.run/)

## Offline-Antivirus- und Erkennungstools

### Yara

#### Installation
```bash
sudo apt-get install -y yara
```
#### Regeln vorbereiten

Verwende dieses Skript, um alle yara malware rules von github herunterzuladen und zusammenzuführen: [https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9](https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9)\
Erstelle das _**rules**_ Verzeichnis und führe es aus. Dadurch wird eine Datei mit dem Namen _**malware_rules.yar**_ erstellt, die alle yara rules für malware enthält.
```bash
wget https://gist.githubusercontent.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9/raw/4ec711d37f1b428b63bed1f786b26a0654aa2f31/malware_yara_rules.py
mkdir rules
python malware_yara_rules.py
```
#### Scan
```bash
yara -w malware_rules.yar image  #Scan 1 file
yara -w malware_rules.yar folder #Scan the whole folder
```
#### YaraGen: Auf Malware prüfen und Regeln erstellen

Du kannst das Tool [**YaraGen**](https://github.com/Neo23x0/yarGen) verwenden, um yara rules aus einem binary zu generieren. Schau dir diese Tutorials an: [**Part 1**](https://www.nextron-systems.com/2015/02/16/write-simple-sound-yara-rules/), [**Part 2**](https://www.nextron-systems.com/2015/10/17/how-to-write-simple-but-sound-yara-rules-part-2/), [**Part 3**](https://www.nextron-systems.com/2016/04/15/how-to-write-simple-but-sound-yara-rules-part-3/)
```bash
python3 yarGen.py --update
python3.exe yarGen.py --excludegood -m  ../../mals/
```
### ClamAV

#### Installation
```
sudo apt-get install -y clamav
```
#### Scan
```bash
sudo freshclam      #Update rules
clamscan filepath   #Scan 1 file
clamscan folderpath #Scan the whole folder
```
### [Capa](https://github.com/mandiant/capa)

**Capa** erkennt potenziell bösartige **capabilities** in ausführbaren Dateien: PE, ELF, .NET. Es findet also Dinge wie Att\&ck tactics, oder verdächtige capabilities wie:

- check for OutputDebugString error
- run as a service
- create process

Hol es dir im [**Github repo**](https://github.com/mandiant/capa).

### IOCs

IOC bedeutet Indicator Of Compromise. Ein IOC ist eine Menge von **Bedingungen, die** potenziell unerwünschte Software oder bestätigte **malware** identifizieren. Blue Teams verwenden diese Art von Definition, um **nach dieser Art bösartiger Dateien** in ihren **Systemen** und **Netzwerken** zu suchen.\
Das Teilen dieser Definitionen ist sehr nützlich, denn wenn auf einem Rechner malware identifiziert wird und dafür ein IOC erstellt wird, können andere Blue Teams es nutzen, um die malware schneller zu erkennen.

Ein Tool, um IOCs zu erstellen oder zu bearbeiten, ist [**IOC Editor**](https://www.fireeye.com/services/freeware/ioc-editor.html).\
Man kann Werkzeuge wie [**Redline**](https://www.fireeye.com/services/freeware/redline.html) verwenden, um **nach definierten IOCs auf einem Gerät zu suchen**.

### Loki

[**Loki**](https://github.com/Neo23x0/Loki) ist ein Scanner für Simple Indicators of Compromise.\
Die Erkennung basiert auf vier Erkennungsmethoden:
```
1. File Name IOC
Regex match on full file path/name

2. Yara Rule Check
Yara signature matches on file data and process memory

3. Hash Check
Compares known malicious hashes (MD5, SHA1, SHA256) with scanned files

4. C2 Back Connect Check
Compares process connection endpoints with C2 IOCs (new since version v.10)
```
### Linux Malware Detect

[**Linux Malware Detect (LMD)**](https://www.rfxn.com/projects/linux-malware-detect/) ist ein Malware-Scanner für Linux, veröffentlicht unter der GNU GPLv2-Lizenz, der auf die Bedrohungen ausgelegt ist, denen Shared-Hosting-Umgebungen ausgesetzt sind. Er nutzt Bedrohungsdaten aus Netzwerk-Edge-Intrusion-Detection-Systemen, um Malware zu extrahieren, die aktiv in Angriffen verwendet wird, und erzeugt Signaturen zur Erkennung. Zusätzlich stammen Bedrohungsdaten auch aus Nutzer-Einsendungen über die LMD checkout-Funktion und aus Ressourcen der Malware-Community.

### rkhunter

Tools wie [**rkhunter**](http://rkhunter.sourceforge.net) können verwendet werden, um das Dateisystem auf mögliche **rootkits** und Malware zu überprüfen.
```bash
sudo ./rkhunter --check -r / -l /tmp/rkhunter.log [--report-warnings-only] [--skip-keypress]
```
### FLOSS

[**FLOSS**](https://github.com/mandiant/flare-floss) ist ein Tool, das versucht, obfuskierte Strings in ausführbaren Dateien mithilfe verschiedener Techniken zu finden.

### PEpper

[PEpper ](https://github.com/Th3Hurrican3/PEpper) prüft grundlegende Dinge in der ausführbaren Datei (Binärdaten, Entropie, URLs und IPs, einige yara-Regeln).

### PEstudio

[PEstudio](https://www.winitor.com/download) ist ein Tool, das Informationen zu Windows-Executables wie Imports, Exports, Headern liefert, aber auch Virus Total prüft und potenzielle Att\&ck-Techniken findet.

### Detect It Easy(DiE)

[**DiE**](https://github.com/horsicq/Detect-It-Easy/) ist ein Tool, um zu erkennen, ob eine Datei **verschlüsselt** ist, und um **Packer** zu finden.

### NeoPI

[**NeoPI** ](https://github.com/CiscoCXSecurity/NeoPI) ist ein Python-Skript, das verschiedene **statistische Methoden** verwendet, um **obfuskierte** und **verschlüsselte** Inhalte in Text-/Script-Dateien zu erkennen. Der Zweck von NeoPI ist es, bei der **Erkennung von verstecktem Webshell-Code** zu unterstützen.

### **php-malware-finder**

[**PHP-malware-finder**](https://github.com/nbs-system/php-malware-finder) versucht bestmöglich, **obfuskierten**/**verdächtigen Code** sowie Dateien mit **PHP**-Funktionen zu erkennen, die häufig in **Malware**/Webshells verwendet werden.

### Apple Binary Signatures

Beim Prüfen einer **Malware sample** sollten Sie immer die **Signatur** der Binärdatei prüfen, da der **developer**, der sie signiert hat, möglicherweise bereits mit **malware** in Verbindung steht.
```bash
#Get signer
codesign -vv -d /bin/ls 2>&1 | grep -E "Authority|TeamIdentifier"

#Check if the app’s contents have been modified
codesign --verify --verbose /Applications/Safari.app

#Check if the signature is valid
spctl --assess --verbose /Applications/Safari.app
```
## Erkennungstechniken

### File Stacking

Wenn Sie wissen, dass ein Ordner, der die **Dateien** eines Webservers enthält, **zu einem bestimmten Datum zuletzt aktualisiert wurde**, **prüfen** Sie das **Datum**, an dem alle **Dateien** auf dem **Webserver** erstellt und geändert wurden, und wenn ein Datum **verdächtig** ist, untersuchen Sie diese Datei.

### Baselines

Wenn die **Dateien** eines Ordners **nicht hätten verändert werden dürfen**, können Sie den **hash** der **originalen Dateien** des Ordners berechnen und **mit** den **aktuellen** vergleichen. Alles, was verändert wurde, ist **verdächtig**.

### Statistische Analyse

Wenn die Informationen in Logs gespeichert sind, können Sie **Statistiken prüfen**, z. B. wie oft jede Datei eines Webservers aufgerufen wurde — eine web shell könnte zu den am häufigsten aufgerufenen gehören.

---

### Android in-app native Telemetrie (no root)

Auf Android können Sie nativen Code innerhalb des Ziel-App-Prozesses instrumentieren, indem Sie vor der Initialisierung anderer JNI libs eine kleine Logger-Library vorladen. Das ermöglicht frühe Einsicht in natives Verhalten ohne systemweite Hooks oder root. Ein verbreiteter Ansatz ist SoTap: legen Sie libsotap.so für das passende ABI in das APK und fügen Sie früh einen System.loadLibrary("sotap")-Aufruf ein (z. B. im static initializer oder in Application.onCreate), danach sammeln Sie Logs aus internen/externen Pfaden oder als Fallback Logcat.

Siehe die Android native reversing Seite für Details zur Einrichtung und zu den Log-Pfaden:

{{#ref}}
../../mobile-pentesting/android-app-pentesting/reversing-native-libraries.md
{{#endref}}

---

## Deobfuskation dynamischer Control-Flow (JMP/CALL RAX Dispatchers)

Moderne Malware-Familien missbrauchen stark die Control-Flow Graph (CFG)-Obfuskation: anstatt eines direkten jump/call berechnen sie das Ziel zur Laufzeit und führen einen `jmp rax` oder `call rax` aus. Ein kleiner *dispatcher* (typischerweise neun Instruktionen) legt das endgültige Ziel abhängig von den CPU-Flags `ZF`/`CF` fest und bricht damit die statische CFG-Wiederherstellung vollständig.

Die Technik – demonstriert vom SLOW#TEMPEST loader – lässt sich mit einem dreistufigen Workflow umgehen, der nur auf IDAPython und dem Unicorn CPU emulator basiert.

### 1. Alle indirekten jump / call lokalisieren
```python
import idautils, idc

for ea in idautils.FunctionItems(idc.here()):
mnem = idc.print_insn_mnem(ea)
if mnem in ("jmp", "call") and idc.print_operand(ea, 0) == "rax":
print(f"[+] Dispatcher found @ {ea:X}")
```
### 2. Extrahiere den dispatcher byte-code
```python
import idc

def get_dispatcher_start(jmp_ea, count=9):
s = jmp_ea
for _ in range(count):
s = idc.prev_head(s, 0)
return s

start = get_dispatcher_start(jmp_ea)
size  = jmp_ea + idc.get_item_size(jmp_ea) - start
code  = idc.get_bytes(start, size)
open(f"{start:X}.bin", "wb").write(code)
```
### 3. Emuliere es zweimal mit Unicorn
```python
from unicorn import *
from unicorn.x86_const import *
import struct

def run(code, zf=0, cf=0):
BASE = 0x1000
mu = Uc(UC_ARCH_X86, UC_MODE_64)
mu.mem_map(BASE, 0x1000)
mu.mem_write(BASE, code)
mu.reg_write(UC_X86_REG_RFLAGS, (zf << 6) | cf)
mu.reg_write(UC_X86_REG_RAX, 0)
mu.emu_start(BASE, BASE+len(code))
return mu.reg_read(UC_X86_REG_RAX)
```
Führe `run(code,0,0)` und `run(code,1,1)` aus, um die *false*- bzw. *true*-Branch-Ziele zu ermitteln.

### 4. Direkten jump / call zurückpatchen
```python
import struct, ida_bytes

def patch_direct(ea, target, is_call=False):
op   = 0xE8 if is_call else 0xE9           # CALL rel32 or JMP rel32
disp = target - (ea + 5) & 0xFFFFFFFF
ida_bytes.patch_bytes(ea, bytes([op]) + struct.pack('<I', disp))
```
Nach dem Patchen erzwingen, dass IDA die Funktion neu analysiert, damit das vollständige CFG und die Hex-Rays-Ausgabe wiederhergestellt werden:
```python
import ida_auto, idaapi
idaapi.reanalyze_function(idc.get_func_attr(ea, idc.FUNCATTR_START))
```
### 5. Indirekte API-Aufrufe kennzeichnen

Sobald das tatsächliche Ziel jedes `call rax` bekannt ist, können Sie IDA mitteilen, was es ist, damit Parameter-Typen und Variablennamen automatisch wiederhergestellt werden:
```python
idc.set_callee_name(call_ea, resolved_addr, 0)  # IDA 8.3+
```
### Praktische Vorteile

* Stellt die reale CFG wieder her → Dekomplilierung geht von *10* Zeilen auf Tausende.
* Ermöglicht string-cross-reference & xrefs, macht die Rekonstruktion des Verhaltens trivial.
* Scripts sind wiederverwendbar: Platziere sie in jeden loader, der durch denselben Trick geschützt ist.

---

## Referenzen

- [Unit42 – Evolving Tactics of SLOW#TEMPEST: A Deep Dive Into Advanced Malware Techniques](https://unit42.paloaltonetworks.com/slow-tempest-malware-obfuscation/)
- SoTap: Lightweight in-app JNI (.so) behavior logger – [github.com/RezaArbabBot/SoTap](https://github.com/RezaArbabBot/SoTap)

{{#include ../../banners/hacktricks-training.md}}
