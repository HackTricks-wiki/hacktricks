# Malware Analysis

{{#include ../../banners/hacktricks-training.md}}

## Adli Bilişim CheatSheet'leri

[https://www.jaiminton.com/cheatsheet/DFIR/#](https://www.jaiminton.com/cheatsheet/DFIR/)

## Çevrimiçi Servisler

- [VirusTotal](https://www.virustotal.com/gui/home/upload)
- [HybridAnalysis](https://www.hybrid-analysis.com)
- [Koodous](https://koodous.com)
- [Intezer](https://analyze.intezer.com)
- [Any.Run](https://any.run/)

## Çevrimdışı Antivirus ve Tespit Araçları

### Yara

#### Kurulum
```bash
sudo apt-get install -y yara
```
#### Kuralları Hazırlayın

Bu script'i kullanarak github'tan tüm yara malware kurallarını indirip birleştirin: [https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9](https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9)\
_**rules**_ dizinini oluşturun ve script'i çalıştırın. Bu, tüm malware için yara kurallarını içeren _**malware_rules.yar**_ adlı bir dosya oluşturacaktır.
```bash
wget https://gist.githubusercontent.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9/raw/4ec711d37f1b428b63bed1f786b26a0654aa2f31/malware_yara_rules.py
mkdir rules
python malware_yara_rules.py
```
#### Tarama
```bash
yara -w malware_rules.yar image  #Scan 1 file
yara -w malware_rules.yar folder #Scan the whole folder
```
#### YaraGen: malware için kontrol etme ve kurallar oluşturma

Bir ikili dosyadan yara rules oluşturmak için [**YaraGen**](https://github.com/Neo23x0/yarGen) aracını kullanabilirsiniz. Bu öğreticilere göz atın: [**Part 1**](https://www.nextron-systems.com/2015/02/16/write-simple-sound-yara-rules/), [**Part 2**](https://www.nextron-systems.com/2015/10/17/how-to-write-simple-but-sound-yara-rules-part-2/), [**Part 3**](https://www.nextron-systems.com/2016/04/15/how-to-write-simple-but-sound-yara-rules-part-3/)
```bash
python3 yarGen.py --update
python3.exe yarGen.py --excludegood -m  ../../mals/
```
### ClamAV

#### Kurulum
```
sudo apt-get install -y clamav
```
#### Tarama
```bash
sudo freshclam      #Update rules
clamscan filepath   #Scan 1 file
clamscan folderpath #Scan the whole folder
```
### [Capa](https://github.com/mandiant/capa)

**Capa** yürütülebilirlerde (PE, ELF, .NET) potansiyel olarak kötü amaçlı **capabilities** tespit eder. Bu nedenle Att\&ck tactics gibi öğeleri veya aşağıdaki gibi şüpheli **capabilities**'leri bulur:

- check for OutputDebugString error
- run as a service
- create process

Edinin: [**Github repo**](https://github.com/mandiant/capa).

### IOCs

IOC, Indicator Of Compromise anlamına gelir. Bir IOC, potansiyel olarak istenmeyen bazı yazılımları veya teyit edilmiş **malware**'i tanımlayan bir dizi **conditions that identify**'dir. Blue Teams bu tür tanımları kendi **systems** ve **networks**'lerinde bu tür kötü amaçlı dosyaları **search for this kind of malicious files** için kullanır.\
Bu tanımları paylaşmak çok faydalıdır; çünkü bir bilgisayarda malware tespit edildiğinde ve o malware için bir IOC oluşturulduğunda, diğer Blue Teams bunu malware'i daha hızlı tanımlamak için kullanabilir.

Bir IOC oluşturmak veya değiştirmek için bir araç [**IOC Editor**](https://www.fireeye.com/services/freeware/ioc-editor.html)**.**\
Tanımlanmış IOC'leri bir cihazda aramak için [**Redline**](https://www.fireeye.com/services/freeware/redline.html) gibi araçları kullanabilirsiniz.

### Loki

[**Loki**](https://github.com/Neo23x0/Loki) Simple Indicators of Compromise için bir tarayıcıdır.\
Tespit dört algılama yöntemine dayanır:
```
1. File Name IOC
Regex match on full file path/name

2. Yara Rule Check
Yara signature matches on file data and process memory

3. Hash Check
Compares known malicious hashes (MD5, SHA1, SHA256) with scanned files

4. C2 Back Connect Check
Compares process connection endpoints with C2 IOCs (new since version v.10)
```
### Linux Malware Detect

[**Linux Malware Detect (LMD)**](https://www.rfxn.com/projects/linux-malware-detect/) Linux için GNU GPLv2 lisansı altında yayımlanmış bir malware tarayıcısıdır; paylaşılan hosting ortamlarında karşılaşılan tehditler göz önünde bulundurularak tasarlanmıştır. Ağ kenarı saldırı tespit sistemlerinden gelen tehdit verilerini kullanarak saldırılarda aktif olarak kullanılan malware'i çıkartır ve tespit için imzalar oluşturur. Ayrıca tehdit verileri, LMD checkout feature aracılığıyla yapılan kullanıcı gönderimleri ve malware topluluk kaynaklarından da elde edilir.

### rkhunter

[**rkhunter**](http://rkhunter.sourceforge.net) gibi araçlar, dosya sistemini olası **rootkits** ve malware için kontrol etmek amacıyla kullanılabilir.
```bash
sudo ./rkhunter --check -r / -l /tmp/rkhunter.log [--report-warnings-only] [--skip-keypress]
```
### FLOSS

[**FLOSS**](https://github.com/mandiant/flare-floss) farklı teknikler kullanarak executables içindeki **obfuscated strings**'i bulmaya çalışan bir araçtır.

### PEpper

[PEpper ](https://github.com/Th3Hurrican3/PEpper) executable içinde bazı temel kontrolleri yapar (binary data, entropy, URLs and IPs, some yara rules).

### PEstudio

[PEstudio](https://www.winitor.com/download) imports, exports, headers gibi Windows executables hakkında bilgi edinmenizi sağlayan bir araçtır; ayrıca virus total'u kontrol eder ve potansiyel Att\&ck techniques'leri tespit eder.

### Detect It Easy(DiE)

[**DiE**](https://github.com/horsicq/Detect-It-Easy/) bir dosyanın **encrypted** olup olmadığını tespit etmeye ve ayrıca **packers**'ı bulmaya yarayan bir araçtır.

### NeoPI

[**NeoPI** ](https://github.com/CiscoCXSecurity/NeoPI) metin/script dosyaları içindeki **obfuscated** ve **encrypted** içeriği tespit etmek için çeşitli **statistical methods** kullanan bir Python scriptidir. NeoPI'nin amacı **detection of hidden web shell code** konusunda yardımcı olmaktır.

### **php-malware-finder**

[**PHP-malware-finder**](https://github.com/nbs-system/php-malware-finder) **obfuscated**/**dodgy code**'u tespit etmeye ve sıklıkla **malwares**/webshells'de kullanılan **PHP** functions'larını içeren dosyaları bulmaya çalışır.

### Apple Binary Signatures

Bazı **malware sample**'larını incelerken binary'nin **check the signature**'ını her zaman yapmalısınız; çünkü imzalayan **developer** zaten **related** olarak **malware** ile bağlantılı olabilir.
```bash
#Get signer
codesign -vv -d /bin/ls 2>&1 | grep -E "Authority|TeamIdentifier"

#Check if the app’s contents have been modified
codesign --verify --verbose /Applications/Safari.app

#Check if the signature is valid
spctl --assess --verbose /Applications/Safari.app
```
## Tespit Teknikleri

### File Stacking

Eğer bir klasörün içinde web sunucusunun **dosyalarının** **en son belirli bir tarihte güncellendiğini** biliyorsanız, web sunucusundaki tüm **dosyaların** **oluşturulma ve değiştirilme tarihlerini** **kontrol edin**; herhangi bir tarih **şüpheli** ise o dosyayı inceleyin.

### Baselines

Bir klasörün dosyaları **değiştirilmemiş olması gerektiğinde**, klasörün **orijinal dosyalarının** **hash**'ini hesaplayıp bunları **mevcut** olanlarla **karşılaştırabilirsiniz**. Değişmiş olan her şey **şüpheli** olacaktır.

### Statistical Analysis

Bilgi loglara kaydedildiğinde, **bir web sunucusunun her bir dosyasına kaç kez erişildiği gibi istatistikleri kontrol edebilirsiniz; bir web shell en çok erişilenlerden biri olabilir**.

---

### Android uygulama içi native telemetri (root yok)

Android'de, hedef uygulama sürecinin içinde native kodu, diğer JNI kütüphaneleri başlatılmadan önce küçük bir logger kütüphanesini preload ederek enstrümante edebilirsiniz. Bu, sistem çapında hook'lara veya root'a ihtiyaç duymadan native davranış hakkında erken görünürlük sağlar. Popüler bir yaklaşım SoTap'tır: uygun ABI için libsotap.so dosyasını APK'ya koyup System.loadLibrary("sotap") çağrısını erken (ör. static initializer veya Application.onCreate) enjekte edin, ardından logları internal/external yollarından veya Logcat yedekleme yönteminden toplayın.

Kurulum ayrıntıları ve log yolları için Android native reversing sayfasına bakın:

{{#ref}}
../../../mobile-pentesting/android-app-pentesting/reversing-native-libraries.md
{{#endref}}

---

## Dinamik Kontrol Akışını Deobfuskasyon (JMP/CALL RAX Dispatchers)

Modern kötü amaçlı yazılım aileleri Control-Flow Graph (CFG) obfuskasyonunu yoğun biçimde kötüye kullanır: doğrudan bir jump/call yerine hedefi çalışma zamanında hesaplarlar ve `jmp rax` veya `call rax` yürütürler. Küçük bir *dispatcher* (genellikle dokuz talimat) CPU `ZF`/`CF` flag'lerine bağlı olarak nihai hedefi ayarlar ve statik CFG kurtarmayı tamamen bozar.

Teknik — SLOW#TEMPEST loader tarafından sergilenen — yalnızca IDAPython ve Unicorn CPU emulator'e dayanan üç adımlı bir iş akışıyla alt edilebilir.

### 1. Her dolaylı jump / call'ı bulun
```python
import idautils, idc

for ea in idautils.FunctionItems(idc.here()):
mnem = idc.print_insn_mnem(ea)
if mnem in ("jmp", "call") and idc.print_operand(ea, 0) == "rax":
print(f"[+] Dispatcher found @ {ea:X}")
```
### 2. Dispatcher byte-code'unu çıkarın
```python
import idc

def get_dispatcher_start(jmp_ea, count=9):
s = jmp_ea
for _ in range(count):
s = idc.prev_head(s, 0)
return s

start = get_dispatcher_start(jmp_ea)
size  = jmp_ea + idc.get_item_size(jmp_ea) - start
code  = idc.get_bytes(start, size)
open(f"{start:X}.bin", "wb").write(code)
```
### 3. Unicorn ile onu iki kez emüle et
```python
from unicorn import *
from unicorn.x86_const import *
import struct

def run(code, zf=0, cf=0):
BASE = 0x1000
mu = Uc(UC_ARCH_X86, UC_MODE_64)
mu.mem_map(BASE, 0x1000)
mu.mem_write(BASE, code)
mu.reg_write(UC_X86_REG_RFLAGS, (zf << 6) | cf)
mu.reg_write(UC_X86_REG_RAX, 0)
mu.emu_start(BASE, BASE+len(code))
return mu.reg_read(UC_X86_REG_RAX)
```
`run(code,0,0)` ve `run(code,1,1)` komutlarını çalıştırarak *false* ve *true* dal hedeflerini elde edin.

### 4. Doğrudan jump / call'ı geri yamala
```python
import struct, ida_bytes

def patch_direct(ea, target, is_call=False):
op   = 0xE8 if is_call else 0xE9           # CALL rel32 or JMP rel32
disp = target - (ea + 5) & 0xFFFFFFFF
ida_bytes.patch_bytes(ea, bytes([op]) + struct.pack('<I', disp))
```
patching işleminden sonra, IDA'nın fonksiyonu yeniden analiz etmesini zorlayın, böylece tam CFG ve Hex-Rays çıktısı geri yüklenir:
```python
import ida_auto, idaapi
idaapi.reanalyze_function(idc.get_func_attr(ea, idc.FUNCATTR_START))
```
### 5. Dolaylı API çağrılarını etiketleyin

Her `call rax`'ın gerçek hedefi bilindiğinde, IDA'ya bunun ne olduğunu söyleyebilir ve böylece parametre tipleri & değişken adları otomatik olarak kurtarılır:
```python
idc.set_callee_name(call_ea, resolved_addr, 0)  # IDA 8.3+
```
### Pratik faydalar

* Gerçek CFG'yi geri yükler → decompilation *10* satırdan binlere çıkar.
* string-cross-reference & xrefs'i etkinleştirir, davranışın yeniden yapılandırılmasını kolaylaştırır.
* Scripts yeniden kullanılabilir: bunları aynı hileyle korunan herhangi bir loader'a yerleştirin.

---

## Referanslar

- [Unit42 – Evolving Tactics of SLOW#TEMPEST: A Deep Dive Into Advanced Malware Techniques](https://unit42.paloaltonetworks.com/slow-tempest-malware-obfuscation/)
- SoTap: Hafif uygulama içi JNI (.so) behavior logger – [github.com/RezaArbabBot/SoTap](https://github.com/RezaArbabBot/SoTap)

{{#include ../../banners/hacktricks-training.md}}
