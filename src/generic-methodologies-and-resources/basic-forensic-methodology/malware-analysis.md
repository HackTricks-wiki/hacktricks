# Ανάλυση Κακόβουλου Λογισμικού

{{#include ../../banners/hacktricks-training.md}}

## Φύλλα Συμβουλών Ψηφιακής Εγκληματολογίας

[https://www.jaiminton.com/cheatsheet/DFIR/#](https://www.jaiminton.com/cheatsheet/DFIR/)

## Διαδικτυακές Υπηρεσίες

- [VirusTotal](https://www.virustotal.com/gui/home/upload)
- [HybridAnalysis](https://www.hybrid-analysis.com)
- [Koodous](https://koodous.com)
- [Intezer](https://analyze.intezer.com)
- [Any.Run](https://any.run/)

## Εργαλεία Αντιϊικού και Ανίχνευσης Εκτός Διαδικτύου

### Yara

#### Εγκατάσταση
```bash
sudo apt-get install -y yara
```
#### Ετοιμάστε κανόνες

Χρησιμοποιήστε αυτό το σενάριο για να κατεβάσετε και να συγχωνεύσετε όλους τους κανόνες yara malware από το github: [https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9](https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9)\
Δημιουργήστε τον φάκελο _**rules**_ και εκτελέστε το. Αυτό θα δημιουργήσει ένα αρχείο με όνομα _**malware_rules.yar**_ που περιέχει όλους τους κανόνες yara για malware.
```bash
wget https://gist.githubusercontent.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9/raw/4ec711d37f1b428b63bed1f786b26a0654aa2f31/malware_yara_rules.py
mkdir rules
python malware_yara_rules.py
```
#### Σάρωση
```bash
yara -w malware_rules.yar image  #Scan 1 file
yara -w malware_rules.yar folder #Scan the whole folder
```
#### YaraGen: Έλεγχος για κακόβουλο λογισμικό και Δημιουργία κανόνων

Μπορείτε να χρησιμοποιήσετε το εργαλείο [**YaraGen**](https://github.com/Neo23x0/yarGen) για να δημιουργήσετε κανόνες yara από ένα δυαδικό αρχείο. Δείτε αυτά τα σεμινάρια: [**Μέρος 1**](https://www.nextron-systems.com/2015/02/16/write-simple-sound-yara-rules/), [**Μέρος 2**](https://www.nextron-systems.com/2015/10/17/how-to-write-simple-but-sound-yara-rules-part-2/), [**Μέρος 3**](https://www.nextron-systems.com/2016/04/15/how-to-write-simple-but-sound-yara-rules-part-3/)
```bash
python3 yarGen.py --update
python3.exe yarGen.py --excludegood -m  ../../mals/
```
### ClamAV

#### Εγκατάσταση
```
sudo apt-get install -y clamav
```
#### Σάρωση
```bash
sudo freshclam      #Update rules
clamscan filepath   #Scan 1 file
clamscan folderpath #Scan the whole folder
```
### [Capa](https://github.com/mandiant/capa)

**Capa** ανιχνεύει δυνητικά κακόβουλες **ικανότητες** σε εκτελέσιμα: PE, ELF, .NET. Έτσι θα βρει πράγματα όπως τακτικές Att\&ck ή ύποπτες ικανότητες όπως:

- έλεγχος για σφάλμα OutputDebugString
- εκτέλεση ως υπηρεσία
- δημιουργία διαδικασίας

Αποκτήστε το στο [**Github repo**](https://github.com/mandiant/capa).

### IOCs

IOC σημαίνει Δείκτης Συμβιβασμού. Ένα IOC είναι ένα σύνολο **συνθηκών που προσδιορίζουν** κάποιο δυνητικά ανεπιθύμητο λογισμικό ή επιβεβαιωμένο **κακόβουλο λογισμικό**. Οι Blue Teams χρησιμοποιούν αυτόν τον τύπο ορισμού για να **αναζητούν αυτόν τον τύπο κακόβουλων αρχείων** στα **συστήματα** και **δίκτυά** τους.\
Η κοινή χρήση αυτών των ορισμών είναι πολύ χρήσιμη καθώς όταν ανιχνεύεται κακόβουλο λογισμικό σε έναν υπολογιστή και δημιουργείται ένα IOC για αυτό το κακόβουλο λογισμικό, άλλες Blue Teams μπορούν να το χρησιμοποιήσουν για να προσδιορίσουν το κακόβουλο λογισμικό πιο γρήγορα.

Ένα εργαλείο για τη δημιουργία ή την τροποποίηση IOCs είναι το [**IOC Editor**](https://www.fireeye.com/services/freeware/ioc-editor.html)**.**\
Μπορείτε να χρησιμοποιήσετε εργαλεία όπως το [**Redline**](https://www.fireeye.com/services/freeware/redline.html) για να **αναζητήσετε καθορισμένα IOCs σε μια συσκευή**.

### Loki

[**Loki**](https://github.com/Neo23x0/Loki) είναι ένας σαρωτής για Απλούς Δείκτες Συμβιβασμού.\
Η ανίχνευση βασίζεται σε τέσσερις μεθόδους ανίχνευσης:
```
1. File Name IOC
Regex match on full file path/name

2. Yara Rule Check
Yara signature matches on file data and process memory

3. Hash Check
Compares known malicious hashes (MD5, SHA1, SHA256) with scanned files

4. C2 Back Connect Check
Compares process connection endpoints with C2 IOCs (new since version v.10)
```
### Linux Malware Detect

[**Linux Malware Detect (LMD)**](https://www.rfxn.com/projects/linux-malware-detect/) είναι ένας σαρωτής κακόβουλου λογισμικού για Linux που κυκλοφορεί υπό την άδεια GNU GPLv2, σχεδιασμένος γύρω από τις απειλές που αντιμετωπίζονται σε κοινά φιλοξενούμενα περιβάλλοντα. Χρησιμοποιεί δεδομένα απειλών από συστήματα ανίχνευσης εισβολών στο δίκτυο για να εξάγει κακόβουλο λογισμικό που χρησιμοποιείται ενεργά σε επιθέσεις και δημιουργεί υπογραφές για ανίχνευση. Επιπλέον, τα δεδομένα απειλών προέρχονται επίσης από υποβολές χρηστών με τη δυνατότητα checkout του LMD και πόρους της κοινότητας κακόβουλου λογισμικού.

### rkhunter

Εργαλεία όπως το [**rkhunter**](http://rkhunter.sourceforge.net) μπορούν να χρησιμοποιηθούν για να ελέγξουν το σύστημα αρχείων για πιθανά **rootkits** και κακόβουλο λογισμικό.
```bash
sudo ./rkhunter --check -r / -l /tmp/rkhunter.log [--report-warnings-only] [--skip-keypress]
```
### FLOSS

[**FLOSS**](https://github.com/mandiant/flare-floss) είναι ένα εργαλείο που θα προσπαθήσει να βρει κρυμμένες συμβολοσειρές μέσα σε εκτελέσιμα αρχεία χρησιμοποιώντας διάφορες τεχνικές.

### PEpper

[PEpper ](https://github.com/Th3Hurrican3/PEpper)ελέγχει κάποια βασικά στοιχεία μέσα στο εκτελέσιμο (δυαδικά δεδομένα, εντροπία, URLs και IPs, κάποιους κανόνες yara).

### PEstudio

[PEstudio](https://www.winitor.com/download) είναι ένα εργαλείο που επιτρέπει την απόκτηση πληροφοριών για εκτελέσιμα Windows όπως εισαγωγές, εξαγωγές, κεφαλίδες, αλλά θα ελέγξει επίσης το virus total και θα βρει πιθανές τεχνικές Att\&ck.

### Detect It Easy(DiE)

[**DiE**](https://github.com/horsicq/Detect-It-Easy/) είναι ένα εργαλείο για να ανιχνεύει αν ένα αρχείο είναι **κρυπτογραφημένο** και επίσης να βρίσκει **πακετάρισμα**.

### NeoPI

[**NeoPI** ](https://github.com/CiscoCXSecurity/NeoPI)είναι ένα σενάριο Python που χρησιμοποιεί μια ποικιλία **στατιστικών μεθόδων** για να ανιχνεύει **κρυμμένο** και **κρυπτογραφημένο** περιεχόμενο μέσα σε αρχεία κειμένου/σεναρίων. Ο προορισμός του NeoPI είναι να βοηθήσει στην **ανίχνευση κρυφού κώδικα web shell**.

### **php-malware-finder**

[**PHP-malware-finder**](https://github.com/nbs-system/php-malware-finder) κάνει το καλύτερο δυνατό για να ανιχνεύσει **κρυμμένο**/**ύποπτο κώδικα** καθώς και αρχεία που χρησιμοποιούν συναρτήσεις **PHP** που συχνά χρησιμοποιούνται σε **malwares**/webshells.

### Apple Binary Signatures

Όταν ελέγχετε κάποιο **δείγμα malware** θα πρέπει πάντα να **ελέγχετε την υπογραφή** του δυαδικού αρχείου καθώς ο **προγραμματιστής** που το υπέγραψε μπορεί ήδη να είναι **σχετικός** με **malware.**
```bash
#Get signer
codesign -vv -d /bin/ls 2>&1 | grep -E "Authority|TeamIdentifier"

#Check if the app’s contents have been modified
codesign --verify --verbose /Applications/Safari.app

#Check if the signature is valid
spctl --assess --verbose /Applications/Safari.app
```
## Τεχνικές Ανίχνευσης

### Συσσώρευση Αρχείων

Αν γνωρίζετε ότι κάποιο φάκελο που περιέχει τα **αρχεία** ενός web server **ενημερώθηκε τελευταία σε κάποια ημερομηνία**. **Ελέγξτε** την **ημερομηνία** που δημιουργήθηκαν και τροποποιήθηκαν όλα τα **αρχεία** στον **web server** και αν κάποια ημερομηνία είναι **ύποπτη**, ελέγξτε αυτό το αρχείο.

### Βασικές Γραμμές

Αν τα αρχεία ενός φακέλου **δεν έπρεπε να έχουν τροποποιηθεί**, μπορείτε να υπολογίσετε το **hash** των **αρχικών αρχείων** του φακέλου και να **συγκρίνετε** τα με τα **τρέχοντα**. Οτιδήποτε τροποποιηθεί θα είναι **ύποπτο**.

### Στατιστική Ανάλυση

Όταν οι πληροφορίες αποθηκεύονται σε logs μπορείτε να **ελέγξετε στατιστικά όπως πόσες φορές κάθε αρχείο ενός web server προσπελάστηκε καθώς ένα web shell μπορεί να είναι ένα από τα πιο**.

---

## Αποκατάσταση Δυναμικού Έλεγχου Ροής (JMP/CALL RAX Dispatchers)

Οι σύγχρονες οικογένειες κακόβουλου λογισμικού εκμεταλλεύονται έντονα την απόκρυψη του Γραφήματος Ροής Ελέγχου (CFG): αντί για άμεσο άλμα/κλήση υπολογίζουν τον προορισμό κατά την εκτέλεση και εκτελούν ένα `jmp rax` ή `call rax`. Ένας μικρός *dispatcher* (συνήθως εννέα εντολές) καθορίζει τον τελικό στόχο ανάλογα με τις σημαίες `ZF`/`CF` της CPU, σπάζοντας εντελώς την στατική ανάκτηση CFG.

Η τεχνική – που παρουσιάζεται από τον φορτωτή SLOW#TEMPEST – μπορεί να καταπολεμηθεί με μια ροή εργασίας τριών βημάτων που βασίζεται μόνο στο IDAPython και τον εξομοιωτή CPU Unicorn.

### 1. Εντοπίστε κάθε έμμεσο άλμα / κλήση
```python
import idautils, idc

for ea in idautils.FunctionItems(idc.here()):
mnem = idc.print_insn_mnem(ea)
if mnem in ("jmp", "call") and idc.print_operand(ea, 0) == "rax":
print(f"[+] Dispatcher found @ {ea:X}")
```
### 2. Εξαγωγή του byte-code του dispatcher
```python
import idc

def get_dispatcher_start(jmp_ea, count=9):
s = jmp_ea
for _ in range(count):
s = idc.prev_head(s, 0)
return s

start = get_dispatcher_start(jmp_ea)
size  = jmp_ea + idc.get_item_size(jmp_ea) - start
code  = idc.get_bytes(start, size)
open(f"{start:X}.bin", "wb").write(code)
```
### 3. Εξομοιώστε το δύο φορές με Unicorn
```python
from unicorn import *
from unicorn.x86_const import *
import struct

def run(code, zf=0, cf=0):
BASE = 0x1000
mu = Uc(UC_ARCH_X86, UC_MODE_64)
mu.mem_map(BASE, 0x1000)
mu.mem_write(BASE, code)
mu.reg_write(UC_X86_REG_RFLAGS, (zf << 6) | cf)
mu.reg_write(UC_X86_REG_RAX, 0)
mu.emu_start(BASE, BASE+len(code))
return mu.reg_read(UC_X86_REG_RAX)
```
Εκτελέστε `run(code,0,0)` και `run(code,1,1)` για να αποκτήσετε τους στόχους του *ψευδούς* και *αληθινού* κλάδου.

### 4. Επαναφορά άμεσου άλματος / κλήσης
```python
import struct, ida_bytes

def patch_direct(ea, target, is_call=False):
op   = 0xE8 if is_call else 0xE9           # CALL rel32 or JMP rel32
disp = target - (ea + 5) & 0xFFFFFFFF
ida_bytes.patch_bytes(ea, bytes([op]) + struct.pack('<I', disp))
```
Μετά την επιδιόρθωση, αναγκάστε το IDA να αναλύσει ξανά τη συνάρτηση ώστε να αποκατασταθούν το πλήρες CFG και η έξοδος Hex-Rays:
```python
import ida_auto, idaapi
idaapi.reanalyze_function(idc.get_func_attr(ea, idc.FUNCATTR_START))
```
### 5. Επισήμανση έμμεσων κλήσεων API

Μόλις είναι γνωστός ο πραγματικός προορισμός κάθε `call rax`, μπορείτε να πείτε στο IDA τι είναι, ώστε οι τύποι παραμέτρων και τα ονόματα μεταβλητών να ανακτηθούν αυτόματα:
```python
idc.set_callee_name(call_ea, resolved_addr, 0)  # IDA 8.3+
```
### Πρακτικά οφέλη

* Αποκαθιστά το πραγματικό CFG → η αποσυναρμολόγηση πηγαίνει από *10* γραμμές σε χιλιάδες.
* Διευκολύνει τη διασταύρωση συμβολοσειρών & xrefs, καθιστώντας την ανακατασκευή συμπεριφοράς απλή.
* Τα σενάρια είναι επαναχρησιμοποιήσιμα: ρίξτε τα σε οποιονδήποτε φορτωτή προστατευμένο από το ίδιο κόλπο.

---

## Αναφορές

- [Unit42 – Evolving Tactics of SLOW#TEMPEST: A Deep Dive Into Advanced Malware Techniques](https://unit42.paloaltonetworks.com/slow-tempest-malware-obfuscation/)

{{#include ../../banners/hacktricks-training.md}}
