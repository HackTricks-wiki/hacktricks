# Malware Analizi

{{#include ../../banners/hacktricks-training.md}}

## Adli Bilimler Hızlı Referansları

[https://www.jaiminton.com/cheatsheet/DFIR/#](https://www.jaiminton.com/cheatsheet/DFIR/)

## Çevrimiçi Hizmetler

- [VirusTotal](https://www.virustotal.com/gui/home/upload)
- [HybridAnalysis](https://www.hybrid-analysis.com)
- [Koodous](https://koodous.com)
- [Intezer](https://analyze.intezer.com)
- [Any.Run](https://any.run/)

## Çevrimdışı Antivirüs ve Tespit Araçları

### Yara

#### Kurulum
```bash
sudo apt-get install -y yara
```
#### Kuralları Hazırlayın

Use this script to download and merge all the yara malware rules from github: [https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9](https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9)\
Create the _**rules**_ directory and execute it. This will create a file called _**malware_rules.yar**_ which contains all the yara rules for malware.
```bash
wget https://gist.githubusercontent.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9/raw/4ec711d37f1b428b63bed1f786b26a0654aa2f31/malware_yara_rules.py
mkdir rules
python malware_yara_rules.py
```
#### Tarama
```bash
yara -w malware_rules.yar image  #Scan 1 file
yara -w malware_rules.yar folder #Scan the whole folder
```
#### YaraGen: Kötü amaçlı yazılımı kontrol et ve kurallar oluştur

Binary'den yara kuralları oluşturmak için [**YaraGen**](https://github.com/Neo23x0/yarGen) aracını kullanabilirsiniz. Bu eğitimlere göz atın: [**Bölüm 1**](https://www.nextron-systems.com/2015/02/16/write-simple-sound-yara-rules/), [**Bölüm 2**](https://www.nextron-systems.com/2015/10/17/how-to-write-simple-but-sound-yara-rules-part-2/), [**Bölüm 3**](https://www.nextron-systems.com/2016/04/15/how-to-write-simple-but-sound-yara-rules-part-3/)
```bash
python3 yarGen.py --update
python3.exe yarGen.py --excludegood -m  ../../mals/
```
### ClamAV

#### Kurulum
```
sudo apt-get install -y clamav
```
#### Tarama
```bash
sudo freshclam      #Update rules
clamscan filepath   #Scan 1 file
clamscan folderpath #Scan the whole folder
```
### [Capa](https://github.com/mandiant/capa)

**Capa**, potansiyel olarak zararlı **yetenekleri** yürütülebilir dosyalarda tespit eder: PE, ELF, .NET. Bu nedenle, Att\&ck taktikleri veya aşağıdaki gibi şüpheli yetenekler gibi şeyleri bulacaktır:

- OutputDebugString hatasını kontrol et
- hizmet olarak çalış
- işlem oluştur

Bunu [**Github repo**](https://github.com/mandiant/capa) üzerinden edinebilirsiniz.

### IOCs

IOC, Kompromi Göstergesi anlamına gelir. Bir IOC, bazı potansiyel olarak istenmeyen yazılımları veya onaylanmış **kötü amaçlı yazılımları** tanımlayan bir **koşullar setidir**. Mavi Takımlar, bu tür tanımları **sistemlerinde** ve **ağlarında** bu tür kötü amaçlı dosyaları **arama** amacıyla kullanır.\
Bu tanımları paylaşmak çok faydalıdır çünkü bir bilgisayarda kötü amaçlı yazılım tespit edildiğinde ve o kötü amaçlı yazılım için bir IOC oluşturulduğunda, diğer Mavi Takımlar bunu kötü amaçlı yazılımı daha hızlı tanımlamak için kullanabilir.

IOC'leri oluşturmak veya değiştirmek için bir araç [**IOC Editor**](https://www.fireeye.com/services/freeware/ioc-editor.html)**.**\
Tanımlı IOCs'leri bir cihazda **arama** yapmak için [**Redline**](https://www.fireeye.com/services/freeware/redline.html) gibi araçları kullanabilirsiniz.

### Loki

[**Loki**](https://github.com/Neo23x0/Loki), Basit Kompromi Göstergeleri için bir tarayıcıdır.\
Tespit, dört tespit yöntemine dayanmaktadır:
```
1. File Name IOC
Regex match on full file path/name

2. Yara Rule Check
Yara signature matches on file data and process memory

3. Hash Check
Compares known malicious hashes (MD5, SHA1, SHA256) with scanned files

4. C2 Back Connect Check
Compares process connection endpoints with C2 IOCs (new since version v.10)
```
### Linux Malware Detect

[**Linux Malware Detect (LMD)**](https://www.rfxn.com/projects/linux-malware-detect/) , paylaşımlı barındırma ortamlarında karşılaşılan tehditler etrafında tasarlanmış, GNU GPLv2 lisansı altında yayımlanan bir Linux kötü amaçlı yazılım tarayıcısıdır. Saldırılarda aktif olarak kullanılan kötü amaçlı yazılımları çıkarmak ve tespit için imzalar oluşturmak amacıyla ağ kenarı saldırı tespit sistemlerinden tehdit verilerini kullanır. Ayrıca, tehdit verileri LMD ödeme özelliği ile kullanıcı gönderimlerinden ve kötü amaçlı yazılım topluluğu kaynaklarından da elde edilmektedir.

### rkhunter

[**rkhunter**](http://rkhunter.sourceforge.net) gibi araçlar, dosya sistemini olası **rootkit** ve kötü amaçlı yazılımlar için kontrol etmek amacıyla kullanılabilir.
```bash
sudo ./rkhunter --check -r / -l /tmp/rkhunter.log [--report-warnings-only] [--skip-keypress]
```
### FLOSS

[**FLOSS**](https://github.com/mandiant/flare-floss) bir dizi teknik kullanarak yürütülebilir dosyalar içinde obfuscate edilmiş dizeleri bulmaya çalışan bir araçtır.

### PEpper

[PEpper ](https://github.com/Th3Hurrican3/PEpper) yürütülebilir dosya içinde bazı temel şeyleri (ikili veriler, entropi, URL'ler ve IP'ler, bazı yara kuralları) kontrol eder.

### PEstudio

[PEstudio](https://www.winitor.com/download) Windows yürütülebilir dosyaları hakkında bilgi almayı sağlayan bir araçtır; örneğin, ithalatlar, ihracatlar, başlıklar gibi bilgileri alır, ayrıca virüs toplamını kontrol eder ve potansiyel Att\&ck tekniklerini bulur.

### Detect It Easy(DiE)

[**DiE**](https://github.com/horsicq/Detect-It-Easy/) bir dosyanın **şifreli** olup olmadığını tespit etmek ve ayrıca **paketleyicileri** bulmak için kullanılan bir araçtır.

### NeoPI

[**NeoPI** ](https://github.com/CiscoCXSecurity/NeoPI) metin/script dosyaları içinde **obfuscate** edilmiş ve **şifreli** içeriği tespit etmek için çeşitli **istatistiksel yöntemler** kullanan bir Python betiğidir. NeoPI'nin amacı, **gizli web shell kodunun** tespitine yardımcı olmaktır.

### **php-malware-finder**

[**PHP-malware-finder**](https://github.com/nbs-system/php-malware-finder) **obfuscate** edilmiş/**şüpheli kod** ile birlikte, genellikle **malware**/webshell'lerde kullanılan **PHP** fonksiyonlarını içeren dosyaları tespit etmek için elinden gelenin en iyisini yapar.

### Apple Binary Signatures

Bazı **malware örneklerini** kontrol ederken, imzayı her zaman **kontrol etmelisiniz** çünkü imzayı atan **geliştirici** zaten **malware** ile **ilişkili** olabilir.
```bash
#Get signer
codesign -vv -d /bin/ls 2>&1 | grep -E "Authority|TeamIdentifier"

#Check if the app’s contents have been modified
codesign --verify --verbose /Applications/Safari.app

#Check if the signature is valid
spctl --assess --verbose /Applications/Safari.app
```
## Tespit Teknikleri

### Dosya Yığma

Eğer bir web sunucusunun **dosyalarını** içeren bir klasörün **son güncellenme tarihini** biliyorsanız, **web sunucusundaki tüm dosyaların oluşturulma ve değiştirilme tarihlerini kontrol edin** ve eğer herhangi bir tarih **şüpheli** ise, o dosyayı kontrol edin.

### Temel Değerler

Eğer bir klasörün dosyaları **değiştirilmemiş olmalıysa**, klasörün **orijinal dosyalarının** **hash'ini** hesaplayabilir ve bunları **mevcut** olanlarla **karşılaştırabilirsiniz**. Değiştirilen herhangi bir şey **şüpheli** olacaktır.

### İstatistiksel Analiz

Bilgiler günlüklerde saklandığında, her bir web sunucusu dosyasının ne kadar sıklıkla erişildiğini kontrol edebilirsiniz; çünkü bir web shell en çok erişilenlerden biri olabilir.

---

## Dinamik Kontrol Akışını Deşifre Etme (JMP/CALL RAX Dağıtıcıları)

Modern kötü amaçlı yazılım aileleri Kontrol Akış Grafiği (CFG) obfuscation'ı yoğun bir şekilde kötüye kullanmaktadır: doğrudan bir atlama/çağrı yerine, hedefi çalışma zamanında hesaplar ve `jmp rax` veya `call rax` komutunu yürütür. Küçük bir *dağıtıcı* (genellikle dokuz talimat) CPU `ZF`/`CF` bayraklarına bağlı olarak son hedefi belirler ve statik CFG geri kazanımını tamamen bozar.

SLOW#TEMPEST yükleyicisi tarafından sergilenen bu teknik, yalnızca IDAPython ve Unicorn CPU emülatörüne dayanan üç adımlı bir iş akışı ile yenilebilir.

### 1. Her dolaylı atlama / çağrıyı bulun
```python
import idautils, idc

for ea in idautils.FunctionItems(idc.here()):
mnem = idc.print_insn_mnem(ea)
if mnem in ("jmp", "call") and idc.print_operand(ea, 0) == "rax":
print(f"[+] Dispatcher found @ {ea:X}")
```
### 2. Dispatcher byte-code'u çıkarın
```python
import idc

def get_dispatcher_start(jmp_ea, count=9):
s = jmp_ea
for _ in range(count):
s = idc.prev_head(s, 0)
return s

start = get_dispatcher_start(jmp_ea)
size  = jmp_ea + idc.get_item_size(jmp_ea) - start
code  = idc.get_bytes(start, size)
open(f"{start:X}.bin", "wb").write(code)
```
### 3. Unicorn ile iki kez taklit et
```python
from unicorn import *
from unicorn.x86_const import *
import struct

def run(code, zf=0, cf=0):
BASE = 0x1000
mu = Uc(UC_ARCH_X86, UC_MODE_64)
mu.mem_map(BASE, 0x1000)
mu.mem_write(BASE, code)
mu.reg_write(UC_X86_REG_RFLAGS, (zf << 6) | cf)
mu.reg_write(UC_X86_REG_RAX, 0)
mu.emu_start(BASE, BASE+len(code))
return mu.reg_read(UC_X86_REG_RAX)
```
`run(code,0,0)` ve `run(code,1,1)` komutlarını çalıştırarak *false* ve *true* dal hedeflerini elde edin.

### 4. Doğrudan bir atlama / çağrıyı geri düzeltin
```python
import struct, ida_bytes

def patch_direct(ea, target, is_call=False):
op   = 0xE8 if is_call else 0xE9           # CALL rel32 or JMP rel32
disp = target - (ea + 5) & 0xFFFFFFFF
ida_bytes.patch_bytes(ea, bytes([op]) + struct.pack('<I', disp))
```
Yamanlamadan sonra, IDA'yı fonksiyonu yeniden analiz etmeye zorlayarak tam CFG ve Hex-Rays çıktısının geri yüklenmesini sağlayın:
```python
import ida_auto, idaapi
idaapi.reanalyze_function(idc.get_func_attr(ea, idc.FUNCATTR_START))
```
### 5. Dolaylı API çağrılarını etiketle

Her `call rax`'ın gerçek hedefi bilindiğinde, IDA'ya bunun ne olduğunu söyleyebilir ve böylece parametre türleri ve değişken adları otomatik olarak geri kazanılır:
```python
idc.set_callee_name(call_ea, resolved_addr, 0)  # IDA 8.3+
```
### Pratik faydalar

* Gerçek CFG'yi geri yükler → dekompilasyon *10* satırdan binlerce satıra çıkar.
* String çapraz referansı ve xrefs'i etkinleştirir, davranış yeniden yapılandırmasını basit hale getirir.
* Scriptler yeniden kullanılabilir: bunları aynı hileyle korunan herhangi bir yükleyiciye bırakın.

---

## Referanslar

- [Unit42 – Evolving Tactics of SLOW#TEMPEST: A Deep Dive Into Advanced Malware Techniques](https://unit42.paloaltonetworks.com/slow-tempest-malware-obfuscation/)

{{#include ../../banners/hacktricks-training.md}}
