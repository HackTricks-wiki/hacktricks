# Malware-analise

{{#include ../../banners/hacktricks-training.md}}

## Forensiese CheatSheets

[https://www.jaiminton.com/cheatsheet/DFIR/#](https://www.jaiminton.com/cheatsheet/DFIR/)

## Aanlyn Dienste

- [VirusTotal](https://www.virustotal.com/gui/home/upload)
- [HybridAnalysis](https://www.hybrid-analysis.com)
- [Koodous](https://koodous.com)
- [Intezer](https://analyze.intezer.com)
- [Any.Run](https://any.run/)

## Aflyn antivirus- en opsporingshulpmiddels

### Yara

#### Installeer
```bash
sudo apt-get install -y yara
```
#### Berei reëls voor

Gebruik hierdie script om al die yara-reëls vir malware van github af te laai en saam te voeg: [https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9](https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9)\
Skep die _**rules**_ gids en voer dit uit. Dit sal 'n lêer met die naam _**malware_rules.yar**_ skep wat al die yara-reëls vir malware bevat.
```bash
wget https://gist.githubusercontent.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9/raw/4ec711d37f1b428b63bed1f786b26a0654aa2f31/malware_yara_rules.py
mkdir rules
python malware_yara_rules.py
```
#### Skandering
```bash
yara -w malware_rules.yar image  #Scan 1 file
yara -w malware_rules.yar folder #Scan the whole folder
```
#### YaraGen: Kontroleer vir malware en skep reëls

Jy kan die gereedskap [**YaraGen**](https://github.com/Neo23x0/yarGen) gebruik om yara rules van 'n binaêr te genereer. Kyk na hierdie handleidings: [**Part 1**](https://www.nextron-systems.com/2015/02/16/write-simple-sound-yara-rules/), [**Part 2**](https://www.nextron-systems.com/2015/10/17/how-to-write-simple-but-sound-yara-rules-part-2/), [**Part 3**](https://www.nextron-systems.com/2016/04/15/how-to-write-simple-but-sound-yara-rules-part-3/)
```bash
python3 yarGen.py --update
python3.exe yarGen.py --excludegood -m  ../../mals/
```
### ClamAV

#### Installeer
```
sudo apt-get install -y clamav
```
#### Skandering
```bash
sudo freshclam      #Update rules
clamscan filepath   #Scan 1 file
clamscan folderpath #Scan the whole folder
```
### [Capa](https://github.com/mandiant/capa)

**Capa** detecteer potensieel kwaadwillige **capabilities** in uitvoerbare lêers: PE, ELF, .NET. Dit sal dus dinge soos Att\&ck tactics vind, of verdagte capabilities soos:

- check for OutputDebugString error
- run as a service
- create process

Get it int he [**Github repo**](https://github.com/mandiant/capa).

### IOCs

IOC means Indicator Of Compromise. 'n IOC is 'n stel **conditions that identify** sekere moontlik ongewenste sagteware of bevestigde **malware**. Blue Teams gebruik hierdie soort definisie om **soortgelyke kwaadaardige lêers in hul stelsels en netwerke te soek**.\
Om hierdie definisies te deel is baie nuttig, want wanneer malware in 'n rekenaar geïdentifiseer word en 'n IOC vir daardie malware geskep word, kan ander Blue Teams dit gebruik om die malware vinniger te identifiseer.

'n Gereedskap om IOCs te skep of te wysig is [**IOC Editor**](https://www.fireeye.com/services/freeware/ioc-editor.html)**.**\
Jy kan gereedskap soos [**Redline**](https://www.fireeye.com/services/freeware/redline.html) gebruik om **naar gedefinieerde IOCs op 'n toestel te soek**.

### Loki

[**Loki**](https://github.com/Neo23x0/Loki) is 'n scanner vir Simple Indicators of Compromise.\
Opsporing is gebaseer op vier opsporingsmetodes:
```
1. File Name IOC
Regex match on full file path/name

2. Yara Rule Check
Yara signature matches on file data and process memory

3. Hash Check
Compares known malicious hashes (MD5, SHA1, SHA256) with scanned files

4. C2 Back Connect Check
Compares process connection endpoints with C2 IOCs (new since version v.10)
```
### Linux Malware Detect

[**Linux Malware Detect (LMD)**](https://www.rfxn.com/projects/linux-malware-detect/) is 'n malware-skandeerder vir Linux, vrygestel onder die GNU GPLv2-lisensie, wat ontwerp is rondom die bedreigings wat in gedeelde gehuisveste omgewings voorkom. Dit gebruik bedreigingsdata van network edge intrusion detection systems om malware wat aktief in aanvalle gebruik word te onttrek en signatures vir deteksie te genereer. Daarbenewens word bedreigingsdata ook verkry uit gebruikersinskrywings via die LMD checkout-feature en uit malware-gemeenskapsbronne.

### rkhunter

Gereedskap soos [**rkhunter**](http://rkhunter.sourceforge.net) kan gebruik word om die lêerstelsel te kontroleer vir moontlike **rootkits** en malware.
```bash
sudo ./rkhunter --check -r / -l /tmp/rkhunter.log [--report-warnings-only] [--skip-keypress]
```
### FLOSS

[**FLOSS**](https://github.com/mandiant/flare-floss) is 'n instrument wat probeer om geobfuskiseerde stringe binne uitvoerbare lêers te vind met verskeie tegnieke.

### PEpper

[PEpper ](https://github.com/Th3Hurrican3/PEpper)kontroleer 'n paar basiese dinge in die uitvoerbare lêer (binaire data, entropie, URLs en IP-adresse, sommige yara-reëls).

### PEstudio

[PEstudio](https://www.winitor.com/download) is 'n instrument wat inligting oor Windows-uitvoerbare lêers verskaf, soos imports, exports en headers, en sal ook VirusTotal nagaan en potensiële Att\&ck-tegnieke vind.

### Detect It Easy(DiE)

[**DiE**](https://github.com/horsicq/Detect-It-Easy/) is 'n instrument om te bepaal of 'n lêer **versleuteld** is en om ook **packers** te vind.

### NeoPI

[**NeoPI** ](https://github.com/CiscoCXSecurity/NeoPI)is 'n Python-skrip wat 'n verskeidenheid **statistiese metodes** gebruik om **geobfuskiseerde** en **versleutelde** inhoud binne teks-/skriplêers te identifiseer. Die beoogde doel van NeoPI is om te help met die **identifisering van verborge web shell-kode**.

### **php-malware-finder**

[**PHP-malware-finder**](https://github.com/nbs-system/php-malware-finder) doen sy uiterste bes om **geobfuskiseerde**/**verdagte kode** te identifiseer, asook lêers wat **PHP**-funksies gebruik wat dikwels in **malware**/webshells aangetref word.

### Apple Binary Signatures

Wanneer jy 'n **malware sample** nagaan, moet jy altyd die **handtekening** van die binêr **kontroleer**, aangesien die **ontwikkelaar** wat dit geteken het moontlik reeds **verwant** is aan **malware.**
```bash
#Get signer
codesign -vv -d /bin/ls 2>&1 | grep -E "Authority|TeamIdentifier"

#Check if the app’s contents have been modified
codesign --verify --verbose /Applications/Safari.app

#Check if the signature is valid
spctl --assess --verbose /Applications/Safari.app
```
## Detection Techniques

### File Stacking

If you know that some folder containing the **files** of a web server was **last updated on some date**. **Check** the **date** all the **files** in the **web server were created and modified** and if any date is **suspicious**, check that file.

As jy weet dat 'n vouer wat die **lêers** van 'n **web server** bevat **laas bygewerk is op 'n bepaalde datum**, **kontroleer** die **datum** waarop al die **lêers** in die **web server** geskep en gewysig is; as enige datum **verdag** is, ondersoek daardie lêer.

### Baselines

If the files of a folder **shouldn't have been modified**, you can calculate the **hash** of the **original files** of the folder and **compare** them with the **current** ones. Anything modified will be **suspicious**.

As die **lêers** van 'n vouer **nie gewysig moes gewees het nie**, kan jy die **hash** van die ** oorspronklike lêers ** van die vouer bereken en dit met die **huidige** vergelyk. Alles wat gewysig is, sal **verdag** wees.

### Statistical Analysis

When the information is saved in logs you can **check statistics like how many times each file of a web server was accessed as a web shell might be one of the most**.

Wanneer die inligting in logs gestoor word, kan jy **statistieke nagaan**, byvoorbeeld hoe dikwels elke lêer van 'n web server geraadpleeg is — 'n web shell kan een van die mees-toeganklike wees.

---

### Android in-app native telemetry (no root)

On Android, you can instrument native code inside the target app process by preloading a tiny logger library before other JNI libs initialize. This gives early visibility into native behavior without system-wide hooks or root. A popular approach is SoTap: drop libsotap.so for the right ABI into the APK and inject a System.loadLibrary("sotap") call early (e.g., static initializer or Application.onCreate), then collect logs from internal/external paths or Logcat fallback.

Op Android kan jy native code binne die teiken-app-proses instrumenteer deur 'n klein logger-biblioteek vooraf te laai voordat ander JNI-libs inisieer. Dit gee vroeë sigbaarheid in native gedrag sonder stelsel-wyde hooks of root. 'n Populêre benadering is SoTap: plaas libsotap.so vir die regte ABI in die APK en injekteer vroeg 'n System.loadLibrary("sotap") oproep (bv. static initializer of Application.onCreate), en versamel dan logs vanaf interne/eksterne paaie of Logcat as rugsteun.

See the Android native reversing page for setup details and log paths:

{{#ref}}
../../mobile-pentesting/android-app-pentesting/reversing-native-libraries.md
{{#endref}}

---

## Deobfuscating Dynamic Control-Flow (JMP/CALL RAX Dispatchers)

Modern malware families heavily abuse Control-Flow Graph (CFG) obfuscation: instead of a direct jump/call they compute the destination at run-time and execute a `jmp rax` or `call rax`.  A small *dispatcher* (typically nine instructions) sets the final target depending on the CPU `ZF`/`CF` flags, completely breaking static CFG recovery.

Moderne malware-families misbruik Control-Flow Graph (CFG)-obfuskering in sterk mate: in plaas van 'n direkte jump/call bereken hulle die bestemming tydens uitvoering en voer 'n `jmp rax` of `call rax` uit. 'n Klein *dispatcher* (tipies nege instruksies) stel die finale teiken afhangend van die CPU `ZF`/`CF` vlagte, wat statiese CFG-herwinning heeltemal breek.

The technique – showcased by the SLOW#TEMPEST loader – can be defeated with a three-step workflow that only relies on IDAPython and the Unicorn CPU emulator.

Die tegniek — tentoongestel deur die SLOW#TEMPEST loader — kan gekeer word met 'n drie-stap werkvloei wat slegs staatmaak op IDAPython en die Unicorn CPU emulator.

### 1. Locate every indirect jump / call
```python
import idautils, idc

for ea in idautils.FunctionItems(idc.here()):
mnem = idc.print_insn_mnem(ea)
if mnem in ("jmp", "call") and idc.print_operand(ea, 0) == "rax":
print(f"[+] Dispatcher found @ {ea:X}")
```
### 2. Haal die dispatcher byte-code uit
```python
import idc

def get_dispatcher_start(jmp_ea, count=9):
s = jmp_ea
for _ in range(count):
s = idc.prev_head(s, 0)
return s

start = get_dispatcher_start(jmp_ea)
size  = jmp_ea + idc.get_item_size(jmp_ea) - start
code  = idc.get_bytes(start, size)
open(f"{start:X}.bin", "wb").write(code)
```
### 3. Emuleer dit twee keer met Unicorn
```python
from unicorn import *
from unicorn.x86_const import *
import struct

def run(code, zf=0, cf=0):
BASE = 0x1000
mu = Uc(UC_ARCH_X86, UC_MODE_64)
mu.mem_map(BASE, 0x1000)
mu.mem_write(BASE, code)
mu.reg_write(UC_X86_REG_RFLAGS, (zf << 6) | cf)
mu.reg_write(UC_X86_REG_RAX, 0)
mu.emu_start(BASE, BASE+len(code))
return mu.reg_read(UC_X86_REG_RAX)
```
Voer `run(code,0,0)` en `run(code,1,1)` uit om die *false* en *true* takbestemmings te kry.

### 4. Patch terug 'n direkte jump / call
```python
import struct, ida_bytes

def patch_direct(ea, target, is_call=False):
op   = 0xE8 if is_call else 0xE9           # CALL rel32 or JMP rel32
disp = target - (ea + 5) & 0xFFFFFFFF
ida_bytes.patch_bytes(ea, bytes([op]) + struct.pack('<I', disp))
```
Na patching, dwing IDA om die funksie opnuut te analiseer sodat die volledige CFG en Hex-Rays-uitset herstel word:
```python
import ida_auto, idaapi
idaapi.reanalyze_function(idc.get_func_attr(ea, idc.FUNCATTR_START))
```
### 5. Merk indirekte API-aanroepe

Sodra die werklike bestemming van elke `call rax` bekend is, kan jy IDA vertel wat dit is sodat parametertipes en veranderlike name outomaties herstel word:
```python
idc.set_callee_name(call_ea, resolved_addr, 0)  # IDA 8.3+
```
### Praktiese voordele

* Herstel die werklike CFG → dekompilasie gaan van *10* reëls na duisende.
* Laat string-cross-reference & xrefs toe, wat gedragsherbou triviaal maak.
* Skripte is herbruikbaar: plaas hulle in enige loader wat deur dieselfde truuk beskerm word.

---

## Verwysings

- [Unit42 – Evolving Tactics of SLOW#TEMPEST: A Deep Dive Into Advanced Malware Techniques](https://unit42.paloaltonetworks.com/slow-tempest-malware-obfuscation/)
- SoTap: Lightweight in-app JNI (.so) behavior logger – [github.com/RezaArbabBot/SoTap](https://github.com/RezaArbabBot/SoTap)

{{#include ../../banners/hacktricks-training.md}}
