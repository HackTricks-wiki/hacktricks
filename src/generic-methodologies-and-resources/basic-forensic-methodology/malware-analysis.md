# Malware Analise

{{#include ../../banners/hacktricks-training.md}}

## Forensiese CheatSheets

[https://www.jaiminton.com/cheatsheet/DFIR/#](https://www.jaiminton.com/cheatsheet/DFIR/)

## Aanlyn Dienste

- [VirusTotal](https://www.virustotal.com/gui/home/upload)
- [HybridAnalysis](https://www.hybrid-analysis.com)
- [Koodous](https://koodous.com)
- [Intezer](https://analyze.intezer.com)
- [Any.Run](https://any.run/)

## Aflyn Antivirus en Opsporing Gereedskap

### Yara

#### Installeer
```bash
sudo apt-get install -y yara
```
#### Berei reëls voor

Gebruik hierdie skrif om al die yara malware reëls van github af te laai en te kombineer: [https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9](https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9)\
Skep die _**reëls**_ gids en voer dit uit. Dit sal 'n lêer genaamd _**malware_rules.yar**_ skep wat al die yara reëls vir malware bevat.
```bash
wget https://gist.githubusercontent.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9/raw/4ec711d37f1b428b63bed1f786b26a0654aa2f31/malware_yara_rules.py
mkdir rules
python malware_yara_rules.py
```
#### Skande
```bash
yara -w malware_rules.yar image  #Scan 1 file
yara -w malware_rules.yar folder #Scan the whole folder
```
#### YaraGen: Kontroleer vir malware en Skep reëls

Jy kan die hulpmiddel [**YaraGen**](https://github.com/Neo23x0/yarGen) gebruik om yara reëls uit 'n binêre te genereer. Kyk na hierdie tutorials: [**Deel 1**](https://www.nextron-systems.com/2015/02/16/write-simple-sound-yara-rules/), [**Deel 2**](https://www.nextron-systems.com/2015/10/17/how-to-write-simple-but-sound-yara-rules-part-2/), [**Deel 3**](https://www.nextron-systems.com/2016/04/15/how-to-write-simple-but-sound-yara-rules-part-3/)
```bash
python3 yarGen.py --update
python3.exe yarGen.py --excludegood -m  ../../mals/
```
### ClamAV

#### Installeer
```
sudo apt-get install -y clamav
```
#### Skande
```bash
sudo freshclam      #Update rules
clamscan filepath   #Scan 1 file
clamscan folderpath #Scan the whole folder
```
### [Capa](https://github.com/mandiant/capa)

**Capa** detecteer potensieel kwaadwillige **vermoëns** in uitvoerbare lêers: PE, ELF, .NET. Dit sal dinge vind soos Att\&ck taktieke, of verdagte vermoëns soos:

- kontroleer vir OutputDebugString fout
- loop as 'n diens
- skep proses

Kry dit in die [**Github repo**](https://github.com/mandiant/capa).

### IOCs

IOC beteken Indicator Of Compromise. 'n IOC is 'n stel **voorwaardes wat** sommige potensieel ongewenste sagteware of bevestigde **malware** identifiseer. Blue Teams gebruik hierdie soort definisie om **te soek na hierdie soort kwaadwillige lêers** in hul **stelsels** en **netwerke**.\
Om hierdie definisies te deel is baie nuttig, aangesien wanneer malware in 'n rekenaar geïdentifiseer word en 'n IOC vir daardie malware geskep word, ander Blue Teams dit kan gebruik om die malware vinniger te identifiseer.

'n Gereedskap om IOCs te skep of te wysig is [**IOC Editor**](https://www.fireeye.com/services/freeware/ioc-editor.html)**.**\
Jy kan gereedskap soos [**Redline**](https://www.fireeye.com/services/freeware/redline.html) gebruik om **te soek na gedefinieerde IOCs in 'n toestel**.

### Loki

[**Loki**](https://github.com/Neo23x0/Loki) is 'n skandeerder vir Eenvoudige Indicators of Compromise.\
Detectie is gebaseer op vier detectiemetodes:
```
1. File Name IOC
Regex match on full file path/name

2. Yara Rule Check
Yara signature matches on file data and process memory

3. Hash Check
Compares known malicious hashes (MD5, SHA1, SHA256) with scanned files

4. C2 Back Connect Check
Compares process connection endpoints with C2 IOCs (new since version v.10)
```
### Linux Malware Detect

[**Linux Malware Detect (LMD)**](https://www.rfxn.com/projects/linux-malware-detect/) is 'n malware skandeerder vir Linux wat vrygestel is onder die GNU GPLv2 lisensie, wat ontwerp is rondom die bedreigings wat in gedeelde gasheeromgewings voorkom. Dit gebruik bedreigingsdata van netwerkrand indringingsdeteksiesisteme om malware wat aktief in aanvalle gebruik word, te onttrek en genereer handtekeninge vir opsporing. Daarbenewens word bedreigingsdata ook afgelei van gebruikersindienings met die LMD afrekenfunksie en malware gemeenskapsbronne.

### rkhunter

Gereedskap soos [**rkhunter**](http://rkhunter.sourceforge.net) kan gebruik word om die lêerstelsel na moontlike **rootkits** en malware te kontroleer.
```bash
sudo ./rkhunter --check -r / -l /tmp/rkhunter.log [--report-warnings-only] [--skip-keypress]
```
### FLOSS

[**FLOSS**](https://github.com/mandiant/flare-floss) is 'n hulpmiddel wat sal probeer om obfuskeerde stringe binne uitvoerbare lêers te vind deur verskillende tegnieke te gebruik.

### PEpper

[PEpper ](https://github.com/Th3Hurrican3/PEpper)kontroleer 'n paar basiese goed binne die uitvoerbare lêer (binarie data, entropie, URL's en IP's, 'n paar yara reëls).

### PEstudio

[PEstudio](https://www.winitor.com/download) is 'n hulpmiddel wat inligting van Windows uitvoerbare lêers soos invoere, uitvoere, koptekste verkry, maar sal ook virus total kontroleer en potensiële Att\&ck tegnieke vind.

### Detect It Easy(DiE)

[**DiE**](https://github.com/horsicq/Detect-It-Easy/) is 'n hulpmiddel om te detecteer of 'n lêer **geënkripteer** is en ook **packers** te vind.

### NeoPI

[**NeoPI** ](https://github.com/CiscoCXSecurity/NeoPI)is 'n Python-skrip wat 'n verskeidenheid **statistiese metodes** gebruik om **obfuskeerde** en **geënkripteerde** inhoud binne teks/skrip lêers te detecteer. Die beoogde doel van NeoPI is om te help met die **detectie van verborge web shell kode**.

### **php-malware-finder**

[**PHP-malware-finder**](https://github.com/nbs-system/php-malware-finder) doen sy beste om **obfuskeerde**/**verdagte kode** sowel as lêers wat **PHP** funksies gebruik wat dikwels in **malwares**/webshells gebruik word, te detecteer.

### Apple Binary Signatures

Wanneer jy 'n paar **malware monsters** kontroleer, moet jy altyd die **handtekening** van die binêre lêer **kontroleer** aangesien die **ontwikkelaar** wat dit onderteken het, dalk reeds **verbonde** is met **malware.**
```bash
#Get signer
codesign -vv -d /bin/ls 2>&1 | grep -E "Authority|TeamIdentifier"

#Check if the app’s contents have been modified
codesign --verify --verbose /Applications/Safari.app

#Check if the signature is valid
spctl --assess --verbose /Applications/Safari.app
```
## Ontdekkings Tegnieke

### Lêer Stapeling

As jy weet dat 'n sekere gids wat die **lêers** van 'n webbediener bevat, **laas op 'n sekere datum opgedateer is**. **Kontroleer** die **datum** waarop al die **lêers** in die **webbediener geskep en gewysig** is, en as enige datum **verdag** is, kontroleer daardie lêer.

### Baselines

As die lêers van 'n gids **nie gewysig moes gewees het nie**, kan jy die **hash** van die **oorspronklike lêers** van die gids bereken en dit met die **huidige** vergelyk. Enige iets wat gewysig is, sal **verdag** wees.

### Statistiese Analise

Wanneer die inligting in logs gestoor word, kan jy **statistieke kontroleer soos hoeveel keer elke lêer van 'n webbediener toeganklik was, aangesien 'n web shell een van die mees** mag wees.

---

## Deobfuskerende Dinamiese Beheer-Stroom (JMP/CALL RAX Verspreiders)

Moderne malware-families misbruik sterk Beheer-Stroom Grafiek (CFG) obfuskerings: in plaas van 'n direkte sprong/oproep bereken hulle die bestemming tydens uitvoering en voer 'n `jmp rax` of `call rax` uit. 'n Klein *verspreider* (tipies nege instruksies) stel die finale teiken op grond van die CPU `ZF`/`CF` vlae, wat statiese CFG-herwinning heeltemal breek.

Die tegniek – wat deur die SLOW#TEMPEST laaier gedemonstreer word – kan oorwin word met 'n drie-stap werkvloei wat slegs op IDAPython en die Unicorn CPU-emulator staatmaak.

### 1. Vind elke indirekte sprong / oproep
```python
import idautils, idc

for ea in idautils.FunctionItems(idc.here()):
mnem = idc.print_insn_mnem(ea)
if mnem in ("jmp", "call") and idc.print_operand(ea, 0) == "rax":
print(f"[+] Dispatcher found @ {ea:X}")
```
### 2. Trek die dispatcher byte-kode uit
```python
import idc

def get_dispatcher_start(jmp_ea, count=9):
s = jmp_ea
for _ in range(count):
s = idc.prev_head(s, 0)
return s

start = get_dispatcher_start(jmp_ea)
size  = jmp_ea + idc.get_item_size(jmp_ea) - start
code  = idc.get_bytes(start, size)
open(f"{start:X}.bin", "wb").write(code)
```
### 3. Emuleer dit twee keer met Unicorn
```python
from unicorn import *
from unicorn.x86_const import *
import struct

def run(code, zf=0, cf=0):
BASE = 0x1000
mu = Uc(UC_ARCH_X86, UC_MODE_64)
mu.mem_map(BASE, 0x1000)
mu.mem_write(BASE, code)
mu.reg_write(UC_X86_REG_RFLAGS, (zf << 6) | cf)
mu.reg_write(UC_X86_REG_RAX, 0)
mu.emu_start(BASE, BASE+len(code))
return mu.reg_read(UC_X86_REG_RAX)
```
Voer `run(code,0,0)` en `run(code,1,1)` uit om die *vals* en *waar* takteikens te verkry.

### 4. Patches 'n direkte sprong / oproep terug
```python
import struct, ida_bytes

def patch_direct(ea, target, is_call=False):
op   = 0xE8 if is_call else 0xE9           # CALL rel32 or JMP rel32
disp = target - (ea + 5) & 0xFFFFFFFF
ida_bytes.patch_bytes(ea, bytes([op]) + struct.pack('<I', disp))
```
Na die opknapping, dwing IDA om die funksie weer te analiseer sodat die volle CFG en Hex-Rays-uitvoer herstel word:
```python
import ida_auto, idaapi
idaapi.reanalyze_function(idc.get_func_attr(ea, idc.FUNCATTR_START))
```
### 5. Etikette indirekte API-oproepe

Sodra die werklike bestemming van elke `call rax` bekend is, kan jy vir IDA sê wat dit is sodat parameter tipes & veranderlike name outomaties herstel word:
```python
idc.set_callee_name(call_ea, resolved_addr, 0)  # IDA 8.3+
```
### Praktiese voordele

* Herstel die werklike CFG → dekompilering gaan van *10* lyne na duisende.
* Maak string-kruisverwysing & xrefs moontlik, wat gedragheropbou triviaal maak.
* Skripte is herbruikbaar: gooi hulle in enige laaier wat deur dieselfde truuk beskerm word.

---

## Verwysings

- [Unit42 – Evolving Tactics of SLOW#TEMPEST: A Deep Dive Into Advanced Malware Techniques](https://unit42.paloaltonetworks.com/slow-tempest-malware-obfuscation/)

{{#include ../../banners/hacktricks-training.md}}
