# 恶意软件分析

{{#include ../../banners/hacktricks-training.md}}

## 取证 速查表

[https://www.jaiminton.com/cheatsheet/DFIR/#](https://www.jaiminton.com/cheatsheet/DFIR/)

## 在线服务

- [VirusTotal](https://www.virustotal.com/gui/home/upload)
- [HybridAnalysis](https://www.hybrid-analysis.com)
- [Koodous](https://koodous.com)
- [Intezer](https://analyze.intezer.com)
- [Any.Run](https://any.run/)

## 离线防病毒及检测工具

### Yara

#### 安装
```bash
sudo apt-get install -y yara
```
#### 准备规则

使用此脚本从 github 下载并合并所有 yara malware 规则: [https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9](https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9)\
创建 _**rules**_ 目录并执行该脚本。该操作会生成一个名为 _**malware_rules.yar**_ 的文件，包含所有用于 malware 的 yara rules。
```bash
wget https://gist.githubusercontent.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9/raw/4ec711d37f1b428b63bed1f786b26a0654aa2f31/malware_yara_rules.py
mkdir rules
python malware_yara_rules.py
```
#### 扫描
```bash
yara -w malware_rules.yar image  #Scan 1 file
yara -w malware_rules.yar folder #Scan the whole folder
```
#### YaraGen: 检测 malware 并创建 yara rules

你可以使用工具 [**YaraGen**](https://github.com/Neo23x0/yarGen) 从二进制文件生成 yara rules。查看这些教程： [**Part 1**](https://www.nextron-systems.com/2015/02/16/write-simple-sound-yara-rules/), [**Part 2**](https://www.nextron-systems.com/2015/10/17/how-to-write-simple-but-sound-yara-rules-part-2/), [**Part 3**](https://www.nextron-systems.com/2016/04/15/how-to-write-simple-but-sound-yara-rules-part-3/)
```bash
python3 yarGen.py --update
python3.exe yarGen.py --excludegood -m  ../../mals/
```
### ClamAV

#### 安装
```
sudo apt-get install -y clamav
```
#### 扫描
```bash
sudo freshclam      #Update rules
clamscan filepath   #Scan 1 file
clamscan folderpath #Scan the whole folder
```
### [Capa](https://github.com/mandiant/capa)

**Capa** 会在可执行文件：PE、ELF、.NET 中检测潜在的恶意 **capabilities**。因此它可以发现诸如 Att\&ck tactics，或下列可疑能力：

- 检查 OutputDebugString 错误
- run as a service
- create process

可在 [**Github repo**](https://github.com/mandiant/capa) 获取。

### IOCs

IOC 意味着 Indicator Of Compromise（入侵指示器）。IOC 是一组**识别条件**，用于识别某些可能不受欢迎的软件或已确认的**malware**。Blue Teams 使用这种定义在其**系统**和**网络**中**搜索此类恶意文件**。\
共享这些定义非常有用：当在一台计算机上识别出 malware 并为其创建了 IOC 时，其他 Blue Teams 可以使用该 IOC 更快地识别该 malware。

用于创建或修改 IOCs 的工具是 [**IOC Editor**](https://www.fireeye.com/services/freeware/ioc-editor.html)**.**\
你可以使用诸如 [**Redline**](https://www.fireeye.com/services/freeware/redline.html) 的工具来**在设备中搜索已定义的 IOCs**。

### Loki

[**Loki**](https://github.com/Neo23x0/Loki) 是一个用于检测简单入侵指示器的扫描器。\
检测基于四种检测方法：
```
1. File Name IOC
Regex match on full file path/name

2. Yara Rule Check
Yara signature matches on file data and process memory

3. Hash Check
Compares known malicious hashes (MD5, SHA1, SHA256) with scanned files

4. C2 Back Connect Check
Compares process connection endpoints with C2 IOCs (new since version v.10)
```
### Linux Malware Detect

[**Linux Malware Detect (LMD)**](https://www.rfxn.com/projects/linux-malware-detect/) 是一个面向 Linux 的 malware 扫描器，基于 GNU GPLv2 许可发布，针对共享托管环境所面临的威胁进行设计。它利用来自网络边缘入侵检测系统的威胁数据来提取正在被用于攻击的 malware，并生成检测签名。此外，威胁数据还来源于用户通过 LMD checkout feature 提交的数据和 malware 社区资源。

### rkhunter

Tools like [**rkhunter**](http://rkhunter.sourceforge.net) can be used to check the filesystem for possible **rootkits** and malware.
```bash
sudo ./rkhunter --check -r / -l /tmp/rkhunter.log [--report-warnings-only] [--skip-keypress]
```
### FLOSS

[**FLOSS**](https://github.com/mandiant/flare-floss) 是一个工具，尝试使用不同的技术在 executables 内查找 obfuscated strings。

### PEpper

[PEpper ](https://github.com/Th3Hurrican3/PEpper) checks 一些可执行文件内部的基本内容（binary data, entropy, URLs and IPs, some yara rules）。

### PEstudio

[PEstudio](https://www.winitor.com/download) 是一个工具，可以获取 Windows executables 的信息，例如 imports、exports、headers，但也会检查 virus total 并发现潜在的 Att\&ck techniques。

### Detect It Easy(DiE)

[**DiE**](https://github.com/horsicq/Detect-It-Easy/) 是一个用于检测文件是否为 **encrypted** 并且查找 **packers** 的工具。

### NeoPI

[**NeoPI** ](https://github.com/CiscoCXSecurity/NeoPI)is 一个 Python 脚本，使用多种 **statistical methods** 来检测文本/脚本文件中 **obfuscated** 和 **encrypted** 的内容。NeoPI 的目的是协助 **detection of hidden web shell code**。

### **php-malware-finder**

[**PHP-malware-finder**](https://github.com/nbs-system/php-malware-finder) 尽最大努力检测 **obfuscated**/**dodgy code**，以及使用常见于 **malwares**/webshells 的 **PHP** 函数的文件。

### Apple Binary Signatures

在检查某些 **malware sample** 时，您应始终 **check the signature** 二进制文件，因为签名的 **developer** 可能已与 **malware.** 有所 **related**。
```bash
#Get signer
codesign -vv -d /bin/ls 2>&1 | grep -E "Authority|TeamIdentifier"

#Check if the app’s contents have been modified
codesign --verify --verbose /Applications/Safari.app

#Check if the signature is valid
spctl --assess --verbose /Applications/Safari.app
```
## 检测技术

### 文件堆叠

如果你知道某个包含 **web 服务器文件** 的文件夹在某个日期被**最后更新**，请**检查**该 web 服务器中所有 **文件** 的**创建和修改日期**，如果有任何日期显得**可疑**，就检查该文件。

### 基线

如果某个文件夹的文件**不应该被修改**，你可以计算该文件夹**原始文件**的 **hash**，并将其与**当前**文件进行**比对**。任何被修改的都会很**可疑**。

### 统计分析

当信息保存在日志中时，你可以**检查统计数据**，例如每个 web 服务器文件被访问的次数，因为 web shell 可能是被访问次数最多的之一。

---

### Android in-app native telemetry (no root)

在 Android 上，你可以通过在其他 JNI 库初始化之前预加载一个小型 logger 库，在目标应用进程内对 native 代码进行插桩。这样可以在不依赖系统范围 hooks 或 root 的情况下，尽早观察 native 行为。一个常用方法是 SoTap：将对应 ABI 的 libsotap.so 放入 APK，并尽早注入 System.loadLibrary("sotap") 调用（例如在静态初始化器或 Application.onCreate 中），然后从内部/外部路径收集日志，或回退到 Logcat。

有关设置细节和日志路径，请参阅 Android native reversing 页面：

{{#ref}}
../../mobile-pentesting/android-app-pentesting/reversing-native-libraries.md
{{#endref}}

---

## Deobfuscating Dynamic Control-Flow (JMP/CALL RAX Dispatchers)

现代恶意软件家族严重滥用 Control-Flow Graph (CFG) 混淆：它们不是直接跳转/调用，而是在运行时计算目标并执行 `jmp rax` 或 `call rax`。一个小的 *dispatcher*（通常九条指令）根据 CPU 的 `ZF`/`CF` 标志设置最终目标，完全破坏了静态 CFG 恢复。

这种技术 — 由 SLOW#TEMPEST loader 展示 — 可以通过一个只依赖 IDAPython 和 Unicorn CPU emulator 的三步工作流程来破解。

### 1. 定位每个间接跳转 / 调用
```python
import idautils, idc

for ea in idautils.FunctionItems(idc.here()):
mnem = idc.print_insn_mnem(ea)
if mnem in ("jmp", "call") and idc.print_operand(ea, 0) == "rax":
print(f"[+] Dispatcher found @ {ea:X}")
```
### 2. 提取 dispatcher byte-code
```python
import idc

def get_dispatcher_start(jmp_ea, count=9):
s = jmp_ea
for _ in range(count):
s = idc.prev_head(s, 0)
return s

start = get_dispatcher_start(jmp_ea)
size  = jmp_ea + idc.get_item_size(jmp_ea) - start
code  = idc.get_bytes(start, size)
open(f"{start:X}.bin", "wb").write(code)
```
### 3. 使用 Unicorn 模拟两次
```python
from unicorn import *
from unicorn.x86_const import *
import struct

def run(code, zf=0, cf=0):
BASE = 0x1000
mu = Uc(UC_ARCH_X86, UC_MODE_64)
mu.mem_map(BASE, 0x1000)
mu.mem_write(BASE, code)
mu.reg_write(UC_X86_REG_RFLAGS, (zf << 6) | cf)
mu.reg_write(UC_X86_REG_RAX, 0)
mu.emu_start(BASE, BASE+len(code))
return mu.reg_read(UC_X86_REG_RAX)
```
运行 `run(code,0,0)` 和 `run(code,1,1)` 以获取 *false* 与 *true* 分支目标。

### 4. 回补直接的 jump / call
```python
import struct, ida_bytes

def patch_direct(ea, target, is_call=False):
op   = 0xE8 if is_call else 0xE9           # CALL rel32 or JMP rel32
disp = target - (ea + 5) & 0xFFFFFFFF
ida_bytes.patch_bytes(ea, bytes([op]) + struct.pack('<I', disp))
```
打补丁后，强制 IDA 重新分析该函数，以便恢复完整的 CFG 和 Hex-Rays 输出：
```python
import ida_auto, idaapi
idaapi.reanalyze_function(idc.get_func_attr(ea, idc.FUNCATTR_START))
```
### 5. Label indirect API calls

一旦每个 `call rax` 的真实目标被确定，你可以告诉 IDA 它是什么，从而自动恢复参数类型 & 变量名：
```python
idc.set_callee_name(call_ea, resolved_addr, 0)  # IDA 8.3+
```
### 实际好处

* 恢复真实的 CFG → 反编译结果从 *10* 行扩展到数千行。
* 启用 string-cross-reference & xrefs，使行为重建变得轻而易举。
* 脚本可重用：将它们放入任何使用相同技巧保护的 loader 中。

---

## 参考资料

- [Unit42 – Evolving Tactics of SLOW#TEMPEST: A Deep Dive Into Advanced Malware Techniques](https://unit42.paloaltonetworks.com/slow-tempest-malware-obfuscation/)
- SoTap：轻量级的 in-app JNI (.so) 行为记录器 – [github.com/RezaArbabBot/SoTap](https://github.com/RezaArbabBot/SoTap)

{{#include ../../banners/hacktricks-training.md}}
