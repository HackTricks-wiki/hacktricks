# 恶意软件分析

{{#include ../../banners/hacktricks-training.md}}

## 取证速查表

[https://www.jaiminton.com/cheatsheet/DFIR/#](https://www.jaiminton.com/cheatsheet/DFIR/)

## 在线服务

- [VirusTotal](https://www.virustotal.com/gui/home/upload)
- [HybridAnalysis](https://www.hybrid-analysis.com)
- [Koodous](https://koodous.com)
- [Intezer](https://analyze.intezer.com)
- [Any.Run](https://any.run/)

## 离线防病毒与检测工具

### Yara

#### 安装
```bash
sudo apt-get install -y yara
```
#### 准备规则

使用此脚本从 github 下载并合并所有 yara malware 规则: [https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9](https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9)\  
创建 _**rules**_ 目录并执行该脚本。 这将创建一个名为 _**malware_rules.yar**_ 的文件，其中包含所有 yara malware 规则。
```bash
wget https://gist.githubusercontent.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9/raw/4ec711d37f1b428b63bed1f786b26a0654aa2f31/malware_yara_rules.py
mkdir rules
python malware_yara_rules.py
```
#### 扫描
```bash
yara -w malware_rules.yar image  #Scan 1 file
yara -w malware_rules.yar folder #Scan the whole folder
```
#### YaraGen: 检测恶意软件并创建规则

您可以使用工具 [**YaraGen**](https://github.com/Neo23x0/yarGen) 从二进制文件生成 yara rules。查看这些教程： [**Part 1**](https://www.nextron-systems.com/2015/02/16/write-simple-sound-yara-rules/), [**Part 2**](https://www.nextron-systems.com/2015/10/17/how-to-write-simple-but-sound-yara-rules-part-2/), [**Part 3**](https://www.nextron-systems.com/2016/04/15/how-to-write-simple-but-sound-yara-rules-part-3/)
```bash
python3 yarGen.py --update
python3.exe yarGen.py --excludegood -m  ../../mals/
```
### ClamAV

#### 安装
```
sudo apt-get install -y clamav
```
#### 扫描
```bash
sudo freshclam      #Update rules
clamscan filepath   #Scan 1 file
clamscan folderpath #Scan the whole folder
```
### [Capa](https://github.com/mandiant/capa)

**Capa** 检测可执行文件中潜在的恶意**capabilities**：PE、ELF、.NET。它会发现诸如 Att\&ck tactics 或以下可疑能力：

- 检查 OutputDebugString 错误
- 以服务方式运行
- 创建进程

在 [**Github repo**](https://github.com/mandiant/capa) 获取。

### IOCs

IOC means Indicator Of Compromise。IOC 是一组用于识别某些潜在不受欢迎软件或已确认 **malware** 的条件。Blue Teams 使用这种定义在其 **系统** 和 **网络** 中搜索这类恶意文件。\
分享这些定义非常有用：当在某台计算机中识别出 **malware** 并为其创建 IOC 时，其他 Blue Teams 可以使用该 IOC 更快地识别该 **malware**。

一个用于创建或修改 IOCs 的工具是 [**IOC Editor**](https://www.fireeye.com/services/freeware/ioc-editor.html)**.**\
你可以使用诸如 [**Redline**](https://www.fireeye.com/services/freeware/redline.html) 之类的工具来 **在设备中搜索已定义的 IOCs**。

### Loki

[**Loki**](https://github.com/Neo23x0/Loki) 是一个用于 Simple Indicators of Compromise 的扫描器。\
检测基于四种检测方法：
```
1. File Name IOC
Regex match on full file path/name

2. Yara Rule Check
Yara signature matches on file data and process memory

3. Hash Check
Compares known malicious hashes (MD5, SHA1, SHA256) with scanned files

4. C2 Back Connect Check
Compares process connection endpoints with C2 IOCs (new since version v.10)
```
### Linux Malware Detect

[**Linux Malware Detect (LMD)**](https://www.rfxn.com/projects/linux-malware-detect/) 是一款面向 Linux 的 malware 扫描器，基于 GNU GPLv2 许可发布，专为共享托管环境中面临的威胁而设计。它使用来自网络边缘入侵检测系统的威胁数据来提取正在被用于攻击的 malware 并生成用于检测的签名。此外，威胁数据还来自通过 LMD checkout feature 的用户提交和 malware 社区资源。

### rkhunter

像 [**rkhunter**](http://rkhunter.sourceforge.net) 这样的工具可用于检查文件系统以发现可能的 **rootkits** 和 malware。
```bash
sudo ./rkhunter --check -r / -l /tmp/rkhunter.log [--report-warnings-only] [--skip-keypress]
```
### FLOSS

[**FLOSS**](https://github.com/mandiant/flare-floss) 是一个工具，使用多种技术尝试在可执行文件中查找 obfuscated strings。

### PEpper

[PEpper ](https://github.com/Th3Hurrican3/PEpper)checks some basic stuff inside the executable (binary data, entropy, URLs and IPs, some yara rules)。

### PEstudio

[PEstudio](https://www.winitor.com/download) 是一个工具，可获取 Windows 可执行文件的信息，如 imports, exports, headers，同时还会检查 virus total 并查找可能的 Att\&ck techniques。

### Detect It Easy(DiE)

[**DiE**](https://github.com/horsicq/Detect-It-Easy/) 是一个工具，用来检测文件是否 **encrypted**，并查找 **packers**。

### NeoPI

[**NeoPI** ](https://github.com/CiscoCXSecurity/NeoPI) 是一个 Python 脚本，使用各种 **statistical methods** 来检测文本/脚本文件中 **obfuscated** 和 **encrypted** 的内容。NeoPI 的预期用途是协助 **detection of hidden web shell code**。

### **php-malware-finder**

[**PHP-malware-finder**](https://github.com/nbs-system/php-malware-finder) 尽其所能检测 **obfuscated**/**dodgy code**，以及使用常见于 **malwares**/webshells 的 **PHP** 函数的文件。

### Apple Binary Signatures

在检查某些 **malware sample** 时，你应该始终 **check the signature**，因为为其签名的 **developer** 可能已经与 **malware** 有所 **related**。
```bash
#Get signer
codesign -vv -d /bin/ls 2>&1 | grep -E "Authority|TeamIdentifier"

#Check if the app’s contents have been modified
codesign --verify --verbose /Applications/Safari.app

#Check if the signature is valid
spctl --assess --verbose /Applications/Safari.app
```
## 检测技术

### File Stacking

如果你知道某个包含 web 服务器 **文件** 的文件夹在某个特定日期被 **最后更新**，请**检查**该 web 服务器中所有 **文件** 的创建和修改 **日期**，如果任何日期看起来 **可疑**，就检查该文件。

### Baselines

如果某个文件夹的 **文件** **不应该被修改**，你可以计算该文件夹 **原始文件** 的 **哈希**，并将其与 **当前** 的文件 **比较**。任何被修改的都将显得 **可疑**。

### Statistical Analysis

当信息保存在日志中时，你可以 **检查统计数据，比如每个 web 服务器文件被访问的次数，因为 web shell 可能是最常见的之一**。

---

### Android 应用内原生遥测 (no root)

在 Android 上，你可以通过在其他 JNI 库初始化之前预加载一个小型 logger 库来对目标应用进程内的 native 代码进行插装。这可以在不使用系统级 hooks 或 root 的情况下，提前观察 native 行为。一个常用方法是 SoTap：将对应 ABI 的 libsotap.so 放入 APK，并在早期注入一条 System.loadLibrary("sotap") 调用（例如在静态初始化器或 Application.onCreate 中），然后从内部/外部路径收集日志，或回退到 Logcat。

See the Android native reversing page for setup details and log paths:

{{#ref}}
../../mobile-pentesting/android-app-pentesting/reversing-native-libraries.md
{{#endref}}

---

## Deobfuscating Dynamic Control-Flow (JMP/CALL RAX Dispatchers)

Modern malware families heavily abuse Control-Flow Graph (CFG) obfuscation: instead of a direct jump/call they compute the destination at run-time and execute a `jmp rax` or `call rax`.  A small *dispatcher* (typically nine instructions) sets the final target depending on the CPU `ZF`/`CF` flags, completely breaking static CFG recovery.

The technique – showcased by the SLOW#TEMPEST loader – can be defeated with a three-step workflow that only relies on IDAPython and the Unicorn CPU emulator.

### 1. 定位所有间接跳转 / 调用
```python
import idautils, idc

for ea in idautils.FunctionItems(idc.here()):
mnem = idc.print_insn_mnem(ea)
if mnem in ("jmp", "call") and idc.print_operand(ea, 0) == "rax":
print(f"[+] Dispatcher found @ {ea:X}")
```
### 2. 提取 dispatcher byte-code
```python
import idc

def get_dispatcher_start(jmp_ea, count=9):
s = jmp_ea
for _ in range(count):
s = idc.prev_head(s, 0)
return s

start = get_dispatcher_start(jmp_ea)
size  = jmp_ea + idc.get_item_size(jmp_ea) - start
code  = idc.get_bytes(start, size)
open(f"{start:X}.bin", "wb").write(code)
```
### 3. 使用 Unicorn 对其模拟两次
```python
from unicorn import *
from unicorn.x86_const import *
import struct

def run(code, zf=0, cf=0):
BASE = 0x1000
mu = Uc(UC_ARCH_X86, UC_MODE_64)
mu.mem_map(BASE, 0x1000)
mu.mem_write(BASE, code)
mu.reg_write(UC_X86_REG_RFLAGS, (zf << 6) | cf)
mu.reg_write(UC_X86_REG_RAX, 0)
mu.emu_start(BASE, BASE+len(code))
return mu.reg_read(UC_X86_REG_RAX)
```
运行 `run(code,0,0)` 和 `run(code,1,1)` 来获取 *false* 和 *true* 分支目标。

### 4. 将直接 jump / call 修补回去
```python
import struct, ida_bytes

def patch_direct(ea, target, is_call=False):
op   = 0xE8 if is_call else 0xE9           # CALL rel32 or JMP rel32
disp = target - (ea + 5) & 0xFFFFFFFF
ida_bytes.patch_bytes(ea, bytes([op]) + struct.pack('<I', disp))
```
打补丁后，强制 IDA 重新分析该函数，以便恢复完整的 CFG 和 Hex-Rays 输出：
```python
import ida_auto, idaapi
idaapi.reanalyze_function(idc.get_func_attr(ea, idc.FUNCATTR_START))
```
### 5. 标注间接 API 调用

一旦每个 `call rax` 的真实目标已知，你可以告诉 IDA 这些目标是什么，这样参数类型和变量名就会被自动恢复：
```python
idc.set_callee_name(call_ea, resolved_addr, 0)  # IDA 8.3+
```
### 实际收益

* 还原真实的 CFG → 反编译结果从 *10* 行变为数千行。
* 支持 string-cross-reference & xrefs，使行为重建变得简单。
* 脚本可重用：将它们放入任何使用相同技巧保护的 loader 即可。

---

## AdaptixC2：配置提取与 TTPs

参见专门页面：

{{#ref}}
adaptixc2-config-extraction-and-ttps.md
{{#endref}}

## 参考资料

- [Unit42 – Evolving Tactics of SLOW#TEMPEST: A Deep Dive Into Advanced Malware Techniques](https://unit42.paloaltonetworks.com/slow-tempest-malware-obfuscation/)
- SoTap：轻量级应用内 JNI (.so) 行为记录器 – [github.com/RezaArbabBot/SoTap](https://github.com/RezaArbabBot/SoTap)
- [Unit42 – AdaptixC2: A New Open-Source Framework Leveraged in Real-World Attacks](https://unit42.paloaltonetworks.com/adaptixc2-post-exploitation-framework/)

{{#include ../../banners/hacktricks-training.md}}
