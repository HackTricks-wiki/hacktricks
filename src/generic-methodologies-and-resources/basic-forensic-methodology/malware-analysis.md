# Malware-Analyse

{{#include ../../banners/hacktricks-training.md}}

## Forensik-CheatSheets

[https://www.jaiminton.com/cheatsheet/DFIR/#](https://www.jaiminton.com/cheatsheet/DFIR/)

## Online-Dienste

- [VirusTotal](https://www.virustotal.com/gui/home/upload)
- [HybridAnalysis](https://www.hybrid-analysis.com)
- [Koodous](https://koodous.com)
- [Intezer](https://analyze.intezer.com)
- [Any.Run](https://any.run/)

## Offline-Antivirus- und Erkennungs-Tools

### Yara

#### Installation
```bash
sudo apt-get install -y yara
```
#### Regeln vorbereiten

Verwende dieses Skript, um alle yara malware rules von github herunterzuladen und zusammenzuführen: [https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9](https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9)\
Erstelle das _**rules**_ Verzeichnis und führe das Skript aus. Dadurch wird eine Datei namens _**malware_rules.yar**_ erstellt, die alle yara rules für malware enthält.
```bash
wget https://gist.githubusercontent.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9/raw/4ec711d37f1b428b63bed1f786b26a0654aa2f31/malware_yara_rules.py
mkdir rules
python malware_yara_rules.py
```
#### Scannen
```bash
yara -w malware_rules.yar image  #Scan 1 file
yara -w malware_rules.yar folder #Scan the whole folder
```
#### YaraGen: Auf malware prüfen und Regeln erstellen

Du kannst das Tool [**YaraGen**](https://github.com/Neo23x0/yarGen) verwenden, um yara rules aus einer Binärdatei zu generieren. Schau dir diese Tutorials an: [**Part 1**](https://www.nextron-systems.com/2015/02/16/write-simple-sound-yara-rules/), [**Part 2**](https://www.nextron-systems.com/2015/10/17/how-to-write-simple-but-sound-yara-rules-part-2/), [**Part 3**](https://www.nextron-systems.com/2016/04/15/how-to-write-simple-but-sound-yara-rules-part-3/)
```bash
python3 yarGen.py --update
python3.exe yarGen.py --excludegood -m  ../../mals/
```
### ClamAV

#### Installation
```
sudo apt-get install -y clamav
```
#### Scannen
```bash
sudo freshclam      #Update rules
clamscan filepath   #Scan 1 file
clamscan folderpath #Scan the whole folder
```
### [Capa](https://github.com/mandiant/capa)

**Capa** erkennt potenziell bösartige **capabilities** in ausführbaren Dateien: PE, ELF, .NET. Es findet auch Dinge wie Att\&ck tactics, oder verdächtige capabilities wie:

- check for OutputDebugString error
- run as a service
- create process

Hol es im [**Github repo**](https://github.com/mandiant/capa).

### IOCs

IOC bedeutet Indicator Of Compromise. Ein IOC ist eine Reihe von **Bedingungen, die** einige potenziell unerwünschte Software oder bestätigte **malware** identifizieren. Blue Teams verwenden diese Art von Definition, um in ihren **systems** und **networks** nach solchen bösartigen Dateien zu suchen.\
Das Teilen dieser Definitionen ist sehr nützlich, denn wenn malware auf einem Computer identifiziert wird und ein IOC für diese malware erstellt wird, können andere Blue Teams es verwenden, um die malware schneller zu identifizieren.

Ein Tool zum Erstellen oder Ändern von IOCs ist [**IOC Editor**](https://www.fireeye.com/services/freeware/ioc-editor.html)**.**\
Sie können Tools wie [**Redline**](https://www.fireeye.com/services/freeware/redline.html) verwenden, um **nach definierten IOCs auf einem Gerät zu suchen**.

### Loki

[**Loki**](https://github.com/Neo23x0/Loki) ist ein Scanner für Simple Indicators of Compromise.\
Die Erkennung basiert auf vier Detection-Methoden:
```
1. File Name IOC
Regex match on full file path/name

2. Yara Rule Check
Yara signature matches on file data and process memory

3. Hash Check
Compares known malicious hashes (MD5, SHA1, SHA256) with scanned files

4. C2 Back Connect Check
Compares process connection endpoints with C2 IOCs (new since version v.10)
```
### Linux Malware Detect

[**Linux Malware Detect (LMD)**](https://www.rfxn.com/projects/linux-malware-detect/) ist ein Malware-Scanner für Linux, veröffentlicht unter der GNU GPLv2-Lizenz, der auf die Bedrohungen in gemeinsam gehosteten Umgebungen ausgelegt ist. Er nutzt Bedrohungsdaten aus netzwerkseitigen Intrusion-Detection-Systemen, um Malware zu extrahieren, die aktiv in Angriffen verwendet wird, und erzeugt Signaturen zur Erkennung. Zusätzlich stammen Bedrohungsdaten aus Benutzereinsendungen über die LMD-Checkout-Funktion und aus Ressourcen der Malware-Community.

### rkhunter

Tools wie [**rkhunter**](http://rkhunter.sourceforge.net) können verwendet werden, um das Dateisystem auf mögliche **rootkits** und Malware zu überprüfen.
```bash
sudo ./rkhunter --check -r / -l /tmp/rkhunter.log [--report-warnings-only] [--skip-keypress]
```
### FLOSS

[**FLOSS**](https://github.com/mandiant/flare-floss) ist ein Tool, das versucht, **obfuscated strings** in ausführbaren Dateien mithilfe verschiedener Techniken zu finden.

### PEpper

[PEpper ](https://github.com/Th3Hurrican3/PEpper)prüft einige grundlegende Dinge in der ausführbaren Datei (binäre Daten, Entropie, URLs und IPs, einige yara rules).

### PEstudio

[PEstudio](https://www.winitor.com/download) ist ein Tool, das Informationen zu Windows-Executables liefert, wie Importe, Exporte und Header; außerdem prüft es VirusTotal und findet potenzielle Att\&ck-Techniken.

### Detect It Easy(DiE)

[**DiE**](https://github.com/horsicq/Detect-It-Easy/) ist ein Tool, um zu erkennen, ob eine Datei **encrypted** ist und außerdem **packers** zu finden.

### NeoPI

[**NeoPI** ](https://github.com/CiscoCXSecurity/NeoPI)ist ein Python-Skript, das verschiedene **statistische Methoden** verwendet, um **obfuscated** und **encrypted** Inhalte in Text-/Script-Dateien zu erkennen. Der beabsichtigte Zweck von NeoPI ist die Unterstützung bei der **Erkennung von verstecktem web shell code**.

### **php-malware-finder**

[**PHP-malware-finder**](https://github.com/nbs-system/php-malware-finder) versucht bestmöglich, **obfuscated**/**dodgy code** zu erkennen sowie Dateien, die **PHP**-Funktionen verwenden, die häufig in **malwares**/webshells genutzt werden.

### Apple Binary Signatures

Beim Prüfen einer **malware sample** sollten Sie immer **die Signatur überprüfen** der Binärdatei, da der **Entwickler**, der sie signiert hat, bereits **in Verbindung** mit **malware.** stehen könnte.
```bash
#Get signer
codesign -vv -d /bin/ls 2>&1 | grep -E "Authority|TeamIdentifier"

#Check if the app’s contents have been modified
codesign --verify --verbose /Applications/Safari.app

#Check if the signature is valid
spctl --assess --verbose /Applications/Safari.app
```
## Erkennungstechniken

### File Stacking

Wenn Sie wissen, dass ein Ordner, der die **Dateien** eines Webservers enthält, **zu einem bestimmten Datum zuletzt aktualisiert wurde**. **Prüfen** Sie das **Datum**, an dem alle **Dateien** des **Webservers erstellt und geändert wurden**, und wenn ein Datum **verdächtig** ist, untersuchen Sie diese Datei.

### Baselines

Wenn die Dateien eines Ordners **nicht hätten verändert werden dürfen**, können Sie den **Hash** der **Originaldateien** des Ordners berechnen und mit den **aktuellen** vergleichen. Alles, was verändert wurde, ist **verdächtig**.

### Statistical Analysis

Wenn die Informationen in Logs gespeichert sind, können Sie **Statistiken prüfen**, z. B. wie oft jede Datei eines Webservers aufgerufen wurde, da eine web shell möglicherweise eine der meistgenutzten ist.

---

### Android in-app native Telemetrie (kein Root)

Auf Android können Sie nativen Code innerhalb des Ziel-App-Prozesses instrumentieren, indem Sie eine kleine Logger-Bibliothek vorladen, bevor andere JNI libs initialisiert werden. Das bietet frühzeitige Einsicht in natives Verhalten ohne systemweite Hooks oder Root. Ein verbreiteter Ansatz ist SoTap: legen Sie libsotap.so für die passende ABI in das APK und fügen Sie früh einen System.loadLibrary("sotap")-Aufruf ein (z. B. static initializer oder Application.onCreate), und sammeln Sie dann Logs aus internen/externen Pfaden oder als Logcat-Fallback.

Siehe die Android native reversing-Seite für Setup-Details und Log-Pfade:

{{#ref}}
../../mobile-pentesting/android-app-pentesting/reversing-native-libraries.md
{{#endref}}

---

## Deobfuskation dynamischer Kontrollflüsse (JMP/CALL RAX Dispatchers)

Moderne malware-Familien missbrauchen stark die Kontrollflussgraph (CFG)-Obfuskation: anstatt eines direkten jump/call berechnen sie das Ziel zur Laufzeit und führen ein `jmp rax` oder `call rax` aus. Ein kleiner *Dispatcher* (typischerweise neun Instruktionen) setzt das finale Ziel abhängig von den CPU-Flags `ZF`/`CF` und bricht damit die statische CFG-Rekonstruktion vollständig.

Die Technik – demonstriert am SLOW#TEMPEST loader – lässt sich mit einem dreistufigen Workflow umgehen, der nur auf IDAPython und dem Unicorn CPU emulator basiert.

### 1. Lokalisieren Sie jeden indirekten jump / call
```python
import idautils, idc

for ea in idautils.FunctionItems(idc.here()):
mnem = idc.print_insn_mnem(ea)
if mnem in ("jmp", "call") and idc.print_operand(ea, 0) == "rax":
print(f"[+] Dispatcher found @ {ea:X}")
```
### 2. Dispatcher-Bytecode extrahieren
```python
import idc

def get_dispatcher_start(jmp_ea, count=9):
s = jmp_ea
for _ in range(count):
s = idc.prev_head(s, 0)
return s

start = get_dispatcher_start(jmp_ea)
size  = jmp_ea + idc.get_item_size(jmp_ea) - start
code  = idc.get_bytes(start, size)
open(f"{start:X}.bin", "wb").write(code)
```
### 3. Emuliere es zweimal mit Unicorn
```python
from unicorn import *
from unicorn.x86_const import *
import struct

def run(code, zf=0, cf=0):
BASE = 0x1000
mu = Uc(UC_ARCH_X86, UC_MODE_64)
mu.mem_map(BASE, 0x1000)
mu.mem_write(BASE, code)
mu.reg_write(UC_X86_REG_RFLAGS, (zf << 6) | cf)
mu.reg_write(UC_X86_REG_RAX, 0)
mu.emu_start(BASE, BASE+len(code))
return mu.reg_read(UC_X86_REG_RAX)
```
Führe `run(code,0,0)` und `run(code,1,1)` aus, um die Ziele des *false*- und *true*-Zweigs zu erhalten.

### 4. Einen direkten jump / call zurückpatchen
```python
import struct, ida_bytes

def patch_direct(ea, target, is_call=False):
op   = 0xE8 if is_call else 0xE9           # CALL rel32 or JMP rel32
disp = target - (ea + 5) & 0xFFFFFFFF
ida_bytes.patch_bytes(ea, bytes([op]) + struct.pack('<I', disp))
```
Nach dem Patchen IDA dazu zwingen, die Funktion neu zu analysieren, damit die vollständige CFG- und Hex-Rays-Ausgabe wiederhergestellt wird:
```python
import ida_auto, idaapi
idaapi.reanalyze_function(idc.get_func_attr(ea, idc.FUNCATTR_START))
```
### 5. Indirekte API-Aufrufe kennzeichnen

Sobald das reale Ziel jedes `call rax` bekannt ist, kannst du IDA mitteilen, was es ist, sodass Parametertypen & Variablennamen automatisch wiederhergestellt werden:
```python
idc.set_callee_name(call_ea, resolved_addr, 0)  # IDA 8.3+
```
### Praktische Vorteile

* Stellt den realen CFG wieder her → decompilation geht von *10* Zeilen auf Tausende.
* Ermöglicht string-cross-reference & xrefs und macht die Verhaltensrekonstruktion trivial.
* Skripte sind wiederverwendbar: lege sie in jeden loader, der durch denselben Trick geschützt ist.

---

## AdaptixC2: Konfigurationsextraktion und TTPs

Siehe die zugehörige Seite:

{{#ref}}
adaptixc2-config-extraction-and-ttps.md
{{#endref}}

## Referenzen

- [Unit42 – Evolving Tactics of SLOW#TEMPEST: A Deep Dive Into Advanced Malware Techniques](https://unit42.paloaltonetworks.com/slow-tempest-malware-obfuscation/)
- SoTap: Lightweight in-app JNI (.so) behavior logger – [github.com/RezaArbabBot/SoTap](https://github.com/RezaArbabBot/SoTap)
- [Unit42 – AdaptixC2: A New Open-Source Framework Leveraged in Real-World Attacks](https://unit42.paloaltonetworks.com/adaptixc2-post-exploitation-framework/)

{{#include ../../banners/hacktricks-training.md}}
