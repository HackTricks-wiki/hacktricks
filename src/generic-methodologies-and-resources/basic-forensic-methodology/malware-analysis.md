# Malware Analysis

{{#include ../../banners/hacktricks-training.md}}

## Forensics CheatSheets

[https://www.jaiminton.com/cheatsheet/DFIR/#](https://www.jaiminton.com/cheatsheet/DFIR/)

## Huduma za Mtandaoni

- [VirusTotal](https://www.virustotal.com/gui/home/upload)
- [HybridAnalysis](https://www.hybrid-analysis.com)
- [Koodous](https://koodous.com)
- [Intezer](https://analyze.intezer.com)
- [Any.Run](https://any.run/)

## Zana za Antivirus na Utambuzi zisizo za Mtandaoni

### Yara

#### Sakinisha
```bash
sudo apt-get install -y yara
```
#### Andaa rules

Tumia script hii kupakua na kuunganisha yote yara malware rules kutoka github: [https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9](https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9)\
Tengeneza saraka _**rules**_ kisha ukimbize script hiyo. Hii itaunda faili liitwalo _**malware_rules.yar**_ ambalo lina yara rules zote za malware.
```bash
wget https://gist.githubusercontent.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9/raw/4ec711d37f1b428b63bed1f786b26a0654aa2f31/malware_yara_rules.py
mkdir rules
python malware_yara_rules.py
```
#### Skana
```bash
yara -w malware_rules.yar image  #Scan 1 file
yara -w malware_rules.yar folder #Scan the whole folder
```
#### YaraGen: Kagua malware na unda rules

Unaweza kutumia zana [**YaraGen**](https://github.com/Neo23x0/yarGen) kutengeneza yara rules kutoka kwa binary. Angalia mafunzo haya: [**Part 1**](https://www.nextron-systems.com/2015/02/16/write-simple-sound-yara-rules/), [**Part 2**](https://www.nextron-systems.com/2015/10/17/how-to-write-simple-but-sound-yara-rules-part-2/), [**Part 3**](https://www.nextron-systems.com/2016/04/15/how-to-write-simple-but-sound-yara-rules-part-3/)
```bash
python3 yarGen.py --update
python3.exe yarGen.py --excludegood -m  ../../mals/
```
### ClamAV

#### Sakinisha
```
sudo apt-get install -y clamav
```
#### Skana
```bash
sudo freshclam      #Update rules
clamscan filepath   #Scan 1 file
clamscan folderpath #Scan the whole folder
```
### [Capa](https://github.com/mandiant/capa)

**Capa** inatambua uwezo unaoweza kuwa hatari katika executables: PE, ELF, .NET. Hivyo itapata mambo kama Att\&ck tactics, au uwezo wenye shaka kama:

- angalia OutputDebugString error
- run as a service
- create process

Pata kwenye [**Github repo**](https://github.com/mandiant/capa).

### IOCs

IOC inamaanisha Indicator Of Compromise. IOC ni seti ya **masharti yanayotambulisha** baadhi ya software zinazoweza kuwa haipendeki au kuthibitishwa kuwa **malware**. Blue Teams hutumia aina hii ya ufafanuzi ili **kutafuta aina hii ya faili zenye madhara** katika **sistimu** na **mitandao** yao.\
Kushirikisha ufafanuzi hivi ni muhimu sana; pale malware inapotambulika kwenye kompyuta na IOC kwa ajili ya malware hiyo ikitengenezwa, Blue Teams wengine wanaweza kuitumia kuitambua malware hiyo haraka zaidi.

Chombo cha kuunda au kuhariri IOCs ni [**IOC Editor**](https://www.fireeye.com/services/freeware/ioc-editor.html)**.**\
Unaweza kutumia zana kama [**Redline**](https://www.fireeye.com/services/freeware/redline.html) kutafuta **IOC zilizofafanuliwa kwenye kifaa**.

### Loki

[**Loki**](https://github.com/Neo23x0/Loki) ni scanner kwa Simple Indicators of Compromise.\
Ugunduzi unategemea mbinu nne za utambuzi:
```
1. File Name IOC
Regex match on full file path/name

2. Yara Rule Check
Yara signature matches on file data and process memory

3. Hash Check
Compares known malicious hashes (MD5, SHA1, SHA256) with scanned files

4. C2 Back Connect Check
Compares process connection endpoints with C2 IOCs (new since version v.10)
```
### Linux Malware Detect

[**Linux Malware Detect (LMD)**](https://www.rfxn.com/projects/linux-malware-detect/) ni skana ya malware kwa Linux iliyotolewa chini ya leseni ya GNU GPLv2, iliyoundwa kwa kuzingatia tishio zinazokumba mazingira yaliyoshirikiwa ya mwenyeji. Inatumia data za tishio kutoka kwa mifumo ya utambuzi wa uvamizi kwenye kingo za mtandao ili kutoa malware zinazotumika katika mashambulizi na kuzalisha saini za kugundua. Zaidi ya hayo, data za tishio hupatikana pia kutoka kwa mawasilisho ya watumiaji kupitia kipengele cha LMD checkout na rasilimali za jamii ya malware.

### rkhunter

Zana kama [**rkhunter**](http://rkhunter.sourceforge.net) zinaweza kutumika kukagua filesystem kwa uwezekano wa **rootkits** na malware.
```bash
sudo ./rkhunter --check -r / -l /tmp/rkhunter.log [--report-warnings-only] [--skip-keypress]
```
### FLOSS

[**FLOSS**](https://github.com/mandiant/flare-floss) ni zana itakayojaribu kutafuta obfuscated strings ndani ya executables kwa kutumia mbinu mbalimbali.

### PEpper

[PEpper ](https://github.com/Th3Hurrican3/PEpper)huchunguza baadhi ya mambo ya msingi ndani ya executable (binary data, entropy, URLs and IPs, baadhi ya yara rules).

### PEstudio

[PEstudio](https://www.winitor.com/download) ni zana inayoruhusu kupata taarifa za Windows executables kama imports, exports, headers, na pia itachunguza virus total na kutambua potential Att\&ck techniques.

### Detect It Easy(DiE)

[**DiE**](https://github.com/horsicq/Detect-It-Easy/) ni zana ya kugundua kama faili ime**encrypted** na pia kutafuta **packers**.

### NeoPI

[**NeoPI** ](https://github.com/CiscoCXSecurity/NeoPI)is script ya Python inayotumia aina mbalimbali za **statistical methods** kutambua yaliyomo yaliyo **obfuscated** na **encrypted** ndani ya text/script files. Kusudi la NeoPI ni kusaidia katika **detection of hidden web shell code**.

### **php-malware-finder**

[**PHP-malware-finder**](https://github.com/nbs-system/php-malware-finder) inajitahidi sana kutambua **obfuscated**/**dodgy code** pamoja na faili zinazotumia **PHP** functions zinazotumiwa mara kwa mara na **malwares**/webshells.

### Apple Binary Signatures

Unapoangalia baadhi ya **malware sample** unapaswa kila mara **check the signature** ya binary kwani **developer** aliyesaini inaweza tayari kuwa **related** na **malware.**
```bash
#Get signer
codesign -vv -d /bin/ls 2>&1 | grep -E "Authority|TeamIdentifier"

#Check if the app’s contents have been modified
codesign --verify --verbose /Applications/Safari.app

#Check if the signature is valid
spctl --assess --verbose /Applications/Safari.app
```
## Mbinu za Ugundaji

### File Stacking

Ikiwa unajua kuwa folda fulani inayoshikilia **faili** za **seva ya wavuti** ilisasishwa mwisho tarehe fulani, **kagua** tarehe ambazo **faili zote** kwenye **seva ya wavuti** ziliundwa na kubadilishwa; ikiwa tarehe yoyote ni **shaka**, angalia faili hiyo.

### Baselines

Ikiwa **faili** za **folda** hazikutakiwa kubadilishwa, unaweza kuhesabu **hash** ya **faili za awali** za folda na **linganisha** nazo zile za **sasa**. Kile kilichobadilishwa kitakuwa **shaka**.

### Uchanganuzi wa Takwimu

Wakati taarifa zimehifadhiwa kwenye logs unaweza **kagua takwimu** kama vile ni mara ngapi kila **faili** ya **seva ya wavuti** ilifikiwa — web shell inaweza kuwa miongoni mwa zilizopatikana mara nyingi.

---

### Android in-app native telemetry (no root)

Kwenye Android, unaweza kuingilia native code ndani ya mchakato wa app lengwa kwa ku-preload library ndogo ya logger kabla libraries nyingine za JNI hazijaanzishwa. Hii inatoa uonekano wa mapema wa tabia za native bila hooks za mfumo mzima au root. Mbinu maarufu ni SoTap: weka libsotap.so kwa ABI sahihi ndani ya APK na injekta wito wa System.loadLibrary("sotap") mapema (kwa mfano, static initializer au Application.onCreate), kisha ukusanye logs kutoka njia za ndani/za nje au tumia Logcat kama fallback.

Tazama ukurasa wa Android native reversing kwa maelezo ya usanidi na njia za logi:

{{#ref}}
../../mobile-pentesting/android-app-pentesting/reversing-native-libraries.md
{{#endref}}

---

## Kuondoa Obfuscation ya Dynamic Control-Flow (JMP/CALL RAX Dispatchers)

Familia za kisasa za malware zinatumia kwa kupindukia obfuscation ya Control-Flow Graph (CFG): badala ya jump/call moja kwa moja wanahesabu marudio wakati wa utekelezaji na kutekeleza `jmp rax` au `call rax`. Dispatcher ndogo (kawaida maagizo tisa) huweka lengo la mwisho kulingana na bendera za CPU `ZF`/`CF`, ikivunja kabisa urejeshaji wa static wa CFG.

Mbinu — iliyoonyeshwa na loader ya SLOW#TEMPEST — inaweza kushindwa kwa mtiririko wa hatua tatu unaoegemea tu IDAPython na emulator ya CPU ya Unicorn.

### 1. Locate every indirect jump / call
```python
import idautils, idc

for ea in idautils.FunctionItems(idc.here()):
mnem = idc.print_insn_mnem(ea)
if mnem in ("jmp", "call") and idc.print_operand(ea, 0) == "rax":
print(f"[+] Dispatcher found @ {ea:X}")
```
### 2. Toa dispatcher byte-code
```python
import idc

def get_dispatcher_start(jmp_ea, count=9):
s = jmp_ea
for _ in range(count):
s = idc.prev_head(s, 0)
return s

start = get_dispatcher_start(jmp_ea)
size  = jmp_ea + idc.get_item_size(jmp_ea) - start
code  = idc.get_bytes(start, size)
open(f"{start:X}.bin", "wb").write(code)
```
### 3. Iiga mara mbili kwa kutumia Unicorn
```python
from unicorn import *
from unicorn.x86_const import *
import struct

def run(code, zf=0, cf=0):
BASE = 0x1000
mu = Uc(UC_ARCH_X86, UC_MODE_64)
mu.mem_map(BASE, 0x1000)
mu.mem_write(BASE, code)
mu.reg_write(UC_X86_REG_RFLAGS, (zf << 6) | cf)
mu.reg_write(UC_X86_REG_RAX, 0)
mu.emu_start(BASE, BASE+len(code))
return mu.reg_read(UC_X86_REG_RAX)
```
Endesha `run(code,0,0)` na `run(code,1,1)` ili kupata malengo ya matawi *false* na *true*.

### 4. Rekebisha tena jump / call ya moja kwa moja
```python
import struct, ida_bytes

def patch_direct(ea, target, is_call=False):
op   = 0xE8 if is_call else 0xE9           # CALL rel32 or JMP rel32
disp = target - (ea + 5) & 0xFFFFFFFF
ida_bytes.patch_bytes(ea, bytes([op]) + struct.pack('<I', disp))
```
Baada ya patching, lazimisha IDA ichambue tena function ili CFG kamili na matokeo ya Hex-Rays virudishwe:
```python
import ida_auto, idaapi
idaapi.reanalyze_function(idc.get_func_attr(ea, idc.FUNCATTR_START))
```
### 5. Weka lebo kwa miito isiyo ya moja kwa moja ya API

Mara tu mahali halisi pa kila `call rax` itakapojulikana, unaweza kumwambia IDA ni nini ili aina za vigezo na majina ya variable vipatikane kiotomatiki:
```python
idc.set_callee_name(call_ea, resolved_addr, 0)  # IDA 8.3+
```
### Manufaa ya vitendo

* Inarejesha CFG halisi → decompilation inaenda kutoka *10* mistari hadi maelfu.
* Inawawezesha string-cross-reference & xrefs, na kuifanya behaviour reconstruction kuwa rahisi.
* Scripts zinaweza kutumika tena: ziweke ndani ya loader yoyote iliyolindwa na trick ile ile.

---

## Marejeo

- [Unit42 – Evolving Tactics of SLOW#TEMPEST: A Deep Dive Into Advanced Malware Techniques](https://unit42.paloaltonetworks.com/slow-tempest-malware-obfuscation/)
- SoTap: Rekoda nyepesi wa tabia ndani ya app kwa JNI (.so) – [github.com/RezaArbabBot/SoTap](https://github.com/RezaArbabBot/SoTap)

{{#include ../../banners/hacktricks-training.md}}
