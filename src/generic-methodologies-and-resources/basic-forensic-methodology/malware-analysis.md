# Análise de Malware

{{#include ../../banners/hacktricks-training.md}}

## Cheatsheets de Forense

[https://www.jaiminton.com/cheatsheet/DFIR/#](https://www.jaiminton.com/cheatsheet/DFIR/)

## Serviços Online

- [VirusTotal](https://www.virustotal.com/gui/home/upload)
- [HybridAnalysis](https://www.hybrid-analysis.com)
- [Koodous](https://koodous.com)
- [Intezer](https://analyze.intezer.com)
- [Any.Run](https://any.run/)

## Ferramentas Offline de Antivírus e Detecção

### Yara

#### Instalação
```bash
sudo apt-get install -y yara
```
#### Preparar regras

Use este script para baixar e mesclar todas as regras yara de malware do github: [https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9](https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9)\
Crie o diretório _**rules**_ e execute-o. Isso criará um arquivo chamado _**malware_rules.yar**_ que contém todas as regras yara para malware.
```bash
wget https://gist.githubusercontent.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9/raw/4ec711d37f1b428b63bed1f786b26a0654aa2f31/malware_yara_rules.py
mkdir rules
python malware_yara_rules.py
```
#### Varredura
```bash
yara -w malware_rules.yar image  #Scan 1 file
yara -w malware_rules.yar folder #Scan the whole folder
```
#### YaraGen: Verificar malware e criar regras

Você pode usar a ferramenta [**YaraGen**](https://github.com/Neo23x0/yarGen) para gerar yara rules a partir de um binário. Confira estes tutoriais: [**Part 1**](https://www.nextron-systems.com/2015/02/16/write-simple-sound-yara-rules/), [**Part 2**](https://www.nextron-systems.com/2015/10/17/how-to-write-simple-but-sound-yara-rules-part-2/), [**Part 3**](https://www.nextron-systems.com/2016/04/15/how-to-write-simple-but-sound-yara-rules-part-3/)
```bash
python3 yarGen.py --update
python3.exe yarGen.py --excludegood -m  ../../mals/
```
### ClamAV

#### Instalação
```
sudo apt-get install -y clamav
```
#### Scan
```bash
sudo freshclam      #Update rules
clamscan filepath   #Scan 1 file
clamscan folderpath #Scan the whole folder
```
### [Capa](https://github.com/mandiant/capa)

**Capa** detecta **capacidades** potencialmente maliciosas em executáveis: PE, ELF, .NET. Assim, encontrará coisas como Att\&ck tactics, ou capacidades suspeitas como:

- verificar erro em OutputDebugString
- executar como um serviço
- criar processo

Obtenha-o no [**Github repo**](https://github.com/mandiant/capa).

### IOCs

IOC significa Indicador de Comprometimento. Um IOC é um conjunto de **condições que identificam** algum software potencialmente indesejado ou confirmado **malware**. Blue Teams usam esse tipo de definição para **procurar por esse tipo de arquivos maliciosos** em seus **sistemas** e **redes**.\
Compartilhar essas definições é muito útil, pois quando um malware é identificado em um computador e um IOC para esse malware é criado, outras Blue Teams podem usá-lo para identificar o malware mais rapidamente.

Uma ferramenta para criar ou modificar IOCs é [**IOC Editor**](https://www.fireeye.com/services/freeware/ioc-editor.html)**.**\
Você pode usar ferramentas como [**Redline**](https://www.fireeye.com/services/freeware/redline.html) para **procurar IOCs definidos em um dispositivo**.

### Loki

[**Loki**](https://github.com/Neo23x0/Loki) é um scanner para Indicadores Simples de Comprometimento.\
A detecção é baseada em quatro métodos de detecção:
```
1. File Name IOC
Regex match on full file path/name

2. Yara Rule Check
Yara signature matches on file data and process memory

3. Hash Check
Compares known malicious hashes (MD5, SHA1, SHA256) with scanned files

4. C2 Back Connect Check
Compares process connection endpoints with C2 IOCs (new since version v.10)
```
### Linux Malware Detect

[**Linux Malware Detect (LMD)**](https://www.rfxn.com/projects/linux-malware-detect/) é um scanner de malware para Linux lançado sob a licença GNU GPLv2, projetado para as ameaças enfrentadas em ambientes de hospedagem compartilhada. Ele usa dados de ameaça de sistemas de detecção de intrusão de borda de rede para extrair malware que está sendo usado ativamente em ataques e gerar assinaturas para detecção. Além disso, os dados de ameaça também são derivados de submissões de usuários com o recurso checkout do LMD e de recursos da comunidade de malware.

### rkhunter

Ferramentas como [**rkhunter**](http://rkhunter.sourceforge.net) podem ser usadas para verificar o sistema de arquivos em busca de possíveis **rootkits** e malware.
```bash
sudo ./rkhunter --check -r / -l /tmp/rkhunter.log [--report-warnings-only] [--skip-keypress]
```
### FLOSS

[**FLOSS**](https://github.com/mandiant/flare-floss) é uma ferramenta que tenta encontrar strings ofuscadas dentro de executáveis usando diferentes técnicas.

### PEpper

[PEpper ](https://github.com/Th3Hurrican3/PEpper) verifica alguns elementos básicos dentro do executável (binary data, entropy, URLs and IPs, algumas regras yara).

### PEstudio

[PEstudio](https://www.winitor.com/download) é uma ferramenta que permite obter informações de executáveis Windows como imports, exports, headers, mas também verifica o VirusTotal e encontra potenciais técnicas do Att\&ck.

### Detect It Easy(DiE)

[**DiE**](https://github.com/horsicq/Detect-It-Easy/) é uma ferramenta para detectar se um arquivo está **criptografado** e também encontrar **packers**.

### NeoPI

[**NeoPI** ](https://github.com/CiscoCXSecurity/NeoPI)is um script Python que usa uma variedade de **métodos estatísticos** para detectar conteúdo **ofuscado** e **criptografado** dentro de arquivos de texto/script. O propósito do NeoPI é auxiliar na **detecção de código de web shell oculto**.

### **php-malware-finder**

[**PHP-malware-finder**](https://github.com/nbs-system/php-malware-finder) faz o seu melhor para detectar código **ofuscado**/**suspeito** assim como arquivos que usam funções **PHP** frequentemente usadas em **malwares**/webshells.

### Apple Binary Signatures

Ao analisar alguma **amostra de malware** você deve sempre **verificar a assinatura** do binário, pois o **desenvolvedor** que a assinou pode já estar **relacionado** com **malware.**
```bash
#Get signer
codesign -vv -d /bin/ls 2>&1 | grep -E "Authority|TeamIdentifier"

#Check if the app’s contents have been modified
codesign --verify --verbose /Applications/Safari.app

#Check if the signature is valid
spctl --assess --verbose /Applications/Safari.app
```
## Técnicas de Detecção

### File Stacking

Se você sabe que alguma pasta contendo os **files** de um **web server** foi **atualizada por último em uma determinada data**, **verifique** a **data** em que todos os **files** no **web server** foram criados e modificados e se alguma data for **suspeita**, cheque esse file.

### Baselines

Se os **files** de uma pasta **não deveriam ter sido modificados**, você pode calcular o **hash** dos **original files** da pasta e **compará-los** com os atuais. Qualquer coisa modificada será **suspeita**.

### Statistical Analysis

Quando a informação é salva em logs você pode **verificar estatísticas, como quantas vezes cada file de um web server foi acessado, já que um web shell pode ser um dos mais**.

---

### Android in-app native telemetry (no root)

On Android, você pode instrumentar código nativo dentro do processo do app alvo pré-carregando uma pequena biblioteca logger antes que outras libs JNI inicializem. Isso dá visibilidade precoce do comportamento nativo sem hooks a nível de sistema ou root. Uma abordagem popular é SoTap: coloque libsotap.so para a ABI correta dentro do APK e injete uma chamada System.loadLibrary("sotap") cedo (por exemplo, em um inicializador estático ou Application.onCreate), então colete logs de caminhos internos/externos ou use Logcat como fallback.

See the Android native reversing page for setup details and log paths:

{{#ref}}
../../mobile-pentesting/android-app-pentesting/reversing-native-libraries.md
{{#endref}}

---

## Desobfuscando Control-Flow Dinâmico (JMP/CALL RAX Dispatchers)

Famílias modernas de malware abusam fortemente da obfuscação do Control-Flow Graph (CFG): em vez de um jump/call direto elas calculam o destino em tempo de execução e executam um `jmp rax` ou `call rax`. Um pequeno *dispatcher* (tipicamente nove instruções) define o alvo final dependendo das flags da CPU `ZF`/`CF`, quebrando completamente a recuperação estática do CFG.

A técnica – demonstrada pelo loader SLOW#TEMPEST – pode ser derrotada com um fluxo de trabalho em três passos que depende apenas de IDAPython e do emulador de CPU Unicorn.

### 1. Localize cada jump/call indireto
```python
import idautils, idc

for ea in idautils.FunctionItems(idc.here()):
mnem = idc.print_insn_mnem(ea)
if mnem in ("jmp", "call") and idc.print_operand(ea, 0) == "rax":
print(f"[+] Dispatcher found @ {ea:X}")
```
### 2. Extrair o byte-code do dispatcher
```python
import idc

def get_dispatcher_start(jmp_ea, count=9):
s = jmp_ea
for _ in range(count):
s = idc.prev_head(s, 0)
return s

start = get_dispatcher_start(jmp_ea)
size  = jmp_ea + idc.get_item_size(jmp_ea) - start
code  = idc.get_bytes(start, size)
open(f"{start:X}.bin", "wb").write(code)
```
### 3. Emule-o duas vezes com Unicorn
```python
from unicorn import *
from unicorn.x86_const import *
import struct

def run(code, zf=0, cf=0):
BASE = 0x1000
mu = Uc(UC_ARCH_X86, UC_MODE_64)
mu.mem_map(BASE, 0x1000)
mu.mem_write(BASE, code)
mu.reg_write(UC_X86_REG_RFLAGS, (zf << 6) | cf)
mu.reg_write(UC_X86_REG_RAX, 0)
mu.emu_start(BASE, BASE+len(code))
return mu.reg_read(UC_X86_REG_RAX)
```
Execute `run(code,0,0)` e `run(code,1,1)` para obter os alvos de branch *false* e *true*.

### 4. Aplicar patch para um jump / call direto
```python
import struct, ida_bytes

def patch_direct(ea, target, is_call=False):
op   = 0xE8 if is_call else 0xE9           # CALL rel32 or JMP rel32
disp = target - (ea + 5) & 0xFFFFFFFF
ida_bytes.patch_bytes(ea, bytes([op]) + struct.pack('<I', disp))
```
Após aplicar o patch, force o IDA a reanalisar a função para que o CFG completo e a saída do Hex-Rays sejam restaurados:
```python
import ida_auto, idaapi
idaapi.reanalyze_function(idc.get_func_attr(ea, idc.FUNCATTR_START))
```
### 5. Rotular chamadas de API indiretas

Uma vez que o destino real de cada `call rax` seja conhecido, você pode informar o IDA sobre ele para que os tipos de parâmetros & nomes de variáveis sejam recuperados automaticamente:
```python
idc.set_callee_name(call_ea, resolved_addr, 0)  # IDA 8.3+
```
### Benefícios práticos

* Restaura o CFG real → a decompilação passa de *10* linhas para milhares.
* Permite string-cross-reference & xrefs, tornando a reconstrução do comportamento trivial.
* Scripts são reutilizáveis: coloque-os em qualquer loader protegido pelo mesmo truque.

---

## Referências

- [Unit42 – Evolving Tactics of SLOW#TEMPEST: A Deep Dive Into Advanced Malware Techniques](https://unit42.paloaltonetworks.com/slow-tempest-malware-obfuscation/)
- SoTap: Lightweight in-app JNI (.so) behavior logger – [github.com/RezaArbabBot/SoTap](https://github.com/RezaArbabBot/SoTap)

{{#include ../../banners/hacktricks-training.md}}
