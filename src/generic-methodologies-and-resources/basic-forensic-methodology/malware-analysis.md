# Malware Analysis

{{#include ../../banners/hacktricks-training.md}}

## Forensics CheatSheets

[https://www.jaiminton.com/cheatsheet/DFIR/#](https://www.jaiminton.com/cheatsheet/DFIR/)

## Aanlyn Dienste

- [VirusTotal](https://www.virustotal.com/gui/home/upload)
- [HybridAnalysis](https://www.hybrid-analysis.com)
- [Koodous](https://koodous.com)
- [Intezer](https://analyze.intezer.com)
- [Any.Run](https://any.run/)

## Offline Antivirus- en Opsporingsinstrumente

### Yara

#### Installeer
```bash
sudo apt-get install -y yara
```
#### Berei reëls voor

Gebruik hierdie script om al die yara malware reëls van github af te laai en saam te voeg: [https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9](https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9)\
Skep die _**rules**_ directory en voer dit uit. Dit sal 'n lêer genaamd _**malware_rules.yar**_ skep wat al die yara reëls vir malware bevat.
```bash
wget https://gist.githubusercontent.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9/raw/4ec711d37f1b428b63bed1f786b26a0654aa2f31/malware_yara_rules.py
mkdir rules
python malware_yara_rules.py
```
#### Skandering
```bash
yara -w malware_rules.yar image  #Scan 1 file
yara -w malware_rules.yar folder #Scan the whole folder
```
#### YaraGen: Kontroleer vir malware en skep rules

Jy kan die tool [**YaraGen**](https://github.com/Neo23x0/yarGen) gebruik om yara rules uit 'n binary te genereer. Kyk na hierdie tutorials: [**Part 1**](https://www.nextron-systems.com/2015/02/16/write-simple-sound-yara-rules/), [**Part 2**](https://www.nextron-systems.com/2015/10/17/how-to-write-simple-but-sound-yara-rules-part-2/), [**Part 3**](https://www.nextron-systems.com/2016/04/15/how-to-write-simple-but-sound-yara-rules-part-3/)
```bash
python3 yarGen.py --update
python3.exe yarGen.py --excludegood -m  ../../mals/
```
### ClamAV

#### Installeer
```
sudo apt-get install -y clamav
```
#### Skandering
```bash
sudo freshclam      #Update rules
clamscan filepath   #Scan 1 file
clamscan folderpath #Scan the whole folder
```
### [Capa](https://github.com/mandiant/capa)

**Capa** detecteer potensieel kwaadwillige **capabilities** in uitvoerbare lêers: PE, ELF, .NET. Dit sal dus dinge vind soos Att\&ck tactics, of verdagte capabilities soos:

- check for OutputDebugString error
- run as a service
- create process

Kry dit in die [**Github repo**](https://github.com/mandiant/capa).

### IOCs

IOC beteken Indicator Of Compromise. 'n IOC is 'n stel **voorwaardes wat identifiseer** sekere potensieel ongewensde sagteware of bevestigde **malware**. Blue Teams gebruik hierdie soort definisie om te **soek na hierdie soort kwaadwillige lêers** in hul **sisteme** en **netwerke**.\
Om hierdie definisies te deel is baie nuttig, want wanneer **malware** in 'n rekenaar geïdentifiseer word en 'n IOC vir daardie **malware** geskep word, kan ander Blue Teams dit gebruik om die **malware** vinniger te identifiseer.

'n Instrument om IOCs te skep of te wysig is [**IOC Editor**](https://www.fireeye.com/services/freeware/ioc-editor.html)**.**\
Jy kan gereedskap soos [**Redline**](https://www.fireeye.com/services/freeware/redline.html) gebruik om **te soek na gedefinieerde IOCs in 'n toestel**.

### Loki

[**Loki**](https://github.com/Neo23x0/Loki) is 'n skandeerder vir Simple Indicators of Compromise.\
Deteksie is gebaseer op vier deteksiemetodes:
```
1. File Name IOC
Regex match on full file path/name

2. Yara Rule Check
Yara signature matches on file data and process memory

3. Hash Check
Compares known malicious hashes (MD5, SHA1, SHA256) with scanned files

4. C2 Back Connect Check
Compares process connection endpoints with C2 IOCs (new since version v.10)
```
### Linux Malware Detect

[**Linux Malware Detect (LMD)**](https://www.rfxn.com/projects/linux-malware-detect/) is 'n malware-skandeerder vir Linux wat vrygestel is onder die GNU GPLv2-lisensie, en is ontwerp vir die bedreigings wat in gedeelde gehoste omgewings teëgekom word. Dit gebruik bedreigingsdata van netwerkrand indringingsopsporingsisteme om malware te onttrek wat aktief in aanvalle gebruik word, en genereer signatures vir opsporing. Daarbenewens word bedreigingsdata ook verkry uit gebruikersinskrywings via die LMD checkout-funksie en malware-communitybronne.

### rkhunter

Instrumente soos [**rkhunter**](http://rkhunter.sourceforge.net) kan gebruik word om die lêerstelsel te ondersoek vir moontlike **rootkits** en malware.
```bash
sudo ./rkhunter --check -r / -l /tmp/rkhunter.log [--report-warnings-only] [--skip-keypress]
```
### FLOSS

[**FLOSS**](https://github.com/mandiant/flare-floss) is 'n hulpmiddel wat probeer om geobfusceerde strings binne uitvoerbare lêers te vind deur verskillende tegnieke te gebruik.

### PEpper

[PEpper ](https://github.com/Th3Hurrican3/PEpper) kontroleer sommige basiese dinge in die uitvoerbare lêer (binary data, entropy, URLs and IPs, some yara rules).

### PEstudio

[PEstudio](https://www.winitor.com/download) is 'n hulpmiddel wat inligting oor Windows executables verskaf, soos imports, exports, headers, maar sal ook virus total kontroleer en potensiële Att\&ck techniques vind.

### Detect It Easy(DiE)

[**DiE**](https://github.com/horsicq/Detect-It-Easy/) is 'n hulpmiddel om te bepaal of 'n lêer **geënkripteer** is en ook **packers** te vind.

### NeoPI

[**NeoPI** ](https://github.com/CiscoCXSecurity/NeoPI)is 'n Python-skrip wat 'n verskeidenheid van **statistiese metodes** gebruik om **geobfusceerde** en **geënkripteerde** inhoud binne teks-/script-lêers op te spoor. Die beoogde doel van NeoPI is om te help met die **opsporing van verborge web shell code**.

### **php-malware-finder**

[**PHP-malware-finder**](https://github.com/nbs-system/php-malware-finder) doen sy bes om **geobfusceerde**/**skadelike code** op te spoor, sowel as lêers wat **PHP** funksies gebruik wat dikwels in **malwares**/webshells gebruik word.

### Apple Binary Signatures

Wanneer jy 'n **malware sample** nagaan, moet jy altyd die **handtekening** van die binêre lêer kontroleer, aangesien die **developer** wat dit gesigneer het dalk reeds met **malware** verwant is.
```bash
#Get signer
codesign -vv -d /bin/ls 2>&1 | grep -E "Authority|TeamIdentifier"

#Check if the app’s contents have been modified
codesign --verify --verbose /Applications/Safari.app

#Check if the signature is valid
spctl --assess --verbose /Applications/Safari.app
```
## Opsporingstegnieke

### File Stacking

As jy weet dat 'n gids wat die **files** van 'n **web server** bevat **laas opgedateer is op 'n sekere datum**. **Kontroleer** die **datum** waarop al die **files** in die **web server** geskep en gewysig is, en as enige datum **verdagtig** is, ondersoek daardie **file**.

### Baselines

As die **files** van 'n gids **nie veronderstel was om gewysig te word nie**, kan jy die **hash** van die **original files** van die gids bereken en dit **vergelyk** met die **current** een. Enige item wat verander is sal **verdagtig** wees.

### Statistical Analysis

Wanneer die inligting in logs gestoor word, kan jy **statistieke kontroleer, soos hoeveel keer elke file van 'n web server geraadpleeg is**, aangesien 'n **web shell** moontlik baie keer geraadpleeg word.

---

### Android in-app native telemetry (no root)

On Android, you can instrument native code inside the target app process by preloading a tiny logger library before other JNI libs initialize. This gives early visibility into native behavior without system-wide hooks or root. A popular approach is SoTap: drop libsotap.so for the right ABI into the APK and inject a System.loadLibrary("sotap") call early (e.g., static initializer or Application.onCreate), then collect logs from internal/external paths or Logcat fallback.

See the Android native reversing page for setup details and log paths:

{{#ref}}
../../mobile-pentesting/android-app-pentesting/reversing-native-libraries.md
{{#endref}}

---

## Deobfuscating Dynamic Control-Flow (JMP/CALL RAX Dispatchers)

Modern malware families heavily abuse Control-Flow Graph (CFG) obfuscation: instead of a direct jump/call they compute the destination at run-time and execute a `jmp rax` or `call rax`.  A small *dispatcher* (typically nine instructions) sets the final target depending on the CPU `ZF`/`CF` flags, completely breaking static CFG recovery.

The technique – showcased by the SLOW#TEMPEST loader – can be defeated with a three-step workflow that only relies on IDAPython and the Unicorn CPU emulator.

### 1. Lokaliseer elke indirect jump / call
```python
import idautils, idc

for ea in idautils.FunctionItems(idc.here()):
mnem = idc.print_insn_mnem(ea)
if mnem in ("jmp", "call") and idc.print_operand(ea, 0) == "rax":
print(f"[+] Dispatcher found @ {ea:X}")
```
### 2. Ekstraheer die dispatcher byte-code
```python
import idc

def get_dispatcher_start(jmp_ea, count=9):
s = jmp_ea
for _ in range(count):
s = idc.prev_head(s, 0)
return s

start = get_dispatcher_start(jmp_ea)
size  = jmp_ea + idc.get_item_size(jmp_ea) - start
code  = idc.get_bytes(start, size)
open(f"{start:X}.bin", "wb").write(code)
```
### 3. Emuleer dit twee keer met Unicorn
```python
from unicorn import *
from unicorn.x86_const import *
import struct

def run(code, zf=0, cf=0):
BASE = 0x1000
mu = Uc(UC_ARCH_X86, UC_MODE_64)
mu.mem_map(BASE, 0x1000)
mu.mem_write(BASE, code)
mu.reg_write(UC_X86_REG_RFLAGS, (zf << 6) | cf)
mu.reg_write(UC_X86_REG_RAX, 0)
mu.emu_start(BASE, BASE+len(code))
return mu.reg_read(UC_X86_REG_RAX)
```
Voer `run(code,0,0)` en `run(code,1,1)` uit om die *false* en *true* branch targets te bekom.

### 4. Patch back a direct jump / call
```python
import struct, ida_bytes

def patch_direct(ea, target, is_call=False):
op   = 0xE8 if is_call else 0xE9           # CALL rel32 or JMP rel32
disp = target - (ea + 5) & 0xFFFFFFFF
ida_bytes.patch_bytes(ea, bytes([op]) + struct.pack('<I', disp))
```
Na patching, dwing IDA om die funksie weer te ontleed sodat die volledige CFG en Hex-Rays-uitset herstel word:
```python
import ida_auto, idaapi
idaapi.reanalyze_function(idc.get_func_attr(ea, idc.FUNCATTR_START))
```
### 5. Merk indirekte API calls

Sodra die werklike bestemming van elke `call rax` bekend is, kan jy aan IDA sê wat dit is sodat parameter-tipes & veranderlike name outomaties herstel word:
```python
idc.set_callee_name(call_ea, resolved_addr, 0)  # IDA 8.3+
```
### Praktiese voordele

* Herstel die werklike CFG → dekompilasie gaan van *10* reëls na duisende.
* Maak string-cross-reference & xrefs moontlik, wat gedragsheropbou triviaal maak.
* Skripte is herbruikbaar: plaas dit in enige loader wat deur dieselfde truuk beskerm word.

---

## Verwysings

- [Unit42 – Evolving Tactics of SLOW#TEMPEST: A Deep Dive Into Advanced Malware Techniques](https://unit42.paloaltonetworks.com/slow-tempest-malware-obfuscation/)
- SoTap: Lightweight in-app JNI (.so) behavior logger – [github.com/RezaArbabBot/SoTap](https://github.com/RezaArbabBot/SoTap)

{{#include ../../banners/hacktricks-training.md}}
