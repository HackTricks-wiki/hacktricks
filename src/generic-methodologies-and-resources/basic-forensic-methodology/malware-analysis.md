# Analyse de Malware

{{#include ../../banners/hacktricks-training.md}}

## Forensics CheatSheets

[https://www.jaiminton.com/cheatsheet/DFIR/#](https://www.jaiminton.com/cheatsheet/DFIR/)

## Services en ligne

- [VirusTotal](https://www.virustotal.com/gui/home/upload)
- [HybridAnalysis](https://www.hybrid-analysis.com)
- [Koodous](https://koodous.com)
- [Intezer](https://analyze.intezer.com)
- [Any.Run](https://any.run/)

## Outils antivirus et de détection hors ligne

### Yara

#### Installation
```bash
sudo apt-get install -y yara
```
#### Préparer les règles

Utilisez ce script pour télécharger et fusionner toutes les règles yara malware depuis github : [https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9](https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9)  
Créez le répertoire _**rules**_ et exécutez le script. Cela créera un fichier nommé _**malware_rules.yar**_ qui contient toutes les règles yara pour malware.
```bash
wget https://gist.githubusercontent.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9/raw/4ec711d37f1b428b63bed1f786b26a0654aa2f31/malware_yara_rules.py
mkdir rules
python malware_yara_rules.py
```
#### Analyse
```bash
yara -w malware_rules.yar image  #Scan 1 file
yara -w malware_rules.yar folder #Scan the whole folder
```
#### YaraGen: Vérifier la présence de malware et créer des règles

Vous pouvez utiliser l'outil [**YaraGen**](https://github.com/Neo23x0/yarGen) pour générer des règles yara à partir d'un binaire. Consultez ces tutoriels : [**Part 1**](https://www.nextron-systems.com/2015/02/16/write-simple-sound-yara-rules/), [**Part 2**](https://www.nextron-systems.com/2015/10/17/how-to-write-simple-but-sound-yara-rules-part-2/), [**Part 3**](https://www.nextron-systems.com/2016/04/15/how-to-write-simple-but-sound-yara-rules-part-3/)
```bash
python3 yarGen.py --update
python3.exe yarGen.py --excludegood -m  ../../mals/
```
### ClamAV

#### Installation
```
sudo apt-get install -y clamav
```
#### Analyse
```bash
sudo freshclam      #Update rules
clamscan filepath   #Scan 1 file
clamscan folderpath #Scan the whole folder
```
### [Capa](https://github.com/mandiant/capa)

**Capa** détecte des **capabilities** potentiellement malveillantes dans les exécutables : PE, ELF, .NET. Il trouvera donc des éléments tels que les tactiques Att\&ck, ou des capabilities suspectes telles que :

- check for OutputDebugString error
- run as a service
- create process

Récupérez-le dans le [**Github repo**](https://github.com/mandiant/capa).

### IOCs

IOC signifie Indicator Of Compromise. Un IOC est un ensemble de **conditions qui identifient** un logiciel potentiellement indésirable ou un **malware** confirmé. Les Blue Teams utilisent ce type de définition pour **rechercher ce type de fichiers malveillants** dans leurs **systèmes** et **réseaux**.\
Partager ces définitions est très utile : lorsqu'un malware est identifié sur un ordinateur et qu'un IOC pour ce malware est créé, d'autres Blue Teams peuvent l'utiliser pour identifier le malware plus rapidement.

Un outil pour créer ou modifier des IOCs est [**IOC Editor**](https://www.fireeye.com/services/freeware/ioc-editor.html).\
Vous pouvez utiliser des outils comme [**Redline**](https://www.fireeye.com/services/freeware/redline.html) pour **chercher des IOCs définis sur un appareil**.

### Loki

[**Loki**](https://github.com/Neo23x0/Loki) est un scanner pour des Simple Indicators of Compromise.\
La détection se base sur quatre méthodes de détection :
```
1. File Name IOC
Regex match on full file path/name

2. Yara Rule Check
Yara signature matches on file data and process memory

3. Hash Check
Compares known malicious hashes (MD5, SHA1, SHA256) with scanned files

4. C2 Back Connect Check
Compares process connection endpoints with C2 IOCs (new since version v.10)
```
### Linux Malware Detect

[**Linux Malware Detect (LMD)**](https://www.rfxn.com/projects/linux-malware-detect/) est un scanner de malware pour Linux publié sous la licence GNU GPLv2, conçu autour des menaces rencontrées dans les environnements d'hébergement mutualisé. Il utilise des données de menace issues de systèmes de détection d'intrusion en périphérie réseau pour extraire les malware utilisés activement dans des attaques et génère des signatures pour leur détection. De plus, les données de menace proviennent également des soumissions d'utilisateurs via la fonctionnalité LMD checkout et des ressources communautaires sur les malware.

### rkhunter

Des outils comme [**rkhunter**](http://rkhunter.sourceforge.net) peuvent être utilisés pour vérifier le système de fichiers à la recherche de rootkits et de malware possibles.
```bash
sudo ./rkhunter --check -r / -l /tmp/rkhunter.log [--report-warnings-only] [--skip-keypress]
```
### FLOSS

[**FLOSS**](https://github.com/mandiant/flare-floss) est un outil qui va tenter de trouver des chaînes obfuscated à l'intérieur des exécutables en utilisant différentes techniques.

### PEpper

[PEpper ](https://github.com/Th3Hurrican3/PEpper) vérifie certaines informations de base à l'intérieur de l'exécutable (binary data, entropy, URLs and IPs, some yara rules).

### PEstudio

[PEstudio](https://www.winitor.com/download) est un outil qui permet d'obtenir des informations sur les exécutables Windows telles que imports, exports, headers, mais il vérifiera aussi virus total et trouvera de potentielles Att\&ck techniques.

### Detect It Easy(DiE)

[**DiE**](https://github.com/horsicq/Detect-It-Easy/) est un outil pour détecter si un fichier est **encrypted** et aussi trouver des **packers**.

### NeoPI

[**NeoPI** ](https://github.com/CiscoCXSecurity/NeoPI) est un script Python qui utilise une variété de **méthodes statistiques** pour détecter du contenu **obfuscated** et **encrypted** dans des fichiers texte/script. Le but prévu de NeoPI est d'aider à la **detection of hidden web shell code**.

### **php-malware-finder**

[**PHP-malware-finder**](https://github.com/nbs-system/php-malware-finder) fait de son mieux pour détecter des **obfuscated**/**dodgy code** ainsi que des fichiers utilisant des fonctions **PHP** souvent utilisées dans des **malwares**/webshells.

### Apple Binary Signatures

Lors de l'analyse d'un **échantillon de malware** vous devriez toujours **vérifier la signature** du binaire car le **développeur** qui l'a signé peut déjà être **lié** à des **malware**.
```bash
#Get signer
codesign -vv -d /bin/ls 2>&1 | grep -E "Authority|TeamIdentifier"

#Check if the app’s contents have been modified
codesign --verify --verbose /Applications/Safari.app

#Check if the signature is valid
spctl --assess --verbose /Applications/Safari.app
```
## Techniques de détection

### File Stacking

Si vous savez qu'un dossier contenant les **files** d'un **web server** a été **last updated on some date**, vérifiez la **date** de création et de modification de tous les **files** du **web server** ; si une **date** semble **suspicious**, examinez ce file.

### Baselines

Si les **files** d'un dossier **shouldn't have been modified**, vous pouvez calculer le **hash** des **original files** du dossier et **compare** ceux-ci avec les versions **current**. Tout élément modifié sera **suspicious**.

### Statistical Analysis

Lorsque l'information est enregistrée dans des **logs**, vous pouvez **check statistics** comme le nombre de fois où chaque **file** du **web server** a été accédé — un **web shell** peut être l'un des plus fréquents.

---

### Android in-app native telemetry (no root)

On **Android**, vous pouvez instrumenter du code natif à l'intérieur du processus de l'app cible en préchargeant une petite bibliothèque de logging avant l'initialisation des autres libs **JNI**. Cela offre une visibilité précoce sur le comportement natif sans hooks système globaux ni root. Une approche populaire est **SoTap** : déposer **libsotap.so** pour le bon **ABI** dans l'**APK** et injecter un appel System.loadLibrary("sotap") tôt (p.ex. initialiseur statique ou Application.onCreate), puis collecter les logs depuis des chemins internes/externes ou en fallback via **Logcat**.

See the Android native reversing page for setup details and log paths:

{{#ref}}
../../mobile-pentesting/android-app-pentesting/reversing-native-libraries.md
{{#endref}}

---

## Deobfuscating Dynamic Control-Flow (JMP/CALL RAX Dispatchers)

Modern **malware** families heavily abuse Control-Flow Graph (CFG) obfuscation: instead of a direct jump/call they compute the destination at run-time and execute a `jmp rax` or `call rax`.  A small *dispatcher* (typically nine instructions) sets the final target depending on the CPU `ZF`/`CF` flags, completely breaking static CFG recovery.

The technique – showcased by the **SLOW#TEMPEST** loader – can be defeated with a three-step workflow that only relies on **IDAPython** and the **Unicorn CPU emulator**.

### 1. Localiser chaque jump / call indirect
```python
import idautils, idc

for ea in idautils.FunctionItems(idc.here()):
mnem = idc.print_insn_mnem(ea)
if mnem in ("jmp", "call") and idc.print_operand(ea, 0) == "rax":
print(f"[+] Dispatcher found @ {ea:X}")
```
### 2. Extraire le dispatcher byte-code
```python
import idc

def get_dispatcher_start(jmp_ea, count=9):
s = jmp_ea
for _ in range(count):
s = idc.prev_head(s, 0)
return s

start = get_dispatcher_start(jmp_ea)
size  = jmp_ea + idc.get_item_size(jmp_ea) - start
code  = idc.get_bytes(start, size)
open(f"{start:X}.bin", "wb").write(code)
```
### 3. Émulez-le deux fois avec Unicorn
```python
from unicorn import *
from unicorn.x86_const import *
import struct

def run(code, zf=0, cf=0):
BASE = 0x1000
mu = Uc(UC_ARCH_X86, UC_MODE_64)
mu.mem_map(BASE, 0x1000)
mu.mem_write(BASE, code)
mu.reg_write(UC_X86_REG_RFLAGS, (zf << 6) | cf)
mu.reg_write(UC_X86_REG_RAX, 0)
mu.emu_start(BASE, BASE+len(code))
return mu.reg_read(UC_X86_REG_RAX)
```
Exécutez `run(code,0,0)` et `run(code,1,1)` pour obtenir les cibles de branche *false* et *true*.

### 4. Rétablir un jump / call direct
```python
import struct, ida_bytes

def patch_direct(ea, target, is_call=False):
op   = 0xE8 if is_call else 0xE9           # CALL rel32 or JMP rel32
disp = target - (ea + 5) & 0xFFFFFFFF
ida_bytes.patch_bytes(ea, bytes([op]) + struct.pack('<I', disp))
```
Après patching, forcez IDA à réanalyser la fonction afin que le CFG complet et la sortie Hex-Rays soient restaurés:
```python
import ida_auto, idaapi
idaapi.reanalyze_function(idc.get_func_attr(ea, idc.FUNCATTR_START))
```
### 5. Étiqueter les appels API indirects

Une fois que la véritable destination de chaque `call rax` est connue, vous pouvez indiquer à IDA ce dont il s'agit afin que les types de paramètres et les noms de variables soient récupérés automatiquement :
```python
idc.set_callee_name(call_ea, resolved_addr, 0)  # IDA 8.3+
```
### Avantages pratiques

* Restaure le vrai CFG → la décompilation passe de *10* lignes à des milliers.
* Permet le string-cross-reference & les xrefs, rendant la reconstruction du comportement triviale.
* Les scripts sont réutilisables : placez-les dans n'importe quel loader protégé par la même astuce.

---

## AdaptixC2: Extraction de configuration et TTPs

Voir la page dédiée :

{{#ref}}
adaptixc2-config-extraction-and-ttps.md
{{#endref}}

## Références

- [Unit42 – Evolving Tactics of SLOW#TEMPEST: A Deep Dive Into Advanced Malware Techniques](https://unit42.paloaltonetworks.com/slow-tempest-malware-obfuscation/)
- SoTap : enregistreur léger de comportement JNI in-app (.so) – [github.com/RezaArbabBot/SoTap](https://github.com/RezaArbabBot/SoTap)
- [Unit42 – AdaptixC2: A New Open-Source Framework Leveraged in Real-World Attacks](https://unit42.paloaltonetworks.com/adaptixc2-post-exploitation-framework/)

{{#include ../../banners/hacktricks-training.md}}
