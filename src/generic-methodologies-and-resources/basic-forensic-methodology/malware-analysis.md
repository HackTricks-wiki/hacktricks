# Malware Analysis

{{#include ../../banners/hacktricks-training.md}}

## Forensics CheatSheets

[https://www.jaiminton.com/cheatsheet/DFIR/#](https://www.jaiminton.com/cheatsheet/DFIR/)

## Servizi online

- [VirusTotal](https://www.virustotal.com/gui/home/upload)
- [HybridAnalysis](https://www.hybrid-analysis.com)
- [Koodous](https://koodous.com)
- [Intezer](https://analyze.intezer.com)
- [Any.Run](https://any.run/)

## Strumenti antivirus e di rilevamento offline

### Yara

#### Installazione
```bash
sudo apt-get install -y yara
```
#### Preparare le regole

Usa questo script per scaricare e unire tutte le regole yara per malware da github: [https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9](https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9)\
Crea la directory _**rules**_ ed esegui lo script. Questo creerà un file chiamato _**malware_rules.yar**_ che contiene tutte le regole yara per malware.
```bash
wget https://gist.githubusercontent.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9/raw/4ec711d37f1b428b63bed1f786b26a0654aa2f31/malware_yara_rules.py
mkdir rules
python malware_yara_rules.py
```
#### Scansione
```bash
yara -w malware_rules.yar image  #Scan 1 file
yara -w malware_rules.yar folder #Scan the whole folder
```
#### YaraGen: Verificare la presenza di malware e creare rules

Puoi usare lo strumento [**YaraGen**](https://github.com/Neo23x0/yarGen) per generare yara rules da un binary. Consulta questi tutorial: [**Part 1**](https://www.nextron-systems.com/2015/02/16/write-simple-sound-yara-rules/), [**Part 2**](https://www.nextron-systems.com/2015/10/17/how-to-write-simple-but-sound-yara-rules-part-2/), [**Part 3**](https://www.nextron-systems.com/2016/04/15/how-to-write-simple-but-sound-yara-rules-part-3/)
```bash
python3 yarGen.py --update
python3.exe yarGen.py --excludegood -m  ../../mals/
```
### ClamAV

#### Installazione
```
sudo apt-get install -y clamav
```
#### Scansione
```bash
sudo freshclam      #Update rules
clamscan filepath   #Scan 1 file
clamscan folderpath #Scan the whole folder
```
### [Capa](https://github.com/mandiant/capa)

**Capa** rileva potenziali **capabilities** dannose in eseguibili: PE, ELF, .NET. Quindi troverà cose come Att\&ck tactics, o capabilities sospette come:

- check for OutputDebugString error
- run as a service
- create process

Scaricalo dal [**Github repo**](https://github.com/mandiant/capa).

### IOCs

IOC significa Indicator Of Compromise. Un IOC è un insieme di **condizioni che identificano** alcuni software potenzialmente indesiderati o **malware** confermato. I Blue Teams usano questo tipo di definizione per **cercare questo tipo di file maligni** nei loro **systems** e **networks**.\
Condividere queste definizioni è molto utile: quando un malware viene identificato in un computer e viene creato un IOC per quel malware, altri Blue Teams possono usarlo per identificare il malware più velocemente.

Uno strumento per creare o modificare IOC è [**IOC Editor**](https://www.fireeye.com/services/freeware/ioc-editor.html)**.**\
Puoi usare strumenti come [**Redline**](https://www.fireeye.com/services/freeware/redline.html) per **cercare gli IOC definiti in un dispositivo**.

### Loki

[**Loki**](https://github.com/Neo23x0/Loki) è uno scanner per Simple Indicators of Compromise.\
La rilevazione si basa su quattro metodi di rilevamento:
```
1. File Name IOC
Regex match on full file path/name

2. Yara Rule Check
Yara signature matches on file data and process memory

3. Hash Check
Compares known malicious hashes (MD5, SHA1, SHA256) with scanned files

4. C2 Back Connect Check
Compares process connection endpoints with C2 IOCs (new since version v.10)
```
### Linux Malware Detect

[**Linux Malware Detect (LMD)**](https://www.rfxn.com/projects/linux-malware-detect/) è uno scanner per malware per Linux rilasciato sotto la licenza GNU GPLv2, progettato per le minacce affrontate negli ambienti di hosting condiviso. Utilizza dati sulle minacce provenienti da network edge intrusion detection systems per estrarre malware attivamente utilizzati negli attacchi e genera signatures per il rilevamento. Inoltre, i dati sulle minacce sono anche ricavati dalle segnalazioni degli utenti tramite la LMD checkout feature e dalle risorse della community sul malware.

### rkhunter

Strumenti come [**rkhunter**](http://rkhunter.sourceforge.net) possono essere utilizzati per controllare il filesystem alla ricerca di possibili **rootkits** e malware.
```bash
sudo ./rkhunter --check -r / -l /tmp/rkhunter.log [--report-warnings-only] [--skip-keypress]
```
### FLOSS

[**FLOSS**](https://github.com/mandiant/flare-floss) è uno strumento che prova a trovare obfuscated strings all'interno degli eseguibili usando tecniche diverse.

### PEpper

[PEpper ](https://github.com/Th3Hurrican3/PEpper) controlla alcune informazioni di base all'interno dell'eseguibile (binary data, entropy, URLs and IPs, alcune yara rules).

### PEstudio

[PEstudio](https://www.winitor.com/download) è uno strumento che permette di ottenere informazioni sugli eseguibili Windows come imports, exports, headers, ma controllerà anche VirusTotal e troverà potenziali tecniche Att\&ck.

### Detect It Easy(DiE)

[**DiE**](https://github.com/horsicq/Detect-It-Easy/) è uno strumento per rilevare se un file è **encrypted** e anche trovare **packers**.

### NeoPI

[**NeoPI** ](https://github.com/CiscoCXSecurity/NeoPI) è uno script Python che utilizza una varietà di **statistical methods** per rilevare contenuti **obfuscated** e **encrypted** all'interno di file di testo/script. Lo scopo previsto di NeoPI è aiutare nella **detection of hidden web shell code**.

### **php-malware-finder**

[**PHP-malware-finder**](https://github.com/nbs-system/php-malware-finder) fa del suo meglio per rilevare **obfuscated**/**dodgy code** così come file che utilizzano funzioni **PHP** spesso usate in **malwares**/webshells.

### Apple Binary Signatures

Quando si controlla qualche **malware sample** dovresti sempre **check the signature** del binario poiché il **developer** che l'ha firmato potrebbe essere già **related** con **malware.**
```bash
#Get signer
codesign -vv -d /bin/ls 2>&1 | grep -E "Authority|TeamIdentifier"

#Check if the app’s contents have been modified
codesign --verify --verbose /Applications/Safari.app

#Check if the signature is valid
spctl --assess --verbose /Applications/Safari.app
```
## Detection Techniques

### File Stacking

Se sai che una cartella contenente i **file** di un web server è stata **ultima modifica in una certa data**, **controlla** la **data** di creazione e modifica di tutti i **file** nel **web server** e se qualche data è **sospetta**, controlla quel file.

### Baselines

Se i file di una cartella **non dovrebbero essere stati modificati**, puoi calcolare l'**hash** dei **file originali** della cartella e **confrontarli** con quelli **attuali**. Qualsiasi modifica sarà **sospetta**.

### Statistical Analysis

Quando le informazioni sono salvate nei log puoi **controllare statistiche** come quante volte ogni file di un web server è stato richiesto, poiché una web shell potrebbe essere tra i più richiesti.

---

### Android in-app native telemetry (no root)

Su Android puoi applicare strumentazione al codice nativo all'interno del processo dell'app target pre-caricando una piccola libreria di logging prima che le altre librerie JNI vengano inizializzate. Questo fornisce visibilità precoce sul comportamento nativo senza hook di sistema o root. Un approccio popolare è SoTap: inserire libsotap.so per l'ABI corretta nell'APK e iniettare una chiamata System.loadLibrary("sotap") precocemente (ad es. initializer statico o Application.onCreate), quindi raccogliere i log da percorsi interni/esterni o come fallback da Logcat.

See the Android native reversing page for setup details and log paths:

{{#ref}}
../../mobile-pentesting/android-app-pentesting/reversing-native-libraries.md
{{#endref}}

---

## Deobfuscating Dynamic Control-Flow (JMP/CALL RAX Dispatchers)

Le famiglie di malware moderne fanno un largo abuso dell'obfuscazione del Control-Flow Graph (CFG): invece di un jump/call diretto calcolano la destinazione a runtime ed eseguono un `jmp rax` o `call rax`. Un piccolo *dispatcher* (tipicamente nove istruzioni) imposta la destinazione finale in base ai flag CPU `ZF`/`CF`, rompendo completamente il recupero statico del CFG.

La tecnica — mostrata dal loader SLOW#TEMPEST — può essere sconfitta con un workflow in tre passi che si basa solo su IDAPython e l'emulatore CPU Unicorn.

### 1. Individua ogni jump / call indiretto
```python
import idautils, idc

for ea in idautils.FunctionItems(idc.here()):
mnem = idc.print_insn_mnem(ea)
if mnem in ("jmp", "call") and idc.print_operand(ea, 0) == "rax":
print(f"[+] Dispatcher found @ {ea:X}")
```
### 2. Estrai il byte-code del dispatcher
```python
import idc

def get_dispatcher_start(jmp_ea, count=9):
s = jmp_ea
for _ in range(count):
s = idc.prev_head(s, 0)
return s

start = get_dispatcher_start(jmp_ea)
size  = jmp_ea + idc.get_item_size(jmp_ea) - start
code  = idc.get_bytes(start, size)
open(f"{start:X}.bin", "wb").write(code)
```
### 3. Emularlo due volte con Unicorn
```python
from unicorn import *
from unicorn.x86_const import *
import struct

def run(code, zf=0, cf=0):
BASE = 0x1000
mu = Uc(UC_ARCH_X86, UC_MODE_64)
mu.mem_map(BASE, 0x1000)
mu.mem_write(BASE, code)
mu.reg_write(UC_X86_REG_RFLAGS, (zf << 6) | cf)
mu.reg_write(UC_X86_REG_RAX, 0)
mu.emu_start(BASE, BASE+len(code))
return mu.reg_read(UC_X86_REG_RAX)
```
Esegui `run(code,0,0)` e `run(code,1,1)` per ottenere i target dei branch *false* e *true*.

### 4. Ripristinare tramite patch un direct jump / call
```python
import struct, ida_bytes

def patch_direct(ea, target, is_call=False):
op   = 0xE8 if is_call else 0xE9           # CALL rel32 or JMP rel32
disp = target - (ea + 5) & 0xFFFFFFFF
ida_bytes.patch_bytes(ea, bytes([op]) + struct.pack('<I', disp))
```
Dopo il patching, forzare IDA a rianalizzare la funzione in modo che il CFG completo e l'output di Hex-Rays siano ripristinati:
```python
import ida_auto, idaapi
idaapi.reanalyze_function(idc.get_func_attr(ea, idc.FUNCATTR_START))
```
### 5. Etichettare le chiamate API indirette

Una volta nota la destinazione reale di ogni `call rax`, puoi indicare a IDA quale sia, in modo che i tipi dei parametri & i nomi delle variabili vengano recuperati automaticamente:
```python
idc.set_callee_name(call_ea, resolved_addr, 0)  # IDA 8.3+
```
### Vantaggi pratici

* Ripristina il reale CFG → la decompilazione passa da *10* righe a migliaia.
* Abilita string-cross-reference & xrefs, rendendo la ricostruzione del comportamento banale.
* Gli script sono riutilizzabili: inseriscili in qualsiasi loader protetto dallo stesso trucco.

---

## AdaptixC2: Estrazione della configurazione e TTPs

Vedi la pagina dedicata:

{{#ref}}
adaptixc2-config-extraction-and-ttps.md
{{#endref}}

## Riferimenti

- [Unit42 – Evolving Tactics of SLOW#TEMPEST: A Deep Dive Into Advanced Malware Techniques](https://unit42.paloaltonetworks.com/slow-tempest-malware-obfuscation/)
- SoTap: Lightweight in-app JNI (.so) behavior logger – [github.com/RezaArbabBot/SoTap](https://github.com/RezaArbabBot/SoTap)
- [Unit42 – AdaptixC2: A New Open-Source Framework Leveraged in Real-World Attacks](https://unit42.paloaltonetworks.com/adaptixc2-post-exploitation-framework/)

{{#include ../../banners/hacktricks-training.md}}
