# Malware-Analyse

{{#include ../../banners/hacktricks-training.md}}

## Forensik CheatSheets

[https://www.jaiminton.com/cheatsheet/DFIR/#](https://www.jaiminton.com/cheatsheet/DFIR/)

## Online-Dienste

- [VirusTotal](https://www.virustotal.com/gui/home/upload)
- [HybridAnalysis](https://www.hybrid-analysis.com)
- [Koodous](https://koodous.com)
- [Intezer](https://analyze.intezer.com)
- [Any.Run](https://any.run/)

## Offline-Antivirus- und Erkennungstools

### Yara

#### Installieren
```bash
sudo apt-get install -y yara
```
#### Regeln vorbereiten

Verwenden Sie dieses Skript, um alle Yara-Malware-Regeln von GitHub herunterzuladen und zusammenzuführen: [https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9](https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9)\
Erstellen Sie das _**rules**_-Verzeichnis und führen Sie es aus. Dies erstellt eine Datei namens _**malware_rules.yar**_, die alle Yara-Regeln für Malware enthält.
```bash
wget https://gist.githubusercontent.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9/raw/4ec711d37f1b428b63bed1f786b26a0654aa2f31/malware_yara_rules.py
mkdir rules
python malware_yara_rules.py
```
#### Scannen
```bash
yara -w malware_rules.yar image  #Scan 1 file
yara -w malware_rules.yar folder #Scan the whole folder
```
#### YaraGen: Überprüfen Sie auf Malware und erstellen Sie Regeln

Sie können das Tool [**YaraGen**](https://github.com/Neo23x0/yarGen) verwenden, um Yara-Regeln aus einer Binärdatei zu generieren. Schauen Sie sich diese Tutorials an: [**Teil 1**](https://www.nextron-systems.com/2015/02/16/write-simple-sound-yara-rules/), [**Teil 2**](https://www.nextron-systems.com/2015/10/17/how-to-write-simple-but-sound-yara-rules-part-2/), [**Teil 3**](https://www.nextron-systems.com/2016/04/15/how-to-write-simple-but-sound-yara-rules-part-3/)
```bash
python3 yarGen.py --update
python3.exe yarGen.py --excludegood -m  ../../mals/
```
### ClamAV

#### Install
```
sudo apt-get install -y clamav
```
#### Scannen
```bash
sudo freshclam      #Update rules
clamscan filepath   #Scan 1 file
clamscan folderpath #Scan the whole folder
```
### [Capa](https://github.com/mandiant/capa)

**Capa** erkennt potenziell bösartige **Fähigkeiten** in ausführbaren Dateien: PE, ELF, .NET. Es wird Dinge wie Att\&ck-Taktiken oder verdächtige Fähigkeiten wie:

- Überprüfung auf OutputDebugString-Fehler
- als Dienst ausführen
- Prozess erstellen

Holen Sie es sich im [**Github-Repo**](https://github.com/mandiant/capa).

### IOCs

IOC bedeutet Indicator Of Compromise. Ein IOC ist eine Reihe von **Bedingungen, die** potenziell unerwünschte Software oder bestätigte **Malware** identifizieren. Blue Teams verwenden diese Art von Definition, um **nach dieser Art von bösartigen Dateien** in ihren **Systemen** und **Netzwerken** zu **suchen**.\
Diese Definitionen zu teilen ist sehr nützlich, da, wenn Malware auf einem Computer identifiziert wird und ein IOC für diese Malware erstellt wird, andere Blue Teams es verwenden können, um die Malware schneller zu identifizieren.

Ein Tool zum Erstellen oder Ändern von IOCs ist [**IOC Editor**](https://www.fireeye.com/services/freeware/ioc-editor.html)**.**\
Sie können Tools wie [**Redline**](https://www.fireeye.com/services/freeware/redline.html) verwenden, um **nach definierten IOCs auf einem Gerät** zu **suchen**.

### Loki

[**Loki**](https://github.com/Neo23x0/Loki) ist ein Scanner für einfache Indicators of Compromise.\
Die Erkennung basiert auf vier Erkennungsmethoden:
```
1. File Name IOC
Regex match on full file path/name

2. Yara Rule Check
Yara signature matches on file data and process memory

3. Hash Check
Compares known malicious hashes (MD5, SHA1, SHA256) with scanned files

4. C2 Back Connect Check
Compares process connection endpoints with C2 IOCs (new since version v.10)
```
### Linux Malware Detect

[**Linux Malware Detect (LMD)**](https://www.rfxn.com/projects/linux-malware-detect/) ist ein Malware-Scanner für Linux, der unter der GNU GPLv2-Lizenz veröffentlicht wurde und auf die Bedrohungen in gemeinsam genutzten Hosting-Umgebungen ausgerichtet ist. Er verwendet Bedrohungsdaten von Netzwerkgrenz-Intrusionserkennungssystemen, um Malware zu extrahieren, die aktiv in Angriffen verwendet wird, und generiert Signaturen zur Erkennung. Darüber hinaus stammen Bedrohungsdaten auch aus Benutzereinsendungen mit der LMD-Checkout-Funktion und Ressourcen der Malware-Community.

### rkhunter

Tools wie [**rkhunter**](http://rkhunter.sourceforge.net) können verwendet werden, um das Dateisystem auf mögliche **Rootkits** und Malware zu überprüfen.
```bash
sudo ./rkhunter --check -r / -l /tmp/rkhunter.log [--report-warnings-only] [--skip-keypress]
```
### FLOSS

[**FLOSS**](https://github.com/mandiant/flare-floss) ist ein Tool, das versucht, obfuskierte Strings in ausführbaren Dateien mit verschiedenen Techniken zu finden.

### PEpper

[PEpper ](https://github.com/Th3Hurrican3/PEpper) überprüft einige grundlegende Dinge in der ausführbaren Datei (binäre Daten, Entropie, URLs und IPs, einige Yara-Regeln).

### PEstudio

[PEstudio](https://www.winitor.com/download) ist ein Tool, das Informationen über Windows-Ausführungsdateien wie Importe, Exporte, Header bereitstellt, aber auch Virus Total überprüft und potenzielle Att\&ck-Techniken findet.

### Detect It Easy(DiE)

[**DiE**](https://github.com/horsicq/Detect-It-Easy/) ist ein Tool, um zu erkennen, ob eine Datei **verschlüsselt** ist und auch **Packers** zu finden.

### NeoPI

[**NeoPI** ](https://github.com/CiscoCXSecurity/NeoPI) ist ein Python-Skript, das eine Vielzahl von **statistischen Methoden** verwendet, um **obfuskierte** und **verschlüsselte** Inhalte in Text-/Skriptdateien zu erkennen. Der beabsichtigte Zweck von NeoPI ist es, bei der **Erkennung von verstecktem Webshell-Code** zu helfen.

### **php-malware-finder**

[**PHP-malware-finder**](https://github.com/nbs-system/php-malware-finder) gibt sein Bestes, um **obfuskierte**/**verdächtige Codes** sowie Dateien zu erkennen, die häufig in **Malware**/Webshells verwendete **PHP**-Funktionen nutzen.

### Apple Binary Signatures

Beim Überprüfen einer **Malware-Probe** sollten Sie immer die **Signatur** der Binärdatei überprüfen, da der **Entwickler**, der sie signiert hat, möglicherweise bereits mit **Malware** **verbunden** ist.
```bash
#Get signer
codesign -vv -d /bin/ls 2>&1 | grep -E "Authority|TeamIdentifier"

#Check if the app’s contents have been modified
codesign --verify --verbose /Applications/Safari.app

#Check if the signature is valid
spctl --assess --verbose /Applications/Safari.app
```
## Detection Techniques

### File Stacking

Wenn Sie wissen, dass ein Ordner mit den **Dateien** eines Webservers **am bestimmten Datum zuletzt aktualisiert wurde**. **Überprüfen** Sie das **Datum**, an dem alle **Dateien** im **Webserver erstellt und geändert** wurden, und wenn ein Datum **verdächtig** ist, überprüfen Sie diese Datei.

### Baselines

Wenn die Dateien eines Ordners **nicht geändert worden sein sollten**, können Sie den **Hash** der **ursprünglichen Dateien** des Ordners berechnen und diese mit den **aktuellen** vergleichen. Alles, was geändert wurde, wird **verdächtig** sein.

### Statistical Analysis

Wenn die Informationen in Protokollen gespeichert sind, können Sie **Statistiken überprüfen, wie oft jede Datei eines Webservers aufgerufen wurde, da eine Web-Shell eine der häufigsten sein könnte**.

---

## Deobfuscating Dynamic Control-Flow (JMP/CALL RAX Dispatchers)

Moderne Malware-Familien missbrauchen stark die Obfuskation von Control-Flow-Graphen (CFG): Anstelle eines direkten Sprungs/Calls berechnen sie das Ziel zur Laufzeit und führen ein `jmp rax` oder `call rax` aus. Ein kleiner *Dispatcher* (typischerweise neun Anweisungen) legt das endgültige Ziel je nach CPU `ZF`/`CF`-Flags fest, wodurch die statische CFG-Wiederherstellung vollständig unterbrochen wird.

Die Technik – demonstriert durch den SLOW#TEMPEST-Loader – kann mit einem dreistufigen Workflow besiegt werden, der nur auf IDAPython und den Unicorn CPU-Emulator angewiesen ist.

### 1. Locate every indirect jump / call
```python
import idautils, idc

for ea in idautils.FunctionItems(idc.here()):
mnem = idc.print_insn_mnem(ea)
if mnem in ("jmp", "call") and idc.print_operand(ea, 0) == "rax":
print(f"[+] Dispatcher found @ {ea:X}")
```
### 2. Extrahieren Sie den Dispatcher-Bytecode
```python
import idc

def get_dispatcher_start(jmp_ea, count=9):
s = jmp_ea
for _ in range(count):
s = idc.prev_head(s, 0)
return s

start = get_dispatcher_start(jmp_ea)
size  = jmp_ea + idc.get_item_size(jmp_ea) - start
code  = idc.get_bytes(start, size)
open(f"{start:X}.bin", "wb").write(code)
```
### 3. Emulieren Sie es zweimal mit Unicorn
```python
from unicorn import *
from unicorn.x86_const import *
import struct

def run(code, zf=0, cf=0):
BASE = 0x1000
mu = Uc(UC_ARCH_X86, UC_MODE_64)
mu.mem_map(BASE, 0x1000)
mu.mem_write(BASE, code)
mu.reg_write(UC_X86_REG_RFLAGS, (zf << 6) | cf)
mu.reg_write(UC_X86_REG_RAX, 0)
mu.emu_start(BASE, BASE+len(code))
return mu.reg_read(UC_X86_REG_RAX)
```
Führen Sie `run(code,0,0)` und `run(code,1,1)` aus, um die Ziele des *false* und *true* Zweigs zu erhalten.

### 4. Patchen Sie einen direkten Sprung / Aufruf zurück
```python
import struct, ida_bytes

def patch_direct(ea, target, is_call=False):
op   = 0xE8 if is_call else 0xE9           # CALL rel32 or JMP rel32
disp = target - (ea + 5) & 0xFFFFFFFF
ida_bytes.patch_bytes(ea, bytes([op]) + struct.pack('<I', disp))
```
Nach dem Patchen IDA zwingen, die Funktion erneut zu analysieren, damit das vollständige CFG und die Hex-Rays-Ausgabe wiederhergestellt werden:
```python
import ida_auto, idaapi
idaapi.reanalyze_function(idc.get_func_attr(ea, idc.FUNCATTR_START))
```
### 5. Indirekte API-Aufrufe kennzeichnen

Sobald das tatsächliche Ziel jedes `call rax` bekannt ist, können Sie IDA mitteilen, was es ist, damit die Parametertypen und Variablennamen automatisch wiederhergestellt werden:
```python
idc.set_callee_name(call_ea, resolved_addr, 0)  # IDA 8.3+
```
### Praktische Vorteile

* Stellt das echte CFG wieder her → Die Dekompilierung geht von *10* Zeilen auf Tausende.
* Ermöglicht String-Cross-Referenzen & xrefs, wodurch die Verhaltensrekonstruktion trivial wird.
* Skripte sind wiederverwendbar: Einfach in jeden Loader einfügen, der durch denselben Trick geschützt ist.

---

## Referenzen

- [Unit42 – Evolving Tactics of SLOW#TEMPEST: A Deep Dive Into Advanced Malware Techniques](https://unit42.paloaltonetworks.com/slow-tempest-malware-obfuscation/)

{{#include ../../banners/hacktricks-training.md}}
