# Análise de Malware

{{#include ../../banners/hacktricks-training.md}}

## CheatSheets de Forense

[https://www.jaiminton.com/cheatsheet/DFIR/#](https://www.jaiminton.com/cheatsheet/DFIR/)

## Serviços Online

- [VirusTotal](https://www.virustotal.com/gui/home/upload)
- [HybridAnalysis](https://www.hybrid-analysis.com)
- [Koodous](https://koodous.com)
- [Intezer](https://analyze.intezer.com)
- [Any.Run](https://any.run/)

## Ferramentas Offline de Antivírus e Detecção

### Yara

#### Instalação
```bash
sudo apt-get install -y yara
```
#### Preparar regras

Use este script para baixar e mesclar todas as regras yara de malware do github: [https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9](https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9)\
Crie o diretório _**rules**_ e execute-o. Isso criará um arquivo chamado _**malware_rules.yar**_ que contém todas as regras yara de malware.
```bash
wget https://gist.githubusercontent.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9/raw/4ec711d37f1b428b63bed1f786b26a0654aa2f31/malware_yara_rules.py
mkdir rules
python malware_yara_rules.py
```
#### Varredura
```bash
yara -w malware_rules.yar image  #Scan 1 file
yara -w malware_rules.yar folder #Scan the whole folder
```
#### YaraGen: Verificar malware e criar regras

Você pode usar a ferramenta [**YaraGen**](https://github.com/Neo23x0/yarGen) para gerar yara rules a partir de um binário. Confira estes tutoriais: [**Part 1**](https://www.nextron-systems.com/2015/02/16/write-simple-sound-yara-rules/), [**Part 2**](https://www.nextron-systems.com/2015/10/17/how-to-write-simple-but-sound-yara-rules-part-2/), [**Part 3**](https://www.nextron-systems.com/2016/04/15/how-to-write-simple-but-sound-yara-rules-part-3/)
```bash
python3 yarGen.py --update
python3.exe yarGen.py --excludegood -m  ../../mals/
```
### ClamAV

#### Instalação
```
sudo apt-get install -y clamav
```
#### Varredura
```bash
sudo freshclam      #Update rules
clamscan filepath   #Scan 1 file
clamscan folderpath #Scan the whole folder
```
### [Capa](https://github.com/mandiant/capa)

**Capa** detecta potencialmente **capacidades** maliciosas em executáveis: PE, ELF, .NET. Assim, encontrará coisas como Att\&ck táticas, ou capacidades suspeitas como:

- verificar erro OutputDebugString
- executar como um serviço
- criar processo

Get it int he [**Github repo**](https://github.com/mandiant/capa).

### IOCs

IOC significa Indicator Of Compromise. Um IOC é um conjunto de **condições que identificam** algum software potencialmente indesejado ou **malware** confirmado. As Blue Teams usam esse tipo de definição para **procurar por esse tipo de arquivos maliciosos** em seus **sistemas** e **redes**.\
Compartilhar essas definições é muito útil, pois quando um malware é identificado em um computador e um IOC para esse malware é criado, outras Blue Teams podem usá‑lo para identificar o malware mais rapidamente.

Uma ferramenta para criar ou modificar IOCs é [**IOC Editor**](https://www.fireeye.com/services/freeware/ioc-editor.html)**.**\
Você pode usar ferramentas como [**Redline**](https://www.fireeye.com/services/freeware/redline.html) para **buscar por IOCs definidos em um dispositivo**.

### Loki

[**Loki**](https://github.com/Neo23x0/Loki) é um scanner para Simple Indicators of Compromise.\
A detecção é baseada em quatro métodos de detecção:
```
1. File Name IOC
Regex match on full file path/name

2. Yara Rule Check
Yara signature matches on file data and process memory

3. Hash Check
Compares known malicious hashes (MD5, SHA1, SHA256) with scanned files

4. C2 Back Connect Check
Compares process connection endpoints with C2 IOCs (new since version v.10)
```
### Linux Malware Detect

[**Linux Malware Detect (LMD)**](https://www.rfxn.com/projects/linux-malware-detect/) é um scanner de malware para Linux lançado sob a licença GNU GPLv2, projetado para as ameaças enfrentadas em ambientes de hospedagem compartilhada. Ele utiliza dados de ameaça de sistemas de detecção de intrusão na borda da rede para extrair malware que está sendo usado ativamente em ataques e gerar assinaturas para detecção. Além disso, os dados de ameaça também são derivados de envios de usuários com o recurso LMD checkout e de recursos da comunidade de malware.

### rkhunter

Ferramentas como [**rkhunter**](http://rkhunter.sourceforge.net) podem ser usadas para verificar o sistema de arquivos em busca de possíveis **rootkits** e malware.
```bash
sudo ./rkhunter --check -r / -l /tmp/rkhunter.log [--report-warnings-only] [--skip-keypress]
```
### FLOSS

[**FLOSS**](https://github.com/mandiant/flare-floss) é uma ferramenta que tenta encontrar obfuscated strings dentro de executáveis usando diferentes técnicas.

### PEpper

[PEpper ](https://github.com/Th3Hurrican3/PEpper) verifica alguns aspetos básicos dentro do executável (binary data, entropy, URLs and IPs, some yara rules).

### PEstudio

[PEstudio](https://www.winitor.com/download) é uma ferramenta que permite obter informação de executáveis Windows, como imports, exports, headers, mas também verifica VirusTotal e encontra potenciais Att\&ck techniques.

### Detect It Easy(DiE)

[**DiE**](https://github.com/horsicq/Detect-It-Easy/) é uma ferramenta para detectar se um ficheiro está **encrypted** e também para encontrar **packers**.

### NeoPI

[**NeoPI** ](https://github.com/CiscoCXSecurity/NeoPI) é um script Python que usa uma variedade de **métodos estatísticos** para detectar conteúdo **obfuscated** e **encrypted** em ficheiros de texto/script. O objetivo do NeoPI é auxiliar na **detecção de código web shell oculto**.

### **php-malware-finder**

[**PHP-malware-finder**](https://github.com/nbs-system/php-malware-finder) faz o seu melhor para detectar **obfuscated**/**dodgy code** assim como ficheiros que usam funções **PHP** frequentemente usadas em **malwares**/webshells.

### Apple Binary Signatures

Ao analisar uma **malware sample** deve sempre **verificar a assinatura** do binário, pois o **developer** que a assinou pode já estar **related** com **malware.**
```bash
#Get signer
codesign -vv -d /bin/ls 2>&1 | grep -E "Authority|TeamIdentifier"

#Check if the app’s contents have been modified
codesign --verify --verbose /Applications/Safari.app

#Check if the signature is valid
spctl --assess --verbose /Applications/Safari.app
```
## Técnicas de Detecção

### File Stacking

Se você souber que alguma pasta contendo os **arquivos** de um servidor web foi **atualizada pela última vez em alguma data**, **verifique** a **data** em que todos os **arquivos** no **servidor web foram criados e modificados** e, se alguma data for **suspeita**, analise esse arquivo.

### Baselines

Se os arquivos de uma pasta **não deveriam ter sido modificados**, você pode calcular o **hash** dos **arquivos originais** da pasta e **compará-los** com os atuais. Qualquer coisa modificada será **suspeita**.

### Statistical Analysis

Quando a informação é salva em logs, você pode **verificar estatísticas**, como quantas vezes cada arquivo de um servidor web foi acessado — já que um web shell pode ser um dos mais acessados.

---

### Telemetria nativa in-app no Android (sem root)

No Android, você pode instrumentar código nativo dentro do processo do app alvo pré-carregando uma pequena biblioteca de logger antes que as outras libs JNI inicializem. Isso fornece visibilidade precoce do comportamento nativo sem hooks a nível de sistema ou root. Uma abordagem popular é SoTap: coloque o libsotap.so para a ABI correta dentro do APK e injete uma chamada System.loadLibrary("sotap") cedo (por exemplo, inicializador estático ou Application.onCreate), então colete logs de caminhos internos/externos ou usando Logcat como fallback.

Veja a página de reversing nativo para Android para detalhes de configuração e caminhos de log:

{{#ref}}
../../mobile-pentesting/android-app-pentesting/reversing-native-libraries.md
{{#endref}}

---

## Desofuscação do Fluxo de Controle Dinâmico (JMP/CALL RAX Dispatchers)

As famílias de malware modernas abusam fortemente da ofuscação do Grafo de Fluxo de Controle (CFG): em vez de um jump/call direto, elas calculam o destino em tempo de execução e executam um `jmp rax` ou `call rax`. Um pequeno *dispatcher* (tipicamente nove instruções) define o alvo final dependendo das flags `ZF`/`CF` da CPU, quebrando completamente a recuperação estática do CFG.

A técnica — demonstrada pelo loader SLOW#TEMPEST — pode ser derrotada com um fluxo de trabalho em três passos que depende apenas de IDAPython e do emulador de CPU Unicorn.

### 1. Localizar cada indirect jump / call
```python
import idautils, idc

for ea in idautils.FunctionItems(idc.here()):
mnem = idc.print_insn_mnem(ea)
if mnem in ("jmp", "call") and idc.print_operand(ea, 0) == "rax":
print(f"[+] Dispatcher found @ {ea:X}")
```
### 2. Extraia o byte-code do dispatcher
```python
import idc

def get_dispatcher_start(jmp_ea, count=9):
s = jmp_ea
for _ in range(count):
s = idc.prev_head(s, 0)
return s

start = get_dispatcher_start(jmp_ea)
size  = jmp_ea + idc.get_item_size(jmp_ea) - start
code  = idc.get_bytes(start, size)
open(f"{start:X}.bin", "wb").write(code)
```
### 3. Emule-o duas vezes com Unicorn
```python
from unicorn import *
from unicorn.x86_const import *
import struct

def run(code, zf=0, cf=0):
BASE = 0x1000
mu = Uc(UC_ARCH_X86, UC_MODE_64)
mu.mem_map(BASE, 0x1000)
mu.mem_write(BASE, code)
mu.reg_write(UC_X86_REG_RFLAGS, (zf << 6) | cf)
mu.reg_write(UC_X86_REG_RAX, 0)
mu.emu_start(BASE, BASE+len(code))
return mu.reg_read(UC_X86_REG_RAX)
```
Execute `run(code,0,0)` e `run(code,1,1)` para obter os *false* e *true* branch targets.

### 4. Patch back a direct jump / call
```python
import struct, ida_bytes

def patch_direct(ea, target, is_call=False):
op   = 0xE8 if is_call else 0xE9           # CALL rel32 or JMP rel32
disp = target - (ea + 5) & 0xFFFFFFFF
ida_bytes.patch_bytes(ea, bytes([op]) + struct.pack('<I', disp))
```
Após patching, force o IDA a reanalisar a função para que o CFG completo e a saída do Hex-Rays sejam restaurados:
```python
import ida_auto, idaapi
idaapi.reanalyze_function(idc.get_func_attr(ea, idc.FUNCATTR_START))
```
### 5. Rotular chamadas indiretas de API

Uma vez que o destino real de cada `call rax` seja conhecido, você pode informar o IDA sobre ele para que os tipos de parâmetros & nomes de variáveis sejam recuperados automaticamente:
```python
idc.set_callee_name(call_ea, resolved_addr, 0)  # IDA 8.3+
```
### Benefícios práticos

* Restaura o CFG real → a decompilação passa de *10* linhas para milhares.
* Habilita string-cross-reference & xrefs, tornando a reconstrução do comportamento trivial.
* Scripts são reutilizáveis: coloque-os em qualquer loader protegido pelo mesmo truque.

---

## Referências

- [Unit42 – Evolving Tactics of SLOW#TEMPEST: A Deep Dive Into Advanced Malware Techniques](https://unit42.paloaltonetworks.com/slow-tempest-malware-obfuscation/)
- SoTap: Lightweight in-app JNI (.so) behavior logger – [github.com/RezaArbabBot/SoTap](https://github.com/RezaArbabBot/SoTap)

{{#include ../../banners/hacktricks-training.md}}
