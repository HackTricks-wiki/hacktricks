# マルウェア解析

{{#include ../../banners/hacktricks-training.md}}

## フォレンジック チートシート

[https://www.jaiminton.com/cheatsheet/DFIR/#](https://www.jaiminton.com/cheatsheet/DFIR/)

## オンラインサービス

- [VirusTotal](https://www.virustotal.com/gui/home/upload)
- [HybridAnalysis](https://www.hybrid-analysis.com)
- [Koodous](https://koodous.com)
- [Intezer](https://analyze.intezer.com)
- [Any.Run](https://any.run/)

## オフラインのアンチウイルスおよび検出ツール

### Yara

#### インストール
```bash
sudo apt-get install -y yara
```
#### ルールを準備する

このスクリプトを使って github からすべての yara malware rules をダウンロードして結合してください: [https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9](https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9)\
_**rules**_ ディレクトリを作成して実行してください。これにより、すべての yara rules for malware を含む _**malware_rules.yar**_ というファイルが作成されます。
```bash
wget https://gist.githubusercontent.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9/raw/4ec711d37f1b428b63bed1f786b26a0654aa2f31/malware_yara_rules.py
mkdir rules
python malware_yara_rules.py
```
#### スキャン
```bash
yara -w malware_rules.yar image  #Scan 1 file
yara -w malware_rules.yar folder #Scan the whole folder
```
#### YaraGen: malware をチェックしてルールを作成

バイナリからyara rulesを生成するには、ツール [**YaraGen**](https://github.com/Neo23x0/yarGen) を使用できます。以下のチュートリアルを参照してください: [**Part 1**](https://www.nextron-systems.com/2015/02/16/write-simple-sound-yara-rules/), [**Part 2**](https://www.nextron-systems.com/2015/10/17/how-to-write-simple-but-sound-yara-rules-part-2/), [**Part 3**](https://www.nextron-systems.com/2016/04/15/how-to-write-simple-but-sound-yara-rules-part-3/)
```bash
python3 yarGen.py --update
python3.exe yarGen.py --excludegood -m  ../../mals/
```
### ClamAV

#### インストール
```
sudo apt-get install -y clamav
```
#### スキャン
```bash
sudo freshclam      #Update rules
clamscan filepath   #Scan 1 file
clamscan folderpath #Scan the whole folder
```
### [Capa](https://github.com/mandiant/capa)

**Capa** は実行ファイル: PE, ELF, .NET 内の潜在的に悪意のある **capabilities** を検出します。したがって、Att\&ck tactics のようなものや、次のような疑わしい capabilities を見つけます:

- OutputDebugString エラーをチェックする
- サービスとして実行する
- プロセスを作成する

入手は [**Github repo**](https://github.com/mandiant/capa) 。

### IOCs

IOC は Indicator Of Compromise を意味します。IOC は、潜在的に望ましくないソフトウェアや確認済みの **malware** を特定するための **conditions that identify** の集合です。Blue Teams はこの種の定義を使って、自組織の **systems** や **networks** 内で **search for this kind of malicious files** を行います。\
これらの定義を共有することは有用です。なぜなら、あるコンピュータ上で malware が確認され、その malware の IOC が作成されれば、他の Blue Teams はそれを使ってより速くその malware を特定できるからです。

A tool to create or modify IOCs is [**IOC Editor**](https://www.fireeye.com/services/freeware/ioc-editor.html)**.**\
You can use tools such as [**Redline**](https://www.fireeye.com/services/freeware/redline.html) to **search for defined IOCs in a device**.

### Loki

[**Loki**](https://github.com/Neo23x0/Loki) は Simple Indicators of Compromise を対象としたスキャナーです。\
Detection is based on four detection methods:
```
1. File Name IOC
Regex match on full file path/name

2. Yara Rule Check
Yara signature matches on file data and process memory

3. Hash Check
Compares known malicious hashes (MD5, SHA1, SHA256) with scanned files

4. C2 Back Connect Check
Compares process connection endpoints with C2 IOCs (new since version v.10)
```
### Linux Malware Detect

[**Linux Malware Detect (LMD)**](https://www.rfxn.com/projects/linux-malware-detect/) は GNU GPLv2 ライセンスで公開された Linux 用の malware scanner で、共有ホスティング環境で直面する脅威を考慮して設計されています。ネットワークエッジの intrusion detection systems から得た threat data を用いて、攻撃で実際に使われている malware を抽出し、検出用のシグネチャを生成します。さらに、threat data は LMD の checkout feature を使ったユーザー提出や malware community resources からも得られます。

### rkhunter

[**rkhunter**](http://rkhunter.sourceforge.net) のようなツールは、ファイルシステムをチェックして可能性のある **rootkits** や malware を検出するために使用できます。
```bash
sudo ./rkhunter --check -r / -l /tmp/rkhunter.log [--report-warnings-only] [--skip-keypress]
```
### FLOSS

[**FLOSS**](https://github.com/mandiant/flare-floss) は、さまざまな手法を用いて実行可能ファイル内の難読化された文字列を検出しようとするツールです。

### PEpper

[PEpper ](https://github.com/Th3Hurrican3/PEpper) は実行可能ファイル内部の基本的な項目（バイナリデータ、エントロピー、URLs と IPs、いくつかの yara ルール）をチェックします。

### PEstudio

[PEstudio](https://www.winitor.com/download) は Windows の実行可能ファイルについて、インポート、エクスポート、ヘッダーなどの情報を取得できるツールで、virus total をチェックし、潜在的な Att\&ck テクニックを見つけます。

### Detect It Easy(DiE)

[**DiE**](https://github.com/horsicq/Detect-It-Easy/) は、ファイルが **暗号化されている** かどうかを検出し、**パッカー** を見つけるツールです。

### NeoPI

[**NeoPI** ](https://github.com/CiscoCXSecurity/NeoPI) は、テキスト/スクリプトファイル内の **難読化された** および **暗号化された** コンテンツを検出するために、さまざまな **統計的手法** を用いる Python スクリプトです。NeoPI の目的は、**隠された web shell コードの検出** を支援することです。

### **php-malware-finder**

[**PHP-malware-finder**](https://github.com/nbs-system/php-malware-finder) は **難読化された**/**不審なコード** を検出することに注力しており、また **PHP** 関数を多用する **マルウェア**/webshells を含むファイルも検出します。

### Apple Binary Signatures

いくつかの **マルウェアサンプル** をチェックする際は、バイナリの **署名を確認する** ことを常に行ってください。署名した **開発者** が既に **マルウェア** と関連している場合があります。
```bash
#Get signer
codesign -vv -d /bin/ls 2>&1 | grep -E "Authority|TeamIdentifier"

#Check if the app’s contents have been modified
codesign --verify --verbose /Applications/Safari.app

#Check if the signature is valid
spctl --assess --verbose /Applications/Safari.app
```
## Detection Techniques

### File Stacking

もしあるフォルダに含まれる **files** が **ある日付に最後に更新された** と分かっているなら、**web server** 上のすべての **files** の作成日・更新日を **確認** し、いずれかの日付が **疑わしい** 場合はそのファイルを確認してください。

### Baselines

フォルダ内のファイルが **変更されてはいけない** 場合、フォルダの **original files** の **hash** を計算して現在のものと **compare** できます。変更されたものは **suspicious** です。

### Statistical Analysis

情報が logs に保存されている場合、web server の各ファイルが何回アクセスされたかのような統計を **確認** できます。web shell が最も多くアクセスされているファイルの1つである可能性があります。

---

### Android in-app native telemetry (no root)

Android では、ターゲットアプリプロセス内の native code に、他の JNI libs が初期化される前に小さな logger library を preload して計測を仕込むことができます。これによりシステム全体のフックや root を必要とせずにネイティブの挙動を早期に可視化できます。一般的なアプローチは SoTap：対応する ABI 向けに libsotap.so を APK に入れ、早い段階（static initializer や Application.onCreate など）で System.loadLibrary("sotap") を注入し、internal/external パスや Logcat フォールバックからログを収集します。

See the Android native reversing page for setup details and log paths:

{{#ref}}
../../mobile-pentesting/android-app-pentesting/reversing-native-libraries.md
{{#endref}}

---

## Deobfuscating Dynamic Control-Flow (JMP/CALL RAX Dispatchers)

Modern malware families heavily abuse Control-Flow Graph (CFG) obfuscation: instead of a direct jump/call they compute the destination at run-time and execute a `jmp rax` or `call rax`.  A small *dispatcher* (typically nine instructions) sets the final target depending on the CPU `ZF`/`CF` flags, completely breaking static CFG recovery.

The technique – showcased by the SLOW#TEMPEST loader – can be defeated with a three-step workflow that only relies on IDAPython and the Unicorn CPU emulator.

### 1. Locate every indirect jump / call
```python
import idautils, idc

for ea in idautils.FunctionItems(idc.here()):
mnem = idc.print_insn_mnem(ea)
if mnem in ("jmp", "call") and idc.print_operand(ea, 0) == "rax":
print(f"[+] Dispatcher found @ {ea:X}")
```
### 2. dispatcher byte-code を抽出する
```python
import idc

def get_dispatcher_start(jmp_ea, count=9):
s = jmp_ea
for _ in range(count):
s = idc.prev_head(s, 0)
return s

start = get_dispatcher_start(jmp_ea)
size  = jmp_ea + idc.get_item_size(jmp_ea) - start
code  = idc.get_bytes(start, size)
open(f"{start:X}.bin", "wb").write(code)
```
### 3. Unicornで2回エミュレートする
```python
from unicorn import *
from unicorn.x86_const import *
import struct

def run(code, zf=0, cf=0):
BASE = 0x1000
mu = Uc(UC_ARCH_X86, UC_MODE_64)
mu.mem_map(BASE, 0x1000)
mu.mem_write(BASE, code)
mu.reg_write(UC_X86_REG_RFLAGS, (zf << 6) | cf)
mu.reg_write(UC_X86_REG_RAX, 0)
mu.emu_start(BASE, BASE+len(code))
return mu.reg_read(UC_X86_REG_RAX)
```
Run `run(code,0,0)` と `run(code,1,1)` を実行して、ブランチの *false* と *true* ターゲットを取得します。

### 4. 直接の jump / call をパッチで復元する
```python
import struct, ida_bytes

def patch_direct(ea, target, is_call=False):
op   = 0xE8 if is_call else 0xE9           # CALL rel32 or JMP rel32
disp = target - (ea + 5) & 0xFFFFFFFF
ida_bytes.patch_bytes(ea, bytes([op]) + struct.pack('<I', disp))
```
パッチ適用後、IDAにその関数を再解析させ、完全なCFGとHex-Raysの出力を復元してください:
```python
import ida_auto, idaapi
idaapi.reanalyze_function(idc.get_func_attr(ea, idc.FUNCATTR_START))
```
### 5. 間接APIコールにラベルを付ける

各 `call rax` の実際の宛先が判明したら、IDA にそれを教えることでパラメータ型や変数名が自動的に復元されます:
```python
idc.set_callee_name(call_ea, resolved_addr, 0)  # IDA 8.3+
```
### 実用的な利点

* 実際の CFG を復元 → decompilation が *10* 行から数千行に増加する。
* string-cross-reference & xrefs を可能にし、動作の再構築を容易にする。
* Scripts は再利用可能: 同じ手法で保護された任意の loader に投入するだけでよい。

---

## 参考文献

- [Unit42 – Evolving Tactics of SLOW#TEMPEST: A Deep Dive Into Advanced Malware Techniques](https://unit42.paloaltonetworks.com/slow-tempest-malware-obfuscation/)
- SoTap: Lightweight in-app JNI (.so) behavior logger – [github.com/RezaArbabBot/SoTap](https://github.com/RezaArbabBot/SoTap)

{{#include ../../banners/hacktricks-training.md}}
