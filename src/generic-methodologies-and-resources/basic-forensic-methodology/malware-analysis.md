# Malware Analysis

{{#include ../../banners/hacktricks-training.md}}

## Forensics CheatSheets

[https://www.jaiminton.com/cheatsheet/DFIR/#](https://www.jaiminton.com/cheatsheet/DFIR/)

## Online Υπηρεσίες

- [VirusTotal](https://www.virustotal.com/gui/home/upload)
- [HybridAnalysis](https://www.hybrid-analysis.com)
- [Koodous](https://koodous.com)
- [Intezer](https://analyze.intezer.com)
- [Any.Run](https://any.run/)

## Εργαλεία Antivirus και Ανίχνευσης εκτός σύνδεσης

### Yara

#### Εγκατάσταση
```bash
sudo apt-get install -y yara
```
#### Προετοιμασία κανόνων

Χρησιμοποιήστε αυτό το script για να κατεβάσετε και να συγχωνεύσετε όλους τους yara κανόνες για malware από github: [https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9](https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9)\
Δημιουργήστε τον φάκελο _**rules**_ και εκτελέστε το script. Αυτό θα δημιουργήσει ένα αρχείο με το όνομα _**malware_rules.yar**_ το οποίο περιέχει όλους τους yara κανόνες για malware.
```bash
wget https://gist.githubusercontent.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9/raw/4ec711d37f1b428b63bed1f786b26a0654aa2f31/malware_yara_rules.py
mkdir rules
python malware_yara_rules.py
```
#### Σάρωση
```bash
yara -w malware_rules.yar image  #Scan 1 file
yara -w malware_rules.yar folder #Scan the whole folder
```
#### YaraGen: Έλεγχος για malware και Δημιουργία yara rules

Μπορείτε να χρησιμοποιήσετε το εργαλείο [**YaraGen**](https://github.com/Neo23x0/yarGen) για να δημιουργήσετε yara rules από ένα binary. Δείτε αυτά τα tutorials: [**Part 1**](https://www.nextron-systems.com/2015/02/16/write-simple-sound-yara-rules/), [**Part 2**](https://www.nextron-systems.com/2015/10/17/how-to-write-simple-but-sound-yara-rules-part-2/), [**Part 3**](https://www.nextron-systems.com/2016/04/15/how-to-write-simple-but-sound-yara-rules-part-3/)
```bash
python3 yarGen.py --update
python3.exe yarGen.py --excludegood -m  ../../mals/
```
### ClamAV

#### Εγκατάσταση
```
sudo apt-get install -y clamav
```
#### Σάρωση
```bash
sudo freshclam      #Update rules
clamscan filepath   #Scan 1 file
clamscan folderpath #Scan the whole folder
```
### [Capa](https://github.com/mandiant/capa)

**Capa** ανιχνεύει ενδεχομένως κακόβουλες **δυνατότητες** σε εκτελέσιμα: PE, ELF, .NET. Έτσι θα εντοπίσει πράγματα όπως Att\&ck tactics, ή ύποπτες δυνατότητες όπως:

- έλεγχος για σφάλμα OutputDebugString
- εκτέλεση ως υπηρεσία
- δημιουργία διεργασίας

Κατεβάστε το από το [**Github repo**](https://github.com/mandiant/capa).

### IOCs

IOC σημαίνει Indicator Of Compromise. Ένα IOC είναι ένα σύνολο **συνθηκών που εντοπίζουν** κάποιο πιθανώς ανεπιθύμητο λογισμικό ή επιβεβαιωμένο **malware**. Οι Blue Teams χρησιμοποιούν αυτόν τον τύπο ορισμού για να **αναζητούν αυτού του είδους τα κακόβουλα αρχεία** στα **systems** και τα **networks**.\
Η ανταλλαγή αυτών των ορισμών είναι πολύ χρήσιμη, καθώς όταν το malware εντοπιστεί σε έναν υπολογιστή και δημιουργηθεί ένα IOC για αυτό, άλλες Blue Teams μπορούν να το χρησιμοποιήσουν για να αναγνωρίσουν το malware πιο γρήγορα.

Ένα εργαλείο για τη δημιουργία ή τροποποίηση IOCs είναι [**IOC Editor**](https://www.fireeye.com/services/freeware/ioc-editor.html)**.**\
Μπορείτε να χρησιμοποιήσετε εργαλεία όπως [**Redline**](https://www.fireeye.com/services/freeware/redline.html) για να **αναζητήσετε καθορισμένα IOCs σε μια συσκευή**.

### Loki

[**Loki**](https://github.com/Neo23x0/Loki) είναι ένας scanner για Simple Indicators of Compromise.\
Η ανίχνευση βασίζεται σε τέσσερις μεθόδους ανίχνευσης:
```
1. File Name IOC
Regex match on full file path/name

2. Yara Rule Check
Yara signature matches on file data and process memory

3. Hash Check
Compares known malicious hashes (MD5, SHA1, SHA256) with scanned files

4. C2 Back Connect Check
Compares process connection endpoints with C2 IOCs (new since version v.10)
```
### Linux Malware Detect

[**Linux Malware Detect (LMD)**](https://www.rfxn.com/projects/linux-malware-detect/) είναι ένας malware σαρωτής για Linux που διανέμεται υπό την άδεια GNU GPLv2 και έχει σχεδιαστεί για τις απειλές που αντιμετωπίζονται σε περιβάλλοντα κοινής φιλοξενίας. Χρησιμοποιεί δεδομένα απειλών από συστήματα ανίχνευσης εισβολών στο άκρο του δικτύου για να εξάγει malware που χρησιμοποιείται ενεργά σε επιθέσεις και να δημιουργεί υπογραφές για την ανίχνευση. Επιπλέον, δεδομένα απειλών προέρχονται επίσης από υποβολές χρηστών μέσω της δυνατότητας LMD checkout και από πόρους της κοινότητας malware.

### rkhunter

Εργαλεία όπως [**rkhunter**](http://rkhunter.sourceforge.net) μπορούν να χρησιμοποιηθούν για να ελέγξουν το σύστημα αρχείων για πιθανά **rootkits** και malware.
```bash
sudo ./rkhunter --check -r / -l /tmp/rkhunter.log [--report-warnings-only] [--skip-keypress]
```
### FLOSS

[**FLOSS**](https://github.com/mandiant/flare-floss) είναι ένα εργαλείο που θα προσπαθήσει να βρει obfuscated strings μέσα σε executables χρησιμοποιώντας διάφορες τεχνικές.

### PEpper

[PEpper ](https://github.com/Th3Hurrican3/PEpper) ελέγχει κάποια βασικά πράγματα μέσα στο executable (binary data, entropy, URLs and IPs, some yara rules).

### PEstudio

[PEstudio](https://www.winitor.com/download) είναι ένα εργαλείο που επιτρέπει την άντληση πληροφοριών από Windows executables όπως imports, exports, headers, αλλά θα ελέγχει επίσης το virus total και θα εντοπίζει πιθανές Att\&ck τεχνικές.

### Detect It Easy(DiE)

[**DiE**](https://github.com/horsicq/Detect-It-Easy/) είναι ένα εργαλείο για να ανιχνεύσει αν ένα αρχείο είναι **encrypted** και επίσης να βρει **packers**.

### NeoPI

[**NeoPI** ](https://github.com/CiscoCXSecurity/NeoPI) είναι ένα Python script που χρησιμοποιεί μια ποικιλία από **statistical methods** για να εντοπίσει **obfuscated** και **encrypted** περιεχόμενο μέσα σε text/script αρχεία. Ο σκοπός του NeoPI είναι να βοηθήσει στην **detection of hidden web shell code**.

### **php-malware-finder**

[**PHP-malware-finder**](https://github.com/nbs-system/php-malware-finder) προσπαθεί όσο μπορεί να εντοπίσει **obfuscated**/**dodgy code** καθώς και αρχεία που χρησιμοποιούν **PHP** functions που συχνά χρησιμοποιούνται σε **malwares**/webshells.

### Apple Binary Signatures

Κατά τον έλεγχο κάποιου **malware sample** θα πρέπει πάντα να **check the signature** του binary καθώς ο **developer** που το υπέγραψε μπορεί να είναι ήδη **related** με **malware.**
```bash
#Get signer
codesign -vv -d /bin/ls 2>&1 | grep -E "Authority|TeamIdentifier"

#Check if the app’s contents have been modified
codesign --verify --verbose /Applications/Safari.app

#Check if the signature is valid
spctl --assess --verbose /Applications/Safari.app
```
## Τεχνικές Ανίχνευσης

### File Stacking

Αν γνωρίζετε ότι κάποιος φάκελος που περιέχει τα **αρχεία** ενός web server ενημερώθηκε **τελευταία σε κάποια ημερομηνία**, **ελέγξτε** την **ημερομηνία** κατά την οποία όλα τα **αρχεία** στον **web server δημιουργήθηκαν και τροποποιήθηκαν** και αν κάποια ημερομηνία είναι **ύποπτη**, ελέγξτε εκείνο το αρχείο.

### Baselines

Αν τα αρχεία ενός φακέλου **δεν έπρεπε να είχαν τροποποιηθεί**, μπορείτε να υπολογίσετε το **hash** των **αρχικών αρχείων** του φακέλου και να τα **συγκρίνετε** με τα **τρέχοντα**. Οτιδήποτε τροποποιημένο θα είναι **ύποπτο**.

### Statistical Analysis

Όταν οι πληροφορίες αποθηκεύονται σε αρχεία καταγραφής μπορείτε να **ελέγξετε στατιστικά όπως πόσες φορές προσπελάστηκε κάθε αρχείο ενός web server καθώς ένα web shell μπορεί να είναι ένα από τα πιο**.

---

### Android in-app native telemetry (no root)

On Android, you can instrument native code inside the target app process by preloading a tiny logger library before other JNI libs initialize. This gives early visibility into native behavior without system-wide hooks or root. A popular approach is SoTap: drop libsotap.so for the right ABI into the APK and inject a System.loadLibrary("sotap") call early (e.g., static initializer or Application.onCreate), then collect logs from internal/external paths or Logcat fallback.

See the Android native reversing page for setup details and log paths:

{{#ref}}
../../../mobile-pentesting/android-app-pentesting/reversing-native-libraries.md
{{#endref}}

---

## Αποκρυπτογράφηση Δυναμικής Ροής Ελέγχου (JMP/CALL RAX Dispatchers)

Σύγχρονες οικογένειες malware κάνουν εκτεταμένη χρήση της απόκρυψης του Control-Flow Graph (CFG): αντί για έναν άμεσο jump/call υπολογίζουν τον προορισμό κατά το χρόνο εκτέλεσης και εκτελούν `jmp rax` ή `call rax`. Ένας μικρός *dispatcher* (τυπικά εννέα εντολές) ορίζει τον τελικό στόχο ανάλογα με τις CPU `ZF`/`CF` σημαίες, καταστρέφοντας εντελώς τη στατική ανάκτηση του CFG.

Η τεχνική – showcased by the SLOW#TEMPEST loader – can be defeated with a three-step workflow that only relies on IDAPython and the Unicorn CPU emulator.

### 1. Εντοπίστε κάθε indirect jump / call
```python
import idautils, idc

for ea in idautils.FunctionItems(idc.here()):
mnem = idc.print_insn_mnem(ea)
if mnem in ("jmp", "call") and idc.print_operand(ea, 0) == "rax":
print(f"[+] Dispatcher found @ {ea:X}")
```
### 2. Εξαγωγή του dispatcher byte-code
```python
import idc

def get_dispatcher_start(jmp_ea, count=9):
s = jmp_ea
for _ in range(count):
s = idc.prev_head(s, 0)
return s

start = get_dispatcher_start(jmp_ea)
size  = jmp_ea + idc.get_item_size(jmp_ea) - start
code  = idc.get_bytes(start, size)
open(f"{start:X}.bin", "wb").write(code)
```
### 3. Εξομοιώστε το δύο φορές με Unicorn
```python
from unicorn import *
from unicorn.x86_const import *
import struct

def run(code, zf=0, cf=0):
BASE = 0x1000
mu = Uc(UC_ARCH_X86, UC_MODE_64)
mu.mem_map(BASE, 0x1000)
mu.mem_write(BASE, code)
mu.reg_write(UC_X86_REG_RFLAGS, (zf << 6) | cf)
mu.reg_write(UC_X86_REG_RAX, 0)
mu.emu_start(BASE, BASE+len(code))
return mu.reg_read(UC_X86_REG_RAX)
```
Τρέξτε `run(code,0,0)` και `run(code,1,1)` για να λάβετε τους στόχους διακλάδωσης *false* και *true*.

### 4. Επαναφορά με patch ενός άμεσου jump / call
```python
import struct, ida_bytes

def patch_direct(ea, target, is_call=False):
op   = 0xE8 if is_call else 0xE9           # CALL rel32 or JMP rel32
disp = target - (ea + 5) & 0xFFFFFFFF
ida_bytes.patch_bytes(ea, bytes([op]) + struct.pack('<I', disp))
```
Μετά το patching, αναγκάστε το IDA να επανα-αναλύσει τη συνάρτηση ώστε το πλήρες CFG και το Hex-Rays output να αποκατασταθούν:
```python
import ida_auto, idaapi
idaapi.reanalyze_function(idc.get_func_attr(ea, idc.FUNCATTR_START))
```
### 5. Επισημάνετε έμμεσες κλήσεις API

Μόλις γίνει γνωστός ο πραγματικός προορισμός κάθε `call rax`, μπορείτε να πείτε στο IDA τι είναι ώστε οι τύποι παραμέτρων & τα ονόματα μεταβλητών να ανακτηθούν αυτόματα:
```python
idc.set_callee_name(call_ea, resolved_addr, 0)  # IDA 8.3+
```
### Πρακτικά οφέλη

* Αποκαθιστά το πραγματικό CFG → η απομεταγλώττιση μετατρέπεται από *10* γραμμές σε χιλιάδες.
* Επιτρέπει string-cross-reference & xrefs, καθιστώντας την ανακατασκευή της συμπεριφοράς πολύ εύκολη.
* Τα Scripts είναι επαναχρησιμοποιήσιμα: τοποθετήστε τα σε οποιονδήποτε loader που προστατεύεται από το ίδιο τρικ.

---

## Αναφορές

- [Unit42 – Evolving Tactics of SLOW#TEMPEST: A Deep Dive Into Advanced Malware Techniques](https://unit42.paloaltonetworks.com/slow-tempest-malware-obfuscation/)
- SoTap: Lightweight in-app JNI (.so) behavior logger – [github.com/RezaArbabBot/SoTap](https://github.com/RezaArbabBot/SoTap)

{{#include ../../banners/hacktricks-training.md}}
