# 맬웨어 분석

{{#include ../../banners/hacktricks-training.md}}

## 포렌식 치트시트

[https://www.jaiminton.com/cheatsheet/DFIR/#](https://www.jaiminton.com/cheatsheet/DFIR/)

## 온라인 서비스

- [VirusTotal](https://www.virustotal.com/gui/home/upload)
- [HybridAnalysis](https://www.hybrid-analysis.com)
- [Koodous](https://koodous.com)
- [Intezer](https://analyze.intezer.com)
- [Any.Run](https://any.run/)

## 오프라인 안티바이러스 및 탐지 도구

### Yara

#### 설치
```bash
sudo apt-get install -y yara
```
#### 규칙 준비

이 스크립트를 사용하여 github에서 모든 yara malware rules를 다운로드하고 병합하세요: [https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9](https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9)\
_**rules**_ 디렉토리를 생성하고 스크립트를 실행하세요. 그러면 malware에 대한 모든 yara rules를 포함하는 _**malware_rules.yar**_ 파일이 생성됩니다.
```bash
wget https://gist.githubusercontent.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9/raw/4ec711d37f1b428b63bed1f786b26a0654aa2f31/malware_yara_rules.py
mkdir rules
python malware_yara_rules.py
```
#### 스캔
```bash
yara -w malware_rules.yar image  #Scan 1 file
yara -w malware_rules.yar folder #Scan the whole folder
```
#### YaraGen: malware 확인 및 규칙 생성

도구 [**YaraGen**](https://github.com/Neo23x0/yarGen)을(를) 사용하여 binary에서 yara rules를 생성할 수 있습니다. 다음 튜토리얼을 확인하세요: [**Part 1**](https://www.nextron-systems.com/2015/02/16/write-simple-sound-yara-rules/), [**Part 2**](https://www.nextron-systems.com/2015/10/17/how-to-write-simple-but-sound-yara-rules-part-2/), [**Part 3**](https://www.nextron-systems.com/2016/04/15/how-to-write-simple-but-sound-yara-rules-part-3/)
```bash
python3 yarGen.py --update
python3.exe yarGen.py --excludegood -m  ../../mals/
```
### ClamAV

#### 설치
```
sudo apt-get install -y clamav
```
#### Scan
```bash
sudo freshclam      #Update rules
clamscan filepath   #Scan 1 file
clamscan folderpath #Scan the whole folder
```
### [Capa](https://github.com/mandiant/capa)

**Capa**는 실행 파일(PE, ELF, .NET)에서 잠재적으로 악성인 **capabilities**를 탐지합니다. 따라서 Att\&ck tactics와 같은 항목이나 다음과 같은 의심스러운 **capabilities**를 찾아냅니다:

- OutputDebugString 오류 확인
- 서비스로 실행
- 프로세스 생성

다음에서 구하세요: [**Github repo**](https://github.com/mandiant/capa).

### IOCs

IOC는 Indicator Of Compromise의 약자입니다. IOC는 잠재적으로 원치 않는 소프트웨어나 확정된 **malware**를 식별하는 **식별하는 조건들**의 집합입니다. Blue Teams는 이러한 정의를 사용해 자신들의 **시스템**과 **네트워크**에서 해당 유형의 악성 파일을 **검색**합니다.\  
이 정의들을 공유하는 것은 매우 유용합니다. 어떤 컴퓨터에서 malware가 식별되어 그 malware에 대한 IOC가 만들어지면, 다른 Blue Teams는 이를 사용해 malware를 더 빠르게 식별할 수 있습니다.

IOC를 생성하거나 수정하는 도구로는 [**IOC Editor**](https://www.fireeye.com/services/freeware/ioc-editor.html)**.**\\ [**Redline**](https://www.fireeye.com/services/freeware/redline.html)과 같은 도구를 사용하여 장치에서 정의된 IOC를 **검색할 수 있습니다**.

### Loki

[**Loki**](https://github.com/Neo23x0/Loki)는 Simple Indicators of Compromise용 스캐너입니다.\\  
탐지는 네 가지 탐지 방법에 기반합니다:
```
1. File Name IOC
Regex match on full file path/name

2. Yara Rule Check
Yara signature matches on file data and process memory

3. Hash Check
Compares known malicious hashes (MD5, SHA1, SHA256) with scanned files

4. C2 Back Connect Check
Compares process connection endpoints with C2 IOCs (new since version v.10)
```
### Linux Malware Detect

[**Linux Malware Detect (LMD)**](https://www.rfxn.com/projects/linux-malware-detect/)는 GNU GPLv2 라이선스로 배포되는 Linux용 malware 스캐너로, 공유 호스팅 환경에서 직면하는 위협을 중심으로 설계되었습니다. 네트워크 엣지 침입 탐지 시스템으로부터의 위협 데이터를 사용하여 공격에 실제로 사용되는 malware를 추출하고 탐지용 시그니처를 생성합니다. 또한 위협 데이터는 LMD checkout 기능을 통한 사용자 제출과 malware 커뮤니티 리소스에서도 얻습니다.

### rkhunter

[**rkhunter**](http://rkhunter.sourceforge.net)와 같은 도구는 파일 시스템에서 가능한 **rootkits** 및 malware를 검사하는 데 사용할 수 있습니다.
```bash
sudo ./rkhunter --check -r / -l /tmp/rkhunter.log [--report-warnings-only] [--skip-keypress]
```
### FLOSS

[**FLOSS**](https://github.com/mandiant/flare-floss)는 다양한 기법을 사용해 실행 파일 내부의 obfuscated strings를 찾아내려고 시도하는 도구입니다.

### PEpper

[PEpper ](https://github.com/Th3Hurrican3/PEpper)checks 일부 실행 파일 내부의 기본 항목들(바이너리 데이터, entropy, URLs and IPs, 일부 yara rules)을 검사합니다.

### PEstudio

[PEstudio](https://www.winitor.com/download)는 imports, exports, headers 등 Windows 실행 파일의 정보를 얻을 수 있게 해주며, virus total을 확인하고 잠재적인 Att\&ck techniques를 찾아냅니다.

### Detect It Easy(DiE)

[**DiE**](https://github.com/horsicq/Detect-It-Easy/)는 파일이 **encrypted** 되었는지 감지하고 **packers**도 찾아내는 도구입니다.

### NeoPI

[**NeoPI** ](https://github.com/CiscoCXSecurity/NeoPI)은 텍스트/스크립트 파일 내의 **obfuscated** 및 **encrypted** 내용을 감지하기 위해 다양한 **statistical methods**를 사용하는 Python 스크립트입니다. NeoPI의 목적은 **detection of hidden web shell code**을 돕는 것입니다.

### **php-malware-finder**

[**PHP-malware-finder**](https://github.com/nbs-system/php-malware-finder)은 **obfuscated**/**dodgy code**뿐만 아니라 자주 악용되는 **PHP** 함수들을 사용하는 파일(예: **malwares**/webshells)을 탐지하려 최선을 다합니다.

### Apple Binary Signatures

어떤 **malware sample**을 확인할 때는 서명한 **developer**가 이미 **related** with **malware**일 수 있으므로 항상 바이너리의 **check the signature**를 해야 합니다.
```bash
#Get signer
codesign -vv -d /bin/ls 2>&1 | grep -E "Authority|TeamIdentifier"

#Check if the app’s contents have been modified
codesign --verify --verbose /Applications/Safari.app

#Check if the signature is valid
spctl --assess --verbose /Applications/Safari.app
```
## 탐지 기법

### File Stacking

만약 웹 서버의 **파일**들을 포함한 어떤 폴더가 **마지막으로 업데이트된 날짜**를 알고 있다면, 웹 서버 내 모든 **파일들의 생성 및 수정 날짜**를 **확인**하고 어떤 날짜가 **의심스럽다면**, 해당 파일을 조사하라.

### Baselines

폴더의 파일이 **변경되지 않았어야 한다면**, 그 폴더의 **원본 파일**들의 **해시(hash)**를 계산하여 **현재** 파일들과 **비교**할 수 있다. 변경된 항목은 **의심스러울** 것이다.

### Statistical Analysis

정보가 로그에 저장되어 있다면, 웹 서버의 각 파일이 몇 번 접근되었는지 같은 통계를 **확인**할 수 있다 — web shell이 가장 많이 접근된 파일 중 하나일 수 있다.

---

### Android in-app native telemetry (no root)

Android에서는 다른 JNI 라이브러리가 초기화되기 전에 작은 로거 라이브러리를 프리로딩함으로써 타깃 앱 프로세스 내부의 native 코드를 계측할 수 있다. 이는 시스템 전역 훅이나 root 없이 native 동작에 대한 조기 가시성을 제공한다. 널리 사용되는 방법은 SoTap이다: 적절한 ABI용 libsotap.so를 APK에 넣고 System.loadLibrary("sotap") 호출을 초기에 삽입(예: static initializer 또는 Application.onCreate)한 뒤 내부/외부 경로 또는 Logcat을 통해 로그를 수집한다.

설정 세부사항과 로그 경로는 Android native reversing 페이지를 참조하라:

{{#ref}}
../../../mobile-pentesting/android-app-pentesting/reversing-native-libraries.md
{{#endref}}

---

## Deobfuscating Dynamic Control-Flow (JMP/CALL RAX Dispatchers)

Modern malware families heavily abuse Control-Flow Graph (CFG) obfuscation: 대신 직접적인 jump/call 대신 실행 시 목적지를 계산하여 `jmp rax` 또는 `call rax`를 실행한다. 작은 *dispatcher*(대개 9개 명령어)가 CPU의 `ZF`/`CF` 플래그에 따라 최종 타겟을 설정하여 정적 CFG 복구를 완전히 무력화한다.

이 기법은 SLOW#TEMPEST loader에서 보여진 바와 같이, IDAPython과 Unicorn CPU emulator만을 사용한 세 단계 워크플로로 무력화할 수 있다.

### 1. Locate every indirect jump / call
```python
import idautils, idc

for ea in idautils.FunctionItems(idc.here()):
mnem = idc.print_insn_mnem(ea)
if mnem in ("jmp", "call") and idc.print_operand(ea, 0) == "rax":
print(f"[+] Dispatcher found @ {ea:X}")
```
### 2. 디스패처 바이트코드 추출
```python
import idc

def get_dispatcher_start(jmp_ea, count=9):
s = jmp_ea
for _ in range(count):
s = idc.prev_head(s, 0)
return s

start = get_dispatcher_start(jmp_ea)
size  = jmp_ea + idc.get_item_size(jmp_ea) - start
code  = idc.get_bytes(start, size)
open(f"{start:X}.bin", "wb").write(code)
```
### 3. Unicorn으로 두 번 에뮬레이트하기
```python
from unicorn import *
from unicorn.x86_const import *
import struct

def run(code, zf=0, cf=0):
BASE = 0x1000
mu = Uc(UC_ARCH_X86, UC_MODE_64)
mu.mem_map(BASE, 0x1000)
mu.mem_write(BASE, code)
mu.reg_write(UC_X86_REG_RFLAGS, (zf << 6) | cf)
mu.reg_write(UC_X86_REG_RAX, 0)
mu.emu_start(BASE, BASE+len(code))
return mu.reg_read(UC_X86_REG_RAX)
```
다음 명령을 실행하여 `run(code,0,0)` 및 `run(code,1,1)`로부터 *false* 및 *true* 분기 대상을 얻는다.

### 4. 직접적인 jump / call을 패치하여 되돌리기
```python
import struct, ida_bytes

def patch_direct(ea, target, is_call=False):
op   = 0xE8 if is_call else 0xE9           # CALL rel32 or JMP rel32
disp = target - (ea + 5) & 0xFFFFFFFF
ida_bytes.patch_bytes(ea, bytes([op]) + struct.pack('<I', disp))
```
패치 후, 전체 CFG와 Hex-Rays 출력이 복원되도록 IDA에 함수를 재분석하도록 강제하십시오:
```python
import ida_auto, idaapi
idaapi.reanalyze_function(idc.get_func_attr(ea, idc.FUNCATTR_START))
```
### 5. 간접 API 호출에 레이블 지정

각 `call rax`의 실제 목적지를 알게 되면 IDA에 이를 알려 매개변수 타입 및 변수 이름이 자동으로 복원되도록 할 수 있다:
```python
idc.set_callee_name(call_ea, resolved_addr, 0)  # IDA 8.3+
```
### 실용적 이점

* 실제 CFG를 복원 → decompilation이 *10* 줄에서 수천 줄로 증가.
* string-cross-reference & xrefs를 활성화하여 행위 재구성이 쉬워짐.
* Scripts는 재사용 가능: 같은 트릭으로 보호된 어떤 loader에도 넣어 재사용할 수 있음.

---

## 참고자료

- [Unit42 – Evolving Tactics of SLOW#TEMPEST: A Deep Dive Into Advanced Malware Techniques](https://unit42.paloaltonetworks.com/slow-tempest-malware-obfuscation/)
- SoTap: Lightweight in-app JNI (.so) behavior logger – [github.com/RezaArbabBot/SoTap](https://github.com/RezaArbabBot/SoTap)

{{#include ../../banners/hacktricks-training.md}}
