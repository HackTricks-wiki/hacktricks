# Malware Analysis

{{#include ../../banners/hacktricks-training.md}}

## Forenzičke CheatSheets

[https://www.jaiminton.com/cheatsheet/DFIR/#](https://www.jaiminton.com/cheatsheet/DFIR/)

## Online servisi

- [VirusTotal](https://www.virustotal.com/gui/home/upload)
- [HybridAnalysis](https://www.hybrid-analysis.com)
- [Koodous](https://koodous.com)
- [Intezer](https://analyze.intezer.com)
- [Any.Run](https://any.run/)

## Offline antivirus i alati za detekciju

### Yara

#### Instalacija
```bash
sudo apt-get install -y yara
```
#### Pripremite pravila

Koristite ovaj skript da preuzmete i spojite sve yara malware rules sa github-a: [https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9](https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9)\
Kreirajte direktorijum _**rules**_ i izvršite skript. Ovo će kreirati fajl nazvan _**malware_rules.yar**_ koji sadrži sve yara rules za malware.
```bash
wget https://gist.githubusercontent.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9/raw/4ec711d37f1b428b63bed1f786b26a0654aa2f31/malware_yara_rules.py
mkdir rules
python malware_yara_rules.py
```
#### Skeniranje
```bash
yara -w malware_rules.yar image  #Scan 1 file
yara -w malware_rules.yar folder #Scan the whole folder
```
#### YaraGen: Provera za malware i kreiranje pravila

Možete koristiti alat [**YaraGen**](https://github.com/Neo23x0/yarGen) za generisanje yara rules iz binarnog fajla. Pogledajte ove tutorijale: [**Part 1**](https://www.nextron-systems.com/2015/02/16/write-simple-sound-yara-rules/), [**Part 2**](https://www.nextron-systems.com/2015/10/17/how-to-write-simple-but-sound-yara-rules-part-2/), [**Part 3**](https://www.nextron-systems.com/2016/04/15/how-to-write-simple-but-sound-yara-rules-part-3/)
```bash
python3 yarGen.py --update
python3.exe yarGen.py --excludegood -m  ../../mals/
```
### ClamAV

#### Instalacija
```
sudo apt-get install -y clamav
```
#### Skeniranje
```bash
sudo freshclam      #Update rules
clamscan filepath   #Scan 1 file
clamscan folderpath #Scan the whole folder
```
### [Capa](https://github.com/mandiant/capa)

**Capa** otkriva potencijalno maliciozne **capabilities** u izvršnim fajlovima: PE, ELF, .NET. Dakle, pronaći će stvari kao što su Att\&ck tactics, ili sumnjive capabilities kao što su:

- provera OutputDebugString error
- pokretanje kao service
- kreiranje procesa

Get it int he [**Github repo**](https://github.com/mandiant/capa).

### IOCs

IOC znači indikator kompromitovanja. IOC je skup **uslova koji identifikuju** neki potencijalno neželjeni softver ili potvrđeni **malware**. Blue Teams koriste ovaj tip definicije da **pretraže ovakve maliciozne fajlove** u svojim **sistemima** i **mrežama**.\
Deljenje ovih definicija je veoma korisno: kada se malware identifikuje na računaru i kreira IOC za taj malware, drugi Blue Teams mogu ga brže identifikovati.

Alat za kreiranje ili izmenu IOC-ova je [**IOC Editor**](https://www.fireeye.com/services/freeware/ioc-editor.html)**.**\
Možete koristiti alate kao što su [**Redline**](https://www.fireeye.com/services/freeware/redline.html) da **pretražite definisane IOCs na uređaju**.

### Loki

[**Loki**](https://github.com/Neo23x0/Loki) je skener za Simple Indicators of Compromise.\
Detekcija se zasniva na četiri metode detekcije:
```
1. File Name IOC
Regex match on full file path/name

2. Yara Rule Check
Yara signature matches on file data and process memory

3. Hash Check
Compares known malicious hashes (MD5, SHA1, SHA256) with scanned files

4. C2 Back Connect Check
Compares process connection endpoints with C2 IOCs (new since version v.10)
```
### Linux Malware Detect

[**Linux Malware Detect (LMD)**](https://www.rfxn.com/projects/linux-malware-detect/) je malware skener za Linux, objavljen pod GNU GPLv2 licencom, koji je dizajniran oko pretnji sa kojima se susreću okruženja sa deljenim hostingom. Koristi threat data iz network edge intrusion detection systems da izvuče malware koji se aktivno koristi u napadima i generiše potpise za detekciju. Pored toga, threat data se takođe dobija iz korisničkih prijava putem LMD checkout feature i iz resursa malware zajednice.

### rkhunter

Alati poput [**rkhunter**](http://rkhunter.sourceforge.net) mogu se koristiti za proveru datotečnog sistema zbog mogućih **rootkits** i **malware**.
```bash
sudo ./rkhunter --check -r / -l /tmp/rkhunter.log [--report-warnings-only] [--skip-keypress]
```
### FLOSS

[**FLOSS**](https://github.com/mandiant/flare-floss) je alat koji pokušava da pronađe obfuscated strings unutar executables koristeći različite tehnike.

### PEpper

[PEpper ](https://github.com/Th3Hurrican3/PEpper)proverava neke osnovne stvari unutar executable-a (binary data, entropy, URLs and IPs, neke yara rules).

### PEstudio

[PEstudio](https://www.winitor.com/download) je alat koji omogućava pribavljanje informacija o Windows executables kao što su imports, exports, headers, ali takođe proverava virus total i pronalazi potencijalne Att\&ck techniques.

### Detect It Easy(DiE)

[**DiE**](https://github.com/horsicq/Detect-It-Easy/) je alat za detekciju da li je fajl **encrypted** i takođe pronalazi **packers**.

### NeoPI

[**NeoPI** ](https://github.com/CiscoCXSecurity/NeoPI)je Python skripta koja koristi razne **statistical methods** da detektuje **obfuscated** i **encrypted** sadržaje unutar text/script fajlova. Namena NeoPI-ja je da pomogne u **detection of hidden web shell code**.

### **php-malware-finder**

[**PHP-malware-finder**](https://github.com/nbs-system/php-malware-finder) se maksimalno trudi da detektuje **obfuscated**/**dodgy code** kao i fajlove koji koriste **PHP** funkcije često korišćene u **malwares**/webshells.

### Apple Binary Signatures

Prilikom provere nekog **malware sample** you should always **check the signature** of the binary as the **developer** that signed it may be already **related** with **malware.**
```bash
#Get signer
codesign -vv -d /bin/ls 2>&1 | grep -E "Authority|TeamIdentifier"

#Check if the app’s contents have been modified
codesign --verify --verbose /Applications/Safari.app

#Check if the signature is valid
spctl --assess --verbose /Applications/Safari.app
```
## Tehnike detekcije

### File Stacking

Ako znate da je neka fascikla koja sadrži **files** web servera poslednji put ažurirana na određeni datum, **proverite** datume kada su svi **files** u **web server** kreirani i izmenjeni; ako je neki datum **sumnjiv**, proverite taj file.

### Baselines

Ako **files** neke fascikle **ne bi trebali biti modifikovani**, možete izračunati **hash** **original files** fascikle i **uporediti** ih sa **current** verzijama. Sve što je izmenjeno biće **sumnjivo**.

### Statistical Analysis

Kada se informacije čuvaju u logs, možete **proveriti statistiku** — npr. koliko puta je svaki file web servera bio pristupan, jer web shell može biti među najčešće pristupanima.

---

### Android in-app native telemetry (no root)

Na Android-u možete instrumentovati native kod unutar procesa ciljne aplikacije tako što ćete prethodno učitati malu logger biblioteku pre nego što se ostale JNI libs inicijalizuju. Ovo daje ranu vidljivost native ponašanja bez system-wide hook-ova ili root-a. Popularan pristup je SoTap: ubacite libsotap.so za odgovarajući ABI u APK i injektujte poziv System.loadLibrary("sotap") rano (npr. u static initializer ili Application.onCreate), zatim prikupite logs iz internog/eksternog puta ili pomoću Logcat kao fallback.

See the Android native reversing page for setup details and log paths:

{{#ref}}
../../../mobile-pentesting/android-app-pentesting/reversing-native-libraries.md
{{#endref}}

---

## Deobfuscating Dynamic Control-Flow (JMP/CALL RAX Dispatchers)

Savremene malware familije intenzivno zloupotrebljavaju Control-Flow Graph (CFG) obfuskaciju: umesto direktnog jump/call oni izračunavaju destinaciju u run-time-u i izvršavaju `jmp rax` ili `call rax`. Mali *dispatcher* (tipično nine instructions) postavlja finalnu metu u zavisnosti od CPU `ZF`/`CF` zastavica, potpuno razbijajući statičko obnavljanje CFG-a.

Tehniku – prikazanu od strane SLOW#TEMPEST loader-a – može se pobediti trostepenim workflow-om koji se oslanja samo na IDAPython i Unicorn CPU emulator.

### 1. Locate every indirect jump / call
```python
import idautils, idc

for ea in idautils.FunctionItems(idc.here()):
mnem = idc.print_insn_mnem(ea)
if mnem in ("jmp", "call") and idc.print_operand(ea, 0) == "rax":
print(f"[+] Dispatcher found @ {ea:X}")
```
### 2. Izvucite dispatcher byte-code
```python
import idc

def get_dispatcher_start(jmp_ea, count=9):
s = jmp_ea
for _ in range(count):
s = idc.prev_head(s, 0)
return s

start = get_dispatcher_start(jmp_ea)
size  = jmp_ea + idc.get_item_size(jmp_ea) - start
code  = idc.get_bytes(start, size)
open(f"{start:X}.bin", "wb").write(code)
```
### 3. Emuliraj ga dva puta koristeći Unicorn
```python
from unicorn import *
from unicorn.x86_const import *
import struct

def run(code, zf=0, cf=0):
BASE = 0x1000
mu = Uc(UC_ARCH_X86, UC_MODE_64)
mu.mem_map(BASE, 0x1000)
mu.mem_write(BASE, code)
mu.reg_write(UC_X86_REG_RFLAGS, (zf << 6) | cf)
mu.reg_write(UC_X86_REG_RAX, 0)
mu.emu_start(BASE, BASE+len(code))
return mu.reg_read(UC_X86_REG_RAX)
```
Pokrenite `run(code,0,0)` i `run(code,1,1)` da biste dobili ciljeve grana *false* i *true*.

### 4. Vratite nazad direktni jump / call
```python
import struct, ida_bytes

def patch_direct(ea, target, is_call=False):
op   = 0xE8 if is_call else 0xE9           # CALL rel32 or JMP rel32
disp = target - (ea + 5) & 0xFFFFFFFF
ida_bytes.patch_bytes(ea, bytes([op]) + struct.pack('<I', disp))
```
Nakon patching, naterajte IDA da ponovo analizira funkciju kako bi kompletan CFG i Hex-Rays izlaz bili vraćeni:
```python
import ida_auto, idaapi
idaapi.reanalyze_function(idc.get_func_attr(ea, idc.FUNCATTR_START))
```
### 5. Obeležite indirektne API pozive

Kada je poznata stvarna destinacija svakog `call rax`, možete reći IDA-i šta je to, tako da se tipovi parametara & imena promenljivih automatski rekonstrušu:
```python
idc.set_callee_name(call_ea, resolved_addr, 0)  # IDA 8.3+
```
### Praktične prednosti

* Vraća pravi CFG → decompilation prelazi sa *10* linija na hiljade.
* Omogućava string-cross-reference & xrefs, čineći rekonstrukciju ponašanja trivijalnom.
* Skripte su ponovo upotrebljive: ubacite ih u bilo koji loader koji je zaštićen istim trikom.

---

## Izvori

- [Unit42 – Evolving Tactics of SLOW#TEMPEST: A Deep Dive Into Advanced Malware Techniques](https://unit42.paloaltonetworks.com/slow-tempest-malware-obfuscation/)
- SoTap: Lightweight in-app JNI (.so) behavior logger – [github.com/RezaArbabBot/SoTap](https://github.com/RezaArbabBot/SoTap)

{{#include ../../banners/hacktricks-training.md}}
