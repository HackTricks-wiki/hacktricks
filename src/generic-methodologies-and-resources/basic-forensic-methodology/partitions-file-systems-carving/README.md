# Partitions/File Systems/Carving

{{#include ../../../banners/hacktricks-training.md}}

## Partitions

एक हार्ड ड्राइव या **SSD डिस्क में विभिन्न विभाजन हो सकते हैं** जिनका उद्देश्य डेटा को भौतिक रूप से अलग करना है।\
डिस्क की **न्यूनतम** इकाई **क्षेत्र** है (सामान्यतः 512B से बनी होती है)। इसलिए, प्रत्येक विभाजन का आकार उस आकार का गुणांक होना चाहिए।

### MBR (मास्टर बूट रिकॉर्ड)

यह **446B बूट कोड के बाद डिस्क के पहले क्षेत्र में आवंटित** होता है। यह क्षेत्र पीसी को यह संकेत देने के लिए आवश्यक है कि एक विभाजन को क्या और कहाँ माउंट किया जाना चाहिए।\
यह **4 विभाजनों** तक की अनुमति देता है (अधिकतम **केवल 1** सक्रिय/**बूट करने योग्य** हो सकता है)। हालाँकि, यदि आपको अधिक विभाजन की आवश्यकता है, तो आप **विस्तारित विभाजन** का उपयोग कर सकते हैं। इस पहले क्षेत्र का **अंतिम बाइट** बूट रिकॉर्ड सिग्नेचर **0x55AA** है। केवल एक विभाजन को सक्रिय के रूप में चिह्नित किया जा सकता है।\
MBR **अधिकतम 2.2TB** की अनुमति देता है।

![](<../../../images/image (350).png>)

![](<../../../images/image (304).png>)

**MBR के 440 से 443 बाइट्स** में आप **Windows डिस्क सिग्नेचर** पा सकते हैं (यदि Windows का उपयोग किया गया है)। हार्ड डिस्क का तार्किक ड्राइव लेटर Windows डिस्क सिग्नेचर पर निर्भर करता है। इस सिग्नेचर को बदलने से Windows बूट करने में विफल हो सकता है (उपकरण: [**Active Disk Editor**](https://www.disk-editor.org/index.html)**)**।

![](<../../../images/image (310).png>)

**फॉर्मेट**

| ऑफसेट      | लंबाई     | आइटम                |
| ----------- | ---------- | ------------------- |
| 0 (0x00)    | 446(0x1BE) | बूट कोड           |
| 446 (0x1BE) | 16 (0x10)  | पहला विभाजन     |
| 462 (0x1CE) | 16 (0x10)  | दूसरा विभाजन    |
| 478 (0x1DE) | 16 (0x10)  | तीसरा विभाजन     |
| 494 (0x1EE) | 16 (0x10)  | चौथा विभाजन    |
| 510 (0x1FE) | 2 (0x2)    | सिग्नेचर 0x55 0xAA |

**विभाजन रिकॉर्ड फॉर्मेट**

| ऑफसेट    | लंबाई   | आइटम                                                   |
| --------- | -------- | ------------------------------------------------------ |
| 0 (0x00)  | 1 (0x01) | सक्रिय ध्वज (0x80 = बूट करने योग्य)                          |
| 1 (0x01)  | 1 (0x01) | प्रारंभिक सिर                                             |
| 2 (0x02)  | 1 (0x01) | प्रारंभिक क्षेत्र (बिट 0-5); सिलेंडर के ऊपरी बिट (6- 7) |
| 3 (0x03)  | 1 (0x01) | प्रारंभिक सिलेंडर के सबसे कम 8 बिट                           |
| 4 (0x04)  | 1 (0x01) | विभाजन प्रकार कोड (0x83 = Linux)                     |
| 5 (0x05)  | 1 (0x01) | अंतिम सिर                                               |
| 6 (0x06)  | 1 (0x01) | अंतिम क्षेत्र (बिट 0-5); सिलेंडर के ऊपरी बिट (6- 7)   |
| 7 (0x07)  | 1 (0x01) | अंतिम सिलेंडर के सबसे कम 8 बिट                             |
| 8 (0x08)  | 4 (0x04) | विभाजन से पहले के क्षेत्र (लिटिल एंडियन)            |
| 12 (0x0C) | 4 (0x04) | विभाजन में क्षेत्र                                   |

Linux में MBR को माउंट करने के लिए आपको पहले प्रारंभिक ऑफसेट प्राप्त करने की आवश्यकता है (आप `fdisk` और `p` कमांड का उपयोग कर सकते हैं)

![](<../../../images/image (413) (3) (3) (3) (2) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png>)

और फिर निम्नलिखित कोड का उपयोग करें
```bash
#Mount MBR in Linux
mount -o ro,loop,offset=<Bytes>
#63x512 = 32256Bytes
mount -o ro,loop,offset=32256,noatime /path/to/image.dd /media/part/
```
**LBA (Logical block addressing)**

**Logical block addressing** (**LBA**) एक सामान्य योजना है जो **कंप्यूटर स्टोरेज डिवाइसों** पर संग्रहीत डेटा के ब्लॉकों के स्थान को निर्दिष्ट करने के लिए उपयोग की जाती है, आमतौर पर हार्ड डिस्क ड्राइव जैसे द्वितीयक स्टोरेज सिस्टम। LBA एक विशेष रूप से सरल रैखिक एड्रेसिंग योजना है; **ब्लॉक एक पूर्णांक अनुक्रमांक द्वारा स्थित होते हैं**, पहले ब्लॉक को LBA 0, दूसरे को LBA 1, और इसी तरह।

### GPT (GUID Partition Table)

GUID Partition Table, जिसे GPT के नाम से जाना जाता है, MBR (Master Boot Record) की तुलना में इसकी उन्नत क्षमताओं के लिए पसंद किया जाता है। विभाजन के लिए **वैश्विक अद्वितीय पहचानकर्ता** के लिए विशिष्ट, GPT कई तरीकों से अलग है:

- **स्थान और आकार**: GPT और MBR दोनों **सेक्टर 0** से शुरू होते हैं। हालाँकि, GPT **64बिट** पर कार्य करता है, जबकि MBR का 32बिट है।
- **विभाजन सीमाएँ**: GPT Windows सिस्टम पर **128 विभाजनों** तक का समर्थन करता है और **9.4ZB** डेटा को समायोजित करता है।
- **विभाजन नाम**: विभाजनों को 36 Unicode वर्णों तक नाम देने की क्षमता प्रदान करता है।

**डेटा स्थिरता और पुनर्प्राप्ति**:

- **अतिरिक्तता**: MBR के विपरीत, GPT विभाजन और बूट डेटा को एक ही स्थान पर सीमित नहीं करता है। यह डेटा को डिस्क पर पुनरावृत्त करता है, डेटा की अखंडता और स्थिरता को बढ़ाता है।
- **साइक्लिक रेडंडेंसी चेक (CRC)**: GPT डेटा की अखंडता सुनिश्चित करने के लिए CRC का उपयोग करता है। यह डेटा भ्रष्टाचार की सक्रिय रूप से निगरानी करता है, और जब पता चलता है, तो GPT दूसरे डिस्क स्थान से भ्रष्ट डेटा को पुनर्प्राप्त करने का प्रयास करता है।

**सुरक्षात्मक MBR (LBA0)**:

- GPT एक सुरक्षात्मक MBR के माध्यम से पीछे की संगतता बनाए रखता है। यह सुविधा विरासत MBR स्थान में स्थित है लेकिन इसे पुराने MBR-आधारित उपयोगिताओं को गलती से GPT डिस्क को अधिलेखित करने से रोकने के लिए डिज़ाइन किया गया है, इस प्रकार GPT-फॉर्मेटेड डिस्क पर डेटा की अखंडता की रक्षा करता है।

![https://upload.wikimedia.org/wikipedia/commons/thumb/0/07/GUID_Partition_Table_Scheme.svg/800px-GUID_Partition_Table_Scheme.svg.png](<../../../images/image (1062).png>)

**हाइब्रिड MBR (LBA 0 + GPT)**

[From Wikipedia](https://en.wikipedia.org/wiki/GUID_Partition_Table)

उन ऑपरेटिंग सिस्टम में जो **BIOS** सेवाओं के माध्यम से **GPT-आधारित बूट** का समर्थन करते हैं, पहले सेक्टर का उपयोग **बूटलोडर** कोड के पहले चरण को संग्रहीत करने के लिए भी किया जा सकता है, लेकिन **संशोधित** किया गया है ताकि **GPT** **विभाजनों** को पहचान सके। MBR में बूटलोडर को 512 बाइट्स के सेक्टर आकार का अनुमान नहीं लगाना चाहिए।

**विभाजन तालिका शीर्षक (LBA 1)**

[From Wikipedia](https://en.wikipedia.org/wiki/GUID_Partition_Table)

विभाजन तालिका शीर्षक डिस्क पर उपयोगी ब्लॉकों को परिभाषित करता है। यह विभाजन तालिका (तालिका में ऑफसेट 80 और 84) का निर्माण करने वाले विभाजन प्रविष्टियों की संख्या और आकार को भी परिभाषित करता है।

| Offset    | Length   | Contents                                                                                                                                                                     |
| --------- | -------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 0 (0x00)  | 8 bytes  | Signature ("EFI PART", 45h 46h 49h 20h 50h 41h 52h 54h or 0x5452415020494645ULL[ ](https://en.wikipedia.org/wiki/GUID_Partition_Table#cite_note-8)on little-endian machines) |
| 8 (0x08)  | 4 bytes  | Revision 1.0 (00h 00h 01h 00h) for UEFI 2.8                                                                                                                                  |
| 12 (0x0C) | 4 bytes  | Header size in little endian (in bytes, usually 5Ch 00h 00h 00h or 92 bytes)                                                                                                 |
| 16 (0x10) | 4 bytes  | [CRC32](https://en.wikipedia.org/wiki/CRC32) of header (offset +0 up to header size) in little endian, with this field zeroed during calculation                             |
| 20 (0x14) | 4 bytes  | Reserved; must be zero                                                                                                                                                       |
| 24 (0x18) | 8 bytes  | Current LBA (location of this header copy)                                                                                                                                   |
| 32 (0x20) | 8 bytes  | Backup LBA (location of the other header copy)                                                                                                                               |
| 40 (0x28) | 8 bytes  | First usable LBA for partitions (primary partition table last LBA + 1)                                                                                                       |
| 48 (0x30) | 8 bytes  | Last usable LBA (secondary partition table first LBA − 1)                                                                                                                    |
| 56 (0x38) | 16 bytes | Disk GUID in mixed endian                                                                                                                                                    |
| 72 (0x48) | 8 bytes  | Starting LBA of an array of partition entries (always 2 in primary copy)                                                                                                     |
| 80 (0x50) | 4 bytes  | Number of partition entries in array                                                                                                                                         |
| 84 (0x54) | 4 bytes  | Size of a single partition entry (usually 80h or 128)                                                                                                                        |
| 88 (0x58) | 4 bytes  | CRC32 of partition entries array in little endian                                                                                                                            |
| 92 (0x5C) | \*       | Reserved; must be zeroes for the rest of the block (420 bytes for a sector size of 512 bytes; but can be more with larger sector sizes)                                      |

**विभाजन प्रविष्टियाँ (LBA 2–33)**

| GUID partition entry format |          |                                                                                                               |
| --------------------------- | -------- | ------------------------------------------------------------------------------------------------------------- |
| Offset                      | Length   | Contents                                                                                                      |
| 0 (0x00)                    | 16 bytes | [Partition type GUID](https://en.wikipedia.org/wiki/GUID_Partition_Table#Partition_type_GUIDs) (mixed endian) |
| 16 (0x10)                   | 16 bytes | Unique partition GUID (mixed endian)                                                                          |
| 32 (0x20)                   | 8 bytes  | First LBA ([little endian](https://en.wikipedia.org/wiki/Little_endian))                                      |
| 40 (0x28)                   | 8 bytes  | Last LBA (inclusive, usually odd)                                                                             |
| 48 (0x30)                   | 8 bytes  | Attribute flags (e.g. bit 60 denotes read-only)                                                               |
| 56 (0x38)                   | 72 bytes | Partition name (36 [UTF-16](https://en.wikipedia.org/wiki/UTF-16)LE code units)                               |

**विभाजन प्रकार**

![](<../../../images/image (83).png>)

More partition types in [https://en.wikipedia.org/wiki/GUID_Partition_Table](https://en.wikipedia.org/wiki/GUID_Partition_Table)

### निरीक्षण

[**ArsenalImageMounter**](https://arsenalrecon.com/downloads/) के साथ फॉरेंसिक इमेज को माउंट करने के बाद, आप Windows टूल [**Active Disk Editor**](https://www.disk-editor.org/index.html)** का उपयोग करके पहले सेक्टर का निरीक्षण कर सकते हैं।** निम्नलिखित छवि में **सेक्टर 0** पर एक **MBR** का पता लगाया गया और व्याख्या की गई:

![](<../../../images/image (354).png>)

यदि यह **MBR के बजाय एक GPT तालिका** होती, तो इसे **सेक्टर 1** में _EFI PART_ का हस्ताक्षर दिखाई देना चाहिए (जो पिछले छवि में खाली है)।

## फ़ाइल-प्रणालियाँ

### Windows फ़ाइल-प्रणालियों की सूची

- **FAT12/16**: MSDOS, WIN95/98/NT/200
- **FAT32**: 95/2000/XP/2003/VISTA/7/8/10
- **ExFAT**: 2008/2012/2016/VISTA/7/8/10
- **NTFS**: XP/2003/2008/2012/VISTA/7/8/10
- **ReFS**: 2012/2016

### FAT

**FAT (File Allocation Table)** फ़ाइल प्रणाली अपने मुख्य घटक, फ़ाइल आवंटन तालिका के चारों ओर डिज़ाइन की गई है, जो वॉल्यूम की शुरुआत में स्थित है। यह प्रणाली डेटा की सुरक्षा करती है **दो प्रतियों** को बनाए रखकर, यह सुनिश्चित करती है कि यदि एक भ्रष्ट हो जाए तो भी डेटा की अखंडता बनी रहे। तालिका, साथ ही रूट फ़ोल्डर, एक **स्थिर स्थान** में होनी चाहिए, जो प्रणाली के स्टार्टअप प्रक्रिया के लिए महत्वपूर्ण है।

फ़ाइल प्रणाली की मूल भंडारण इकाई एक **क्लस्टर, आमतौर पर 512B** है, जिसमें कई सेक्टर शामिल होते हैं। FAT ने संस्करणों के माध्यम से विकास किया है:

- **FAT12**, 12-बिट क्लस्टर पते का समर्थन करता है और 4078 क्लस्टर (4084 UNIX के साथ) को संभालता है।
- **FAT16**, 16-बिट पते में सुधार करता है, जिससे 65,517 क्लस्टर तक का समर्थन होता है।
- **FAT32**, 32-बिट पते के साथ आगे बढ़ता है, जिससे प्रति वॉल्यूम 268,435,456 क्लस्टर की प्रभावशाली संख्या की अनुमति मिलती है।

FAT संस्करणों में एक महत्वपूर्ण सीमा **4GB अधिकतम फ़ाइल आकार** है, जो फ़ाइल आकार भंडारण के लिए उपयोग किए गए 32-बिट क्षेत्र द्वारा निर्धारित है।

FAT12 और FAT16 के लिए रूट निर्देशिका के प्रमुख घटक हैं:

- **फ़ाइल/फ़ोल्डर नाम** (8 वर्णों तक)
- **गुण**
- **निर्माण, संशोधन, और अंतिम पहुँच तिथियाँ**
- **FAT तालिका पता** (फ़ाइल के प्रारंभ क्लस्टर को इंगित करता है)
- **फ़ाइल आकार**

### EXT

**Ext2** सबसे सामान्य फ़ाइल प्रणाली है जो **जर्नलिंग** विभाजनों (**विभाजन जो ज्यादा नहीं बदलते**) के लिए है जैसे बूट विभाजन। **Ext3/4** **जर्नलिंग** हैं और आमतौर पर **बाकी विभाजनों** के लिए उपयोग की जाती हैं।

## **मेटाडेटा**

कुछ फ़ाइलों में मेटाडेटा होता है। यह जानकारी फ़ाइल की सामग्री के बारे में होती है जो कभी-कभी विश्लेषक के लिए दिलचस्प हो सकती है क्योंकि फ़ाइल के प्रकार के आधार पर, इसमें जानकारी हो सकती है जैसे:

- शीर्षक
- MS Office संस्करण का उपयोग किया गया
- लेखक
- निर्माण और अंतिम संशोधन की तिथियाँ
- कैमरे का मॉडल
- GPS निर्देशांक
- छवि जानकारी

आप फ़ाइल के मेटाडेटा प्राप्त करने के लिए [**exiftool**](https://exiftool.org) और [**Metadiver**](https://www.easymetadata.com/metadiver-2/) जैसे उपकरणों का उपयोग कर सकते हैं।

## **हटाई गई फ़ाइलों की पुनर्प्राप्ति**

### लॉग की गई हटाई गई फ़ाइलें

जैसा कि पहले देखा गया है, कई स्थान हैं जहाँ फ़ाइल "हटाई गई" होने के बाद भी अभी भी सहेजी गई है। इसका कारण यह है कि आमतौर पर फ़ाइल सिस्टम से फ़ाइल को हटाने से इसे केवल हटाए गए के रूप में चिह्नित किया जाता है लेकिन डेटा को छुआ नहीं जाता। फिर, फ़ाइलों के रजिस्ट्रियों (जैसे MFT) का निरीक्षण करना और हटाई गई फ़ाइलों को खोजना संभव है।

इसके अलावा, OS आमतौर पर फ़ाइल सिस्टम परिवर्तनों और बैकअप के बारे में बहुत सारी जानकारी सहेजता है, इसलिए फ़ाइल को पुनर्प्राप्त करने या यथासंभव अधिक जानकारी प्राप्त करने के लिए उनका उपयोग करने का प्रयास करना संभव है।

{{#ref}}
file-data-carving-recovery-tools.md
{{#endref}}

### **फ़ाइल कार्विंग**

**फ़ाइल कार्विंग** एक तकनीक है जो **डेटा के बड़े हिस्से में फ़ाइलों को खोजने की कोशिश करती है**। इस तरह के उपकरणों के काम करने के 3 मुख्य तरीके हैं: **फ़ाइल प्रकार के शीर्षकों और फुटर्स के आधार पर**, फ़ाइल प्रकार की **संरचनाओं** के आधार पर और **सामग्री** के आधार पर।

ध्यान दें कि यह तकनीक **खंडित फ़ाइलों को पुनर्प्राप्त करने के लिए काम नहीं करती**। यदि एक फ़ाइल **सन्निहित सेक्टरों में संग्रहीत नहीं है**, तो यह तकनीक इसे या कम से कम इसके एक भाग को खोजने में असमर्थ होगी।

आप फ़ाइल कार्विंग के लिए कई उपकरणों का उपयोग कर सकते हैं जो आप जिन फ़ाइल प्रकारों को खोजने के लिए संकेत देते हैं।

{{#ref}}
file-data-carving-recovery-tools.md
{{#endref}}

### डेटा स्ट्रीम **C**arving

डेटा स्ट्रीम कार्विंग फ़ाइल कार्विंग के समान है लेकिन **पूर्ण फ़ाइलों की तलाश करने के बजाय, यह जानकारी के दिलचस्प टुकड़ों की तलाश करता है**।\
उदाहरण के लिए, लॉग की गई URL को शामिल करने वाली एक पूर्ण फ़ाइल की तलाश करने के बजाय, यह तकनीक URL की खोज करेगी।

{{#ref}}
file-data-carving-recovery-tools.md
{{#endref}}

### सुरक्षित हटाना

स्पष्ट रूप से, फ़ाइलों और उनके बारे में लॉग के एक भाग को **"सुरक्षित" हटाने** के तरीके हैं। उदाहरण के लिए, एक फ़ाइल की सामग्री को कई बार बेकार डेटा के साथ **ओवरराइट** करना संभव है, और फिर फ़ाइल के बारे में **$MFT** और **$LOGFILE** से **लॉग** को **हटाना**, और **वॉल्यूम शैडो कॉपीज़** को **हटाना**।\
आप देख सकते हैं कि इस क्रिया को करने पर भी फ़ाइल के अस्तित्व को लॉग करने के लिए **अन्य भाग हो सकते हैं**, और यह सच है और फॉरेंसिक पेशेवर का काम उन्हें खोजना है।

## संदर्भ

- [https://en.wikipedia.org/wiki/GUID_Partition_Table](https://en.wikipedia.org/wiki/GUID_Partition_Table)
- [http://ntfs.com/ntfs-permissions.htm](http://ntfs.com/ntfs-permissions.htm)
- [https://www.osforensics.com/faqs-and-tutorials/how-to-scan-ntfs-i30-entries-deleted-files.html](https://www.osforensics.com/faqs-and-tutorials/how-to-scan-ntfs-i30-entries-deleted-files.html)
- [https://docs.microsoft.com/en-us/windows-server/storage/file-server/volume-shadow-copy-service](https://docs.microsoft.com/en-us/windows-server/storage/file-server/volume-shadow-copy-service)
- **iHackLabs Certified Digital Forensics Windows**

{{#include ../../../banners/hacktricks-training.md}}
