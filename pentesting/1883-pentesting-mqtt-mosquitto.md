# 1883 - Pentesting MQTT \(Mosquitto\)

## Basic Information

MQTT stands for MQ Telemetry Transport. It is a publish/subscribe, extremely simple and lightweight messaging protocol, designed for constrained devices and low-bandwidth, high-latency or unreliable networks. The design principles are to minimise network bandwidth and device resource requirements whilst also attempting to ensure reliability and some degree of assurance of delivery. These principles also turn out to make the protocol ideal of the emerging “machine-to-machine” \(M2M\) or “Internet of Things” world of connected devices, and for mobile applications where bandwidth and battery power are at a premium.

**Default port:** 1883

```text
PORT     STATE SERVICE                 REASON
1883/tcp open  mosquitto version 1.4.8 syn-ack
```

## Pentesting MQTT

**Authentication is totally optional** and even if authentication is being performed, **encryption is not used by default** \(credentials are sent in clear text\). MITM attacks can still be executed to steal passwords.

To connect to a MQTT service you can use: [https://github.com/bapowell/python-mqtt-client-shell](https://github.com/bapowell/python-mqtt-client-shell) and subscribe yourself to all the topics doing:

```text
> connect (NOTICE that you need to indicate before this the params of the connection, by default 127.0.0.1:1883)
> subscribe "#" 1
> subscribe "$SYS/#"
```

You could also use [https://github.com/akamai-threat-research/mqtt-pwn](https://github.com/akamai-threat-research/mqtt-pwn)

Or you could **run this code to try to connect to a MQTT service without authentication, subscribe to every topic and listen them**:

```python
#This is a modified version of https://github.com/Warflop/IOT-MQTT-Exploit/blob/master/mqtt.py
import paho.mqtt.client as mqtt
import time
import os

HOST = "127.0.0.1"
PORT = 1883

def on_connect(client, userdata, flags, rc):
	client.subscribe('#', qos=1)
	client.subscribe('$SYS/#')

def on_message(client, userdata, message):
	print('Topic: %s | QOS: %s  | Message: %s' % (message.topic, message.qos, message.payload))

def main():
	client = mqtt.Client()
	client.on_connect = on_connect
	client.on_message = on_message
	client.connect(HOST, PORT)
	client.loop_start()
	#time.sleep(10)
	#client.loop_stop()

if __name__ == "__main__":
	main()
```

## More information

from here: [https://morphuslabs.com/hacking-the-iot-with-mqtt-8edaf0d07b9b](https://morphuslabs.com/hacking-the-iot-with-mqtt-8edaf0d07b9b)

### The Publish/Subscribe Pattern <a id="b667"></a>

The publish/subscribe model is composed of:

* **Publisher**: publishes a message to one \(or many\) topic\(s\) in the broker.
* **Subscriber**: subscribes to one \(or many\) topic\(s\) in the broker and receives all the messages sent from the publisher.
* **Broker**: routes all the messages from the publishers to the subscribers.
* **Topic**: consists of one or more levels that are separated by a a forward slash \(e.g., /smartshouse/livingroom/temperature\).

![](https://miro.medium.com/max/60/1*sIxvchdgHSqAGebJjFHBAg.png?q=20)![](https://miro.medium.com/max/1073/1*sIxvchdgHSqAGebJjFHBAg.png)Figure 01: The Publish/Subscribe Model

### Packet Format <a id="f15a"></a>

Every MQTT packet contains a fixed header \(Figure 02\).Figure 02: Fixed Header

![](https://miro.medium.com/max/838/1*k6RkAHEk0576geQGUcKSTA.png)

The first field of the fixed header represents the type of the MQTT Packet. All packet types are listed in table 01.Table 01: MQTT Packet Types

![](https://miro.medium.com/max/1469/1*z0fhdUVzGa0PLikH_cyBmQ.png)

## Shodan

* `port:1883 MQTT`

