# First Fit

<details>

<summary><strong>ゼロからヒーローまでのAWSハッキングを学ぶ</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE（HackTricks AWS Red Team Expert）</strong></a><strong>！</strong></summary>

HackTricks をサポートする他の方法:

* **HackTricks で企業を宣伝したい** または **HackTricks をPDFでダウンロードしたい** 場合は [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop) をチェックしてください！
* [**公式PEASS＆HackTricksグッズ**](https://peass.creator-spring.com)を入手する
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)、当社の独占的な [**NFTs**](https://opensea.io/collection/the-peass-family) コレクションを発見する
* **💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f) または [**telegramグループ**](https://t.me/peass) に参加するか、**Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)** をフォローする。**
* **ハッキングトリックを共有するために** [**HackTricks**](https://github.com/carlospolop/hacktricks) と [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) のGitHubリポジトリにPRを提出する。

</details>

## **First Fit**

glibcを使用してプログラム内のメモリを解放すると、異なる "bins" がメモリチャンクを管理するために使用されます。ここでは、2つの一般的なシナリオ、unsorted bins と fastbins の簡略化された説明があります。

### Unsorted Bins

高速チャンクでないメモリチャンクを解放すると、それはunsorted binに移動します。このbinは、新しく解放されたチャンクが前方（"head"）に追加されるリストのように機能します。新しいメモリチャンクを要求すると、アロケータはunsorted binを後方（"tail"）から見て、必要なサイズのチャンクを見つけます。unsorted binからのチャンクが必要なサイズよりも大きい場合、分割され、前半部分が返され、残りの部分がbinに残ります。

例:

* 300バイト (`a`) を割り当て、次に250バイト (`b`) を割り当て、`a` を解放してから再度250バイト (`c`) を要求します。
* `a` を解放すると、unsorted binに移動します。
* 次に250バイトを要求すると、アロケータはtailで`a`を見つけ、それを分割して、リクエストに合う部分を返し、残りをbinに保持します。
* `c` は以前の `a` を指し示し、`a` で埋められます。
```c
char *a = malloc(300);
char *b = malloc(250);
free(a);
char *c = malloc(250);
```
### Fastbins

Fastbinsは小さなメモリチャンクに使用されます。Unsorted binsとは異なり、fastbinsは新しいチャンクを先頭に追加し、最後に追加されたものが最初に取り出される（LIFO）動作を作成します。もしメモリの小さなチャンクをリクエストすると、アロケータはfastbinの先頭から取り出します。

例:

* 20バイトずつ4つのチャンク（`a`、`b`、`c`、`d`）を割り当てます。
* 任意の順序でそれらを解放すると、解放されたチャンクはfastbinの先頭に追加されます。
* その後20バイトのチャンクをリクエストすると、アロケータはfastbinの先頭から最も最近解放されたチャンクを返します。
```c
char *a = malloc(20);
char *b = malloc(20);
char *c = malloc(20);
char *d = malloc(20);
free(a);
free(b);
free(c);
free(d);
a = malloc(20);   // d
b = malloc(20);   // c
c = malloc(20);   // b
d = malloc(20);   // a
```
## その他の参考文献と例

* [**https://heap-exploitation.dhavalkapil.com/attacks/first\_fit**](https://heap-exploitation.dhavalkapil.com/attacks/first\_fit)
* [**https://8ksec.io/arm64-reversing-and-exploitation-part-2-use-after-free/**](https://8ksec.io/arm64-reversing-and-exploitation-part-2-use-after-free/)
* ARM64。Use after free: ユーザーオブジェクトを生成し、解放し、解放されたチャンクを取得し、そのチャンクに書き込みを許可するオブジェクトを生成し、**以前のものからuser->passwordの位置を上書き**します。ユーザーを再利用して**パスワードチェックをバイパス**します。
* [**https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/use\_after\_free/#example**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/use\_after\_free/#example)
* プログラムはノートを作成することを許可します。ノートには、malloc(8)でノート情報（呼び出される可能性のある関数へのポインタを持つ）と、ノートの内容を持つ別のmalloc(\<size>)へのポインタがあります。
* 攻撃は、ノート情報サイズよりも大きなmallocコンテンツを持つ2つのノート（note0とnote1）を作成し、それらを解放して高速ビン（またはtcache）に入れることです。
* 次に、コンテンツサイズが8の別のノート（note2）を作成します。コンテンツはノート1になり、チャンクが再利用されるため、関数ポインタをwin関数を指すように変更し、その後、note1をUse-After-Freeして新しい関数ポインタを呼び出します。
* [**https://guyinatuxedo.github.io/26-heap\_grooming/pico\_areyouroot/index.html**](https://guyinatuxedo.github.io/26-heap\_grooming/pico\_areyouroot/index.html)
* 一部のメモリを割り当て、必要な値を書き込み、解放し、再割り当てすることが可能で、以前のデータがまだ残っているため、新しい期待される構造体に従って処理され、値を設定するかフラグを取得することが可能です。
* [**https://guyinatuxedo.github.io/26-heap\_grooming/swamp19\_heapgolf/index.html**](https://guyinatuxedo.github.io/26-heap\_grooming/swamp19\_heapgolf/index.html)
* この場合、最初に割り当てられた特定のチャンクに4を書き込む必要があります（それらをすべて強制的に解放した後でも）。 新しく割り当てられた各チャンクには、配列インデックスの番号が格納されます。 次に、4つのチャンク（最初に割り当てられたものを含む）を割り当て、最後のチャンクにはその中に4が含まれています。それらを解放し、最初のチャンクを再割り当てし、最後に解放された最初のチャンクを使用します。それは中に4が含まれているチャンクです。
