# BROP - Programaci칩n Orientada a Retorno a Ciegas

<details>

<summary><strong>Aprende hacking en AWS desde cero hasta experto con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Otras formas de apoyar a HackTricks:

* Si deseas ver tu **empresa anunciada en HackTricks** o **descargar HackTricks en PDF** 춰Consulta los [**PLANES DE SUSCRIPCI칍N**](https://github.com/sponsors/carlospolop)!
* Obt칠n la [**merchandising oficial de PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubre [**La Familia PEASS**](https://opensea.io/collection/the-peass-family), nuestra colecci칩n exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **칔nete al** 游눫 [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s칤guenos** en **Twitter** 游냕 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Comparte tus trucos de hacking enviando PRs a los repositorios de** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

## Informaci칩n B치sica

El objetivo de este ataque es poder **abusar de un ROP a trav칠s de un desbordamiento de b칰fer sin tener informaci칩n sobre el binario vulnerable**.\
Este ataque se basa en el siguiente escenario:

* Una vulnerabilidad de pila y conocimiento de c칩mo activarla.
* Una aplicaci칩n de servidor que se reinicia despu칠s de un fallo.

## Ataque

### **1. Encontrar el desplazamiento vulnerable** enviando un car치cter m치s hasta que se detecte un mal funcionamiento del servidor

### **2. Fuerza bruta del canary** para filtrarlo&#x20;

### **3. Fuerza bruta de las direcciones almacenadas de RBP y RIP** en la pila para filtrarlas

Puedes encontrar m치s informaci칩n sobre estos procesos [aqu칤 (BF Forked & Threaded Stack Canaries)](../common-binary-protections-and-bypasses/stack-canaries/bf-forked-stack-canaries.md) y [aqu칤 (BF Addresses in the Stack)](../common-binary-protections-and-bypasses/pie/bypassing-canary-and-pie.md).

### **4. Encontrar el gadget de parada**

Este gadget b치sicamente permite confirmar que algo interesante fue ejecutado por el gadget ROP porque la ejecuci칩n no se bloque칩. Por lo general, este gadget va a ser algo que **detiene la ejecuci칩n** y se posiciona al final de la cadena ROP al buscar gadgets ROP para confirmar que se ejecut칩 un gadget ROP espec칤fico.

### **5. Encontrar el gadget BROP**

Esta t칠cnica utiliza el gadget [**ret2csu**](ret2csu.md). Y esto se debe a que si se accede a este gadget en medio de algunas instrucciones, se obtienen gadgets para controlar **`rsi`** y **`rdi`**:

<figure><img src="../../.gitbook/assets/image.png" alt="" width="278"><figcaption><p><a href="https://www.scs.stanford.edu/brop/bittau-brop.pdf">https://www.scs.stanford.edu/brop/bittau-brop.pdf</a></p></figcaption></figure>

Estos ser칤an los gadgets:

* `pop rsi; pop r15; ret`
* `pop rdi; ret`

Observa c칩mo con esos gadgets es posible **controlar 2 argumentos** de una funci칩n a llamar.

Adem치s, observa que el gadget ret2csu tiene una **firma muy 칰nica** porque va a sacar 6 registros de la pila. Por lo tanto, enviando una cadena como:

`'A' * desplazamiento + canary + rbp + DIRECCI칍N + 0xdead * 6 + STOP`

Si se ejecuta el **STOP**, esto b치sicamente significa que se utiliz칩 una **direcci칩n que est치 sacando 6 registros** de la pila. O que la direcci칩n utilizada tambi칠n fue una direcci칩n de STOP.

Para **eliminar esta 칰ltima opci칩n**, se ejecuta una nueva cadena como la siguiente y no debe ejecutar el gadget STOP para confirmar que el anterior sac칩 6 registros:

`'A' * desplazamiento + canary + rbp + DIRECCI칍N`

Conociendo la direcci칩n del gadget ret2csu, es posible **inferir la direcci칩n de los gadgets para controlar `rsi` y `rdi`**.

### 6. Encontrar PLT

La tabla PLT se puede buscar desde 0x400000 o desde la **direcci칩n RIP filtrada** de la pila (si se est치 utilizando **PIE**). Las **entradas** de la tabla est치n **separadas por 16B** (0x10B), y cuando se llama a una funci칩n, el servidor no se bloquea incluso si los argumentos no son correctos. Adem치s, verificar la direcci칩n de una entrada en el **PLT + 6B tampoco se bloquea** ya que es el primer c칩digo ejecutado.

Por lo tanto, es posible encontrar la tabla PLT verificando los siguientes comportamientos:

* `'A' * desplazamiento + canary + rbp + DIRECCI칍N + STOP` -> sin bloqueo
* `'A' * desplazamiento + canary + rbp + (DIRECCI칍N + 0x6) + STOP` -> sin bloqueo
* `'A' * desplazamiento + canary + rbp + (DIRECCI칍N + 0x10) + STOP` -> sin bloqueo

### 7. Encontrar strcmp

La funci칩n **`strcmp`** establece el registro **`rdx`** a la longitud de la cadena que se est치 comparando. Ten en cuenta que **`rdx`** es el **tercer argumento** y necesitamos que sea **mayor que 0** para luego usar `write` para filtrar el programa.

Es posible encontrar la ubicaci칩n de **`strcmp`** en la tabla PLT bas치ndose en su comportamiento utilizando el hecho de que ahora podemos controlar los 2 primeros argumentos de las funciones:

* strcmp(\<direcci칩n no le칤da>, \<direcci칩n no le칤da>) -> bloqueo
* strcmp(\<direcci칩n no le칤da>, \<direcci칩n le칤da>) -> bloqueo
* strcmp(\<direcci칩n le칤da>, \<direcci칩n no le칤da>) -> bloqueo
* strcmp(\<direcci칩n le칤da>, \<direcci칩n le칤da>) -> sin bloqueo

Es posible verificar esto llamando a cada entrada de la tabla PLT o utilizando el **camino lento de PLT** que b치sicamente consiste en **llamar a una entrada en la tabla PLT + 0xb** (que llama a **`dlresolve`**) seguido en la pila por el **n칰mero de entrada que se desea sondear** (comenzando en cero) para escanear todas las entradas de PLT desde la primera:

* strcmp(\<direcci칩n no le칤da>, \<direcci칩n le칤da>) -> bloqueo
* `b'A' * desplazamiento + canary + rbp + (BROP + 0x9) + RIP + (BROP + 0x7) + p64(0x300) + p64(0x0) + (PLT + 0xb ) + p64(ENTRY) + STOP` -> Bloquear치
* strcmp(\<direcci칩n le칤da>, \<direcci칩n no le칤da>) -> bloqueo
* `b'A' * desplazamiento + canary + rbp + (BROP + 0x9) + p64(0x300) + (BROP + 0x7) + RIP + p64(0x0) + (PLT + 0xb ) + p64(ENTRY) + STOP`&#x20;
* strcmp(\<direcci칩n le칤da>, \<direcci칩n le칤da>) -> sin bloqueo
* `b'A' * desplazamiento + canary + rbp + (BROP + 0x9) + RIP + (BROP + 0x7) + RIP + p64(0x0) + (PLT + 0xb ) + p64(ENTRY) + STOP`&#x20;

Recuerda que:

* BROP + 0x7 apunta a **`pop RSI; pop R15; ret;`**
* BROP + 0x9 apunta a **`pop RDI; ret;`**
* PLT + 0xb apunta a una llamada a **dl\_resolve**.

Habiendo encontrado `strcmp`, es posible establecer **`rdx`** en un valor mayor que 0.

{% hint style="success" %}
Ten en cuenta que por lo general `rdx` ya contendr치 un valor mayor que 0, por lo que este paso podr칤a no ser necesario.
{% endhint %}
### 8. Encontrar Write o equivalente

Finalmente, se necesita un gadget que exfiltre datos para exfiltrar el binario. Y en este momento es posible **controlar 2 argumentos y establecer `rdx` mayor que 0.**

Hay 3 funciones comunes que podr칤an ser abusadas para esto:

* `puts(data)`
* `dprintf(fd, data)`
* `write(fd, data, len(data)`

Sin embargo, el documento original solo menciona la funci칩n **`write`**, as칤 que hablemos de ella:

El problema actual es que no sabemos **d칩nde est치 la funci칩n write dentro de la PLT** y no sabemos **un n칰mero de fd para enviar los datos a nuestro socket**.

Sin embargo, sabemos **d칩nde est치 la tabla PLT** y es posible encontrar write basado en su **comportamiento**. Y podemos crear **varias conexiones** con el servidor y usar un **FD alto** esperando que coincida con algunas de nuestras conexiones.

Firmas de comportamiento para encontrar esas funciones:

* `'A' * offset + canary + rbp + (BROP + 0x9) + RIP + (BROP + 0x7) + p64(0) + p64(0) + (PLT + 0xb) + p64(ENTRY) + STOP`  -> Si se imprime alg칰n dato, entonces se encontr칩 puts
* `'A' * offset + canary + rbp + (BROP + 0x9) + FD + (BROP + 0x7) + RIP + p64(0x0) + (PLT + 0xb) + p64(ENTRY) + STOP`  -> Si se imprime alg칰n dato, entonces se encontr칩 dprintf
* `'A' * offset + canary + rbp + (BROP + 0x9) + RIP + (BROP + 0x7) + (RIP + 0x1) + p64(0x0) + (PLT + 0xb ) + p64(STRCMP ENTRY) + (BROP + 0x9) + FD + (BROP + 0x7) + RIP + p64(0x0) + (PLT + 0xb) + p64(ENTRY) + STOP`  -> Si se imprime alg칰n dato, entonces se encontr칩 write

## Explotaci칩n Autom치tica

* [https://github.com/Hakumarachi/Bropper](https://github.com/Hakumarachi/Bropper)

## Referencias

* Documento original: [https://www.scs.stanford.edu/brop/bittau-brop.pdf](https://www.scs.stanford.edu/brop/bittau-brop.pdf)
* [https://www.ctfrecipes.com/pwn/stack-exploitation/arbitrary-code-execution/code-reuse-attack/blind-return-oriented-programming-brop](https://www.ctfrecipes.com/pwn/stack-exploitation/arbitrary-code-execution/code-reuse-attack/blind-return-oriented-programming-brop)

<details>

<summary><strong>Aprende hacking en AWS desde cero hasta experto con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Otras formas de apoyar a HackTricks:

* Si deseas ver tu **empresa anunciada en HackTricks** o **descargar HackTricks en PDF** 춰Consulta los [**PLANES DE SUSCRIPCI칍N**](https://github.com/sponsors/carlospolop)!
* Obt칠n la [**merchandising oficial de PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubre [**The PEASS Family**](https://opensea.io/collection/the-peass-family), nuestra colecci칩n exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **칔nete al** 游눫 [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s칤guenos** en **Twitter** 游냕 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Comparte tus trucos de hacking enviando PRs a los repositorios de** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github.

</details>
