# malloc & sysmalloc

<details>

<summary><strong>ã‚¼ãƒ­ã‹ã‚‰ãƒ’ãƒ¼ãƒ­ãƒ¼ã¾ã§ã®AWSãƒãƒƒã‚­ãƒ³ã‚°ã‚’å­¦ã¶</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTEï¼ˆHackTricks AWS Red Team Expertï¼‰</strong></a><strong>ï¼</strong></summary>

HackTricksã‚’ã‚µãƒãƒ¼ãƒˆã™ã‚‹ä»–ã®æ–¹æ³•ï¼š

- **HackTricksã§ä¼æ¥­ã‚’å®£ä¼ã—ãŸã„**ã¾ãŸã¯**HackTricksã‚’PDFã§ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã—ãŸã„**å ´åˆã¯ã€[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)ã‚’ãƒã‚§ãƒƒã‚¯ã—ã¦ãã ã•ã„ï¼
- [**å…¬å¼PEASSï¼†HackTricksã‚¹ãƒ¯ãƒƒã‚°**](https://peass.creator-spring.com)ã‚’å…¥æ‰‹ã™ã‚‹
- [**The PEASS Family**](https://opensea.io/collection/the-peass-family)ã‚’ç™ºè¦‹ã—ã€ç‹¬å çš„ãª[**NFTs**](https://opensea.io/collection/the-peass-family)ã®ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã‚’è¦‹ã¤ã‘ã‚‹
- **ğŸ’¬ [Discordã‚°ãƒ«ãƒ¼ãƒ—](https://discord.gg/hRep4RUj7f)**ã¾ãŸã¯[Telegramã‚°ãƒ«ãƒ¼ãƒ—](https://t.me/peass)ã«**å‚åŠ **ã™ã‚‹ã‹ã€**Twitter** ğŸ¦ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)ã‚’**ãƒ•ã‚©ãƒ­ãƒ¼**ã™ã‚‹ã€‚
- **ãƒãƒƒã‚­ãƒ³ã‚°ãƒˆãƒªãƒƒã‚¯ã‚’å…±æœ‰ã™ã‚‹ã«ã¯ã€[HackTricks](https://github.com/carlospolop/hacktricks)ã¨[HackTricks Cloud](https://github.com/carlospolop/hacktricks-cloud)ã®GitHubãƒªãƒã‚¸ãƒˆãƒªã«PRã‚’æå‡ºã—ã¦ãã ã•ã„ã€‚**

</details>

## Allocation Order Summary <a href="#libc_malloc" id="libc_malloc"></a>

ï¼ˆã“ã®è¦ç´„ã§ã¯ãƒã‚§ãƒƒã‚¯ã¯èª¬æ˜ã•ã‚Œã¦ãŠã‚‰ãšã€ç°¡æ½”ã•ã®ãŸã‚ä¸€éƒ¨ã®ã‚±ãƒ¼ã‚¹ãŒçœç•¥ã•ã‚Œã¦ã„ã¾ã™ï¼‰

1. `__libc_malloc` ã¯ã€tcache ã‹ã‚‰ãƒãƒ£ãƒ³ã‚¯ã‚’å–å¾—ã—ã‚ˆã†ã¨ã—ã¾ã™ã€‚å–å¾—ã§ããªã„å ´åˆã¯ `_int_malloc` ã‚’å‘¼ã³å‡ºã—ã¾ã™ã€‚
2. `_int_malloc`ï¼š
   1. ã‚¢ãƒªãƒ¼ãƒŠã‚’ç”Ÿæˆã—ã‚ˆã†ã¨ã—ã¾ã™ï¼ˆå­˜åœ¨ã—ãªã„å ´åˆï¼‰
   2. æ­£ã—ã„ã‚µã‚¤ã‚ºã®ä»»æ„ã®ãƒ•ã‚¡ã‚¹ãƒˆãƒ“ãƒ³ãƒãƒ£ãƒ³ã‚¯ãŒã‚ã‚Œã°ä½¿ç”¨ã—ã¾ã™
      1. ä»–ã®ãƒ•ã‚¡ã‚¹ãƒˆãƒãƒ£ãƒ³ã‚¯ã§ tcache ã‚’åŸ‹ã‚ã¾ã™
   3. æ­£ã—ã„ã‚µã‚¤ã‚ºã®ä»»æ„ã®ã‚¹ãƒ¢ãƒ¼ãƒ«ãƒ“ãƒ³ãƒãƒ£ãƒ³ã‚¯ãŒã‚ã‚Œã°ä½¿ç”¨ã—ã¾ã™
      1. ãã®ã‚µã‚¤ã‚ºã®ä»–ã®ãƒãƒ£ãƒ³ã‚¯ã§ tcache ã‚’åŸ‹ã‚ã¾ã™
   4. è¦æ±‚ã•ã‚ŒãŸã‚µã‚¤ã‚ºãŒã‚¹ãƒ¢ãƒ¼ãƒ«ãƒ“ãƒ³ç”¨ã§ãªã„å ´åˆã€ãƒ•ã‚¡ã‚¹ãƒˆãƒ“ãƒ³ã‚’ã‚¢ãƒ³ã‚½ãƒ¼ãƒˆãƒ“ãƒ³ã«çµ±åˆã—ã¾ã™
   5. ã‚¢ãƒ³ã‚½ãƒ¼ãƒˆãƒ“ãƒ³ã‚’ãƒã‚§ãƒƒã‚¯ã—ã€ååˆ†ãªã‚¹ãƒšãƒ¼ã‚¹ãŒã‚ã‚‹æœ€åˆã®ãƒãƒ£ãƒ³ã‚¯ã‚’ä½¿ç”¨ã—ã¾ã™
      1. è¦‹ã¤ã‹ã£ãŸãƒãƒ£ãƒ³ã‚¯ãŒå¤§ãã„å ´åˆã€ä¸€éƒ¨ã‚’è¿”å´ã™ã‚‹ãŸã‚ã«åˆ†å‰²ã—ã€æ®‹ã‚Šã‚’ã‚¢ãƒ³ã‚½ãƒ¼ãƒˆãƒ“ãƒ³ã«è¿½åŠ ã—ã¾ã™
      2. ã‚µã‚¤ã‚ºãŒè¦æ±‚ã•ã‚ŒãŸã‚µã‚¤ã‚ºã¨åŒã˜å ´åˆã€ãã‚Œã‚’è¿”å´ã™ã‚‹ä»£ã‚ã‚Šã« tcache ã‚’åŸ‹ã‚ã‚‹ãŸã‚ã«ä½¿ç”¨ã—ã¾ã™ï¼ˆtcache ãŒã„ã£ã±ã„ã«ãªã‚‹ã¾ã§ã€æ¬¡ã®ã‚‚ã®ã‚’è¿”å´ã—ã¾ã™ï¼‰
      3. ãƒã‚§ãƒƒã‚¯ã•ã‚ŒãŸã‚µã‚¤ã‚ºã‚ˆã‚Šã‚‚å°ã•ã„ã‚µã‚¤ã‚ºã®å„ãƒãƒ£ãƒ³ã‚¯ã«ã¤ã„ã¦ã€ãã‚Œãã‚Œå¯¾å¿œã™ã‚‹ã‚¹ãƒ¢ãƒ¼ãƒ«ãƒ“ãƒ³ã¾ãŸã¯ãƒ©ãƒ¼ã‚¸ãƒ“ãƒ³ã«é…ç½®ã—ã¾ã™
   6. è¦æ±‚ã•ã‚ŒãŸã‚µã‚¤ã‚ºã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã§ãƒ©ãƒ¼ã‚¸ãƒ“ãƒ³ã‚’ãƒã‚§ãƒƒã‚¯ã—ã¾ã™
      1. è¦æ±‚ã•ã‚ŒãŸã‚µã‚¤ã‚ºã‚ˆã‚Šã‚‚å¤§ãã„æœ€åˆã®ãƒãƒ£ãƒ³ã‚¯ã‹ã‚‰æ¤œç´¢ã‚’é–‹å§‹ã—ã€è¦‹ã¤ã‹ã£ãŸå ´åˆã¯ãã‚Œã‚’è¿”å´ã—ã€æ®‹ã‚Šã‚’ã‚¹ãƒ¢ãƒ¼ãƒ«ãƒ“ãƒ³ã«è¿½åŠ ã—ã¾ã™
   7. æœ€å¾Œã¾ã§ã®æ¬¡ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‹ã‚‰ãƒ©ãƒ¼ã‚¸ãƒ“ãƒ³ã‚’ãƒã‚§ãƒƒã‚¯ã—ã¾ã™
      1. æ¬¡ã®å¤§ããªã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‹ã‚‰ã€ãƒãƒ£ãƒ³ã‚¯ã‚’æ¤œç´¢ã—ã€æœ€åˆã«è¦‹ã¤ã‹ã£ãŸãƒãƒ£ãƒ³ã‚¯ã‚’ä½¿ç”¨ã—ã¦è¦æ±‚ã•ã‚ŒãŸã‚µã‚¤ã‚ºã«ä½¿ç”¨ã—ã€æ®‹ã‚Šã‚’ã‚¢ãƒ³ã‚½ãƒ¼ãƒˆãƒ“ãƒ³ã«è¿½åŠ ã—ã¾ã™
   8. å‰ã®ãƒ“ãƒ³ã§ä½•ã‚‚è¦‹ã¤ã‹ã‚‰ãªã„å ´åˆã€ãƒˆãƒƒãƒ—ãƒãƒ£ãƒ³ã‚¯ã‹ã‚‰ãƒãƒ£ãƒ³ã‚¯ã‚’å–å¾—ã—ã¾ã™
   9. ãƒˆãƒƒãƒ—ãƒãƒ£ãƒ³ã‚¯ãŒååˆ†ã«å¤§ãããªã„å ´åˆã¯ã€`sysmalloc` ã§æ‹¡å¼µã—ã¾ã™

## \_\_libc\_malloc <a href="#libc_malloc" id="libc_malloc"></a>

`malloc` é–¢æ•°ã¯å®Ÿéš›ã«ã¯ `__libc_malloc` ã‚’å‘¼ã³å‡ºã—ã¾ã™ã€‚ã“ã®é–¢æ•°ã¯ã€tcache ã‚’ãƒã‚§ãƒƒã‚¯ã—ã¦ã€å¿…è¦ãªã‚µã‚¤ã‚ºã®åˆ©ç”¨å¯èƒ½ãªãƒãƒ£ãƒ³ã‚¯ãŒã‚ã‚‹ã‹ã©ã†ã‹ã‚’ç¢ºèªã—ã¾ã™ã€‚åˆ©ç”¨å¯èƒ½ãªå ´åˆã¯ãã‚Œã‚’ä½¿ç”¨ã—ã€ãã†ã§ãªã„å ´åˆã¯ã‚·ãƒ³ã‚°ãƒ«ã‚¹ãƒ¬ãƒƒãƒ‰ã§ã‚ã‚‹ã‹ã©ã†ã‹ã‚’ç¢ºèªã—ã€ãã®å ´åˆã¯ãƒ¡ã‚¤ãƒ³ã‚¢ãƒªãƒ¼ãƒŠã® `_int_malloc` ã‚’å‘¼ã³å‡ºã—ã€ãã†ã§ãªã„å ´åˆã¯ã‚¹ãƒ¬ãƒƒãƒ‰ã®ã‚¢ãƒªãƒ¼ãƒŠã® `_int_malloc` ã‚’å‘¼ã³å‡ºã—ã¾ã™ã€‚

<details>

<summary>__libc_malloc ã‚³ãƒ¼ãƒ‰</summary>
```c
// From https://github.com/bminor/glibc/blob/master/malloc/malloc.c

#if IS_IN (libc)
void *
__libc_malloc (size_t bytes)
{
mstate ar_ptr;
void *victim;

_Static_assert (PTRDIFF_MAX <= SIZE_MAX / 2,
"PTRDIFF_MAX is not more than half of SIZE_MAX");

if (!__malloc_initialized)
ptmalloc_init ();
#if USE_TCACHE
/* int_free also calls request2size, be careful to not pad twice.  */
size_t tbytes = checked_request2size (bytes);
if (tbytes == 0)
{
__set_errno (ENOMEM);
return NULL;
}
size_t tc_idx = csize2tidx (tbytes);

MAYBE_INIT_TCACHE ();

DIAG_PUSH_NEEDS_COMMENT;
if (tc_idx < mp_.tcache_bins
&& tcache != NULL
&& tcache->counts[tc_idx] > 0)
{
victim = tcache_get (tc_idx);
return tag_new_usable (victim);
}
DIAG_POP_NEEDS_COMMENT;
#endif

if (SINGLE_THREAD_P)
{
victim = tag_new_usable (_int_malloc (&main_arena, bytes));
assert (!victim || chunk_is_mmapped (mem2chunk (victim)) ||
&main_arena == arena_for_chunk (mem2chunk (victim)));
return victim;
}

arena_get (ar_ptr, bytes);

victim = _int_malloc (ar_ptr, bytes);
/* Retry with another arena only if we were able to find a usable arena
before.  */
if (!victim && ar_ptr != NULL)
{
LIBC_PROBE (memory_malloc_retry, 1, bytes);
ar_ptr = arena_get_retry (ar_ptr, bytes);
victim = _int_malloc (ar_ptr, bytes);
}

if (ar_ptr != NULL)
__libc_lock_unlock (ar_ptr->mutex);

victim = tag_new_usable (victim);

assert (!victim || chunk_is_mmapped (mem2chunk (victim)) ||
ar_ptr == arena_for_chunk (mem2chunk (victim)));
return victim;
}
```
</details>

ä»¥ä¸‹ã¯ã€å¸¸ã«è¿”ã•ã‚ŒãŸãƒã‚¤ãƒ³ã‚¿ã« `tag_new_usable` ã‚’ä»˜ã‘ã‚‹æ–¹æ³•ã«ã¤ã„ã¦ã®ã‚³ãƒ¼ãƒ‰ã§ã™:
```c
void *tag_new_usable (void *ptr)

Allocate a new random color and use it to color the user region of
a chunk; this may include data from the subsequent chunk's header
if tagging is sufficiently fine grained.  Returns PTR suitably
recolored for accessing the memory there.
```
## \_int\_malloc <a href="#int_malloc" id="int_malloc"></a>

ã“ã‚Œã¯ã€ä»–ã®ãƒ“ãƒ³ã¨ãƒˆãƒƒãƒ—ãƒãƒ£ãƒ³ã‚¯ã‚’ä½¿ç”¨ã—ã¦ãƒ¡ãƒ¢ãƒªã‚’å‰²ã‚Šå½“ã¦ã‚‹é–¢æ•°ã§ã™ã€‚

* é–‹å§‹

ã„ãã¤ã‹ã®å¤‰æ•°ã‚’å®šç¾©ã—ã€ãƒªã‚¯ã‚¨ã‚¹ãƒˆã•ã‚ŒãŸãƒ¡ãƒ¢ãƒªã‚¹ãƒšãƒ¼ã‚¹ãŒå®Ÿéš›ã«å¿…è¦ã¨ã™ã‚‹ã‚µã‚¤ã‚ºã‚’å–å¾—ã™ã‚‹ã“ã¨ã‹ã‚‰å§‹ã¾ã‚Šã¾ã™:

<details>

<summary>_int_malloc é–‹å§‹</summary>
```c
// From https://github.com/bminor/glibc/blob/f942a732d37a96217ef828116ebe64a644db18d7/malloc/malloc.c#L3847
static void *
_int_malloc (mstate av, size_t bytes)
{
INTERNAL_SIZE_T nb;               /* normalized request size */
unsigned int idx;                 /* associated bin index */
mbinptr bin;                      /* associated bin */

mchunkptr victim;                 /* inspected/selected chunk */
INTERNAL_SIZE_T size;             /* its size */
int victim_index;                 /* its bin index */

mchunkptr remainder;              /* remainder from a split */
unsigned long remainder_size;     /* its size */

unsigned int block;               /* bit map traverser */
unsigned int bit;                 /* bit map traverser */
unsigned int map;                 /* current word of binmap */

mchunkptr fwd;                    /* misc temp for linking */
mchunkptr bck;                    /* misc temp for linking */

#if USE_TCACHE
size_t tcache_unsorted_count;	    /* count of unsorted chunks processed */
#endif

/*
Convert request size to internal form by adding SIZE_SZ bytes
overhead plus possibly more to obtain necessary alignment and/or
to obtain a size of at least MINSIZE, the smallest allocatable
size. Also, checked_request2size returns false for request sizes
that are so large that they wrap around zero when padded and
aligned.
*/

nb = checked_request2size (bytes);
if (nb == 0)
{
__set_errno (ENOMEM);
return NULL;
}
```
</details>

### ã‚¢ãƒªãƒ¼ãƒŠ

ä½¿ç”¨å¯èƒ½ãªã‚¢ãƒªãƒ¼ãƒŠãŒãªã„å ´åˆã€`mmap`ã‹ã‚‰ãƒãƒ£ãƒ³ã‚¯ã‚’å–å¾—ã™ã‚‹ãŸã‚ã«`sysmalloc`ã‚’ä½¿ç”¨ã—ã¾ã™ï¼š

<details>

<summary>_int_malloc not arena</summary>
```c
// From https://github.com/bminor/glibc/blob/f942a732d37a96217ef828116ebe64a644db18d7/malloc/malloc.c#L3885C3-L3893C6
/* There are no usable arenas.  Fall back to sysmalloc to get a chunk from
mmap.  */
if (__glibc_unlikely (av == NULL))
{
void *p = sysmalloc (nb, av);
if (p != NULL)
alloc_perturb (p, bytes);
return p;
}
```
</details>

### ãƒ•ã‚¡ã‚¹ãƒˆãƒ“ãƒ³

å¿…è¦ãªã‚µã‚¤ã‚ºãŒãƒ•ã‚¡ã‚¹ãƒˆãƒ“ãƒ³ã®ã‚µã‚¤ã‚ºå†…ã«ã‚ã‚‹å ´åˆã¯ã€ãƒ•ã‚¡ã‚¹ãƒˆãƒ“ãƒ³ã‹ã‚‰ãƒãƒ£ãƒ³ã‚¯ã‚’ä½¿ç”¨ã—ã‚ˆã†ã¨ã—ã¾ã™ã€‚åŸºæœ¬çš„ã«ã€ã‚µã‚¤ã‚ºã«åŸºã¥ã„ã¦ã€æœ‰åŠ¹ãªãƒãƒ£ãƒ³ã‚¯ãŒé…ç½®ã•ã‚Œã¦ã„ã‚‹ã¹ããƒ•ã‚¡ã‚¹ãƒˆãƒ“ãƒ³ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’è¦‹ã¤ã‘ã€å­˜åœ¨ã™ã‚Œã°ãã®ã†ã¡ã®1ã¤ã‚’è¿”ã—ã¾ã™ã€‚\
ã•ã‚‰ã«ã€tcacheãŒæœ‰åŠ¹ã«ãªã£ã¦ã„ã‚‹å ´åˆã€ãã®ã‚µã‚¤ã‚ºã®tcacheãƒ“ãƒ³ã‚’ãƒ•ã‚¡ã‚¹ãƒˆãƒ“ãƒ³ã§åŸ‹ã‚ã¾ã™ã€‚

ã“ã‚Œã‚‰ã®ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚’å®Ÿè¡Œã™ã‚‹éš›ã«ã€ã“ã“ã§ã„ãã¤ã‹ã®ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒã‚§ãƒƒã‚¯ãŒå®Ÿè¡Œã•ã‚Œã¾ã™:

- ãƒãƒ£ãƒ³ã‚¯ãŒã‚¢ãƒ©ã‚¤ãƒ¡ãƒ³ãƒˆã•ã‚Œã¦ã„ãªã„å ´åˆ: `malloc(): unaligned fastbin chunk detected 2`
- ãƒ•ã‚©ãƒ¯ãƒ¼ãƒ‰ãƒãƒ£ãƒ³ã‚¯ãŒã‚¢ãƒ©ã‚¤ãƒ¡ãƒ³ãƒˆã•ã‚Œã¦ã„ãªã„å ´åˆ: `malloc(): unaligned fastbin chunk detected`
- è¿”ã•ã‚ŒãŸãƒãƒ£ãƒ³ã‚¯ãŒã€ãƒ•ã‚¡ã‚¹ãƒˆãƒ“ãƒ³å†…ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã®ãŸã‚ã«æ­£ã—ã„ã‚µã‚¤ã‚ºã§ãªã„å ´åˆ: `malloc(): memory corruption (fast)`
- tcacheã‚’åŸ‹ã‚ã‚‹ãŸã‚ã«ä½¿ç”¨ã•ã‚Œã‚‹ãƒãƒ£ãƒ³ã‚¯ãŒã‚¢ãƒ©ã‚¤ãƒ¡ãƒ³ãƒˆã•ã‚Œã¦ã„ãªã„å ´åˆ: `malloc(): unaligned fastbin chunk detected 3`

<details>

<summary>_int_malloc fast bin</summary>
```c
// From https://github.com/bminor/glibc/blob/f942a732d37a96217ef828116ebe64a644db18d7/malloc/malloc.c#L3895C3-L3967C6
/*
If the size qualifies as a fastbin, first check corresponding bin.
This code is safe to execute even if av is not yet initialized, so we
can try it without checking, which saves some time on this fast path.
*/

#define REMOVE_FB(fb, victim, pp)			\
do							\
{							\
victim = pp;					\
if (victim == NULL)				\
break;						\
pp = REVEAL_PTR (victim->fd);                                     \
if (__glibc_unlikely (pp != NULL && misaligned_chunk (pp)))       \
malloc_printerr ("malloc(): unaligned fastbin chunk detected"); \
}							\
while ((pp = catomic_compare_and_exchange_val_acq (fb, pp, victim)) \
!= victim);					\

if ((unsigned long) (nb) <= (unsigned long) (get_max_fast ()))
{
idx = fastbin_index (nb);
mfastbinptr *fb = &fastbin (av, idx);
mchunkptr pp;
victim = *fb;

if (victim != NULL)
{
if (__glibc_unlikely (misaligned_chunk (victim)))
malloc_printerr ("malloc(): unaligned fastbin chunk detected 2");

if (SINGLE_THREAD_P)
*fb = REVEAL_PTR (victim->fd);
else
REMOVE_FB (fb, pp, victim);
if (__glibc_likely (victim != NULL))
{
size_t victim_idx = fastbin_index (chunksize (victim));
if (__builtin_expect (victim_idx != idx, 0))
malloc_printerr ("malloc(): memory corruption (fast)");
check_remalloced_chunk (av, victim, nb);
#if USE_TCACHE
/* While we're here, if we see other chunks of the same size,
stash them in the tcache.  */
size_t tc_idx = csize2tidx (nb);
if (tcache != NULL && tc_idx < mp_.tcache_bins)
{
mchunkptr tc_victim;

/* While bin not empty and tcache not full, copy chunks.  */
while (tcache->counts[tc_idx] < mp_.tcache_count
&& (tc_victim = *fb) != NULL)
{
if (__glibc_unlikely (misaligned_chunk (tc_victim)))
malloc_printerr ("malloc(): unaligned fastbin chunk detected 3");
if (SINGLE_THREAD_P)
*fb = REVEAL_PTR (tc_victim->fd);
else
{
REMOVE_FB (fb, pp, tc_victim);
if (__glibc_unlikely (tc_victim == NULL))
break;
}
tcache_put (tc_victim, tc_idx);
}
}
#endif
void *p = chunk2mem (victim);
alloc_perturb (p, bytes);
return p;
}
}
}
```
</details>

### Small Bin

ã‚³ãƒ¡ãƒ³ãƒˆã§ç¤ºã•ã‚Œã¦ã„ã‚‹ã‚ˆã†ã«ã€small bin ã¯1ã¤ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã”ã¨ã«1ã¤ã®ã‚µã‚¤ã‚ºã‚’ä¿æŒã—ã¦ã„ã‚‹ãŸã‚ã€æœ‰åŠ¹ãªãƒãƒ£ãƒ³ã‚¯ãŒåˆ©ç”¨å¯èƒ½ã‹ã©ã†ã‹ã‚’ãƒã‚§ãƒƒã‚¯ã™ã‚‹ã®ã¯éå¸¸ã«é«˜é€Ÿã§ã™ã€‚ãã®ãŸã‚ã€fast bin ã®å¾Œã«ã¯ small bin ãŒãƒã‚§ãƒƒã‚¯ã•ã‚Œã¾ã™ã€‚

æœ€åˆã®ãƒã‚§ãƒƒã‚¯ã¯ã€ãƒªã‚¯ã‚¨ã‚¹ãƒˆã•ã‚ŒãŸã‚µã‚¤ã‚ºãŒ small bin ã®ç¯„å›²å†…ã«ã‚ã‚‹ã‹ã©ã†ã‹ã‚’è¦‹ã¤ã‘ã‚‹ã“ã¨ã§ã™ã€‚ãã®å ´åˆã€small bin å†…ã®å¯¾å¿œã™ã‚‹ **index** ã‚’å–å¾—ã—ã€**åˆ©ç”¨å¯èƒ½ãªãƒãƒ£ãƒ³ã‚¯** ãŒã‚ã‚‹ã‹ã©ã†ã‹ã‚’ç¢ºèªã—ã¾ã™ã€‚

æ¬¡ã«ã€ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒã‚§ãƒƒã‚¯ãŒè¡Œã‚ã‚Œã¾ã™:

* &#x20;`victim->bk->fd = victim` ãŒè¡Œã‚ã‚Œã¾ã™ã€‚ä¸¡æ–¹ã®ãƒãƒ£ãƒ³ã‚¯ãŒæ­£ã—ããƒªãƒ³ã‚¯ã•ã‚Œã¦ã„ã‚‹ã‹ã©ã†ã‹ã‚’ç¢ºèªã—ã¾ã™ã€‚

ãã®å ´åˆã€ãƒãƒ£ãƒ³ã‚¯ã¯ **`inuse` ãƒ“ãƒƒãƒˆã‚’å–å¾—**ã—ã€ãƒ€ãƒ–ãƒ«ãƒªãƒ³ã‚¯ãƒªã‚¹ãƒˆãŒä¿®æ­£ã•ã‚Œã‚‹ãŸã‚ã€ã“ã®ãƒãƒ£ãƒ³ã‚¯ã¯ãã“ã‹ã‚‰æ¶ˆãˆã¾ã™ï¼ˆä½¿ç”¨ã•ã‚Œã‚‹ãŸã‚ï¼‰ã€å¿…è¦ã«å¿œã˜ã¦ãƒ¡ã‚¤ãƒ³ã‚¢ãƒªãƒ¼ãƒŠä»¥å¤–ã®ãƒ“ãƒƒãƒˆãŒè¨­å®šã•ã‚Œã¾ã™ã€‚

æœ€å¾Œã«ã€ãƒªã‚¯ã‚¨ã‚¹ãƒˆã•ã‚ŒãŸã‚µã‚¤ã‚ºã® tcache ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’ä»–ã® small bin å†…ã®ãƒãƒ£ãƒ³ã‚¯ã§åŸ‹ã‚ã¾ã™ï¼ˆã‚ã‚Œã°ï¼‰ã€‚
```c
// From https://github.com/bminor/glibc/blob/f942a732d37a96217ef828116ebe64a644db18d7/malloc/malloc.c#L3895C3-L3967C6

/*
If a small request, check regular bin.  Since these "smallbins"
hold one size each, no searching within bins is necessary.
(For a large request, we need to wait until unsorted chunks are
processed to find best fit. But for small ones, fits are exact
anyway, so we can check now, which is faster.)
*/

if (in_smallbin_range (nb))
{
idx = smallbin_index (nb);
bin = bin_at (av, idx);

if ((victim = last (bin)) != bin)
{
bck = victim->bk;
if (__glibc_unlikely (bck->fd != victim))
malloc_printerr ("malloc(): smallbin double linked list corrupted");
set_inuse_bit_at_offset (victim, nb);
bin->bk = bck;
bck->fd = bin;

if (av != &main_arena)
set_non_main_arena (victim);
check_malloced_chunk (av, victim, nb);
#if USE_TCACHE
/* While we're here, if we see other chunks of the same size,
stash them in the tcache.  */
size_t tc_idx = csize2tidx (nb);
if (tcache != NULL && tc_idx < mp_.tcache_bins)
{
mchunkptr tc_victim;

/* While bin not empty and tcache not full, copy chunks over.  */
while (tcache->counts[tc_idx] < mp_.tcache_count
&& (tc_victim = last (bin)) != bin)
{
if (tc_victim != 0)
{
bck = tc_victim->bk;
set_inuse_bit_at_offset (tc_victim, nb);
if (av != &main_arena)
set_non_main_arena (tc_victim);
bin->bk = bck;
bck->fd = bin;

tcache_put (tc_victim, tc_idx);
}
}
}
#endif
void *p = chunk2mem (victim);
alloc_perturb (p, bytes);
return p;
}
}
```
### malloc\_consolidate

ã‚‚ã—å°ã•ãªãƒãƒ£ãƒ³ã‚¯ã§ãªã„å ´åˆã€ãã‚Œã¯å¤§ããªãƒãƒ£ãƒ³ã‚¯ã§ã‚ã‚Šã€ã“ã®å ´åˆã«ã¯**`malloc_consolidate`**ãŒãƒ¡ãƒ¢ãƒªã®æ–­ç‰‡åŒ–ã‚’é¿ã‘ã‚‹ãŸã‚ã«å‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚

<details>

<summary>malloc_consolidateã®å‘¼ã³å‡ºã—</summary>
```c
/*
If this is a large request, consolidate fastbins before continuing.
While it might look excessive to kill all fastbins before
even seeing if there is space available, this avoids
fragmentation problems normally associated with fastbins.
Also, in practice, programs tend to have runs of either small or
large requests, but less often mixtures, so consolidation is not
invoked all that often in most programs. And the programs that
it is called frequently in otherwise tend to fragment.
*/

else
{
idx = largebin_index (nb);
if (atomic_load_relaxed (&av->have_fastchunks))
malloc_consolidate (av);
}

```
</details>

mallocã®consolidateé–¢æ•°ã¯ã€åŸºæœ¬çš„ã«ã¯é«˜é€Ÿãƒ“ãƒ³ã‹ã‚‰ãƒãƒ£ãƒ³ã‚¯ã‚’å‰Šé™¤ã—ã€ãã‚Œã‚‰ã‚’unsortedãƒ“ãƒ³ã«é…ç½®ã—ã¾ã™ã€‚æ¬¡ã®mallocã®å¾Œã€ã“ã‚Œã‚‰ã®ãƒãƒ£ãƒ³ã‚¯ã¯ãã‚Œãã‚Œã®å°ã•ãª/é«˜é€Ÿãƒ“ãƒ³ã«æ•´ç†ã•ã‚Œã¾ã™ã€‚

ã“ã‚Œã‚‰ã®ãƒãƒ£ãƒ³ã‚¯ã‚’å‰Šé™¤ã™ã‚‹éš›ã«ã€ä½¿ç”¨ã•ã‚Œã¦ã„ãªã„å‰å¾Œã®ãƒãƒ£ãƒ³ã‚¯ãŒè¦‹ã¤ã‹ã£ãŸå ´åˆã€ãã‚Œã‚‰ã¯**ãƒªãƒ³ã‚¯è§£é™¤ãŠã‚ˆã³ãƒãƒ¼ã‚¸**ã•ã‚Œã€æœ€çµ‚çš„ãªãƒãƒ£ãƒ³ã‚¯ãŒ**unsorted**ãƒ“ãƒ³ã«é…ç½®ã•ã‚Œã‚‹å‰ã«è¡Œã‚ã‚Œã¾ã™ã€‚

å„é«˜é€Ÿãƒ“ãƒ³ã®ãƒãƒ£ãƒ³ã‚¯ã«å¯¾ã—ã¦ã€ã„ãã¤ã‹ã®ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒã‚§ãƒƒã‚¯ãŒå®Ÿè¡Œã•ã‚Œã¾ã™:

- ãƒãƒ£ãƒ³ã‚¯ãŒã‚¢ãƒ©ã‚¤ãƒ³ã•ã‚Œã¦ã„ãªã„å ´åˆã«ãƒˆãƒªã‚¬ãƒ¼: `malloc_consolidate(): unaligned fastbin chunk detected`
- ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã«ã‚ˆã£ã¦ã‚µã‚¤ã‚ºãŒç•°ãªã‚‹å ´åˆã«ãƒˆãƒªã‚¬ãƒ¼: `malloc_consolidate(): invalid chunk size`
- å‰ã®ãƒãƒ£ãƒ³ã‚¯ãŒä½¿ç”¨ã•ã‚Œã¦ãŠã‚‰ãšã€å‰ã®ãƒãƒ£ãƒ³ã‚¯ã®ã‚µã‚¤ã‚ºãŒ`prev_chunk`ã§æŒ‡å®šã•ã‚ŒãŸã‚µã‚¤ã‚ºã¨ç•°ãªã‚‹å ´åˆ: `corrupted size vs. prev_size in fastbins`

<details>

<summary>malloc_consolidateé–¢æ•°</summary>
```c
// https://github.com/bminor/glibc/blob/f942a732d37a96217ef828116ebe64a644db18d7/malloc/malloc.c#L4810C1-L4905C2

static void malloc_consolidate(mstate av)
{
mfastbinptr*    fb;                 /* current fastbin being consolidated */
mfastbinptr*    maxfb;              /* last fastbin (for loop control) */
mchunkptr       p;                  /* current chunk being consolidated */
mchunkptr       nextp;              /* next chunk to consolidate */
mchunkptr       unsorted_bin;       /* bin header */
mchunkptr       first_unsorted;     /* chunk to link to */

/* These have same use as in free() */
mchunkptr       nextchunk;
INTERNAL_SIZE_T size;
INTERNAL_SIZE_T nextsize;
INTERNAL_SIZE_T prevsize;
int             nextinuse;

atomic_store_relaxed (&av->have_fastchunks, false);

unsorted_bin = unsorted_chunks(av);

/*
Remove each chunk from fast bin and consolidate it, placing it
then in unsorted bin. Among other reasons for doing this,
placing in unsorted bin avoids needing to calculate actual bins
until malloc is sure that chunks aren't immediately going to be
reused anyway.
*/

maxfb = &fastbin (av, NFASTBINS - 1);
fb = &fastbin (av, 0);
do {
p = atomic_exchange_acquire (fb, NULL);
if (p != 0) {
do {
{
if (__glibc_unlikely (misaligned_chunk (p)))
malloc_printerr ("malloc_consolidate(): "
"unaligned fastbin chunk detected");

unsigned int idx = fastbin_index (chunksize (p));
if ((&fastbin (av, idx)) != fb)
malloc_printerr ("malloc_consolidate(): invalid chunk size");
}

check_inuse_chunk(av, p);
nextp = REVEAL_PTR (p->fd);

/* Slightly streamlined version of consolidation code in free() */
size = chunksize (p);
nextchunk = chunk_at_offset(p, size);
nextsize = chunksize(nextchunk);

if (!prev_inuse(p)) {
prevsize = prev_size (p);
size += prevsize;
p = chunk_at_offset(p, -((long) prevsize));
if (__glibc_unlikely (chunksize(p) != prevsize))
malloc_printerr ("corrupted size vs. prev_size in fastbins");
unlink_chunk (av, p);
}

if (nextchunk != av->top) {
nextinuse = inuse_bit_at_offset(nextchunk, nextsize);

if (!nextinuse) {
size += nextsize;
unlink_chunk (av, nextchunk);
} else
clear_inuse_bit_at_offset(nextchunk, 0);

first_unsorted = unsorted_bin->fd;
unsorted_bin->fd = p;
first_unsorted->bk = p;

if (!in_smallbin_range (size)) {
p->fd_nextsize = NULL;
p->bk_nextsize = NULL;
}

set_head(p, size | PREV_INUSE);
p->bk = unsorted_bin;
p->fd = first_unsorted;
set_foot(p, size);
}

else {
size += nextsize;
set_head(p, size | PREV_INUSE);
av->top = p;
}

} while ( (p = nextp) != 0);

}
} while (fb++ != maxfb);
}
```
</details>

### Unsorted bin

æ½œåœ¨çš„ãªæœ‰åŠ¹ãªãƒãƒ£ãƒ³ã‚¯ã‚’ä½¿ç”¨ã™ã‚‹ãŸã‚ã«ã€ã‚¢ãƒ³ã‚½ãƒ¼ãƒˆã•ã‚ŒãŸãƒ“ãƒ³ã‚’ãƒã‚§ãƒƒã‚¯ã™ã‚‹æ™‚é–“ã§ã™ã€‚

#### é–‹å§‹

ã“ã‚Œã¯ã€`bk`ã®æ–¹å‘ã«ã‚¢ãƒ³ã‚½ãƒ¼ãƒˆã•ã‚ŒãŸãƒ“ãƒ³ã‚’ãƒˆãƒ©ãƒãƒ¼ã‚¹ã™ã‚‹å¤§ããªforãƒ«ãƒ¼ãƒ—ã§å§‹ã¾ã‚Šã€`while ((victim = unsorted_chunks (av)->bk) != unsorted_chunks (av))` ã¾ã§åˆ°é”ã—ã¾ã™ã€‚

ã•ã‚‰ã«ã€æ–°ã—ã„ãƒãƒ£ãƒ³ã‚¯ãŒè€ƒæ…®ã•ã‚Œã‚‹ãŸã³ã«ã„ãã¤ã‹ã®ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒã‚§ãƒƒã‚¯ãŒå®Ÿè¡Œã•ã‚Œã¾ã™:

- ãƒãƒ£ãƒ³ã‚¯ã®ã‚µã‚¤ã‚ºãŒå¥‡å¦™ãªå ´åˆï¼ˆå°ã•ã™ãã‚‹ã‹å¤§ãã™ãã‚‹å ´åˆï¼‰: `malloc(): invalid size (unsorted)`
- æ¬¡ã®ãƒãƒ£ãƒ³ã‚¯ã®ã‚µã‚¤ã‚ºãŒå¥‡å¦™ãªå ´åˆï¼ˆå°ã•ã™ãã‚‹ã‹å¤§ãã™ãã‚‹å ´åˆï¼‰: `malloc(): invalid next size (unsorted)`
- æ¬¡ã®ãƒãƒ£ãƒ³ã‚¯ã«ã‚ˆã£ã¦ç¤ºã•ã‚Œã‚‹å‰ã®ã‚µã‚¤ã‚ºãŒãƒãƒ£ãƒ³ã‚¯ã®ã‚µã‚¤ã‚ºã¨ç•°ãªã‚‹å ´åˆ: `malloc(): mismatching next->prev_size (unsorted)`
- `victim->bck->fd == victim` ã¾ãŸã¯ `victim->fd == av`ï¼ˆã‚¢ãƒªãƒ¼ãƒŠï¼‰ã§ãªã„å ´åˆ: `malloc(): unsorted double linked list corrupted`
- å¸¸ã«æœ€å¾Œã®ã‚‚ã®ã‚’ãƒã‚§ãƒƒã‚¯ã—ã¦ã„ã‚‹ãŸã‚ã€ãã® `fd` ã¯å¸¸ã«ã‚¢ãƒªãƒ¼ãƒŠæ§‹é€ ä½“ã‚’æŒ‡ã—ã¦ã„ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚
- æ¬¡ã®ãƒãƒ£ãƒ³ã‚¯ãŒå‰ã®ãƒãƒ£ãƒ³ã‚¯ãŒä½¿ç”¨ä¸­ã§ã‚ã‚‹ã“ã¨ã‚’ç¤ºã—ã¦ã„ãªã„å ´åˆ: `malloc(): invalid next->prev_inuse (unsorted)`

<details>

<summary><code>_int_malloc</code> ã‚¢ãƒ³ã‚½ãƒ¼ãƒˆã•ã‚ŒãŸãƒ“ãƒ³ã®é–‹å§‹</summary>
```c
/*
Process recently freed or remaindered chunks, taking one only if
it is exact fit, or, if this a small request, the chunk is remainder from
the most recent non-exact fit.  Place other traversed chunks in
bins.  Note that this step is the only place in any routine where
chunks are placed in bins.

The outer loop here is needed because we might not realize until
near the end of malloc that we should have consolidated, so must
do so and retry. This happens at most once, and only when we would
otherwise need to expand memory to service a "small" request.
*/

#if USE_TCACHE
INTERNAL_SIZE_T tcache_nb = 0;
size_t tc_idx = csize2tidx (nb);
if (tcache != NULL && tc_idx < mp_.tcache_bins)
tcache_nb = nb;
int return_cached = 0;

tcache_unsorted_count = 0;
#endif

for (;; )
{
int iters = 0;
while ((victim = unsorted_chunks (av)->bk) != unsorted_chunks (av))
{
bck = victim->bk;
size = chunksize (victim);
mchunkptr next = chunk_at_offset (victim, size);

if (__glibc_unlikely (size <= CHUNK_HDR_SZ)
|| __glibc_unlikely (size > av->system_mem))
malloc_printerr ("malloc(): invalid size (unsorted)");
if (__glibc_unlikely (chunksize_nomask (next) < CHUNK_HDR_SZ)
|| __glibc_unlikely (chunksize_nomask (next) > av->system_mem))
malloc_printerr ("malloc(): invalid next size (unsorted)");
if (__glibc_unlikely ((prev_size (next) & ~(SIZE_BITS)) != size))
malloc_printerr ("malloc(): mismatching next->prev_size (unsorted)");
if (__glibc_unlikely (bck->fd != victim)
|| __glibc_unlikely (victim->fd != unsorted_chunks (av)))
malloc_printerr ("malloc(): unsorted double linked list corrupted");
if (__glibc_unlikely (prev_inuse (next)))
malloc_printerr ("malloc(): invalid next->prev_inuse (unsorted)");

```
#### ã‚‚ã— `in_smallbin_range` ãªã‚‰

ã‚‚ã—ãƒãƒ£ãƒ³ã‚¯ãŒè¦æ±‚ã•ã‚ŒãŸã‚µã‚¤ã‚ºã‚ˆã‚Šã‚‚å¤§ãã„å ´åˆã¯ãã‚Œã‚’ä½¿ç”¨ã—ã€ãƒãƒ£ãƒ³ã‚¯ã®æ®‹ã‚Šã®ã‚¹ãƒšãƒ¼ã‚¹ã‚’æœªæ•´åˆ—ãƒªã‚¹ãƒˆã«è¨­å®šã—ã€`last_remainder` ã‚’æ›´æ–°ã—ã¾ã™ã€‚

</details>
```c
// From https://github.com/bminor/glibc/blob/master/malloc/malloc.c#L4090C11-L4124C14

/*
If a small request, try to use last remainder if it is the
only chunk in unsorted bin.  This helps promote locality for
runs of consecutive small requests. This is the only
exception to best-fit, and applies only when there is
no exact fit for a small chunk.
*/

if (in_smallbin_range (nb) &&
bck == unsorted_chunks (av) &&
victim == av->last_remainder &&
(unsigned long) (size) > (unsigned long) (nb + MINSIZE))
{
/* split and reattach remainder */
remainder_size = size - nb;
remainder = chunk_at_offset (victim, nb);
unsorted_chunks (av)->bk = unsorted_chunks (av)->fd = remainder;
av->last_remainder = remainder;
remainder->bk = remainder->fd = unsorted_chunks (av);
if (!in_smallbin_range (remainder_size))
{
remainder->fd_nextsize = NULL;
remainder->bk_nextsize = NULL;
}

set_head (victim, nb | PREV_INUSE |
(av != &main_arena ? NON_MAIN_ARENA : 0));
set_head (remainder, remainder_size | PREV_INUSE);
set_foot (remainder, remainder_size);

check_malloced_chunk (av, victim, nb);
void *p = chunk2mem (victim);
alloc_perturb (p, bytes);
return p;
}

```
</details>

æˆåŠŸã—ãŸå ´åˆã¯ã€ãƒãƒ£ãƒ³ã‚¯ã‚’è¿”ã—ã¦çµ‚äº†ã—ã€ãã†ã§ãªã„å ´åˆã¯ã€é–¢æ•°ã®å®Ÿè¡Œã‚’ç¶šè¡Œã—ã¾ã™...

#### ã‚µã‚¤ã‚ºãŒç­‰ã—ã„å ´åˆ

è¦æ±‚ã•ã‚ŒãŸã‚µã‚¤ã‚ºãŒãƒãƒ£ãƒ³ã‚¯ã®ã‚µã‚¤ã‚ºã¨å®Œå…¨ã«ä¸€è‡´ã™ã‚‹å ´åˆã€æ¬¡ã®æ‰‹é †ã‚’å®Ÿè¡Œã—ã¾ã™:

- tcache ãŒæº€æ¯ã§ãªã„å ´åˆã€tcache ã«è¿½åŠ ã—ã¦ã€tcache ã«ä½¿ç”¨å¯èƒ½ãªãƒãƒ£ãƒ³ã‚¯ãŒã‚ã‚‹ã“ã¨ã‚’ç¤ºã—ç¶šã‘ã¾ã™
- tcache ãŒæº€æ¯ã®å ´åˆã€ãã®ã¾ã¾ä½¿ç”¨ã—ã¦è¿”ã—ã¾ã™

<details>

<summary><code>_int_malloc</code> unsorted bin equal size</summary>
```c
// From https://github.com/bminor/glibc/blob/master/malloc/malloc.c#L4126C11-L4157C14

/* remove from unsorted list */
unsorted_chunks (av)->bk = bck;
bck->fd = unsorted_chunks (av);

/* Take now instead of binning if exact fit */

if (size == nb)
{
set_inuse_bit_at_offset (victim, size);
if (av != &main_arena)
set_non_main_arena (victim);
#if USE_TCACHE
/* Fill cache first, return to user only if cache fills.
We may return one of these chunks later.  */
if (tcache_nb > 0
&& tcache->counts[tc_idx] < mp_.tcache_count)
{
tcache_put (victim, tc_idx);
return_cached = 1;
continue;
}
else
{
#endif
check_malloced_chunk (av, victim, nb);
void *p = chunk2mem (victim);
alloc_perturb (p, bytes);
return p;
#if USE_TCACHE
}
#endif
}

```
</details>

ãƒãƒ£ãƒ³ã‚¯ãŒè¿”ã•ã‚Œãªã‹ã£ãŸã‚Šã€tcache ã«è¿½åŠ ã•ã‚Œãªã‹ã£ãŸå ´åˆã¯ã€ã‚³ãƒ¼ãƒ‰ã‚’ç¶šè¡Œã—ã¾ã™...

#### ãƒã‚¤ãƒŠãƒªã«ãƒãƒ£ãƒ³ã‚¯ã‚’é…ç½®ã™ã‚‹

ãƒã‚§ãƒƒã‚¯ã•ã‚ŒãŸãƒãƒ£ãƒ³ã‚¯ã‚’ã€ãƒãƒ£ãƒ³ã‚¯ã®ã‚µã‚¤ã‚ºã«å¿œã˜ã¦ small bin ã¾ãŸã¯ large bin ã«æ ¼ç´ã—ã¾ã™ï¼ˆlarge bin ã‚’é©åˆ‡ã«æ•´ç†ã—ã¾ã™ï¼‰ã€‚

å¤§ããª bin ã®ãƒ€ãƒ–ãƒ«ãƒªãƒ³ã‚¯ãƒªã‚¹ãƒˆãŒç ´æã—ã¦ã„ãªã„ã“ã¨ã‚’ç¢ºèªã™ã‚‹ãŸã‚ã«ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒã‚§ãƒƒã‚¯ãŒå®Ÿè¡Œã•ã‚Œã¾ã™:

* ã‚‚ã— `fwd->bk_nextsize->fd_nextsize != fwd` ãªã‚‰ã°: `malloc(): largebin double linked list corrupted (nextsize)`
* ã‚‚ã— `fwd->bk->fd != fwd` ãªã‚‰ã°: `malloc(): largebin double linked list corrupted (bk)`

<details>

<summary><code>_int_malloc</code> ãƒã‚¤ãƒŠãƒªã«ãƒãƒ£ãƒ³ã‚¯ã‚’é…ç½®ã™ã‚‹</summary>
```c
/* place chunk in bin */

if (in_smallbin_range (size))
{
victim_index = smallbin_index (size);
bck = bin_at (av, victim_index);
fwd = bck->fd;
}
else
{
victim_index = largebin_index (size);
bck = bin_at (av, victim_index);
fwd = bck->fd;

/* maintain large bins in sorted order */
if (fwd != bck)
{
/* Or with inuse bit to speed comparisons */
size |= PREV_INUSE;
/* if smaller than smallest, bypass loop below */
assert (chunk_main_arena (bck->bk));
if ((unsigned long) (size)
< (unsigned long) chunksize_nomask (bck->bk))
{
fwd = bck;
bck = bck->bk;

victim->fd_nextsize = fwd->fd;
victim->bk_nextsize = fwd->fd->bk_nextsize;
fwd->fd->bk_nextsize = victim->bk_nextsize->fd_nextsize = victim;
}
else
{
assert (chunk_main_arena (fwd));
while ((unsigned long) size < chunksize_nomask (fwd))
{
fwd = fwd->fd_nextsize;
assert (chunk_main_arena (fwd));
}

if ((unsigned long) size
== (unsigned long) chunksize_nomask (fwd))
/* Always insert in the second position.  */
fwd = fwd->fd;
else
{
victim->fd_nextsize = fwd;
victim->bk_nextsize = fwd->bk_nextsize;
if (__glibc_unlikely (fwd->bk_nextsize->fd_nextsize != fwd))
malloc_printerr ("malloc(): largebin double linked list corrupted (nextsize)");
fwd->bk_nextsize = victim;
victim->bk_nextsize->fd_nextsize = victim;
}
bck = fwd->bk;
if (bck->fd != fwd)
malloc_printerr ("malloc(): largebin double linked list corrupted (bk)");
}
}
else
victim->fd_nextsize = victim->bk_nextsize = victim;
}

mark_bin (av, victim_index);
victim->bk = bck;
victim->fd = fwd;
fwd->bk = victim;
bck->fd = victim;
```
</details>

#### `_int_malloc`ã®åˆ¶é™

ã“ã®æ™‚ç‚¹ã§ã€ä½¿ç”¨å¯èƒ½ãªtcacheãƒãƒ£ãƒ³ã‚¯ãŒã‚ã‚‹å ´åˆã‹ã¤åˆ¶é™ã«é”ã—ãŸå ´åˆã¯ã€å˜ã«**tcacheãƒãƒ£ãƒ³ã‚¯ã‚’è¿”ã—ã¾ã™**ã€‚

ã•ã‚‰ã«ã€**MAX\_ITERS**ã«é”ã—ãŸå ´åˆã¯ã€ãƒ«ãƒ¼ãƒ—ã‹ã‚‰æŠœã‘ã¦ç•°ãªã‚‹æ–¹æ³•ã§ï¼ˆãƒˆãƒƒãƒ—ãƒãƒ£ãƒ³ã‚¯ã‹ã‚‰ï¼‰ãƒãƒ£ãƒ³ã‚¯ã‚’å–å¾—ã—ã¾ã™ã€‚

`return_cached`ãŒè¨­å®šã•ã‚Œã¦ã„ã‚‹å ´åˆã¯ã€ã‚ˆã‚Šå¤§ããªæ¤œç´¢ã‚’é¿ã‘ã‚‹ãŸã‚ã«tcacheã‹ã‚‰ãƒãƒ£ãƒ³ã‚¯ã‚’è¿”ã—ã¾ã™ã€‚

<details>

<summary><code>_int_malloc</code>ã®åˆ¶é™</summary>
```c
// From https://github.com/bminor/glibc/blob/master/malloc/malloc.c#L4227C1-L4250C7

#if USE_TCACHE
/* If we've processed as many chunks as we're allowed while
filling the cache, return one of the cached ones.  */
++tcache_unsorted_count;
if (return_cached
&& mp_.tcache_unsorted_limit > 0
&& tcache_unsorted_count > mp_.tcache_unsorted_limit)
{
return tcache_get (tc_idx);
}
#endif

#define MAX_ITERS       10000
if (++iters >= MAX_ITERS)
break;
}

#if USE_TCACHE
/* If all the small chunks we found ended up cached, return one now.  */
if (return_cached)
{
return tcache_get (tc_idx);
}
#endif
```
</details>

ã‚‚ã—åˆ¶é™ã«é”ã—ã¦ã„ãªã„å ´åˆã€ã‚³ãƒ¼ãƒ‰ã‚’ç¶šè¡Œã—ã¾ã™...

### ãƒ©ãƒ¼ã‚¸ãƒ“ãƒ³ï¼ˆã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹åˆ¥ï¼‰

ãƒªã‚¯ã‚¨ã‚¹ãƒˆãŒå¤§ãã„å ´åˆï¼ˆsmall bin ã«ãªã„ï¼‰ã‹ã¤ã¾ã ãƒãƒ£ãƒ³ã‚¯ã‚’è¿”ã—ã¦ã„ãªã„å ´åˆã¯ã€è¦æ±‚ã•ã‚ŒãŸã‚µã‚¤ã‚ºã®**ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹**ã‚’**ãƒ©ãƒ¼ã‚¸ãƒ“ãƒ³**ã§å–å¾—ã—ã€ã“ã®ãƒ“ãƒ³å†…ã®**æœ€å¤§ã®ãƒãƒ£ãƒ³ã‚¯ãŒè¦æ±‚ã•ã‚ŒãŸã‚µã‚¤ã‚ºã‚ˆã‚Šã‚‚å¤§ãã„**ã‹ã©ã†ã‹ã‚’ç¢ºèªã—ã€ãã®å ´åˆã¯è¦æ±‚ã•ã‚ŒãŸã‚µã‚¤ã‚ºã«ä½¿ç”¨ã§ãã‚‹**æœ€å°ã®ãƒãƒ£ãƒ³ã‚¯ã‚’è¦‹ã¤ã‘ã¾ã™**ã€‚

æœ€çµ‚çš„ã«ä½¿ç”¨ã•ã‚ŒãŸãƒãƒ£ãƒ³ã‚¯ã‹ã‚‰ã®ä½™ç™½ãŒæ–°ã—ã„ãƒãƒ£ãƒ³ã‚¯ã«ãªã‚Šå¾—ã‚‹å ´åˆã¯ã€ãã‚Œã‚’æœªæ•´åˆ—ãƒ“ãƒ³ã«è¿½åŠ ã—ã€lsast\_reminder ãŒæ›´æ–°ã•ã‚Œã¾ã™ã€‚

æœªæ•´åˆ—ãƒ“ãƒ³ã«ãƒªãƒã‚¤ãƒ³ãƒ€ã‚’è¿½åŠ ã™ã‚‹éš›ã«ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒã‚§ãƒƒã‚¯ãŒè¡Œã‚ã‚Œã¾ã™ï¼š

- `bck->fd-> bk != bck`: `malloc(): corrupted unsorted chunks`

<details>

<summary><code>_int_malloc</code> ãƒ©ãƒ¼ã‚¸ãƒ“ãƒ³ï¼ˆã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹åˆ¥ï¼‰</summary>
```c
// From https://github.com/bminor/glibc/blob/master/malloc/malloc.c#L4252C7-L4317C10

/*
If a large request, scan through the chunks of current bin in
sorted order to find smallest that fits.  Use the skip list for this.
*/

if (!in_smallbin_range (nb))
{
bin = bin_at (av, idx);

/* skip scan if empty or largest chunk is too small */
if ((victim = first (bin)) != bin
&& (unsigned long) chunksize_nomask (victim)
>= (unsigned long) (nb))
{
victim = victim->bk_nextsize;
while (((unsigned long) (size = chunksize (victim)) <
(unsigned long) (nb)))
victim = victim->bk_nextsize;

/* Avoid removing the first entry for a size so that the skip
list does not have to be rerouted.  */
if (victim != last (bin)
&& chunksize_nomask (victim)
== chunksize_nomask (victim->fd))
victim = victim->fd;

remainder_size = size - nb;
unlink_chunk (av, victim);

/* Exhaust */
if (remainder_size < MINSIZE)
{
set_inuse_bit_at_offset (victim, size);
if (av != &main_arena)
set_non_main_arena (victim);
}
/* Split */
else
{
remainder = chunk_at_offset (victim, nb);
/* We cannot assume the unsorted list is empty and therefore
have to perform a complete insert here.  */
bck = unsorted_chunks (av);
fwd = bck->fd;
if (__glibc_unlikely (fwd->bk != bck))
malloc_printerr ("malloc(): corrupted unsorted chunks");
last_re->bk = bck;
remainder->fd = fwd;
bck->fd = remainder;
fwd->bk = remainder;
if (!in_smallbin_range (remainder_size))
{
remainder->fd_nextsize = NULL;
remainder->bk_nextsize = NULL;
}
set_head (victim, nb | PREV_INUSE |
(av != &main_arena ? NON_MAIN_ARENA : 0));
set_head (remainder, remainder_size | PREV_INUSE);
set_foot (remainder, remainder_size);
}
check_malloced_chunk (av, victim, nb);
void *p = chunk2mem (victim);
alloc_perturb (p, bytes);
return p;
}
}
```
</details>

é©åˆ‡ãªãƒãƒ£ãƒ³ã‚¯ãŒè¦‹ã¤ã‹ã‚‰ãªã„å ´åˆã¯ã€æ¬¡ã®æ‰‹é †ã‚’å®Ÿè¡Œã—ã¾ã™

### ãƒ©ãƒ¼ã‚¸ãƒ“ãƒ³ï¼ˆæ¬¡ã®å¤§ãã„ã‚‚ã®ï¼‰

æ­£ç¢ºãªãƒ©ãƒ¼ã‚¸ãƒ“ãƒ³ã«ä½¿ç”¨å¯èƒ½ãªãƒãƒ£ãƒ³ã‚¯ãŒè¦‹ã¤ã‹ã‚‰ãªã„å ´åˆã¯ã€æ¬¡ã®ãƒ©ãƒ¼ã‚¸ãƒ“ãƒ³å…¨ã¦ã‚’ãƒ«ãƒ¼ãƒ—ã—ã¦ï¼ˆç›´ã¡ã«å¤§ãã„ã‚‚ã®ã‹ã‚‰é–‹å§‹ã—ã¦ï¼‰è¦‹ã¤ã‹ã‚‹ã¾ã§ç¶šã‘ã¾ã™ã€‚

åˆ†å‰²ã•ã‚ŒãŸãƒãƒ£ãƒ³ã‚¯ã®æ®‹ã‚Šã¯ã‚¢ãƒ³ã‚½ãƒ¼ãƒˆãƒ“ãƒ³ã«è¿½åŠ ã•ã‚Œã€last\_reminder ãŒæ›´æ–°ã•ã‚Œã€åŒã˜ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒã‚§ãƒƒã‚¯ãŒå®Ÿè¡Œã•ã‚Œã¾ã™:

* `bck->fd-> bk != bck`: `malloc(): corrupted unsorted chunks2`

<details>

<summary><code>_int_malloc</code> ãƒ©ãƒ¼ã‚¸ãƒ“ãƒ³ï¼ˆæ¬¡ã®å¤§ãã„ã‚‚ã®ï¼‰</summary>
```c
// From https://github.com/bminor/glibc/blob/master/malloc/malloc.c#L4319C7-L4425C10

/*
Search for a chunk by scanning bins, starting with next largest
bin. This search is strictly by best-fit; i.e., the smallest
(with ties going to approximately the least recently used) chunk
that fits is selected.

The bitmap avoids needing to check that most blocks are nonempty.
The particular case of skipping all bins during warm-up phases
when no chunks have been returned yet is faster than it might look.
*/

++idx;
bin = bin_at (av, idx);
block = idx2block (idx);
map = av->binmap[block];
bit = idx2bit (idx);

for (;; )
{
/* Skip rest of block if there are no more set bits in this block.  */
if (bit > map || bit == 0)
{
do
{
if (++block >= BINMAPSIZE) /* out of bins */
goto use_top;
}
while ((map = av->binmap[block]) == 0);

bin = bin_at (av, (block << BINMAPSHIFT));
bit = 1;
}

/* Advance to bin with set bit. There must be one. */
while ((bit & map) == 0)
{
bin = next_bin (bin);
bit <<= 1;
assert (bit != 0);
}

/* Inspect the bin. It is likely to be non-empty */
victim = last (bin);

/*  If a false alarm (empty bin), clear the bit. */
if (victim == bin)
{
av->binmap[block] = map &= ~bit; /* Write through */
bin = next_bin (bin);
bit <<= 1;
}

else
{
size = chunksize (victim);

/*  We know the first chunk in this bin is big enough to use. */
assert ((unsigned long) (size) >= (unsigned long) (nb));

remainder_size = size - nb;

/* unlink */
unlink_chunk (av, victim);

/* Exhaust */
if (remainder_size < MINSIZE)
{
set_inuse_bit_at_offset (victim, size);
if (av != &main_arena)
set_non_main_arena (victim);
}

/* Split */
else
{
remainder = chunk_at_offset (victim, nb);

/* We cannot assume the unsorted list is empty and therefore
have to perform a complete insert here.  */
bck = unsorted_chunks (av);
fwd = bck->fd;
if (__glibc_unlikely (fwd->bk != bck))
malloc_printerr ("malloc(): corrupted unsorted chunks 2");
remainder->bk = bck;
remainder->fd = fwd;
bck->fd = remainder;
fwd->bk = remainder;

/* advertise as last remainder */
if (in_smallbin_range (nb))
av->last_remainder = remainder;
if (!in_smallbin_range (remainder_size))
{
remainder->fd_nextsize = NULL;
remainder->bk_nextsize = NULL;
}
set_head (victim, nb | PREV_INUSE |
(av != &main_arena ? NON_MAIN_ARENA : 0));
set_head (remainder, remainder_size | PREV_INUSE);
set_foot (remainder, remainder_size);
}
check_malloced_chunk (av, victim, nb);
void *p = chunk2mem (victim);
alloc_perturb (p, bytes);
return p;
}
}
```
</details>

### ãƒˆãƒƒãƒ—ãƒãƒ£ãƒ³ã‚¯

ã“ã®æ™‚ç‚¹ã§ã€ãƒˆãƒƒãƒ—ãƒãƒ£ãƒ³ã‚¯ã‹ã‚‰æ–°ã—ã„ãƒãƒ£ãƒ³ã‚¯ã‚’å–å¾—ã™ã‚‹æ™‚ãŒæ¥ã¾ã—ãŸï¼ˆã‚‚ã—ååˆ†ã«å¤§ãã„å ´åˆï¼‰ã€‚

ã¾ãšã€ãƒãƒ£ãƒ³ã‚¯ã®ã‚µã‚¤ã‚ºãŒå¤§ãã™ããªã„ã“ã¨ã‚’ç¢ºèªã™ã‚‹ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒã‚§ãƒƒã‚¯ãŒå§‹ã¾ã‚Šã¾ã™ï¼ˆç ´æã—ã¦ã„ãªã„ã“ã¨ã‚’ç¢ºèªï¼‰:

* `chunksize(av->top) > av->system_mem`: `malloc(): corrupted top size`

ãã®å¾Œã€ãƒªã‚¯ã‚¨ã‚¹ãƒˆã•ã‚ŒãŸã‚µã‚¤ã‚ºã®ãƒãƒ£ãƒ³ã‚¯ã‚’ä½œæˆã™ã‚‹ãŸã‚ã«ã€ãƒˆãƒƒãƒ—ãƒãƒ£ãƒ³ã‚¯ã®ã‚¹ãƒšãƒ¼ã‚¹ãŒååˆ†ã«å¤§ãã„å ´åˆã¯ãã‚Œã‚’ä½¿ç”¨ã—ã¾ã™ã€‚\
ã‚‚ã—å¤§ãã•ãŒè¶³ã‚Šãªã„å ´åˆã¯ã€é«˜é€Ÿãƒãƒ£ãƒ³ã‚¯ãŒã‚ã‚Œã°ãã‚Œã‚‰ã‚’çµ±åˆã—ã¦å†è©¦è¡Œã—ã¾ã™ã€‚\
æœ€å¾Œã«ã€ååˆ†ãªã‚¹ãƒšãƒ¼ã‚¹ãŒãªã„å ´åˆã¯ã€ååˆ†ãªã‚µã‚¤ã‚ºã‚’å‰²ã‚Šå½“ã¦ã‚‹ãŸã‚ã«`sysmalloc`ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚

<details>

<summary><code>_int_malloc</code> ãƒˆãƒƒãƒ—ãƒãƒ£ãƒ³ã‚¯</summary>
```c
use_top:
/*
If large enough, split off the chunk bordering the end of memory
(held in av->top). Note that this is in accord with the best-fit
search rule.  In effect, av->top is treated as larger (and thus
less well fitting) than any other available chunk since it can
be extended to be as large as necessary (up to system
limitations).

We require that av->top always exists (i.e., has size >=
MINSIZE) after initialization, so if it would otherwise be
exhausted by current request, it is replenished. (The main
reason for ensuring it exists is that we may need MINSIZE space
to put in fenceposts in sysmalloc.)
*/

victim = av->top;
size = chunksize (victim);

if (__glibc_unlikely (size > av->system_mem))
malloc_printerr ("malloc(): corrupted top size");

if ((unsigned long) (size) >= (unsigned long) (nb + MINSIZE))
{
remainder_size = size - nb;
remainder = chunk_at_offset (victim, nb);
av->top = remainder;
set_head (victim, nb | PREV_INUSE |
(av != &main_arena ? NON_MAIN_ARENA : 0));
set_head (remainder, remainder_size | PREV_INUSE);

check_malloced_chunk (av, victim, nb);
void *p = chunk2mem (victim);
alloc_perturb (p, bytes);
return p;
}

/* When we are using atomic ops to free fast chunks we can get
here for all block sizes.  */
else if (atomic_load_relaxed (&av->have_fastchunks))
{
malloc_consolidate (av);
/* restore original bin index */
if (in_smallbin_range (nb))
idx = smallbin_index (nb);
else
idx = largebin_index (nb);
}

/*
Otherwise, relay to handle system-dependent cases
*/
else
{
void *p = sysmalloc (nb, av);
if (p != NULL)
alloc_perturb (p, bytes);
return p;
}
}
}

```
### sysmalloc

### sysmalloc é–‹å§‹

ã‚‚ã—ã‚¢ãƒªãƒ¼ãƒŠãŒnullã§ã‚ã‚‹ã‹ã€è¦æ±‚ã•ã‚ŒãŸã‚µã‚¤ã‚ºãŒå¤§ãã™ãã‚‹å ´åˆï¼ˆã‹ã¤è¨±å¯ã•ã‚ŒãŸmmapãŒæ®‹ã£ã¦ã„ã‚‹å ´åˆï¼‰ã€`sysmalloc_mmap`ã‚’ä½¿ç”¨ã—ã¦ç©ºé–“ã‚’å‰²ã‚Šå½“ã¦ã¦è¿”ã—ã¾ã™ã€‚
```c
// From https://github.com/bminor/glibc/blob/f942a732d37a96217ef828116ebe64a644db18d7/malloc/malloc.c#L2531

/*
sysmalloc handles malloc cases requiring more memory from the system.
On entry, it is assumed that av->top does not have enough
space to service request for nb bytes, thus requiring that av->top
be extended or replaced.
*/

static void *
sysmalloc (INTERNAL_SIZE_T nb, mstate av)
{
mchunkptr old_top;              /* incoming value of av->top */
INTERNAL_SIZE_T old_size;       /* its size */
char *old_end;                  /* its end address */

long size;                      /* arg to first MORECORE or mmap call */
char *brk;                      /* return value from MORECORE */

long correction;                /* arg to 2nd MORECORE call */
char *snd_brk;                  /* 2nd return val */

INTERNAL_SIZE_T front_misalign; /* unusable bytes at front of new space */
INTERNAL_SIZE_T end_misalign;   /* partial page left at end of new space */
char *aligned_brk;              /* aligned offset into brk */

mchunkptr p;                    /* the allocated/returned chunk */
mchunkptr remainder;            /* remainder from allocation */
unsigned long remainder_size;   /* its size */


size_t pagesize = GLRO (dl_pagesize);
bool tried_mmap = false;


/*
If have mmap, and the request size meets the mmap threshold, and
the system supports mmap, and there are few enough currently
allocated mmapped regions, try to directly map this request
rather than expanding top.
*/

if (av == NULL
|| ((unsigned long) (nb) >= (unsigned long) (mp_.mmap_threshold)
&& (mp_.n_mmaps < mp_.n_mmaps_max)))
{
char *mm;
if (mp_.hp_pagesize > 0 && nb >= mp_.hp_pagesize)
{
/* There is no need to issue the THP madvise call if Huge Pages are
used directly.  */
mm = sysmalloc_mmap (nb, mp_.hp_pagesize, mp_.hp_flags, av);
if (mm != MAP_FAILED)
return mm;
}
mm = sysmalloc_mmap (nb, pagesize, 0, av);
if (mm != MAP_FAILED)
return mm;
tried_mmap = true;
}

/* There are no usable arenas and mmap also failed.  */
if (av == NULL)
return 0;
```
<details>

<summary>sysmallocã®ãƒã‚§ãƒƒã‚¯</summary>

### sysmallocã®ãƒã‚§ãƒƒã‚¯

å¤ã„ãƒˆãƒƒãƒ—ãƒãƒ£ãƒ³ã‚¯æƒ…å ±ã‚’å–å¾—ã—ã€ä»¥ä¸‹ã®æ¡ä»¶ã®ã„ãã¤ã‹ãŒçœŸã§ã‚ã‚‹ã“ã¨ã‚’ç¢ºèªã—ã¦é–‹å§‹ã—ã¾ã™ï¼š

* å¤ã„ãƒ’ãƒ¼ãƒ—ã‚µã‚¤ã‚ºãŒ0ã§ã‚ã‚‹ï¼ˆæ–°ã—ã„ãƒ’ãƒ¼ãƒ—ï¼‰
* å‰ã®ãƒ’ãƒ¼ãƒ—ã®ã‚µã‚¤ã‚ºãŒMINSIZEã‚ˆã‚Šã‚‚å¤§ããã€å¤ã„ãƒˆãƒƒãƒ—ãŒä½¿ç”¨ä¸­ã§ã‚ã‚‹
* ãƒ’ãƒ¼ãƒ—ãŒãƒšãƒ¼ã‚¸ã‚µã‚¤ã‚ºã«æ•´åˆ—ã•ã‚Œã¦ã„ã‚‹ï¼ˆ0x1000ãªã®ã§ã€ä¸‹ä½12ãƒ“ãƒƒãƒˆã¯0ã§ã‚ã‚‹å¿…è¦ãŒã‚ã‚‹ï¼‰

ãã®å¾Œã€ä»¥ä¸‹ã‚‚ãƒã‚§ãƒƒã‚¯ã•ã‚Œã¾ã™ï¼š

* å¤ã„ã‚µã‚¤ã‚ºãŒè¦æ±‚ã•ã‚ŒãŸã‚µã‚¤ã‚ºã®ãƒãƒ£ãƒ³ã‚¯ã‚’ä½œæˆã™ã‚‹ã®ã«ååˆ†ãªã‚¹ãƒšãƒ¼ã‚¹ãŒãªã„ã‹ã©ã†ã‹ã‚’ãƒã‚§ãƒƒã‚¯ã—ã¾ã™

</details>
```c
/* Record incoming configuration of top */

old_top = av->top;
old_size = chunksize (old_top);
old_end = (char *) (chunk_at_offset (old_top, old_size));

brk = snd_brk = (char *) (MORECORE_FAILURE);

/*
If not the first time through, we require old_size to be
at least MINSIZE and to have prev_inuse set.
*/

assert ((old_top == initial_top (av) && old_size == 0) ||
((unsigned long) (old_size) >= MINSIZE &&
prev_inuse (old_top) &&
((unsigned long) old_end & (pagesize - 1)) == 0));

/* Precondition: not enough current space to satisfy nb request */
assert ((unsigned long) (old_size) < (unsigned long) (nb + MINSIZE));
```
</details>

### sysmalloc not main arena

æœ€åˆã«ã€ã“ã®ãƒ’ãƒ¼ãƒ—ã®ãŸã‚ã«å‰ã®ãƒ’ãƒ¼ãƒ—ã‚’**æ‹¡å¼µ**ã—ã‚ˆã†ã¨ã—ã¾ã™ã€‚ãã‚ŒãŒã§ããªã„å ´åˆã¯ã€**æ–°ã—ã„ãƒ’ãƒ¼ãƒ—ã‚’å‰²ã‚Šå½“ã¦**ã€ãã‚Œã‚’ä½¿ç”¨ã§ãã‚‹ã‚ˆã†ã«ãƒã‚¤ãƒ³ã‚¿ã‚’æ›´æ–°ã—ã‚ˆã†ã¨ã—ã¾ã™ã€‚\
æœ€å¾Œã«ãã‚Œã§ã‚‚ã†ã¾ãã„ã‹ãªã„å ´åˆã¯ã€**`sysmalloc_mmap`**ã‚’å‘¼ã³å‡ºã—ã¦ã¿ã¦ãã ã•ã„ã€‚&#x20;

<details>

<summary>sysmalloc not main arena</summary>
```c
if (av != &main_arena)
{
heap_info *old_heap, *heap;
size_t old_heap_size;

/* First try to extend the current heap. */
old_heap = heap_for_ptr (old_top);
old_heap_size = old_heap->size;
if ((long) (MINSIZE + nb - old_size) > 0
&& grow_heap (old_heap, MINSIZE + nb - old_size) == 0)
{
av->system_mem += old_heap->size - old_heap_size;
set_head (old_top, (((char *) old_heap + old_heap->size) - (char *) old_top)
| PREV_INUSE);
}
else if ((heap = new_heap (nb + (MINSIZE + sizeof (*heap)), mp_.top_pad)))
{
/* Use a newly allocated heap.  */
heap->ar_ptr = av;
heap->prev = old_heap;
av->system_mem += heap->size;
/* Set up the new top.  */
top (av) = chunk_at_offset (heap, sizeof (*heap));
set_head (top (av), (heap->size - sizeof (*heap)) | PREV_INUSE);

/* Setup fencepost and free the old top chunk with a multiple of
MALLOC_ALIGNMENT in size. */
/* The fencepost takes at least MINSIZE bytes, because it might
become the top chunk again later.  Note that a footer is set
up, too, although the chunk is marked in use. */
old_size = (old_size - MINSIZE) & ~MALLOC_ALIGN_MASK;
set_head (chunk_at_offset (old_top, old_size + CHUNK_HDR_SZ),
0 | PREV_INUSE);
if (old_size >= MINSIZE)
{
set_head (chunk_at_offset (old_top, old_size),
CHUNK_HDR_SZ | PREV_INUSE);
set_foot (chunk_at_offset (old_top, old_size), CHUNK_HDR_SZ);
set_head (old_top, old_size | PREV_INUSE | NON_MAIN_ARENA);
_int_free (av, old_top, 1);
}
else
{
set_head (old_top, (old_size + CHUNK_HDR_SZ) | PREV_INUSE);
set_foot (old_top, (old_size + CHUNK_HDR_SZ));
}
}
else if (!tried_mmap)
{
/* We can at least try to use to mmap memory.  If new_heap fails
it is unlikely that trying to allocate huge pages will
succeed.  */
char *mm = sysmalloc_mmap (nb, pagesize, 0, av);
if (mm != MAP_FAILED)
return mm;
}
}
```
</details>

### sysmallocãƒ¡ã‚¤ãƒ³ã‚¢ãƒªãƒ¼ãƒŠ

å¿…è¦ãªãƒ¡ãƒ¢ãƒªé‡ã‚’è¨ˆç®—ã—å§‹ã‚ã¾ã™ã€‚é€£ç¶šã—ãŸãƒ¡ãƒ¢ãƒªã‚’è¦æ±‚ã—ã¦ã€ã“ã®å ´åˆã€ä½¿ç”¨ã•ã‚Œã¦ã„ãªã„å¤ã„ãƒ¡ãƒ¢ãƒªã‚’ä½¿ç”¨ã§ãã‚‹ã‚ˆã†ã«ã—ã¾ã™ã€‚ã¾ãŸã€ã„ãã¤ã‹ã®ã‚¢ãƒ©ã‚¤ãƒ³ãƒ¡ãƒ³ãƒˆæ“ä½œãŒå®Ÿè¡Œã•ã‚Œã¾ã™ã€‚

<details>

<summary>sysmallocãƒ¡ã‚¤ãƒ³ã‚¢ãƒªãƒ¼ãƒŠ</summary>
```c
// From https://github.com/bminor/glibc/blob/f942a732d37a96217ef828116ebe64a644db18d7/malloc/malloc.c#L2665C1-L2713C10

else     /* av == main_arena */


{ /* Request enough space for nb + pad + overhead */
size = nb + mp_.top_pad + MINSIZE;

/*
If contiguous, we can subtract out existing space that we hope to
combine with new space. We add it back later only if
we don't actually get contiguous space.
*/

if (contiguous (av))
size -= old_size;

/*
Round to a multiple of page size or huge page size.
If MORECORE is not contiguous, this ensures that we only call it
with whole-page arguments.  And if MORECORE is contiguous and
this is not first time through, this preserves page-alignment of
previous calls. Otherwise, we correct to page-align below.
*/

#ifdef MADV_HUGEPAGE
/* Defined in brk.c.  */
extern void *__curbrk;
if (__glibc_unlikely (mp_.thp_pagesize != 0))
{
uintptr_t top = ALIGN_UP ((uintptr_t) __curbrk + size,
mp_.thp_pagesize);
size = top - (uintptr_t) __curbrk;
}
else
#endif
size = ALIGN_UP (size, GLRO(dl_pagesize));

/*
Don't try to call MORECORE if argument is so big as to appear
negative. Note that since mmap takes size_t arg, it may succeed
below even if we cannot call MORECORE.
*/

if (size > 0)
{
brk = (char *) (MORECORE (size));
if (brk != (char *) (MORECORE_FAILURE))
madvise_thp (brk, size);
LIBC_PROBE (memory_sbrk_more, 2, brk, size);
}
```
### sysmallocãƒ¡ã‚¤ãƒ³ã‚¢ãƒªãƒ¼ãƒŠå‰ã®ã‚¨ãƒ©ãƒ¼1

å‰å›ã®æˆ»ã‚Šå€¤ãŒ`MORECORE_FAILURE`ã ã£ãŸå ´åˆã¯ã€`sysmalloc_mmap_fallback`ã‚’ä½¿ç”¨ã—ã¦ãƒ¡ãƒ¢ãƒªã‚’å†å‰²ã‚Šå½“ã¦ã—ã¦ã¿ã¦ãã ã•ã„ã€‚
```c
// From https://github.com/bminor/glibc/blob/f942a732d37a96217ef828116ebe64a644db18d7/malloc/malloc.c#L2715C7-L2740C10

if (brk == (char *) (MORECORE_FAILURE))
{
/*
If have mmap, try using it as a backup when MORECORE fails or
cannot be used. This is worth doing on systems that have "holes" in
address space, so sbrk cannot extend to give contiguous space, but
space is available elsewhere.  Note that we ignore mmap max count
and threshold limits, since the space will not be used as a
segregated mmap region.
*/

char *mbrk = MAP_FAILED;
if (mp_.hp_pagesize > 0)
mbrk = sysmalloc_mmap_fallback (&size, nb, old_size,
mp_.hp_pagesize, mp_.hp_pagesize,
mp_.hp_flags, av);
if (mbrk == MAP_FAILED)
mbrk = sysmalloc_mmap_fallback (&size, nb, old_size, MMAP_AS_MORECORE_SIZE,
pagesize, 0, av);
if (mbrk != MAP_FAILED)
{
/* We do not need, and cannot use, another sbrk call to find end */
brk = mbrk;
snd_brk = brk + size;
}
}
```
### sysmallocãƒ¡ã‚¤ãƒ³ã‚¢ãƒªãƒ¼ãƒŠã®ç¶šã

å‰ã®æ‰‹é †ãŒ`MORECORE_FAILURE`ã‚’è¿”ã•ãªã‹ã£ãŸå ´åˆã€å‹•ä½œã—ãŸå ´åˆã¯ã„ãã¤ã‹ã®ã‚¢ãƒ©ã‚¤ãƒ¡ãƒ³ãƒˆã‚’ä½œæˆã—ã¾ã™ã€‚
```c
// From https://github.com/bminor/glibc/blob/f942a732d37a96217ef828116ebe64a644db18d7/malloc/malloc.c#L2742

if (brk != (char *) (MORECORE_FAILURE))
{
if (mp_.sbrk_base == 0)
mp_.sbrk_base = brk;
av->system_mem += size;

/*
If MORECORE extends previous space, we can likewise extend top size.
*/

if (brk == old_end && snd_brk == (char *) (MORECORE_FAILURE))
set_head (old_top, (size + old_size) | PREV_INUSE);

else if (contiguous (av) && old_size && brk < old_end)
/* Oops!  Someone else killed our space..  Can't touch anything.  */
malloc_printerr ("break adjusted to free malloc space");

/*
Otherwise, make adjustments:

* If the first time through or noncontiguous, we need to call sbrk
just to find out where the end of memory lies.

* We need to ensure that all returned chunks from malloc will meet
MALLOC_ALIGNMENT

* If there was an intervening foreign sbrk, we need to adjust sbrk
request size to account for fact that we will not be able to
combine new space with existing space in old_top.

* Almost all systems internally allocate whole pages at a time, in
which case we might as well use the whole last page of request.
So we allocate enough more memory to hit a page boundary now,
which in turn causes future contiguous calls to page-align.
*/

else
{
front_misalign = 0;
end_misalign = 0;
correction = 0;
aligned_brk = brk;

/* handle contiguous cases */
if (contiguous (av))
{
/* Count foreign sbrk as system_mem.  */
if (old_size)
av->system_mem += brk - old_end;

/* Guarantee alignment of first new chunk made from this space */

front_misalign = (INTERNAL_SIZE_T) chunk2mem (brk) & MALLOC_ALIGN_MASK;
if (front_misalign > 0)
{
/*
Skip over some bytes to arrive at an aligned position.
We don't need to specially mark these wasted front bytes.
They will never be accessed anyway because
prev_inuse of av->top (and any chunk created from its start)
is always true after initialization.
*/

correction = MALLOC_ALIGNMENT - front_misalign;
aligned_brk += correction;
}

/*
If this isn't adjacent to existing space, then we will not
be able to merge with old_top space, so must add to 2nd request.
*/

correction += old_size;

/* Extend the end address to hit a page boundary */
end_misalign = (INTERNAL_SIZE_T) (brk + size + correction);
correction += (ALIGN_UP (end_misalign, pagesize)) - end_misalign;

assert (correction >= 0);
snd_brk = (char *) (MORECORE (correction));

/*
If can't allocate correction, try to at least find out current
brk.  It might be enough to proceed without failing.

Note that if second sbrk did NOT fail, we assume that space
is contiguous with first sbrk. This is a safe assumption unless
program is multithreaded but doesn't use locks and a foreign sbrk
occurred between our first and second calls.
*/

if (snd_brk == (char *) (MORECORE_FAILURE))
{
correction = 0;
snd_brk = (char *) (MORECORE (0));
}
else
madvise_thp (snd_brk, correction);
}

/* handle non-contiguous cases */
else
{
if (MALLOC_ALIGNMENT == CHUNK_HDR_SZ)
/* MORECORE/mmap must correctly align */
assert (((unsigned long) chunk2mem (brk) & MALLOC_ALIGN_MASK) == 0);
else
{
front_misalign = (INTERNAL_SIZE_T) chunk2mem (brk) & MALLOC_ALIGN_MASK;
if (front_misalign > 0)
{
/*
Skip over some bytes to arrive at an aligned position.
We don't need to specially mark these wasted front bytes.
They will never be accessed anyway because
prev_inuse of av->top (and any chunk created from its start)
is always true after initialization.
*/

aligned_brk += MALLOC_ALIGNMENT - front_misalign;
}
}

/* Find out current end of memory */
if (snd_brk == (char *) (MORECORE_FAILURE))
{
snd_brk = (char *) (MORECORE (0));
}
}

/* Adjust top based on results of second sbrk */
if (snd_brk != (char *) (MORECORE_FAILURE))
{
av->top = (mchunkptr) aligned_brk;
set_head (av->top, (snd_brk - aligned_brk + correction) | PREV_INUSE);
av->system_mem += correction;

/*
If not the first time through, we either have a
gap due to foreign sbrk or a non-contiguous region.  Insert a
double fencepost at old_top to prevent consolidation with space
we don't own. These fenceposts are artificial chunks that are
marked as inuse and are in any case too small to use.  We need
two to make sizes and alignments work out.
*/

if (old_size != 0)
{
/*
Shrink old_top to insert fenceposts, keeping size a
multiple of MALLOC_ALIGNMENT. We know there is at least
enough space in old_top to do this.
*/
old_size = (old_size - 2 * CHUNK_HDR_SZ) & ~MALLOC_ALIGN_MASK;
set_head (old_top, old_size | PREV_INUSE);

/*
Note that the following assignments completely overwrite
old_top when old_size was previously MINSIZE.  This is
intentional. We need the fencepost, even if old_top otherwise gets
lost.
*/
set_head (chunk_at_offset (old_top, old_size),
CHUNK_HDR_SZ | PREV_INUSE);
set_head (chunk_at_offset (old_top,
old_size + CHUNK_HDR_SZ),
CHUNK_HDR_SZ | PREV_INUSE);

/* If possible, release the rest. */
if (old_size >= MINSIZE)
{
_int_free (av, old_top, 1);
}
}
}
}
}
} /* if (av !=  &main_arena) */
```
### sysmalloc æœ€çµ‚å‡¦ç†

ã‚¢ãƒªãƒ¼ãƒŠæƒ…å ±ã‚’æ›´æ–°ã—ã¦å‰²ã‚Šå½“ã¦ã‚’å®Œäº†ã—ã¾ã™

</details>
```c
// From https://github.com/bminor/glibc/blob/f942a732d37a96217ef828116ebe64a644db18d7/malloc/malloc.c#L2921C3-L2943C12

if ((unsigned long) av->system_mem > (unsigned long) (av->max_system_mem))
av->max_system_mem = av->system_mem;
check_malloc_state (av);

/* finally, do the allocation */
p = av->top;
size = chunksize (p);

/* check that one of the above allocation paths succeeded */
if ((unsigned long) (size) >= (unsigned long) (nb + MINSIZE))
{
remainder_size = size - nb;
remainder = chunk_at_offset (p, nb);
av->top = remainder;
set_head (p, nb | PREV_INUSE | (av != &main_arena ? NON_MAIN_ARENA : 0));
set_head (remainder, remainder_size | PREV_INUSE);
check_malloced_chunk (av, p, nb);
return chunk2mem (p);
}

/* catch all failure paths */
__set_errno (ENOMEM);
return 0;
```
## sysmalloc_mmap

<details>

<summary>sysmalloc_mmapã®ã‚³ãƒ¼ãƒ‰</summary>
```c
// From https://github.com/bminor/glibc/blob/f942a732d37a96217ef828116ebe64a644db18d7/malloc/malloc.c#L2392C1-L2481C2

static void *
sysmalloc_mmap (INTERNAL_SIZE_T nb, size_t pagesize, int extra_flags, mstate av)
{
long int size;

/*
Round up size to nearest page.  For mmapped chunks, the overhead is one
SIZE_SZ unit larger than for normal chunks, because there is no
following chunk whose prev_size field could be used.

See the front_misalign handling below, for glibc there is no need for
further alignments unless we have have high alignment.
*/
if (MALLOC_ALIGNMENT == CHUNK_HDR_SZ)
size = ALIGN_UP (nb + SIZE_SZ, pagesize);
else
size = ALIGN_UP (nb + SIZE_SZ + MALLOC_ALIGN_MASK, pagesize);

/* Don't try if size wraps around 0.  */
if ((unsigned long) (size) <= (unsigned long) (nb))
return MAP_FAILED;

char *mm = (char *) MMAP (0, size,
mtag_mmap_flags | PROT_READ | PROT_WRITE,
extra_flags);
if (mm == MAP_FAILED)
return mm;

#ifdef MAP_HUGETLB
if (!(extra_flags & MAP_HUGETLB))
madvise_thp (mm, size);
#endif

__set_vma_name (mm, size, " glibc: malloc");

/*
The offset to the start of the mmapped region is stored in the prev_size
field of the chunk.  This allows us to adjust returned start address to
meet alignment requirements here and in memalign(), and still be able to
compute proper address argument for later munmap in free() and realloc().
*/

INTERNAL_SIZE_T front_misalign; /* unusable bytes at front of new space */

if (MALLOC_ALIGNMENT == CHUNK_HDR_SZ)
{
/* For glibc, chunk2mem increases the address by CHUNK_HDR_SZ and
MALLOC_ALIGN_MASK is CHUNK_HDR_SZ-1.  Each mmap'ed area is page
aligned and therefore definitely MALLOC_ALIGN_MASK-aligned.  */
assert (((INTERNAL_SIZE_T) chunk2mem (mm) & MALLOC_ALIGN_MASK) == 0);
front_misalign = 0;
}
else
front_misalign = (INTERNAL_SIZE_T) chunk2mem (mm) & MALLOC_ALIGN_MASK;

mchunkptr p;                    /* the allocated/returned chunk */

if (front_misalign > 0)
{
ptrdiff_t correction = MALLOC_ALIGNMENT - front_misalign;
p = (mchunkptr) (mm + correction);
set_prev_size (p, correction);
set_head (p, (size - correction) | IS_MMAPPED);
}
else
{
p = (mchunkptr) mm;
set_prev_size (p, 0);
set_head (p, size | IS_MMAPPED);
}

/* update statistics */
int new = atomic_fetch_add_relaxed (&mp_.n_mmaps, 1) + 1;
atomic_max (&mp_.max_n_mmaps, new);

unsigned long sum;
sum = atomic_fetch_add_relaxed (&mp_.mmapped_mem, size) + size;
atomic_max (&mp_.max_mmapped_mem, sum);

check_chunk (av, p);

return chunk2mem (p);
}
```
</details>

<details>

<summary><strong>AWSãƒãƒƒã‚­ãƒ³ã‚°ã‚’ã‚¼ãƒ­ã‹ã‚‰ãƒ’ãƒ¼ãƒ­ãƒ¼ã¾ã§å­¦ã¶</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTEï¼ˆHackTricks AWS Red Team Expertï¼‰</strong></a><strong>ï¼</strong></summary>

HackTricksã‚’ã‚µãƒãƒ¼ãƒˆã™ã‚‹ä»–ã®æ–¹æ³•:

* **HackTricksã§ä¼æ¥­ã‚’å®£ä¼ã—ãŸã„**ã¾ãŸã¯**HackTricksã‚’PDFã§ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã—ãŸã„**å ´åˆã¯ã€[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)ã‚’ãƒã‚§ãƒƒã‚¯ã—ã¦ãã ã•ã„ï¼
* [**å…¬å¼PEASSï¼†HackTricksã®ã‚¹ã‚¦ã‚©ãƒƒã‚°**](https://peass.creator-spring.com)ã‚’å…¥æ‰‹ã—ã¦ãã ã•ã„
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)ã‚’ç™ºè¦‹ã—ã€ç‹¬å çš„ãª[**NFTs**](https://opensea.io/collection/the-peass-family)ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã‚’ã”è¦§ãã ã•ã„
* **ğŸ’¬ [**Discordã‚°ãƒ«ãƒ¼ãƒ—**](https://discord.gg/hRep4RUj7f)ã«å‚åŠ ã™ã‚‹ã‹ã€[**telegramã‚°ãƒ«ãƒ¼ãƒ—**](https://t.me/peass)ã«å‚åŠ ã™ã‚‹ã‹ã€**Twitter** ğŸ¦ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**ã‚’ãƒ•ã‚©ãƒ­ãƒ¼ã—ã¦ãã ã•ã„ã€‚**
* **ãƒãƒƒã‚­ãƒ³ã‚°ãƒˆãƒªãƒƒã‚¯ã‚’å…±æœ‰ã™ã‚‹ãŸã‚ã«ã€PRã‚’** [**HackTricks**](https://github.com/carlospolop/hacktricks) **ãŠã‚ˆã³** [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) **ã®GitHubãƒªãƒã‚¸ãƒˆãƒªã«æå‡ºã—ã¦ãã ã•ã„ã€‚**

</details>
