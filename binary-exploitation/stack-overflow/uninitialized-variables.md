# Variables no inicializadas

<details>

<summary><strong>Aprende hacking en AWS de cero a h茅roe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (Experto en Red Team de AWS de HackTricks)</strong></a><strong>!</strong></summary>

Otras formas de apoyar a HackTricks:

* Si deseas ver tu **empresa anunciada en HackTricks** o **descargar HackTricks en PDF** 隆Consulta los [**PLANES DE SUSCRIPCIN**](https://github.com/sponsors/carlospolop)!
* Obt茅n la [**merchandising oficial de PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubre [**La Familia PEASS**](https://opensea.io/collection/the-peass-family), nuestra colecci贸n exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **nete al**  [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s铆guenos** en **Twitter**  [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Comparte tus trucos de hacking enviando PRs a los repositorios de** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

## Informaci贸n B谩sica

La idea principal aqu铆 es entender qu茅 sucede con las **variables no inicializadas, ya que tendr谩n el valor que ya estaba asignado en la memoria asignada a ellas.** Ejemplo:

* **Funci贸n 1: `initializeVariable`**: Declaramos una variable `x` y le asignamos un valor, digamos `0x1234`. Esta acci贸n es similar a reservar un espacio en la memoria y poner un valor espec铆fico en 茅l.
* **Funci贸n 2: `useUninitializedVariable`**: Aqu铆, declaramos otra variable `y` pero no le asignamos ning煤n valor. En C, las variables no inicializadas no se establecen autom谩ticamente en cero. En su lugar, conservan el valor que estaba almacenado en su ubicaci贸n de memoria.

Cuando ejecutamos estas dos funciones **secuencialmente**:

1. En `initializeVariable`, `x` se le asigna un valor (`0x1234`), que ocupa una direcci贸n de memoria espec铆fica.
2. En `useUninitializedVariable`, se declara `y` pero no se le asigna un valor, por lo que toma el lugar de memoria justo despu茅s de `x`. Debido a no inicializar `y`, termina "heredando" el valor de la misma ubicaci贸n de memoria utilizada por `x`, porque ese fue el 煤ltimo valor que estaba all铆.

Este comportamiento ilustra un concepto clave en la programaci贸n de bajo nivel: **La gesti贸n de memoria es crucial**, y las variables no inicializadas pueden llevar a un comportamiento impredecible o vulnerabilidades de seguridad, ya que pueden contener involuntariamente datos sensibles dejados en la memoria.

Las variables de la pila no inicializadas podr铆an plantear varios riesgos de seguridad como:

* **Fuga de datos**: Informaci贸n sensible como contrase帽as, claves de cifrado o detalles personales pueden ser expuestos si se almacenan en variables no inicializadas, lo que permite a los atacantes potencialmente leer estos datos.
* **Divulgaci贸n de informaci贸n**: El contenido de variables no inicializadas podr铆a revelar detalles sobre el dise帽o de memoria del programa u operaciones internas, ayudando a los atacantes a desarrollar exploits dirigidos.
* **Fallos e Inestabilidad**: Las operaciones que involucran variables no inicializadas pueden resultar en un comportamiento indefinido, lo que lleva a bloqueos del programa o resultados impredecibles.
* **Ejecuci贸n de C贸digo Arbitrario**: En ciertos escenarios, los atacantes podr铆an explotar estas vulnerabilidades para alterar el flujo de ejecuci贸n del programa, lo que les permite ejecutar c贸digo arbitrario, que podr铆a incluir amenazas de ejecuci贸n de c贸digo remoto.

### Ejemplo
```c
#include <stdio.h>

// Function to initialize and print a variable
void initializeAndPrint() {
int initializedVar = 100; // Initialize the variable
printf("Initialized Variable:\n");
printf("Address: %p, Value: %d\n\n", (void*)&initializedVar, initializedVar);
}

// Function to demonstrate the behavior of an uninitialized variable
void demonstrateUninitializedVar() {
int uninitializedVar; // Declare but do not initialize
printf("Uninitialized Variable:\n");
printf("Address: %p, Value: %d\n\n", (void*)&uninitializedVar, uninitializedVar);
}

int main() {
printf("Demonstrating Initialized vs. Uninitialized Variables in C\n\n");

// First, call the function that initializes its variable
initializeAndPrint();

// Then, call the function that has an uninitialized variable
demonstrateUninitializedVar();

return 0;
}
```
#### C贸mo Funciona:

* **Funci贸n `initializeAndPrint`**: Esta funci贸n declara una variable entera `initializedVar`, le asigna el valor `100` y luego imprime tanto la direcci贸n de memoria como el valor de la variable. Este paso es directo y muestra c贸mo se comporta una variable inicializada.
* **Funci贸n `demonstrateUninitializedVar`**: En esta funci贸n, declaramos una variable entera `uninitializedVar` sin inicializarla. Cuando intentamos imprimir su valor, la salida puede mostrar un n煤mero aleatorio. Este n煤mero representa cualquier dato que estuviera previamente en esa ubicaci贸n de memoria. Dependiendo del entorno y del compilador, la salida real puede variar y, a veces, por seguridad, algunos compiladores podr铆an inicializar autom谩ticamente las variables a cero, aunque no se debe confiar en esto.
* **Funci贸n `main`**: La funci贸n `main` llama a ambas funciones anteriores en secuencia, demostrando la diferencia entre una variable inicializada y una no inicializada.

## Ejemplo ARM64

Esto no cambia en absoluto en ARM64, ya que las variables locales tambi茅n se gestionan en la pila, puedes [**ver este ejemplo**](https://8ksec.io/arm64-reversing-and-exploitation-part-6-exploiting-an-uninitialized-stack-variable-vulnerability/) donde se muestra esto.
