# Variables no inicializadas

<details>

<summary><strong>Aprende hacking en AWS de cero a h茅roe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (Experto en Equipos Rojos de AWS de HackTricks)</strong></a><strong>!</strong></summary>

Otras formas de apoyar a HackTricks:

* Si deseas ver tu **empresa anunciada en HackTricks** o **descargar HackTricks en PDF** 隆Consulta los [**PLANES DE SUSCRIPCIN**](https://github.com/sponsors/carlospolop)!
* Obt茅n la [**merchandising oficial de PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubre [**La Familia PEASS**](https://opensea.io/collection/the-peass-family), nuestra colecci贸n exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **nete al**  [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s铆guenos** en **Twitter**  [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Comparte tus trucos de hacking enviando PRs a los repositorios de** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

## Informaci贸n B谩sica

La idea principal aqu铆 es entender qu茅 sucede con las **variables no inicializadas, ya que tendr谩n el valor que ya estaba asignado en la memoria reservada para ellas.** Ejemplo:

* **Funci贸n 1: `initializeVariable`**: Declaramos una variable `x` y le asignamos un valor, digamos `0x1234`. Esta acci贸n es similar a reservar un espacio en la memoria y colocar un valor espec铆fico en 茅l.
* **Funci贸n 2: `useUninitializedVariable`**: Aqu铆, declaramos otra variable `y` pero no le asignamos ning煤n valor. En C, las variables no inicializadas no se establecen autom谩ticamente en cero. En su lugar, conservan el valor que estaba almacenado en su ubicaci贸n de memoria.

Cuando ejecutamos estas dos funciones **secuencialmente**:

1. En `initializeVariable`, `x` recibe un valor (`0x1234`), que ocupa una direcci贸n de memoria espec铆fica.
2. En `useUninitializedVariable`, se declara `y` pero no se le asigna un valor, por lo que toma el lugar de memoria justo despu茅s de `x`. Debido a no inicializar `y`, termina "heredando" el valor de la misma ubicaci贸n de memoria utilizada por `x`, ya que ese fue el 煤ltimo valor que estaba all铆.

Este comportamiento ilustra un concepto clave en la programaci贸n a bajo nivel: **La gesti贸n de memoria es crucial**, y las variables no inicializadas pueden provocar un comportamiento impredecible o vulnerabilidades de seguridad, ya que pueden contener involuntariamente datos sensibles dejados en la memoria.

### Ejemplo
```c
#include <stdio.h>

// Function to initialize and print a variable
void initializeAndPrint() {
int initializedVar = 100; // Initialize the variable
printf("Initialized Variable:\n");
printf("Address: %p, Value: %d\n\n", (void*)&initializedVar, initializedVar);
}

// Function to demonstrate the behavior of an uninitialized variable
void demonstrateUninitializedVar() {
int uninitializedVar; // Declare but do not initialize
printf("Uninitialized Variable:\n");
printf("Address: %p, Value: %d\n\n", (void*)&uninitializedVar, uninitializedVar);
}

int main() {
printf("Demonstrating Initialized vs. Uninitialized Variables in C\n\n");

// First, call the function that initializes its variable
initializeAndPrint();

// Then, call the function that has an uninitialized variable
demonstrateUninitializedVar();

return 0;
}
```
#### C贸mo Funciona:

* **Funci贸n `initializeAndPrint`**: Esta funci贸n declara una variable entera `initializedVar`, le asigna el valor `100`, y luego imprime tanto la direcci贸n de memoria como el valor de la variable. Este paso es directo y muestra c贸mo se comporta una variable inicializada.
* **Funci贸n `demonstrateUninitializedVar`**: En esta funci贸n, declaramos una variable entera `uninitializedVar` sin inicializarla. Cuando intentamos imprimir su valor, la salida podr铆a mostrar un n煤mero aleatorio. Este n煤mero representa cualquier dato que estuviera previamente en esa ubicaci贸n de memoria. Dependiendo del entorno y del compilador, la salida real puede variar, y a veces, por seguridad, algunos compiladores podr铆an inicializar autom谩ticamente las variables a cero, aunque no se debe confiar en esto.
* **Funci贸n `main`**: La funci贸n `main` llama a ambas funciones anteriores en secuencia, demostrando la diferencia entre una variable inicializada y una no inicializada.
