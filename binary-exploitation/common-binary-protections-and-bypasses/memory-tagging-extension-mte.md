# メモリタギング拡張（MTE）

<details>

<summary><strong>htARTE（HackTricks AWS Red Team Expert）</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>を通じてゼロからヒーローまでAWSハッキングを学ぶ</strong></a><strong>！</strong></summary>

HackTricksをサポートする他の方法：

- **HackTricksで企業を宣伝**したい場合や**HackTricksをPDFでダウンロード**したい場合は、[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！
- [**公式PEASS＆HackTricksスワッグ**](https://peass.creator-spring.com)を入手する
- [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見し、独占的な[**NFTs**](https://opensea.io/collection/the-peass-family)のコレクションを見つける
- **💬 [Discordグループ](https://discord.gg/hRep4RUj7f)**に参加するか、[telegramグループ](https://t.me/peass)に参加するか、**Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)をフォローする
- **ハッキングトリックを共有するには、[HackTricks](https://github.com/carlospolop/hacktricks)と[HackTricks Cloud](https://github.com/carlospolop/hacktricks-cloud)のGitHubリポジトリにPRを提出してください**

</details>

## 基本情報

**メモリタギング拡張（MTE）**は、**バッファオーバーフロー**や**解放後に使用**される脆弱性などの**メモリ関連エラーを検出および防止**することで、ソフトウェアの信頼性とセキュリティを向上させるよう設計されています。MTEは**ARM**アーキテクチャの一部として、**各メモリ割り当てに小さなタグを添付**し、そのメモリを参照する**各ポインタに対応するタグ**を提供します。このアプローチにより、実行時に不正なメモリアクセスを検出し、これらの脆弱性を悪用して任意のコードを実行するリスクを大幅に低減できます。

### **メモリタギング拡張の動作方法**

MTEは、**メモリを小さな固定サイズのブロックに分割**し、通常は数ビットの**タグを割り当てる**ことによって動作します。

ポインタがそのメモリを指すように作成されると、同じタグが付与されます。このタグは、**メモリポインタの未使用ビットに格納**され、効果的にポインタを対応するメモリブロックにリンクします。

<figure><img src="../../.gitbook/assets/image (1202).png" alt=""><figcaption><p><a href="https://www.youtube.com/watch?v=UwMt0e_dC_Q">https://www.youtube.com/watch?v=UwMt0e_dC_Q</a></p></figcaption></figure>

プログラムがポインタを介してメモリにアクセスすると、MTEハードウェアは**ポインタのタグがメモリブロックのタグと一致するかどうか**をチェックします。タグが**一致しない**場合、不正なメモリアクセスを示します。

### MTEポインタタグ

ポインタ内のタグは、トップバイト内の4ビットに格納されます：

<figure><img src="../../.gitbook/assets/image (1203).png" alt=""><figcaption><p><a href="https://www.youtube.com/watch?v=UwMt0e_dC_Q">https://www.youtube.com/watch?v=UwMt0e_dC_Q</a></p></figcaption></figure>

したがって、これにより最大**16種類の異なるタグ値**が可能となります。

### MTEメモリタグ

**物理メモリの16Bごと**に対応する**メモリタグ**があります。

メモリタグは、**専用のRAM領域**に格納されています（通常の使用ではアクセスできません）。16Bメモリタグごとに4ビットのタグを持つことで、RAMの3%まで可能です。

ARMは、これらのタグを専用のRAMメモリで操作するために次の命令を導入しています：
```
STG [<Xn/SP>], #<simm>    Store Allocation (memory) Tag
LDG <Xt>, [<Xn/SP>]       Load Allocatoin (memory) Tag
IRG <Xd/SP>, <Xn/SP>      Insert Random [pointer] Tag
...
```
## チェックモード

### Sync

CPUは**命令の実行中に**タグをチェックし、不一致があると例外を発生させます。\
これは最も遅くて最も安全です。

### Async

CPUは**非同期的に**タグをチェックし、不一致が見つかるとシステムレジスタの例外ビットを設定します。前のものより**速い**ですが、不一致を引き起こす正確な命令を指摘することが**できず**、例外をすぐに発生させず、攻撃者に攻撃を完了する時間を与えます。

### Mixed

???

## 実装と検出の例

ハードウェアタグベースのKASAN、MTEベースのKASAN、またはカーネル内MTEと呼ばれます。\
カーネルアロケータ（`kmalloc`など）は、**このモジュールを呼び出し**、使用するタグを準備し（ランダムに）、カーネルスペースに割り当てられたメモリにそれをアタッチし、返されたポインタにそれをアタッチします。

要求されたサイズに十分なメモリグラニュール（それぞれ16B）だけを**マーク**します。したがって、要求されたサイズが35で、60Bのスラブが与えられた場合、最初の16\*3 = 48Bをこのタグでマークし、**残り**は**無効なタグ（0xEと呼ばれる）**で**マーク**されます。

タグ**0xF**は**すべてのポインタに一致**します。このポインタを持つメモリには、そのメモリにアクセスするために**任意のタグを使用**できます（不一致がありません）。これにより、攻撃が検出されない可能性があります。

したがって、0xEと0xFを予約しているため、タグを生成するために使用できる**値は14個だけ**です。再利用されるタグの確率は1/17 -> 約**7%**です。

カーネルが**無効なタグのグラニュール**にアクセスすると、**不一致**が**検出**されます。別のメモリ位置にアクセスする場合、メモリに**異なるタグ**（または無効なタグ）がある場合、不一致が**検出**されます。攻撃者が幸運でメモリが同じタグを使用している場合、検出されません。確率は約7%です。

もう1つのバグは、割り当てられたメモリの**最後のグラニュール**で発生します。アプリケーションが35Bを要求した場合、32から48までのグラニュールが与えられます。したがって、36から47までのバイトは同じタグを使用していますが、要求されていません。攻撃者が**これらの余分なバイトにアクセスすると、これは検出されません**。

**`kfree()`**が実行されると、メモリは無効なメモリタグで再タグ付けされるため、**free後に使用**されると、**不一致が検出**されます。

ただし、free後に同じ**チャンクが以前と同じタグで再割り当て**される場合、攻撃者はこのアクセスを使用でき、これは検出されません（約7%の確率）。

さらに、**`slab`と`page_alloc`**のみがタグ付きメモリを使用しますが、将来的には`vmalloc`、`stack`、`globals`でも使用される予定です（ビデオの時点ではこれらはまだ悪用される可能性があります）。

**不一致が検出**されると、カーネルは**パニック**を起こして、さらなる悪用や攻撃の再試行を防ぎます（MTEには誤検知がありません）。

## 参考文献

* [https://www.youtube.com/watch?v=UwMt0e\_dC\_Q](https://www.youtube.com/watch?v=UwMt0e\_dC\_Q)
