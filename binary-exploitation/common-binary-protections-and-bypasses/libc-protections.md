# Protecciones de Libc

<details>

<summary><strong>Aprende a hackear AWS desde cero hasta convertirte en un experto con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Otras formas de apoyar a HackTricks:

* Si quieres ver tu **empresa anunciada en HackTricks** o **descargar HackTricks en PDF** Consulta los [**PLANES DE SUSCRIPCIN**](https://github.com/sponsors/carlospolop)!
* Obt茅n la [**oficial PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Descubre [**The PEASS Family**](https://opensea.io/collection/the-peass-family), nuestra colecci贸n exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **nete al**  [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s铆guenos** en **Twitter**  [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Comparte tus trucos de hacking enviando PRs a los** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repositorios de github.

</details>

## Aplicaci贸n de Alineaci贸n de Chunks

**Malloc** asigna memoria en agrupaciones de **8 bytes (32 bits) o 16 bytes (64 bits)**. Esto significa que el final de los chunks en sistemas de 32 bits deber铆a alinearse con **0x8**, y en sistemas de 64 bits con **0x0**. La caracter铆stica de seguridad verifica que cada chunk **se alinee correctamente** en estas ubicaciones espec铆ficas antes de usar un puntero de un bin.

### Beneficios de Seguridad

La aplicaci贸n de la alineaci贸n de chunks en sistemas de 64 bits mejora significativamente la seguridad de Malloc al **limitar la ubicaci贸n de chunks falsos a solo 1 de cada 16 direcciones**. Esto complica los esfuerzos de explotaci贸n, especialmente en escenarios donde el usuario tiene un control limitado sobre los valores de entrada, haciendo que los ataques sean m谩s complejos y dif铆ciles de ejecutar con 茅xito.

* **Ataque Fastbin en \_\_malloc\_hook**

Las nuevas reglas de alineaci贸n en Malloc tambi茅n frustran un ataque cl谩sico que implica el `__malloc_hook`. Anteriormente, los atacantes pod铆an manipular tama帽os de chunks para **sobrescribir este puntero de funci贸n** y obtener **ejecuci贸n de c贸digo**. Ahora, el estricto requisito de alineaci贸n garantiza que tales manipulaciones ya no sean viables, cerrando una ruta com煤n de explotaci贸n y mejorando la seguridad general.

## Enmascaramiento de Punteros en fastbins y tcache

El **Enmascaramiento de Punteros** es una mejora de seguridad utilizada para proteger los **punteros Fd de fastbin y tcache** en operaciones de gesti贸n de memoria. Esta t茅cnica ayuda a prevenir ciertos tipos de t谩cticas de explotaci贸n de memoria, espec铆ficamente aquellas que no requieren informaci贸n de memoria filtrada o que manipulan ubicaciones de memoria directamente en relaci贸n con posiciones conocidas (sobrescrituras **relativas**).

El n煤cleo de esta t茅cnica es una f贸rmula de ofuscaci贸n:

**`Nuevo_Ptr = (L >> 12) XOR P`**

* **L** es la **Ubicaci贸n de Almacenamiento** del puntero.
* **P** es el **Puntero Fd de fastbin/tcache** real.

La raz贸n por la cual el desplazamiento de bits de la ubicaci贸n de almacenamiento (L) por 12 bits hacia la derecha antes de la operaci贸n XOR es cr铆tica. Esta manipulaci贸n aborda una vulnerabilidad inherente en la naturaleza determinista de los 12 bits menos significativos de las direcciones de memoria, que suelen ser predecibles debido a las limitaciones de la arquitectura del sistema. Al desplazar los bits, la parte predecible se elimina de la ecuaci贸n, mejorando la aleatoriedad del nuevo puntero enmascarado y protegiendo as铆 contra exploits que dependen de la previsibilidad de estos bits.

Este puntero enmascarado aprovecha la aleatoriedad existente proporcionada por la **Aleatorizaci贸n del Dise帽o del Espacio de Direcciones (ASLR)**, que aleatoriza las direcciones utilizadas por los programas para dificultar que los atacantes predigan el dise帽o de memoria de un proceso.

**Desenmascarar** el puntero para recuperar la direcci贸n original implica usar la misma operaci贸n XOR. Aqu铆, el puntero enmascarado se trata como P en la f贸rmula, y al hacer XOR con la ubicaci贸n de almacenamiento sin cambios (L), se revela el puntero original. Esta simetr铆a en el enmascaramiento y desenmascaramiento garantiza que el sistema pueda codificar y decodificar eficientemente punteros sin una sobrecarga significativa, al tiempo que aumenta sustancialmente la seguridad contra ataques que manipulan punteros de memoria.

### Beneficios de Seguridad

El enmascaramiento de punteros tiene como objetivo **prevenir sobrescrituras parciales y completas de punteros en el heap**, una mejora significativa en seguridad. Esta caracter铆stica impacta las t茅cnicas de explotaci贸n de varias maneras:

1. **Prevenci贸n de Sobrescrituras Relativas de Bye Byte**: Anteriormente, los atacantes pod铆an cambiar parte de un puntero para **redirigir chunks del heap a ubicaciones diferentes sin conocer direcciones exactas**, una t茅cnica evidente en el exploit **House of Roman** sin filtraciones. Con el enmascaramiento de punteros, tales sobrescrituras relativas **sin una filtraci贸n de heap ahora requieren fuerza bruta**, reduciendo dr谩sticamente su probabilidad de 茅xito.
2. **Aumento de la Dificultad de Ataques a Tcache Bin/Fastbin**: Los ataques comunes que sobrescriben punteros de funci贸n (como `__malloc_hook`) manipulando entradas de fastbin o tcache se ven obstaculizados. Por ejemplo, un ataque podr铆a implicar filtrar una direcci贸n de LibC, liberar un chunk en el tcache bin y luego sobrescribir el puntero Fd para redirigirlo a `__malloc_hook` para ejecuci贸n de c贸digo arbitrario. Con el enmascaramiento de punteros, estos punteros deben enmascararse correctamente, **necesitando una filtraci贸n de heap para una manipulaci贸n precisa**, elevando as铆 la barrera de explotaci贸n.
3. **Requisito de Filtraciones de Heap en Ubicaciones No-Heap**: Crear un chunk falso en 谩reas no-heap (como la pila, secci贸n .bss o PLT/GOT) ahora tambi茅n **requiere una filtraci贸n de heap** debido a la necesidad de enmascaramiento de punteros. Esto extiende la complejidad de explotar estas 谩reas, similar al requisito de manipulaci贸n de direcciones de LibC.
4. **Hacer Filtraciones de Direcciones de Heap se Vuelve M谩s Desafiante**: El enmascaramiento de punteros restringe la utilidad de los punteros Fd en fastbin y tcache bins como fuentes de filtraciones de direcciones de heap. Sin embargo, los punteros en bins no ordenados, peque帽os y grandes permanecen sin enmascarar, a煤n siendo utilizables para filtrar direcciones. Este cambio empuja a los atacantes a explorar estos bins en busca de informaci贸n explotable, aunque algunas t茅cnicas a煤n pueden permitir desenmascarar punteros antes de una filtraci贸n, aunque con limitaciones.

### **Desenmascaramiento de Punteros con una Filtraci贸n de Heap**

{% hint style="danger" %}
Para una mejor explicaci贸n del proceso [**consulta la publicaci贸n original desde aqu铆**](https://maxwelldulin.com/BlogPost?post=5445977088).
{% endhint %}

### Resumen del Algoritmo

La f贸rmula utilizada para enmascarar y desenmascarar punteros es:&#x20;

**`Nuevo_Ptr = (L >> 12) XOR P`**

Donde **L** es la ubicaci贸n de almacenamiento y **P** es el puntero Fd. Cuando **L** se desplaza hacia la derecha por 12 bits, expone los bits m谩s significativos de **P**, debido a la naturaleza de **XOR**, que produce 0 cuando los bits se XOR con ellos mismos.

**Pasos Clave en el Algoritmo:**

1. **Filtraci贸n Inicial de los Bits M谩s Significativos**: Al hacer XOR entre el **L** desplazado y **P**, obtienes efectivamente los 12 bits superiores de **P** porque la parte desplazada de **L** ser谩 cero, dejando los bits correspondientes de **P** sin cambios.
2. **Recuperaci贸n de Bits del Puntero**: Dado que XOR es reversible, conocer el resultado y uno de los operandos te permite calcular el otro operando. Esta propiedad se utiliza para deducir el conjunto completo de bits para **P** al hacer XOR sucesivamente con conjuntos conocidos de bits con partes del puntero enmascarado.
3. **Desenmascaramiento Iterativo**: El proceso se repite, utilizando cada vez los bits de **P** reci茅n descubiertos del paso anterior para decodificar el siguiente segmento del puntero enmascarado, hasta que se recuperan todos los bits.
4. **Manejo de Bits Deterministas**: Los 煤ltimos 12 bits de **L** se pierden debido al desplazamiento, pero son deterministas y pueden reconstruirse despu茅s del proceso.

Puedes encontrar una implementaci贸n de este algoritmo aqu铆: [https://github.com/mdulin2/mangle](https://github.com/mdulin2/mangle)
## Protecci贸n de Punteros

Pointer guard es una t茅cnica de mitigaci贸n de exploits utilizada en glibc para proteger los punteros de funciones almacenados, especialmente aquellos registrados por llamadas de biblioteca como `atexit()`. Esta protecci贸n implica mezclar los punteros mediante XOR con un secreto almacenado en los datos del hilo (`fs:0x30`) y aplicar una rotaci贸n de bits. Este mecanismo tiene como objetivo evitar que los atacantes secuestren el flujo de control sobrescribiendo punteros de funciones.

### **Burlando Pointer Guard con una fuga**

1. **Entendiendo las Operaciones de Pointer Guard:** El mezclado de punteros se realiza utilizando la macro `PTR_MANGLE` que realiza XOR con el puntero con un secreto de 64 bits y luego realiza una rotaci贸n a la izquierda de 0x11 bits. La operaci贸n inversa para recuperar el puntero original es manejada por `PTR_DEMANGLE`.
2. **Estrategia de Ataque:** El ataque se basa en un enfoque de texto plano conocido, donde el atacante necesita conocer tanto la versi贸n original como la mezclada de un puntero para deducir el secreto utilizado para el mezclado.
3. **Explotando Textos Planos Conocidos:**
* **Identificando Punteros de Funciones Fijos:** Al examinar el c贸digo fuente de glibc o tablas de punteros de funciones inicializadas (como `__libc_pthread_functions`), un atacante puede encontrar punteros de funciones predecibles.
* **Calculando el Secreto:** Utilizando un puntero de funci贸n conocido como `__pthread_attr_destroy` y su versi贸n mezclada de la tabla de punteros de funciones, el secreto se puede calcular mediante una rotaci贸n inversa (rotaci贸n a la derecha) del puntero mezclado y luego XOR con la direcci贸n de la funci贸n.
4. **Textos Planos Alternativos:** El atacante tambi茅n puede experimentar con la mezcla de punteros con valores conocidos como 0 o -1 para ver si estos producen patrones identificables en la memoria, potencialmente revelando el secreto cuando se encuentran estos patrones en volcados de memoria.
5. **Aplicaci贸n Pr谩ctica:** Despu茅s de calcular el secreto, un atacante puede manipular punteros de manera controlada, esencialmente burlando la protecci贸n de Pointer Guard en una aplicaci贸n multiproceso con conocimiento de la direcci贸n base de libc y la capacidad de leer ubicaciones de memoria arbitrarias.

## Referencias

* [https://maxwelldulin.com/BlogPost?post=5445977088](https://maxwelldulin.com/BlogPost?post=5445977088)
* [https://blog.infosectcbr.com.au/2020/04/bypassing-pointer-guard-in-linuxs-glibc.html?m=1](https://blog.infosectcbr.com.au/2020/04/bypassing-pointer-guard-in-linuxs-glibc.html?m=1)
