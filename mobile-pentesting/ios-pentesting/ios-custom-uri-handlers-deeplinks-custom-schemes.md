<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>â˜ï¸ HackTricks Cloud â˜ï¸</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>ğŸ¦ Twitter ğŸ¦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>ğŸ™ï¸ Twitch ğŸ™ï¸</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>ğŸ¥ Youtube ğŸ¥</strong></a></summary>

- VocÃª trabalha em uma **empresa de ciberseguranÃ§a**? VocÃª quer ver sua **empresa anunciada no HackTricks**? ou vocÃª quer ter acesso Ã  **Ãºltima versÃ£o do PEASS ou baixar o HackTricks em PDF**? Confira os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!

- Descubra [**A FamÃ­lia PEASS**](https://opensea.io/collection/the-peass-family), nossa coleÃ§Ã£o exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)

- Adquira o [**swag oficial do PEASS & HackTricks**](https://peass.creator-spring.com)

- **Junte-se ao** [**ğŸ’¬**](https://emojipedia.org/speech-balloon/) [**grupo Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo telegram**](https://t.me/peass) ou **siga-me** no **Twitter** [**ğŸ¦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks_live)**.**

- **Compartilhe suas tÃ©cnicas de hacking enviando PRs para o [repositÃ³rio hacktricks](https://github.com/carlospolop/hacktricks) e [hacktricks-cloud repo](https://github.com/carlospolop/hacktricks-cloud)**.

</details>


Os esquemas de URL personalizados [permitem que os aplicativos se comuniquem por meio de um protocolo personalizado](https://developer.apple.com/library/content/documentation/iPhone/Conceptual/iPhoneOSProgrammingGuide/Inter-AppCommunication/Inter-AppCommunication.html#//apple\_ref/doc/uid/TP40007072-CH6-SW1). Um aplicativo deve declarar suporte para os esquemas e lidar com URLs de entrada que usam esses esquemas.

> Os esquemas de URL oferecem um vetor de ataque potencial para o seu aplicativo, portanto, certifique-se de **validar todos os parÃ¢metros de URL** e **descartar URLs malformados**. AlÃ©m disso, limite as **aÃ§Ãµes** disponÃ­veis para aquelas que **nÃ£o colocam em risco os dados do usuÃ¡rio**.

Por exemplo, a URI: `myapp://hostname?data=123876123` irÃ¡ **invocar** o **aplicativo** mydata (aquele que **registrou** o esquema `mydata`) para a **aÃ§Ã£o** relacionada ao **hostname** `hostname` enviando o **parÃ¢metro** `data` com valor `123876123`.

Um exemplo vulnerÃ¡vel Ã© o seguinte [bug no aplicativo mÃ³vel do Skype](http://www.dhanjani.com/blog/2010/11/insecure-handling-of-url-schemes-in-apples-ios.html), descoberto em 2010: O aplicativo Skype registrou o manipulador de protocolo `skype://`, o que **permitiu que outros aplicativos acionassem chamadas para outros usuÃ¡rios do Skype e nÃºmeros de telefone**. Infelizmente, o Skype nÃ£o pediu permissÃ£o aos usuÃ¡rios antes de fazer as chamadas, entÃ£o qualquer aplicativo poderia ligar para nÃºmeros arbitrÃ¡rios sem o conhecimento do usuÃ¡rio. Os atacantes exploraram essa vulnerabilidade colocando um `<iframe src="skype://xxx?call"></iframe>` invisÃ­vel (onde `xxx` foi substituÃ­do por um nÃºmero premium), entÃ£o qualquer usuÃ¡rio do Skype que inadvertidamente visitasse um site malicioso chamava o nÃºmero premium.

VocÃª pode encontrar os **esquemas registrados por um aplicativo** no arquivo **`Info.plist`** do aplicativo procurando por **`CFBundleURLTypes`** (exemplo do [iGoat-Swift](https://github.com/OWASP/iGoat-Swift)):
```markup
<key>CFBundleURLTypes</key>
<array>
    <dict>
        <key>CFBundleURLName</key>
        <string>com.iGoat.myCompany</string>
        <key>CFBundleURLSchemes</key>
        <array>
            <string>iGoat</string>
        </array>
    </dict>
</array>
```
No entanto, observe que **aplicativos maliciosos podem registrar novamente URIs** jÃ¡ registrados por outros aplicativos. Portanto, se vocÃª estiver enviando **informaÃ§Ãµes confidenciais por meio de URIs** (myapp://hostname?password=123456), um aplicativo **malicioso** pode **interceptar** a URI com as **informaÃ§Ãµes confidenciais**.

AlÃ©m disso, a entrada dessas URIs **deve ser verificada e sanitizada**, pois pode estar vindo de **origens maliciosas** tentando explorar SQLInjections, XSS, CSRF, Traversals de Caminho ou outras possÃ­veis vulnerabilidades.

## Registro de Esquemas de Consulta do Aplicativo

Os aplicativos podem chamar [`canOpenURL:`](https://developer.apple.com/documentation/uikit/uiapplication/1622952-canopenurl?language=objc) para verificar se o **aplicativo de destino estÃ¡ disponÃ­vel**. No entanto, como esse mÃ©todo estava sendo usado por aplicativos maliciosos como uma forma de **enumerar aplicativos instalados**, [a partir do iOS 9.0, os esquemas de URL passados para ele tambÃ©m devem ser declarados](https://developer.apple.com/documentation/uikit/uiapplication/1622952-canopenurl?language=objc#discussion) adicionando a chave `LSApplicationQueriesSchemes` ao arquivo `Info.plist` do aplicativo e um array de **atÃ© 50 esquemas de URL**.
```markup
<key>LSApplicationQueriesSchemes</key>
    <array>
        <string>url_scheme1</string>
        <string>url_scheme2</string>
    </array>
```
`canOpenURL` sempre retornarÃ¡ `NO` para esquemas nÃ£o declarados, independentemente de um aplicativo apropriado estar instalado ou nÃ£o. No entanto, essa restriÃ§Ã£o se aplica apenas ao `canOpenURL`.

## Testando o Manuseio e ValidaÃ§Ã£o de URLs

Para determinar como um caminho de URL Ã© construÃ­do e validado, se vocÃª tiver o cÃ³digo-fonte original, pode **procurar pelos seguintes mÃ©todos**:

* MÃ©todo `application:didFinishLaunchingWithOptions:` ou `application:will-FinishLaunchingWithOptions:`: verifique como a decisÃ£o Ã© tomada e como as informaÃ§Ãµes sobre a URL sÃ£o recuperadas.
* [`application:openURL:options:`](https://developer.apple.com/documentation/uikit/uiapplicationdelegate/1623112-application?language=objc): verifique como o recurso estÃ¡ sendo aberto, ou seja, como os dados estÃ£o sendo analisados, verifique as [opÃ§Ãµes](https://developer.apple.com/documentation/uikit/uiapplication/openurloptionskey), especialmente se o acesso pelo aplicativo chamador ([`sourceApplication`](https://developer.apple.com/documentation/uikit/uiapplication/openurloptionskey/1623128-sourceapplication)) deve ser permitido ou negado. O aplicativo tambÃ©m pode precisar da permissÃ£o do usuÃ¡rio ao usar o esquema de URL personalizado.

No Telegram, vocÃª encontrarÃ¡ [quatro mÃ©todos diferentes sendo usados](https://github.com/peter-iakovlev/Telegram-iOS/blob/87e0a33ac438c1d702f2a0b75bf21f26866e346f/Telegram-iOS/AppDelegate.swift#L1250):
```swift
func application(_ application: UIApplication, open url: URL, sourceApplication: String?) -> Bool {
    self.openUrl(url: url)
    return true
}

func application(_ application: UIApplication, open url: URL, sourceApplication: String?,
annotation: Any) -> Bool {
    self.openUrl(url: url)
    return true
}

func application(_ app: UIApplication, open url: URL,
options: [UIApplicationOpenURLOptionsKey : Any] = [:]) -> Bool {
    self.openUrl(url: url)
    return true
}

func application(_ application: UIApplication, handleOpen url: URL) -> Bool {
    self.openUrl(url: url)
    return true
}
```
## Testando solicitaÃ§Ãµes de URL para outros aplicativos

O mÃ©todo [`openURL:options:completionHandler:`](https://developer.apple.com/documentation/uikit/uiapplication/1648685-openurl?language=objc) e o mÃ©todo [obsoleto `openURL:` da `UIApplication`](https://developer.apple.com/documentation/uikit/uiapplication/1622961-openurl?language=objc) sÃ£o responsÃ¡veis por **abrir URLs** (ou seja, enviar solicitaÃ§Ãµes / fazer consultas para outros aplicativos) que podem ser locais para o aplicativo atual ou podem ser fornecidos por um aplicativo diferente. Se vocÃª tiver o cÃ³digo-fonte original, poderÃ¡ procurar diretamente por usos desses mÃ©todos.

AlÃ©m disso, se vocÃª estiver interessado em saber se o aplicativo estÃ¡ consultando serviÃ§os ou aplicativos especÃ­ficos e se o aplicativo Ã© bem conhecido, tambÃ©m pode pesquisar por esquemas de URL comuns online e incluÃ­-los em seus **greps (lista de esquemas de aplicativos iOS)**.
```bash
egrep -nr "open.*options.*completionHandler" ./Telegram-iOS/
egrep -nr "openURL\(" ./Telegram-iOS/
egrep -nr "mt-encrypted-file://" ./Telegram-iOS/
egrep -nr "://" ./Telegram-iOS/
```
## Testando MÃ©todos Obsoletos

Procure por mÃ©todos obsoletos como:

* [`application:handleOpenURL:`](https://developer.apple.com/documentation/uikit/uiapplicationdelegate/1622964-application?language=objc)
* [`openURL:`](https://developer.apple.com/documentation/uikit/uiapplication/1622961-openurl?language=objc)
* [`application:openURL:sourceApplication:annotation:`](https://developer.apple.com/documentation/uikit/uiapplicationdelegate/1623073-application)

Por exemplo, aqui encontramos esses trÃªs:
```bash
$ rabin2 -zzq Telegram\ X.app/Telegram\ X | grep -i "openurl"

0x1000d9e90 31 30 UIApplicationOpenURLOptionsKey
0x1000dee3f 50 49 application:openURL:sourceApplication:annotation:
0x1000dee71 29 28 application:openURL:options:
0x1000dee8e 27 26 application:handleOpenURL:
0x1000df2c9 9 8 openURL:
0x1000df766 12 11 canOpenURL:
0x1000df772 35 34 openURL:options:completionHandler:
...
```
## Chamando URLs arbitrÃ¡rias

* **Safari**: Para testar rapidamente um esquema de URL, vocÃª pode abrir as URLs no Safari e observar como o aplicativo se comporta. Por exemplo, se vocÃª escrever `tel://123456789`, o Safari tentarÃ¡ iniciar a chamada para o nÃºmero.
* **Notes App**: Pressione longamente os links que vocÃª escreveu para testar esquemas de URL personalizados. Lembre-se de sair do modo de ediÃ§Ã£o para poder abri-los. Observe que vocÃª pode clicar ou pressionar links, incluindo esquemas de URL personalizados, somente se o aplicativo estiver instalado, caso contrÃ¡rio, eles nÃ£o serÃ£o destacados como _links clicÃ¡veis_.
* [**IDB**](https://github.com/facebook/idb):
  * Inicie o IDB, conecte-se ao seu dispositivo e selecione o aplicativo de destino. VocÃª pode encontrar detalhes na [documentaÃ§Ã£o do IDB](https://www.idbtool.com/documentation/setup.html).
  * VÃ¡ para a seÃ§Ã£o **URL Handlers**. Em **URL schemes**, clique em **Refresh**, e Ã  esquerda vocÃª encontrarÃ¡ uma lista de todos os esquemas personalizados definidos no aplicativo em teste. VocÃª pode carregar esses esquemas clicando em **Open**, no lado direito. Ao simplesmente abrir um esquema de URI em branco (por exemplo, abrindo `myURLscheme://`), vocÃª pode descobrir funcionalidades ocultas (por exemplo, uma janela de depuraÃ§Ã£o) e contornar a autenticaÃ§Ã£o local.
*   **Frida**:

    Se vocÃª simplesmente deseja abrir o esquema de URL, pode fazÃª-lo usando o Frida:

    ```javascript
    $ frida -U iGoat-Swift

    [iPhone::iGoat-Swift]-> function openURL(url) {
                                var UIApplication = ObjC.classes.UIApplication.sharedApplication();
                                var toOpen = ObjC.classes.NSURL.URLWithString_(url);
                                return UIApplication.openURL_(toOpen);
                            }
    [iPhone::iGoat-Swift]-> openURL("tel://234234234")
    true
    ```

    Neste exemplo do [Frida CodeShare](https://codeshare.frida.re/@dki/ios-url-scheme-fuzzing/), o autor usa a API nÃ£o pÃºblica `LSApplicationWorkspace.openSensitiveURL:withOptions:` para abrir as URLs (do aplicativo SpringBoard):

    ```javascript
    function openURL(url) {
        var w = ObjC.classes.LSApplicationWorkspace.defaultWorkspace();
        var toOpen = ObjC.classes.NSURL.URLWithString_(url);
        return w.openSensitiveURL_withOptions_(toOpen, null);
    }
    ```

    > Observe que o uso de APIs nÃ£o pÃºblicas nÃ£o Ã© permitido na App Store, Ã© por isso que nem mesmo testamos essas APIs, mas podemos usÃ¡-las para nossa anÃ¡lise dinÃ¢mica.

## Fuzzing de Esquemas de URL

Se o aplicativo analisa partes da URL, vocÃª tambÃ©m pode realizar fuzzing de entrada para detectar bugs de corrupÃ§Ã£o de memÃ³ria.

O que aprendemos acima pode ser usado agora para construir seu prÃ³prio fuzzer na linguagem de sua escolha, por exemplo, em Python e chamar o `openURL` usando o [RPC do Frida](https://www.frida.re/docs/javascript-api/#rpc). Esse fuzzer deve fazer o seguinte:

* Gerar payloads.
* Para cada um deles, chame `openURL`.
* Verifique se o aplicativo gera um relatÃ³rio de falha (`.ips`) em `/private/var/mobile/Library/Logs/CrashReporter`.

O projeto [FuzzDB](https://github.com/fuzzdb-project/fuzzdb) oferece dicionÃ¡rios de fuzzing que vocÃª pode usar como payloads.

## **Fuzzing Usando Frida**

Fazer isso com o Frida Ã© bastante fÃ¡cil, vocÃª pode se referir a este [post de blog](https://grepharder.github.io/blog/0x03\_learning\_about\_universal\_links\_and\_fuzzing\_url\_schemes\_on\_ios\_with\_frida.html) para ver um exemplo que faz fuzzing do aplicativo iGoat-Swift (funcionando no iOS 11.1.2).

Antes de executar o fuzzer, precisamos dos esquemas de URL como entradas. A partir da anÃ¡lise estÃ¡tica, sabemos que o aplicativo iGoat-Swift suporta o seguinte esquema de URL e parÃ¢metros: `iGoat://?contactNumber={0}&message={0}`.
```bash
$ frida -U SpringBoard -l ios-url-scheme-fuzzing.js
[iPhone::SpringBoard]-> fuzz("iGoat", "iGoat://?contactNumber={0}&message={0}")
Watching for crashes from iGoat...
No logs were moved.
Opened URL: iGoat://?contactNumber=0&message=0
```
# ReferÃªncias

{% embed url="https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06h-testing-platform-interaction#testing-object-persistence-mstg-platform-8" %}



<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>â˜ï¸ HackTricks Cloud â˜ï¸</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>ğŸ¦ Twitter ğŸ¦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>ğŸ™ï¸ Twitch ğŸ™ï¸</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>ğŸ¥ Youtube ğŸ¥</strong></a></summary>

- VocÃª trabalha em uma **empresa de ciberseguranÃ§a**? VocÃª quer ver sua **empresa anunciada no HackTricks**? ou vocÃª quer ter acesso Ã  **Ãºltima versÃ£o do PEASS ou baixar o HackTricks em PDF**? Confira os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!

- Descubra [**A FamÃ­lia PEASS**](https://opensea.io/collection/the-peass-family), nossa coleÃ§Ã£o exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)

- Adquira o [**swag oficial do PEASS & HackTricks**](https://peass.creator-spring.com)

- **Junte-se ao** [**ğŸ’¬**](https://emojipedia.org/speech-balloon/) [**grupo do Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo do telegram**](https://t.me/peass) ou **siga-me** no **Twitter** [**ğŸ¦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks_live)**.**

- **Compartilhe suas tÃ©cnicas de hacking enviando PRs para o [repositÃ³rio hacktricks](https://github.com/carlospolop/hacktricks) e [repositÃ³rio hacktricks-cloud](https://github.com/carlospolop/hacktricks-cloud)**.

</details>
