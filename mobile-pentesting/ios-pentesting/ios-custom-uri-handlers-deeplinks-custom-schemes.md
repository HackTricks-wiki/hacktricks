<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>â˜ï¸ HackTricks Cloud â˜ï¸</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>ğŸ¦ Twitter ğŸ¦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>ğŸ™ï¸ Twitch ğŸ™ï¸</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>ğŸ¥ Youtube ğŸ¥</strong></a></summary>

- Â¿Trabajas en una **empresa de ciberseguridad**? Â¿Quieres ver tu **empresa anunciada en HackTricks**? Â¿O quieres tener acceso a la **Ãºltima versiÃ³n de PEASS o descargar HackTricks en PDF**? Â¡Consulta los [**PLANES DE SUSCRIPCIÃ“N**](https://github.com/sponsors/carlospolop)!

- Descubre [**The PEASS Family**](https://opensea.io/collection/the-peass-family), nuestra colecciÃ³n exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)

- ObtÃ©n la [**oficial PEASS & HackTricks swag**](https://peass.creator-spring.com)

- **Ãšnete al** [**ğŸ’¬**](https://emojipedia.org/speech-balloon/) [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **sÃ­gueme** en **Twitter** [**ğŸ¦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks_live)**.**

- **Comparte tus trucos de hacking enviando PRs al [repositorio de hacktricks](https://github.com/carlospolop/hacktricks) y al [repositorio de hacktricks-cloud](https://github.com/carlospolop/hacktricks-cloud)**.

</details>


Los esquemas de URL personalizados [permiten que las aplicaciones se comuniquen a travÃ©s de un protocolo personalizado](https://developer.apple.com/library/content/documentation/iPhone/Conceptual/iPhoneOSProgrammingGuide/Inter-AppCommunication/Inter-AppCommunication.html#//apple\_ref/doc/uid/TP40007072-CH6-SW1). Una aplicaciÃ³n debe declarar el soporte para los esquemas y manejar las URL entrantes que usan esos esquemas.

> Los esquemas de URL ofrecen un posible vector de ataque a su aplicaciÃ³n, asÃ­ que asegÃºrese de **validar todos los parÃ¡metros de URL** y **descartar cualquier URL malformada**. AdemÃ¡s, limite las **acciones** disponibles a aquellas que **no pongan en riesgo los datos del usuario**.

Por ejemplo, la URI: `myapp://hostname?data=123876123` **invocarÃ¡** la **aplicaciÃ³n** mydata (la que ha **registrado** el esquema `mydata`) a la **acciÃ³n** relacionada con el **hostname** `hostname` enviando el **parÃ¡metro** `data` con valor `123876123`.

Un ejemplo vulnerable es el siguiente [bug en la aplicaciÃ³n mÃ³vil de Skype](http://www.dhanjani.com/blog/2010/11/insecure-handling-of-url-schemes-in-apples-ios.html), descubierto en 2010: La aplicaciÃ³n de Skype registrÃ³ el manejador de protocolo `skype://`, lo que **permitiÃ³ que otras aplicaciones activaran llamadas a otros usuarios de Skype y nÃºmeros de telÃ©fono**. Desafortunadamente, Skype no solicitÃ³ permiso a los usuarios antes de realizar las llamadas, por lo que cualquier aplicaciÃ³n podÃ­a llamar a nÃºmeros arbitrarios sin el conocimiento del usuario. Los atacantes explotaron esta vulnerabilidad colocando un `<iframe src="skype://xxx?call"></iframe>` invisible (donde `xxx` fue reemplazado por un nÃºmero premium), por lo que cualquier usuario de Skype que visitara inadvertidamente un sitio web malicioso llamaba al nÃºmero premium.

Puede encontrar los **esquemas registrados por una aplicaciÃ³n** en el archivo **`Info.plist`** de la aplicaciÃ³n buscando **`CFBundleURLTypes`** (ejemplo de [iGoat-Swift](https://github.com/OWASP/iGoat-Swift)):
```markup
<key>CFBundleURLTypes</key>
<array>
    <dict>
        <key>CFBundleURLName</key>
        <string>com.iGoat.myCompany</string>
        <key>CFBundleURLSchemes</key>
        <array>
            <string>iGoat</string>
        </array>
    </dict>
</array>
```
Sin embargo, tenga en cuenta que las aplicaciones maliciosas pueden volver a registrar URIs ya registrados por otras aplicaciones. Por lo tanto, si estÃ¡ enviando informaciÃ³n sensible a travÃ©s de URIs (myapp://hostname?password=123456), una aplicaciÃ³n maliciosa puede interceptar el URI con la informaciÃ³n sensible.

AdemÃ¡s, la entrada de estos URIs debe ser verificada y saneada, ya que puede provenir de orÃ­genes maliciosos que intentan explotar SQLInjections, XSS, CSRF, Path Traversals u otras posibles vulnerabilidades.

## Registro de esquemas de consulta de aplicaciones

Las aplicaciones pueden llamar a [`canOpenURL:`](https://developer.apple.com/documentation/uikit/uiapplication/1622952-canopenurl?language=objc) para verificar que la aplicaciÃ³n de destino estÃ¡ disponible. Sin embargo, como este mÃ©todo estaba siendo utilizado por aplicaciones maliciosas como una forma de enumerar aplicaciones instaladas, [a partir de iOS 9.0, los esquemas de URL pasados a Ã©l tambiÃ©n deben ser declarados](https://developer.apple.com/documentation/uikit/uiapplication/1622952-canopenurl?language=objc#discussion) agregando la clave `LSApplicationQueriesSchemes` al archivo `Info.plist` de la aplicaciÃ³n y un array de hasta 50 esquemas de URL.
```markup
<key>LSApplicationQueriesSchemes</key>
    <array>
        <string>url_scheme1</string>
        <string>url_scheme2</string>
    </array>
```
`canOpenURL` siempre devolverÃ¡ `NO` para los esquemas no declarados, independientemente de si hay o no una aplicaciÃ³n adecuada instalada. Sin embargo, esta restricciÃ³n solo se aplica a `canOpenURL`.

## Pruebas de manejo y validaciÃ³n de URL

Para determinar cÃ³mo se construye y valida una ruta de URL, si tiene el cÃ³digo fuente original, puede **buscar los siguientes mÃ©todos**:

* MÃ©todo `application:didFinishLaunchingWithOptions:` o `application:will-FinishLaunchingWithOptions:`: verifique cÃ³mo se toma la decisiÃ³n y cÃ³mo se recupera la informaciÃ³n sobre la URL.
* [`application:openURL:options:`](https://developer.apple.com/documentation/uikit/uiapplicationdelegate/1623112-application?language=objc): verifique cÃ³mo se abre el recurso, es decir, cÃ³mo se analizan los datos, verifique las [opciones](https://developer.apple.com/documentation/uikit/uiapplication/openurloptionskey), especialmente si se debe permitir o denegar el acceso por parte de la aplicaciÃ³n que llama ([`sourceApplication`](https://developer.apple.com/documentation/uikit/uiapplication/openurloptionskey/1623128-sourceapplication)). La aplicaciÃ³n tambiÃ©n puede necesitar permiso del usuario al usar el esquema de URL personalizado.

En Telegram [encontrarÃ¡ cuatro mÃ©todos diferentes que se utilizan](https://github.com/peter-iakovlev/Telegram-iOS/blob/87e0a33ac438c1d702f2a0b75bf21f26866e346f/Telegram-iOS/AppDelegate.swift#L1250):
```swift
func application(_ application: UIApplication, open url: URL, sourceApplication: String?) -> Bool {
    self.openUrl(url: url)
    return true
}

func application(_ application: UIApplication, open url: URL, sourceApplication: String?,
annotation: Any) -> Bool {
    self.openUrl(url: url)
    return true
}

func application(_ app: UIApplication, open url: URL,
options: [UIApplicationOpenURLOptionsKey : Any] = [:]) -> Bool {
    self.openUrl(url: url)
    return true
}

func application(_ application: UIApplication, handleOpen url: URL) -> Bool {
    self.openUrl(url: url)
    return true
}
```
## Probando solicitudes de URL a otras aplicaciones

El mÃ©todo [`openURL:options:completionHandler:`](https://developer.apple.com/documentation/uikit/uiapplication/1648685-openurl?language=objc) y el mÃ©todo [obsoleto `openURL:` de `UIApplication`](https://developer.apple.com/documentation/uikit/uiapplication/1622961-openurl?language=objc) son responsables de **abrir URLs** (es decir, enviar solicitudes / hacer consultas a otras aplicaciones) que pueden ser locales para la aplicaciÃ³n actual o pueden ser proporcionadas por una aplicaciÃ³n diferente. Si tiene el cÃ³digo fuente original, puede buscar directamente los usos de esos mÃ©todos.

AdemÃ¡s, si estÃ¡ interesado en saber si la aplicaciÃ³n estÃ¡ consultando servicios o aplicaciones especÃ­ficas, y si la aplicaciÃ³n es conocida, tambiÃ©n puede buscar en lÃ­nea los esquemas de URL comunes e incluirlos en sus **greps (l**[**ista de esquemas de aplicaciones iOS**](https://ios.gadgethacks.com/how-to/always-updated-list-ios-app-url-scheme-names-paths-for-shortcuts-0184033/)**)**.
```bash
egrep -nr "open.*options.*completionHandler" ./Telegram-iOS/
egrep -nr "openURL\(" ./Telegram-iOS/
egrep -nr "mt-encrypted-file://" ./Telegram-iOS/
egrep -nr "://" ./Telegram-iOS/
```
## Pruebas para mÃ©todos obsoletos

Busque mÃ©todos obsoletos como:

* [`application:handleOpenURL:`](https://developer.apple.com/documentation/uikit/uiapplicationdelegate/1622964-application?language=objc)
* [`openURL:`](https://developer.apple.com/documentation/uikit/uiapplication/1622961-openurl?language=objc)
* [`application:openURL:sourceApplication:annotation:`](https://developer.apple.com/documentation/uikit/uiapplicationdelegate/1623073-application)

Por ejemplo, aquÃ­ encontramos esos tres:
```bash
$ rabin2 -zzq Telegram\ X.app/Telegram\ X | grep -i "openurl"

0x1000d9e90 31 30 UIApplicationOpenURLOptionsKey
0x1000dee3f 50 49 application:openURL:sourceApplication:annotation:
0x1000dee71 29 28 application:openURL:options:
0x1000dee8e 27 26 application:handleOpenURL:
0x1000df2c9 9 8 openURL:
0x1000df766 12 11 canOpenURL:
0x1000df772 35 34 openURL:options:completionHandler:
...
```
## Llamando a URLs arbitrarias

* **Safari**: Para probar rÃ¡pidamente un esquema de URL, puedes abrir las URLs en Safari y observar cÃ³mo se comporta la aplicaciÃ³n. Por ejemplo, si escribes `tel://123456789`, Safari intentarÃ¡ iniciar una llamada al nÃºmero.
* **Notes App**: MantÃ©n presionados los enlaces que has escrito para probar los esquemas de URL personalizados. Recuerda salir del modo de ediciÃ³n para poder abrirlos. Ten en cuenta que solo puedes hacer clic o mantener presionados los enlaces que incluyen esquemas de URL personalizados si la aplicaciÃ³n estÃ¡ instalada, de lo contrario no se resaltarÃ¡n como _enlaces clicables_.
* [**IDB**](https://github.com/facebook/idb):
  * Inicia IDB, conecta tu dispositivo y selecciona la aplicaciÃ³n objetivo. Puedes encontrar detalles en la [documentaciÃ³n de IDB](https://www.idbtool.com/documentation/setup.html).
  * Ve a la secciÃ³n **Manejadores de URL**. En **Esquemas de URL**, haz clic en **Actualizar**, y a la izquierda encontrarÃ¡s una lista de todos los esquemas personalizados definidos en la aplicaciÃ³n que se estÃ¡ probando. Puedes cargar estos esquemas haciendo clic en **Abrir**, en el lado derecho. Simplemente abriendo un esquema de URI en blanco (por ejemplo, abriendo `myURLscheme://`), puedes descubrir funcionalidades ocultas (por ejemplo, una ventana de depuraciÃ³n) y evitar la autenticaciÃ³n local.
*   **Frida**:

    Si simplemente quieres abrir el esquema de URL, puedes hacerlo usando Frida:

    ```javascript
    $ frida -U iGoat-Swift

    [iPhone::iGoat-Swift]-> function openURL(url) {
                                var UIApplication = ObjC.classes.UIApplication.sharedApplication();
                                var toOpen = ObjC.classes.NSURL.URLWithString_(url);
                                return UIApplication.openURL_(toOpen);
                            }
    [iPhone::iGoat-Swift]-> openURL("tel://234234234")
    true
    ```

    En este ejemplo de [Frida CodeShare](https://codeshare.frida.re/@dki/ios-url-scheme-fuzzing/), el autor utiliza la API no pÃºblica `LSApplicationWorkspace.openSensitiveURL:withOptions:` para abrir las URLs (desde la aplicaciÃ³n SpringBoard):

    ```javascript
    function openURL(url) {
        var w = ObjC.classes.LSApplicationWorkspace.defaultWorkspace();
        var toOpen = ObjC.classes.NSURL.URLWithString_(url);
        return w.openSensitiveURL_withOptions_(toOpen, null);
    }
    ```

    > Ten en cuenta que el uso de APIs no pÃºblicas no estÃ¡ permitido en la App Store, por lo que ni siquiera las probamos, pero se nos permite usarlas para nuestro anÃ¡lisis dinÃ¡mico.

## Fuzzing de Esquemas de URL

Si la aplicaciÃ³n analiza partes de la URL, tambiÃ©n puedes realizar fuzzing de entrada para detectar errores de corrupciÃ³n de memoria.

Lo que hemos aprendido anteriormente ahora se puede utilizar para construir tu propio fuzzer en el lenguaje de tu elecciÃ³n, por ejemplo, en Python y llamar a `openURL` usando [RPC de Frida](https://www.frida.re/docs/javascript-api/#rpc). Ese fuzzer deberÃ­a hacer lo siguiente:

* Generar payloads.
* Para cada uno de ellos, llamar a `openURL`.
* Comprobar si la aplicaciÃ³n genera un informe de fallo (`.ips`) en `/private/var/mobile/Library/Logs/CrashReporter`.

El proyecto [FuzzDB](https://github.com/fuzzdb-project/fuzzdb) ofrece diccionarios de fuzzing que puedes usar como payloads.

## **Fuzzing Usando Frida**

Hacer esto con Frida es bastante fÃ¡cil, puedes consultar esta [publicaciÃ³n de blog](https://grepharder.github.io/blog/0x03\_learning\_about\_universal\_links\_and\_fuzzing\_url\_schemes\_on\_ios\_with\_frida.html) para ver un ejemplo que hace fuzzing de la aplicaciÃ³n iGoat-Swift (funcionando en iOS 11.1.2).

Antes de ejecutar el fuzzer, necesitamos los esquemas de URL como entradas. A partir del anÃ¡lisis estÃ¡tico, sabemos que la aplicaciÃ³n iGoat-Swift admite el siguiente esquema de URL y parÃ¡metros: `iGoat://?contactNumber={0}&message={0}`.
```bash
$ frida -U SpringBoard -l ios-url-scheme-fuzzing.js
[iPhone::SpringBoard]-> fuzz("iGoat", "iGoat://?contactNumber={0}&message={0}")
Watching for crashes from iGoat...
No logs were moved.
Opened URL: iGoat://?contactNumber=0&message=0
```
# Referencias

{% embed url="https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06h-testing-platform-interaction#testing-object-persistence-mstg-platform-8" %}



<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>â˜ï¸ HackTricks Cloud â˜ï¸</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>ğŸ¦ Twitter ğŸ¦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>ğŸ™ï¸ Twitch ğŸ™ï¸</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>ğŸ¥ Youtube ğŸ¥</strong></a></summary>

- Â¿Trabajas en una **empresa de ciberseguridad**? Â¿Quieres ver tu **empresa anunciada en HackTricks**? Â¿O quieres tener acceso a la **Ãºltima versiÃ³n de PEASS o descargar HackTricks en PDF**? Â¡Consulta los [**PLANES DE SUSCRIPCIÃ“N**](https://github.com/sponsors/carlospolop)!

- Descubre [**The PEASS Family**](https://opensea.io/collection/the-peass-family), nuestra colecciÃ³n exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)

- ObtÃ©n la [**oficial PEASS & HackTricks swag**](https://peass.creator-spring.com)

- **Ãšnete al** [**ğŸ’¬**](https://emojipedia.org/speech-balloon/) **grupo de Discord** o al [**grupo de telegram**](https://t.me/peass) o **sÃ­gueme en** **Twitter** [**ğŸ¦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks_live)**.**

- **Comparte tus trucos de hacking enviando PR al repositorio [hacktricks](https://github.com/carlospolop/hacktricks) y al repositorio [hacktricks-cloud](https://github.com/carlospolop/hacktricks-cloud)**.

</details>
