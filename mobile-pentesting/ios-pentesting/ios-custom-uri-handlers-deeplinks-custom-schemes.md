<details>

<summary><strong>Aprende hacking en AWS de cero a h茅roe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Otras formas de apoyar a HackTricks:

* Si quieres ver tu **empresa anunciada en HackTricks** o **descargar HackTricks en PDF**, consulta los [**PLANES DE SUSCRIPCIN**](https://github.com/sponsors/carlospolop)!
* Consigue el [**merchandising oficial de PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubre [**La Familia PEASS**](https://opensea.io/collection/the-peass-family), nuestra colecci贸n de [**NFTs exclusivos**](https://opensea.io/collection/the-peass-family)
* **nete al**  [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **sigue** a **Twitter**  [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Comparte tus trucos de hacking enviando PRs a los repositorios de GitHub de** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>


Los esquemas de URL personalizados [permiten que las aplicaciones se comuniquen a trav茅s de un protocolo personalizado](https://developer.apple.com/library/content/documentation/iPhone/Conceptual/iPhoneOSProgrammingGuide/Inter-AppCommunication/Inter-AppCommunication.html#//apple_ref/doc/uid/TP40007072-CH6-SW1). Una aplicaci贸n debe declarar soporte para los esquemas y manejar las URLs entrantes que utilizan esos esquemas.

> Los esquemas de URL ofrecen un vector de ataque potencial en tu aplicaci贸n, as铆 que aseg煤rate de **validar todos los par谩metros de la URL** y **descartar cualquier URL malformada**. Adem谩s, limita las **acciones** disponibles a aquellas que **no pongan en riesgo los datos del usuario**.

Por ejemplo, la URI: `myapp://hostname?data=123876123` **invocar谩** la **aplicaci贸n** mydata (la que ha **registrado** el esquema `mydata`) a la **acci贸n** relacionada con el **hostname** `hostname` enviando el **par谩metro** `data` con valor `123876123`

Un ejemplo vulnerable es el siguiente [bug en la aplicaci贸n m贸vil de Skype](http://www.dhanjani.com/blog/2010/11/insecure-handling-of-url-schemes-in-apples-ios.html), descubierto en 2010: La aplicaci贸n de Skype registr贸 el manejador del protocolo `skype://`, que **permit铆a a otras aplicaciones desencadenar llamadas a otros usuarios de Skype y n煤meros de tel茅fono**. Desafortunadamente, Skype no solicitaba permiso a los usuarios antes de realizar las llamadas, por lo que cualquier aplicaci贸n pod铆a llamar a n煤meros arbitrarios sin el conocimiento del usuario. Los atacantes explotaron esta vulnerabilidad colocando un `<iframe src="skype://xxx?call"></iframe>` invisible (donde `xxx` se reemplazaba por un n煤mero premium), as铆 que cualquier usuario de Skype que visitara inadvertidamente un sitio web malicioso llamaba al n煤mero premium.

Puedes encontrar los **esquemas registrados por una aplicaci贸n** en el archivo **`Info.plist`** de la aplicaci贸n buscando **`CFBundleURLTypes`** (ejemplo de [iGoat-Swift](https://github.com/OWASP/iGoat-Swift)):
```markup
<key>CFBundleURLTypes</key>
<array>
<dict>
<key>CFBundleURLName</key>
<string>com.iGoat.myCompany</string>
<key>CFBundleURLSchemes</key>
<array>
<string>iGoat</string>
</array>
</dict>
</array>
```
Sin embargo, ten en cuenta que **aplicaciones maliciosas pueden volver a registrar URIs** ya registradas por aplicaciones. Por lo tanto, si est谩s enviando **informaci贸n sensible a trav茅s de URIs** (myapp://hostname?password=123456), una aplicaci贸n **maliciosa** puede **interceptar** la URI con la **informaci贸n** **sensible**.

Adem谩s, la entrada de estas URIs **debe ser verificada y saneada**, ya que puede provenir de **or铆genes maliciosos** que intentan explotar SQLInjections, XSS, CSRF, Path Traversals u otras posibles vulnerabilidades.

## Registro de Esquemas de Consulta de Aplicaciones

Las aplicaciones pueden llamar a [`canOpenURL:`](https://developer.apple.com/documentation/uikit/uiapplication/1622952-canopenurl?language=objc) para verificar que la **aplicaci贸n objetivo est谩 disponible**. Sin embargo, como este m茅todo estaba siendo utilizado por aplicaciones maliciosas como una forma de **enumerar aplicaciones instaladas**, [desde iOS 9.0 los esquemas de URL pasados a este deben ser tambi茅n declarados](https://developer.apple.com/documentation/uikit/uiapplication/1622952-canopenurl?language=objc#discussion) agregando la clave `LSApplicationQueriesSchemes` al archivo `Info.plist` de la aplicaci贸n y un arreglo de **hasta 50 esquemas de URL**.
```markup
<key>LSApplicationQueriesSchemes</key>
<array>
<string>url_scheme1</string>
<string>url_scheme2</string>
</array>
```
`canOpenURL` siempre devolver谩 `NO` para esquemas no declarados, independientemente de si hay una aplicaci贸n apropiada instalada o no. Sin embargo, esta restricci贸n solo se aplica a `canOpenURL`.

## Pruebas de Manejo y Validaci贸n de URL

Para determinar c贸mo se construye y valida una ruta de URL, si tienes el c贸digo fuente original, puedes **buscar los siguientes m茅todos**:

* M茅todo `application:didFinishLaunchingWithOptions:` o `application:willFinishLaunchingWithOptions:`: verifica c贸mo se toma la decisi贸n y c贸mo se recupera la informaci贸n sobre la URL.
* [`application:openURL:options:`](https://developer.apple.com/documentation/uikit/uiapplicationdelegate/1623112-application?language=objc): verifica c贸mo se est谩 abriendo el recurso, es decir, c贸mo se est谩 analizando la informaci贸n, verifica las [opciones](https://developer.apple.com/documentation/uikit/uiapplication/openurloptionskey), especialmente si se debe permitir o denegar el acceso por la aplicaci贸n llamadora ([`sourceApplication`](https://developer.apple.com/documentation/uikit/uiapplication/openurloptionskey/1623128-sourceapplication)). La aplicaci贸n tambi茅n podr铆a necesitar permiso del usuario al usar el esquema de URL personalizado.

En Telegram encontrar谩s [cuatro m茅todos diferentes que se utilizan](https://github.com/peter-iakovlev/Telegram-iOS/blob/87e0a33ac438c1d702f2a0b75bf21f26866e346f/Telegram-iOS/AppDelegate.swift#L1250):
```swift
func application(_ application: UIApplication, open url: URL, sourceApplication: String?) -> Bool {
self.openUrl(url: url)
return true
}

func application(_ application: UIApplication, open url: URL, sourceApplication: String?,
annotation: Any) -> Bool {
self.openUrl(url: url)
return true
}

func application(_ app: UIApplication, open url: URL,
options: [UIApplicationOpenURLOptionsKey : Any] = [:]) -> Bool {
self.openUrl(url: url)
return true
}

func application(_ application: UIApplication, handleOpen url: URL) -> Bool {
self.openUrl(url: url)
return true
}
```
## Pruebas de Solicitudes URL a Otras Aplicaciones

El m茅todo [`openURL:options:completionHandler:`](https://developer.apple.com/documentation/uikit/uiapplication/1648685-openurl?language=objc) y el [m茅todo obsoleto `openURL:` de `UIApplication`](https://developer.apple.com/documentation/uikit/uiapplication/1622961-openurl?language=objc) son responsables de **abrir URLs** (es decir, para enviar solicitudes / hacer consultas a otras aplicaciones) que pueden ser locales a la aplicaci贸n actual o puede ser una que debe ser proporcionada por una aplicaci贸n diferente. Si tienes el c贸digo fuente original, puedes buscar directamente usos de esos m茅todos.

Adem谩s, si est谩s interesado en saber si la aplicaci贸n est谩 consultando servicios o aplicaciones espec铆ficas, y si la aplicaci贸n es bien conocida, tambi茅n puedes buscar esquemas de URL comunes en l铆nea e incluirlos en tus **greps ([**lista de esquemas de aplicaciones iOS**](https://ios.gadgethacks.com/how-to/always-updated-list-ios-app-url-scheme-names-paths-for-shortcuts-0184033/)**)**.
```bash
egrep -nr "open.*options.*completionHandler" ./Telegram-iOS/
egrep -nr "openURL\(" ./Telegram-iOS/
egrep -nr "mt-encrypted-file://" ./Telegram-iOS/
egrep -nr "://" ./Telegram-iOS/
```
## Pruebas de M茅todos Obsoletos

Busque m茅todos obsoletos como:

* [`application:handleOpenURL:`](https://developer.apple.com/documentation/uikit/uiapplicationdelegate/1622964-application?language=objc)
* [`openURL:`](https://developer.apple.com/documentation/uikit/uiapplication/1622961-openurl?language=objc)
* [`application:openURL:sourceApplication:annotation:`](https://developer.apple.com/documentation/uikit/uiapplicationdelegate/1623073-application)

Por ejemplo, aqu铆 encontramos estos tres:
```bash
$ rabin2 -zzq Telegram\ X.app/Telegram\ X | grep -i "openurl"

0x1000d9e90 31 30 UIApplicationOpenURLOptionsKey
0x1000dee3f 50 49 application:openURL:sourceApplication:annotation:
0x1000dee71 29 28 application:openURL:options:
0x1000dee8e 27 26 application:handleOpenURL:
0x1000df2c9 9 8 openURL:
0x1000df766 12 11 canOpenURL:
0x1000df772 35 34 openURL:options:completionHandler:
...
```
## Llamadas a URLs arbitrarias

* **Safari**: Para probar r谩pidamente un esquema de URL, puedes abrir las URLs en Safari y observar c贸mo se comporta la app. Por ejemplo, si escribes `tel://123456789`, Safari intentar谩 iniciar la llamada al n煤mero.
* **App de Notas**: Mant茅n presionados los enlaces que has escrito para probar esquemas de URL personalizados. Recuerda salir del modo de edici贸n para poder abrirlos. Ten en cuenta que puedes hacer clic o mantener presionados enlaces que incluyan esquemas de URL personalizados solo si la app est谩 instalada, si no, no se resaltar谩n como _enlaces clicables_.
* [**IDB**](https://github.com/facebook/idb):
* Inicia IDB, con茅ctate a tu dispositivo y selecciona la app objetivo. Puedes encontrar detalles en la [documentaci贸n de IDB](https://www.idbtool.com/documentation/setup.html).
* Ve a la secci贸n **URL Handlers**. En **URL schemes**, haz clic en **Refresh**, y a la izquierda encontrar谩s una lista de todos los esquemas personalizados definidos en la app que se est谩 probando. Puedes cargar estos esquemas haciendo clic en **Open**, en el lado derecho. Simplemente abriendo un esquema de URI en blanco (por ejemplo, abriendo `myURLscheme://`), puedes descubrir funcionalidades ocultas (por ejemplo, una ventana de depuraci贸n) y eludir la autenticaci贸n local.
*   **Frida**:

Si simplemente quieres abrir el esquema de URL, puedes hacerlo usando Frida:

```javascript
$ frida -U iGoat-Swift

[iPhone::iGoat-Swift]-> function openURL(url) {
var UIApplication = ObjC.classes.UIApplication.sharedApplication();
var toOpen = ObjC.classes.NSURL.URLWithString_(url);
return UIApplication.openURL_(toOpen);
}
[iPhone::iGoat-Swift]-> openURL("tel://234234234")
true
```

En este ejemplo de [Frida CodeShare](https://codeshare.frida.re/@dki/ios-url-scheme-fuzzing/) el autor utiliza la API no p煤blica `LSApplicationWorkspace.openSensitiveURL:withOptions:` para abrir las URLs (desde la app SpringBoard):

```javascript
function openURL(url) {
var w = ObjC.classes.LSApplicationWorkspace.defaultWorkspace();
var toOpen = ObjC.classes.NSURL.URLWithString_(url);
return w.openSensitiveURL_withOptions_(toOpen, null);
}
```

> Ten en cuenta que el uso de APIs no p煤blicas no est谩 permitido en la App Store, por eso ni siquiera las probamos, pero se nos permite usarlas para nuestro an谩lisis din谩mico.

## Fuzzing de Esquemas de URL

Si la app analiza partes de la URL, tambi茅n puedes realizar fuzzing de entrada para detectar errores de corrupci贸n de memoria.

Lo que hemos aprendido anteriormente ahora se puede utilizar para construir tu propio fuzzer en el lenguaje de tu elecci贸n, por ejemplo, en Python y llamar a `openURL` usando [RPC de Frida](https://www.frida.re/docs/javascript-api/#rpc). Ese fuzzer deber铆a hacer lo siguiente:

* Generar cargas 煤tiles.
* Llamar a `openURL` con cada una de ellas.
* Verificar si la app genera un informe de fallos (`.ips`) en `/private/var/mobile/Library/Logs/CrashReporter`.

El proyecto [FuzzDB](https://github.com/fuzzdb-project/fuzzdb) ofrece diccionarios de fuzzing que puedes usar como cargas 煤tiles.

## **Fuzzing Usando Frida**

Hacer esto con Frida es bastante f谩cil, puedes referirte a este [post del blog](https://grepharder.github.io/blog/0x03\_learning\_about\_universal\_links\_and\_fuzzing\_url\_schemes\_on\_ios\_with\_frida.html) para ver un ejemplo que hace fuzzing de la app iGoat-Swift (funcionando en iOS 11.1.2).

Antes de ejecutar el fuzzer necesitamos los esquemas de URL como entradas. Desde el an谩lisis est谩tico sabemos que la app iGoat-Swift soporta el siguiente esquema de URL y par谩metros: `iGoat://?contactNumber={0}&message={0}`.
```bash
$ frida -U SpringBoard -l ios-url-scheme-fuzzing.js
[iPhone::SpringBoard]-> fuzz("iGoat", "iGoat://?contactNumber={0}&message={0}")
Watching for crashes from iGoat...
No logs were moved.
Opened URL: iGoat://?contactNumber=0&message=0
```
# Referencias

{% embed url="https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06h-testing-platform-interaction#testing-object-persistence-mstg-platform-8" %}



<details>

<summary><strong>Aprende hacking en AWS de cero a h茅roe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Otras formas de apoyar a HackTricks:

* Si quieres ver a tu **empresa anunciada en HackTricks** o **descargar HackTricks en PDF**, consulta los [**PLANES DE SUSCRIPCIN**](https://github.com/sponsors/carlospolop)!
* Consigue el [**merchandising oficial de PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubre [**La Familia PEASS**](https://opensea.io/collection/the-peass-family), nuestra colecci贸n de [**NFTs**](https://opensea.io/collection/the-peass-family) exclusivos
* **nete al**  [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s铆gueme** en **Twitter**  [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Comparte tus trucos de hacking enviando PRs a los repositorios de github de** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
