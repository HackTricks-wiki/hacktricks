```markdown
<details>

<summary><strong>Aprende a hackear AWS de cero a h칠roe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Otras formas de apoyar a HackTricks:

* Si quieres ver a tu **empresa anunciada en HackTricks** o **descargar HackTricks en PDF** revisa los [**PLANES DE SUSCRIPCI칍N**](https://github.com/sponsors/carlospolop)!
* Consigue el [**merchandising oficial de PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubre [**La Familia PEASS**](https://opensea.io/collection/the-peass-family), nuestra colecci칩n de [**NFTs**](https://opensea.io/collection/the-peass-family) exclusivos
* **칔nete al** 游눫 [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s칤gueme** en **Twitter** 游냕 [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Comparte tus trucos de hacking enviando PRs a los repositorios de github de** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>


# Separaci칩n de Privilegios y Sandbox

Las aplicaciones a las que el usuario puede acceder se ejecutan como el usuario **mobile** mientras que los procesos cr칤ticos del sistema se ejecutan como **root**.\
Sin embargo, el sandbox permite un mejor control sobre las acciones que los procesos y aplicaciones pueden realizar.

Por ejemplo, incluso si dos procesos se ejecutan como el mismo usuario (mobile), **no se les permite acceder o modificar los datos del otro**.

Cada aplicaci칩n se instala bajo **`private/var/mobile/Applications/{ID aleatorio}`**\
Una vez instaladas, las aplicaciones tienen acceso de lectura limitado a algunas 치reas y funciones del sistema (SMS, llamadas telef칩nicas...). Si una aplicaci칩n quiere acceder a un **치rea protegida,** aparece un **pop-up solicitando permiso**.

# Protecci칩n de Datos

Los desarrolladores de aplicaciones pueden aprovechar las APIs de _Protecci칩n de Datos_ de iOS para implementar un **control de acceso detallado** para los datos del usuario almacenados en la memoria flash. Las APIs est치n construidas sobre el **Secure Enclave Processor** (SEP). El SEP es un coprocesador que proporciona **operaciones criptogr치ficas para la protecci칩n de datos y la gesti칩n de claves**. Una clave de hardware espec칤fica del dispositivo, el **device UID** (ID 칔nico), est치 **incrustada en el enclave seguro**, asegurando la integridad de la protecci칩n de datos incluso cuando el kernel del sistema operativo est치 comprometido.

Cuando se **crea un archivo** en el disco, se genera una nueva clave **AES de 256 bits** con la ayuda del generador de n칰meros aleatorios basado en hardware del enclave seguro. El **contenido del archivo se cifra entonces con la clave generada**. Y luego, esta **clave se guarda cifrada con una clave de clase** junto con **el ID de clase,** con **ambos datos cifrados por la clave del sistema,** dentro de los **metadatos** del archivo.

![](<../../.gitbook/assets/image (473).png>)

Para descifrar el archivo, los **metadatos se descifran usando la clave del sistema**. Luego, **usando el ID de clase** se **recupera la clave de clase** **para descifrar la clave del archivo y descifrar el archivo.**

Los archivos pueden asignarse a una de **cuatro** **diferentes** **clases de protecci칩n**, que se explican con m치s detalle en la [Gu칤a de Seguridad de la Plataforma Apple](https://help.apple.com/pdf/security/en_US/apple-platform-security-guide.pdf):

* **Protecci칩n Completa (NSFileProtectionComplete)**: Una clave derivada del c칩digo de acceso del usuario y el device UID protege esta clave de clase. La clave derivada se elimina de la memoria poco despu칠s de que el dispositivo se bloquea, haciendo que los datos sean inaccesibles hasta que el usuario desbloquee el dispositivo.
* **Protegido a Menos que Est칠 Abierto (NSFileProtectionCompleteUnlessOpen)**: Esta clase de protecci칩n es similar a la Protecci칩n Completa, pero, si el archivo est치 abierto cuando se desbloquea, la aplicaci칩n puede continuar accediendo al archivo incluso si el usuario bloquea el dispositivo. Esta clase de protecci칩n se utiliza cuando, por ejemplo, se est치 descargando un adjunto de correo en segundo plano.
* **Protegido Hasta la Primera Autenticaci칩n del Usuario (NSFileProtectionCompleteUntilFirstUserAuthentication)**: El archivo se puede acceder tan pronto como el usuario desbloquee el dispositivo por primera vez despu칠s de arrancar. Se puede acceder incluso si el usuario vuelve a bloquear el dispositivo y la clave de clase no se elimina de la memoria.
* **Sin Protecci칩n (NSFileProtectionNone)**: La clave para esta clase de protecci칩n est치 protegida solo con el UID. La clave de clase se almacena en "Effaceable Storage", que es una regi칩n de la memoria flash en el dispositivo iOS que permite el almacenamiento de peque침as cantidades de datos. Esta clase de protecci칩n existe para el borrado remoto r치pido (eliminaci칩n inmediata de la clave de clase, lo que hace que los datos sean inaccesibles).

Todas las claves de clase excepto `NSFileProtectionNone` est치n cifradas con una clave derivada del device UID y el c칩digo de acceso del usuario. Como resultado, el descifrado solo puede ocurrir en el propio dispositivo y requiere el c칩digo de acceso correcto.

Desde iOS 7, la clase de protecci칩n de datos predeterminada es "Protegido Hasta la Primera Autenticaci칩n del Usuario".

[**FileDP**](https://github.com/abjurato/FileDp-Source) es un programa que puedes subir y usar dentro del iPhone para **inspeccionar la clase de protecci칩n de datos** de cada archivo.

## El Keychain

Un keychain es un **contenedor cifrado** donde cada aplicaci칩n puede **almacenar** piezas de **informaci칩n sensible** y solo la misma aplicaci칩n (o aplicaciones autorizadas) puede recuperar los contenidos.\
iOS **genera su propia contrase침a para el keychain** y **almacena** una versi칩n **cifrada** de esta clave en el dispositivo. Esta contrase침a est치 cifrada con AES usando una clave AES creada por una funci칩n **PBKDF2** del **c칩digo de acceso del usuario + sal** (el **UID de 256 bits del dispositivo** **solo accesible** al chipset del enclave **seguro** en el dispositivo). Debido al uso de este UID del dispositivo como sal, un dispositivo no podr치 descifrar el keychain de un dispositivo diferente incluso conociendo el c칩digo de acceso de los usuarios.

El acceso al Keychain est치 gestionado por el daemon **`securityd`**, que concede acceso de acuerdo con los `Keychain-access-groups`, `application-identifier`, y `application-group` entitlements de la aplicaci칩n.

La [API de Keychain](https://developer.apple.com/library/content/documentation/Security/Conceptual/keychainServConcepts/02concepts/concepts.html) incluye las siguientes operaciones principales:

* `SecItemAdd`
* `SecItemUpdate`
* `SecItemCopyMatching`
* `SecItemDelete`

Las 칰nicas formas de intentar BF esta contrase침a es volcando la clave cifrada y BF el c칩digo de acceso + sal (la funci칩n **pbkdf2** utiliza **al menos 10000 iteraciones**). O intentando **BF dentro del dispositivo** para evitar BF la sal, sin embargo, el enclave seguro asegura que hay al menos un **retraso de 5s entre 2 intentos fallidos de contrase침a**.

Puedes configurar **protecci칩n de datos para elementos del Keychain** estableciendo la clave `kSecAttrAccessible` en la llamada a `SecItemAdd` o `SecItemUpdate`.Los siguientes valores de accesibilidad configurables para `kSecAttrAccessible` son las clases de Protecci칩n de Datos del Keychain:

* **`kSecAttrAccessibleAlways`**: Los datos en el elemento del Keychain pueden **accederse siempre**, independientemente de si el dispositivo est치 bloqueado.
* **`kSecAttrAccessibleAlwaysThisDeviceOnly`**: Los datos en el elemento del Keychain pueden **accederse siempre**, independientemente de si el dispositivo est치 bloqueado. Los datos **no se incluir치n en una copia de seguridad de iCloud** o local.
* **`kSecAttrAccessibleAfterFirstUnlock`**: Los datos en el elemento del Keychain no pueden accederse despu칠s de un reinicio hasta que el **dispositivo haya sido desbloqueado una vez** por el usuario.
* **`kSecAttrAccessibleAfterFirstUnlockThisDeviceOnly`**: Los datos en el elemento del Keychain no pueden accederse despu칠s de un reinicio hasta que el **dispositivo haya sido desbloqueado una vez** por el usuario. Los elementos con este atributo **no migran a un nuevo dispositivo**. Por lo tanto, despu칠s de restaurar desde una copia de seguridad de un dispositivo diferente, estos elementos no estar치n presentes.
* **`kSecAttrAccessibleWhenUnlocked`**: Los datos en el elemento del Keychain pueden accederse **solo mientras el dispositivo est치 desbloqueado** por el usuario.
* **`kSecAttrAccessibleWhenUnlockedThisDeviceOnly`**: Los datos en el elemento del Keychain pueden accederse **solo mientras el dispositivo est치 desbloqueado** por el usuario. Los datos **no se incluir치n en una copia de seguridad de iCloud o local**.
* **`kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly`**: Los datos en el Keychain pueden accederse **solo cuando el dispositivo est치 desbloqueado**. Esta clase de protecci칩n **solo est치 disponible si se establece un c칩digo de acceso** en el dispositivo. Los datos **no se incluir치n en una copia de seguridad de iCloud o local**.

**`AccessControlFlags`** definen los mecanismos con los que los usuarios pueden autenticar la clave (`SecAccessControlCreateFlags`):

* **`kSecAccessControlDevicePasscode`**: Acceder al elemento mediante un c칩digo de acceso.
* **`kSecAccessControlBiometryAny`**: Acceder al elemento mediante una de las huellas dactilares registradas en Touch ID. Agregar o eliminar una huella dactilar no invalidar치 el elemento.
* **`kSecAccessControlBiometryCurrentSet`**: Acceder al elemento mediante una de las huellas dactilares registradas en Touch ID. Agregar o eliminar una huella dactilar _s칤_ invalidar치 el elemento.
* **`kSecAccessControlUserPresence`**: Acceder al elemento mediante una de las huellas dactilares registradas (usando Touch ID) o por defecto al c칩digo de acceso.

Tenga en cuenta que las claves aseguradas por Touch ID (a trav칠s de `kSecAccessControlBiometryAny` o `kSecAccessControlBiometryCurrentSet`) est치n protegidas por el Secure Enclave: el Keychain solo contiene un token, no la clave real. La clave reside en el Secure Enclave.

El iPhone utiliza el **c칩digo de acceso introducido por el usuario al desbloquear el dispositivo para descifrar los secretos en el keychain**.

iOS utiliza el _**AppIdentifierPrefix**_ (Team ID) y el _**BundleIdentifier**_ (proporcionado por el desarrollador) para hacer cumplir el **control de acceso sobre los elementos del keychain**. Entonces, el mismo equipo **puede** **configurar** **2 aplicaciones para compartir elementos del keychain**.

Cuando se inicia un proceso de copia de seguridad, los **datos del keychain respaldados permanecen cifrados y la contrase침a del keychain no se incluye en la copia de seguridad**.

{% hint style="warning" %}
**En un dispositivo con jailbreak el keychain no est치 protegido.**
{% endhint %}

### **Persistencia de Datos del Keychain**

En iOS, cuando se desinstala una aplicaci칩n, los datos del Keychain utilizados por la aplicaci칩n son retenidos por el dispositivo, a diferencia de los datos almacenados por el sandbox de la aplicaci칩n que se borran. En el caso de que un **usuario venda su dispositivo sin realizar un restablecimiento de f치brica, el comprador del dispositivo podr칤a acceder a las cuentas y datos de las aplicaciones del usuario anterior reinstalando** las mismas aplicaciones utilizadas por el usuario anterior. Esto no requerir칤a ninguna habilidad t칠cnica para realizar.

No hay una API de iOS que los desarrolladores puedan usar para forzar el borrado de datos cuando se desinstala una aplicaci칩n. En su lugar, los desarrolladores deben tomar las siguientes medidas para evitar que los datos del Keychain persistan entre instalaciones de aplicaciones:

* Cuando una aplicaci칩n se lanza por primera vez despu칠s de la instalaci칩n, borrar todos los datos del Keychain asociados con la aplicaci칩n. Esto evitar치 que un segundo usuario del dispositivo acceda accidentalmente a las cuentas del usuario anterior. El siguiente ejemplo en Swift es una demostraci칩n b치sica de este procedimiento de borrado:
```
```objectivec
let userDefaults = UserDefaults.standard

if userDefaults.bool(forKey: "hasRunBefore") == false {
// Remove Keychain items here

// Update the flag indicator
userDefaults.set(true, forKey: "hasRunBefore")
userDefaults.synchronize() // Forces the app to update UserDefaults
}
```
* Al desarrollar la funcionalidad de cierre de sesi칩n para una aplicaci칩n iOS, aseg칰rate de que los datos de Keychain se borren como parte del cierre de sesi칩n de la cuenta. Esto permitir치 a los usuarios limpiar sus cuentas antes de desinstalar una aplicaci칩n.

# **Capacidades de la App**

**Cada app tiene un directorio hogar 칰nico y est치 en un entorno aislado (sandboxed)**, de modo que no pueden acceder a recursos del sistema protegidos o archivos almacenados por el sistema o por otras apps. Estas restricciones se implementan a trav칠s de pol칤ticas de entorno aislado (tambi칠n conocidas como _perfiles_), que son aplicadas por el [Marco de Control de Acceso Obligatorio Trusted BSD (MAC)](http://www.trustedbsd.org/mac.html) a trav칠s de una extensi칩n del kernel.

Algunas [**capacidades/permisos**](https://help.apple.com/developer-account/#/dev21218dfd6) pueden ser configuradas por los desarrolladores de la app (por ejemplo, Protecci칩n de Datos o Compartir Keychain) y tendr치n efecto inmediatamente despu칠s de la instalaci칩n. Sin embargo, para otras, **se pedir치 expl칤citamente al usuario la primera vez que la app intente acceder a un recurso protegido**.

Los [_Purpose strings_](https://developer.apple.com/documentation/uikit/core_app/protecting_the_user_s_privacy/accessing_protected_resources?language=objc#3037322) o _cadenas de descripci칩n de uso_ son textos personalizados que se ofrecen a los usuarios en la alerta de solicitud de permisos del sistema cuando se solicita permiso para acceder a datos o recursos protegidos.

![](https://gblobscdn.gitbook.com/assets%2F-LH00RC4WVf3-6Ou4e0l%2F-Lf1APQHyCHdAvoJSvc_%2F-Lf1AQw8W2q7BB5-il7r%2Fpermission_request_alert.png?alt=media)

Si tienes el c칩digo fuente original, puedes verificar los permisos incluidos en el archivo `Info.plist`:

* Abre el proyecto con Xcode.
* Encuentra y abre el archivo `Info.plist` en el editor predeterminado y busca las claves que comienzan con `"Privacy -"`.

Puedes cambiar la vista para mostrar los valores brutos haciendo clic derecho y seleccionando "Mostrar Claves/Valores Brutos" (de esta manera, por ejemplo, `"Privacy - Location When In Use Usage Description"` se convertir치 en `NSLocationWhenInUseUsageDescription`).

Si solo tienes el IPA:

* Descomprime el IPA.
* El `Info.plist` se encuentra en `Payload/<appname>.app/Info.plist`.
* Convi칠rtelo si es necesario (por ejemplo, `plutil -convert xml1 Info.plist`) como se explica en el cap칤tulo "Pruebas B치sicas de Seguridad en iOS", secci칩n "El Archivo Info.plist".
*   Inspecciona todas las claves de _purpose strings en Info.plist_, que generalmente terminan con `UsageDescription`:

```markup
<plist version="1.0">
<dict>
<key>NSLocationWhenInUseUsageDescription</key>
<string>Tu ubicaci칩n se utiliza para proporcionar indicaciones paso a paso hasta tu destino.</string>
```

## Capacidades del Dispositivo

Las capacidades del dispositivo son utilizadas por la App Store para asegurar que solo los dispositivos compatibles est칠n listados y, por lo tanto, tengan permitido descargar la app. Se especifican en el archivo `Info.plist` de la app bajo la clave [`UIRequiredDeviceCapabilities`](https://developer.apple.com/library/archive/documentation/General/Reference/InfoPlistKeyReference/Articles/iPhoneOSKeys.html#//apple_ref/doc/plist/info/UIRequiredDeviceCapabilities).
```markup
<key>UIRequiredDeviceCapabilities</key>
<array>
<string>armv7</string>
</array>
```
> T칤picamente encontrar치s la capacidad `armv7`, lo que significa que la app est치 compilada solo para el conjunto de instrucciones armv7, o si es una app universal de 32/64 bits.

Por ejemplo, una app podr칤a depender completamente de NFC para funcionar (por ejemplo, una app ["NFC Tag Reader"](https://itunes.apple.com/us/app/nfc-taginfo-by-nxp/id1246143596)). Seg칰n la [Referencia de Compatibilidad de Dispositivos iOS archivada](https://developer.apple.com/library/archive/documentation/DeviceInformation/Reference/iOSDeviceCompatibility/DeviceCompatibilityMatrix/DeviceCompatibilityMatrix.html), NFC solo est치 disponible a partir del iPhone 7 (y iOS 11). Un desarrollador podr칤a querer excluir todos los dispositivos incompatibles estableciendo la capacidad del dispositivo `nfc`.

## Entitlements

> Los entitlements son pares clave-valor que est치n firmados en una app y permiten autenticaci칩n m치s all치 de factores de tiempo de ejecuci칩n, como el ID de usuario UNIX. Dado que los entitlements est치n firmados digitalmente, no se pueden cambiar. Los entitlements son utilizados extensivamente por apps del sistema y daemons para **realizar operaciones privilegiadas espec칤ficas que de otro modo requerir칤an que el proceso se ejecute como root**. Esto reduce en gran medida el potencial de escalada de privilegios por una app del sistema o daemon comprometido.

Por ejemplo, si quieres establecer la capacidad "Protecci칩n de Datos Predeterminada", necesitar칤as ir a la pesta침a **Capabilities** en Xcode y habilitar **Protecci칩n de Datos**. Esto es escrito directamente por Xcode en el archivo `<appname>.entitlements` como el entitlement `com.apple.developer.default-data-protection` con el valor predeterminado `NSFileProtectionComplete`. En el IPA podr칤amos encontrar esto en el `embedded.mobileprovision` como:
```markup
<key>Entitlements</key>
<dict>
...
<key>com.apple.developer.default-data-protection</key>
<string>NSFileProtectionComplete</string>
</dict>
```
Para otras capacidades como HealthKit, se debe pedir permiso al usuario, por lo tanto, no es suficiente con a침adir los entitlements, tambi칠n se deben agregar claves y cadenas especiales al archivo `Info.plist` de la app.

# Fundamentos de Objective-C y Swift

**Objective-C** tiene un **runtime din치mico**, as칤 que cuando un programa de Objective-C se ejecuta en iOS, llama a bibliotecas cuyas **direcciones se resuelven en tiempo de ejecuci칩n** comparando el nombre de la funci칩n enviada en el mensaje contra una lista de todos los nombres de funciones disponibles.

Al principio, solo las apps creadas por Apple funcionaban en los iPhones, por lo que ten칤an **acceso a todo** ya que eran **confiables**. Sin embargo, cuando Apple **permiti칩 aplicaciones de terceros**, simplemente elimin칩 los archivos de cabecera de las funciones poderosas para "ocultarlas" a los desarrolladores. No obstante, los desarrolladores descubrieron que las funciones "seguras" necesitaban algunas de estas funciones no documentadas y solo creando un **archivo de cabecera personalizado con los nombres de las funciones no documentadas, era posible invocar estas poderosas funciones ocultas.** De hecho, Apple, antes de permitir la publicaci칩n de una app, verifica si la app llama a alguna de estas funciones prohibidas.

Luego, apareci칩 Swift. Como **Swift est치 vinculado est치ticamente** (no resuelve las direcciones de las funciones en tiempo de ejecuci칩n como Objective-C), se pueden verificar m치s f치cilmente las llamadas que va a realizar un programa de Swift mediante an치lisis de c칩digo est치tico.

# Gesti칩n de Dispositivos

Desde la versi칩n 6 de iOS, hay **soporte incorporado para la capacidad de gesti칩n de dispositivos** con controles de granularidad fina que permiten a una organizaci칩n controlar los dispositivos Apple corporativos.\
El enrolamiento puede ser **iniciado por el usuario instalando un agente** para acceder a las apps corporativas. En este caso, el dispositivo generalmente pertenece al usuario.\
O la **empresa puede indicar los n칰meros de serie** de los dispositivos comprados o la ID de la orden de compra y especificar el perfil MDM para instalar en esos dispositivos. Cabe destacar que Apple **no permite enrolar un dispositivo en particular de esta manera dos veces**. Una vez que se elimina el primer perfil, el usuario necesita dar su consentimiento para instalar otro.

El usuario puede ver las pol칤ticas instaladas en _**Ajustes**_ --> _**General**_ --> _**Gesti칩n de Perfiles y Dispositivos**_

Como estas pol칤ticas MDM est치n revisando y limitando otras aplicaciones, est치n **funcionando con m치s privilegios**.\
Una pol칤tica MDM puede **obligar** a los **usuarios** a tener un **c칩digo de acceso** establecido con una **complejidad de contrase침a m칤nima**.\
Los perfiles est치n vinculados al deviceID, **firmados** y **cifrados** por el servidor MDM y son **a prueba de manipulaciones**. **No pueden** ser **eliminados** sin **perder** todos los **datos corporativos**.\
Los perfiles MDM permiten **borrar** todos los **datos** si hay X **intentos fallidos** de contrase침a. Adem치s, el **administrador** puede **borrar remotamente** el iPhone en cualquier momento a trav칠s de la interfaz MDM.

Los agentes MDM tambi칠n **verificar치n** posibles **jailbreaks del dispositivo**, ya que este es un estado muy peligroso para un iPhone.


<details>

<summary><strong>Aprende hacking en AWS de cero a h칠roe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Otras formas de apoyar a HackTricks:

* Si quieres ver a tu **empresa anunciada en HackTricks** o **descargar HackTricks en PDF** consulta los [**PLANES DE SUSCRIPCI칍N**](https://github.com/sponsors/carlospolop)!
* Consigue el [**merchandising oficial de PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubre [**La Familia PEASS**](https://opensea.io/collection/the-peass-family), nuestra colecci칩n de [**NFTs**](https://opensea.io/collection/the-peass-family) exclusivos
* **칔nete al** 游눫 [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s칤gueme** en **Twitter** 游냕 [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Comparte tus trucos de hacking enviando PRs a los repositorios de** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) en github.

</details>
