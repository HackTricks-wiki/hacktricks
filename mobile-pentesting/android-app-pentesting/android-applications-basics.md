# Conceptos B谩sicos de Aplicaciones Android

<details>

<summary><strong>Aprende hacking en AWS de cero a h茅roe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Otras formas de apoyar a HackTricks:

* Si quieres ver a tu **empresa anunciada en HackTricks** o **descargar HackTricks en PDF**, consulta los [**PLANES DE SUSCRIPCIN**](https://github.com/sponsors/carlospolop)!
* Consigue el [**merchandising oficial de PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubre [**La Familia PEASS**](https://opensea.io/collection/the-peass-family), nuestra colecci贸n de [**NFTs**](https://opensea.io/collection/the-peass-family) exclusivos
* **nete al**  [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de Telegram**](https://t.me/peass) o **s铆gueme** en **Twitter**  [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Comparte tus trucos de hacking enviando PRs a los repositorios de GitHub de** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

<figure><img src="/.gitbook/assets/image (675).png" alt=""><figcaption></figcaption></figure>

Encuentra vulnerabilidades que importan m谩s para poder solucionarlas m谩s r谩pido. Intruder rastrea tu superficie de ataque, realiza escaneos proactivos de amenazas, encuentra problemas en todo tu stack tecnol贸gico, desde APIs hasta aplicaciones web y sistemas en la nube. [**Pru茅balo gratis**](https://www.intruder.io/?utm\_source=referral\&utm\_campaign=hacktricks) hoy.

{% embed url="https://www.intruder.io/?utm_campaign=hacktricks&utm_source=referral" %}

***

## Modelo de Seguridad de Android

**Hay dos capas:**

* El **SO**, que mantiene las aplicaciones instaladas aisladas unas de otras.
* La **aplicaci贸n en s铆**, que permite a los desarrolladores **exponer ciertas funcionalidades** y configura las capacidades de la aplicaci贸n.

### Separaci贸n de UID

**A cada aplicaci贸n se le asigna un ID de Usuario espec铆fico**. Esto se hace durante la instalaci贸n de la app para que **la app solo pueda interactuar con archivos propiedad de su ID de Usuario o archivos compartidos**. Por lo tanto, solo la propia app, ciertos componentes del SO y el usuario root pueden acceder a los datos de la app.

### Compartici贸n de UID

**Dos aplicaciones pueden configurarse para usar el mismo UID**. Esto puede ser 煤til para compartir informaci贸n, pero si una de ellas se ve comprometida, los datos de ambas aplicaciones estar谩n comprometidos. Por eso se **desaconseja** este comportamiento.\
**Para compartir el mismo UID, las aplicaciones deben definir el mismo valor `android:sharedUserId` en sus manifiestos.**

### Aislamiento (Sandboxing)

El **Sandbox de Aplicaciones Android** permite ejecutar **cada aplicaci贸n** como un **proceso separado bajo un ID de usuario separado**. Cada proceso tiene su propia m谩quina virtual, por lo que el c贸digo de una app se ejecuta aislado de otras apps.\
Desde Android 5.0(L) se aplica **SELinux**. B谩sicamente, SELinux deniega todas las interacciones de procesos y luego crea pol铆ticas para **permitir solo las interacciones esperadas entre ellos**.

### Permisos

Cuando instalas una **app y esta pide permisos**, la app est谩 solicitando los permisos configurados en los elementos **`uses-permission`** en el archivo **AndroidManifest.xml**. El elemento **uses-permission** indica el nombre del permiso solicitado dentro del **atributo name**. Tambi茅n tiene el atributo **maxSdkVersion** que deja de pedir permisos en versiones superiores a la especificada.\
Nota que las aplicaciones de android no necesitan pedir todos los permisos al principio, tambi茅n pueden **pedir permisos din谩micamente** pero todos los permisos deben estar **declarados** en el **manifiesto.**

Cuando una app expone funcionalidad, puede limitar el **acceso solo a apps que tienen un permiso especificado**.\
Un elemento de permiso tiene tres atributos:

* El **nombre** del permiso
* El atributo **permission-group**, que permite agrupar permisos relacionados.
* El **protection-level** que indica c贸mo se otorgan los permisos. Hay cuatro tipos:
  * **Normal**: Usado cuando no hay **amenazas conocidas** para la app. El usuario **no necesita aprobarlo**.
  * **Peligroso (Dangerous)**: Indica que el permiso otorga a la aplicaci贸n solicitante alg煤n **acceso elevado**. **Se solicita a los usuarios que los aprueben**.
  * **Firma (Signature)**: Solo **apps firmadas por el mismo certificado que el** que exporta el componente pueden recibir permiso. Este es el tipo de protecci贸n m谩s fuerte.
  * **FirmaOSistema (SignatureOrSystem)**: Solo **apps firmadas por el mismo certificado que el** que exporta el componente o **apps que se ejecutan con acceso a nivel de sistema** pueden recibir permisos

## Aplicaciones Preinstaladas

Estas apps generalmente se encuentran en los directorios **`/system/app`** o **`/system/priv-app`** y algunas de ellas est谩n **optimizadas** (puede que ni siquiera encuentres el archivo `classes.dex`). Estas aplicaciones valen la pena revisarlas porque a veces est谩n **ejecut谩ndose con demasiados permisos** (como root).

* Las que vienen con la **ROM** del **AOSP** (Proyecto de C贸digo Abierto de Android)
* A帽adidas por el **fabricante del dispositivo**
* A帽adidas por el proveedor de **telefon铆a m贸vil** (si se compr贸 a trav茅s de ellos)

## Rooting

Para obtener acceso root en un dispositivo android f铆sico generalmente necesitas **explotar** 1 o 2 **vulnerabilidades** que suelen ser **espec铆ficas** para el **dispositivo** y **versi贸n**.\
Una vez que el exploit ha funcionado, generalmente se copia el binario `su` de Linux en una ubicaci贸n especificada en la variable de entorno PATH del usuario, como `/system/xbin`.

Una vez configurado el binario su, se utiliza otra aplicaci贸n de Android para interactuar con el binario `su` y **procesar solicitudes de acceso root** como **Superuser** y **SuperSU** (disponibles en Google Play store).

{% hint style="danger" %}
Nota que el proceso de rooting es muy peligroso y puede da帽ar severamente el dispositivo
{% endhint %}

### ROMs

Es posible **reemplazar el SO instalando un firmware personalizado**. Haciendo esto es posible extender la utilidad de un dispositivo antiguo, eludir restricciones de software o acceder al c贸digo m谩s reciente de Android.\
**OmniROM** y **LineageOS** son dos de los firmwares m谩s populares para usar.

Nota que **no siempre es necesario rootear el dispositivo** para instalar un firmware personalizado. **Algunos fabricantes permiten** el desbloqueo de sus gestores de arranque de una manera bien documentada y segura.

### Implicaciones

Una vez que un dispositivo est谩 rooteado, cualquier app podr铆a solicitar acceso como root. Si una aplicaci贸n maliciosa lo obtiene, tendr谩 acceso a casi todo y podr谩 da帽ar el tel茅fono.

## Fundamentos de la Aplicaci贸n Android <a href="#2-android-application-fundamentals" id="2-android-application-fundamentals"></a>

Esta introducci贸n est谩 tomada de [https://maddiestone.github.io/AndroidAppRE/app\_fundamentals.html](https://maddiestone.github.io/AndroidAppRE/app\_fundamentals.html)

### Revisi贸n de Fundamentos <a href="#fundamentals-review" id="fundamentals-review"></a>

* Las aplicaciones Android est谩n en el _formato de archivo APK_. **APK es b谩sicamente un archivo ZIP**. (Puedes cambiar la extensi贸n del archivo a .zip y usar unzip para abrirlo y ver su contenido.)
* Contenidos del APK (No exhaustivo)
  * **AndroidManifest.xml**
  * resources.arsc/strings.xml
  * resources.arsc: un archivo que contiene recursos precompilados, como XML binario, por ejemplo.
  * res/xml/files\_paths.xml
  * META-INF/
    * 隆El certificado vive aqu铆!
  * **classes.dex**
    * Bytecode Dalvik para la aplicaci贸n en formato de archivo DEX. **Este es el c贸digo Java (o Kotlin) compilado** que la aplicaci贸n ejecutar谩 por defecto.
  * lib/
    * Las bibliotecas nativas para la aplicaci贸n, por defecto, 隆viven aqu铆! Bajo el directorio lib/, est谩n los directorios espec铆ficos de la CPU.
    * `armeabi`: c贸digo compilado solo para procesadores basados en ARM
    * `armeabi-v7a`: c贸digo compilado solo para procesadores basados en ARMv7 y superiores
    * `x86`: c贸digo compilado para X86
    * `mips`: c贸digo compilado solo para procesadores MIPS
  * assets/
    * Cualquier otro archivo que pueda ser necesario para la app.
    * Bibliotecas nativas adicionales o archivos DEX pueden estar incluidos aqu铆. Esto puede suceder especialmente cuando los autores de malware quieren intentar "ocultar" c贸digo adicional, nativo o Dalvik, al no incluirlo en las ubicaciones predeterminadas.
  * res/
    * el directorio que contiene recursos no compilados en resources.arsc

### **Dalvik & Smali**

La mayor铆a de las aplicaciones Android est谩n escritas en Java. Kotlin tambi茅n es compatible e interoperable con Java. Para simplificar, por el resto de este taller, cuando me refiera a "Java", puedes asumir que me refiero a "Java o Kotlin". **En lugar de que el c贸digo Java se ejecute en la M谩quina Virtual de Java** (JVM) como las aplicaciones de escritorio, en Android, el **Java se compila al formato de bytecode \_Dalvik Executable (DEX)**\_\*\*.\*\* Para versiones anteriores de Android, el bytecode era traducido por la m谩quina virtual Dalvik. Para versiones m谩s recientes de Android, se utiliza el Android Runtime (ART).\
Si los desarrolladores escriben en Java y el c贸digo se compila a bytecode DEX, para la ingenier铆a inversa, trabajamos en la direcci贸n opuesta.\
\\

![Diagrama de flujo del proceso del desarrollador. Java a bytecode DEX](https://maddiestone.github.io/AndroidAppRE/images/DevelopersFlow.jpg)

![Diagrama de flujo del proceso del ingeniero inverso. Bytecode DEX a SMALI a Java descompilado](https://maddiestone.github.io/AndroidAppRE/images/ReversersFlow.jpg)

**Smali es la versi贸n legible por humanos del bytecode Dalvik**. T茅cnicamente, Smali y baksmali son los nombres de las herramientas (ensamblador y desensamblador, respectivamente), pero en Android, a menudo usamos el t茅rmino "Smali" para referirnos a las instrucciones. Si has hecho ingenier铆a inversa o arquitectura inform谩tica en c贸digo compilado C/C++. **SMALI es como el lenguaje ensamblador: entre el c贸digo fuente de alto nivel y el bytecode**.

<figure><img src="/.gitbook/assets/image (675).png" alt=""><figcaption></figcaption></figure>

Encuentra vulnerabilidades que importan m谩s para poder solucionarlas m谩s r谩pido. Intruder rastrea tu superficie de ataque, realiza escaneos proactivos de amenazas, encuentra problemas en todo tu stack tecnol贸gico, desde APIs hasta aplicaciones web y sistemas en la nube. [**Pru茅balo gratis**](https://www.intruder.io/?utm\_source=referral\&utm\_campaign=hacktricks) hoy.

{% embed url="https://www.intruder.io/?utm_campaign=hacktricks&utm_source=referral" %}

***

## Intents

Los Intents son el principal medio por el cual las aplicaciones Android se comunican entre sus componentes o con otras apps. Estos objetos de mensaje tambi茅n pueden llevar datos entre apps o componentes, de manera similar a c贸mo se utilizan las solicitudes GET/POST en las comunicaciones HTTP.

Entonces, un Intent es b谩sicamente un **mensaje que se pasa entre componentes**. Los Intents **pueden dirigirse** a componentes o apps espec铆ficas, **o pueden enviarse sin un destinatario espec铆fico**.\
Para ser simples, los Intents pueden usarse:

* Para iniciar una Actividad, abriendo t铆picamente una interfaz de usuario para una app
* Como difusiones para informar al sistema y a las apps de cambios
* Para iniciar, detener y comunicarse con un servicio en segundo plano
* Para acceder a datos a trav茅s de ContentProviders
* Como callbacks para manejar eventos

Una implementaci贸n incorrecta podr铆a resultar en la fuga de datos, funciones restringidas siendo llamadas y la manipulaci贸n del flujo del programa.

### Intent-Filter

Un Intent Filter especifica **los tipos de Intents a los que puede responder una actividad, servicio o Broadcast Receiver**. Especifica lo que una actividad o servicio puede hacer y qu茅 tipos de difusiones puede manejar un Receiver. Permite que el componente correspondiente reciba Intents del tipo declarado. Los Intent Filters se definen t铆picamente **a trav茅s del archivo AndroidManifest.xml**. Para **Broadcast Receiver** tambi茅n es posible definirlos en **c贸digo**. Un Intent Filter se define por su categor铆a, acci贸n y filtros de datos. Tambi茅n puede contener metadatos adicionales.

En Android, una actividad/servicio/content provider/broadcast receiver es **p煤blico** cuando **`exported`** est谩 configurado en **`true`** pero un componente es **tambi茅n p煤blico** si el **manifiesto especifica un Intent filter** para 茅l. Sin embargo,\
los desarrolladores pueden **hacer expl铆citamente privados los componentes** (independientemente de cualquier filtro de intent)\
configurando el atributo \*\* `exported` a `false`\*\* para cada componente en el archivo del manifiesto.\
Los desarrolladores tambi茅n pueden configurar el atributo **`permission`** para **requerir cierto permiso para acceder** al componente, restringiendo as铆 el acceso al componente.

### Intents Impl铆citos

Los Intents se crean program谩ticamente utilizando un constructor de Intent:
```java
Intent email = new Intent(Intent.ACTION_SEND, Uri.parse("mailto:"));
```
El **Action** del intent previamente declarado es **ACTION\_SEND** y el **Extra** es un **Uri** mailto (el Extra es la informaci贸n adicional que el intent espera).

Este intent debe declararse dentro del manifiesto como en el siguiente ejemplo:
```markup
<activity android:name="ShareActivity">
<intent-filter>
<action android:name="android.intent.action.SEND" />
<category android:name="android.intent.category.DEFAULT" />
</intent-filter>
</activity>
```
Un intent-filter necesita coincidir con la **acci贸n**, **datos** y **categor铆a** para recibir un mensaje.

El proceso de "Resoluci贸n de Intent" determina qu茅 aplicaci贸n debe recibir cada mensaje. Este proceso considera el **atributo de prioridad**, que se puede establecer en la **declaraci贸n del intent-filter**, y **se seleccionar谩 el que tenga la mayor prioridad**. Esta prioridad se puede establecer entre -1000 y 1000 y las aplicaciones pueden usar el valor `SYSTEM_HIGH_PRIORITY`. Si surge un **conflicto**, aparece una ventana de "elecci贸n" para que el **usuario pueda decidir**.

### Intents Expl铆citos

Un intent expl铆cito especifica el nombre de la clase al que est谩 dirigido:
```java
Intent downloadIntent = new (this, DownloadService.class):
```
En otras aplicaciones para acceder al intent previamente declarado puedes usar:
```java
Intent intent = new Intent();
intent.setClassName("com.other.app", "com.other.app.ServiceName");
context.startService(intent);
```
### Pending Intents

Estos permiten que otras aplicaciones **realicen acciones en nombre de tu aplicaci贸n**, utilizando la identidad y permisos de tu app. Al construir un Pending Intent se debe **especificar un intent y la acci贸n a realizar**. Si el **intent declarado no es Expl铆cito** (no declara qu茅 intent puede llamarlo) una **aplicaci贸n maliciosa podr铆a realizar la acci贸n declarada** en nombre de la app v铆ctima. Adem谩s, **si no se especifica una acci贸n**, la aplicaci贸n maliciosa podr谩 realizar **cualquier acci贸n en nombre de la v铆ctima**.

### Broadcast Intents

A diferencia de los intents anteriores, que solo son recibidos por una app, los broadcast intents **pueden ser recibidos por m煤ltiples aplicaciones**. Sin embargo, desde la versi贸n de API 14, es **posible especificar la aplicaci贸n que debe recibir** el mensaje usando Intent.set Package.

Alternativamente, tambi茅n es posible **especificar un permiso al enviar el broadcast**. La aplicaci贸n receptora necesitar谩 tener ese permiso.

Hay **dos tipos** de Broadcasts: **Normal** (asincr贸nico) y **Ordenado** (sincr贸nico). El **orden** se basa en la **prioridad configurada dentro del elemento receptor**. **Cada app puede procesar, retransmitir o descartar el Broadcast.**

Es posible **enviar** un **broadcast** utilizando la funci贸n **`sendBroadcast(intent, receiverPermission)`** de la clase `Context`.\
Tambi茅n podr铆as usar la funci贸n **`sendBroadcast`** del **`LocalBroadCastManager`** asegura que el **mensaje nunca salga de la app**. Usando esto ni siquiera necesitar谩s exportar un componente receptor.

### Sticky Broadcasts

Este tipo de Broadcasts **puede ser accedido mucho tiempo despu茅s de haber sido enviado**.\
Fueron obsoletos en el nivel de API 21 y se recomienda **no usarlos**.\
**Permiten que cualquier aplicaci贸n husmee los datos, pero tambi茅n los modifique.**

Si encuentras funciones que contienen la palabra "sticky" como **`sendStickyBroadcast`** o **`sendStickyBroadcastAsUser`**, **verifica el impacto e intenta eliminarlas**.

## Deep links / Esquemas de URL

**Los deep links permiten activar un Intent a trav茅s de una URL**. Una aplicaci贸n puede declarar un **esquema de URL** dentro de una actividad para que cada vez que el dispositivo Android intente **acceder a una direcci贸n usando ese esquema** se llame a la actividad de la aplicaci贸n:

![](<../../.gitbook/assets/image (214).png>)

En este caso el esquema es `myapp://` (nota tambi茅n la **`categor铆a BROWSABLE`**)

Si dentro del `intent-filter` encuentras algo como esto:

![](<../../.gitbook/assets/image (263).png>)

Entonces, est谩 esperando algo como `http://www.example.com/gizmos`

Si encuentras algo como esto:

![](<../../.gitbook/assets/image (262).png>)

Significar谩 que est谩 esperando una URL que comience con `example://gizmos`\
En este caso podr铆as intentar abusar de la funcionalidad creando una web con los siguientes payloads. Intentar谩 navegar a p谩ginas arbitrarias y tratar de ejecutar JS:
```markup
<a href="example://gizmos/https://google.com">click here</a>
<a href="example://gizmos/javascript://%250dalert(1)">click here</a>
```
Para encontrar el **c贸digo que se ejecutar谩 en la App**, ve a la actividad llamada por el deeplink y busca la funci贸n **`onNewIntent`**.

![](<../../.gitbook/assets/image (436) (1) (1) (1).png>)

Aprende c贸mo [llamar a deep links sin usar p谩ginas HTML](./#exploiting-schemes-deep-links).

## AIDL - Lenguaje de Definici贸n de Interfaz de Android

El **Lenguaje de Definici贸n de Interfaz de Android** (AIDL) te permite definir la interfaz de programaci贸n que tanto el cliente como el servicio acuerdan para **comunicarse entre s铆 utilizando la comunicaci贸n entre procesos** (IPC). En Android, **un proceso normalmente no puede acceder a la memoria de otro proceso**. Por lo tanto, para comunicarse, necesitan descomponer sus objetos en primitivas que el **sistema operativo** pueda entender y trasladar los objetos a trav茅s de ese l铆mite por ti. El c贸digo para hacer ese traslado es tedioso de escribir, por lo que Android lo maneja por ti con AIDL.

Los servicios que utilizan AIDL se conocen como **Servicios Vinculados**. En la clase del Servicio encontrar谩s el m茅todo **`onBind`**. Aqu铆 es **donde comienza la interacci贸n**, por lo que es la parte inicial del c贸digo a revisar en busca de posibles vulnerabilidades.

Un servicio vinculado es el servidor en una interfaz cliente-servidor. **Permite que componentes (como actividades) se vinculen al servicio, env铆en solicitudes, reciban respuestas y realicen comunicaci贸n entre procesos** (IPC). Un servicio vinculado normalmente solo existe mientras sirve a otro componente de la aplicaci贸n y no se ejecuta en segundo plano indefinidamente.

### Messenger

Un Messenger es otro tipo de mecanismo IPC. Dado que el **Messenger tambi茅n es un "Servicio Vinculado"**, los datos pasados desde la aplicaci贸n cliente tambi茅n se procesan a trav茅s del m茅todo `onBind`. Por lo tanto, la revisi贸n del c贸digo debe comenzar en este m茅todo y debes buscar la invocaci贸n de funcionalidades sensibles o el manejo inseguro de datos.

### Binder

Es raro encontrar una clase Binder invocada directamente ya que es mucho m谩s f谩cil usar AIDL (que abstrae la clase Binder). Sin embargo, es bueno saber que **Binder es un controlador a nivel de kernel que mueve datos de la memoria de un proceso a la de otro** ([https://www.youtube.com/watch?v=O-UHvFjxwZ8](https://www.youtube.com/watch?v=O-UHvFjxwZ8)).

## Componentes

Estos incluyen: **Actividades, Servicios, Receptores de Difusi贸n y Proveedores.**

### Actividad de Inicio y otras actividades

Una **actividad de Android** es una pantalla de la interfaz de usuario de la **app de Android**. De esa manera, una **actividad de Android** es muy similar a las ventanas en una aplicaci贸n de escritorio. Una **app de Android** puede contener una o m谩s actividades, es decir, una o m谩s pantallas.

La **actividad de inicio** es lo que la mayor铆a de las personas consideran como el **punto de entrada** a una aplicaci贸n de Android. La actividad de inicio es la actividad que se inicia cuando un usuario hace clic en el 铆cono de una aplicaci贸n. Puedes determinar la actividad de inicio mirando el manifiesto de la aplicaci贸n. La actividad de inicio tendr谩 los siguientes intentos MAIN y LAUNCHER listados.

Ten en cuenta que no todas las aplicaciones tendr谩n una actividad de inicio, especialmente las aplicaciones sin una UI. Ejemplos de aplicaciones sin UI (y por lo tanto sin actividad de inicio) son aplicaciones preinstaladas que realizan servicios en segundo plano, como el buz贸n de voz.
```markup
<activity android:name=".LauncherActivity">
<intent-filter>
<action android:name="android.intent.action.MAIN" />
<category android:name="android.intent.category.LAUNCHER" />
</intent-filter>
</activity>
```
Las Activities pueden ser exportadas permitiendo que otros procesos en el dispositivo inicien la activity. Por defecto, no est谩n exportadas, pero puedes exportarlas configurando:
```markup
<service android:name=".ExampleExportedService" android:exported="true"/>
```
Tenga en cuenta que la capacidad de **bypass activity protections no siempre es una vulnerabilidad**, necesita verificar a qu茅 datos ha obtenido acceso.\
Adem谩s, **algunas actividades devuelven datos al llamador**. En estos escenarios, necesita buscar el m茅todo **`setResult`** y verificar los datos que se pasan al par谩metro Intent. **Si son datos sensibles, podr铆a tener una vulnerabilidad de fuga de informaci贸n** y es explotable con aplicaciones capaces de comunicarse con la Actividad.

**El c贸digo de una actividad comienza con el m茅todo `onCreate`.**

### Subclase de Aplicaci贸n

Las aplicaciones Android pueden definir una **subclase** de [Application](https://developer.android.com/reference/android/app/Application). Las aplicaciones pueden, pero no tienen que definir una subclase personalizada de Application. Si una aplicaci贸n Android define una subclase de Application, **esta clase se instancia antes que cualquier otra clase en la aplicaci贸n**.

Si el m茅todo **`attachBaseContext`** est谩 definido en la subclase de Application, se llama primero, antes del m茅todo **`onCreate`**.

### Servicios

Los [Services](https://developer.android.com/guide/components/services) **funcionan en segundo plano sin una interfaz de usuario (UI).** Se utilizan para realizar **procesos de larga duraci贸n, incluso si el usuario comienza a utilizar una aplicaci贸n diferente**.

Hay una mir铆ada de formas en que se pueden iniciar y, por lo tanto, son un punto de entrada para aplicaciones. La forma predeterminada en que un servicio puede iniciarse como punto de entrada a una aplicaci贸n es a trav茅s de **Intents**.

Cuando se llama al m茅todo **`startService`** para iniciar un Servicio, se ejecuta el m茅todo **`onStart`** en el Servicio. Funcionar谩 indefinidamente hasta que se llame al m茅todo **`stopService`**. Si el servicio solo es necesario mientras el cliente est谩 conectado, el cliente debe "vincularse" a 茅l utilizando el m茅todo **`bindService`**.

Para un **servicio vinculado** (ver secci贸n anterior), los datos se pasar谩n al m茅todo **`onBind`**.

Por ejemplo, un servicio podr铆a reproducir m煤sica en segundo plano mientras el usuario est谩 en una aplicaci贸n diferente, o podr铆a obtener datos a trav茅s de la red sin bloquear la interacci贸n del usuario con una actividad.

Un **servicio puede ser exportado lo que permite a otros procesos en el dispositivo iniciar el servicio**. Por defecto los servicios no se exportan pero se puede configurar en el Manifiesto:
```markup
<service android:name=".ExampleExportedService" android:exported="true"/>
```
### Broadcast Receivers

Los Broadcasts pueden considerarse un sistema de mensajer铆a y **los receptores de broadcast son los oyentes**. Si una aplicaci贸n ha registrado un receptor para un broadcast espec铆fico, el c贸digo en ese receptor se ejecuta cuando el sistema env铆a el broadcast. Tenga en cuenta que en este caso **varias aplicaciones pueden recibir el mismo mensaje**.

Hay **2 formas** en que una aplicaci贸n puede **registrar un receptor**: en el **Manifiesto de la aplicaci贸n o registrado din谩micamente** en el c贸digo de la aplicaci贸n utilizando la llamada a la API **`registerReceiver`**. En el manifiesto, puedes limitar los broadcasts que aceptas mediante el **uso de permisos dentro del elemento receptor**. Cuando se define **din谩micamente**, puedes **pasar el permiso al m茅todo `registerReceiver`**.

En ambos casos, para registrar el receptor, se establecen los **filtros de intenci贸n para el receptor**. Estos filtros de intenci贸n son los broadcasts que deben activar el receptor.

Cuando se env铆an los broadcasts espec铆ficos para los que se ha registrado el receptor, se **ejecuta** **`onReceive`** en la clase BroadcastReceiver.

Una aplicaci贸n puede registrar un receptor para el mensaje de bater铆a baja, por ejemplo, y cambiar su comportamiento en base a esa informaci贸n.

Los Broadcasts pueden ser **asincr贸nicos** (todos los receptores lo reciben) o **sincr贸nicos** (el broadcast se recibe de manera ordenada en base a la prioridad establecida para recibirlo).

{% hint style="danger" %}
**Tenga en cuenta que cualquier aplicaci贸n puede establecerse como m谩xima prioridad para recibir un Broadcast.**
{% endhint %}

Para **examinar** el **c贸digo** implementado en un BroadcastReceiver, necesita buscar el m茅todo **`onReceive`** de la clase del receptor.\
Tenga en cuenta que **los Broadcasts Ordenados pueden descartar el Intent recibido o incluso modificarlo** utilizando uno de los m茅todos setter. Por lo tanto, los **receptores deben validar los datos**.

### Content Provider

Los Content Providers son la forma en que las **aplicaciones comparten datos estructurados**, como bases de datos relacionales. Por lo tanto, es muy importante usar **permisos** y establecer el nivel de protecci贸n adecuado para protegerlos.\
Los Content Providers pueden usar los atributos **`readPermission`** y **`writePermission`** para especificar qu茅 permisos debe tener una aplicaci贸n. **Estos permisos tienen prioridad sobre el atributo de permiso**.\
Adem谩s, tambi茅n pueden **permitir excepciones temporales** configurando **`grantUriPermission`** en verdadero y luego configurando los par谩metros apropiados en el elemento **`grant-uri-permission`** dentro del elemento del proveedor en el archivo del manifiesto.

El **`grant-uri-permission`** tiene tres atributos: path, pathPrefix y pathPattern:

* **path**: Permite especificar la ruta completa a excluir
* **pathPrefix**: Permite especificar el comienzo de la ruta
* **pathPattern**: Permite el uso de comodines y reemplazos simb贸licos para obtener un control m谩s granular.

Es **importante validar y sanear la entrada recibida** para evitar vulnerabilidades potenciales como la inyecci贸n SQL.

**Caracter铆sticas del Content Provider:**

* El componente Content Provider suministra datos de una aplicaci贸n a otras bajo solicitud.
* Puedes almacenar los datos en el sistema de archivos, una base de datos SQLite, en la web o cualquier otro lugar de almacenamiento persistente al que tu aplicaci贸n pueda acceder.
* A trav茅s del content provider, otras aplicaciones pueden consultar o incluso modificar los datos (si el content provider lo permite).
* Content Provider es 煤til en casos en que una aplicaci贸n quiere compartir datos con otra aplicaci贸n.
* Es muy similar a las bases de datos y tiene cuatro m茅todos.
* insert()
* update()
* delete()
* query()

**FileProvider**

Este es un tipo de Content Provider que **compartir谩 archivos** desde una carpeta. Puedes declarar un file provider as铆:
```markup
<provider android:name="androidx.core.content.FileProvider"
android:authorities="com.example.myapp.fileprovider"
android:grantUriPermissions="true" android:exported="false">
<meta-data
android:name="android.support.FILE_PROVIDER_PATHS"
android:resource="@xml/filepaths" />
</provider>
```
Tenga en cuenta el atributo **`android:exported`** porque si es **`true`**, las aplicaciones externas podr谩n acceder a las carpetas compartidas.\
Observe que la configuraci贸n `android:resource="@xml/filepaths"` est谩 indicando que el archivo _res/xml/filepaths.xml_ contiene la configuraci贸n de **qu茅 carpetas** este **FileProvider** va a **compartir**. Este es un ejemplo de c贸mo indicar compartir una carpeta en ese archivo:
```markup
<paths>
<files-path path="images/" name="myimages" />
</paths>
```
Compartir algo como **`path="."`** podr铆a ser **peligroso** incluso si el proveedor no est谩 exportado si hay otra vulnerabilidad en alguna parte del c贸digo que intent贸 acceder a este proveedor.\
Podr铆as **acceder** a una **imagen** dentro de esa carpeta con `content://com.example.myapp.fileprovider/myimages/default_image.jpg`

El elemento `<paths>` puede tener m煤ltiples hijos, cada uno especificando un directorio diferente para compartir. Adem谩s del elemento **`<files-path>`**, puedes usar el elemento **`<external-path>`** para compartir directorios en **almacenamiento externo**, y el elemento **`<cache-path>`** para compartir directorios en tu **directorio de cach茅 interno**.\
[Para m谩s informaci贸n sobre atributos espec铆ficos de proveedores de archivos, haz clic aqu铆.](https://developer.android.com/reference/androidx/core/content/FileProvider)

[M谩s informaci贸n sobre FileProviders aqu铆](https://developer.android.com/training/secure-file-sharing/setup-sharing).

## WebViews

Los WebViews son efectivamente **navegadores web** incrustados en aplicaciones Android.\
El contenido de los WebViews puede provenir de sitios remotos o ser archivos incluidos en la aplicaci贸n.\
Los WebViews son **vulnerables a las mismas vulnerabilidades que afectan a cualquier navegador web**. Sin embargo, hay algunas **configuraciones** que pueden ser 煤tiles para **limitar** la **superficie de ataque**.

Hay dos tipos de WebViews en Android:

* El **WebViewClient**, m谩s adecuado para la renderizaci贸n simple de HTML. Este no ejecutar谩 la funci贸n de alerta JS. Por lo tanto, las pruebas de XSS utilizando esa funci贸n ser谩n inv谩lidas.
* El **WebChrome** **client**, es un navegador Chrome.

Ten en cuenta que los **navegadores WebView no tienen acceso a las cookies del navegador nativo**.

Para cargar una URL o archivo es posible usar las funciones **`loadUrl`**, **`loadData`** o **`loadDataWithBaseURL`**. **Es importante acceder solo a URLs saneadas.**\
La seguridad de WebView se puede configurar a trav茅s del objeto **`WebSettings`**.\
Por ejemplo, la ejecuci贸n de c贸digo JS se puede deshabilitar usando el m茅todo **`setJavaScriptEnabled`** con el valor **`false`**. Esto eliminar谩 la posibilidad de un **XSS** y otras vulnerabilidades relacionadas con JS.

La funcionalidad "Bridge" de JavaScript **inyecta objetos Java en un WebView haci茅ndolos accesibles a JS**. Desde Android 4.2 los m茅todos deben estar anotados con **`@JavascriptInterface`** para ser accesibles a JavaScript.

Si se pasa **`true`** a **`setAllowContentAccess`**, **los WebViews podr谩n acceder a los Proveedores de Contenido** a trav茅s del esquema **`content://`**. Esto obviamente representa un riesgo de seguridad. Ten en cuenta que si se otorga este acceso, es muy importante **asegurarse** de que la URL **`content://`** sea **segura**.

Por defecto, los archivos locales pueden ser accedidos por WebViews a trav茅s de URLs file://, pero hay varias formas de prevenir este comportamiento:

* Pasar **`false`** a **`setAllowFileAccess`**, previene el acceso al sistema de archivos con la excepci贸n de los activos a trav茅s de `file:///android_asset` _y_ `file:///android_res`. Estas rutas deben usarse solo para datos no sensibles (como im谩genes), por lo que esto deber铆a ser seguro.
* El m茅todo **`setAllowFileAccess`** indica si una ruta de una URL `file://` deber铆a poder acceder al contenido de otras URLs del esquema de archivo.
* El m茅todo **`setAllowUniversalAccessFromFileURLs`** indica si una ruta de una URL `file://` deber铆a poder acceder al contenido de cualquier origen.

## Otros componentes de la aplicaci贸n

### **Firma de Aplicaciones**

* Android requiere que **todas las aplicaciones est茅n firmadas digitalmente con un certificado** antes de que puedan ser instaladas. Android utiliza este certificado para identificar al autor de una aplicaci贸n.
* Para ejecutar la aplicaci贸n en el dispositivo, debe estar firmada. Cuando se instala la aplicaci贸n en un dispositivo, el **gestor de paquetes verifica** si la aplicaci贸n ha sido correctamente firmada con el certificado en el archivo apk o no.
* La aplicaci贸n puede estar autofirmada o puede ser firmada a trav茅s de una CA.
* La firma de aplicaciones asegura que una aplicaci贸n no pueda acceder a otra aplicaci贸n excepto a trav茅s de IPC bien definido y tambi茅n que se pase sin modificaciones al dispositivo.

### **Verificaci贸n de Aplicaciones**

* Android 4.2 y versiones posteriores admiten la verificaci贸n de aplicaciones. Los usuarios pueden optar por habilitar "Verificar aplicaciones" y tener las aplicaciones evaluadas por un verificador de aplicaciones antes de la instalaci贸n.
* La verificaci贸n de aplicaciones puede alertar al usuario si intentan instalar una aplicaci贸n que podr铆a ser da帽ina; si una aplicaci贸n es especialmente mala, puede bloquear la instalaci贸n.

## Gesti贸n de Dispositivos M贸viles

MDM o Gesti贸n de Dispositivos M贸viles son suites de software que se utilizan para **asegurar el control y los requisitos de seguridad** sobre dispositivos m贸viles. Estas suites utilizan las caracter铆sticas denominadas API de Administraci贸n de Dispositivos y requieren que se instale una aplicaci贸n Android.

Generalmente, las soluciones MDM realizan funciones como imponer pol铆ticas de contrase帽as, forzar el cifrado de almacenamiento y habilitar el borrado remoto de datos del dispositivo.

<figure><img src="/.gitbook/assets/image (675).png" alt=""><figcaption></figcaption></figure>

Encuentra vulnerabilidades que importan m谩s para que puedas solucionarlas m谩s r谩pido. Intruder rastrea tu superficie de ataque, realiza escaneos proactivos de amenazas, encuentra problemas en toda tu pila tecnol贸gica, desde APIs hasta aplicaciones web y sistemas en la nube. [**Pru茅balo gratis**](https://www.intruder.io/?utm\_source=referral\&utm\_campaign=hacktricks) hoy.

{% embed url="https://www.intruder.io/?utm_campaign=hacktricks&utm_source=referral" %}

***

<details>

<summary><strong>Aprende hacking en AWS de cero a h茅roe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Otras formas de apoyar a HackTricks:

* Si quieres ver a tu **empresa anunciada en HackTricks** o **descargar HackTricks en PDF** Consulta los [**PLANES DE SUSCRIPCIN**](https://github.com/sponsors/carlospolop)!
* Consigue el [**merchandising oficial de PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubre [**La Familia PEASS**](https://opensea.io/collection/the-peass-family), nuestra colecci贸n de [**NFTs**](https://opensea.io/collection/the-peass-family) exclusivos
* **nete al**  [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s铆gueme** en **Twitter**  [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Comparte tus trucos de hacking enviando PRs a los repositorios de GitHub** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
