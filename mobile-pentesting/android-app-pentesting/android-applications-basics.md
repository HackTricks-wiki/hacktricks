# Fundamentos de Aplicaciones Android

<details>

<summary><strong>Aprende a hackear AWS desde cero hasta convertirte en un experto con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Otras formas de apoyar a HackTricks:

* Si deseas ver tu **empresa anunciada en HackTricks** o **descargar HackTricks en PDF** 隆Consulta los [**PLANES DE SUSCRIPCIN**](https://github.com/sponsors/carlospolop)!
* Obt茅n el [**oficial PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Descubre [**The PEASS Family**](https://opensea.io/collection/the-peass-family), nuestra colecci贸n exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **nete al**  [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s铆gueme** en **Twitter**  [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Comparte tus trucos de hacking enviando PRs a** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repositorios de github.

</details>

<figure><img src="/.gitbook/assets/image (675).png" alt=""><figcaption></figcaption></figure>

Encuentra vulnerabilidades que importan para que puedas solucionarlas m谩s r谩pido. Intruder rastrea tu superficie de ataque, ejecuta escaneos proactivos de amenazas, encuentra problemas en toda tu pila tecnol贸gica, desde APIs hasta aplicaciones web y sistemas en la nube. [**隆Pru茅balo gratis**](https://www.intruder.io/?utm\_source=referral\&utm\_campaign=hacktricks) hoy.

{% embed url="https://www.intruder.io/?utm_campaign=hacktricks&utm_source=referral" %}

***

## Modelo de Seguridad de Android

**Hay dos capas:**

* El **SO**, que mantiene las aplicaciones instaladas aisladas entre s铆.
* La **aplicaci贸n en s铆**, que permite a los desarrolladores **exponer ciertas funcionalidades** y configurar las capacidades de la aplicaci贸n.

### Separaci贸n de UID

**A cada aplicaci贸n se le asigna un ID de usuario espec铆fico**. Esto se hace durante la instalaci贸n de la aplicaci贸n para que **la aplicaci贸n solo pueda interactuar con archivos propiedad de su ID de usuario o archivos compartidos**. Por lo tanto, solo la aplicaci贸n en s铆, ciertos componentes del SO y el usuario root pueden acceder a los datos de las aplicaciones.

### Compartir UID

**Dos aplicaciones pueden configurarse para usar el mismo UID**. Esto puede ser 煤til para compartir informaci贸n, pero si una de ellas se ve comprometida, los datos de ambas aplicaciones se ver谩n comprometidos. Por eso este comportamiento es **desaconsejado**.\
**Para compartir el mismo UID, las aplicaciones deben definir el mismo valor `android:sharedUserId` en sus manifiestos.**

### Aislamiento

La **Sandbox de Aplicaciones Android** permite ejecutar **cada aplicaci贸n** como un **proceso separado bajo un ID de usuario separado**. Cada proceso tiene su propia m谩quina virtual, por lo que el c贸digo de una aplicaci贸n se ejecuta de forma aislada de otras aplicaciones.\
A partir de Android 5.0(L) se aplica **SELinux**. B谩sicamente, SELinux deneg贸 todas las interacciones de procesos y luego cre贸 pol铆ticas para **permitir solo las interacciones esperadas entre ellos**.

### Permisos

Cuando instalas una **aplicaci贸n y solicita permisos**, la aplicaci贸n est谩 pidiendo los permisos configurados en los elementos **`uses-permission`** en el archivo **AndroidManifest.xml**. El elemento **uses-permission** indica el nombre del permiso solicitado dentro del **atributo de nombre**. Tambi茅n tiene el atributo **maxSdkVersion** que deja de solicitar permisos en versiones superiores a la especificada.\
Ten en cuenta que las aplicaciones de Android no necesitan solicitar todos los permisos al principio, tambi茅n pueden **solicitar permisos din谩micamente** pero todos los permisos deben estar **declarados** en el **manifiesto**.

Cuando una aplicaci贸n expone funcionalidades puede limitar el **acceso solo a aplicaciones que tengan un permiso especificado**.\
Un elemento de permiso tiene tres atributos:

* El **nombre** del permiso
* El atributo **permission-group**, que permite agrupar permisos relacionados.
* El **nivel de protecci贸n** que indica c贸mo se otorgan los permisos. Hay cuatro tipos:
  * **Normal**: Se utiliza cuando no hay **amenazas conocidas** para la aplicaci贸n. No se requiere que el usuario lo apruebe.
  * **Peligroso**: Indica que el permiso otorga a la aplicaci贸n solicitante cierto **acceso elevado**. **Se solicita a los usuarios que los aprueben**.
  * **Firma**: Solo **las aplicaciones firmadas por el mismo certificado que la** que exporta el componente pueden recibir permiso. Este es el tipo de protecci贸n m谩s fuerte.
  * **FirmaOSystema**: Solo **las aplicaciones firmadas por el mismo certificado que la** que exporta el componente o **las aplicaciones que se ejecutan con acceso a nivel de sistema** pueden recibir permisos.

## Aplicaciones Preinstaladas

Estas aplicaciones generalmente se encuentran en los directorios **`/system/app`** o **`/system/priv-app`** y algunas de ellas est谩n **optimizadas** (es posible que ni siquiera encuentres el archivo `classes.dex`). Vale la pena verificar estas aplicaciones porque a veces est谩n **ejecut谩ndose con demasiados permisos** (como root).

* Las que se env铆an con el **ROM** de **AOSP** (Proyecto de C贸digo Abierto de Android)
* Agregadas por el **fabricante** del dispositivo
* Agregadas por el **proveedor** de telefon铆a celular (si se compr贸 a trav茅s de ellos)

## Rooting

Para obtener acceso root en un dispositivo Android f铆sico generalmente necesitas **explotar** 1 o 2 **vulnerabilidades** que suelen ser **espec铆ficas** para el **dispositivo** y la **versi贸n**.\
Una vez que la explotaci贸n ha funcionado, generalmente se copia el binario `su` de Linux en una ubicaci贸n especificada en la variable de entorno PATH del usuario como `/system/xbin`.

Una vez configurado el binario su, se utiliza otra aplicaci贸n de Android para interactuar con el binario `su` y **procesar solicitudes de acceso root** como **Superuser** y **SuperSU** (disponibles en Google Play Store).

{% hint style="danger" %}
Ten en cuenta que el proceso de rooting es muy peligroso y puede da帽ar gravemente el dispositivo
{% endhint %}

### ROMs

Es posible **reemplazar el SO instalando un firmware personalizado**. Haciendo esto es posible extender la utilidad de un dispositivo antiguo, evadir restricciones de software o acceder al c贸digo m谩s reciente de Android.\
**OmniROM** y **LineageOS** son dos de los firmwares m谩s populares para usar.

Ten en cuenta que **no siempre es necesario rootear el dispositivo** para instalar un firmware personalizado. **Algunos fabricantes permiten** el desbloqueo de sus cargadores de arranque de manera documentada y segura.

### Implicaciones

Una vez que un dispositivo est谩 rooteado, cualquier aplicaci贸n podr铆a solicitar acceso como root. Si una aplicaci贸n maliciosa lo obtiene, podr谩 acceder a casi todo y podr谩 da帽ar el tel茅fono.

## Fundamentos de Aplicaciones Android <a href="#2-android-application-fundamentals" id="2-android-application-fundamentals"></a>

- El formato de las aplicaciones de Android se denomina formato de archivo _APK_. Es esencialmente un **archivo ZIP** (al cambiar la extensi贸n del archivo a .zip, se pueden extraer y ver los contenidos).
- Contenidos de APK (No exhaustivo)
  - **AndroidManifest.xml**
  - resources.arsc/strings.xml
  - resources.arsc: contiene recursos precompilados, como XML binario.
  - res/xml/files\_paths.xml
  - META-INF/
    - 隆Aqu铆 se encuentra el Certificado!
  - **classes.dex**
    - Contiene bytecode Dalvik, que representa el c贸digo Java (o Kotlin) compilado que la aplicaci贸n ejecuta de forma predeterminada.
  - lib/
    - Contiene bibliotecas nativas, segregadas por arquitectura de CPU en subdirectorios.
      - `armeabi`: c贸digo para procesadores basados en ARM
      - `armeabi-v7a`: c贸digo para procesadores basados en ARMv7 y superiores
      - `x86`: c贸digo para procesadores X86
      - `mips`: c贸digo solo para procesadores MIPS
  - assets/
    - Almacena archivos diversos necesarios para la aplicaci贸n, potencialmente incluyendo bibliotecas nativas adicionales o archivos DEX, a veces utilizados por autores de malware para ocultar c贸digo adicional.
  - res/
    - Contiene recursos que no se compilan en resources.arsc

### **Dalvik y Smali**

- La mayor铆a de las aplicaciones de Android se desarrollan en Java o Kotlin (intercambiables en este contexto cuando se refieren a "Java").
- **En lugar de ejecutar c贸digo Java en la M谩quina Virtual Java** (JVM) como las aplicaciones de escritorio, Android compila Java en **c贸digo de bytes Dalvik Ejecutable (DEX)**.
- La traducci贸n de bytecode hist贸ricamente era manejada por la m谩quina virtual Dalvik, mientras que las versiones m谩s recientes de Android utilizan el Android Runtime (ART).
- El proceso de ingenier铆a inversa implica descompilar el bytecode DEX a un formato legible por humanos.

**Smali es la forma legible por humanos del bytecode Dalvik**. Aunque "Smali" y "baksmali" t茅cnicamente se refieren a las herramientas ensambladoras y desensambladoras, en el contexto de Android, "Smali" a menudo denota las instrucciones en s铆 mismas. **SMALI es similar al lenguaje ensamblador, sirviendo como intermediario entre el c贸digo fuente y el bytecode**.


<figure><img src="/.gitbook/assets/image (675).png" alt=""><figcaption></figcaption></figure>

Encuentra vulnerabilidades que importan para que puedas solucionarlas m谩s r谩pido. Intruder rastrea tu superficie de ataque, ejecuta escaneos proactivos de amenazas, encuentra problemas en toda tu pila tecnol贸gica, desde APIs hasta aplicaciones web y sistemas en la nube. [**隆Pru茅balo gratis**](https://www.intruder.io/?utm\_source=referral\&utm\_campaign=hacktricks) hoy.

***

## Intents

Los Intents son el principal medio por el cual las aplicaciones de Android se comunican entre sus componentes o con otras aplicaciones. Estos objetos de mensaje tambi茅n pueden transportar datos entre aplicaciones o componentes, similar a c贸mo se utilizan las solicitudes GET/POST en las comunicaciones HTTP.

Por lo tanto, un Intent es b谩sicamente un **mensaje que se pasa entre componentes**. Los Intents **pueden dirigirse** a componentes o aplicaciones espec铆ficas, **o pueden enviarse sin un destinatario espec铆fico**.\
Para simplificar, un Intent se puede usar para:

* Iniciar una Actividad, abriendo t铆picamente una interfaz de usuario para una aplicaci贸n
* Como transmisiones para informar al sistema y a las aplicaciones de cambios
* Para iniciar, detener y comunicarse con un servicio en segundo plano
* Para acceder a datos a trav茅s de ContentProviders
* Como devoluciones de llamada para manejar eventos

Una implementaci贸n incorrecta podr铆a resultar en fuga de datos, llamadas a funciones restringidas y manipulaci贸n del flujo del programa.

### Filtro de Intents

Un Filtro de Intent especifica los **tipos de Intent a los que una actividad, servicio o Receptor de Difusi贸n puede responder**. Especifica lo que una actividad o servicio puede hacer y qu茅 tipos de transmisiones puede manejar un Receptor. Permite que el componente correspondiente reciba Intents del tipo declarado. Los Filtros de Intent se definen t铆picamente a trav茅s del archivo AndroidManifest.xml. Para **Receptor de Difusi贸n** tambi茅n es posible definirlos en **c贸digo**. Un Filtro de Intent se define por su categor铆a, acci贸n y filtros de datos. Tambi茅n puede contener metadatos adicionales.

En Android, una actividad/servicio/proveedor de contenido/receptor de difusi贸n es **p煤blico** cuando **`exported`** se establece en **`true`** pero un componente tambi茅n es **p煤blico** si el **manifiesto especifica un filtro de Intent** para 茅l. Sin embargo,\
los desarrolladores pueden **hacer expl铆citamente privados los componentes** (independientemente de cualquier filtro de Intent)\
configurando el atributo \*\* `exported` en `false`\*\* para cada componente en el archivo de manifiesto.\
Los desarrolladores tambi茅n pueden establecer el atributo **`permission`** para **requerir un cierto permiso para acceder** al componente, restringiendo as铆 el acceso al componente.

### Intents Impl铆citos

Los Intents se crean program谩ticamente utilizando un constructor de Intent:
```java
Intent email = new Intent(Intent.ACTION_SEND, Uri.parse("mailto:"));
```
La **Acci贸n** del intent previamente declarado es **ACTION\_SEND** y el **Extra** es un **Uri** de mailto (el Extra es la informaci贸n adicional que el intent espera).

Este intent debe ser declarado dentro del manifiesto como en el siguiente ejemplo:
```markup
<activity android:name="ShareActivity">
<intent-filter>
<action android:name="android.intent.action.SEND" />
<category android:name="android.intent.category.DEFAULT" />
</intent-filter>
</activity>
```
Un intent-filter necesita coincidir con la **acci贸n**, **datos** y **categor铆a** para recibir un mensaje.

El proceso de "resoluci贸n de intenciones" determina qu茅 aplicaci贸n debe recibir cada mensaje. Este proceso considera el atributo de **prioridad**, que se puede establecer en la **declaraci贸n del intent-filter**, y **se seleccionar谩 el que tenga la prioridad m谩s alta**. Esta prioridad se puede establecer entre -1000 y 1000 y las aplicaciones pueden usar el valor `SYSTEM_HIGH_PRIORITY`. Si surge un **conflicto**, aparece una ventana de "selector" para que el **usuario pueda decidir**.

### Intenciones Expl铆citas

Una intenci贸n expl铆cita especifica el nombre de la clase a la que apunta:
```java
Intent downloadIntent = new (this, DownloadService.class):
```
En otras aplicaciones, para acceder al intent previamente declarado, puedes usar:
```java
Intent intent = new Intent();
intent.setClassName("com.other.app", "com.other.app.ServiceName");
context.startService(intent);
```
### Intenciones Pendientes

Estas permiten que otras aplicaciones **realicen acciones en nombre de tu aplicaci贸n**, utilizando la identidad y permisos de tu aplicaci贸n. Al construir una Intenci贸n Pendiente, se debe **especificar una intenci贸n y la acci贸n a realizar**. Si la **intenci贸n declarada no es expl铆cita** (no declara qu茅 intenci贸n puede llamarla), una **aplicaci贸n maliciosa podr铆a realizar la acci贸n declarada** en nombre de la aplicaci贸n v铆ctima. Adem谩s, **si no se especifica una acci贸n**, la aplicaci贸n maliciosa podr谩 realizar **cualquier acci贸n en nombre de la v铆ctima**.

### Intenciones de Difusi贸n

A diferencia de las intenciones anteriores, que solo son recibidas por una aplicaci贸n, las intenciones de difusi贸n **pueden ser recibidas por m煤ltiples aplicaciones**. Sin embargo, a partir de la versi贸n 14 de la API, es **posible especificar la aplicaci贸n que debe recibir** el mensaje utilizando Intent.setPackage.

Alternativamente, tambi茅n es posible **especificar un permiso al enviar la difusi贸n**. La aplicaci贸n receptora necesitar谩 tener ese permiso.

Existen **dos tipos** de Difusiones: **Normales** (asincr贸nicas) y **Ordenadas** (sincr贸nicas). El **orden** se basa en la **prioridad configurada dentro del receptor**. **Cada aplicaci贸n puede procesar, retransmitir o descartar la Difusi贸n**.

Es posible **enviar** una **difusi贸n** utilizando la funci贸n \*\*`sendBroadcast(intent, receiverPermission)` \*\* de la clase `Context`.\
Tambi茅n se puede utilizar la funci贸n **`sendBroadcast`** del **`LocalBroadCastManager`** para asegurar que el **mensaje nunca abandone la aplicaci贸n**. Al hacer esto, ni siquiera necesitar谩s exportar un componente receptor.

### Difusiones Persistentes

Este tipo de Difusiones **pueden ser accedidas mucho tiempo despu茅s de ser enviadas**.\
Fueron desaprobadas en el nivel de API 21 y se recomienda **no utilizarlas**.\
**Permiten que cualquier aplicaci贸n husmee los datos, pero tambi茅n los modifique**.

Si encuentras funciones que contienen la palabra "persistentes" como **`sendStickyBroadcast`** o **`sendStickyBroadcastAsUser`**, **verifica el impacto e intenta eliminarlas**.

## Enlaces Profundos / Esquemas de URL

**Los enlaces profundos permiten activar una Intenci贸n a trav茅s de una URL**. Una aplicaci贸n puede declarar un **esquema de URL** dentro de una actividad para que cada vez que el dispositivo Android intente **acceder a una direcci贸n utilizando ese esquema**, se llame a la actividad de la aplicaci贸n:

![](<../../.gitbook/assets/image (214).png>)

En este caso, el esquema es `myapp://` (tambi茅n se observa la **`categor铆a BROWSABLE`**)

Si dentro del `intent-filter` encuentras algo como esto:

![](<../../.gitbook/assets/image (263).png>)

Entonces, est谩 esperando algo como `http://www.example.com/gizmos`

Si encuentras algo como esto:

![](<../../.gitbook/assets/image (262).png>)

Significar谩 que est谩 esperando una URL que comience con `example://gizmos`\
En este caso, podr铆as intentar abusar de la funcionalidad creando una web con los siguientes payloads. Intentar谩 navegar a p谩ginas arbitrarias e intentar谩 ejecutar JS:
```markup
<a href="example://gizmos/https://google.com">click here</a>
<a href="example://gizmos/javascript://%250dalert(1)">click here</a>
```
Para encontrar el **c贸digo que se ejecutar谩 en la aplicaci贸n**, ve a la actividad llamada por el enlace profundo y busca la funci贸n **`onNewIntent`**.

![](<../../.gitbook/assets/image (436) (1) (1) (1).png>)

Aprende c贸mo [llamar a enlaces profundos sin usar p谩ginas HTML](./#exploiting-schemes-deep-links).

## AIDL - Android Interface Definition Language

El **Lenguaje de Definici贸n de Interfaz de Android** (AIDL) te permite definir la interfaz de programaci贸n en la que tanto el cliente como el servicio acuerdan para **comunicarse entre s铆 utilizando comunicaci贸n entre procesos** (IPC). En Android, **un proceso normalmente no puede acceder a la memoria de otro proceso**. Por lo tanto, para comunicarse, necesitan descomponer sus objetos en primitivas que el **sistema operativo** pueda entender y transmitir los objetos a trav茅s de ese l铆mite por ti. El c贸digo para realizar esa transmisi贸n es tedioso de escribir, por lo que Android lo maneja por ti con AIDL.

Los servicios que utilizan AIDL se conocen como **Servicios Vinculados**. En la clase del Servicio encontrar谩s el m茅todo **`onBind`**. Este es **donde comienza la interacci贸n**, por lo que es la parte inicial del c贸digo a revisar en busca de posibles vulnerabilidades.

Un servicio vinculado es el servidor en una interfaz cliente-servidor. **Permite a los componentes (como actividades) vincularse al servicio, enviar solicitudes, recibir respuestas y realizar comunicaci贸n entre procesos** (IPC). Un servicio vinculado normalmente solo est谩 activo mientras sirve a otro componente de la aplicaci贸n y no se ejecuta indefinidamente en segundo plano.

### Messenger

Un Messenger es otro tipo de mecanismo IPC. Dado que el **Messenger tambi茅n es un "Servicio Vinculado"**, los datos enviados desde la aplicaci贸n cliente tambi茅n se procesan a trav茅s del m茅todo `onBind`. Por lo tanto, la revisi贸n de c贸digo debe comenzar en este m茅todo y debes buscar la invocaci贸n de funcionalidades sensibles o el manejo inseguro de datos.

### Binder

Es raro encontrar una clase Binder invocada directamente, ya que es mucho m谩s f谩cil usar AIDL (que abstrae la clase Binder). Sin embargo, es bueno saber que **Binder es un controlador a nivel de kernel que mueve datos de la memoria de un proceso a la de otro** ([https://www.youtube.com/watch?v=O-UHvFjxwZ8](https://www.youtube.com/watch?v=O-UHvFjxwZ8)).

## Componentes

Estos incluyen: **Actividades, Servicios, Receptores de Difusi贸n y Proveedores**.

### Actividad de Inicio y otras actividades

Una **actividad de Android** es una pantalla de la interfaz de usuario de la aplicaci贸n de **Android**. De esa manera, una **actividad de Android** es muy similar a las ventanas en una aplicaci贸n de escritorio. Una aplicaci贸n de **Android** puede contener una o m谩s actividades, lo que significa una o m谩s pantallas.

La **actividad de inicio** es lo que la mayor铆a de la gente piensa como el **punto de entrada** a una aplicaci贸n de Android. La actividad de inicio es la actividad que se inicia cuando un usuario hace clic en el icono de una aplicaci贸n. Puedes determinar la actividad de inicio mirando el manifiesto de la aplicaci贸n. La actividad de inicio tendr谩 las siguientes intenciones MAIN y LAUNCHER listadas.

Ten en cuenta que no todas las aplicaciones tendr谩n una actividad de inicio, especialmente las aplicaciones sin interfaz de usuario. Ejemplos de aplicaciones sin interfaz de usuario (y por lo tanto sin actividad de inicio) son las aplicaciones preinstaladas que realizan servicios en segundo plano, como el correo de voz.
```markup
<activity android:name=".LauncherActivity">
<intent-filter>
<action android:name="android.intent.action.MAIN" />
<category android:name="android.intent.category.LAUNCHER" />
</intent-filter>
</activity>
```
Las actividades se pueden exportar permitiendo que otros procesos en el dispositivo inicien la actividad. Por defecto, no est谩n exportadas, pero puedes exportarlas configurando:
```markup
<service android:name=".ExampleExportedService" android:exported="true"/>
```
Ten en cuenta que la capacidad de **burlar las protecciones de actividad no siempre es una vulnerabilidad**, debes verificar a qu茅 datos has obtenido acceso.  
Adem谩s, **algunas actividades devuelven datos a un llamante**. En estos escenarios, debes buscar el m茅todo **`setResult`** y verificar los datos que se pasan al par谩metro Intent. **Si son datos sensibles, podr铆as tener una vulnerabilidad de fuga de informaci贸n** y ser explotable con aplicaciones capaces de comunicarse con la Actividad.

**El c贸digo de una actividad comienza con el m茅todo `onCreate`.**

### Subclase de Aplicaci贸n

Las aplicaciones de Android pueden definir una **subclase** de [Application](https://developer.android.com/reference/android/app/Application). Las aplicaciones pueden, pero no tienen que definir una subclase personalizada de Application. Si una aplicaci贸n de Android define una subclase de Application, **esta clase se instancia antes que cualquier otra clase en la aplicaci贸n**.

Si se define el m茅todo **`attachBaseContext`** en la subclase de Application, se llama primero, antes del m茅todo **`onCreate`**.

### Servicios

[Los servicios](https://developer.android.com/guide/components/services) **se ejecutan en segundo plano sin una interfaz de usuario**. Se utilizan para realizar **procesos de larga duraci贸n, incluso si el usuario comienza a usar una aplicaci贸n diferente**.

Hay una mir铆ada de formas en las que pueden iniciarse y, por lo tanto, son un punto de entrada para las aplicaciones. La forma predeterminada en que un servicio puede iniciarse como punto de entrada a una aplicaci贸n es a trav茅s de **Intents**.

Cuando se llama al m茅todo **`startService`** para iniciar un Servicio, se ejecuta el m茅todo **`onStart`** en el Servicio. Se ejecutar谩 indefinidamente hasta que se llame al m茅todo **`stopService`**. Si el servicio solo es necesario mientras el cliente est谩 conectado, el cliente deber铆a "vincularse" a 茅l usando el m茅todo **`bindService`**.

Para un **servicio vinculado** (ver secci贸n anterior), los datos se pasar谩n al m茅todo **`onBind`**.

Por ejemplo, un servicio podr铆a reproducir m煤sica en segundo plano mientras el usuario est谩 en una aplicaci贸n diferente, o podr铆a recuperar datos a trav茅s de la red sin bloquear la interacci贸n del usuario con una actividad.

Un **servicio puede ser exportado, lo que permite a otros procesos en el dispositivo iniciar el servicio**. Por defecto, los servicios no est谩n exportados, pero se pueden configurar en el Manifiesto:
```markup
<service android:name=".ExampleExportedService" android:exported="true"/>
```
### Receptores de difusi贸n

Las difusiones se pueden considerar un sistema de mensajer铆a y **los receptores de difusi贸n son los oyentes**. Si una aplicaci贸n ha registrado un receptor para una difusi贸n espec铆fica, el c贸digo en ese receptor se ejecuta cuando el sistema env铆a la difusi贸n. Tenga en cuenta que en este caso **varias aplicaciones pueden recibir el mismo mensaje**.

Hay **2 formas** en que una aplicaci贸n puede **registrar un receptor**: en el **Manifiesto de la aplicaci贸n o registrado din谩micamente** en el c贸digo de la aplicaci贸n utilizando la llamada a la API **`registerReceiver`**. En el manifiesto, puede limitar las difusiones que acepta a trav茅s del **uso de permisos dentro del elemento receptor**. Cuando se define **din谩micamente**, puede **pasar el permiso al m茅todo `registerReceiver`**.

En ambos casos, para registrar el receptor, se establecen los **filtros de intenci贸n para el receptor**. Estos filtros de intenci贸n son las difusiones que deben activar el receptor.

Cuando se env铆an las difusiones espec铆ficas para las que se ha registrado el receptor, se ejecuta **`onReceive`** en la clase BroadcastReceiver.

Una aplicaci贸n puede registrar un receptor para el mensaje de bater铆a baja, por ejemplo, y cambiar su comportamiento en funci贸n de esa informaci贸n.

La difusi贸n puede ser **as铆ncrona** (cada receptor la recibe) o **sincr贸nica** (la difusi贸n se recibe de manera ordenada seg煤n la prioridad establecida para recibirla).

{% hint style="danger" %}
**Tenga en cuenta que cualquier aplicaci贸n puede establecerse como m谩xima prioridad para recibir una difusi贸n.**
{% endhint %}

Para **examinar** el **c贸digo** implementado en un Receptor de difusi贸n, es necesario buscar el m茅todo **`onReceive`** de la clase del receptor.\
Tenga en cuenta que las **Difusiones ordenadas pueden descartar la Intenci贸n recibida o incluso modificarla** utilizando uno de los m茅todos setter. Por lo tanto, los **receptores deben validar los datos**.

### Proveedor de contenido

Los Proveedores de contenido son la forma en que las **aplicaciones comparten datos estructurados**, como bases de datos relacionales. Por lo tanto, es muy importante utilizar **permisos** y establecer el nivel de protecci贸n adecuado para protegerlos.\
Los Proveedores de contenido pueden utilizar los atributos **`readPermission`** y **`writePermission`** para especificar qu茅 permisos debe tener una aplicaci贸n. **Estos permisos tienen prioridad sobre el atributo de permiso**.\
Adem谩s, tambi茅n pueden **permitir excepciones temporales** configurando el **`grantUriPermission`** como verdadero y luego configurando los par谩metros apropiados en el elemento **`grant-uri-permission`** dentro del elemento proveedor dentro del archivo de manifiesto.

El **`grant-uri-permission`** tiene tres atributos: path, pathPrefix y pathPattern:

* **path**: Permite especificar la ruta completa a excluir
* **pathPrefix**: Permite especificar el inicio de la ruta
* **pathPattern**: Permite el uso de comodines y reemplazos simb贸licos para obtener un control m谩s granular.

Es **importante validar y sanear la entrada recibida** para evitar posibles vulnerabilidades como la inyecci贸n SQL.

**Caracter铆sticas del Proveedor de contenido:**

* El componente Proveedor de contenido suministra datos de una aplicaci贸n a otras bajo demanda.
* Puede almacenar los datos en el sistema de archivos, una base de datos SQLite, en la web, o en cualquier otra ubicaci贸n de almacenamiento persistente a la que pueda acceder su aplicaci贸n.
* A trav茅s del proveedor de contenido, otras aplicaciones pueden consultar o incluso modificar los datos (si el proveedor de contenido lo permite).
* El Proveedor de contenido es 煤til en casos en los que una aplicaci贸n desea compartir datos con otra aplicaci贸n.
* Es muy similar a las bases de datos y tiene cuatro m茅todos.
  * insert()
  * update()
  * delete()
  * query()

**FileProvider**

Este es un tipo de Proveedor de contenido que **compartir谩 archivos** desde una carpeta. Puede declarar un proveedor de archivos de la siguiente manera:
```markup
<provider android:name="androidx.core.content.FileProvider"
android:authorities="com.example.myapp.fileprovider"
android:grantUriPermissions="true" android:exported="false">
<meta-data
android:name="android.support.FILE_PROVIDER_PATHS"
android:resource="@xml/filepaths" />
</provider>
```
Toma nota del atributo **`android:exported`** porque si est谩 **`true`** las aplicaciones externas podr谩n acceder a las carpetas compartidas.\
Ten en cuenta que la configuraci贸n `android:resource="@xml/filepaths"` indica que el archivo _res/xml/filepaths.xml_ contiene la configuraci贸n de **qu茅 carpetas** va a **compartir** este **FileProvider**. Este es un ejemplo de c贸mo indicar que se comparta una carpeta en ese archivo:
```markup
<paths>
<files-path path="images/" name="myimages" />
</paths>
```
Compartir algo como **`path="."`** podr铆a ser **peligroso** incluso si el proveedor no est谩 exportado si hay otra vulnerabilidad en alguna parte del c贸digo que intenta acceder a este proveedor.\
Podr铆as **acceder** a una **imagen** dentro de esa carpeta con `content://com.example.myapp.fileprovider/myimages/default_image.jpg`

El elemento `<paths>` puede tener varios hijos, cada uno especificando un directorio diferente para compartir. Adem谩s del elemento **`<files-path>`**, puedes usar el elemento **`<external-path>`** para compartir directorios en el **almacenamiento externo**, y el elemento **`<cache-path>`** para compartir directorios en tu **directorio de cach茅 interno**.\
[Para obtener m谩s informaci贸n sobre los atributos espec铆ficos de los proveedores de archivos, ve aqu铆.](https://developer.android.com/reference/androidx/core/content/FileProvider)

[M谩s informaci贸n sobre FileProviders aqu铆](https://developer.android.com/training/secure-file-sharing/setup-sharing).

## WebViews

Los WebViews son efectivamente **navegadores web** integrados en las aplicaciones de Android.\
El contenido de los WebViews puede provenir de sitios remotos o de archivos incluidos en la aplicaci贸n.\
Los WebViews son **vulnerables a las mismas vulnerabilidades que afectan a cualquier navegador web**. Sin embargo, hay algunas **configuraciones** que pueden ser 煤tiles para **limitar** la **superficie de ataque**.

Hay dos tipos de WebViews en Android:

* El **WebViewClient**, m谩s adecuado para la representaci贸n de HTML simple. Esto no ejecutar谩 la funci贸n de alerta JS. Por lo tanto, las pruebas de XSS que utilizan esa funci贸n ser谩n inv谩lidas.
* El **cliente WebChrome**, es un navegador Chrome.

Ten en cuenta que los **navegadores WebView no tienen acceso a las cookies del navegador nativo**.

Para cargar una URL o un archivo, es posible utilizar las funciones **`loadUrl`**, **`loadData`** o **`loadDataWithBaseURL`**. **Es importante acceder solo a URLs sanitizadas.**\
La seguridad de WebView se puede configurar a trav茅s del objeto **`WebSettings`**.\
Por ejemplo, la ejecuci贸n de c贸digo JS se puede deshabilitar utilizando el m茅todo **`setJavaScriptEnabled`** con el valor **`false`**. Esto **eliminar谩** la posibilidad de un **XSS** y otras vulnerabilidades relacionadas con JS.

La funcionalidad de JavaScript "**Bridge**" **inyecta objetos Java en un WebView haci茅ndolos accesibles para JS**. A partir de Android 4.2, los m茅todos deben estar anotados con **`@JavascriptInterface`** para ser accesibles desde JavaScript.

Si se pasa **`true`** a **`setAllowContentAccess`**, los **WebViews podr谩n acceder a los Proveedores de Contenido** a trav茅s del esquema **`content://`**. Esto obviamente plantea un riesgo de seguridad. Ten en cuenta que si se otorga este acceso, es muy importante **asegurarse** de que la URL de **`content://`** sea **segura**.

Por defecto, los archivos locales pueden ser accedidos por los WebViews a trav茅s de URLs file://, pero hay varias formas de evitar este comportamiento:

* Pasar **`false`** a **`setAllowFileAccess`**, evita el acceso al sistema de archivos con la excepci贸n de los activos a trav茅s de `file:///android_asset` _y_ `file:///android_res`. Estas rutas deben usarse solo para datos no sensibles (como im谩genes) por lo que esto deber铆a ser seguro.
* El m茅todo **`setAllowFileAccess`** indica si una ruta de una URL `file://` deber铆a poder acceder al contenido de otras URLs de esquema de archivo.
* El m茅todo **`setAllowUniversalAccessFromFileURLs`** indica si una ruta de una URL `file://` deber铆a poder acceder al contenido desde cualquier origen.

## Otros componentes de la aplicaci贸n

### **Firma de la aplicaci贸n**

* Android requiere que **todas las aplicaciones est茅n firmadas digitalmente con un certificado** antes de que puedan ser instaladas. Android utiliza este certificado para identificar al autor de una aplicaci贸n.
* Para ejecutar la aplicaci贸n en el dispositivo, debe estar firmada. Cuando la aplicaci贸n se instala en un dispositivo, el **gestor de paquetes verifica** si la aplicaci贸n ha sido correctamente firmada con el certificado en el archivo apk o no.
* La aplicaci贸n puede ser auto-firmada o firmada a trav茅s de una CA.
* La firma de la aplicaci贸n garantiza que una aplicaci贸n no pueda acceder a ninguna otra aplicaci贸n excepto a trav茅s de IPC bien definidos y tambi茅n que se pase sin modificaciones al dispositivo.

### **Verificaci贸n de la aplicaci贸n**

* Android 4.2 y versiones posteriores admiten la verificaci贸n de aplicaciones. Los usuarios pueden optar por habilitar "Verificar aplicaciones" y hacer que las aplicaciones sean evaluadas por un verificador de aplicaciones antes de la instalaci贸n.
* La verificaci贸n de aplicaciones puede alertar al usuario si intentan instalar una aplicaci贸n que podr铆a ser da帽ina; si una aplicaci贸n es especialmente mala, puede bloquear la instalaci贸n.

## Gesti贸n de dispositivos m贸viles

MDM o Gesti贸n de Dispositivos M贸viles son suites de software que se utilizan para **garantizar requisitos de control y seguridad** sobre dispositivos m贸viles. Estas suites utilizan las funciones denominadas API de Administraci贸n de Dispositivos y requieren que se instale una aplicaci贸n de Android.

Generalmente, las soluciones MDM realizan funciones como hacer cumplir pol铆ticas de contrase帽as, forzar el cifrado de almacenamiento y habilitar el borrado remoto de datos del dispositivo.

<figure><img src="/.gitbook/assets/image (675).png" alt=""><figcaption></figcaption></figure>

Encuentra las vulnerabilidades que m谩s importan para que puedas solucionarlas m谩s r谩pido. Intruder rastrea tu superficie de ataque, ejecuta escaneos proactivos de amenazas, encuentra problemas en toda tu pila tecnol贸gica, desde APIs hasta aplicaciones web y sistemas en la nube. [**Pru茅balo gratis**](https://www.intruder.io/?utm\_source=referral\&utm\_campaign=hacktricks) hoy.

{% embed url="https://www.intruder.io/?utm_campaign=hacktricks&utm_source=referral" %}

***


<details>

<summary><strong>Aprende a hackear AWS desde cero hasta experto con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Otras formas de apoyar a HackTricks:

* Si quieres ver tu **empresa anunciada en HackTricks** o **descargar HackTricks en PDF** 隆Consulta los [**PLANES DE SUSCRIPCIN**](https://github.com/sponsors/carlospolop)!
* Obt茅n la [**merchandising oficial de PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubre [**The PEASS Family**](https://opensea.io/collection/the-peass-family), nuestra colecci贸n exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **nete al**  [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s铆gueme** en **Twitter**  [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Comparte tus trucos de hacking enviando PRs a los repositorios de** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
